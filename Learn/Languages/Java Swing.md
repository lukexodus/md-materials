## Components

### Visual Guide

**Basic Controls**

|                                                                                                                                                                                          |                                                                                                                                                                                                                  |                                                                                                                                                                                                                   |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ![Button image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-ButtonM.png)<br><br>[JButton](http://docs.oracle.com/javase/tutorial/uiswing/components/button.html)     | ![CheckBox image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-CheckBoxM.png)<br><br>[JCheckBox](http://docs.oracle.com/javase/tutorial/uiswing/components/button.html#checkbox)              | ![Combo box image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-ComboBoxM.png)<br><br>[JComboBox](http://docs.oracle.com/javase/tutorial/uiswing/components/combobox.html)                     |
|                                                                                                                                                                                          |                                                                                                                                                                                                                  |                                                                                                                                                                                                                   |
| ![Menu image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-MenuM.png)<br><br>[JMenu](http://docs.oracle.com/javase/tutorial/uiswing/components/menu.html)             | ![Radio Button image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-RadioButtonM.png)<br><br>[JRadioButton](http://docs.oracle.com/javase/tutorial/uiswing/components/button.html#radiobutton) | ![Slider image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-SliderM.png)<br><br>[JSlider](http://docs.oracle.com/javase/tutorial/uiswing/components/slider.html)                              |
|                                                                                                                                                                                          |                                                                                                                                                                                                                  |                                                                                                                                                                                                                   |
| ![Spinner image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-SpinnerM.png)<br><br>[JSpinner](http://docs.oracle.com/javase/tutorial/uiswing/components/spinner.html) | ![Text field image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-TextFieldM.png)<br><br>[JTextField](http://docs.oracle.com/javase/tutorial/uiswing/components/textfield.html)                | ![Password field image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-PasswordFieldM.png)<br><br>[JPasswordField](http://docs.oracle.com/javase/tutorial/uiswing/components/passwordfield.html) |
| ![List image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-ListM.png)<br><br>[JList](http://docs.oracle.com/javase/tutorial/uiswing/components/list.html)             |                                                                                                                                                                                                                  |                                                                                                                                                                                                                   |

**Interactive Displays of Highly Formatted Information**

|                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                              |     |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --- |
| ![Color Chooser Image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-ColorChooserM.png)<br><br>[JColorChooser](http://docs.oracle.com/javase/tutorial/uiswing/components/colorchooser.html) | ![Text pane Image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-TextPaneM.png)<br><br>[JEditorPane](http://docs.oracle.com/javase/tutorial/uiswing/components/editorpane.html) and [JTextPane](http://docs.oracle.com/javase/tutorial/uiswing/components/editorpane.html) |     |
|                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                              |     |
| ![File Chooser Image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-FileChooserM.png)<br><br>[JFileChooser](http://docs.oracle.com/javase/tutorial/uiswing/components/filechooser.html)     | ![Tree Image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-TreeM.png)<br><br>[JTree](http://docs.oracle.com/javase/tutorial/uiswing/components/tree.html)                                                                                                                 |     |
| ![Table Image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-TableM.png)<br><br>[JTable](http://docs.oracle.com/javase/tutorial/uiswing/components/table.html)                              | ![Text Image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-TextAreaM.png)<br><br>[JTextArea](http://docs.oracle.com/javase/tutorial/uiswing/components/text.html)                                                                                                         |     |
**Uneditable Information Displays**

|                                                                                                                                                                                                  |                                                                                                                                                                                                        |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| ![Label image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-LabelM.png)<br><br>[JLabel](http://docs.oracle.com/javase/tutorial/uiswing/components/label.html)                 | ![Progress bar image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-ProgressBarM.png)<br><br>[JProgressBar](http://docs.oracle.com/javase/tutorial/uiswing/components/progress.html) |
| ![Separator image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-SeparatorM.png)<br><br>[JSeparator](http://docs.oracle.com/javase/tutorial/uiswing/components/separator.html) | ![Tool tip image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-ToolTipM.png)<br><br>[JToolTip](http://docs.oracle.com/javase/tutorial/uiswing/components/tooltip.html)              |

**Top-Level Containers**

|                                                                                                                                                                                     |                                                                                                                                                                                      |                                                                                                                                                                                  |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ![Applet image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-Applet.png)<br><br>[JApplet](http://docs.oracle.com/javase/tutorial/uiswing/components/applet.html) | ![Dialog image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-DialogM.png)<br><br>[JDialog](http://docs.oracle.com/javase/tutorial/uiswing/components/dialog.html) | ![Frame image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-FrameM.png)<br><br>[JFrame](http://docs.oracle.com/javase/tutorial/uiswing/components/frame.html) |

**General-Purpose Containers**

|                                                                                                                                                                                                   |                                                                                                                                                                                                       |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ![Panel image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-PanelM.png)<br><br>[JPanel](http://docs.oracle.com/javase/tutorial/uiswing/components/panel.html)                  | ![Scroll pane image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-ScrollPaneM.png)<br><br>[JScrollPane](http://docs.oracle.com/javase/tutorial/uiswing/components/scrollpane.html) |
|                                                                                                                                                                                                   |                                                                                                                                                                                                       |
| ![Split pane image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-SplitPaneM.png)<br><br>[JSplitPane](http://docs.oracle.com/javase/tutorial/uiswing/components/splitpane.html) | ![Tabbed pane image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-TabbedPaneM.png)<br><br>[JTabbedPane](http://docs.oracle.com/javase/tutorial/uiswing/components/tabbedpane.html) |
|                                                                                                                                                                                                   |                                                                                                                                                                                                       |
| ![ToolBar image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-ToolBarM.png)<br><br>[JToolBar](http://docs.oracle.com/javase/tutorial/uiswing/components/toolbar.html)          |                                                                                                                                                                                                       |

**Special-Purpose Containers**

|                                                                                                                                                                                                                   |                                                                                                                                                                                                           |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ![Internal frame image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-InternalFrameM.png)<br><br>[JInternalFrame](http://docs.oracle.com/javase/tutorial/uiswing/components/internalframe.html) | ![Layered pane image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-LayeredPaneM.png)<br><br>[JLayeredPane](http://docs.oracle.com/javase/tutorial/uiswing/components/layeredpane.html) |
|                                                                                                                                                                                                                   |                                                                                                                                                                                                           |
| ![Root pane image](https://web.mit.edu/6.005/www/sp14/psets/ps4/java-6-tutorial/ui-rootPane.gif)<br><br>[Root pane](http://docs.oracle.com/javase/tutorial/uiswing/components/rootpane.html)                      |                                                                                                                                                                                                           |


### JFrame

`JFrame` is a class in Java Swing that represents a top-level window with a border and a title bar. It is commonly used as the main container for GUI applications in Swing. `JFrame` provides methods and properties for creating, managing, and customizing windows in Swing applications.

Here are some key features and functionalities of `JFrame`:

1. **Creating a JFrame**:
   You can create an instance of `JFrame` using its constructor. By default, a `JFrame` has no content pane and no layout manager.

   ```java
   JFrame frame = new JFrame("My Frame");
   ```

2. **Setting Size and Location**:
   You can set the size and location of the frame using methods such as `setSize()` and `setLocation()`.

   ```java
   frame.setSize(500, 300); // Set size to 500x300 pixels
   frame.setLocationRelativeTo(null); // Center the frame on the screen
   ```

3. **Setting Layout Manager**:
   You can set a layout manager for the content pane of the frame using the `setLayout()` method. Common layout managers include `FlowLayout`, `BorderLayout`, `GridLayout`, etc.

   ```java
   frame.setLayout(new BorderLayout());
   ```

4. **Adding Components**:
   You can add components (e.g., buttons, labels, panels) to the content pane of the frame using the `add()` method.

   ```java
   JButton button = new JButton("Click Me");
   frame.add(button, BorderLayout.CENTER); // Add button to the center of the frame
   ```

5. **Displaying the Frame**:
   You can make the frame visible using the `setVisible()` method.

   ```java
   frame.setVisible(true);
   ```

6. **Closing Behavior**:
	   You can specify what happens when the user closes the frame using the `setDefaultCloseOperation()` method. Common options include `EXIT_ON_CLOSE`, `DISPOSE_ON_CLOSE`, `HIDE_ON_CLOSE` etc.

   ```java
   frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
   ```

7. **Adding Menus**:
   You can add menus and menu items to the frame using `JMenuBar`, `JMenu`, and `JMenuItem`.

   ```java
   JMenuBar menuBar = new JMenuBar();
   JMenu fileMenu = new JMenu("File");
   JMenuItem exitMenuItem = new JMenuItem("Exit");
   fileMenu.add(exitMenuItem);
   menuBar.add(fileMenu);
   frame.setJMenuBar(menuBar);
   ```

8. **Customizing Appearance**:
   You can customize the appearance of the frame by setting properties such as title, icon, background color, etc.

   ```java
   frame.setTitle("My Frame");
   frame.setIconImage(iconImage);
   frame.getContentPane().setBackground(Color.WHITE);
   ```

`JFrame` provides a flexible and powerful way to create and manage windows in Swing applications. It serves as the main entry point for building GUIs in Java Swing.

### JPanel

In Swing, `JPanel` is a container that is used to hold and organize other components. It is a lightweight component that can be added to a `JFrame`, another `JPanel`, or any other container.

Here are some key points about `JPanel`:

1. **Constructor**:
   - `JPanel()`: Creates a new panel with a default flow layout.
   - `JPanel(LayoutManager lm)`: Creates a panel that uses the layout manager specified by `lm`. The panel is double-buffered.
   - `JPanel(boolean doubleBuffered)`: Creates a panel that uses flow layout. If `doubleBuffered` is `true`, the panel is double-buffered. If `doubleBuffered` is `false`, it is not double-buffered.
   - `JPanel(LayoutManager lm, boolean doubleBuffered)`: Creates a panel that uses the layout specified by `lm`. If `doubleBuffered` is `true`, the panel is double-buffered. If `doubleBuffered` is `false`, it is not double-buffered.
   - [[#Explanation of Double Buffering]]

2. **Layout Management**:
   - By default, a `JPanel` uses a `FlowLayout`, which arranges components from left to right in a row. However, you can set a different layout manager using the `setLayout(LayoutManager layout)` method.
   - Common layout managers used with `JPanel` include `FlowLayout`, `BorderLayout`, `GridLayout`, `GridBagLayout`, and `BoxLayout`.

3. **Adding Components**:
   - You can add components to a `JPanel` using the `add(Component comp)` method.
   - Components are laid out according to the panel's layout manager.

4. **Background Color**:
   - You can set the background color of a `JPanel` using the `setBackground(Color bg)` method.

5. **Border**:
   - You can set a border around the panel using the `setBorder(Border border)` method.

6. **Event Handling**:
   - `JPanel` itself does not generate any events. Event handling is typically done by the components contained within the panel.

7. **Customization**:
   - `JPanel` provides various methods to customize its appearance and behavior, such as `setOpaque(boolean isOpaque)` to control whether the panel is opaque or transparent, and `setEnabled(boolean enabled)` to enable or disable user interaction with the panel. `isOpaque()` returns true if the component is opaque and false if it is transparent.

8. **Nested Panels**:
   - You can nest `JPanels` within each other to create complex layouts. Each panel can have its own layout manager and contain its own set of components.

**Use a Custom JPanel as the Content Pane**

Absolutely, customizing the content pane of a `JFrame` by using a custom `JPanel` offers flexibility and allows you to create a more tailored user interface. Here's a breakdown of the steps involved:

1. **Create a Custom JPanel**: Define a class that extends `JPanel`. This custom panel will serve as the content pane for the `JFrame`.

2. **Populate the Custom Panel**: Inside the custom panel class, add the desired components and layout arrangement to create the user interface.

3. **Set the Content Pane of the JFrame**: Use the `setContentPane()` method of the `JFrame` to set the custom panel as the content pane.

Here's a simplified example:

```java
import javax.swing.*;
import java.awt.*;

public class CustomPanel extends JPanel {
    public CustomPanel() {
        // Add components to the custom panel
        JLabel label = new JLabel("Hello, Custom Panel!");
        add(label);
        
        // Set layout manager if needed
        setLayout(new FlowLayout());
    }
}

public class CustomContentPaneExample {
    public static void main(String[] args) {
        // Create a JFrame
        JFrame frame = new JFrame("Custom Content Pane Example");

        // Create a custom panel
        CustomPanel customPanel = new CustomPanel();

        // Set the custom panel as the content pane of the JFrame
        frame.setContentPane(customPanel);

        // Set frame properties
        frame.setSize(300, 200);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}
```

### JLabel

A `JLabel` in Java Swing is a component used to display text or an image. It is commonly used to provide information or instructions to the user in a graphical user interface (GUI) application. Here's how you can use `JLabel`:

1. **Basic Usage**:
   You can create a `JLabel` by instantiating the class and passing the text you want to display as an argument to the constructor.

   ```java
   JLabel label = new JLabel("Hello, World!");
   ```

2. **Adding to a Container**:
   Once you've created a `JLabel`, you can add it to a container (e.g., a `JFrame`, `JPanel`, etc.) using the `add()` method.

   ```java
   JPanel panel = new JPanel();
   panel.add(label);
   ```

3. **Setting Text**:
   You can change the text displayed by the `JLabel` using the `setText()` method.

   ```java
   label.setText("New Text");
   ```

4. **Styling**:
   You can customize the appearance of the `JLabel` by setting properties such as font, foreground color, background color, alignment, etc.

   ```java
   label.setFont(new Font("Arial", Font.BOLD, 16));
   label.setForeground(Color.BLUE);
   ```

5. **Displaying Images**:
   `JLabel` can also display images. You can use the `setIcon()` method to set an image as the label's icon.

   ```java
   ImageIcon icon = new ImageIcon("image.png");
   label.setIcon(icon);
   ```

Here's a complete example demonstrating the usage of `JLabel`:

```java
import javax.swing.*;
import java.awt.*;

public class JLabelExample {
    public static void main(String[] args) {
        // Create a JFrame
        JFrame frame = new JFrame("JLabel Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(300, 200);
        frame.setLayout(new FlowLayout());

        // Create a JLabel with text
        JLabel label1 = new JLabel("Hello, World!");

        // Create a JLabel with an icon
        ImageIcon icon = new ImageIcon("image.png");
        JLabel label2 = new JLabel(icon);

        // Customize label properties
        label1.setFont(new Font("Arial", Font.BOLD, 16));
        label1.setForeground(Color.BLUE);

        // Add labels to the frame
        frame.add(label1);
        frame.add(label2);

        // Make the frame visible
        frame.setVisible(true);
    }
}
```

**Different Ways to Construct a JLabel**

Here are some different ways of creating a `JLabel` using its various constructors:

1. **Default Constructor**:
   ```java
   JLabel label = new JLabel();
   ```

2. **Text Constructor**:
   ```java
   JLabel label = new JLabel("Hello, World!");
   ```

3. **Icon Constructor**:
   ```java
   ImageIcon icon = new ImageIcon("path/to/icon.png");
   JLabel label = new JLabel(icon);
   ```

4. **Text and Alignment Constructor**:
   ```java
   JLabel label = new JLabel("Hello, World!", SwingConstants.CENTER);
   ```
   - The `SwingConstants` interface defines several constants that relate to Swing:
	   - `SwingConstants.LEFT`
	   - `SwingConstants.RIGHT`
	   - `SwingConstants.CENTER`
	   - `SwingConstants.TRAILING`
	   - `SwingConstants.LEADING`
   - You can call the setHorizontalAlignment() method on the label after it has been constructed.

5. **Icon and Alignment Constructor**:
   ```java
   ImageIcon icon = new ImageIcon("path/to/icon.png");
   JLabel label = new JLabel(icon, SwingConstants.CENTER);
   ```

6. **Text, Icon, and Alignment Constructor**:
   ```java
   ImageIcon icon = new ImageIcon("path/to/icon.png");
   JLabel label = new JLabel("Hello, World!", icon, SwingConstants.CENTER);
   ```

7. **Text, Icon, and Horizontal Alignment, and Vertical Alignment Constructor**:
   ```java
   ImageIcon icon = new ImageIcon("path/to/icon.png");
   JLabel label = new JLabel("Hello, World!", icon, SwingConstants.CENTER);
   label.setVerticalAlignment(SwingConstants.TOP);
   ```
   - `SwingConstants.TOP`
   - `SwingConstants.CENTER`
   - `SwingConstants.BOTTOM`

**Note**:
In general, label alignment only affects those labels that are sized larger than their contents. One way this can occur is when using a layout manager, such as `GridLayout`, that automatically adjusts the size of a label to fit an available space. Another way it can happen is when you specify a preferred component size that is larger than that needed to bold its contents.

**Label Sizing**

You can explicitly set the preferred size, minimum size, and maximum size of a component in Java Swing using methods provided by the `JComponent` class. Here's how you can do it:

1. **Setting Preferred Size**:
   ```java
	JLabel label = new JLabel("Hello, World!");
	
	// Set preferred size for the label
	label.setPreferredSize(new Dimension(200, 100));
   ```
   In this example, we set the preferred size of the `JLabel` to be 200 pixels wide and 100 pixels high using the `setPreferredSize` method.

2. **Setting Minimum Size**:
   ```java
   // Set minimum size for the label
   label.setMinimumSize(new Dimension(100, 50));
   ```

3. **Setting Maximum Size**:
   ```java
   // Set maximum size for the label
   label.setMaximumSize(new Dimension(300, 150));
   ```

These methods allow you to specify the dimensions for a component, which serve as suggestions for layout managers. However, some layout managers may choose to ignore these dimensions based on their own rules.

**Text and Icon Positioning**

To change the position of the text relative to the image in a `JLabel` that contains both a string and an image, you can use the `setVerticalTextPosition` and `setHorizontalTextPosition` methods. Here's how you can do it:

```java
	// Create a label with text and an image
	ImageIcon icon = new ImageIcon("path/to/image.png");
	JLabel label = new JLabel("Hello, World!", icon, SwingConstants.CENTER);

	// Set the vertical text position to TOP (above the icon)
	label.setVerticalTextPosition(SwingConstants.TOP);

	// Set the horizontal text position to CENTER (centered horizontally)
	label.setHorizontalTextPosition(SwingConstants.CENTER);
```

**Enabling, DIsabling, and Disabled Icon**

To enable or disable a label in Java Swing, you can use the `setEnabled` method inherited from `JComponent`. Additionally, you can specify a separate image to use when the label is disabled using the `setDisabledIcon` method. Here's how you can do it:

```java
	// Create a label with text and an image
	ImageIcon icon = new ImageIcon("path/to/image.png");
	JLabel label = new JLabel("Hello, World!", icon, SwingConstants.CENTER);

	// Disable the label
	label.setEnabled(false);

	// Create a separate disabled icon
	ImageIcon disabledIcon = new ImageIcon("path/to/disabled_image.png");

	// Set the disabled icon for the label
	label.setDisabledIcon(disabledIcon);
```

**Adding Mnemonic to a Label**

In Java Swing, you can add a mnemonic to a label using the `setDisplayedMnemonic` method. A mnemonic is a keyboard shortcut that allows users to quickly access a component using the keyboard. When the mnemonic key is pressed along with the Alt key, the focus shifts to the labeled component. Here's how you can add a mnemonic to a label:

```java
	// Create a label with text and set its mnemonic
	JLabel label = new JLabel("Click Here");
	label.setDisplayedMnemonic('C'); // Setting 'C' as the mnemonic key
```

In this example, we create a `JLabel` with the text "Click Here". We then set the mnemonic key to 'C' using the `setDisplayedMnemonic` method. When the user presses Alt+C, the focus will shift to the labeled component, in this case, the label itself. Additionally, the mnemonic key 'C' will be underlined in the label's text to indicate the shortcut to the user.

When using a mnemonic in a `JLabel`, the default behavior is to underline the first occurrence of the specified letter in the label's text. However, if you want to explicitly specify which occurrence of the letter should be underlined, you can use the `setDisplayedMnemonicIndex()` method. This method allows you to set the index of the character to underline.

Here's how you can use it in your example "Enter E-mail Address" to underline the 'E' in "E-mail":

```java
	// Create a JLabel with mnemonic and set the mnemonic index
	JLabel label = new JLabel("Enter E-mail Address");
	label.setDisplayedMnemonic('E'); // Set the mnemonic to 'E'
	label.setDisplayedMnemonicIndex(6); // Set the index of the 'E' in "E-mail"
```

**Linking Labels to other Components**

In Java Swing, the `setLabelFor` method is used to associate a label with another component, such as a text field or a button. This association allows screen readers and other accessibility tools to provide more meaningful information to users, especially for users who rely on keyboard navigation or assistive technologies. Here's how you can use the `setLabelFor` method:

```java
	// Create a label and a text field
	JLabel label = new JLabel("Name:");
	JTextField textField = new JTextField(20);

	// Associate the label with the text field
	label.setLabelFor(textField);

	// Add the label and text field to a panel
	JPanel panel = new JPanel();
	panel.add(label);
	panel.add(textField);
```

**Changing the Text of the Label**

1. **setText(String text)**:
   - This method sets the text content of the `JLabel` to the specified string `text`.
   - For example, if you have a `JLabel` called `label`, you can set its text content like this:
     ```java
     JLabel label = new JLabel();
     label.setText("Hello, World!");
     ```

2. **getText()**:
   - This method retrieves the text content of the `JLabel`.
   - It returns a string representing the text content of the `JLabel`.
   - For example, if you want to get the text content from the `label` created earlier, you can use:
     ```java
     String labelText = label.getText();
     System.out.println(labelText); // Output: Hello, World!
     ```

**Using HTML in a Label**

You can use HTML formatting within a `JLabel` to achieve various text styles, such as bold, italic, underlined, colored text, and more. This is achieved by setting the text of the `JLabel` using HTML markup. Here's how you can do it:

```java
	JLabel label = new JLabel("<html><b>Bold Text</b>, <i>Italic Text</i>, <u>Underlined Text</u>, <font color='red'>Red Text</font></html>");
```

### JButton

`JButton` is a component in Java Swing that represents a clickable button. It is one of the most commonly used components for user interaction in GUI applications. `JButton` allows users to trigger actions or events when clicked, such as submitting a form, opening a dialog, or performing any other operation defined by the application.

Here are some key features and functionalities of `JButton`:

1. **Creating a JButton**:
   You can create an instance of `JButton` using its constructor and specifying the text to display on the button.

   ```java
   JButton button = new JButton("Click Me");
   ```

2. **Adding Action Listeners**:
   You can add action listeners to the button to handle events when it is clicked. Action listeners are notified when the button is clicked, and you can define custom behavior for the button click event.

   ```java
   button.addActionListener(new ActionListener() {
       public void actionPerformed(ActionEvent e) {
           // Your action handling code here
       }
   });
   ```

3. **Setting Icons**:
   You can set icons to be displayed on the button using the `setIcon()` method. Icons can be used to provide visual cues or represent the purpose of the button.

   ```java
   ImageIcon icon = new ImageIcon("icon.png");
   button.setIcon(icon);
   ```

4. **Disabling and Enabling**:
   You can disable or enable the button based on application logic using the `setEnabled()` method.

   ```java
   button.setEnabled(false); // Disable the button
   button.setEnabled(true); // Enable the button
   ```

5. **Customizing Appearance**:
   You can customize various aspects of the button's appearance, such as the font, foreground and background colors, border, and text alignment.

   ```java
   button.setFont(new Font("Arial", Font.BOLD, 14));
   button.setForeground(Color.RED);
   button.setBackground(Color.YELLOW);
   button.setBorder(BorderFactory.createLineBorder(Color.BLACK));
   button.setHorizontalAlignment(SwingConstants.CENTER);
   ```

6. **Tool Tips**:
   You can set tool tips to provide additional information when the user hovers over the button.

   ```java
   button.setToolTipText("Click this button to submit the form");
   ```

7. **Adding to Containers**:
   You can add the button to containers such as `JFrame`, `JPanel`, etc., using the `add()` method.

   ```java
   JPanel panel = new JPanel();
   panel.add(button);
   ```

The `setActionCommand` and `getActionCommand` methods are used with `JButton` objects to associate a string command with the button. This command can then be retrieved when the button is clicked, allowing you to differentiate between different buttons and perform different actions based on their commands.

```java
import javax.swing.*;
import java.awt.event.*;

public class JButtonActionCommandExample implements ActionListener {
    public static void main(String[] args) {
        JFrame frame = new JFrame("JButton Action Command Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        // Create two buttons
        JButton button1 = new JButton("Button 1");
        JButton button2 = new JButton("Button 2");

        // Set action commands for the buttons
        button1.setActionCommand("button1");
        button2.setActionCommand("button2");

        button1.addActionListener(this); 
        button2.addActionListener(this);

        // Add the buttons to the frame
        frame.add(button1);
        frame.add(button2);

        frame.setLayout(new java.awt.FlowLayout());
        frame.setSize(300, 200);
        frame.setVisible(true);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        // Get the action command when a button is clicked
        String command = e.getActionCommand();

        // Perform different actions based on the action command
        switch (command) {
            case "button1":
                System.out.println("Button 1 clicked.");
                // Add your action for button 1 here
                break;
            case "button2":
                System.out.println("Button 2 clicked.");
                // Add your action for button 2 here
                break;
            default:
                System.out.println("Unknown command.");
        }
    }
}
```

**Ways to Construct a Button**

1. **Default Constructor**: This constructor creates a button with no text or icon.
    ```java
    JButton button = new JButton();
    ```

2. **Text Constructor**: This constructor creates a button with the specified text.
    ```java
    JButton button = new JButton("Click Me");
    ```

3. **Icon Constructor**: This constructor creates a button with the specified icon.
    ```java
    Icon icon = new ImageIcon("buttonIcon.png");
    JButton button = new JButton(icon);
    ```

4. **Text and Icon Constructor**: This constructor creates a button with both text and an icon.
    ```java
    JButton button = new JButton("Click Me", icon);
    ```

5. **Action Constructor**: This constructor creates a button with the specified action. An action is an object that encapsulates the behavior of the button, including its text, icon, and action listener.
    ```java
    Action action = new AbstractAction("Click Me", icon) {
        public void actionPerformed(ActionEvent e) {
            // Action to perform when the button is clicked
            System.out.println("Button clicked");
        }
    };
    JButton button = new JButton(action);
    ```

6. **Model Constructor**: This constructor creates a button with the specified button model. A button model represents the state and behavior of the button.
    ```java
    ButtonModel model = new DefaultButtonModel();
    JButton button = new JButton(model);
    ```

**Methods**

- **setIcon(Icon icon)**:
   - Sets the default icon for the button. This icon is displayed when the button is in its default state.
   
- **getIcon()**:
   - Retrieves the current default icon of the button.
   
- **setDisabledIcon(Icon icon)**:
   - Sets the icon to be displayed when the button is disabled. This icon is displayed when the button is not enabled (i.e., `setEnabled(false)`).
   
- **setPressedIcon(Icon icon)**:
   - Sets the icon to be displayed when the button is pressed. This icon is displayed when the button is being pressed by the user.
   
- **setRolloverIcon(Icon icon)**:
   - Sets the icon to be displayed when the mouse is rolled over the button. This icon is displayed when the mouse pointer is over the button.
   
- **isRolloverEnabled()**:
   - Checks if rollover effects are enabled for the button. Rollover effects include changing the icon when the mouse is over the button.
   
- **setRolloverEnabled(boolean enabled)**:
   - Enables or disables rollover effects for the button. When enabled, the button changes its appearance when the mouse is over it.
   
- **setEnabled(boolean enabled)**:
   - Enables or disables the button. When a button is disabled, it cannot be clicked or interacted with by the user.
   
- **isEnabled()**:
   - Checks if the button is currently enabled.

**Setting a Default Button**

Setting a default button in Java Swing allows you to specify a button that will be activated when the user presses the Enter key, providing a convenient way for users to submit forms or perform default actions. Here's how you can define a default button in your Swing application:

1. **Get the Root Pane**: Retrieve the root pane of the container where your button resides. You can obtain the root pane using the `getRootPane()` method of your `JFrame` or `JDialog`.

2. **Set the Default Button**: Call the `setDefaultButton()` method on the root pane and pass the button that you want to set as the default.

Here's an example:

```java
import javax.swing.*;

public class DefaultButtonExample {
    public static void main(String[] args) {
        // Create a JFrame
        JFrame frame = new JFrame("Default Button Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        // Create buttons
        JButton button1 = new JButton("Button 1");
        JButton button2 = new JButton("Button 2");

        // Add buttons to the frame
        frame.getContentPane().add(button1);
        frame.getContentPane().add(button2);

        // Set button1 as the default button
        frame.getRootPane().setDefaultButton(button1);

        // Set frame size and make it visible
        frame.setSize(300, 200);
        frame.setVisible(true);
    }
}
```

- The default button should typically represent the primary action that the user is expected to take, such as submitting a form or confirming a dialog.

**Options**

1. **Using HTML for Text**:
   - You can use HTML markup to format the text displayed on a button. This allows you to create buttons with multiple lines of text or apply formatting such as bold or italics.
   - Example:
     ```java
     JButton jbtn = new JButton("<html>Press<br>Me");
     ```
   - This creates a button with the text "Press" on the first line and "Me" on the second line.

2. **Setting a Mnemonic**:
   - You can assign a keyboard mnemonic to a button, allowing users to activate the button by pressing a specific key in combination with the ALT key.
   - Example:
     ```java
     jbtn.setMnemonic('p');
     ```
   - This sets the mnemonic to 'p', so users can activate the button by pressing ALT+P.

3. **Positioning Text and Icon**:
   - When a button contains both text and an icon, you can specify the position of the text relative to the icon using `setVerticalTextPosition()` or `setHorizontalTextPosition()`.
   - Example:
     ```java
     jbtn.setVerticalTextPosition(SwingConstants.BOTTOM);
     jbtn.setHorizontalTextPosition(SwingConstants.CENTER);
     ```
   - This sets the text to be positioned below the icon (`SwingConstants.BOTTOM`) and horizontally centered (`SwingConstants.CENTER`).

### JToggleButton

`JToggleButton` is a Swing component in Java that represents a button that can be toggled between selected and deselected states. It inherits from the `AbstractButton` class, which means it shares many features with other button components like `JButton`.

Here's a brief overview of `JToggleButton`:

- **Toggle Functionality**: Unlike a regular button (`JButton`), a `JToggleButton` has two states: selected and deselected. Clicking on it toggles between these two states. This makes it useful for implementing features where users need to choose between two options.

- **Appearance**: Visually, a `JToggleButton` typically looks like a regular button, but it has a different appearance when selected compared to when deselected. For example, it may appear pressed or have a different color to indicate its state.

- **Events**: Like other Swing components, `JToggleButton` can generate events when interacted with by the user. You can add action listeners to respond to these events and perform actions based on the state changes of the toggle button.

Here's a simple example of how you might create and use a `JToggleButton`:

```java
import javax.swing.*;
import java.awt.event.*;

public class ToggleButtonExample {
    public static void main(String[] args) {
        // Create a JFrame
        JFrame frame = new JFrame("Toggle Button Example");

        // Create a JToggleButton
        JToggleButton toggleButton = new JToggleButton("Toggle Me");

        // Add an ItemListener to respond to item state changes
        toggleButton.addItemListener(new ItemListener() {
            @Override
            public void itemStateChanged(ItemEvent e) {
                // Get the source of the event (the toggle button)
                JToggleButton button = (JToggleButton) e.getItem();

                // Check if the button is selected or deselected using isSelected()
                if (button.isSelected()) {
                    System.out.println("Button is selected");
                } else {
                    System.out.println("Button is deselected");
                }

                // Alternatively, you can use getStateChange() to check if the button is selected or deselected
                int stateChange = e.getStateChange();
                if (stateChange == ItemEvent.SELECTED) {
                    System.out.println("Button was selected");
                } else if (stateChange == ItemEvent.DESELECTED) {
                    System.out.println("Button was deselected");
                }
            }
        });

        // Add the toggle button to the frame
        frame.getContentPane().add(toggleButton);

        // Set frame properties
        frame.setSize(300, 200);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}
```

**Ways to Construct**

There are several ways to construct a `JToggleButton` in Java Swing, allowing you to create toggle buttons with different configurations based on your application's needs. Here are some common ways to construct a `JToggleButton`:

1. **Default Constructor**:
   - This constructor creates a toggle button with no text or icon.
   ```java
   JToggleButton toggleButton = new JToggleButton();
   ```

2. **Text Constructor**:
   - This constructor creates a toggle button with the specified text.
   ```java
   JToggleButton toggleButton = new JToggleButton("Toggle Me");
   ```

3. **Icon Constructor**:
   - This constructor creates a toggle button with the specified icon.
   ```java
   Icon icon = new ImageIcon("toggleIcon.png");
   JToggleButton toggleButton = new JToggleButton(icon);
   ```

4. **Text and Icon Constructor**:
   - This constructor creates a toggle button with both text and an icon.
   ```java
   JToggleButton toggleButton = new JToggleButton("Toggle Me", icon);
   ```

5. **Icon and Selected Constructor**:
   - This constructor creates a toggle button with the specified icon and initial selection state.
   ```java
   Icon icon = new ImageIcon("toggleIcon.png");
   JToggleButton toggleButton = new JToggleButton(icon, true); // Initial state: selected
   ```

6. **Text, Icon, and Selected Constructor**:
   - This constructor creates a toggle button with text, an icon, and initial selection state.
   ```java
   JToggleButton toggleButton = new JToggleButton("Toggle Me", icon, true); // Initial state: selected
   ```

**ToggleButtonModel**

The `JToggleButton` in Java Swing uses a different model compared to `JButton`. It utilizes a nested class called `JToggleButton.ToggleButtonModel` to define its model. While you typically won't interact directly with the model for standard toggle buttons, it's important to understand how it works.

**Options**

1. **Setting Icons**:
   - You can specify icons that indicate the pressed and unpressed states of the toggle button, as well as a rollover icon.
   - Use the constructor `JToggleButton(String text, Icon icon)` to create a toggle button with a default icon.
   - Additional icons can be set using methods such as `setDisabledIcon()`, `setPressedIcon()`, `setRolloverIcon()`, `setRolloverSelectedIcon()`, and `setSelectedIcon()`.
   - Remember to provide a default icon for the toggle button to utilize the other icons effectively.

2. **Text Positioning**:
   - You can specify the position of the text relative to an icon using methods like `setVerticalTextPosition()` or `setHorizontalTextPosition()`.

3. **Setting Mnemonics**:
   - You can add a mnemonic to the text displayed within the button, allowing users to toggle the button by pressing a specific key in combination with the ALT key.
   - Use the `setMnemonic(char key)` method to set the keyboard mnemonic for the toggle button.

4. **Disabling/Enabling**:
   - Toggle buttons can be disabled or enabled using the `setEnabled(boolean enabled)` method, similar to `JButton`.

### JCheckBox

A `JCheckBox` is a Swing component in Java that represents a checkbox, which can be selected (checked) or deselected (unchecked) by the user. It's commonly used when users need to make multiple selections from a list of options or to represent a binary choice.

Here's a brief overview of `JCheckBox`:

- **Selection State**: A `JCheckBox` can be in one of two states: selected (checked) or deselected (unchecked). Clicking on the checkbox toggles between these two states.

- **Appearance**: Visually, a `JCheckBox` typically consists of a small box and a label next to it. The label describes the option represented by the checkbox, and the box indicates whether the option is selected or not.

- **Events**: Like other Swing components, `JCheckBox` can generate events when interacted with by the user. You can add item listeners to respond to these events and perform actions based on the state changes of the checkbox.

Here's a simple example of how you might create and use a `JCheckBox`:

```java
import javax.swing.*;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;

public class CheckBoxExample {
    public static void main(String[] args) {
        // Create a JFrame
        JFrame frame = new JFrame("Checkbox Example");

        // Create a JCheckBox
        JCheckBox checkBox = new JCheckBox("Enable Feature");

        // Add an ItemListener to respond to checkbox state changes
        checkBox.addItemListener(new ItemListener() {
            @Override
            public void itemStateChanged(ItemEvent e) {
                // Check the state of the checkbox
                if (e.getStateChange() == ItemEvent.SELECTED) {
                    System.out.println("Feature is enabled");
                } else {
                    System.out.println("Feature is disabled");
                }
            }
        });

        // Add the checkbox to the frame
        frame.getContentPane().add(checkBox);

        // Set frame properties
        frame.setSize(300, 200);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}
```

In this example, a `JCheckBox` is created with the label "Enable Feature". An `ItemListener` is added to the checkbox to respond to state changes. When the checkbox is selected or deselected, the listener prints a corresponding message to the console.

### JRadioButton

A `JRadioButton` is a Swing component in Java that represents a radio button, which allows users to make a single selection from a group of options. Unlike checkboxes (`JCheckBox`), where users can select multiple options, radio buttons are used when users are expected to make only one choice from a set of mutually exclusive options.

Here's a brief overview of `JRadioButton`:

- **Selection**: A group of radio buttons is associated with each other using a common `ButtonGroup` object. When a user selects one radio button within the group, any previously selected radio button is automatically deselected.

- **Appearance**: Visually, a `JRadioButton` typically consists of a circular button and a label next to it. The label describes the option represented by the radio button.

- **Events**: Like other Swing components, `JRadioButton` can generate events when interacted with by the user. You can add action listeners to respond to these events and perform actions based on the selected radio button.

Here's a simple example of how you might create and use a group of `JRadioButton` components:

```java
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class RadioButtonExample {
    public static void main(String[] args) {
        // Create a JFrame
        JFrame frame = new JFrame("Radio Button Example");

        // Create a ButtonGroup for the radio buttons
        ButtonGroup buttonGroup = new ButtonGroup();

        // Create radio buttons
        JRadioButton radioButton1 = new JRadioButton("Option 1");
        JRadioButton radioButton2 = new JRadioButton("Option 2");
        JRadioButton radioButton3 = new JRadioButton("Option 3");

        // Add radio buttons to the ButtonGroup
        buttonGroup.add(radioButton1);
        buttonGroup.add(radioButton2);
        buttonGroup.add(radioButton3);

        // Add an ActionListener to respond to radio button selection
        ActionListener listener = new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                // Get the selected radio button
                JRadioButton selectedButton = (JRadioButton) e.getSource();
                System.out.println("Selected option: " + selectedButton.getText());
            }
        };

        // Add the ActionListener to each radio button
        radioButton1.addActionListener(listener);
        radioButton2.addActionListener(listener);
        radioButton3.addActionListener(listener);

        // Create a panel to hold the radio buttons
        JPanel panel = new JPanel(new GridLayout(3, 1));
        panel.add(radioButton1);
        panel.add(radioButton2);
        panel.add(radioButton3);

        // Add the panel to the frame
        frame.getContentPane().add(panel);

        // Set frame properties
        frame.setSize(300, 200);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}
```

In this example, three `JRadioButton` components are created and added to a `ButtonGroup`. An `ActionListener` is added to each radio button to respond to selection events. When a radio button is selected, the listener prints the selected option to the console.

### ButtonModel

The `ButtonModel` interface in Java Swing represents the data model behind a button component, such as `JButton`, `JToggleButton`, or `JRadioButton`. It encapsulates the state and behavior of the button, allowing you to manipulate its properties programmatically.

Here's a brief overview of `ButtonModel`:

1. **State Management**: `ButtonModel` manages the state of the button, including whether it is enabled or disabled, selected or deselected, pressed or released, and focused or unfocused.

2. **Events**: It generates events to notify listeners when the state of the button changes. These events include action events, change events, item events, and more, depending on the type of button and its interactions.

3. **Interaction with UI Components**: `ButtonModel` interacts with UI components to update the visual representation of the button based on its state. For example, it manages the appearance of the button when it's selected, pressed, or disabled.

4. **Methods**: `ButtonModel` provides methods to query and modify the state of the button, such as `isEnabled()`, `isSelected()`, `setSelected()`, `isPressed()`, `setPressed()`, `isArmed()`, `setArmed()`, and so on.
	- **isArmed()**:
	   - Returns `true` if the button has been pressed but not yet released.
	
	- **isEnabled()**:
	   - Returns `true` if the button is enabled and available for use.
	
	- **isPressed()**:
	   - Returns `true` if the button is currently pressed.
	
	- **isRollover()**:
	   - Returns `true` if the mouse is positioned over the button.
	
	- **isSelected()**:
	   - Returns `true` if the button is selected. This method applies only to two-state buttons.
	
	- **setArmed(boolean b)**:
	   - Sets whether the button is armed (pressed but not yet released).
	
	- **setEnabled(boolean b)**:
	   - Sets whether the button is enabled or disabled.
	
	- **setPressed(boolean b)**:
	   - Sets whether the button is pressed.
	
	- **setRollover(boolean b)**:
	   - Sets whether the mouse is positioned over the button.
	
	- **setSelected(boolean b)**:
	    - Sets whether the button is selected. This method applies only to two-state buttons.

5. **Model-View Separation**: The use of a separate model interface allows for a clear separation between the data model (the `ButtonModel`) and the view (the UI component). This separation promotes modularity and flexibility in UI design.

Here's a simple example demonstrating the use of `ButtonModel`:

```java
import javax.swing.*;
import javax.swing.event.*;

public class ButtonModelExample {
    public static void main(String[] args) {
        // Create a JButton
        JButton button = new JButton("Click Me");

        // Get the button's model
        ButtonModel model = button.getModel();

        // Add a ChangeListener to monitor state changes
        model.addChangeListener(new ChangeListener() {
            public void stateChanged(ChangeEvent e) {
                // Check if the button is selected
                if (model.isSelected()) {
                    System.out.println("Button is selected");
                } else {
                    System.out.println("Button is deselected");
                }
            }
        });

        // Create a JFrame and add the button
        JFrame frame = new JFrame("ButtonModel Example");
        frame.getContentPane().add(button);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.pack();
        frame.setVisible(true);
    }
}
```


### ButtonGroup

In Java Swing, a `ButtonGroup` is a mechanism used to group together a set of radio buttons or toggle buttons. This grouping ensures that only one button in the group can be selected at a time, simulating the behavior of radio buttons in a group.

Here's an overview of `ButtonGroup` and how it works:

1. **Creating a ButtonGroup**:
   - You create a `ButtonGroup` instance using its default constructor.
   - ```java
     ButtonGroup group = new ButtonGroup();
     ```

2. **Adding Buttons to the Group**:
   - Once you have a `ButtonGroup` instance, you add radio buttons or toggle buttons to the group using the `add(AbstractButton b)` method.
   - ```java
     JRadioButton radioButton1 = new JRadioButton("Option 1");
     JRadioButton radioButton2 = new JRadioButton("Option 2");
     
     group.add(radioButton1);
     group.add(radioButton2);
     ```

3. **Behavior**:
   - When buttons are added to a `ButtonGroup`, only one button in the group can be selected at a time.
   - Selecting one button automatically deselects any other button in the same group.
   - This behavior is similar to that of radio buttons in a radio button group.

4. **Use Cases**:
   - `ButtonGroup` is commonly used when you have a set of mutually exclusive options and you want the user to select only one option from the set.
   - It's useful for creating sets of radio buttons where only one option should be selected.

5. **Examples**:
   - Radio buttons for selecting a gender (Male/Female/Other).
   - Toggle buttons for selecting a mode (Normal/Advanced/Expert).

Here's a simple example of using `ButtonGroup` with radio buttons:

```java
import javax.swing.*;

public class RadioButtonExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame("Radio Button Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        JRadioButton radioButton1 = new JRadioButton("Option 1");
        JRadioButton radioButton2 = new JRadioButton("Option 2");
        
        ButtonGroup group = new ButtonGroup();
        group.add(radioButton1);
        group.add(radioButton2);
        
        JPanel panel = new JPanel();
        panel.add(radioButton1);
        panel.add(radioButton2);
        
        frame.add(panel);
        frame.pack();
        frame.setVisible(true);
    }
}
```

In this example, `ButtonGroup` ensures that only one radio button can be selected at a time.

### BoundedRangeModel

The `BoundedRangeModel` interface in Java Swing provides a representation of a bounded range. It is commonly used to represent properties such as scroll bars, sliders, and progress bars, where the range of values is bounded within a specified minimum and maximum range.

Here's an overview of the `BoundedRangeModel` interface and its methods:

1. **Interface Overview**:
   - The `BoundedRangeModel` interface defines the state and behavior of a bounded range, including its current value, minimum and maximum values, and extent (the visible portion of the range).

2. **Methods**:
   - `int getMinimum()`: Returns the minimum value of the range.
   - `int getMaximum()`: Returns the maximum value of the range.
   - `int getValue()`: Returns the current value of the range.
   - `void setValue(int value)`: Sets the current value of the range.
   - `int getExtent()`: Returns the extent of the range (the visible portion).
   - `void setExtent(int extent)`: Sets the extent of the range.
   - `void setMinimum(int minimum)`: Sets the minimum value of the range.
   - `void setMaximum(int maximum)`: Sets the maximum value of the range.
   - `void setRangeProperties(int value, int extent, int min, int max, boolean adjusting)`: Sets the properties of the range in a single method call, allowing you to specify the current value, extent, minimum, and maximum values, as well as whether the range is currently being adjusted.

3. **Usage**:
   - You typically use a class that implements the `BoundedRangeModel` interface, such as `DefaultBoundedRangeModel`, to represent the state of components like scroll bars and sliders.
   - By setting the properties of the range model, you control the behavior and appearance of these components, such as their current value, range limits, and visible extent.

The `BoundedRangeModel` in Java Swing enforces a relationship between its four values: minimum, maximum, value, and extent. Here's an explanation of this relationship and the additional properties provided by the `BoundedRangeModel`:

1. **Minimum and Maximum Values**:
   - These define the endpoints of the range over which a component based on `BoundedRangeModel` can operate.
   - The current value of the component will be within this range.
   - The minimum value must be less than or equal to the maximum value.

2. **Current Value**:
   - It represents the current position within the range.
   - The current value must be greater than or equal to the minimum value.
   - The current value plus the extent must be less than or equal to the maximum value.

3. **Extent**:
   - It represents the width or "thickness" of the sliding element that moves between the endpoints of the component.
   - For example, in a scroll bar, the extent corresponds to the width of the slider box.
   - Specifying an extent of 0 allows the current value to be anywhere within the range specified by the minimum and maximum values, inclusive.

4. **Adjusting Property**:
   - The `BoundedRangeModel` also defines a property that indicates when the component is in the process of being changed.
   - This property, known as the "is-adjusting" property, can be accessed through the `getValueIsAdjusting()` and `setValueIsAdjusting()` methods.
   - It is useful because both scroll bars and sliders generate many events when they are being dragged to a new setting.
   - Event handlers can wait until `getValueIsAdjusting()` returns false before taking action, or they can respond to all events as they happen in real time.

Here's a simple example demonstrating the usage of `BoundedRangeModel` with a `JSlider`:

```java
import javax.swing.*;
import javax.swing.event.*;

public class BoundedRangeModelExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame("Bounded Range Model Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        // Create a slider with default range model
        JSlider slider = new JSlider();
        
        // Get the range model from the slider
        BoundedRangeModel model = slider.getModel();
        
        // Add a change listener to track changes in the range model
        model.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                // Print the current value of the range model
                System.out.println("Current value: " + model.getValue());
            }
        });

        frame.getContentPane().add(slider);
        frame.pack();
        frame.setVisible(true);
    }
}
```

In this example, we create a `JSlider` component and obtain its range model using the `getModel()` method. We then add a change listener to the range model to track changes in the slider's value. When the slider's value changes, the `stateChanged()` method of the change listener is called, and we print the current value of the range model.

### JScrollBar

In Java Swing, a `JScrollBar` is a component used for navigating through a range of values by scrolling. It provides a graphical user interface for adjusting a numeric value within a specified range.

Here's an overview of `JScrollBar` and its key features:

1. **Functionality**:
   - A `JScrollBar` typically consists of a thumb (also known as a slider), arrow buttons at each end, and a track.
   - Users can interact with the scrollbar by clicking the arrow buttons to increment or decrement the value by a small amount, or by dragging the thumb along the track to smoothly adjust the value.
   - Scrollbars are commonly used in user interfaces to navigate through large datasets, adjust zoom levels, or control various parameters such as volume or brightness.

2. **Orientation**:
   - A `JScrollBar` can be either horizontal or vertical, depending on the orientation required for your user interface.
   - You specify the orientation when creating the scrollbar using the constructor or by calling the `setOrientation()` method.

3. **Range and Value**:
   - The scrollbar operates within a specified range defined by minimum and maximum values.
   - The current value of the scrollbar represents the position of the thumb within this range.
   - You can set the minimum and maximum values using the `setMinimum()` and `setMaximum()` methods, and you can set the current value using the `setValue()` method.

4. **Event Handling**:
   - `JScrollBar` generates events when the value changes.
   - You can register event listeners, such as `AdjustmentListener`, to respond to changes in the scrollbar's value.
   - The `AdjustmentListener` interface defines a single method, `adjustmentValueChanged()`, which is called whenever the scrollbar's value changes.

5. **Customization**:
   - You can customize the appearance and behavior of a `JScrollBar` by setting properties such as the unit increment (amount by which the value changes when clicking the arrow buttons), block increment (amount by which the value changes when clicking in the track), and whether the scrollbar is visible or enabled.

Here's a simple example demonstrating the usage of `JScrollBar`:

```java
import javax.swing.*;
import java.awt.event.*;

public class ScrollBarExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame("Scroll Bar Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        // Create a vertical scrollbar
        JScrollBar scrollBar = new JScrollBar(JScrollBar.VERTICAL, 0, 10, 0, 100);
        
        // Add an AdjustmentListener to track changes in value
        scrollBar.addAdjustmentListener(new AdjustmentListener() {
            @Override
            public void adjustmentValueChanged(AdjustmentEvent e) {
                System.out.println("Value: " + scrollBar.getValue());
            }
        });

        frame.getContentPane().add(scrollBar);
        frame.pack();
        frame.setVisible(true);
    }
}
```

**Ways to Construct a Scroll Bar**

1. **Using Default Constructor**:
   - You can create a `JScrollBar` using the default constructor, which creates a vertical scrollbar with default values.
	```java
     JScrollBar scrollBar = new JScrollBar();
     ```

2. **Specifying Orientation and Values**:
   - You can specify the orientation (horizontal or vertical) and initial values (current value, extent, minimum, and maximum) using the constructor with parameters.
   ```java
     JScrollBar scrollBar = new JScrollBar(JScrollBar.HORIZONTAL, initialValue, extent, minimum, maximum);
     ```
```java
	JScrollBar scrollBar = new JScrollBar(JScrollBar.VERTICAL, initialValue, extent, minimum, maximum);
```

3. **Setting Values Later**:
   - You can create a `JScrollBar` with the default constructor and then set its properties (orientation, current value, extent, minimum, and maximum) later using setter methods.
```java
     JScrollBar scrollBar = new JScrollBar();
     scrollBar.setOrientation(JScrollBar.HORIZONTAL);
     scrollBar.setValue(initialValue);
     scrollBar.setExtent(extent);
     scrollBar.setMinimum(minimum);
     scrollBar.setMaximum(maximum);
 ```

4. **Using Builder Pattern**:
   - If you prefer a more fluent and readable way to construct a `JScrollBar`, you can use a builder pattern.
   ```java
 JScrollBar scrollBar = new JScrollBarBuilder()
							.orientation(JScrollBar.HORIZONTAL)
							.value(initialValue)
							.extent(extent)
							.minimum(minimum)
							.maximum(maximum)
							.build();
     ```

**Methods**

In Java Swing, the `JScrollBar` class provides several methods to access and modify its properties, including the extent, unit increment, block increment, and adjusting state. Here's an explanation of these methods:

1. **Extent (Visible Amount)**:
   - The extent represents the size of the visible portion of the scrollable content.
   - Accessor Methods:
     - `int getVisibleAmount()`: Returns the current extent (visible amount).
     - `void setVisibleAmount(int val)`: Sets the extent (visible amount) to the specified value.

2. **Setting Values at Once**:
   - `void setValues(int value, int visibleAmount, int min, int max)`: Allows setting the value, extent, minimum, and maximum values in a single call.

3. **Adjusting State**:
   - The adjusting state indicates whether the scrollbar is in the process of being changed.
   - Accessor Methods:
     - `boolean getValueIsAdjusting()`: Returns true if the scrollbar is in the process of being changed; false otherwise.
     - `void setValueIsAdjusting(boolean value)`: Sets the adjusting state of the scrollbar.

4. **Unit Increment**:
   - The unit increment is the amount by which the scrollbar value changes when clicking the arrow buttons.
   - Accessor Methods:
     - `int getUnitIncrement()`: Returns the current unit increment value.
     - `void setUnitIncrement(int val)`: Sets the unit increment value to the specified amount.

5. **Block Increment**:
   - The block increment is the amount by which the scrollbar value changes when clicking the paging area.
   - Accessor Methods:
     - `int getBlockIncrement()`: Returns the current block increment value.
     - `void setBlockIncrement(int val)`: Sets the block increment value to the specified amount.

**Handling JScrollBar Adjustment Events**

To handle adjustment events generated by a `JScrollBar`, you need to implement the `AdjustmentListener` interface and override the `adjustmentValueChanged()` method. This method will be called whenever a change is made to the value of the scroll bar.

Here's an example demonstrating how to handle adjustment events for a `JScrollBar`:

```java
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class ScrollBarAdjustmentExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame("ScrollBar Adjustment Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        // Create a vertical scroll bar
        JScrollBar scrollBar = new JScrollBar(JScrollBar.VERTICAL, 0, 10, 0, 100);
        
        // Add an AdjustmentListener to handle adjustment events
        scrollBar.addAdjustmentListener(new AdjustmentListener() {
            @Override
            public void adjustmentValueChanged(AdjustmentEvent e) {
                JScrollBar source = (JScrollBar) e.getAdjustable();
                int value = source.getValue();
                boolean isAdjusting = e.getValueIsAdjusting();
                
                System.out.println("Value: " + value);
                System.out.println("Is Adjusting: " + isAdjusting);
            }
        });

        frame.getContentPane().add(scrollBar, BorderLayout.CENTER);
        frame.setSize(300, 200);
        frame.setVisible(true);
    }
}
```

### JScrollPane

In Java Swing, a `JScrollPane` is a container that allows its content to be scrolled. It's commonly used to provide scrolling functionality to components such as text areas, tables, lists, or custom components that exceed the available space in the visible area.

Here are the ways to construct a `JScrollPane`:

1. **Using a Component as Content**:
   - You can create a `JScrollPane` with a component (e.g., `JTextArea`, `JTable`, `JList`) as its content.
   ```java
     JTextArea textArea = new JTextArea(10, 20); // Example component
     JScrollPane scrollPane = new JScrollPane(textArea);
     ```

2. **Setting Viewport View Later**:
   - You can create a `JScrollPane` without specifying the content component initially and then set the component later using the `setViewportView()` method.
   ```java
     JScrollPane scrollPane = new JScrollPane();
     JTextArea textArea = new JTextArea(10, 20); // Example component
     scrollPane.setViewportView(textArea);
     ```

3. **Customizing Scrollbars**:
   - By default, `JScrollPane` provides horizontal and vertical scroll bars as needed. You can customize the scroll bar policies using the `setHorizontalScrollBarPolicy()` and `setVerticalScrollBarPolicy()` methods.
```java
     JScrollPane scrollPane = new JScrollPane(textArea);
     scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
     scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
     ```

Here are the commonly used constants in the `ScrollPaneConstants` interface:

- **Horizontal Scroll Bar Policies**:
   - `HORIZONTAL_SCROLLBAR_AS_NEEDED`: The horizontal scroll bar appears only when the view's width exceeds the width of the viewport.
   - `HORIZONTAL_SCROLLBAR_NEVER`: The horizontal scroll bar is never displayed.
   - `HORIZONTAL_SCROLLBAR_ALWAYS`: The horizontal scroll bar is always displayed, regardless of the view's size.

- **Vertical Scroll Bar Policies**:
   - `VERTICAL_SCROLLBAR_AS_NEEDED`: The vertical scroll bar appears only when the view's height exceeds the height of the viewport.
   - `VERTICAL_SCROLLBAR_NEVER`: The vertical scroll bar is never displayed.
   - `VERTICAL_SCROLLBAR_ALWAYS`: The vertical scroll bar is always displayed, regardless of the view's size.

4. **Using Builder Pattern**:
   - If you prefer a fluent and readable way to construct a `JScrollPane`, you can use a builder pattern.
   ```java
 JScrollPane scrollPane = new JScrollPaneBuilder()
.viewportView(textArea)
							  .horizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS)
							  .verticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS)
							  .build();
     ```

**Constructors**

1. **`JScrollPane()`**: Creates a scroll pane with an empty view.

2. **`JScrollPane(Component view)`**: Creates a scroll pane with the specified view component.

3. **`JScrollPane(Component view, int vsbPolicy, int hsbPolicy)`**: Creates a scroll pane with the specified view component and scroll bar policies.

4. **`JScrollPane(int vsbPolicy, int hsbPolicy)`**: Creates a scroll pane with no view and the specified scroll bar policies.

5. **`JScrollPane(int vsbPolicy, int hsbPolicy)`**: Creates a scroll pane with no view and the specified scroll bar policies.

**`JViewport`**

- **`JViewport`**: A `JViewport` is a lightweight container that is typically used as the view of a `JScrollPane`. It provides a window onto a larger view, allowing users to scroll through the view when it's larger than the viewport.

- **Functionality**: 
  - **View Control**: The `JViewport` controls the viewable area of its enclosed component.
  - **Scrolling**: It enables scrolling by displaying scroll bars when necessary based on the content size relative to the viewport size.
  - **Scaling**: In some cases, it can scale its content to fit the viewport.
  - **Positioning**: It allows positioning the viewable area within the content component.

When you create a `JScrollPane`, you typically pass the component you want to display inside the scroll pane to one of its constructors. This component becomes the view of the scroll pane and is usually wrapped in a `JViewport`. The `JViewport` then manages the size and position of the view within the scroll pane, enabling scrolling functionality as needed.

**Customization**

1. **Scroll Bar Policies**:
   - Set the vertical and horizontal scroll bar policies using `setVerticalScrollBarPolicy()` and `setHorizontalScrollBarPolicy()` methods. You can choose between showing the scroll bars always, never, or as needed.

2. **Viewport**:
   - Access the viewport using `getViewport()` method and customize its properties.
   - Set the view using `setViewportView()` method to specify the component displayed within the scroll pane.
   - Adjust the size of the viewport using `setPreferredSize()` method to control the visible area.

3. **Appearance**:
   - Customize the look and feel of scroll bars using UIManager properties or custom UI classes.
   - Use custom icons for scroll bar buttons, thumb, and track.
   - Adjust the border and background color of the scroll pane using `setBorder()` and `setBackground()` methods.

4. **Scrolling Behavior**:
   - Modify scrolling behavior by subclassing `JScrollPane` and overriding methods such as `getScrollableUnitIncrement()` or `getScrollableBlockIncrement()`.
   - Implement custom scrolling actions by attaching event listeners to scroll bars and handling scroll events.

5. **Scroll Speed**:
   - Adjust the speed of scrolling by setting the unit and block increments of the scroll bars using `setUnitIncrement()` and `setBlockIncrement()` methods.

6. **Accessibility**:
   - Ensure that the scroll pane is accessible to users with disabilities by providing keyboard navigation support and appropriate labels for scroll bars and viewport.

7. **Listeners**:
   - Attach scroll event listeners using `addAdjustmentListener()` method to respond to changes in the viewport position.
   - Add component resize listeners to adjust the size of the viewport dynamically based on the content size.

8. **Row and Column Headers**:
   - Use `setRowHeaderView()` and `setColumnHeaderView()` methods to set components as row and column headers respectively. These components will remain fixed while scrolling the main viewport.
   - Parameters:
     - `setRowHeaderView(Component view)` - Accepts a `Component` object representing the row header view.
     - `setColumnHeaderView(Component view)` - Accepts a `Component` object representing the column header view.

9. **Viewport Border**:
   - Set a border around the viewport area using `setViewportBorder()` method to provide visual separation between the viewport and scroll bars.
   - Parameter:
     - `setViewportBorder(Border border)` - Accepts a `Border` object to be set as the border for the viewport.

10. **Accessing Scroll Bars**:
    - Retrieve references to the horizontal and vertical scroll bars using `getHorizontalScrollBar()` and `getVerticalScrollBar()` methods respectively.
    - These methods return instances of `JScrollBar`.
    - Example:
      ```java
      JScrollBar horizontalScrollBar = scrollPane.getHorizontalScrollBar();
      ```

11. **Customizing Scroll Bars**:
    - Customize the behavior and appearance of the scroll bars by setting properties and attaching listeners to them.
    - Use `setHorizontalScrollBar()` and `setVerticalScrollBar()` methods to replace the default scroll bars with custom instances.
    - Parameters:
      - `setHorizontalScrollBar(JScrollBar horizontalScrollBar)` - Accepts a `JScrollBar` object to be set as the horizontal scroll bar.
      - `setVerticalScrollBar(JScrollBar verticalScrollBar)` - Accepts a `JScrollBar` object to be set as the vertical scroll bar.

12. **Corner Component**:
    - Set a custom component to be displayed in the corner where the row and column headers meet using the `setCorner()` method.
    - Parameters:
      - `setCorner(String key, Component corner)` - Accepts a `String` key indicating the corner (e.g., `ScrollPaneConstants.UPPER_LEFT_CORNER`, `ScrollPaneConstants.LOWER_RIGHT_CORNER`) and a `Component` object to be set as the corner component.

### JSlider

In Java Swing, a `JSlider` is a GUI component that allows users to select a value from a range by sliding a knob along a track. It's commonly used for settings such as volume control, brightness adjustment, or selecting a value within a range.

Here's a basic example of how to create and customize a `JSlider`:

```java
import javax.swing.*;
import java.awt.*;
import javax.swing.event.*;

public class SliderExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame("Slider Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        // Create a horizontal slider with default minimum, maximum, and initial values
        JSlider slider = new JSlider();
        
        // Customize the slider
        slider.setMinimum(0);       // Set the minimum value
        slider.setMaximum(100);     // Set the maximum value
        slider.setValue(50);         // Set the initial value
        
        // Set major and minor tick spacing
        slider.setMajorTickSpacing(10);
        slider.setMinorTickSpacing(1);
        slider.setPaintTicks(true);
        
        // Set labels to be displayed at major tick marks
        slider.setPaintLabels(true);
        
        // Create labels at major tick marks
        slider.setLabelTable(slider.createStandardLabels(10));
        
        // Set orientation to horizontal (default)
        slider.setOrientation(JSlider.HORIZONTAL);
        
        // Add change listener to handle adjustments
        slider.addChangeListener(new ChangeListener() {
            public void stateChanged(ChangeEvent e) {
                JSlider source = (JSlider)e.getSource();
                if (!source.getValueIsAdjusting()) {
                    int value = source.getValue();
                    System.out.println("Slider value changed to: " + value);
                }
            }
        });
        
        // Add the slider to the frame
        frame.getContentPane().add(slider, BorderLayout.CENTER);
        
        frame.setSize(300, 200);
        frame.setVisible(true);
    }
}
```

**Constructors:**

1. **`JSlider()`**:
   - Creates a horizontal slider with a range from 0 to 100. The extent is 0, and the initial value is set to 50.

2. **`JSlider(int min, int max)`**:
   - Creates a horizontal slider with the specified minimum and maximum values. The extent is 0, and the initial value is set to the midpoint between `min` and `max`.

3. **`JSlider(int min, int max, int val)`**:
   - Creates a horizontal slider with the specified minimum, maximum, and initial values.

4. **`JSlider(int VorH)`**:
   - Creates a slider with orientation specified by `VorH`, which must be either `JSlider.VERTICAL` or `JSlider.HORIZONTAL`. The range is from 0 to 100, and the initial value is set to 50.

5. **`JSlider(int VorH, int min, int max, int val)`**:
   - Creates a slider with orientation specified by `VorH`, and the specified minimum, maximum, and initial values.

6. **`JSlider(BoundedRangeModel model)`**:
   - Creates a slider using the specified `BoundedRangeModel`.

**Methods:**

1. **Event Handling**:
   - `addChangeListener(ChangeListener l)`: Registers a listener to receive change events when the slider's value changes.
   - `removeChangeListener(ChangeListener l)`: Removes the specified change listener.
   - `stateChanged(ChangeEvent e)`: Method called when the slider's state changes.

2. **Accessors**:
   - `int getValue()`: Returns the current value of the slider.
   - `void setValue(int value)`: Sets the current value of the slider.
   - `int getMinimum()`: Returns the minimum value of the slider.
   - `void setMinimum(int minimum)`: Sets the minimum value of the slider.
   - `int getMaximum()`: Returns the maximum value of the slider.
   - `void setMaximum(int maximum)`: Sets the maximum value of the slider.
   - `int getExtent()`: Returns the extent, which represents the size of the thumb relative to the range of the slider.
   - `void setExtent(int extent)`: Sets the extent.

3. **Orientation**:
   - `int getOrientation()`: Returns the orientation of the slider (either `JSlider.HORIZONTAL` or `JSlider.VERTICAL`).
   - `void setOrientation(int orientation)`: Sets the orientation of the slider.

4. **Labels**:
	- **`setLabelTable(Dictionary labels)`**:
	   - This method sets the table of labels to be displayed at major tick marks on the slider.
	   - You need to pass a `Dictionary` object containing the labels and their corresponding positions on the slider.
	   - Example:
	     ```java
	 Dictionary<Integer, JLabel> labelTable = new Hashtable<>();
	 labelTable.put(0, new JLabel("Min"));
	 labelTable.put(50, new JLabel("Mid"));
	 labelTable.put(100, new JLabel("Max"));
	 slider.setLabelTable(labelTable);
     ```
	- **`createStandardLabels(int increment)`**:
	   - This method creates a set of standard labels at regular intervals specified by the `increment` parameter.
	   - It returns a `Dictionary` containing the labels and their positions.
	   - Example:
	     ```java
	 slider.setLabelTable(slider.createStandardLabels(10));
	     ```
	- **`setPaintLabels(boolean b)`**:
	   - This method enables or disables painting of labels at major tick marks on the slider.
	   - Pass `true` to display labels or `false` to hide them.
	   - Example:
	     ```java
	 slider.setPaintLabels(true);
     ```

**Options**

In Swing, `JSlider` provides additional options to customize its behavior. Let's explore two of these options: "snap-to-ticks" and inverting the range.

1. **Snap-to-Ticks**:
   - This feature automatically moves the knob to the nearest tick mark when the user stops moving it.
   - **Method**: `setSnapToTicks(boolean on)`
     - When `on` is `true`, the knob snaps to the nearest tick mark automatically.
   - **Usage**:
     ```java
     slider.setSnapToTicks(true);
     ```
   - **Effect**: When enabled, the knob will always land on a tick mark when moved.

2. **Inverting the Range**:
   - This option reverses the direction of the slider's range.
   - **Method**: `setInverted(boolean on)`
     - When `on` is `true`, the range is inverted.
   - **Usage**:
     ```java
     slider.setInverted(true);
     ```
   - **Effect**: The slider's range is displayed in the reverse direction, e.g., from right to left instead of left to right.

Additionally, you can set the preferred size of the slider using `setPreferredSize()` to ensure it fits well within your user interface layout. This allows you to customize the appearance of the slider according to your application's design.

### JProgressBar

In Swing, `JProgressBar` is used to visually represent the progress of a task. It provides feedback to the user about the status of an operation.

```java
import javax.swing.*;
import javax.swing.event.*;
import java.awt.*;

public class ProgressBarExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame("Progress Bar Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        // Create a progress bar
        JProgressBar progressBar = new JProgressBar();
        progressBar.setStringPainted(true); // Display string representation
        progressBar.setMinimum(0);
        progressBar.setMaximum(100);
        
        // Create a timer to simulate progress updates
        Timer timer = new Timer(1000, e -> {
            int value = progressBar.getValue();
            if (value < 100) {
                value += 10; // Increment progress by 10
                progressBar.setValue(value);
            } else {
                ((Timer)e.getSource()).stop(); // Stop the timer when progress reaches 100
            }
        });
        
        // Add a change listener to the progress bar
        progressBar.addChangeListener(new ChangeListener() {
            public void stateChanged(ChangeEvent e) {
                JProgressBar progressBar = (JProgressBar) e.getSource();
                if (progressBar.getValue() == 100) {
                    // Perform action when progress reaches 100
                    JOptionPane.showMessageDialog(frame, "Task completed!");
                }
            }
        });
        
        // Start the timer
        timer.start();
        
        // Add the progress bar to the frame
        frame.getContentPane().add(progressBar, BorderLayout.CENTER);
        
        // Set frame properties
        frame.setSize(300, 100);
        frame.setVisible(true);
    }
}
```

1. **Constructor**:
   - `JProgressBar()` : Creates a horizontal progress bar with default minimum and maximum values (0 and 100) and initial value (0).
   - `JProgressBar(int orient)` : Creates a progress bar with the specified orientation (`JProgressBar.HORIZONTAL` or `JProgressBar.VERTICAL`) and default minimum, maximum, and initial values.
   - `JProgressBar(int min, int max)` : Creates a horizontal progress bar with the specified minimum and maximum values and initial value (equal to the minimum value).
   - `JProgressBar(int orient, int min, int max)` : Creates a progress bar with the specified orientation, minimum, maximum, and initial values.
   - `JProgressBar(BoundedRangeModel newModel)` : Creates a progress bar using the specified data model.

2. **Orientation**:
   - `JProgressBar.HORIZONTAL` : Indicates a horizontal progress bar (default).
   - `JProgressBar.VERTICAL` : Indicates a vertical progress bar.

3. **Setting Progress**:
   - `setValue(int n)` : Sets the current value of the progress bar.
   - `setMinimum(int n)` : Sets the minimum value of the progress bar.
   - `setMaximum(int n)` : Sets the maximum value of the progress bar.
   - `setIndeterminate(boolean newValue)` : Sets the indeterminate state of the progress bar. When set to `true`, the progress bar continuously cycles to indicate that the task is ongoing and the progress is indeterminate.
   - `isIndeterminate()`: It returns true if the progress bar is in an indeterminate state and false otherwise.

4. **Getting Progress**:
   - `getValue()` : Retrieves the current value of the progress bar.
   - `getMinimum()` : Retrieves the minimum value of the progress bar.
   - `getMaximum()` : Retrieves the maximum value of the progress bar.

5. **String Representation**:
   - `setStringPainted(boolean b)` : Sets whether or not the progress bar should render its string representation.
   - `setString(String s)` : Sets the string to be displayed on the progress bar.
   - `getString()`: It returns the current string.
   - `isStringPainted()`: If it returns true, the string is displayed. Otherwise, the string is not displayed.

6. **Appearance**:
   - `setForeground(Color c)` : Sets the foreground color of the progress bar.
   - `setBackground(Color c)` : Sets the background color of the progress bar.
   - `setBorder(Border border)` : Sets the border of the progress bar.
   - `setBorderPainted(boolean on)`: If on is true, the border is painted. If it is false, the border is removed.
   - `isBorderPainted()`: It returns true if the border is painted and false otherwise.

7. **Listeners**:
   - `addChangeListener(ChangeListener listener)` : Registers a listener to receive change events from the progress bar.

### JTabbedPane

The `JTabbedPane` component in Swing provides a tabbed pane layout, allowing users to navigate between multiple panels using tabs. Here are its constructors and some of its key methods:

**Constructors:**

1. **Default Constructor**:
   - `JTabbedPane()`: Constructs a new tabbed pane with no tabs.

2. **Constructor with Tab Placement**:
   - `JTabbedPane(int tabPlacement)`: Constructs a new tabbed pane with the specified tab placement. The `tabPlacement` parameter can be one of the following constants:
     - `JTabbedPane.TOP`: Tabs are placed at the top of the tabbed pane.
     - `JTabbedPane.BOTTOM`: Tabs are placed at the bottom of the tabbed pane.
     - `JTabbedPane.LEFT`: Tabs are placed on the left side of the tabbed pane.
     - `JTabbedPane.RIGHT`: Tabs are placed on the right side of the tabbed pane.

3. **Constructor with Tab Placement and Tab Layout Policy**:
   - `JTabbedPane(int tabPlacement, int tabLayoutPolicy)`: Constructs a new tabbed pane with the specified tab placement and tab layout policy. The `tabPlacement` parameter specifies the placement of tabs, and the `tabLayoutPolicy` parameter can be one of the following constants:
     - `JTabbedPane.WRAP_TAB_LAYOUT`: Wrap tab layout policy. If tabs exceed the available width, they are wrapped to the next line.
     - `JTabbedPane.SCROLL_TAB_LAYOUT`: Scroll tab layout policy. If tabs exceed the available width, a scrollbar is provided for navigation.

**Methods:**

1. **Adding Tabs**:
   - `addTab(String title, Component component)`: Adds a new tab with the specified title and component.
   - `insertTab(String title, Icon icon, Component component, String tip, int index)`: Inserts a new tab at the specified index with the given title, icon, and component.

2. **Removing Tabs**:
   - `remove(int index)`: Removes the tab at the specified index.
   - `remove(Component component)`: Removes the tab containing the specified component.

3. **Tab Properties**:
   - `setTitleAt(int index, String title)`: Sets the title of the tab at the specified index.
   - `setToolTipTextAt(int index, String toolTipText)`: Sets the tooltip text for the tab at the specified index.
   - `setIconAt(int index, Icon icon)`: Sets the icon for the tab at the specified index.

4. **Navigating Tabs**:
   - `setSelectedIndex(int index)`: Sets the selected tab to the one at the specified index.
   - `getSelectedIndex()`: Returns the index of the currently selected tab.

5. **Tab Layout and Rendering**:
   - `setTabLayoutPolicy(int policy)`: Sets the tab layout policy (either `JTabbedPane.WRAP_TAB_LAYOUT` or `JTabbedPane.SCROLL_TAB_LAYOUT`).
   - `setTabPlacement(int placement)`: Sets the placement of the tabs (e.g., `JTabbedPane.TOP`, `JTabbedPane.BOTTOM`, `JTabbedPane.LEFT`, or `JTabbedPane.RIGHT`).

6. **Events**:
   - `addChangeListener(ChangeListener listener)`: Registers a listener to be notified when the selected tab changes.
   - `removeChangeListener(ChangeListener listener)`: Unregisters a change listener.

**Example 1**

```java
import javax.swing.*;

public class TabbedPaneExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame("Tabbed Pane Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JTabbedPane tabbedPane = new JTabbedPane();
        tabbedPane.addTab("Tab 1", new JLabel("Content for Tab 1"));
        tabbedPane.addTab("Tab 2", new JLabel("Content for Tab 2"));

        frame.getContentPane().add(tabbedPane);
        frame.setSize(300, 200);
        frame.setVisible(true);
    }
}
```

**Other Features**

- **Set the foreground color of a tab**: You can set the foreground color of a specific tab by calling the `setForegroundAt(int tabIndex, Color color)` method.
  
- **Set the background color of a tab**: To set the background color of a tab, use the `setBackgroundAt(int tabIndex, Color color)` method.

- **Set a keyboard mnemonic for a tab**: You can specify a keyboard mnemonic for a tab using the `setMnemonicAt(int tabIndex, int mnemonic)` method. The mnemonic is a key code that can be pressed in combination with the ALT key to select the tab.

- **Select a tab under program control**: To programmatically select a tab, use the `setSelectedIndex(int index)` method. Pass the index of the tab you want to select.

- **Enable or disable a tab under program control**: You can enable or disable a tab programmatically using the `setEnabledAt(int tabIndex, boolean enabled)` method. Set the `enabled` parameter to `true` to enable the tab and `false` to disable it.

- **Determine the enabled state of a tab**: To check if a tab is enabled, use the `isEnabledAt(int tabIndex)` method. It returns `true` if the tab at the specified index is enabled, otherwise `false`.

- **Specify a disabled icon for a tab**: If you want to provide a different icon for a disabled tab, you can use the `setDisabledIconAt(int tabIndex, Icon icon)` method.


```java
import javax.swing.*;
import java.awt.*;

public class TabbedPaneCustomizationExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame("TabbedPane Customization Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JTabbedPane tabbedPane = new JTabbedPane();

        // Add tabs with labels
        tabbedPane.addTab("Tab 1", new JLabel("Content for Tab 1"));
        tabbedPane.addTab("Tab 2", new JLabel("Content for Tab 2"));

        // Customize tab properties
        tabbedPane.setForegroundAt(0, Color.BLUE); // Set foreground color of first tab
        tabbedPane.setBackgroundAt(1, Color.YELLOW); // Set background color of second tab
        tabbedPane.setMnemonicAt(0, KeyEvent.VK_1); // Set mnemonic for first tab (Alt+1)
        tabbedPane.setSelectedIndex(1); // Select second tab programmatically
        tabbedPane.setEnabledAt(1, false); // Disable second tab
        tabbedPane.setDisabledIconAt(1, UIManager.getIcon("OptionPane.errorIcon")); // Set disabled icon for second tab

        // Add the tabbedPane to the frame
        frame.getContentPane().add(tabbedPane);

        // Set frame properties
        frame.setSize(300, 200);
        frame.setVisible(true);
    }
}
```

### JSplitPane

`JSplitPane` is a Swing component that provides a way to divide two components in a container with a draggable divider. This allows users to adjust the relative sizes of the two components. Here are some key aspects and constructors of `JSplitPane`:

**Key Aspects:**

1. **Divider**: A draggable divider separates the two components in the split pane. Users can adjust the size of each component by dragging the divider.
  
2. **Orientation**: `JSplitPane` can be either horizontally or vertically oriented. The orientation determines whether the components are arranged side by side or top to bottom.
  
3. **Resize Weight**: The resize weight determines how extra space is distributed among the components when the split pane is resized. Components with higher resize weights receive more extra space.
  
4. **Continuous Layout**: When set to `true`, the split pane continuously lays out its components during resizing. This means that the components are resized in real-time as the divider is dragged.

5. **One-Touch Expandable**: If set to `true`, the split pane provides buttons to quickly expand one of the components to its maximum size.

**Constructors:**

1. `JSplitPane()`: Creates a horizontal split pane with two initially empty components.

2. `JSplitPane(int newOrientation)`: Creates a split pane with the specified orientation (`JSplitPane.HORIZONTAL_SPLIT` or `JSplitPane.VERTICAL_SPLIT`).

3. `JSplitPane(int newOrientation, boolean newContinuousLayout)`: Creates a split pane with the specified orientation and continuous layout behavior (continuously redraw the components as the divider moves).

4. `JSplitPane(int newOrientation, boolean newContinuousLayout, Component newLeftComponent, Component newRightComponent)`: Creates a split pane with the specified orientation, continuous layout behavior, and initial left and right components.

5. `JSplitPane(int newOrientation, Component newLeftComponent, Component newRightComponent)`: Creates a split pane with the specified orientation and initial left and right components.

6. `JSplitPane(int newOrientation, Component newLeftComponent, Component newRightComponent, Component newDivider)`: Creates a split pane with the specified orientation, left and right components, and divider component.

**Example:**

```java
import javax.swing.*;

public class SplitPaneExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame("SplitPane Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        // Create two panels to be placed in the split pane
        JPanel panel1 = new JPanel();
        JPanel panel2 = new JPanel();

        // Create a split pane with horizontal orientation
        JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, panel1, panel2);

        // Set the resize weight to evenly distribute extra space
        splitPane.setResizeWeight(0.5);

        // Set continuous layout for smooth resizing
        splitPane.setContinuousLayout(true);

        // Add the split pane to the frame
        frame.getContentPane().add(splitPane);

        // Set frame properties
        frame.setSize(400, 300);
        frame.setVisible(true);
    }
}
```

**Methods**

1. **getDividerLocation() / setDividerLocation(int location)**:
   - `getDividerLocation()` retrieves the current location of the divider (the position of the divider's left edge for horizontal split pane or top edge for vertical split pane).
   - `setDividerLocation(int location)` sets the location of the divider. The location parameter specifies the new position of the divider.

2. **setResizeWeight(double value)**:
   - Sets the resize weight for the split pane. The resize weight determines how extra space is distributed among the components. Components with higher resize weights receive more extra space.

3. **setContinuousLayout(boolean newContinuousLayout)**:
   - Enables or disables continuous layout. When continuous layout is enabled (`true`), the split pane continuously lays out its components during resizing. This provides a smoother resizing experience.

4. **setOneTouchExpandable(boolean newValue)**:
   - Sets whether the split pane should provide buttons to allow one-touch expanding/collapsing of one of its components.

5. **setDividerSize(int newSize)**:
   - Sets the size of the divider (the width for horizontal split pane or height for vertical split pane).

6. **setLeftComponent(Component comp)** / **setRightComponent(Component comp)**:
   - Sets the left or right component of the split pane.

7. **setTopComponent(Component comp)** / **setBottomComponent(Component comp)**:
   - Sets the top or bottom component of the split pane for vertical split pane.

8. **getTopComponent()** / **getBottomComponent()**:
   - Retrieves the top or bottom component of the split pane for vertical split pane.

9. **getLeftComponent()** / **getRightComponent()**:
   - Retrieves the left or right component of the split pane.

10. **setOrientation(int orientation)**:
    - Sets the orientation of the split pane. The orientation can be either `JSplitPane.HORIZONTAL_SPLIT` or `JSplitPane.VERTICAL_SPLIT`.

11. **setDividerLocation(double proportionalLocation)**:
    - Sets the location of the divider based on a proportional value relative to the size of the split pane.

12. **getUI() / setUI(SplitPaneUI ui)**:
    - Allows customization of the look and feel of the split pane by getting or setting its UI (User Interface).
### JList

A `JList` in Swing is a component that displays a list of items from which the user can make selections. It is a versatile component commonly used in GUI applications for presenting lists of options, data, or elements for the user to choose from. Here's an overview of `JList` and its usage:

- **Constructor**:
   - `JList()` : Creates an empty `JList`.
   - `JList(Object[] items)` : Creates a `JList` that contains the items specified by the array `items`.
   - `JList(Vector<?> items)` : Creates a `JList` that contains the items in the `Vector` specified by `items`.
   - `JList(ListModel<E> model)` : Creates a `JList` that uses the model specified by `model`.

- **Setting Data**:
   - You can populate a `JList` with data by providing either an array of items or a `ListModel` containing the data.
   - Example:
     ```java
     String[] data = {"Item 1", "Item 2", "Item 3"};
     JList<String> list = new JList<>(data);
     ```

- **Selection Modes**:
   - `JList` supports different selection modes such as single selection, multiple selection, and interval selection. You can set the selection mode using the `setSelectionMode(int mode)` method.
   - Example:
     ```java
     list.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
     ```
	- **SINGLE_SELECTION**: Allows only one item to be selected at a time.
	- **SINGLE_INTERVAL_SELECTION**: Allows contiguous selection of multiple items using a single click and drag.
	- **MULTIPLE_INTERVAL_SELECTION**: Allows non-contiguous selection of multiple items using Ctrl or Shift key modifiers.

- **Adding Listeners**:
   - You can add listeners to a `JList` to detect selection changes or other events. Common listeners include `ListSelectionListener` and `MouseListener`.
   - Example:
     ```java
     list.addListSelectionListener(e -> {
         // Handle selection change event
     });
     ```
    
- **Scroll Panes**:
   - If the number of items exceeds the visible area of the `JList`, you can place it within a `JScrollPane` to enable scrolling.
   - Example:
     ```java
     JScrollPane scrollPane = new JScrollPane(list);
     ```

- **Manipulating Data**:
   - You can manipulate the data displayed in a `JList` by modifying the underlying `ListModel` or array. Common methods include `addElement(E element)`, `removeElement(E element)`, and `clear()`.
   - Example:
     ```java
     DefaultListModel<String> model = new DefaultListModel<>();
     JList<String> list = new JList<>(model);
     model.addElement("New Item");
     ```

- **ListSelectionListener**:
   - You can add a `ListSelectionListener` to a `JList` to detect changes in the selection. This listener interface has a method called `valueChanged(ListSelectionEvent e)` that is invoked whenever the selection in the list changes.
   - Example:
     ```java
     list.addListSelectionListener(new ListSelectionListener() {
         public void valueChanged(ListSelectionEvent e) {
             if (!e.getValueIsAdjusting()) {
                 // Handle selection change here
                 int selectedIndex = list.getSelectedIndex();
                 // Perform actions based on the selected index
             }
         }
     });
     ```
   - In this example, `getValueIsAdjusting()` is used to ensure that the event is not fired multiple times during a single selection change.

- **getSelectedIndex**:
   - You can use the `getSelectedIndex()` method to retrieve the index of the currently selected item in the list. If no item is selected, this method returns `-1`.
   - Example:
     ```java
     int selectedIndex = list.getSelectedIndex();
     ```

- **setSelectedIndex**:
    - The `setSelectedIndex(int index)` method allows you to programmatically select an item in the list by specifying its index. This method deselects any previously selected items.
    - Example:
      ```java
      list.setSelectedIndex(2); // Selects the item at index 2
      ```

- **getSelectedIndices**:
    - If your list allows multiple selections, you can use the `getSelectedIndices()` method to retrieve an array of indices corresponding to the selected items.
    - Example:
      ```java
      int[] selectedIndices = list.getSelectedIndices();
      ```

- **getSelectedValue**:
    - The `getSelectedValue()` method returns the value of the first selected item in the list, or `null` if no item is selected.
    - Example:
      ```java
      Object selectedValue = list.getSelectedValue();
      ```

- **setSelectedValue**:
    - Use the `setSelectedValue(Object anObject, boolean shouldScroll)` method to programmatically select an item in the list by specifying its value. If `shouldScroll` is `true`, the list will scroll to make the selected item visible.
    - Example:
      ```java
      list.setSelectedValue("Apple", true); // Selects the item with value "Apple"
      ```

- **getSelectedValues**:
    - If your list allows multiple selections, you can use the `getSelectedValues()` method to retrieve an array of objects corresponding to the selected items.
    - Example:
      ```java
      Object[] selectedValues = list.getSelectedValues();
      ```

- **clearSelection**:
    - The `clearSelection()` method clears the selection in the list, deselecting all selected items.
    - Example:
      ```java
      list.clearSelection();
      ```

- **isSelectionEmpty**:
    - You can use the `isSelectionEmpty()` method to check if the list currently has any selected items. It returns `true` if the selection is empty, and `false` otherwise.
    - Example:
      ```java
      boolean isEmpty = list.isSelectionEmpty();
      ```

- **getAnchorSelectionIndex**:
    - The `getAnchorSelectionIndex()` method returns the index of the anchor selection. This is useful in multiple selection scenarios where an anchor point is established.
    - Example:
      ```java
      int anchorIndex = list.getAnchorSelectionIndex();
      ```

- **getLeadSelectionIndex**:
    - Similarly, the `getLeadSelectionIndex()` method returns the index of the lead selection. This is useful in multiple selection scenarios where a lead point is established.
    - Example:
      ```java
      int leadIndex = list.getLeadSelectionIndex();
      ```

- **setSelectionInterval**:
   - If your list supports multiple selections, you can use the `setSelectionInterval(int anchor, int lead)` method to set the selection to the contiguous range of items between the indices specified by `anchor` and `lead`, inclusive.
   - Example:
     ```java
     list.setSelectionInterval(2, 5); // Selects items from index 2 to 5
     ```

- **setListData**:
   - The `setListData(Object[] listData)` method replaces the current contents of the list with the elements from the specified array `listData`.
   - Example:
     ```java
     String[] newData = {"Apple", "Banana", "Orange"};
     list.setListData(newData);
     ```

- **getValueIsAdjusting**:
   - The `getValueIsAdjusting()` method returns `true` if the value is still in the process of being changed; otherwise, it returns `false`.
   - Example:
     ```java
     boolean isAdjusting = list.getValueIsAdjusting();
     ```

- **Custom Rendering**:
   - When you want to customize the appearance of items in a JList, you can implement a custom cell renderer.
	- **ListCellRenderer Interface**:
	  - The `ListCellRenderer` interface is used to customize how items are displayed within a JList. It's a generic interface that allows you to specify the type of the elements in your list.
	  - The primary method you need to implement is `getListCellRendererComponent`, which is responsible for creating and returning a component that will be used to render each cell in the list.
	- **getListCellRendererComponent**:
	  - This method is defined by the `ListCellRenderer` interface. It is where you define the custom rendering logic for your list items.
	  - It typically receives parameters such as the list itself, the value to be rendered, the index of the cell being rendered, and whether the cell is selected or focused.
	  - Inside this method, you create and configure the component that will represent the list item based on the provided parameters.
	- **setCellRenderer**:
	  - The `setCellRenderer(ListCellRenderer<? super E> renderer)` method of the JList class is used to set a custom cell renderer for the list.
	  - You pass an instance of a class that implements the `ListCellRenderer` interface as an argument to this method.
	  - After setting the cell renderer, the `getListCellRendererComponent` method of your custom renderer will be called automatically for each item in the list to render its appearance.
	```java
import javax.swing.*;
import java.awt.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

public class CustomListRendererExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("Custom List Renderer Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            
            // Sample data for the list
            String[] data = {"Apple", "Banana", "Orange", "Grapes", "Watermelon"};
            
            // Create a JList with sample data
            JList<String> list = new JList<>(data);
            
            // Set custom cell renderer
            list.setCellRenderer(new CustomCellRenderer());
            
            // Add selection listener
            list.addListSelectionListener(new ListSelectionListener() {
                @Override
                public void valueChanged(ListSelectionEvent e) {
                    if (!e.getValueIsAdjusting()) {
                        System.out.println("Selected item: " + list.getSelectedValue());
                    }
                }
            });
            
            // Add the list to a JScrollPane
            JScrollPane scrollPane = new JScrollPane(list);
            
            // Add the scroll pane to the frame
            frame.getContentPane().add(scrollPane);
            
            frame.setSize(300, 200);
            frame.setVisible(true);
        });
    }
    
    // Custom cell renderer class
    static class CustomCellRenderer extends JLabel implements ListCellRenderer<String> {
        private static final Color SELECTED_COLOR = Color.YELLOW;
        private static final Color UNSELECTED_COLOR = Color.WHITE;
        
        public CustomCellRenderer() {
            setOpaque(true);
            setBorder(new EmptyBorder(5, 10, 5, 10));
        }
        
        @Override
        public Component getListCellRendererComponent(JList<? extends String> list, String value, int index, boolean isSelected, boolean cellHasFocus) {
            setText(value);
            
            // Set background color based on selection
            if (isSelected) {
                setBackground(SELECTED_COLOR);
            } else {
                setBackground(UNSELECTED_COLOR);
            }
            
            return this;
        }
    }
}
	```

### ListModel

The ListModel interface in Java Swing provides a structured way to manage the data for a JList component. It defines the methods necessary to interact with the underlying data structure represented by the JList.

Here are the key methods defined by the ListModel interface:

1. `int getSize()`: Returns the number of elements in the list.

2. `Object getElementAt(int index)`: Returns the element at the specified index in the list.

3. `void addListDataListener(ListDataListener l)`: Adds a ListDataListener to the model to receive notifications about changes to the data.

4. `void removeListDataListener(ListDataListener l)`: Removes a previously added ListDataListener from the model.

ListModel implementations typically manage a collection of data elements, such as an array or a collection, and provide methods to add, remove, and update elements. 

Here's a simple example of a custom ListModel implementation using an ArrayList:

```java
import javax.swing.*;
import javax.swing.event.*;
import java.util.*;

class MyListModel extends AbstractListModel<String> {
    private List<String> data;

    public MyListModel() {
        data = new ArrayList<>();
    }

    public void addElement(String element) {
        data.add(element);
        int index = data.size() - 1;
        fireIntervalAdded(this, index, index);
    }

    public void removeElement(String element) {
        int index = data.indexOf(element);
        if (index != -1) {
            data.remove(element);
            fireIntervalRemoved(this, index, index);
        }
    }

    @Override
    public int getSize() {
        return data.size();
    }

    @Override
    public String getElementAt(int index) {
        return data.get(index);
    }
}

public class ListModelExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("ListModel Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            MyListModel model = new MyListModel();
            JList<String> list = new JList<>(model);

            model.addElement("Apple");
            model.addElement("Banana");
            model.addElement("Orange");

            list.addListSelectionListener(new ListSelectionListener() {
                public void valueChanged(ListSelectionEvent e) {
                    if (!e.getValueIsAdjusting()) {
                        System.out.println("Selected: " + list.getSelectedValue());
                    }
                }
            });

            frame.getContentPane().add(new JScrollPane(list));
            frame.setSize(200, 200);
            frame.setVisible(true);
        });
    }
}
```

### DefaultListModel

The DefaultListModel class in Java Swing is an implementation of the ListModel interface that provides a default implementation for managing a list of elements. It extends the AbstractListModel class and is often used with JList components to provide a simple way to manage the data displayed in the list.

Here are some key features and methods provided by the DefaultListModel class:

1. **Addition and Removal of Elements**:
   - `void add(int idx, Object item)`: Adds item at the index specified by idx.
   - `void addElement(E element)`: Adds the specified element to the end of the list.
   - `void insertElementAt(E element, int index)`: Inserts the specified element at the specified index in the list.
   - `void remove(int idx)`: Removes the Item at the index specified by idx, returning the item in the process.
   - `void removeElement(Object element)`: Removes the first occurrence of the specified element from the list.
   - `void removeElementAt(int index)`: Removes the element at the specified index from the list.
   - `void removeRange(int start, int end)`: Removes the range of elements specified by start and end, inclusive. Also, start must not be greater than end.

3. **Accessing Elements**:
   - `E get(int index)`: Returns the element at the specified index in the list.
   - `int indexOf(Object element)`: Returns the index of the first occurrence of the specified element in the list.
   - `int getSize()`: Returns the number of elements in the list.

4. **List Modification Events**:
   - The DefaultListModel class automatically generates ListDataEvents to notify registered ListDataListeners whenever the contents of the list change.

5. **List Manipulation**:
   - `void clear()`: Removes all elements from the list.
   - `void removeAllElements()`: Removes all elements from the list.

Using DefaultListModel simplifies the management of data in JList components by providing methods for adding, removing, and accessing elements in a list-like manner.

Here's a simple example demonstrating the usage of DefaultListModel with a JList:

```java
import javax.swing.*;

public class DefaultListModelExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("DefaultListModel Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            DefaultListModel<String> model = new DefaultListModel<>();
            JList<String> list = new JList<>(model);

            model.addElement("Apple");
            model.addElement("Banana");
            model.addElement("Orange");

            frame.getContentPane().add(new JScrollPane(list));
            frame.setSize(200, 200);
            frame.setVisible(true);
        });
    }
}
```

### JComboBox

The JComboBox class in Java Swing provides a drop-down list of items from which the user can select one item at a time. It's a versatile component commonly used in graphical user interfaces to offer users a selection of options.

Here are some key features and methods provided by the JComboBox class:

1. **Construction**:
   - `JComboBox()`: Creates an empty JComboBox with no items.
   - `JComboBox(E[] items)`: Creates a JComboBox initialized with an array of items.
   - `JComboBox(Vector<E> items)`: Creates a JComboBox initialized with a Vector of items.
   - `JComboBox(ComboBoxModel cbm)`: Creates a combo box that uses the model specified by cbm.

2. **Adding and Removing Items**:
   - `void addItem(E item)`: Adds an item to the end of the combo box's item list.
   - `void insertItemAt(E item, int index)`: Inserts an item into the combo box's item list at the specified index.
   - `void removeItem(Object item)`: Removes the first occurrence of the specified item from the combo box's item list.
   - `void removeItemAt(int index)`: Removes the item at the specified index from the combo box's item list.
   - `void removeAllItems()`: Removes all items from the combo box's item list.
   - `int getItemCount()`: Returns the size of the list.

3. **Selection and Accessing Items**:
   - `Object getSelectedItem()`: Returns the currently selected item, or null if nothing is selected.
   - `int getSelectedIndex()`: It returns the zero-based index of the selected item in the list. If no item is selected, -1 is returned.
   - `void setSelectedltem(Object item)`: Select an item in the list under program control by specifying the item.
   - `void setSelectedIndex(int idx)`: Select an item in the list under program control by specifying the index.
   - `E getItemAt(int index)`: Returns the item at the specified index.
   - `int getItemCount()`: Returns the number of items in the combo box.

4. **Handling Selection Events**:
   - JComboBox generates ActionEvents when an item is selected. You can register ActionListener to respond to these events.

5. **Custom Rendering**:
   - You can customize the appearance of items in the combo box by providing a custom renderer using the `setRenderer(ListCellRenderer<? super E> renderer)` method.

6. **Editable JComboBox**:
   - JComboBox can be set to allow users to enter their own text by calling `setEditable(true)`. This allows users to either select an item from the list or type their own value.

7. **Popup Visibility**:
   - `void setPopupVisible(boolean v)`: Sets the visibility of the popup list.
   - `void hidePopup()`: Hides the pop-up list.
   - `void setEnabled(boolean enabled)`: If enable is true, the combo box is enabled. If it is false, the combo box is disabled.
   - `boolean isPopupVisible()`: Returns true if the pop-up list is currently displayed and false otherwise.

8. **Autocomplete**:
   - JComboBox provides auto-completion support, where typing characters automatically selects the first item that matches the typed characters.

9. **Popup Menu Customization**:
   - You can customize the appearance and behavior of the popup menu by providing a custom popup menu using the `setUI(ComboBoxUI ui)` method.

10. **Listeners**:
	- You can add ActionListener, ItemListener, and PopupMenuListener to handle various events related to JComboBox.

11. **Accessing the Model**:
	- `ComboBoxModel getModel()`: Returns a reference to the combo box model.
	- `void setModel(ComboBoxModel)`: Set the model.

Here's a simple example demonstrating the usage of JComboBox:

```java
import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class JComboBoxExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("JComboBox Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            String[] items = {"Apple", "Banana", "Orange"};
            JComboBox<String> comboBox = new JComboBox<>(items);

            // Add ActionListener to respond to item selection events
            comboBox.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    // Get the selected item and display it
                    String selected = (String) comboBox.getSelectedItem();
                    JOptionPane.showMessageDialog(frame, "Selected: " + selected);
                }
            });

            // Set selected index and editable
            comboBox.setSelectedIndex(1); // Select "Banana" initially
            comboBox.setEditable(true); // Allow user to type their own value

            frame.getContentPane().add(comboBox);
            frame.setSize(200, 100);
            frame.setVisible(true);
        });
    }
}
```

### JSpinner

A `JSpinner` is a Swing component that provides a user interface for selecting a value from a bounded range, such as numbers, dates, or predefined options. It typically consists of a text field and a pair of arrow buttons for incrementing or decrementing the value.

**Constructors**:
- `JSpinner()`: Creates a spinner with default settings.
- `JSpinner(SpinnerModel model)`: Creates a spinner with the specified model.
- `JSpinner(NumberModel model)`: Creates a spinner for numbers with the specified model.
- `JSpinner(ListModel model)`: Creates a spinner for lists with the specified model.
- `JSpinner(ComboBoxModel model)`: Creates a spinner for combo boxes with the specified model.

**SpinnerModel**:
The `SpinnerModel` interface defines the data model for a spinner. It includes methods to get and set the value, the minimum and maximum allowed values, and the step size.

**NumberModel**:
The `NumberModel` interface extends `SpinnerModel` and is specifically designed for numeric values. It provides additional methods to handle number-related operations.

**ListModel and ComboBoxModel**:
These interfaces extend `SpinnerModel` and are used for spinners that allow selection from a list or a combo box, respectively.

**Common Methods**:
- `getValue()`: Retrieves the current value of the spinner.
- `setValue(Object value)`: Sets the value of the spinner.
- `getMinimum()`, `setMinimum(Object minimum)`: Gets or sets the minimum allowed value.
- `getMaximum()`, `setMaximum(Object maximum)`: Gets or sets the maximum allowed value.
- `getStepSize()`, `setStepSize(Object stepSize)`: Gets or sets the step size for numeric spinners.
- `getModel()`, `setModel(SpinnerModel model)`: Gets or sets the spinner's model.
- `getEditor()`: Gets the editor component used for editing the spinner's value.

**Handling Events**:
- `ChangeListener`: Used to listen for changes in the spinner's value. Implement the `stateChanged()` method to handle value change events.

**Customization**:
- You can customize the appearance and behavior of a spinner by providing custom models, editors, and renderers.
- Use methods like `setEditor(JComponent editor)` to set a custom editor component for the spinner.

**Example**:
```java
import javax.swing.*;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

public class SpinnerExample {
    public static void main(String[] args) {
        // Create a SpinnerNumberModel with initial value, minimum, maximum, and step
        SpinnerModel model = new SpinnerNumberModel(5, 1, 10, 1);

        // Create a JSpinner with the SpinnerModel
        JSpinner spinner = new JSpinner(model);

        // Add a ChangeListener to listen for value changes
        spinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                // Get the current value from the spinner model
                int value = (int) spinner.getValue();
                System.out.println("Selected value: " + value);
            }
        });

        // Create a JFrame to hold the spinner
        JFrame frame = new JFrame("Spinner Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.getContentPane().add(spinner);
        frame.pack();
        frame.setVisible(true);
    }
}
```

### SpinnerModel

The `SpinnerModel` interface in Java Swing provides the foundation for controlling the behavior and data of a spinner component. It defines the methods needed to manage the spinner's value, range, and other properties. Here are the key aspects of the `SpinnerModel` interface:

**Interface Overview:**
- **Purpose**: Defines the data model for a spinner component.
- **Package**: `javax.swing`
- **Implementations**: `AbstractSpinnerModel`, `SpinnerNumberModel`, `SpinnerListModel`, `SpinnerDateModel`, etc.

**Methods:**
1. `Object getValue()`: Returns the current value of the spinner.
2. `void setValue(Object value)`: Sets the current value of the spinner.
3. `Object getNextValue()`: Returns the next legal value of the spinner, or `null` if no such value exists.
4. `Object getPreviousValue()`: Returns the previous legal value of the spinner, or `null` if no such value exists.
5. `void addChangeListener(ChangeListener listener)`: Registers a listener to be notified of changes to the spinner's value.
6. `void removeChangeListener(ChangeListener listener)`: Unregisters a change listener from the spinner.

**Implementations:**
1. **AbstractSpinnerModel**: An abstract class that provides a basic implementation of the `SpinnerModel` interface. It's often extended to create custom spinner models.
2. **SpinnerNumberModel**: A concrete implementation of `SpinnerModel` for numeric values. It defines methods to handle integer and floating-point numbers.
3. **SpinnerListModel**: A concrete implementation for spinner models backed by a list of objects.
4. **SpinnerDateModel**: A concrete implementation for spinner models representing dates.

**Usage:**
```java
SpinnerModel model = new SpinnerNumberModel(5, 1, 10, 1); // Initial value, min, max, step
JSpinner spinner = new JSpinner(model);
```

**Customization:**
- You can subclass `AbstractSpinnerModel` to create custom spinner models tailored to specific data types or requirements.
- Implement the `ChangeListener` interface to listen for changes to the spinner's value and react accordingly.

### SpinnerNumberModel

The `SpinnerNumberModel` class in Java Swing is a concrete implementation of the `SpinnerModel` interface designed specifically for handling numeric values. It allows you to create spinner components that enable users to select numerical values within a specified range.

**Overview:**
- **Purpose**: Provides a data model for spinner components that manipulate numeric values.
- **Package**: `javax.swing`
- **Superclass**: `AbstractSpinnerModel`
- **Implemented Interfaces**: `SpinnerModel`

**Constructors:**

1. **Constructor:**
   - `SpinnerNumberModel()`: Creates a default model that is unbounded. Its initial value is 0 and its step size is 1.

2. **Constructor:**
   - `SpinnerNumberModel(int val, int min, int max, int stepSize)`: Creates a model that sets the initial value to `val`, the minimum value to `min`, the maximum value to `max`, and the step size to `stepSize`.

3. **Constructor:**
   - `SpinnerNumberModel(double val, double min, double max, double stepSize)`: Creates a model that sets the initial value to `val`, the minimum value to `min`, the maximum value to `max`, and the step size to `stepSize`.

4. **Constructor:**
   - `SpinnerNumberModel(Number val, Comparable min, Comparable max, Number stepSize)`: Creates a model that sets the initial value to `val` and the step size to `stepSize`. The minimum and maximum bounds are determined by the objects referenced by `min` and `max`.

**Key Methods:**
1. `int getMinimum()`: Returns the minimum value allowed by the spinner model.
2. `void setMinimum(int minimum)`: Sets the minimum value allowed by the spinner model.
3. `int getMaximum()`: Returns the maximum value allowed by the spinner model.
4. `void setMaximum(int maximum)`: Sets the maximum value allowed by the spinner model.
5. `Comparable<?> getStepSize()`: Returns the step size used to increment or decrement the spinner's value.
6. `void setStepSize(Comparable<?> stepSize)`: Sets the step size used to increment or decrement the spinner's value.
7. `void setMinimum(Number minimum)`: Sets the minimum value allowed by the spinner model.
8. `void setMaximum(Number maximum)`: Sets the maximum value allowed by the spinner model.
9. `void setStepSize(Number stepSize)`: Sets the step size used to increment or decrement the spinner's value.
10. `Number getNumber()`: Returns the current value of the spinner as a `Number` object.
11. `void setValue(Number value)`: Sets the current value of the spinner to the specified `Number`.

**Usage Example:**
```java
SpinnerNumberModel model = new SpinnerNumberModel(5, 1, 10, 1); // Initial value, min, max, step
JSpinner spinner = new JSpinner(model);
```

**Customization:**
- You can customize the behavior of the `SpinnerNumberModel` by setting the minimum, maximum, and step size properties to define the range and increment for the spinner's values.
- Implement the `ChangeListener` interface to listen for changes to the spinner's value and perform custom actions in response.

### SpinnerDateModel

The `SpinnerDateModel` class in Java Swing extends `AbstractSpinnerModel` and provides a spinner model specifically tailored for handling date values. It allows users to select a date from a range of dates using a spinner component. Here's an overview of the `SpinnerDateModel` class:

- **Package:** `javax.swing`
- **Extends:** `AbstractSpinnerModel`

**Constructor Summary:**
1. `SpinnerDateModel()`: Constructs a spinner model with the current date, minimum and maximum dates set to `null`, and the calendar field set to `Calendar.DAY_OF_MONTH`.
2. `SpinnerDateModel(Date value, Comparable start, Comparable end, int calendarField)`: Constructs a spinner model with the specified initial date, minimum date, maximum date, and calendar field.

**`Comparable` and `Date` Objects**

A `Date` object can be compared to other `Date` objects using the `compareTo()` method inherited from the `Comparable` interface. This method returns an integer value based on the comparison result:

- If the invoking object is less than the object being compared, it returns a negative integer.
- If they are equal, it returns 0.
- If the invoking object is greater than the object being compared, it returns a positive integer.

For example:

```java
Date date1 = new Date(); // Current date and time
Date date2 = new Date(System.currentTimeMillis() + 10000); // Current date and time + 10 seconds

int comparison = date1.compareTo(date2);
if (comparison < 0) {
    System.out.println("date1 is before date2");
} else if (comparison > 0) {
    System.out.println("date1 is after date2");
} else {
    System.out.println("date1 and date2 are equal");
}
```

Using `Comparable` objects, such as `Date`, allows for easy sorting and comparison operations in Java.

**`calendarField` Property**

The `SpinnerDateModel` class also features a property called `calendarField`, which determines how the date is changed when the spinner value is adjusted. This property defines whether the date changes by day, month, hour, minute, and so on. 

It's important to note that the `calendarField` property can be ignored by the look and feel implementation. In such cases, the field selected by the user will be changed. Therefore, it's advisable not to solely rely on the `calendarField` property for precise control over the spinner behavior.

The `calendarField` property must have a value that corresponds to one of the constants defined by the `Calendar` class, such as:

- `AM_PM`
- `DAY_OF_MONTH`
- `DAY_OF_WEEK`
- `DAY_OF_WEEK_IN_MONTH`
- `DAY_OF_YEAR`
- `ERA`
- `HOUR`
- `HOUR_OF_DAY`
- `MILLISECOND`
- `MINUTE`
- `MONTH`
- `SECOND`
- `WEEK_OF_MONTH`
- `WEEK_OF_YEAR`
- `YEAR`

**Methods:**
1. `Date getDate()`: Returns the current date value of the spinner model.
2. `void setDate(Date value)`: Sets the current date value of the spinner model.
3. `Date getNextValue()`: Returns the next date value in the sequence.
4. `Date getPreviousValue()`: Returns the previous date value in the sequence.
5. `Comparable getStart()`: Returns the minimum date allowed by the spinner model.
6. `void setStart(Comparable start)`: Sets the minimum date allowed by the spinner model. Even though `setEnd()` and `setStart()` use parameters of type `Comparable`, you will usually pass `Date` objects. (`Date` implements `Comparable`.)
8. `Comparable getEnd()`: Returns the maximum date allowed by the spinner model.
9. `void setEnd(Comparable end)`: Sets the maximum date allowed by the spinner model.
10. `int getCalendarField()`: Returns the calendar field used by the spinner model.
11. `void setCalendarField(int calendarField)`: Sets the calendar field used by the spinner model.
12. `void setMinimum(Date minimum)`: Sets the minimum date allowed by the spinner model.
13. `void setMaximum(Date maximum)`: Sets the maximum date allowed by the spinner model.
14. `void setRange(Comparable start, Comparable end)`: Sets the range of dates allowed by the spinner model.

**Example Usage:**
```java
SpinnerDateModel model = new SpinnerDateModel(new Date(), null, null, Calendar.DAY_OF_MONTH);
JSpinner spinner = new JSpinner(model);
```

### SpinnerListModel

The `SpinnerListModel` class in Java Swing extends `AbstractSpinnerModel` and provides a spinner model specifically designed for handling a list of values. It allows users to select items from a predefined list using a spinner component. Here's an overview of the `SpinnerListModel` class:

**Package:** `javax.swing`

**Extends:** `AbstractSpinnerModel`

**Constructor Summary:**
1. `SpinnerListModel(List<?> list)`: Constructs a spinner model with the specified list of items.
2. `SpinnerListModel(Object[] values)`: Constructs a spinner model with the specified array of items.

**Methods:**
1. `Object getValue()`: Returns the current selected value of the spinner model.
2. `void setValue(Object value)`: Sets the current selected value of the spinner model.
3. `Object getNextValue()`: Returns the next value in the sequence.
4. `Object getPreviousValue()`: Returns the previous value in the sequence.
5. `List<?> getList()`: Returns the list of values contained in the spinner model.
6. `void setList(List<?> list)`: Sets the list of values for the spinner model.
7. `void setList(Object[] values)`: Sets the list of values using an array.
8. `boolean contains(Object value)`: Checks if the specified value is present in the list.
9. `int getSize()`: Returns the size of the list.
10. `Object getElementAt(int index)`: Returns the element at the specified index in the list.
11. `void removeChangeListener(ChangeListener cl)`: Removes cl as a listener for change events.

**Example Usage:**
```java
List<String> items = Arrays.asList("Apple", "Banana", "Orange");
SpinnerListModel model = new SpinnerListModel(items);
JSpinner spinner = new JSpinner(model);
```

### JTextField

`JTextField` is a Swing component used for displaying and editing a single line of text. It allows users to input text into a graphical user interface (GUI) application. Here are some key features and functionalities of `JTextField`:

1. **Creating a JTextField**:
   You can create an instance of `JTextField` using its default constructor or by specifying the initial text and column width.

   ```java
   JTextField textField = new JTextField();
   // OR
   JTextField textField = new JTextField("Enter text here", 20); // Initial text and column width
   ```
   You can enter a string that is longer than the number of columns. It's just that the physical size of the text field on the screen will be cols columns wide.

2. **Getting and Setting Text**:
   You can retrieve the text entered by the user using the `getText()` method and set the text programmatically using the `setText()` method.

   ```java
   String text = textField.getText();
   textField.setText("New text");
   ```

3. **Listening for Text Changes**:
   You can add a document listener to the `JTextField` to listen for changes in its text. Document listeners are notified when the text content of the field changes.

   ```java
	// Add a DocumentListener to the text field
	textField.getDocument().addDocumentListener(new DocumentListener() {
		@Override
		public void insertUpdate(DocumentEvent e) {
			// Called when text is inserted into the document
			System.out.println("Text inserted: " + textField.getText());
		}

		@Override
		public void removeUpdate(DocumentEvent e) {
			// Called when text is removed from the document
			System.out.println("Text removed: " + textField.getText());
		}

		@Override
		public void changedUpdate(DocumentEvent e) {
			// Called when attributes of the document change
			System.out.println("Document attributes changed");
		}
	});
   ```

4. **Setting Editability**:
   You can control whether the text field is editable by the user using the `setEditable()` method. If set to `false`, the text field becomes read-only.

   ```java
   textField.setEditable(false); // Make the text field read-only
   ```

5. **Placeholder Text**:
   You can set placeholder text to provide a hint or prompt to the user. Placeholder text is displayed when the text field is empty and does not have focus.

   ```java
   textField.setPlaceholder("Enter your name");
   ```

6. **Selection and Focus**:
   You can programmatically select text within the `JTextField` using the `setSelectionStart()` and `setSelectionEnd()` methods. Additionally, you can request focus for the text field using the `requestFocus()` method.

   ```java
   textField.setSelectionStart(0);
   textField.setSelectionEnd(textField.getText().length());
   textField.requestFocus();
   ```

7. **Keyboard Events**:
   You can listen for keyboard events in the text field by adding a key listener using the `addKeyListener()` method. However, it's recommended to use document listeners for text changes instead.

   ```java
   textField.addKeyListener(new KeyAdapter() {
       @Override
       public void keyTyped(KeyEvent e) {
           // Handle key typed event
       }
   });
   ```

**When User Presses ENTER**

When a user presses ENTER when inputting into a text field, an `ActionEvent` is generated. Therefore, `JTextField` provides the `addActionListener()` and `removeActionListener( )` methods. To handle action events, you must implement the `actionPerformed()` method defined by the `ActionListener` interface.

**`setActionCommand()` and `getActionCommand()`**

Like a `JButton`, a `JTextField` has an action command string associated with it. By default, the action command is the current contents of the text field. However, you can set this to an action command of your choosing by calling the `setActionCommand( )` method.

One reason that you might want to explicitly set the action command is to provide a way to recognize the text field as the source of an action event. This is helpful when another control in the same frame also generates action events and you want to use the same event handler to process both events. Setting the action command gives you a way to tell them apart. For example, in the following program, two text fields are used and each is recognized based on its action command.

```java
jtfl = new JTextField(10);
jtf2 = new JTextField(10);

jtfl.setActionCommand( "One");
jtf2.setActionCommand("Two");

public void actionPerformed(ActionEvent ae) {
	if (ae.getActionCommand().equals("One"))
	{
		jlab.setText("ENTER pressed in tfl:" + jtfl.getText());
	}
	else
	{
		jlab.setText("ENTER pressed in jtf2: " + jtf2.getText());
	}
}
```

**Methods**

- **Text Retrieval and Modification:**

   - `String getText()`: Returns the text contained in the text field.
   - `void setText(String text)`: Sets the text of the text field to the specified string.

- **Selection:**

   - `void selectAll()`: Selects all the text in the text field.
   - `void setSelectionStart(int position)`: Sets the starting position of the selected text.
   - `void setSelectionEnd(int position)`: Sets the ending position of the selected text.
   - `void setSelectionStart(int start)` and `void setSelectionEnd(int end)`: Sets the starting and ending positions of the selected text.

- **Text Navigation:**

   - `void setCaretPosition(int position)`: Sets the position of the text insertion caret.
   - `int getCaretPosition()`: Returns the position of the text insertion caret.

- **Miscellaneous:**

   - `void setEditable(boolean editable)`: Sets whether or not the text field is editable.
   - `void setColumns(int columns)`: Sets the number of columns in the text field.
   - `void setHorizontalAlignment(int alignment)`: Sets the horizontal alignment of the text within the text field.
   - `void setToolTipText(String text)`: Sets the tooltip text that appears when the mouse hovers over the text field.

### JPasswordField

The `JPasswordField` class in Java Swing provides a field for entering passwords, where the characters entered are masked for security purposes. Here are the constructors and some key methods of the `JPasswordField` class:

**Constructors:**

1. `JPasswordField()`:
   - Constructs a new empty password field.

2. `JPasswordField(int columns)`:
   - Constructs a new password field with the specified number of columns.

3. `JPasswordField(String text)`:
   - Constructs a new password field initialized with the specified text.

4. `JPasswordField(String text, int columns)`:
   - Constructs a new password field initialized with the specified text and number of columns.

**Methods:**

1. `char[] getPassword()`:
   - Returns the password entered into this password field as an array of characters.

2. `void setPassword(char[] newPassword)`:
   - Sets the text of this password field to the specified array of characters.

3. `void setEchoChar(char c)`:
   - Sets the echo character for this password field. The echo character is displayed instead of the actual characters when the user types in the field.

4. `char getEchoChar()`:
   - Returns the character to be displayed for each character in the text field.

5. `void setEditable(boolean editable)`:
   - Sets whether or not this text field is editable.

6. `boolean isEditable()`:
   - Determines whether or not this text field is editable.

7. `void selectAll()`:
   - Selects all the text in the text field.

8. `void setSelectionStart(int selectionStart)`:
   - Sets the selection start to the specified position.

9. `int getSelectionStart()`:
   - Returns the starting point of the text that is selected.

10. `void setSelectionEnd(int selectionEnd)`:
    - Sets the selection end to the specified position.

11. `int getSelectionEnd()`:
    - Returns the end point of the text that is selected.

12. `void setHorizontalAlignment(int alignment)`:
    - Sets the alignment of the text in this text field.

13. `int getHorizontalAlignment()`:
    - Returns the horizontal alignment of the text in this text field.

**Event Handling:**

To handle events in a `JPasswordField`, you can use ActionListeners and DocumentListeners.

**Using ActionListener:**

An ActionListener is triggered when the user presses the "Enter" key while the `JPasswordField` has focus.

```java
import javax.swing.*;
import java.awt.event.*;

public class PasswordFieldExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame("Password Field Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JPasswordField passwordField = new JPasswordField(20);
        passwordField.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                char[] password = passwordField.getPassword();
                // Process the password here
                System.out.println("Password entered: " + new String(password));
            }
        });

        frame.getContentPane().add(passwordField);
        frame.setSize(300, 200);
        frame.setVisible(true);
    }
}
```

**Using DocumentListener:**

A DocumentListener is triggered whenever the text in the `JPasswordField` changes.

```java
import javax.swing.*;
import javax.swing.event.*;
import java.awt.*;

public class PasswordFieldExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame("Password Field Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        JPasswordField passwordField = new JPasswordField(20);
        passwordField.getDocument().addDocumentListener(new DocumentListener() {
            public void changedUpdate(DocumentEvent e) {
                // Handle change
                System.out.println("Password changed");
            }

            public void insertUpdate(DocumentEvent e) {
                // Handle insertion
                System.out.println("Character inserted");
            }

            public void removeUpdate(DocumentEvent e) {
                // Handle removal
                System.out.println("Character removed");
            }
        });

        frame.getContentPane().add(passwordField);
        frame.setSize(300, 200);
        frame.setVisible(true);
    }
}
```

### JFormattedTextField

`JFormattedTextField` is a subclass of `JTextField` that allows for the input and display of formatted data. It provides various constructors and methods to work with formatted text. Here are the constructors and some important methods:

**Constructors:**

1. `JFormattedTextField()`: 
   - This constructor creates an empty formatted text field that does not have a formatter associated with it.

2. `JFormattedTextField(Object contents)`: This constructor automatically constructs an `AbstractFormatterFactory` based on the type of data referred to by the `contents` parameter. For example, if `contents` refers to a numeric value like an integer, a formatter for numbers will be created automatically. This approach is convenient for simple formats, but it may not provide the level of control you need in certain cases.

3. `JFormattedTextField(Format fmt)`: This constructor allows you to specify the precise format for the `JFormattedTextField`. The `fmt` parameter is an instance of the `Format` class, which is an abstract class defining the basic nature of a format. Java provides two important classes derived from `Format`: `DateFormat` for date formats and `NumberFormat` for numeric formats. You can create custom formats by extending `Format` or using predefined formats from these classes.
	
	Here's an example of using each constructor:
	
	```java
	import javax.swing.*;
	import java.text.*;
	
	public class JFormattedTextFieldExample {
	    public static void main(String[] args) {
	        // Example using JFormattedTextField(Object contents)
	        JFormattedTextField textField1 = new JFormattedTextField(10); // Automatically handles integers
	
	        // Example using JFormattedTextField(Format fmt)
	        NumberFormat numberFormat = NumberFormat.getNumberInstance(); // Create a number format
	        JFormattedTextField textField2 = new JFormattedTextField(numberFormat); // Use the number format
	
	        // Example using a custom format
	        DateFormat dateFormat = new SimpleDateFormat("MM/dd/yyyy"); // Create a date format
	        JFormattedTextField textField3 = new JFormattedTextField(dateFormat); // Use the date format
	
	        // Add the text fields to a panel and display them
	        JPanel panel = new JPanel();
	        panel.add(textField1);
	        panel.add(textField2);
	        panel.add(textField3);
	
	        JFrame frame = new JFrame("JFormattedTextField Example");
	        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	        frame.getContentPane().add(panel);
	        frame.pack();
	        frame.setVisible(true);
	    }
	}
	```

4. `JFormattedTextField(AbstractFormatter absFmt)`: 
   - This constructor creates an empty formatted text field that uses the abstract formatter specified by the `absFmt` parameter.

5. `JFormattedTextField(AbstractFormatterFactory absFmtFact)`: 
   - This constructor creates an empty formatted text field that uses the abstract formatter factory specified by the `absFmtFact` parameter.

6. `JFormattedTextField(AbstractFormatterFactory absFmtFact, Object contents)`: 
   - This constructor creates a formatted text field that displays the data specified by the `contents` parameter. It uses the abstract formatter factory specified by the `absFmtFact` parameter.


**Methods:**

- **`getValue()`**:
  - Returns the current value of the formatted text field.

- **`setValue(Object value)`**:
  - Sets the value of the formatted text field to the specified object.

- **`commitEdit()`**:
  - Commits the current value of the text field. If the current value is not valid according to the formatter, it will be reverted to the last valid value.

- **`selectAll()`**:
  - Selects all the text in the formatted text field.

- **`setFormatter(AbstractFormatter formatter)`**:
  - Sets the formatter for the text field to the specified abstract formatter.

- **`setFormatterFactory(AbstractFormatterFactory factory)`**:
  - Sets the formatter factory for the text field to the specified abstract formatter factory.

- **`setFocusLostBehavior(int behavior)`**:
  - Sets the behavior for what happens when the formatted text field loses focus.

- **`setColumns(int columns)`**:
  - Sets the preferred number of columns for the text field.

- **`getFormatter()`**:
  - Returns the formatter used by the text field.

- **`getFormatterFactory()`**:
  - Returns the formatter factory used by the text field.

- **`getFocusLostBehavior()`**:
  - Returns the behavior for what happens when the text field loses focus.

- **`getColumns()`**:
  - Returns the preferred number of columns for the text field.

- **`getDocument()`**:
  - Returns the document model for the text field.

- **`setEditValid(boolean isValid)`**:
  - Sets whether the current value of the text field is valid according to the formatter.

- **`isEditValid()`**:
  - Returns `true` if the current value of the text field is valid according to the formatter, otherwise `false`.

**Example**

```java
import javax.swing.*;
import java.awt.event.*;
import java.text.NumberFormat;

public class FormattedTextFieldExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("JFormattedTextField Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            // Create a NumberFormat to format numbers
            NumberFormat format = NumberFormat.getIntegerInstance();

            // Create a JFormattedTextField with the NumberFormat
            JFormattedTextField formattedTextField = new JFormattedTextField(format);

            // Set initial value
            formattedTextField.setValue(0);

            // Add a FocusListener to select all text when the field gains focus
            formattedTextField.addFocusListener(new FocusAdapter() {
                @Override
                public void focusGained(FocusEvent e) {
                    formattedTextField.selectAll();
                }
            });

            // Add an ActionListener to print the current value when Enter is pressed
            formattedTextField.addActionListener(e -> {
                System.out.println("Current value: " + formattedTextField.getValue());
            });

            // Create a button to reset the value
            JButton resetButton = new JButton("Reset");
            resetButton.addActionListener(e -> {
                formattedTextField.setValue(0);
            });

            // Create a panel to hold components
            JPanel panel = new JPanel();
            panel.add(new JLabel("Enter a number: "));
            panel.add(formattedTextField);
            panel.add(resetButton);

            // Add the panel to the frame
            frame.getContentPane().add(panel);
            
            frame.pack();
            frame.setLocationRelativeTo(null); // Center the frame
            frame.setVisible(true);
        });
    }
}
```

**How JFormattedTextField Works**

- **Value vs. Displayed Text**: 
  - The value of a `JFormattedTextField` is distinct from the text displayed in it. 
  - The value is the actual data stored by the component, while the displayed text is a representation of that value.

- **Updating the Value**:
  - When a user enters text, the formatter converts it into the corresponding value.
  - Alternatively, if the value is set programmatically, the formatter converts it into text displayed in the field.

- **Committing Changes**:
  - By default, changes made to the text inside a formatted text field are not reflected in the value until the user presses Enter or moves focus to another field.
  - These changes are "committed" when the text field loses focus or the user presses Enter, and the value is updated to reflect the changes, provided they are valid according to the format.

- **Listening for Value Changes**:
  - To detect changes in a `JFormattedTextField`'s value, you need to listen for property change events rather than action events.
  - Implement the `PropertyChangeListener` interface and override the `propertyChange()` method to handle property change events.

- **Setting and Getting Values**:
  - You can programmatically set the value of a `JFormattedTextField` using the `setValue()` method, and retrieve the current value using the `getValue()` method.

Here's a summary of the methods involved:
```java
void setValue(Object value)
Object getValue()
void addPropertyChangeListener(PropertyChangeListener listener)
void addPropertyChangeListener(String propertyName, PropertyChangeListener listener)
```

These methods allow you to manipulate the value of a `JFormattedTextField` and listen for property change events to respond to value changes.

**Focus Lost Behavior**

The `setFocusLostBehavior()` method in `JFormattedTextField` allows you to specify the behavior of the component when it loses input focus. Here's an explanation of the parameters:

- **Method**: `setFocusLostBehavior(int behavior)`
- **Parameters**:
  - `behavior`: An integer representing the desired focus-lost behavior. It can be one of the following constants defined in the `JFormattedTextField` class:
    - `JFormattedTextField.COMMIT`: Commits a valid entry, updating the value of the component. If the entry is invalid, no change is made to the value.
    - `JFormattedTextField.REVERT`: Reverts the text field to its previous value.
    - `JFormattedTextField.COMMIT_OR_REVERT`: Commits a valid entry, updating the value, or reverts to the previous value if the entry is invalid (default behavior).
    - `JFormattedTextField.PERSIST`: Maintains the current edit without changing the value.

**Example:**
```java
JFormattedTextField formattedTextField = new JFormattedTextField();
formattedTextField.setFocusLostBehavior(JFormattedTextField.REVERT); // Sets focus-lost behavior to revert changes
```

### JTextArea (Empty)



### JEditorPane (Empty)



### JTextPane (Empty)


### JSeparator

The `JSeparator` class in Java Swing is used to create a visual horizontal or vertical line that visually separates components in a container. It doesn't react to user input and is purely for visual organization. Here's a breakdown:

**Constructor:**

- `JSeparator()`: Creates a horizontal separator by default. To create a vertical separator, you need to specify the orientation using `JSeparator.VERTICAL`.

**Methods:**

- `setOrientation(int orientation)`: Sets the orientation of the separator. Use `JSeparator.HORIZONTAL` for a horizontal separator and `JSeparator.VERTICAL` for a vertical separator.
- `getOrientation()`: Retrieves the orientation of the separator.
- Other methods inherited from `JComponent`, such as `setBackground()`, `setForeground()`, etc., for customizing appearance.

**Example Usage:**

```java
import javax.swing.*;

public class MyFrame extends JFrame {
    public MyFrame() {
        super("Separator Example");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
        
        JLabel label1 = new JLabel("Label 1");
        panel.add(label1);
        
        JSeparator separator = new JSeparator();
        panel.add(separator);
        
        JLabel label2 = new JLabel("Label 2");
        panel.add(label2);
        
        add(panel);
        
        setSize(300, 200);
        setVisible(true);
    }
    
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> new MyFrame());
    }
}
```

This code creates a `JFrame` with two `JLabels` separated by a `JSeparator` inside a `JPanel` with a `BoxLayout`. This results in a vertical line separating the two labels. You can adjust the orientation and appearance of the separator as needed for your UI design.

### JCalendar



### JOptionPane

#### showMessageDialog

The `showMessageDialog` method in Java Swing is used to display a simple dialog box with a message. It's often used to show informative messages, warnings, errors, or notifications to the user.

**Method Signature:**

```java
public static void showMessageDialog(Component parentComponent, Object message)
```

**Parameters:**

- `parentComponent`: The parent component of the dialog box. It's typically the `JFrame` or `JDialog` to which the dialog is associated. Can be `null`.
- `message`: The message to be displayed in the dialog box. It can be a string, an icon, or any other object that needs to be displayed.

**Example Usage:**

```java
import javax.swing.*;

public class MessageDialogExample {
    public static void main(String[] args) {
        // Create a JFrame
        JFrame frame = new JFrame("Message Dialog Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        // Show a simple message dialog
        JOptionPane.showMessageDialog(frame, "Hello, World!");

        // Set JFrame size and make it visible
        frame.setSize(300, 200);
        frame.setVisible(true);
    }
}
```

In this example, we create a `JFrame` and display a message dialog with the text "Hello, World!". The dialog box is associated with the frame as the parent component. When you run this code, a dialog box will appear with the specified message.

**Versions**

1. **Basic Message Dialog**:
   ```java
   showMessageDialog(Component parentComponent, Object message)
   ```
   Displays a simple message dialog with the specified message.

2. **Message Dialog with Title**:
   ```java
   showMessageDialog(Component parentComponent, Object message, String title, int messageType)
   ```
   Displays a message dialog with the specified title and message type.

3. **Message Dialog with Icon**:
   ```java
   showMessageDialog(Component parentComponent, Object message, String title, int messageType, Icon icon)
   ```
   Displays a message dialog with the specified title, message type, and icon.

4. **Message Dialog with Custom Option Buttons**:
   ```java
   showMessageDialog(Component parentComponent, Object message, String title, int optionType, int messageType, Icon icon)
   ```
   Displays a message dialog with the specified title, message type, icon, and option buttons. The `optionType` parameter determines which buttons are displayed.

5. **Message Dialog with Custom Message Panel**:
   ```java
   showMessageDialog(Component parentComponent, Object message, String title, int messageType, Icon icon, MessagePanel messagePanel)
   ```
   Displays a message dialog with the specified title, message type, icon, and a custom message panel.

6. **Message Dialog with Custom Options and Default Selection**:
   ```java
   showMessageDialog(Component parentComponent, Object message, String title, int optionType, int messageType, Icon icon, Object[] options, Object initialValue)
   ```
   Displays a message dialog with the specified title, message type, icon, custom option buttons, and default selection.

7. **Message Dialog with Custom Options and Custom Message Panel**:
   ```java
   showMessageDialog(Component parentComponent, Object message, String title, int messageType, Icon icon, MessagePanel messagePanel, Object[] options, Object initialValue)
   ```
   Displays a message dialog with the specified title, message type, icon, custom message panel, custom option buttons, and default selection.

**Message Types**

1. **PLAIN_MESSAGE**:
   - A plain message dialog with no specific icon.

2. **INFORMATION_MESSAGE**:
   - A message dialog with an information icon.

3. **WARNING_MESSAGE**:
   - A message dialog with a warning icon.

4. **ERROR_MESSAGE**:
   - A message dialog with an error icon.

5. **QUESTION_MESSAGE**:
   - A message dialog with a question icon.

These message types can be specified when creating message dialogs using the `JOptionPane` class, allowing you to convey different levels of importance or urgency in your messages. Depending on the context and purpose of the message, you can choose the appropriate message type to enhance the user experience and provide clear communication.

#### showConfirmDialog

The `showConfirmDialog` method in Java Swing is used to display a dialog box with a set of buttons typically used for confirming or cancelling an action. Here are the options available when using `showConfirmDialog`:

1. **Option Type Constants**:
   - These constants represent the possible options that can be displayed in the dialog. They include:
     - `YES_NO_OPTION`: Displays Yes and No buttons.
     - `YES_NO_CANCEL_OPTION`: Displays Yes, No, and Cancel buttons.
     - `OK_CANCEL_OPTION`: Displays OK and Cancel buttons.

2. **Message Object**:
   - The message to be displayed in the dialog. This can be a string or any other object that can be rendered as text.

3. **Message Type Constant**:
   - The type of message to be displayed, such as `INFORMATION_MESSAGE`, `WARNING_MESSAGE`, `ERROR_MESSAGE`, etc.

4. **Icon**:
   - An optional icon to be displayed in the dialog, typically corresponding to the message type.

5. **Options Array**:
   - An array of objects representing the options to be displayed in the dialog. This allows you to customize the text of the buttons.

6. **Default Option**:
   - The option that should be selected by default when the dialog is initially displayed.

The `showConfirmDialog` method returns an integer value representing the user's choice. The specific values returned depend on the option type chosen. For example, if the user clicks the Yes button, the method may return `JOptionPane.YES_OPTION`.

Here's a basic example of using `showConfirmDialog`:

```java
int choice = JOptionPane.showConfirmDialog(null, "Are you sure you want to proceed?", "Confirmation", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);

if (choice == JOptionPane.YES_OPTION) {
    // User clicked Yes
} else {
    // User clicked No or closed the dialog
}
```

This code displays a dialog box with a message asking the user if they want to proceed, with Yes and No buttons. Depending on the user's choice, the appropriate action can be taken.

#### showInputDialog

The `showInputDialog` method in Java Swing is used to prompt the user for input through a dialog box. It allows you to display a message to the user and retrieve a string input from them. Here are the main components of `showInputDialog`:

1. **Parent Component**:
   - The parent component relative to which the dialog is displayed. This can be `null` if there is no parent component.

2. **Message**:
   - The message to be displayed in the dialog box, prompting the user for input.

3. **Title**:
   - The title of the dialog box.

4. **Message Type**:
   - The type of message to be displayed, such as `PLAIN_MESSAGE`, `INFORMATION_MESSAGE`, `WARNING_MESSAGE`, `ERROR_MESSAGE`, etc. This affects the icon displayed in the dialog.

5. **Icon**:
   - An optional icon to be displayed in the dialog, typically corresponding to the message type.

6. **Initial Value**:
   - An optional initial value to be displayed in the input field. This can be used to suggest a default value to the user.

The `showInputDialog` method returns a string containing the user's input, or `null` if the user cancels the dialog.

Here's a basic example of using `showInputDialog`:

```java
String userInput = JOptionPane.showInputDialog(null, "Please enter your name:", "Input Dialog", JOptionPane.QUESTION_MESSAGE);

if (userInput != null) {
    // User provided input
    System.out.println("Hello, " + userInput + "!");
} else {
    // User cancelled the dialog
    System.out.println("No input provided.");
}
```

This code displays a dialog box prompting the user to enter their name. If the user enters a name and clicks OK, the input is retrieved and displayed. If the user cancels the dialog, `null` is returned.

#### showOptionDialog

The `showOptionDialog` method in Java Swing is used to display a customized dialog box with a set of options for the user to choose from. It provides more flexibility compared to other dialog methods like `showMessageDialog` or `showConfirmDialog`.

Here are the main components of `showOptionDialog`:

1. **Parent Component**:
   - The parent component relative to which the dialog is displayed. This can be `null` if there is no parent component.

2. **Message**:
   - The message to be displayed in the dialog box, providing context or instructions to the user.

3. **Title**:
   - The title of the dialog box.

4. **Option Type**:
   - An integer representing the type of options to be displayed, such as `YES_NO_OPTION`, `YES_NO_CANCEL_OPTION`, `OK_CANCEL_OPTION`, etc. This determines the buttons available for the user to choose from.

5. **Message Type**:
   - The type of message to be displayed, such as `PLAIN_MESSAGE`, `INFORMATION_MESSAGE`, `WARNING_MESSAGE`, `ERROR_MESSAGE`, etc. This affects the icon displayed in the dialog.

6. **Icon**:
   - An optional icon to be displayed in the dialog, typically corresponding to the message type.

7. **Options**:
   - An array of strings representing the text labels for the options presented to the user.

8. **Default Option**:
   - An integer specifying which option should be selected by default when the dialog is initially displayed.

The `showOptionDialog` method returns an integer representing the index of the option chosen by the user, or `-1` if the dialog is closed without making a selection.

Here's a basic example of using `showOptionDialog`:

```java
Object[] options = {"Yes", "No", "Cancel"};
int choice = JOptionPane.showOptionDialog(null, "Do you want to save changes?", "Save Changes", JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]);

switch (choice) {
    case JOptionPane.YES_OPTION:
        // User chose "Yes"
        System.out.println("Changes saved.");
        break;
    case JOptionPane.NO_OPTION:
        // User chose "No"
        System.out.println("Changes discarded.");
        break;
    case JOptionPane.CANCEL_OPTION:
        // User chose "Cancel" or closed the dialog
        System.out.println("Operation cancelled.");
        break;
    case JOptionPane.CLOSED_OPTION:
        // Dialog was closed without making a selection
        System.out.println("Dialog closed.");
        break;
}
```

This code displays a dialog box with the message "Do you want to save changes?" and provides three options: "Yes", "No", and "Cancel". Depending on the user's choice, different actions are taken.

### JDialog

`JDialog` is a part of the Swing library in Java, designed to create customizable dialog windows. It is a top-level container used to present a range of dialog boxes including messages, confirmations, and complex custom dialogs. `JDialog` can be modal or non-modal, meaning it can block user input to other windows or allow interaction with other windows while it is open.

**Class Hierarchy:**

- `java.lang.Object`
  - `java.awt.Component`
    - `java.awt.Container`
      - `java.awt.Window`
        - `java.awt.Dialog`
          - `javax.swing.JDialog`

**Key Features:**

1. **Modality**:
   - `JDialog` can be set to modal, which means it blocks input to other top-level windows while it is visible.
   - Modality types include `MODELESS`, `DOCUMENT_MODAL`, `APPLICATION_MODAL`, and `TOOLKIT_MODAL`.
	1. **MODELESS**
		- **Definition**: A modeless dialog does not block any other window. Users can interact with other windows while the dialog is open.
		- **Use Case**: Useful for auxiliary tools or information panels that should not interrupt the user's workflow.
	2. **DOCUMENT_MODAL**
		- **Definition**: A document-modal dialog blocks all windows that are part of the same document but allows interaction with windows from other documents.
		- **Use Case**: Suitable for applications where the user might be working on multiple documents simultaneously, such as an IDE with multiple projects open.
	3. **APPLICATION_MODAL**
		- **Definition**: An application-modal dialog blocks all windows from the same Java application. The user must close the dialog before interacting with any other window in the application.
		- **Use Case**: Common for confirmation dialogs or error messages where the user must address the dialog before continuing with the application.
	4. **TOOLKIT_MODAL**
		- **Definition**: A toolkit-modal dialog blocks all windows from all applications that run in the same Java Virtual Machine (JVM). This is the most restrictive modality type.
		- **Use Case**: Rarely used, as it is very intrusive. It might be used for critical alerts or information that must be addressed immediately.

2. **Customizability**:
   - You can add any Swing components (buttons, labels, panels, etc.) to a `JDialog`, making it highly customizable.
   - Supports different layouts, making it flexible for various dialog designs.

3. **Events and Listeners**:
   - Can handle events like window closing, button actions, etc., using standard Java event listeners.

4. **Look and Feel**:
   - Inherits the look and feel of the Swing components, ensuring consistency with the rest of the application.

**Constructors:**

1. **JDialog()**
   - Creates a non-modal dialog without a specified owner.
   ```java
   JDialog dialog = new JDialog();
   ```

2. **JDialog(Frame owner)**
   - Creates a non-modal dialog with the specified `Frame` as its owner.
   ```java
   JFrame frame = new JFrame();
   JDialog dialog = new JDialog(frame);
   ```

3. **JDialog(Frame owner, boolean modal)**
   - Creates a dialog with the specified owner and modality.
   - `modal`: If `true`, the dialog blocks user input to other top-level windows while it is visible.
   ```java
   JFrame frame = new JFrame();
   JDialog dialog = new JDialog(frame, true);
   ```

4. **JDialog(Frame owner, String title)**
   - Creates a non-modal dialog with the specified title and owner.
   ```java
   JFrame frame = new JFrame();
   JDialog dialog = new JDialog(frame, "Dialog Title");
   ```

5. **JDialog(Frame owner, String title, boolean modal)**
   - Creates a dialog with the specified title, owner, and modality.
   ```java
   JFrame frame = new JFrame();
   JDialog dialog = new JDialog(frame, "Dialog Title", true);
   ```

6. **JDialog(Frame owner, String title, boolean modal, GraphicsConfiguration gc)**
   - Creates a dialog with the specified title, owner, modality, and `GraphicsConfiguration`.
   ```java
   JFrame frame = new JFrame();
   GraphicsConfiguration gc = frame.getGraphicsConfiguration();
   JDialog dialog = new JDialog(frame, "Dialog Title", true, gc);
   ```

7. **JDialog(Dialog owner)**
   - Creates a non-modal dialog with the specified `Dialog` as its owner.
   ```java
   JDialog parentDialog = new JDialog();
   JDialog dialog = new JDialog(parentDialog);
   ```

8. **JDialog(Dialog owner, boolean modal)**
   - Creates a dialog with the specified owner and modality.
   ```java
   JDialog parentDialog = new JDialog();
   JDialog dialog = new JDialog(parentDialog, true);
   ```

9. **JDialog(Dialog owner, String title)**
   - Creates a non-modal dialog with the specified title and owner.
   ```java
   JDialog parentDialog = new JDialog();
   JDialog dialog = new JDialog(parentDialog, "Dialog Title");
   ```

10. **JDialog(Dialog owner, String title, boolean modal)**
    - Creates a dialog with the specified title, owner, and modality.
    ```java
    JDialog parentDialog = new JDialog();
    JDialog dialog = new JDialog(parentDialog, "Dialog Title", true);
    ```

11. **JDialog(Dialog owner, String title, boolean modal, GraphicsConfiguration gc)**
    - Creates a dialog with the specified title, owner, modality, and `GraphicsConfiguration`.
    ```java
    JDialog parentDialog = new JDialog();
    GraphicsConfiguration gc = parentDialog.getGraphicsConfiguration();
    JDialog dialog = new JDialog(parentDialog, "Dialog Title", true, gc);
    ```

12. **JDialog(Window owner)**
    - Creates a non-modal dialog with the specified `Window` as its owner.
    ```java
    JFrame frame = new JFrame();
    JDialog dialog = new JDialog(frame);
    ```

13. **JDialog(Window owner, ModalityType modalityType)**
    - Creates a dialog with the specified owner and modality type.
    - `modalityType`: One of the `ModalityType` constants (`MODELESS`, `DOCUMENT_MODAL`, `APPLICATION_MODAL`, `TOOLKIT_MODAL`).
    ```java
    JFrame frame = new JFrame();
    JDialog dialog = new JDialog(frame, Dialog.ModalityType.APPLICATION_MODAL);
    ```

14. **JDialog(Window owner, String title)**
    - Creates a non-modal dialog with the specified title and owner.
    ```java
    JFrame frame = new JFrame();
    JDialog dialog = new JDialog(frame, "Dialog Title");
    ```

15. **JDialog(Window owner, String title, ModalityType modalityType)**
    - Creates a dialog with the specified title, owner, and modality type.
    ```java
    JFrame frame = new JFrame();
    JDialog dialog = new JDialog(frame, "Dialog Title", Dialog.ModalityType.APPLICATION_MODAL);
    ```

16. **JDialog(Window owner, String title, ModalityType modalityType, GraphicsConfiguration gc)**
    - Creates a dialog with the specified title, owner, modality type, and `GraphicsConfiguration`.
    ```java
    JFrame frame = new JFrame();
    GraphicsConfiguration gc = frame.getGraphicsConfiguration();
    JDialog dialog = new JDialog(frame, "Dialog Title", Dialog.ModalityType.APPLICATION_MODAL, gc);
    ```

**Common Methods:**

1. **setVisible(boolean b)**
   - Shows or hides the dialog.
   - `b`: `true` to make the dialog visible, `false` to hide it.
   ```java
   JDialog dialog = new JDialog();
   dialog.setVisible(true);
   ```

2. **setModal(boolean modal)**
   - Sets whether the dialog is modal.
   - `modal`: `true` to make the dialog modal, `false` for non-modal.
   ```java
   JDialog dialog = new JDialog();
   dialog.setModal(true);
   ```

3. **setTitle(String title)**
   - Sets the title of the dialog.
   - `title`: The title to be displayed on the dialog.
   ```java
   JDialog dialog = new JDialog();
   dialog.setTitle("My Dialog");
   ```

4. **getContentPane()**
   - Returns the content pane of the dialog. You add components to this pane.
   ```java
   JDialog dialog = new JDialog();
   Container contentPane = dialog.getContentPane();
   contentPane.add(new JLabel("Hello"));
   ```

5. **add(Component comp)**
   - Adds a component to the dialog’s content pane.
   - `comp`: The component to add.
   ```java
   JDialog dialog = new JDialog();
   dialog.add(new JButton("OK"));
   ```

6. **setDefaultCloseOperation(int operation)**
   - Sets the operation that will happen by default when the user initiates a "close" on this dialog.
   - `operation`: One of `WindowConstants.DISPOSE_ON_CLOSE`, `WindowConstants.DO_NOTHING_ON_CLOSE`, `WindowConstants.HIDE_ON_CLOSE`.
   ```java
   JDialog dialog = new JDialog();
   dialog.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
   ```

7. **pack()**
   - Causes the dialog to be sized to fit the preferred size and layouts of its subcomponents.
   ```java
   JDialog dialog = new JDialog();
   dialog.pack();
   ```

8. **setLocationRelativeTo(Component c)**
   - Sets the location of the dialog relative to the specified component.
   - `c`: The component in relation to which the dialog's location is determined.
   ```java
   JDialog dialog = new JDialog();
   dialog.setLocationRelativeTo(null); // Center on screen
   ```

9. **dispose()**
   - Releases all of the native screen resources used by this dialog, its subcomponents, and all of its owned children.
   ```java
   JDialog dialog = new JDialog();
   dialog.dispose();
   ```

10. **setSize(int width, int height)**
    - Resizes the dialog to the specified width and height.
    ```java
    JDialog dialog = new JDialog();
    dialog.setSize(300, 200);
    ```

11. **setResizable(boolean resizable)**
    - Sets whether the dialog is resizable by the user.
    - `resizable`: `true` to make the dialog resizable, `false` otherwise.
    ```java
    JDialog dialog = new JDialog();
    dialog.setResizable(true);
    ```

12. **setLocation(int x, int y)**
    - Sets the location of the dialog relative to the screen coordinates.
    - `x`: The x-coordinate of the dialog's new location.
    - `y`: The y-coordinate of the dialog's new location.
    ```java
    JDialog dialog = new JDialog();
    dialog.setLocation(100, 100);
    ```

13. **setLayout(LayoutManager manager)**
    - Sets the layout manager for the dialog's content pane.
    - `manager`: The layout manager to use.
    ```java
    JDialog dialog = new JDialog();
    dialog.setLayout(new FlowLayout());
    ```

14. **getRootPane()**
    - Returns the root pane of the dialog.
    ```java
    JDialog dialog = new JDialog();
    JRootPane rootPane = dialog.getRootPane();
    ```

15. **getOwner()**
    - Returns the owner of the dialog.
    ```java
    JDialog dialog = new JDialog();
    Window owner = dialog.getOwner();
    ```

16. **setModalityType(Dialog.ModalityType type)**
    - Sets the modality type for the dialog.
    - `type`: One of the `Dialog.ModalityType` constants (`MODELESS`, `DOCUMENT_MODAL`, `APPLICATION_MODAL`, `TOOLKIT_MODAL`).
    ```java
    JDialog dialog = new JDialog();
    dialog.setModalityType(Dialog.ModalityType.APPLICATION_MODAL);
    ```

17. **getModalityType()**
    - Returns the modality type of the dialog.
    ```java
    JDialog dialog = new JDialog();
    Dialog.ModalityType modalityType = dialog.getModalityType();
    ```

18. **isModal()**
    - Returns whether the dialog is modal.
    ```java
    JDialog dialog = new JDialog();
    boolean isModal = dialog.isModal();
    ```

19. **getDefaultCloseOperation()**
    - Returns the operation that occurs when the user initiates a "close" on the dialog.
    ```java
    JDialog dialog = new JDialog();
    int closeOperation = dialog.getDefaultCloseOperation();
    ```

20. **setUndecorated(boolean undecorated)**
    - Sets whether the dialog is undecorated (i.e., does not have a title bar or borders).
    - `undecorated`: `true` to make the dialog undecorated, `false` otherwise.
    ```java
    JDialog dialog = new JDialog();
    dialog.setUndecorated(true);
    ```

21. **isUndecorated()**
    - Returns whether the dialog is undecorated.
    ```java
    JDialog dialog = new JDialog();
    boolean isUndecorated = dialog.isUndecorated();
    ```

22. **getContentPane().add(Component comp, Object constraints)**
    - Adds a component to the content pane with the specified constraints.
    - `comp`: The component to add.
    - `constraints`: The layout constraints.
    ```java
    JDialog dialog = new JDialog();
    dialog.getContentPane().setLayout(new BorderLayout());
    dialog.getContentPane().add(new JButton("OK"), BorderLayout.SOUTH);
    ```

23. **getContentPane().remove(Component comp)**
    - Removes the specified component from the content pane.
    - `comp`: The component to remove.
    ```java
    JDialog dialog = new JDialog();
    JButton button = new JButton("Remove Me");
    dialog.getContentPane().add(button);
    dialog.getContentPane().remove(button);
    ```

24. **getContentPane().removeAll()**
    - Removes all components from the content pane.
    ```java
    JDialog dialog = new JDialog();
    dialog.getContentPane().removeAll();
    ```

25. **setIconImage(Image image)**
    - Sets the icon image for the dialog.
    - `image`: The image to be displayed as the icon.
    ```java
    JDialog dialog = new JDialog();
    ImageIcon icon = new ImageIcon("path/to/icon.png");
    dialog.setIconImage(icon.getImage());
    ```

26. **toFront()**
    - Brings the dialog to the front.
    ```java
    JDialog dialog = new JDialog();
    dialog.toFront();
    ```

27. **toBack()**
    - Sends the dialog to the back.
    ```java
    JDialog dialog = new JDialog();
    dialog.toBack();
    ```

28. **setAlwaysOnTop(boolean alwaysOnTop)**
    - Sets whether the dialog should always be on top.
    - `alwaysOnTop`: `true` to make the dialog always on top, `false` otherwise.
    ```java
    JDialog dialog = new JDialog();
    dialog.setAlwaysOnTop(true);
    ```

29. **isAlwaysOnTop()**
    - Returns whether the dialog is always on top.
    ```java
    JDialog dialog = new JDialog();
    boolean isAlwaysOnTop = dialog.isAlwaysOnTop();
    ```

30. **setOwner(Window owner)**
    - Sets the owner of the dialog.
    - `owner`: The window to be set as the owner.
    ```java
    Window owner = new JFrame();
    JDialog dialog = new JDialog(owner);
    ```

31. **setOpacity(float opacity)**
    - Sets the opacity level of the dialog.
    - `opacity`: A float between 0.0 (completely transparent) and 1.0 (completely opaque).
    ```java
    JDialog dialog = new JDialog();
    dialog.setOpacity(0.75f);
    ```

32. **isResizable()**
    - Returns whether the dialog is resizable.
    ```java
    JDialog dialog = new JDialog();
    boolean isResizable = dialog.isResizable();
    ```

33. **isVisible()**
    - Returns whether the dialog is visible.
    ```java
    JDialog dialog = new JDialog();
    boolean isVisible = dialog.isVisible();
    ```

34. **addWindowListener(WindowListener l)**
    - Adds a window listener to the dialog.
    - `l`: The window listener to be added.
    ```java
    JDialog dialog = new JDialog();
    dialog.addWindowListener(new WindowAdapter() {
        @Override
        public void windowClosing(WindowEvent e) {
            System.out.println("Dialog is closing");
        }
    });
    ```

35. **removeWindowListener(WindowListener l)**
    - Removes a window listener from the dialog.
    - `l`: The window listener to be removed.
    ```java
    JDialog dialog = new JDialog();
    WindowListener listener = new WindowAdapter() {
        @Override
        public void windowClosing(WindowEvent e) {
            System.out.println("Dialog is closing");
        }
    };
    dialog.addWindowListener(listener);
    dialog.removeWindowListener(listener);
    ```

36. **addWindowStateListener(WindowStateListener l)**
    - Adds a window state listener to the dialog.
    - `l`: The window state listener to be added.
    ```java
    JDialog dialog = new JDialog();
    dialog.addWindowStateListener(new WindowStateListener() {
        @Override
        public void windowStateChanged(WindowEvent e) {
            System.out.println("Window state changed");
        }
    });
    ```

37. **removeWindowStateListener(WindowStateListener l)**
    - Removes a window state listener from the dialog.
    - `l`: The window state listener to be removed.
    ```java
    JDialog dialog = new JDialog();
    WindowStateListener listener = new WindowStateListener() {
        @Override
        public void windowStateChanged(WindowEvent e) {
            System.out.println("Window state changed");
        }
    };
    dialog.addWindowStateListener(listener);
    dialog.removeWindowStateListener(listener);
    ```

38. **addWindowFocusListener(WindowFocusListener l)**
    - Adds a window focus listener to the dialog.
    - `l`: The window focus listener to be added.
    ```java
    JDialog dialog = new JDialog();
    dialog.addWindowFocusListener(new WindowFocusListener() {
        @Override
        public void windowGainedFocus(WindowEvent e) {
            System.out.println("Dialog gained focus");
        }

        @Override
        public void windowLostFocus(WindowEvent e) {
            System.out.println("Dialog lost focus");
        }
    });
    ```

39. **removeWindowFocusListener(WindowFocusListener l)**
    - Removes a window focus listener from the dialog.
    - `l`: The window focus listener to be removed.
    ```java
    JDialog dialog = new JDialog();
    WindowFocusListener listener = new WindowFocusListener() {
        @Override
        public void windowGainedFocus(WindowEvent e) {
            System.out.println("Dialog gained focus");
        }

        @Override
        public void windowLostFocus(WindowEvent e) {
            System.out.println("Dialog lost focus");
        }
    };
    dialog.addWindowFocusListener(listener);
    dialog.removeWindowFocusListener(listener);
    ```

40. **setDefaultLookAndFeelDecorated(boolean defaultLookAndFeelDecorated)**
    - Provides a hint as to whether or not newly created `JDialog`s should have their Window decorations (such as borders, widgets for closing the window, title, etc.) provided by the current `LookAndFeel`.
    - `defaultLookAndFeelDecorated`: `true` if `JDialog`s should use the current `LookAndFeel` for decorating the window.
    ```java
    JDialog.setDefaultLookAndFeelDecorated(true);
    ```

**Example Usage:**

Here’s a simple example demonstrating how to create and use a `JDialog`:

```java
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class JDialogExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame("JDialog Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(300, 200);

        JButton showDialogButton = new JButton("Show Dialog");
        showDialogButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                // Create a JDialog
                JDialog dialog = new JDialog(frame, "Custom Dialog", true);
                dialog.setSize(200, 150);
                dialog.setLayout(new FlowLayout());

                // Add custom components to the dialog
                dialog.add(new JLabel("This is a custom dialog"));
                JButton okButton = new JButton("OK");
                okButton.addActionListener(new ActionListener() {
                    @Override
                    public void actionPerformed(ActionEvent e) {
                        dialog.dispose();
                    }
                });
                dialog.add(okButton);

                // Set dialog position and show it
                dialog.setLocationRelativeTo(frame);
                dialog.setVisible(true);
            }
        });

        frame.setLayout(new FlowLayout());
        frame.add(showDialogButton);
        frame.setVisible(true);
    }
}
```

Using `JDialog`, you can create complex, interactive dialog windows tailored to your application's needs, providing a flexible way to handle user interactions.

## Base Components

### JRootPane

In Java Swing, `JRootPane` is a container that serves as the root of a containment hierarchy for a Swing GUI application. It provides a way to manage the components of a window, including the menu bar, content pane, and various decorations. `JRootPane` consists of several parts, each serving a specific purpose:

1. **ContentPane**:
   The `contentPane` is where the main content of the window is placed. It is typically a `JPanel` or another container that holds the user interface components (e.g., buttons, text fields, labels) of the application. By default, when you add components to a `JFrame`, they are added to the content pane.

2. **LayeredPane**:
   The `layeredPane` is a container that manages the z-ordering of components within the `JRootPane`. It allows you to overlay components on top of each other and control their visibility. Components added to the layered pane can be positioned at different layers, and their stacking order can be adjusted dynamically.

3. **MenuBar**:
   The `JMenuBar` is a special component that holds menu items and submenus. It is typically placed at the top of the window and provides access to various commands and options through dropdown menus.

4. **GlassPane**:
   The `glassPane` is an invisible layer that sits on top of the content pane and intercepts mouse and keyboard events. It can be used to implement custom modal dialogs, tooltips, or overlays that need to capture user input without allowing interaction with underlying components.

Here's a brief overview of how these parts fit together:

```plaintext
  --------------------------------------------
 |                JRootPane                   |
 |--------------------------------------------|
 |               MenuBar                      |
 |--------------------------------------------|
 |                LayeredPane                 |
 |  --------------------------------------    |
 | |                GlassPane             |   |
 | |                                      |   |
 | |                                      |   |
 |  --------------------------------------    |
 |                                            |
 |                ContentPane                 |
 |                                            |
  --------------------------------------------
```

When you create a `JFrame` or any other top-level container in Swing, it contains a `JRootPane` as its root component. You can access the different parts of the `JRootPane` using getter methods (`getContentPane()`, `getLayeredPane()`, `getGlassPane()`) and customize them as needed to build your application's user interface.

### AbstractButton

`AbstractButton` is an abstract class in Java Swing that serves as the base class for button components such as `JButton`, `JToggleButton`, and `JRadioButton`. It provides common functionality and behavior that is shared among different types of buttons.

Here are some key points about `AbstractButton`:

1. **Common Features**: `AbstractButton` defines common features and behaviors that are shared by all types of buttons, such as handling actions, setting icons, and managing text content.

2. **State Management**: It manages the state of a button, including whether it is enabled, disabled, selected, or deselected.

3. **Events**: Like other Swing components, `AbstractButton` can generate events when interacted with by the user. You can add action listeners to respond to these events and perform actions based on user input.

4. **Abstract Methods**: `AbstractButton` contains abstract methods that subclasses must implement. For example, the `getModel()` method returns the button's data model, which is implemented by subclasses.

5. **Subclasses**: Common subclasses of `AbstractButton` include `JButton`, `JToggleButton`, and `JRadioButton`. These subclasses provide specific implementations for different types of buttons, such as regular buttons, toggle buttons, and radio buttons.

**Methods:**

- **addActionListener(ActionListener listener)**:
   - Registers a listener for action events. This listener will be notified when the button is clicked or activated in some other way.

- **addChangeListener(ChangeListener listener)**:
   - Registers a listener for change events. This listener will be notified when the state of the button changes.

- **addItemListener(ItemListener listener)**:
   - Registers a listener for item events. This listener will be notified when the state of the item (such as a checkbox or list item) changes.

- **doClick()**:
   - Programmatically presses the button, simulating a user click. This can be useful for triggering the button's action programmatically.

- **getText()**:
   - Gets the text displayed on the button.

- **getModel()**:
   - Returns the model for the button. The model contains properties and methods related to the button's state and behavior.

- **isSelected()**:
   - Returns true if the button is selected (for two-state buttons like checkboxes or radio buttons), and false otherwise.

- **setEnabled(boolean state)**:
   - Sets whether the button is enabled or disabled based on the boolean value `state`.

- **setDisabledIcon(Icon icon)**:
   - Sets the icon to be displayed when the button is disabled.

- **setHorizontalAlignment(int horizontalAlignment)**:
    - Sets the horizontal alignment of the button's content. Valid values are `SwingConstants.CENTER`, `SwingConstants.LEFT`, `SwingConstants.RIGHT`, `SwingConstants.LEADING`, or `SwingConstants.TRAILING`.

- **setHorizontalTextPosition(int textPosition)**:
    - Sets the horizontal position of the text relative to the button's icon. Valid values are the same as for horizontal alignment.

- **setMnemonic(int ch)**:
   - Sets the mnemonic for the button to the specified character `ch`. A mnemonic is a keyboard shortcut that activates the button when combined with the Alt key (or another modifier key, depending on the platform). The mnemonic character should be one of the characters in the button's text.

- **setPressedIcon(Icon icon)**:
   - Sets the icon to be displayed when the button is pressed.

- **setRolloverIcon(Icon icon)**:
   - Sets the icon to be displayed when the mouse is rolled over the button.

- **setRolloverSelectedIcon(Icon icon)**:
   - Sets the icon to be displayed when a selected button is rolled over by the mouse. This method applies only to two-state buttons like checkboxes or radio buttons.

- **setSelected(boolean state)**:
   - Sets whether the button is selected (checked) or deselected (unchecked). This method applies only to two-state buttons.

- **setSelectedIcon(Icon icon)**:
   - Sets the icon to be displayed when the button is selected. This method applies only to two-state buttons.

- **setText(String str)**:
   - Sets the text displayed on the button to the specified string `str`.

- **setVerticalAlignment(int verticalAlignment)**:
   - Vertically aligns the contents of the button. Valid values are `SwingConstants.CENTER`, `SwingConstants.TOP`, or `SwingConstants.BOTTOM`.

- **setVerticalTextPosition(int textPosition)**:
   - Sets the vertical position of the text relative to the button's icon. Valid values are `SwingConstants.CENTER`, `SwingConstants.TOP`, or `SwingConstants.BOTTOM`.

### JTextComponent

The `JTextComponent` class serves as the base class for swing components that allow the editing of text. It's an abstract class, meaning you can't instantiate it directly. Instead, you'll typically use one of its concrete subclasses like `JTextField`, `JTextArea`, or `JEditorPane`.

**Methods:**

1. **setText(String text)**: Sets the text content of the component.
2. **String getText()**: Retrieves the text content from the component.
3. **void setEditable(boolean editable)**: Sets whether the text component is editable or not.
4. **boolean isEditable()**: Checks if the text component is editable.
5. **void setEnabled(boolean enabled)**: Sets whether the text component is enabled or not.
6. **boolean isEnabled()**: Checks if the text component is enabled.
7. **void setCaretPosition(int position)**: Sets the caret position within the text component.
8. **int getCaretPosition()**: Retrieves the current caret position within the text component.
9. **void moveCaretPosition(int newLoc)**: Sets the position of the caret to newLoc, which is specified in terms of characters from the start of the text. The text between the current position and the new position is selected.
10. **void select(int start, int end)**: Selects text within the component from the start index to the end index.
11. **void cut()**: Cuts the selected text and places it into the system clipboard.
12. **void copy()**: Copies the selected text into the system clipboard.
13. **void paste()**: Pastes the text from the system clipboard into the component.
14. **void read(Reader input, Object what) throws IOException**: Copies data from *input* to the text component. The value of *what* describes the input stream. It can be null.
15. **void write(Writer output) throws IOException**: Writes the contents of the component to the specified stream.
16. **Document getDocument()**: Returns the model.
17. **void requestFocus()**: Requests focus for the text component.
18. **Insets getMargin()**: Returns and **Insets** object that contains the margins.
19. **void setMargin(lnsets margins)**: Sets the text margins to those specified by margins.
20. **String getSelectedText()**: Returns a string that contains the text that is currently selected.
21. **int getSelectionEnd()**: Returns the hiosition of the last character selected. This value represents the number of characters that the end character is from the start of the text.
22. **int getSelectionStart()**: Returns the position of the first character selected. This value represents the number of characters that the start character is from the start of the text.
23. **void select(int start, int end)**: Selects the text between start and end, which is specified in terms of characters from the start of the text. In all cases, start must be less than or equal to end and both must be within the text.
24. **void selectAII()**: Selects all of the text within the component.
25. **void addCaretListener(CaretListener listener)**: Adds a caret listener to listen for caret position changes.
26. **void removeCaretListener(CaretListener listener)**: Removes a caret listener.

**Concepts:**

1. **Caret**: Represents the insertion point within the text component where new text will be inserted. You can control its position programmatically and listen for changes to it.
2. **Selection**: Refers to the highlighted or selected portion of text within the component. You can manipulate the selection programmatically using methods like `select()`, `cut()`, `copy()`, and `paste()`.
3. **Focus**: Indicates which component is currently ready to receive input from the keyboard. You can request focus for a text component using `requestFocus()`.
### AbstractFormatter

`AbstractFormatter` is an abstract class in Java Swing that serves as the basis for creating custom formatters for text fields, spinners, and other components that accept textual input. It provides a framework for parsing and formatting user input according to specified rules.

Here are some key points about `AbstractFormatter`:

1. **Parsing and Formatting**: It defines methods for parsing user input into a valid value and formatting a value for display. These methods allow you to specify how input should be interpreted and displayed.

2. **Validation**: You can implement custom validation logic to ensure that user input meets certain criteria. This can include checking for valid characters, enforcing input length limits, or verifying input against a predefined list of values.

3. **Error Handling**: `AbstractFormatter` provides mechanisms for handling errors that occur during parsing or formatting. You can customize how errors are reported to the user and how they are handled internally.

4. **Extensibility**: You can subclass `AbstractFormatter` to create custom formatters tailored to your specific requirements. This allows you to define your own parsing and formatting rules, validation logic, and error handling strategies.

5. **Usage**: `AbstractFormatter` is typically used in conjunction with components that accept textual input, such as `JFormattedTextField`, `JSpinner`, and `JFormattedTextField`. By setting an instance of a subclass of `AbstractFormatter` on one of these components, you can control how user input is interpreted and displayed.

Overall, `AbstractFormatter` provides a flexible framework for implementing custom input handling and formatting logic in Swing applications. It allows you to define the behavior of text input components according to your application's requirements.

### AbstractFormatterFactory

`AbstractFormatterFactory` is an abstract class in Java Swing that serves as a factory for creating formatter instances to be used with formatted text input components, such as `JFormattedTextField` or `JSpinner`. It provides a way to encapsulate the creation of formatter objects and allows for dynamic switching of formatters based on different criteria.

Here are some key points about `AbstractFormatterFactory`:

1. **Factory Method Pattern**: `AbstractFormatterFactory` follows the Factory Method design pattern, where it defines a method for creating formatter instances. Subclasses are responsible for implementing this method to create and return specific formatter instances.

2. **Dynamic Formatter Selection**: By using `AbstractFormatterFactory`, you can dynamically select or switch formatters based on various factors such as user input, application state, or data type. This allows for flexibility in formatting user input based on changing requirements.

3. **Customization**: Subclasses of `AbstractFormatterFactory` can encapsulate complex logic for selecting or creating formatters. This can include logic for choosing different formatters based on user preferences, locale settings, or data validation requirements.

4. **Integration with Formatted Text Components**: `AbstractFormatterFactory` is typically used in conjunction with formatted text input components, such as `JFormattedTextField` or `JSpinner`. These components allow you to set an instance of `AbstractFormatterFactory`, which determines the formatter used for parsing and formatting user input.

5. **Error Handling**: `AbstractFormatterFactory` provides mechanisms for handling errors that occur during the creation of formatter instances. Subclasses can customize error handling behavior to provide meaningful feedback to the user.

Overall, `AbstractFormatterFactory` provides a flexible and extensible way to manage the creation of formatter instances for formatted text input components in Swing applications. It allows for dynamic selection and customization of formatters, making it suitable for a wide range of input formatting requirements.

### MaskFormatter

The `MaskFormatter` class in Java Swing allows you to specify a mask for formatting and parsing text input. It's commonly used with components like `JFormattedTextField` to enforce specific formats for user input, such as phone numbers, dates, or social security numbers.

Here's a brief overview of the `MaskFormatter` class:

- **Constructor**: 
  - `MaskFormatter(String mask)`: Creates a `MaskFormatter` with the specified mask. The mask defines the format of the text input, where certain characters represent fixed or variable parts of the input. For example, `"###-##-####"` could be a mask for a social security number.

- **Methods**:
  - `setMask(String mask)`: Sets or changes the mask for the formatter.
  - `setPlaceholder(char placeholder)`: Sets the character to be used as a placeholder for unfilled positions in the mask.
  - `setAllowsInvalid(boolean allowsInvalid)`: Specifies whether the formatter allows invalid characters or not.
  - `setValidCharacters(String validCharacters)`: Sets the valid characters that can be inputted at any position in the mask.
  - `setCommitsOnValidEdit(boolean commitsOnValidEdit)`: Specifies whether edits should be committed immediately upon entering a valid value.
  - `install(JFormattedTextField ftf)`: Installs the `MaskFormatter` on a `JFormattedTextField`.
  - `uninstall()`: Removes the `MaskFormatter` from the associated `JFormattedTextField`.

Here's a simple example demonstrating the usage of `MaskFormatter` with a `JFormattedTextField`:

```java
import javax.swing.*;
import javax.swing.text.MaskFormatter;
import java.awt.*;

public class MaskFormatterExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame("MaskFormatter Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        try {
            MaskFormatter formatter = new MaskFormatter("###-##-####"); // Social Security Number format
            JFormattedTextField textField = new JFormattedTextField(formatter);

            JPanel panel = new JPanel(new FlowLayout());
            panel.add(new JLabel("Social Security Number:"));
            panel.add(textField);

            frame.getContentPane().add(panel);
        } catch (Exception e) {
            e.printStackTrace();
        }

        frame.pack();
        frame.setLocationRelativeTo(null); // Center the frame
        frame.setVisible(true);
    }
}
```

**Placeholder Characters**

Here's an expanded list of placeholder characters that can be used in the `fmtMask` string for defining the general form of the format in a `MaskFormatter`:
  
- **A**:
  - Alphanumeric characters (letters and digits).
  
- **H**:
  - Hexadecimal characters (0-9, a-f, A-F).

- **L**:
  - Letters, translated to lowercase.

- **U**:
  - Letters, translated to uppercase.

- **#**:
  - Digits (0-9).

- **' '** (Space):
  - Space character.

- **'?'**:
  - Any character.

- **'!'**:
  - Escape code to specify one of the format characters as a literal.

Literal characters, such as hyphens or slashes, are simply included in the mask string without any special placeholder symbol.

### Format

In Java, the `Format` class is an abstract base class for formatting and parsing operations on objects. It serves as a common interface for various concrete formatter implementations, such as `NumberFormat`, `DateFormat`, and `MessageFormat`, allowing them to be used interchangeably in certain contexts.

Here are some key points about the `Format` class:

1. **Abstract Base Class**: `Format` is an abstract class, meaning that it cannot be instantiated directly. Instead, you use one of its concrete subclasses, such as `NumberFormat` or `DateFormat`, for specific formatting and parsing tasks.

2. **Formatting and Parsing**: The primary purpose of `Format` and its subclasses is to provide methods for formatting data into a human-readable string representation and parsing strings back into their original data types. For example, `NumberFormat` formats numeric values as strings, while `DateFormat` formats dates and times.

3. **Common Interface**: `Format` defines common formatting and parsing methods that are shared by its subclasses. These methods include `format(Object obj)` for formatting data into a string representation, and `parseObject(String source)` for parsing a string into an object.

4. **Localization**: Many concrete implementations of `Format`, such as `NumberFormat` and `DateFormat`, support localization by formatting and parsing data according to locale-specific conventions, such as number formats, date formats, and language-specific text elements.

5. **Thread Safety**: The `Format` class and its subclasses are generally not thread-safe. If multiple threads need to use a `Format` instance concurrently, it's recommended to synchronize access to the formatter or use thread-local instances.

Overall, the `Format` class provides a common interface for formatting and parsing operations on objects, allowing for consistent handling of data formatting tasks across different data types and locales in Java applications.

## Component Commons

### Tooltips

Tooltips in Swing components provide a way to display additional information when the user hovers the mouse cursor over a component. They are useful for providing context-sensitive help or explanations about the purpose of a component. Here's how you can use tooltips in Swing:

1. **Setting Tooltips for Components**:
   - You can set a tooltip for a Swing component using the `setToolTipText(String text)` method. This method accepts a string parameter representing the tooltip text.
   - Example:
     ```java
     JButton button = new JButton("Click Me");
     button.setToolTipText("This is a button. Click it to perform an action.");
     ```

2. **Enabling Tooltips**:
   - By default, tooltips are enabled in Swing components. However, if they are disabled for any reason, you can enable them using the `setToolTipText()` method.
   - Example:
     ```java
     ToolTipManager.sharedInstance().setEnabled(true);
     ```

3. **Customizing Tooltips**:
   - You can customize the appearance and behavior of tooltips by subclassing `JToolTip` and implementing custom rendering or interaction logic.
   - Example:
     ```java
     class CustomToolTip extends JToolTip {
         // Custom rendering logic
     }
     ```

4. **Display Delay**:
   - You can adjust the delay before a tooltip appears using `ToolTipManager` methods such as `setInitialDelay(int milliseconds)`, `setDismissDelay(int milliseconds)`, and `setReshowDelay(int milliseconds)`.

5. **Retrieving Tooltips**:
   - To retrieve the tooltip text of a component, you can use the `getToolTipText()` method.
   - Example:
     ```java
     String tooltip = button.getToolTipText();
     ```

6. **Localized Tooltips**:
   - For internationalization and localization purposes, you can provide tooltips in multiple languages by using resource bundles or properties files to store tooltip text.

7. **HTML Tooltips**:
   - To display formatted tooltips with HTML content, you can use HTML tags in the tooltip text. This allows you to add formatting such as bold, italics, or hyperlinks.
   - Example:
     ```java
     button.setToolTipText("<html><b>Click Me</b><br>This is a <i>bold</i> button.</html>");
     ```

## Events

### Event Classes

#### AWT

In Java AWT (Abstract Window Toolkit), there are several event classes representing different types of user interactions with GUI components. Each event class has a corresponding listener interface that allows you to handle events of that type. Here are some common AWT event classes and their corresponding listener interfaces:

1. **ActionEvent**:
   Represents an action performed by the user, such as clicking a button or selecting a menu item.
   - Corresponding Listener Interface: ActionListener

2. **MouseEvent**:
   Represents a mouse-related event, such as mouse clicks, mouse movements, and mouse button presses/releases.
   - Corresponding Listener Interface: MouseListener

3. **KeyEvent**:
   Represents a keyboard-related event, such as key presses and key releases.
   - Corresponding Listener Interface: KeyListener

4. **ItemEvent**:
   Represents an item state change event, such as selecting/deselecting a checkbox or selecting an item in a choice (drop-down) menu.
   - Corresponding Listener Interface: ItemListener

5. **FocusEvent**:
   Represents a focus-related event, such as gaining or losing focus by a component.
   - Corresponding Listener Interface: FocusListener

6. **WindowEvent**:
   Represents a window-related event, such as window opening, closing, activation, deactivation, and iconification.
   - Corresponding Listener Interface: WindowListener

7. **ComponentEvent**:
   Represents a component-related event, such as resizing, moving, showing, and hiding of components.
   - Corresponding Listener Interface: ComponentListener

8. **AdjustmentEvent**:
   Represents a change in the value of a scrollbar.
   - Corresponding Listener Interface: AdjustmentListener

9. **TextEvent**:
   Represents a change in the text of a text component.
   - Corresponding Listener Interface: TextListener

10. **ContainerEvent**:
    Represents an event related to the addition or removal of components from a container.
    - Corresponding Listener Interface: ContainerListener

To handle events of a particular type, you need to implement the corresponding listener interface and register your listener with the appropriate event source using the `add` method. When the event occurs, the corresponding method in your listener implementation will be called to handle the event. This allows you to define custom behavior in response to user interactions with GUI components.

#### Swing

Here are the Swing event classes and their corresponding event listener interfaces:

1. **AncestorEvent**:
   - Generated when an ancestor of a component has been added, moved, or removed.
   - Corresponding Listener Interface: AncestorListener

2. **CaretEvent**:
   - Generated when the position of the caret in a text component changes.
   - Corresponding Listener Interface: CaretListener

3. **ChangeEvent**:
   - Generated when a component changes its state.
   - Corresponding Listener Interface: ChangeListener

4. **HyperlinkEvent**:
   - Generated when a hyperlink is accessed.
   - Corresponding Listener Interface: HyperlinkListener

5. **ListDataEvent**:
   - Generated when the contents of a list changes.
   - Corresponding Listener Interface: ListDataListener

6. **ListSelectionEvent**:
   - Generated when a list selection changes.
   - Corresponding Listener Interface: ListSelectionListener

7. **MenuEvent**:
   - Generated when a menu selection occurs.
   - Corresponding Listener Interface: MenuListener

8. **TableModelEvent**:
   - Generated when the table model changes.
   - Corresponding Listener Interface: TableModelListener

9. **TreeExpansionEvent**:
   - Generated when a tree is expanded or collapsed.
   - Corresponding Listener Interface: TreeExpansionListener

10. **TreeModelEvent**:
    - Generated when a tree model changes.
    - Corresponding Listener Interface: TreeModelListener

11. **TreeSelectionEvent**:
    - Generated when a node on a tree is selected.
    - Corresponding Listener Interface: TreeSelectionListener

To handle events of a particular type, you need to implement the corresponding listener interface and register your listener with the appropriate event source using the `add` method. When the event occurs, the corresponding method in your listener implementation will be called to handle the event. This allows you to define custom behavior in response to user interactions with Swing components.

### Adapter Classes

Adapter classes in Java Swing provide a convenient way to handle events by providing default implementations for listener interfaces. These adapter classes implement listener interfaces with empty methods, allowing subclasses to override only the methods relevant to their needs. This avoids the need for every listener implementation to override all methods, even if they are not interested in handling all events.

Here are some commonly used adapter classes in Java Swing:

1. **ComponentAdapter**:
   - Implements the ComponentListener interface.
   - Provides empty default implementations for all methods in the ComponentListener interface: componentResized(), componentMoved(), componentShown(), and componentHidden().

2. **FocusAdapter**:
   - Implements the FocusListener interface.
   - Provides empty default implementations for all methods in the FocusListener interface: focusGained() and focusLost().

3. **KeyAdapter**:
   - Implements the KeyListener interface.
   - Provides empty default implementations for all methods in the KeyListener interface: keyPressed(), keyReleased(), and keyTyped().

4. **MouseAdapter**:
   - Implements the MouseListener interface.
   - Provides empty default implementations for all methods in the MouseListener interface: mouseClicked(), mousePressed(), mouseReleased(), mouseEntered(), and mouseExited().

5. **MouseMotionAdapter**:
   - Implements the MouseMotionListener interface.
   - Provides empty default implementations for all methods in the MouseMotionListener interface: mouseDragged() and mouseMoved().

6. **WindowAdapter**:
   - Implements the WindowListener interface.
   - Provides empty default implementations for all methods in the WindowListener interface: windowOpened(), windowClosing(), windowClosed(), windowIconified(), windowDeiconified(), windowActivated(), and windowDeactivated().

Not all listener interfaces have corresponding adapters. For example, there is no adapter for ActionEvent because it defines only one method. In general, there are adapters for listeners that define two or more methods. For example, the MouseMotionListener class has two methods, mouseDragged() and mouseMoved( ). Empty implementations of these methods are provided by MouseMotionAdapter. If you were interested in only mouse drag events, then you could simply extend MouseMotionAdapter and implement mouseDragged( ). The empty implementation of mouseMoved( ) would handle the mouse motion events for you.

These adapter classes simplify event handling code by allowing developers to override only the methods they are interested in, while still providing the flexibility to handle various types of events. They are particularly useful when implementing listener interfaces with multiple methods, as they reduce the amount of boilerplate code required.


### Button Events

Understanding the events that Swing buttons can generate is crucial for developing responsive and interactive user interfaces. Let's delve into each category of button events:

1. **Action Events**:
   - **Description**: Action events are triggered when a user performs an action, such as clicking a button or pressing Enter while a button has focus.
   - **Example**: When a user clicks on a JButton, an action event is generated, allowing you to perform actions in response to the button click.
   - **Relevance**: Action events are meaningful for all types of buttons, including JButton, JToggleButton, and JRadioButton.

2. **Item Events**:
   - **Description**: Item events are generated when the state of a button changes, such as when a button is selected (checked) or deselected (unchecked).
   - **Example**: When a user selects or deselects a JCheckBox or a JRadioButton, an item event is generated, indicating the change in state.
   - **Relevance**: Item events are primarily relevant for two-state buttons like JCheckBox and JRadioButton, as they represent the selection or deselection of an option.

3. **Change Events**:
   - **Description**: Change events are fired when the state of the button changes in any way, including changes in selection, enabled/disabled state, or appearance.
   - **Example**: When the state of a JToggleButton changes, such as when it is selected or deselected, a change event is generated, allowing you to react to the change in state.
   - **Relevance**: Change events are useful for monitoring any changes in the state of buttons, making them applicable to various button types, including JButton and JToggleButton.

Understanding these event categories helps developers design responsive user interfaces by allowing them to respond appropriately to user interactions. Depending on the specific requirements of your application and the type of buttons used, you can choose to handle one or more of these event types to provide the desired functionality and user experience.

### ActionEvent & ActionListener

An `ActionEvent` in Java Swing represents an event that occurs when a user interacts with a component that can trigger an action, such as clicking a button, selecting a menu item, or pressing Enter while a component has focus. It is one of the most commonly used event types in Swing applications, especially for handling user actions.

Here's a breakdown of `ActionEvent`:

- **Description**: An `ActionEvent` encapsulates information about the event, including the source of the event (the component that triggered it) and any modifiers (such as the Shift or Control key) that were pressed during the event.
  
- **Source Component**: The `getSource()` method of `ActionEvent` returns the object that fired the event, allowing you to identify which component triggered the action.

- **Modifiers**: The `getModifiers()` method returns an integer representing the modifiers associated with the event (`ALT_MASK`, `CTRL_MASK`, `META_MASK`,  `SHIFT_MASK`). You can use helper methods such as `isAltDown()`, `isControlDown()`, `isShiftDown()`, etc., to check for specific modifiers.

- **Command String**: The `getActionCommand()` method returns the command string associated with the event. For buttons, this is typically the text displayed on the button.

- **Handling**: You can handle `ActionEvent` using event listeners, such as `ActionListener`, which has a single method `actionPerformed(ActionEvent e)` that gets called when the event occurs. You typically register an `ActionListener` with the component that can trigger the action, such as a JButton.

- **Timing**: For some applications, the time at which the event was generated may be useful. You can obtain this by calling `getWhen( )`. It returns the time at which the event took place. This is called the event's timestamp.

Here's the example code:

```java
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class ActionEventModifiersExample {
    public static void main(String[] args) {
        // Create a JButton with an action command
        JButton button = new JButton("Click Me");
        button.setActionCommand("myButtonAction");

        // Register an ActionListener to handle ActionEvents
        button.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                // Get the source of the event
                Object source = e.getSource();
                
                // Get the action command associated with the event
                String actionCommand = e.getActionCommand();
                
                // Get the modifiers associated with the event
                int modifiers = e.getModifiers();
                
                // Check if Alt key was pressed during the event
                boolean isAltDown = (modifiers & ActionEvent.ALT_MASK) != 0;
                // OR:
                // boolean isAltDown = e.isAltDown();
                
                // Check if Control key was pressed during the event
                boolean isControlDown = (modifiers & ActionEvent.CTRL_MASK) != 0;
                
                // Check if Shift key was pressed during the event
                boolean isShiftDown = (modifiers & ActionEvent.SHIFT_MASK) != 0;
                
		        // Get the time when the event occurred
		        long eventTime = e.getWhen();
            
            }
        });

        // Create a JFrame and add the button
        JFrame frame = new JFrame("ActionEvent Modifiers Example");
        frame.getContentPane().add(button, BorderLayout.CENTER);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.pack();
        frame.setVisible(true);
    }
}
```

### ItemEvent & ItemListener

1. **Item Events and ItemListener Interface**:
   - An item event occurs when an item, such as a checkbox or radio button, is selected or deselected.
   - Item events are represented by the `ItemEvent` class.
   - Item events are handled by classes that implement the `ItemListener` interface, which defines the `itemStateChanged()` method.

2. **Obtaining the Changed Item**:
   - To obtain a reference to the item that changed, you can call the `getItem()` method on the `ItemEvent` object.
   - The reference returned by `getItem()` needs to be cast to the appropriate component class, such as `JCheckBox` or `JRadioButton`.

3. **Getting the ItemSelectable Object**:
   - Calling `getItemSelectable()` on the `ItemEvent` object returns an `ItemSelectable` reference to the object that generated the event.
   - `ItemSelectable` is an interface implemented by components that can be selected.

4. **State of the Item**:
   - When an item event occurs, the component can be in one of two states: selected or deselected.
   - The `ItemEvent` class defines static int constants `SELECTED` and `DESELECTED` to represent these two states.
   - You can obtain the new state by calling the `getStateChange()` method, which returns either `ItemEvent.SELECTED` or `ItemEvent.DESELECTED`.

5. **Determining the State of a Button**:
   - For buttons, such as checkboxes or radio buttons, you can also determine the selected/deselected state by calling the `isSelected()` method, which is defined by `AbstractButton`.

Here's a simple example demonstrating how to handle item events:

```java
import javax.swing.*;
import java.awt.event.*;

public class ItemEventExample {
    public static void main(String[] args) {
        // Create a JFrame
        JFrame frame = new JFrame("Item Event Example");

        // Create a checkbox
        JCheckBox checkBox = new JCheckBox("Select Me");

        // Add an ItemListener to handle item events
        checkBox.addItemListener(new ItemListener() {
            public void itemStateChanged(ItemEvent e) {
                // Get the source of the event
                Object source = e.getItemSelectable();

                // Get the state change (selected or deselected)
                int stateChange = e.getStateChange();

                // Determine the new state
                String newState = (stateChange == ItemEvent.SELECTED) ? "selected" : "deselected";

                // Print information about the event
                System.out.println("Item changed: " + newState);

                // Check if the source is a checkbox
                if (source instanceof JCheckBox) {
                    JCheckBox checkBox = (JCheckBox) source;
                    System.out.println("Checkbox text: " + checkBox.getText());
                }
            }
        });

        // Add the checkbox to the frame
        frame.getContentPane().add(checkBox);

        // Set frame properties
        frame.setSize(300, 200);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}
```

### ChangeEvent & ChangeListener

Handling change events in Java Swing involves listening for changes to the model of a component and responding to these changes appropriately. Here's a breakdown of how to handle change events:

1. **Change Events and ChangeListener Interface**:
   - A change event occurs when a change takes place to the model of a component, such as a slider's value changing or a tab selection changing.
   - Change events are represented by objects of type `ChangeEvent`.
   - Change events are handled by classes that implement the `ChangeListener` interface, which specifies the `stateChanged()` method.

2. **stateChanged() Method**:
   - The `stateChanged()` method is invoked when a change event occurs.
   - It receives a `ChangeEvent` object as its parameter, containing information about the event.

3. **Identifying the Source Component**:
   - To identify the component that generated the `ChangeEvent`, you can call the `getSource()` method on the `ChangeEvent` object.
   - The `getSource()` method is inherited from `EventObject` and returns the object that fired the event.

```java
import javax.swing.*;
import javax.swing.event.*;

public class ButtonChangeEventExample {
    public static void main(String[] args) {
        // Create a JButton
        JButton button = new JButton("Toggle State");

        // Create a label to display the button's state
        JLabel stateLabel = new JLabel("State: Not Pressed");

        // Add a ChangeListener to the button's model
        button.getModel().addChangeListener(new ChangeListener() {
            public void stateChanged(ChangeEvent e) {
                // Get the source of the event (the button's model)
                ButtonModel model = (ButtonModel) e.getSource();

                // Check if the button is pressed
                if (model.isPressed()) {
                    stateLabel.setText("State: Pressed");
                } else {
                    stateLabel.setText("State: Not Pressed");
                }
            }
        });

        // Create a JFrame and add the button and label
        JFrame frame = new JFrame("Button Change Event Example");
        frame.getContentPane().add(button);
        frame.getContentPane().add(stateLabel, "South");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.pack();
        frame.setVisible(true);
    }
}

```

```java
import javax.swing.*;
import javax.swing.event.*;

public class ChangeEventExample {
    public static void main(String[] args) {
        // Create a JSlider
        JSlider slider = new JSlider(JSlider.HORIZONTAL, 0, 100, 50);

        // Create a label to display the slider value
        JLabel valueLabel = new JLabel("Value: " + slider.getValue());

        // Add a ChangeListener to the slider
        slider.addChangeListener(new ChangeListener() {
            public void stateChanged(ChangeEvent e) {
                // Get the source of the event (the slider)
                JSlider sourceSlider = (JSlider) e.getSource();

                // Update the label with the new slider value
                valueLabel.setText("Value: " + sourceSlider.getValue());
            }
        });

        // Create a JFrame and add the slider and label
        JFrame frame = new JFrame("Change Event Example");
        frame.getContentPane().add(slider);
        frame.getContentPane().add(valueLabel, "South");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.pack();
        frame.setVisible(true);
    }
}
```

### CaretEvent & CaretListener

`CaretEvent` and `CaretListener` are part of the Swing package and are used to handle changes in the caret position within a text component, such as a `JTextField` or `JTextArea`. Here's a brief explanation of each:

**CaretEvent:**

- `CaretEvent` is an event object that represents a change in the caret position within a text component.
- It's typically generated when the user moves the caret by typing, clicking, or using keyboard shortcuts.
- This event provides information about the old and new caret positions within the text component.
- CaretEvent defines two methods: int `getDot( )`, `int getMark( )`.
- The `getDot( )` method returns the current location of the caret. This is called the dot. The `getMark()` method returns the beginning point of a selection. This is called the mark. Thus, a selection is bound by the mark and the dot. If no selection has been made, then the dot and mark will be the same value.

**CaretListener:**

- `CaretListener` is an interface that defines methods to handle caret events.
- It contains a single method: `caretUpdate(CaretEvent e)`.
- When implementing this interface, you need to override the `caretUpdate` method to specify what action should be taken when a caret event occurs.
- You can add a `CaretListener` to a text component using the `addCaretListener` method, and remove it using the `removeCaretListener` method.

Here's a simple example demonstrating the usage of `CaretListener`:

```java
import javax.swing.*;
import javax.swing.event.CaretEvent;
import javax.swing.event.CaretListener;

public class CaretListenerExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame("Caret Listener Example");
        JTextField textField = new JTextField(20);

        textField.addCaretListener(new CaretListener() {
            @Override
            public void caretUpdate(CaretEvent e) {
                int dot = e.getDot(); // Get the current caret position
                int mark = e.getMark(); // Get the other end of the selection
                if (dot != mark) {
                    // If there is a selection, print its start and end positions
                    System.out.println("Selection start: " + Math.min(dot, mark) + ", end: " + Math.max(dot, mark));
                } else {
                    // If no selection, print the caret position
                    System.out.println("Caret position: " + dot);
                }
            }
        });

        frame.getContentPane().add(textField);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.pack();
        frame.setVisible(true);
    }
}
```

### Focus Event & FocusListener

A `FocusListener` in Java Swing is an interface used to monitor focus events on a component. It provides two methods: `focusGained()` and `focusLost()`, which are invoked when the component gains or loses keyboard focus, respectively.

Here's an explanation of the methods in the `FocusListener` interface:

1. `void focusGained(FocusEvent e)`: This method is called when the component gains keyboard focus. You can implement this method to perform actions when the component becomes focused, such as selecting all text in a text field or changing the appearance of the component.

2. `void focusLost(FocusEvent e)`: This method is called when the component loses keyboard focus. You can implement this method to perform actions when the component loses focus, such as validating input or updating data.

Here's an example of how to use a `FocusListener` with a `JFormattedTextField` to select all text when the field gains focus:

```java
import javax.swing.*;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;

public class FocusListenerExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("FocusListener Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            // Create a JTextField
            JTextField textField = new JTextField(20);

            // Add a FocusListener to select all text when the field gains focus
            textField.addFocusListener(new FocusListener() {
                @Override
                public void focusGained(FocusEvent e) {
                    textField.selectAll(); // Select all text when field gains focus
                }

                @Override
                public void focusLost(FocusEvent e) {
                    // No action needed when focus is lost
                }
            });

            // Add the text field to the frame
            frame.getContentPane().add(textField);
            frame.pack();
            frame.setLocationRelativeTo(null); // Center the frame
            frame.setVisible(true);
        });
    }
}
```

In this example, when the `JTextField` gains focus, the `focusGained()` method is called, which selects all text in the field using the `selectAll()` method. This allows the user to easily replace the existing text with new input.

### PropertyChangeEvent & PropertyChangeListener

The `PropertyChangeListener` interface in Java Swing provides a way to listen for changes to properties of a component. Here's an overview:

- **Interface**: `java.beans.PropertyChangeListener`
- **Method**: `propertyChange(PropertyChangeEvent evt)`

**How it Works:**

- **Interface Implementation**: Implement the `PropertyChangeListener` interface in a class that needs to listen for property changes.
- **Override Method**: Implement the `propertyChange()` method to define what should happen when a property change event occurs.
- **Registration**: Add an instance of the listener to the component whose property changes you want to monitor.

**Method Signature:**

- **`propertyChange(PropertyChangeEvent evt)`**:
  - Parameters:
    - `evt`: The `PropertyChangeEvent` object containing information about the event, such as the source of the event, the name of the property that changed, and the old and new values of the property.

**Example Usage:**

```java
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

public class MyPropertyChangeListener implements PropertyChangeListener {
    @Override
    public void propertyChange(PropertyChangeEvent evt) {
        // Handle property change event
        String propertyName = evt.getPropertyName();
        Object oldValue = evt.getOldValue();
        Object newValue = evt.getNewValue();

        // Custom logic based on the property change
        System.out.println("Property '" + propertyName + "' changed from " + oldValue + " to " + newValue);
    }
}

// Registering the listener
SomeComponent.addPropertyChangeListener(new MyPropertyChangeListener());
```

In this example, `SomeComponent` is an instance of a Swing component, and `MyPropertyChangeListener` is a class implementing the `PropertyChangeListener` interface. The listener is registered with the component using the `addPropertyChangeListener()` method. When a property change event occurs in `SomeComponent`, the `propertyChange()` method of `MyPropertyChangeListener` will be invoked to handle the event.

### ListSelectionEvent & ListSelectionListener

In Java Swing, `ListSelectionEvent` and `ListSelectionListener` are used together to handle events related to changes in the selection of items in a list component, such as a `JList`.

1. **ListSelectionEvent**:
   - Represents an event that occurs when the selection in a list component changes.
   - Provides information about the source of the event and the range of indices that are affected by the selection change.
   - Allows you to obtain the selection status before and after the change.
	- **int getFirstIndex()**:
	   - Returns the index of the first item affected by the selection change.
	- **int getLastIndex()**:
	   - Returns the index of the last item affected by the selection change.
	- **boolean getValueIsAdjusting()**:
	   - Returns whether the event is one of a series of multiple events, indicating that the selection is still in the process of being adjusted.
	- **int[] getIndices()**:
	   - Returns an array of all the indices that were affected by the selection change.
	- **boolean isAddedSelection()**:
	   - Returns whether the selection change was an addition to the existing selection.
	- **boolean isRemovedSelection()**:
	   - Returns whether the selection change was a removal from the existing selection.
	- **String toString()**:
	   - Returns a string representation of the event, including details such as the affected indices and the adjusting status.

2. **ListSelectionListener**:
   - An interface that must be implemented by classes that wish to listen for selection change events in list components.
   - Defines a single method: `valueChanged(ListSelectionEvent e)`, which is invoked when the selection changes in the list component.
   - Inside this method, you can write code to respond to the selection change event.

Here's a basic example of how to use `ListSelectionListener` to handle selection change events in a `JList`:

```java
import javax.swing.*;
import javax.swing.event.*;
import java.awt.*;

public class ListSelectionExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("List Selection Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            DefaultListModel<String> model = new DefaultListModel<>();
            model.addElement("Item 1");
            model.addElement("Item 2");
            model.addElement("Item 3");

            JList<String> list = new JList<>(model);
            list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
            list.addListSelectionListener(new ListSelectionListener() {
                public void valueChanged(ListSelectionEvent e) {
                    if (!e.getValueIsAdjusting()) {
                        // Get the selected index
                        int selectedIndex = list.getSelectedIndex();
                        // Get the selected item
                        String selectedItem = list.getSelectedValue();
                        // Print or process the selected index or item
                        System.out.println("Selected Index: " + selectedIndex);
                        System.out.println("Selected Item: " + selectedItem);
                    }
                }
            });

            JScrollPane scrollPane = new JScrollPane(list);
            frame.getContentPane().add(scrollPane, BorderLayout.CENTER);

            frame.setSize(300, 200);
            frame.setVisible(true);
        });
    }
}
```

### ListDataEvent & ListDataListener

**ListDataEvent**

The `ListDataEvent` class is part of the Java Swing framework and is used to represent events that occur when the contents of a list model change. These events are typically generated by the `DefaultListModel` or any custom list model implementations.

Here's a brief overview of the `ListDataEvent` class:

- **javax.swing.event.ListDataEvent**: This class represents an event that occurs when the contents of a list model change.
  
  - **getIndex0()**: Returns the lower index of the range of affected elements.
  - **getIndex1()**: Returns the upper index of the range of affected elements.
  - **getType()**: Returns the type of event, indicating whether elements were added, removed, or changed.
  
The `ListDataEvent` class provides essential information about the change that occurred in the list model, such as the range of affected elements and the type of event (e.g., elements added, removed, or changed). This information is useful for handling changes to the list model and updating the UI accordingly.

When implementing a `ListDataListener` to listen for changes in a list model, you typically override methods such as `intervalAdded()`, `intervalRemoved()`, and `contentsChanged()` to respond to different types of events and update the UI as needed. The `ListDataEvent` object passed to these methods provides detailed information about the event, allowing you to handle it appropriately.

**ListDataListener**

The `ListDataListener` interface is part of the `javax.swing.event` package in Java Swing and is used to listen for changes in the data of a list model, such as a `DefaultListModel`. It's commonly used to update the user interface when elements are added, removed, or modified in the list model.

Here's a brief overview of the `ListDataListener` interface:

- **javax.swing.event.ListDataListener**: This interface defines methods that must be implemented by classes that wish to listen for changes in a list model.

  - **intervalAdded(ListDataEvent e)**: Called when one or more elements are added to the list model.
  - **intervalRemoved(ListDataEvent e)**: Called when one or more elements are removed from the list model.
  - **contentsChanged(ListDataEvent e)**: Called when the contents of the list model change in any way, such as when elements are added, removed, or modified.

By implementing the `ListDataListener` interface and overriding its methods, you can define custom behavior to handle changes in the list model. For example, you can update the UI to reflect the changes, perform validation or calculations based on the new data, or trigger other actions as needed.

Here's a basic example of implementing a `ListDataListener`:

```java
import javax.swing.event.*;

public class MyListDataListener implements ListDataListener {
    @Override
    public void intervalAdded(ListDataEvent e) {
        System.out.println("Elements added to the list model");
        // Update UI or perform other actions
    }

    @Override
    public void intervalRemoved(ListDataEvent e) {
        System.out.println("Elements removed from the list model");
        // Update UI or perform other actions
    }

    @Override
    public void contentsChanged(ListDataEvent e) {
        System.out.println("Contents of the list model changed");
        // Update UI or perform other actions
    }
}
```

You can then add an instance of this listener to a list model using the `addListDataListener()` method. When changes occur in the list model, the appropriate methods of the `ListDataListener` will be called, allowing you to respond accordingly.

### DocumentEvent & DocumentListener

The `DocumentEvent` class in Swing represents a change that occurred in a document, such as when text is inserted, removed, or changed. It provides information about the location and extent of the change within the document.

Here's an overview of the `DocumentEvent` class:

- **javax.swing.event.DocumentEvent**: This class represents an event that occurs when a document is modified.

  - **getOffset()**: Returns the offset within the document where the change occurred.
  - **getLength()**: Returns the length of the change.
  - **getDocument()**: Returns the document associated with the event.

When a change occurs in a document, a `DocumentEvent` object is created and passed to the appropriate listener methods, such as `insertUpdate(DocumentEvent e)` or `removeUpdate(DocumentEvent e)`, depending on the type of change.

Here's an example of how you can use a `DocumentEvent`:

```java
import javax.swing.*;
import javax.swing.event.*;
import java.awt.*;

public class DocumentEventExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame("DocumentEvent Example");
        JTextField textField = new JTextField(20);

        // Add a DocumentListener to the text field's document
        textField.getDocument().addDocumentListener(new DocumentListener() {
            @Override
            public void insertUpdate(DocumentEvent e) {
                // Called when text is inserted into the document
                int offset = e.getOffset();
                int length = e.getLength();
                System.out.println("Text inserted at offset " + offset + ", length " + length);
            }

            @Override
            public void removeUpdate(DocumentEvent e) {
                // Called when text is removed from the document
                int offset = e.getOffset();
                int length = e.getLength();
                System.out.println("Text removed at offset " + offset + ", length " + length);
            }

            @Override
            public void changedUpdate(DocumentEvent e) {
                // Called when attributes of the document change
                // This is typically not used for plain text components
            }
        });

        frame.add(textField, BorderLayout.NORTH);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.pack();
        frame.setVisible(true);
    }
}
```


The `DocumentListener` interface in Swing is used to listen for changes in a document, typically associated with text components such as JTextFields, JTextAreas, and JEditorPanes. It provides methods to be notified when text is inserted, removed, or changed within the document.

Here's an overview of the `DocumentListener` interface:

- **javax.swing.event.DocumentListener**: This interface defines three methods that must be implemented by classes that wish to listen for changes in a document:

    - **insertUpdate(DocumentEvent e)**: Called when text is inserted into the document.
    - **removeUpdate(DocumentEvent e)**: Called when text is removed from the document.
    - **changedUpdate(DocumentEvent e)**: Called when attributes of the document change (typically not used for plain text components).

These methods are invoked by the Swing event dispatch thread whenever the associated document is modified.

Here's an example of how you can use a `DocumentListener`:

```java
import javax.swing.*;
import javax.swing.event.*;
import java.awt.*;

public class DocumentListenerExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame("DocumentListener Example");
        JTextField textField = new JTextField(20);

        // Add a DocumentListener to the text field's document
        textField.getDocument().addDocumentListener(new DocumentListener() {
            @Override
            public void insertUpdate(DocumentEvent e) {
                // Called when text is inserted into the document
                System.out.println("Text inserted: " + textField.getText());
            }

            @Override
            public void removeUpdate(DocumentEvent e) {
                // Called when text is removed from the document
                System.out.println("Text removed: " + textField.getText());
            }

            @Override
            public void changedUpdate(DocumentEvent e) {
                // Called when attributes of the document change
                // This is typically not used for plain text components
            }
        });

        frame.add(textField, BorderLayout.NORTH);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.pack();
        frame.setVisible(true);
    }
}
```

In this example:

- We create a JTextField named `textField`.
- We add a DocumentListener to the text field's document using `textField.getDocument().addDocumentListener()`.
- Inside the DocumentListener's methods (`insertUpdate()`, `removeUpdate()`, `changedUpdate()`), we print messages indicating when text is inserted or removed from the text field.
- As the user types into the text field, the corresponding messages are printed to the console, demonstrating the usage of the DocumentListener.

### Anonymous Inner Class

Anonymous inner classes are commonly used in Java to implement event listeners in Swing applications. They allow you to define event handling logic inline, making your code more concise. Here's how you can use an anonymous inner class to handle events for a `JButton`:

```java
import javax.swing.*;
import java.awt.event.*;

public class JButtonEventHandling {
    public static void main(String[] args) {
        // Create a JFrame
        JFrame frame = new JFrame("Button Event Handling");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        // Create a JButton
        JButton button = new JButton("Click Me");

        // Add an ActionListener using an anonymous inner class
        button.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                // Action to perform when the button is clicked
                JOptionPane.showMessageDialog(frame, "Button Clicked!");
            }
        });

        // Add the button to the frame
        frame.getContentPane().add(button);
        frame.pack();
        frame.setVisible(true);
    }
}
```

## Layout Managers

### FlowLayout

`FlowLayout` is a layout manager in Java Swing that arranges components in a left-to-right flow, wrapping to the next line if the container's width is exceeded. It is one of the simplest layout managers and is often used for arranging components horizontally, such as in toolbars, status bars, or simple forms.

Here's how `FlowLayout` works:

- Components added to a container with `FlowLayout` are positioned one after another horizontally, starting from the left side of the container.
- If the width of the container is exceeded by adding components, the components are wrapped to the next line.
- By default, there is a default gap between components, both horizontally and vertically.

**Constructors**

1. `FlowLayout()`: Creates a new flow layout manager with a default alignment (centered), and a default horizontal and vertical gap of 5 pixels.

2. `FlowLayout(int align)`: Creates a new flow layout manager with the specified alignment. The `align` parameter can be one of the following constants:
   - `FlowLayout.LEFT`: Aligns components to the left edge.
   - `FlowLayout.CENTER`: Centers components horizontally.
   - `FlowLayout.RIGHT`: Aligns components to the right edge.

3. `FlowLayout(int align, int hgap, int vgap)`: Creates a new flow layout manager with the specified alignment, horizontal gap (hgap), and vertical gap (vgap). The `hgap` parameter represents the horizontal gap between components, and the `vgap` parameter represents the vertical gap between components.

```java
import javax.swing.*;
import java.awt.*;

public class FlowLayoutExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            // Create a JFrame
            JFrame frame = new JFrame("FlowLayout Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            // Create a JPanel with FlowLayout
            JPanel panel = new JPanel();

            // Create buttons to add to the panel
            JButton button1 = new JButton("Button 1");
            JButton button2 = new JButton("Button 2");
            JButton button3 = new JButton("Button 3");

            // Add buttons to the panel
            panel.add(button1);
            panel.add(button2);
            panel.add(button3);

            // Set the layout manager of the panel
            panel.setLayout(new FlowLayout(FlowLayout.CENTER, 10, 10)); // Centered alignment with gaps of 10 pixels

            // Add the panel to the frame
            frame.getContentPane().add(panel);

            // Adjust frame size and make it visible
            frame.pack();
            frame.setLocationRelativeTo(null); // Center the frame on the screen
            frame.setVisible(true);
        });
    }
}
```

1. **Alignment**:
   - By default, components are aligned to the left in `FlowLayout`. You can change this alignment to center or right using the constants `FlowLayout.CENTER` and `FlowLayout.RIGHT`.
   - For right-to-left locales, you can use `FlowLayout.LEADING` (which aligns components to the right) and `FlowLayout.TRAILING` (which aligns components to the left).

2. **Horizontal and Vertical Gaps**:
   - `FlowLayout` has default horizontal and vertical gaps between components. You can set custom gaps using the `setHgap(int hgap)` and `setVgap(int vgap)` methods, respectively.
   - Horizontal gap (`hgap`) specifies the space between components horizontally.
   - Vertical gap (`vgap`) specifies the space between components vertically.

3. **Component Alignment**:
   - You can specify the alignment of components within each row using the `setAlignment(int align)` method. The alignment can be `FlowLayout.LEFT`, `FlowLayout.CENTER`, or `FlowLayout.RIGHT`.

Here's an example demonstrating how to customize `FlowLayout`:

```java
import javax.swing.*;
import java.awt.*;

public class CustomFlowLayoutExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                createAndShowGUI();
            }
        });
    }

    private static void createAndShowGUI() {
        JFrame frame = new JFrame("Custom FlowLayout Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        // Create a panel with FlowLayout and customizations
        JPanel panel = new JPanel();
        FlowLayout flowLayout = new FlowLayout();
        flowLayout.setAlignment(FlowLayout.RIGHT); // Align components to the right
        flowLayout.setHgap(20); // Set horizontal gap between components
        flowLayout.setVgap(10); // Set vertical gap between components
        panel.setLayout(flowLayout);

        // Add buttons to the panel
        panel.add(new JButton("Button 1"));
        panel.add(new JButton("Button 2"));
        panel.add(new JButton("Button 3"));
        panel.add(new JButton("Button 4"));
        panel.add(new JButton("Button 5"));

        // Add the panel to the frame
        frame.add(panel);

        frame.pack();
        frame.setVisible(true);
    }
}
```

### BorderLayout

`BorderLayout` is a layout manager in Java Swing that divides the container into five regions: North, South, East, West, and Center. It is a versatile layout manager commonly used for creating user interfaces with distinct sections, such as toolbars, status bars, or main content areas. Here's an overview of `BorderLayout`:

1. **Regions**:
   - **North**: Positioned at the top of the container.
   - **South**: Positioned at the bottom of the container.
   - **East**: Positioned on the right side of the container.
   - **West**: Positioned on the left side of the container.
   - **Center**: Positioned in the center of the container and occupies any remaining space.

2. **Adding Components**:
   - When you add components to a container with `BorderLayout`, you specify the region where each component should be positioned.
   - You can add multiple components to each region, but only one component can be added to the Center region.

3. **Resizing Behavior**:
   - Components in the East and West regions are given their preferred widths and can be resized horizontally.
   - Components in the North and South regions are given their preferred heights and can be resized vertically.
   - The Center region expands to fill any remaining space in the container.

4. **Default Alignment**:
   - By default, components are aligned to the center of their respective regions.
   - You can customize the alignment of components within each region using other layout managers or by adding nested containers with their own layout managers.

While `BorderLayout` in Java Swing has predefined regions (North, South, East, West, and Center), you can customize its behavior and appearance in several ways:

1. **Specify Component Sizes**:
   - You can specify preferred sizes for components added to `BorderLayout`. This can be done using methods like `setPreferredSize()` on components before adding them to the layout.

2. **Nested Containers**:
   - To achieve more complex layouts within a `BorderLayout`, you can add nested containers with their own layout managers to each region. For example, you can add a `JPanel` with `FlowLayout` to the West region to arrange components horizontally.

3. **Padding**:
   - You can add padding around components by using empty borders. This can be done using `setBorder()` with an `EmptyBorder` that specifies the desired padding.

4. **Custom Alignment**:
   - While `BorderLayout` aligns components to the center of their respective regions by default, you can achieve custom alignment by using nested containers with layout managers like `FlowLayout` or `GridLayout` within each region.

5. **Component Visibility**:
   - You can control the visibility of components within `BorderLayout` regions. Components can be set visible or invisible using `setVisible()`.

Here's an example demonstrating some of these customizations:

```java
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class BorderLayoutCustomizationExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> createAndShowGUI());
    }

    private static void createAndShowGUI() {
        JFrame frame = new JFrame("BorderLayout Customization Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        // Create buttons for each region
        JButton northButton = new JButton("North");
        JButton southButton = new JButton("South");
        JButton eastButton = new JButton("East");
        JButton westButton = new JButton("West");
        JButton centerButton = new JButton("Center");

        // Add padding to center button
        centerButton.setBorder(new EmptyBorder(10, 10, 10, 10));

        // Customize preferred sizes for buttons
        northButton.setPreferredSize(new Dimension(100, 50));
        southButton.setPreferredSize(new Dimension(100, 50));

        // Create a panel with FlowLayout for West region
        JPanel westPanel = new JPanel(new FlowLayout());
        westPanel.add(new JButton("Button 1"));
        westPanel.add(new JButton("Button 2"));
        westPanel.add(new JButton("Button 3"));

        // Add buttons and panel to the frame with BorderLayout
        frame.add(northButton, BorderLayout.NORTH);
        frame.add(southButton, BorderLayout.SOUTH);
        frame.add(eastButton, BorderLayout.EAST);
        frame.add(westPanel, BorderLayout.WEST);
        frame.add(centerButton, BorderLayout.CENTER);

        frame.setSize(400, 300);
        frame.setVisible(true);
    }
}
```

### GridLayout

`GridLayout` is a layout manager in Java Swing that arranges components in a grid of rows and columns. Each cell in the grid has the same size, and components are added sequentially, filling each row before moving to the next. Here are some key points about `GridLayout`:

1. **Equal Cell Sizes**:
   - Components added to a container with `GridLayout` are resized to occupy equal-sized cells in the grid.
   - The size of each cell is determined by dividing the container's width and height by the number of rows and columns specified in the `GridLayout`.

2. **Sequential Placement**:
   - Components are added to the container in a left-to-right, top-to-bottom order.
   - Once a row is filled, components start filling the next row.

3. **Fixed Rows and Columns**:
   - The number of rows and columns in the grid is fixed when you create a `GridLayout` object.
   - You specify the number of rows and columns in the constructor of `GridLayout`.

4. **Uniform Spacing**:
   - By default, `GridLayout` places components with equal spacing between them, both horizontally and vertically.

While `GridLayout` in Java Swing offers a simple grid-based layout, its customization options are somewhat limited compared to other layout managers. However, you can still achieve some customization by combining it with other layout managers or by adjusting component sizes and alignments. Here are some ways to customize `GridLayout`:

1. **Adjust Component Sizes**:
   - You can customize the preferred sizes of components added to the `GridLayout`. By setting preferred sizes explicitly using `setPreferredSize()`, you can control the size of components within the grid.

2. **Empty Cells**:
   - If you want to leave certain cells in the grid empty, you can add `null` or invisible components (such as empty labels) to those cells. This allows you to create layouts where not all cells contain visible components.

3. **Combine with Other Layout Managers**:
   - You can nest containers with different layout managers within cells of the `GridLayout`. For example, you can use `FlowLayout`, `BorderLayout`, or `GridBagLayout` within individual cells to achieve more complex layouts.

4. **Custom Borders**:
   - You can add custom borders to components within the grid to create visual separation between them. For example, you can use `setBorder()` with `EmptyBorder` to add padding around components.

Here's an example demonstrating some of these customizations:

```java
import javax.swing.*;
import java.awt.*;

public class CustomGridLayoutExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> createAndShowGUI());
    }

    private static void createAndShowGUI() {
        JFrame frame = new JFrame("Custom GridLayout Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        // Create a panel with GridLayout (2 rows, 3 columns)
        JPanel panel = new JPanel(new GridLayout(2, 3));

        // Customize preferred sizes for some buttons
        JButton button1 = new JButton("Button 1");
        button1.setPreferredSize(new Dimension(100, 50));
        panel.add(button1);

        // Add null component to leave an empty cell
        panel.add(null);

        // Add an invisible label to leave an empty cell
        panel.add(new JLabel());

        // Add buttons with different alignments
        JButton button2 = new JButton("Button 2");
        button2.setHorizontalAlignment(SwingConstants.RIGHT);
        panel.add(button2);

        JButton button3 = new JButton("Button 3");
        button3.setVerticalAlignment(SwingConstants.BOTTOM);
        panel.add(button3);

        JButton button4 = new JButton("Button 4");
        button4.setPreferredSize(new Dimension(150, 100));
        panel.add(button4);

        // Add the panel to the frame
        frame.add(panel);

        frame.setSize(400, 200);
        frame.setVisible(true);
    }
}
```

Here are the constructors provided by the `GridLayout` class:

1. **Default Constructor**:
   ```java
   GridLayout()
   ```
   Creates a grid layout with one row and one column.

2. **Constructor with Rows and Columns**:
   ```java
   GridLayout(int rows, int cols)
   ```
   Creates a grid layout with the specified number of rows and columns.

3. **Constructor with Rows, Columns, Horizontal Gap, and Vertical Gap**:
   ```java
   GridLayout(int rows, int cols, int hgap, int vgap)
   ```
   Creates a grid layout with the specified number of rows and columns, and the specified horizontal and vertical gaps between components.

### BoxLayout

`BoxLayout` is a layout manager in Java Swing that arranges components either vertically or horizontally in a single row or column. It provides more flexibility than `FlowLayout` and `GridLayout` for creating complex layouts with components aligned in a linear fashion.

**Constructors**

1. `BoxLayout(Container target, int axis)`:
    - Creates a new `BoxLayout` instance for the specified target container and axis (either `BoxLayout.X_AXIS` for horizontal arrangement or `BoxLayout.Y_AXIS` for vertical arrangement).
2. `BoxLayout(Container target, int axis, int alignment)`:
    - Creates a new `BoxLayout` instance for the specified target container, axis, and alignment.
    - The `alignment` parameter specifies how components are aligned along the axis and can be one of the following constants: `BoxLayout.LEFT_ALIGNMENT`, `BoxLayout.CENTER_ALIGNMENT`, or `BoxLayout.RIGHT_ALIGNMENT`.
    - This constructor is particularly useful for specifying the alignment of components within the container.

**Key Aspects**

1. **Orientation**:
   - `BoxLayout` supports two orientations: `X_AXIS` (horizontal) and `Y_AXIS` (vertical).
   - Components added to a container with `BoxLayout` are arranged along the specified axis.

2. **Component Alignment**:
   - By default, components are centered within the container along the axis of the `BoxLayout`.
   - You can specify the alignment of components using constants like `Component.LEFT_ALIGNMENT`, `Component.CENTER_ALIGNMENT`, and `Component.RIGHT_ALIGNMENT`.
   - You can specify the alignment of components within the container using `setAlignmentX()` and `setAlignmentY()` methods of the components.


3. **Flexible Sizing**:
   - Components added to a `BoxLayout` container can have different sizes and alignments along the axis.
   - You can specify the minimum, preferred, and maximum sizes of components to control their resizing behavior.

4. **Glue and Struts**:
   - `BoxLayout` supports the use of "glue" and "struts" to control the spacing between components.
   - Glue (`Box.createGlue()`) expands to fill any available space along the axis, pushing components to the edges of the container.
   - Struts (`Box.createHorizontalStrut(width)` or `Box.createVerticalStrut(height)`) create fixed-width or fixed-height gaps between components.

5. **Component Sizes**:
   - You can customize the sizes of components by setting their preferred, minimum, and maximum sizes using methods like `setPreferredSize()`, `setMinimumSize()`, and `setMaximumSize()`.
   - Setting these sizes allows you to control how components expand or shrink within the container.

4. **Nested Containers**:
   - You can nest containers with different layout managers within a `BoxLayout` container. This allows you to create more complex layouts by combining multiple layout managers.

5. **Component Ordering**:
   - The order in which components are added to the container affects their layout within `BoxLayout`. Components are laid out sequentially according to the order they are added.

Here's an example demonstrating some of these customizations:

```java
import javax.swing.*;
import java.awt.*;

public class CustomBoxLayoutExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> createAndShowGUI());
    }

    private static void createAndShowGUI() {
        JFrame frame = new JFrame("Custom BoxLayout Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        // Create a panel with BoxLayout (vertical orientation)
        JPanel panel = new JPanel();
        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));

        // Add buttons with different alignments and struts
        JButton button1 = new JButton("Button 1");
        button1.setAlignmentX(Component.LEFT_ALIGNMENT);
        panel.add(button1);

        JButton button2 = new JButton("Button 2");
        button2.setAlignmentX(Component.CENTER_ALIGNMENT);
        panel.add(button2);

        panel.add(Box.createVerticalStrut(20)); // Add vertical strut for spacing

        // Create nested panel with FlowLayout (horizontal orientation)
        JPanel nestedPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        nestedPanel.add(new JButton("Nested Button 1"));
        nestedPanel.add(new JButton("Nested Button 2"));
        panel.add(nestedPanel);

        // Add glue to expand space between buttons and nested panel
        panel.add(Box.createVerticalGlue());

        JButton button3 = new JButton("Button 3");
        button3.setAlignmentX(Component.RIGHT_ALIGNMENT);
        panel.add(button3);

        // Add the panel to the frame
        frame.add(panel);

        frame.setSize(300, 200);
        frame.setVisible(true);
    }
}
```

### GridBagLayout

`GridBagLayout` is a flexible layout manager in Java Swing that allows you to create complex layouts by arranging components in a grid of cells, where each cell can have its own set of constraints. It provides precise control over the placement and sizing of components within the grid. Here are some key points about `GridBagLayout`:

1. **Grid Cells**:
   - Components are placed within the grid of cells defined by `GridBagLayout`.
   - Each cell can contain at most one component, but components can span multiple cells.

2. **Constraints**:
   - `GridBagLayout` uses `GridBagConstraints` objects to specify constraints for each component.
   - Constraints include parameters such as grid coordinates, anchor, fill, weight, insets, and more.
   - These constraints allow you to control how components are positioned and resized within the layout.

3. **Alignment and Resizing**:
   - Components can be aligned within their cells both horizontally and vertically using anchor constraints.
   - You can specify how components resize within their cells using fill and weight constraints.

4. **Grid Spacing**:
   - `GridBagLayout` allows you to specify the spacing between cells (both horizontally and vertically) using `Insets`.

5. **Grid Spanning**:
   - Components can span multiple cells in the grid using `gridwidth` and `gridheight` constraints.

6. **Fine-Grained Control**:
   - `GridBagLayout` provides fine-grained control over layout parameters, making it suitable for creating complex and customized user interfaces.

Here's a basic example demonstrating the usage of `GridBagLayout`:

```java
import javax.swing.*;
import java.awt.*;

public class GridBagLayoutExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> createAndShowGUI());
    }

    private static void createAndShowGUI() {
        JFrame frame = new JFrame("GridBagLayout Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        // Create a panel with GridBagLayout
        JPanel panel = new JPanel(new GridBagLayout());

        // Create GridBagConstraints for the components
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.fill = GridBagConstraints.HORIZONTAL; // Fill component horizontally
        gbc.gridx = 0; // Column index
        gbc.gridy = 0; // Row index
        gbc.insets = new Insets(5, 5, 5, 5); // Padding around component

        // Add components to the panel with GridBagConstraints
        panel.add(new JButton("Button 1"), gbc);

        gbc.gridx = 1; // Move to next column
        panel.add(new JButton("Button 2"), gbc);

        gbc.gridy = 1; // Move to next row
        gbc.gridx = 0; // Reset column index
        gbc.gridwidth = 2; // Span two columns
        panel.add(new JButton("Button 3 (span 2 columns)"), gbc);

        // Add the panel to the frame
        frame.add(panel);

        frame.pack();
        frame.setVisible(true);
    }
}
```

Customizing `GridBagLayout` involves manipulating the various constraints provided by `GridBagConstraints` to achieve specific layout requirements. Here are some common customizations and techniques you can apply with `GridBagLayout`:

1. **Component Alignment**:
   - Use the `anchor` constraint to specify the alignment of a component within its cell. Options include `GridBagConstraints.NORTH`, `GridBagConstraints.CENTER`, `GridBagConstraints.WEST`, etc.

2. **Component Filling**:
   - Control how a component fills its cell using the `fill` constraint. Options include `GridBagConstraints.HORIZONTAL`, `GridBagConstraints.VERTICAL`, and `GridBagConstraints.BOTH`.

3. **Cell Spanning**:
   - Components can span multiple cells using the `gridwidth` and `gridheight` constraints. This is useful for creating larger components or dividing the layout into sections.

4. **Weighting**:
   - Use the `weightx` and `weighty` constraints to specify how much additional space a component should be allocated in its cell. This is useful for distributing extra space when the container is resized.

5. **Insets**:
   - Adjust the spacing around a component using the `insets` constraint. This allows you to create padding between components and the edges of their cells.

6. **Grid Positioning**:
   - Specify the row and column indices for each component using the `gridx` and `gridy` constraints. Components are laid out according to their row and column indices.

7. **Grid Spacing**:
   - Control the spacing between cells using the `ipadx` and `ipady` constraints. These constraints define the internal padding within each cell.

8. **Baseline Alignment**:
   - Use the `baseline` constraint to align components along their baselines. This is useful for aligning text or other elements within a row.

9. **Filler Components**:
   - Add invisible filler components to create empty space within the layout. This can be achieved using empty `JPanel` instances or by setting the `weightx` and `weighty` constraints of empty components.

10. **Nested Layouts**:
    - Combine `GridBagLayout` with other layout managers, such as `FlowLayout` or `BoxLayout`, within individual cells. This allows for more complex layouts with different arrangements of components.

Here's an example demonstrating some of these customizations:

```java
import javax.swing.*;
import java.awt.*;

public class CustomGridBagLayoutExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> createAndShowGUI());
    }

    private static void createAndShowGUI() {
        JFrame frame = new JFrame("Custom GridBagLayout Example");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        // Create a panel with GridBagLayout
        JPanel panel = new JPanel(new GridBagLayout());

        // Create GridBagConstraints for the components
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.fill = GridBagConstraints.HORIZONTAL; // Fill component horizontally
        gbc.insets = new Insets(5, 5, 5, 5); // Padding around component

        // Add components with different constraints
        addComponent(panel, new JButton("Button 1"), gbc, 0, 0, 1, 1, GridBagConstraints.CENTER);
        addComponent(panel, new JButton("Button 2"), gbc, 1, 0, 1, 1, GridBagConstraints.EAST);
        addComponent(panel, new JButton("Button 3 (span 2 columns)"), gbc, 0, 1, 2, 1, GridBagConstraints.WEST);
        addComponent(panel, new JButton("Button 4"), gbc, 0, 2, 1, 1, GridBagConstraints.NORTH);
        addComponent(panel, new JButton("Button 5"), gbc, 1, 2, 1, 1, GridBagConstraints.SOUTH);

        // Add the panel to the frame
        frame.add(panel);

        frame.pack();
        frame.setVisible(true);
    }

    private static void addComponent(Container container, Component component, GridBagConstraints gbc,
                                     int gridx, int gridy, int gridwidth, int gridheight, int anchor) {
        gbc.gridx = gridx;
        gbc.gridy = gridy;
        gbc.gridwidth = gridwidth;
        gbc.gridheight = gridheight;
        gbc.anchor = anchor;
        container.add(component, gbc);
    }
}
```

## Borders

![Borders](http://www.java2s.com/Code/JavaImages/BorderSample.PNG)

In Swing, borders are used to visually separate or decorate components within a container. They can enhance the appearance of user interface elements and provide visual cues to users. Swing provides several border classes in the `javax.swing.border` package to achieve different border styles and effects. Here's an overview of some commonly used borders:

1. **EmptyBorder**:
   - The `EmptyBorder` class creates a border with empty space around the component.
   - It allows you to specify the amount of padding (empty space) on each side of the component.
   - Useful for creating spacing between components or between a component and its container.

2. **LineBorder**:
   - The `LineBorder` class creates a border with a single line drawn around the component.
   - You can specify the color and thickness of the border line.
   - Useful for creating simple outlines around components.

3. **EtchedBorder**:
   - The `EtchedBorder` class creates a border with a raised or lowered etched effect.
   - It gives components a 3D appearance by drawing lines that simulate beveled edges.
   - You can specify whether the etched effect is raised or lowered, as well as the color of the lines.

4. **BevelBorder**:
   - The `BevelBorder` class creates a border with a raised or lowered bevel effect.
   - It adds depth to components by drawing shaded edges that create a raised or lowered appearance.
   - You can specify whether the bevel effect is raised or lowered, as well as the highlight and shadow colors.

5. **MatteBorder**:
   - The `MatteBorder` class creates a border with a solid color matte (filled area) around the component.
   - You can specify the thickness of the border and the color of the matte.
   - Useful for creating borders with solid color backgrounds.

6. **CompoundBorder**:
   - The `CompoundBorder` class combines two borders into a single border.
   - It allows you to apply multiple border effects to a component by nesting borders.
   - You can specify separate inner and outer borders, each with its own style and appearance.

These are just a few examples of Swing borders. Each border class provides various constructors and methods for customizing its appearance and behavior. By using different combinations of borders, you can create visually appealing and well-defined layouts in your Swing applications.

### LineBorder

The `LineBorder` class in Swing is used to create a border with a single line drawn around a component. It allows you to specify the color and thickness of the border line. Here's how you can use the `LineBorder` class:

1. **Creating a Line Border**:
   ```java
   import javax.swing.*;
   import java.awt.*;

   public class LineBorderExample {
       public static void main(String[] args) {
           SwingUtilities.invokeLater(() -> {
               JFrame frame = new JFrame("Line Border Example");
               frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

               JPanel panel = new JPanel();
               panel.setBorder(BorderFactory.createLineBorder(Color.BLACK, 2)); // Create a black line border with thickness 2

               JLabel label = new JLabel("Hello, World!");
               panel.add(label);

               frame.add(panel);
               frame.pack();
               frame.setLocationRelativeTo(null); // Center the frame on the screen
               frame.setVisible(true);
           });
       }
   }
   ```
   In this example, we create a `JPanel` and set a line border with black color and thickness of 2 pixels using `BorderFactory.createLineBorder(Color.BLACK, 2)`.

2. **Customizing Line Border**:
   You can customize the color and thickness of the line border according to your requirements by providing different parameters to the `createLineBorder` method.

   - For example, to create a red line border with thickness 1:
     ```java
     panel.setBorder(BorderFactory.createLineBorder(Color.RED, 1));
     ```

3. **Adding Line Border to Existing Component**:
   You can also add a line border to an existing component by calling the `setBorder` method on the component and passing a `LineBorder` object.

   ```java
   component.setBorder(BorderFactory.createLineBorder(Color.BLUE, 3)); // Add a blue line border with thickness 3 to the component
   ```

The `LineBorder` class provides flexibility in creating simple borders with a single line around Swing components. It's commonly used to add visual distinction to components within a user interface.

### EmptyBorder

The `EmptyBorder` class in Swing is used to create a border with empty space around a component. It allows you to specify the amount of padding (empty space) on each side of the component. Here's how you can use the `EmptyBorder` class:

1. **Creating an Empty Border**:
   ```java
   import javax.swing.*;
   import java.awt.*;

   public class EmptyBorderExample {
       public static void main(String[] args) {
           SwingUtilities.invokeLater(() -> {
               JFrame frame = new JFrame("Empty Border Example");
               frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

               JPanel panel = new JPanel();
               panel.setBorder(BorderFactory.createEmptyBorder(10, 20, 10, 20)); // Create an empty border with 10 pixels padding on top, 20 pixels padding on left, bottom, and right

               JLabel label = new JLabel("Hello, World!");
               panel.add(label);

               frame.add(panel);
               frame.pack();
               frame.setLocationRelativeTo(null); // Center the frame on the screen
               frame.setVisible(true);
           });
       }
   }
   ```
   In this example, we create a `JPanel` and set an empty border with 10 pixels padding on top, 20 pixels padding on the left, bottom, and right sides using `BorderFactory.createEmptyBorder(10, 20, 10, 20)`.

2. **Customizing Empty Border**:
   You can customize the padding on each side of the component by providing different parameters to the `createEmptyBorder` method.

   - For example, to create an empty border with 5 pixels padding on all sides:
     ```java
     panel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
     ```

3. **Adding Empty Border to Existing Component**:
   You can also add an empty border to an existing component by calling the `setBorder` method on the component and passing an `EmptyBorder` object.

   ```java
   component.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10)); // Add an empty border with 10 pixels padding on all sides to the component
   ```

The `EmptyBorder` class provides a simple way to add padding around Swing components, creating space between the component and its container or neighboring components. It's commonly used for layout purposes to improve the spacing and appearance of user interfaces.

### EtchedBorder

The `EtchedBorder` class in Swing is used to create a border with a raised or lowered etched effect. It gives components a 3D appearance by drawing lines that simulate beveled edges. You can specify whether the etched effect is raised or lowered, as well as the color of the lines. Here's how you can use the `EtchedBorder` class:

1. **Creating an Etched Border**:
   ```java
   import javax.swing.*;
   import java.awt.*;

   public class EtchedBorderExample {
       public static void main(String[] args) {
           SwingUtilities.invokeLater(() -> {
               JFrame frame = new JFrame("Etched Border Example");
               frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

               JPanel panel = new JPanel();
               panel.setBorder(BorderFactory.createEtchedBorder(EtchedBorder.RAISED)); // Create a raised etched border

               JLabel label = new JLabel("Hello, World!");
               panel.add(label);

               frame.add(panel);
               frame.pack();
               frame.setLocationRelativeTo(null); // Center the frame on the screen
               frame.setVisible(true);
           });
       }
   }
   ```
   In this example, we create a `JPanel` and set a raised etched border using `BorderFactory.createEtchedBorder(EtchedBorder.RAISED)`.

2. **Customizing Etched Border**:
   You can customize the etched effect and color of the lines by specifying different parameters to the `createEtchedBorder` method.

   - For example, to create a lowered etched border with gray lines:
     ```java
     panel.setBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, Color.GRAY));
     ```

3. **Adding Etched Border to Existing Component**:
   You can also add an etched border to an existing component by calling the `setBorder` method on the component and passing an `EtchedBorder` object.

   ```java
   component.setBorder(BorderFactory.createEtchedBorder(EtchedBorder.RAISED)); // Add a raised etched border to the component
   ```

The `EtchedBorder` class provides a simple way to add a decorative 3D effect to Swing components, enhancing their appearance and making them stand out within a user interface. It's commonly used for grouping related components or providing visual separation between different sections of a GUI.

## Concepts

### Event Delegation Model

The Delegation Event Model is an event handling mechanism used in Java Swing to manage events generated by user interactions with GUI components. It is based on the principle of event delegation, where event handling responsibilities are delegated from individual components to higher-level containers or listener objects.

In the Delegation Event Model, event handling involves three main components:

1. **Event Sources (Producers)**:
   These are the components that can generate events, such as buttons, text fields, checkboxes, etc. In Swing, these components are subclasses of `java.awt.Component` or `javax.swing.JComponent`.

2. **Event Listeners (Consumers)**:
   These are objects that register interest in specific types of events and implement corresponding listener interfaces. Listener interfaces are typically defined as inner interfaces of event classes, such as `ActionListener`, `MouseListener`, `KeyListener`, etc.

3. **Event Objects**:
   These are objects that encapsulate information about an event when it occurs. Each event class typically contains methods to access information such as the event source, event type, and any relevant event data.

In the Delegation Event Model, event handling follows these steps:

1. **Registration of Event Listeners**:
   Event listeners are registered with event sources using appropriate registration methods. For example, to listen for action events from a button, you would call the `addActionListener()` method and pass an instance of `ActionListener`.

2. **Event Dispatching**:
   When an event occurs, the event source creates an event object and dispatches it to all registered listeners. The event object contains information about the event, such as the source component, event type, and any event-specific data.

3. **Event Handling**:
   Registered event listeners receive the event objects and handle them by invoking appropriate methods defined in the listener interfaces. For example, an `ActionListener` handles action events by implementing the `actionPerformed()` method.

4. **Propagation**:
   If the event is not consumed by the first listener, it may be propagated further up the containment hierarchy to other registered listeners. This allows event handling to be delegated to higher-level containers if necessary.

The Delegation Event Model promotes separation of concerns and encapsulation by allowing components to generate events independently of how those events are handled. It also supports flexibility and extensibility by allowing multiple listeners to respond to the same event, and by allowing listeners to be added or removed dynamically at runtime.

### Event Sources

In Java, an event source refers to an object that generates events when specific actions or conditions occur. These events can then be captured and processed by event listeners. Event sources are typically GUI components such as buttons, text fields, checkboxes, menus, and other interactive elements. When a user interacts with these components (e.g., clicking a button, typing in a text field), they generate events that can be handled by the application.

Here are some common examples of event sources in Java:

1. **JButton**:
   A JButton generates action events when the user clicks on it.

2. **JTextField**:
   A JTextField generates action events when the user presses the "Enter" key after typing in the text field, as well as focus events when it gains or loses focus.

3. **JCheckBox**:
   A JCheckBox generates item events when the user selects or deselects it.

4. **JComboBox**:
   A JComboBox generates action events when the user selects an item from the drop-down list.

5. **JMenuItem**:
   A JMenuItem generates action events when the user selects it from a menu.

6. **JList**:
   A JList generates list selection events when the user selects one or more items from the list.

7. **JSlider**:
   A JSlider generates change events when the user moves the slider's thumb.

8. **Timer** (javax.swing.Timer):
   A Timer generates action events at regular intervals.

These are just a few examples of event sources in Java. In general, any object that implements the `java.util.EventListener` interface and fires events can be considered an event source. By registering event listeners with these sources, you can respond to user actions and update the application's state accordingly. Event-driven programming, facilitated by event sources and listeners, is a fundamental concept in building interactive GUI applications in Java.

### Event Listeners

Event listeners in Java are objects that are responsible for handling events generated by event sources. They are implemented as classes that implement specific listener interfaces provided by the Java API. These interfaces define methods that the listener classes must implement to respond to particular types of events.

Here are some common event listener interfaces in Java:

1. **ActionListener**:
   This interface is used to handle action events, such as button clicks or menu item selections. It defines a single method, `actionPerformed()`, which is called when the action event occurs.

2. **MouseListener**:
   This interface is used to handle mouse events, such as mouse clicks, mouse movements, and mouse button presses/releases. It defines methods such as `mouseClicked()`, `mousePressed()`, `mouseReleased()`, `mouseEntered()`, and `mouseExited()`.

3. **KeyListener**:
   This interface is used to handle keyboard events, such as key presses and key releases. It defines methods such as `keyPressed()`, `keyReleased()`, and `keyTyped()`.

4. **ItemListener**:
   This interface is used to handle item events, such as selection/deselection of checkboxes, radio buttons, and combo box items. It defines a single method, `itemStateChanged()`.

5. **FocusListener**:
   This interface is used to handle focus events, such as gaining or losing focus by a component. It defines methods such as `focusGained()` and `focusLost()`.

6. **WindowListener**:
   This interface is used to handle window-related events, such as window opening, closing, activation, deactivation, and iconification. It defines methods such as `windowOpened()`, `windowClosing()`, `windowClosed()`, `windowActivated()`, `windowDeactivated()`, and `windowIconified()`.

7. **ComponentListener**:
   This interface is used to handle component-related events, such as resizing, moving, showing, and hiding of components. It defines methods such as `componentResized()`, `componentMoved()`, `componentShown()`, and `componentHidden()`.

To use an event listener, you need to create a class that implements the corresponding listener interface and provide implementations for its methods. Then, you can register an instance of this listener class with the appropriate event source using the source's `add` method. When the corresponding event occurs, the appropriate method in the listener class will be called to handle the event. This allows you to define custom behavior in response to user interactions with GUI components.

### Event Dispatching Thread (EDT)

In Java Swing, it's recommended to run GUI programs on the Event Dispatching Thread (EDT) rather than the main thread. This is because Swing is not thread-safe, and all GUI-related operations should be performed on the EDT to ensure proper synchronization and avoid potential race conditions and deadlock situations.

The EDT is a special thread responsible for handling events and updating the user interface components in Swing applications. It ensures that all GUI-related code is executed sequentially and avoids concurrency issues that can arise when multiple threads access Swing components simultaneously.

Here's why running GUI programs on the EDT is important:

1. **Thread Safety**: Swing components are not thread-safe, meaning they are not designed to be accessed or modified from multiple threads concurrently. Running GUI-related code on the EDT ensures that all interactions with Swing components occur in a single-threaded environment, preventing potential race conditions and synchronization issues.

2. **Event Handling**: Swing relies on event-driven programming, where user interactions and system events trigger callbacks to handle GUI updates. These event callbacks are executed on the EDT, so running GUI programs on the EDT ensures that event handling remains responsive and consistent.

3. **UI Responsiveness**: By executing GUI operations on the EDT, Swing applications remain responsive to user input and maintain a smooth and interactive user experience. Running long-running tasks or blocking operations on the main thread can cause the UI to become unresponsive or freeze, leading to a poor user experience.

To run GUI programs on the EDT, you can use the `SwingUtilities.invokeLater()` or `EventQueue.invokeLater()` methods to schedule GUI-related code to be executed on the EDT. This ensures that the code runs asynchronously on the EDT, allowing the main thread to continue executing other tasks.

Here's an example of how to run GUI initialization code on the EDT using `SwingUtilities.invokeLater()`:

```java
public static void main(String[] args) {
    SwingUtilities.invokeLater(new Runnable() {
        public void run() {
            // Initialize and display GUI components here
            JFrame frame = new JFrame("My Swing Application");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            // Add components, set layout, etc.
            frame.pack();
            frame.setVisible(true);
        }
    });
}
```

By following this approach, you ensure that all GUI-related code executes safely and efficiently on the EDT, providing a responsive and reliable user interface in Swing applications.

### Layout Managers

Layout managers in Java Swing are responsible for determining the size and position of components within a container. They help in creating flexible and resizable user interfaces that adapt well to different screen sizes and resolutions. Here are some commonly used layout managers in Java Swing:

1. **FlowLayout**:
   - Arranges components in a left-to-right flow, wrapping to the next line if the container's width is exceeded.
   - Components are positioned one after another with a default gap between them.
   - Useful for creating simple forms or toolbars.

2. **BorderLayout**:
   - Divides the container into five regions: North, South, East, West, and Center.
   - Components added to the BorderLayout are positioned in one of these regions.
   - The Center region expands to fill any remaining space.
   - Suitable for creating complex user interfaces with distinct sections.

3. **GridLayout**:
   - Organizes components in a grid of rows and columns.
   - All cells in the grid have the same size.
   - Components are added sequentially, filling each row before moving to the next.
   - Useful for creating uniform layouts with a fixed number of rows and columns.

4. **BoxLayout**:
   - Arranges components either vertically or horizontally in a single row or column.
   - Components are aligned based on the specified axis (X_AXIS or Y_AXIS).
   - Allows for easy stacking of components in a single direction.

5. **GridBagLayout**:
   - Provides the most flexibility and control over component positioning.
   - Components are arranged in a grid, but each component can occupy multiple cells and have different sizes.
   - Allows for precise control over component alignment, size, and spacing.
   - Suitable for creating complex and custom layouts.

Each layout manager has its own advantages and is suitable for different types of user interfaces. By combining and nesting layout managers, you can create sophisticated and responsive GUI designs in Java Swing. Choose the appropriate layout manager based on the requirements of your application and the desired arrangement of components.

### Double Buffering

Double buffering is a technique used in computer graphics to reduce visual artifacts such as flickering and tearing when updating the display. In Swing, double buffering is often used to create smoother animations and improve rendering performance.

When double buffering is enabled for a component like `JPanel`, it renders its contents to an off-screen buffer (an image in memory) instead of directly to the screen. This off-screen buffer is then copied to the screen all at once, which can eliminate flickering and improve performance, especially when rapidly updating the display.

In the context of `JPanel`, when you create a panel with double buffering enabled, Swing automatically manages the rendering process to use double buffering. This can be beneficial when the panel contains dynamic content or animations, as it helps maintain a smooth and flicker-free user interface.

By default, Swing components like `JPanel` are double-buffered, providing smoother rendering without the need for explicit configuration. However, you have the option to disable double buffering if it's not required or if it consumes too much memory in certain situations.

- **isDoubleBuffered()**: This method is used to determine if a component is double-buffered. It returns `true` if the component is double-buffered and `false` otherwise.

- **setDoubleBuffered(boolean DBon)**: This method enables or disables double buffering for the component. If `DBon` is `true`, the component will be double-buffered. If `DBon` is `false`, double buffering is deactivated.

## Swing Packages

- `javax.swing`: This is the core package for Swing, which provides a set of components for building GUI (Graphical User Interface) applications in Java. It includes classes like `JFrame`, `JPanel`, `JButton`, `JLabel`, etc., which are used to create the visual elements of a user interface.

- `javax.swing.border`: This package contains classes and interfaces for defining and managing borders around Swing components. Borders are used to visually separate or decorate components within a container.

- `javax.swing.colorchooser`: This package provides classes for creating color chooser dialogs and components. It includes the `JColorChooser` class, which allows users to select colors from a palette or define custom colors.

- `javax.swing.event`: This package defines event classes and listener interfaces used in Swing applications. It includes classes like `ActionEvent`, `MouseEvent`, and `ChangeListener`, which represent different types of user interactions with components.

- `javax.swing.filechooser`: This package provides classes and interfaces for creating file chooser dialogs, which allow users to browse and select files or directories on the file system.

- `javax.swing.plaf`: This package contains classes and interfaces related to the pluggable look and feel mechanism in Swing. It allows developers to customize the appearance and behavior of Swing components by providing different look and feel implementations.

- `javax.swing.plaf.basic`: This package contains the basic look and feel implementation for Swing components. It includes classes like `BasicLookAndFeel` and `BasicButtonUI`, which provide the default appearance and behavior for components.

- `javax.swing.plaf.metal`: This package contains the Metal look and feel implementation for Swing components. Metal is one of the built-in look and feel options provided by Swing, featuring a modern and metallic appearance.

- `javax.swing.plaf.multi`: This package provides classes for supporting multiple look and feel implementations in Swing applications. It allows developers to mix and match different look and feel styles for individual components.

- `javax.swing.plaf.synth`: This package contains classes and interfaces for the Synth look and feel, which allows developers to define custom look and feel styles using XML-based skinning. Synth provides a flexible and customizable approach to styling Swing components.

- `javax.swing.table`: This package provides classes and interfaces for creating and managing tables in Swing applications. It includes classes like `JTable`, `TableModel`, and `TableColumn`, which are used to display tabular data.

- `javax.swing.text`: This package contains classes and interfaces for handling text and document processing in Swing applications. It includes classes for displaying styled text (`JTextPane`, `JEditorPane`), editing text (`Document`, `TextComponent`), and parsing HTML and RTF documents.

- `javax.swing.text.html`: This package contains classes and interfaces for working with HTML documents in Swing applications. It includes classes like `HTMLDocument`, `HTMLParser`, and `HTMLEditorKit`, which allow developers to display and manipulate HTML content.

- `javax.swing.text.html.parser`: This package contains classes for parsing HTML documents in Swing applications. It includes the `ParserDelegator` class, which can be used to parse HTML content and generate corresponding Swing components.

- `javax.swing.text.rtf`: This package contains classes and interfaces for working with RTF (Rich Text Format) documents in Swing applications. It includes classes like `RTFEditorKit`, which allow developers to read and write RTF content.

- `javax.swing.tree`: This package provides classes and interfaces for creating and managing tree structures in Swing applications. It includes classes like `JTree`, `DefaultMutableTreeNode`, and `TreeModel`, which are used to display hierarchical data.

- `javax.swing.undo`: This package contains classes and interfaces for implementing undo and redo functionality in Swing applications. It includes classes like `UndoManager` and `UndoableEdit`, which allow developers to manage and track changes made to documents or application state.

## Miscellaneous Classes

### GregorianCalendar

`GregorianCalendar` is a concrete implementation of the `Calendar` class in Java, specifically tailored to the Gregorian calendar system, which is the calendar system commonly used today. It provides methods for performing various operations on dates, such as getting and setting the year, month, day, hour, minute, and second.

Here are some key points about `GregorianCalendar`:

1. **Initialization**: You can create a `GregorianCalendar` object using its constructors, which allow you to specify the year, month, day, hour, minute, and second.

2. **Manipulation**: `GregorianCalendar` provides methods for adding or subtracting time units, such as years, months, days, hours, minutes, and seconds.

3. **Information Retrieval**: You can retrieve information about a `GregorianCalendar` instance, such as the current date and time, using methods like `get(Calendar.YEAR)`, `get(Calendar.MONTH)`, `get(Calendar.DAY_OF_MONTH)`, etc.

4. **Locale-awareness**: `GregorianCalendar` takes into account the locale-specific conventions for first days of the week and minimal days in the first week.

5. **Leap Year Handling**: It handles leap years correctly according to the rules of the Gregorian calendar.

6. **Extensibility**: While `GregorianCalendar` implements the most commonly used calendar system, it is also extensible, allowing for the implementation of other calendar systems.

```java
import java.util.*;

public class CalendarExample {
    public static void main(String[] args) {
        // Create a GregorianCalendar instance representing the current date and time
        GregorianCalendar calendar = new GregorianCalendar();

        // Display the current date and time
        System.out.println("Current Date and Time:");
        displayDateTime(calendar);

        // Set the calendar to a specific date and time
        calendar.set(2024, Calendar.APRIL, 15, 13, 30, 0);

        // Display the updated date and time
        System.out.println("\nUpdated Date and Time:");
        displayDateTime(calendar);

        // Add 1 year and 2 months
        calendar.add(Calendar.YEAR, 1);
        calendar.add(Calendar.MONTH, 2);

        // Display the modified date and time
        System.out.println("\nDate and Time after Adding 1 Year and 2 Months:");
        displayDateTime(calendar);

        // Subtract 7 days
        calendar.add(Calendar.DAY_OF_MONTH, -7);

        // Display the modified date and time
        System.out.println("\nDate and Time after Subtracting 7 Days:");
        displayDateTime(calendar);

        // Retrieve and display specific components of the date and time
        System.out.println("\nRetrieved Components:");
        System.out.println("Year: " + calendar.get(Calendar.YEAR));
        System.out.println("Month: " + calendar.get(Calendar.MONTH));
        System.out.println("Day of Month: " + calendar.get(Calendar.DAY_OF_MONTH));
        System.out.println("Hour: " + calendar.get(Calendar.HOUR_OF_DAY));
        System.out.println("Minute: " + calendar.get(Calendar.MINUTE));
        System.out.println("Second: " + calendar.get(Calendar.SECOND));
    }

    // Helper method to display the date and time
    private static void displayDateTime(Calendar calendar) {
        System.out.println("Date: " + calendar.getTime());
    }
}
```

### Font

Fonts in Java Swing are handled using the `Font` class, which allows you to specify the typeface, style, and size of text to be displayed in components such as labels, buttons, and text fields. Here's an overview of working with fonts in Java Swing:

1. **Creating Fonts:**
   - You can create a `Font` object using one of the constructors provided by the `Font` class. For example:
     ```java
     Font font1 = new Font("Arial", Font.PLAIN, 12); // Plain font, size 12
     Font font2 = new Font("Times New Roman", Font.BOLD, 14); // Bold font, size 14
     ```

2. **Setting Fonts in Components:**
   - Once you have created a `Font` object, you can set it in various Swing components using appropriate methods. For example:
     ```java
     JLabel label = new JLabel("Hello");
     label.setFont(font1);
     ```

3. **Font Styles:**
   - The `Font` class provides constants for different font styles, such as `Font.PLAIN`, `Font.BOLD`, `Font.ITALIC`, and `Font.BOLD + Font.ITALIC`.

4. **System Fonts:**
   - You can also use system-defined fonts by specifying their names, such as "Dialog", "SansSerif", "Serif", etc.

5. **Font Metrics:**
   - You can obtain font metrics using the `FontMetrics` class, which allows you to measure text and calculate the size of strings when rendered in a specific font.

6. **Default Fonts:**
   - If you don't explicitly set a font for a Swing component, it will use the default font defined by the look and feel of the platform.

Here's a basic example demonstrating how to create a font and set it in a `JLabel`:

```java
import javax.swing.*;
import java.awt.*;

public class FontExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("Font Example");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            // Create a custom font
            Font font = new Font("Arial", Font.BOLD, 16);

            // Create a JLabel with custom font
            JLabel label = new JLabel("Custom Font Example");
            label.setFont(font);

            frame.getContentPane().add(label);
            frame.setSize(300, 200);
            frame.setVisible(true);
        });
    }
}
```

This example creates a custom font with Arial typeface, bold style, and size 16, and then sets it in a `JLabel`. You can adjust the font properties and apply them to other Swing components as needed.