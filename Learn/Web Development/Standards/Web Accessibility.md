# Syllabus

## Module 1: Foundations of Accessibility

- Definition and importance of web accessibility
- Disability types (visual, auditory, motor, cognitive, neurological)
- Assistive technologies overview
- Business case for accessibility
- Legal and ethical considerations
- Universal design principles
- Inclusive design philosophy
- Accessibility as a human right

## Module 2: Standards and Guidelines

- WCAG 2.2 structure and organization
- WCAG 2.1 comprehensive coverage
- WCAG 2.0 legacy support
- Conformance levels (A, AA, AAA)
- Success criteria breakdown
- Sufficient and advisory techniques
- Understanding vs. How to Meet documents
- Quick reference guide usage

## Module 3: WCAG Principles (POUR)

- Perceivable principle
- Operable principle
- Understandable principle
- Robust principle
- Guideline structure
- Success criterion anatomy
- Level assignment rationale
- Principle application strategies

## Module 4: Legal and Regulatory Compliance

- Section 508 (United States)
- ADA (Americans with Disabilities Act)
- EN 301 549 (European Union)
- EAA (European Accessibility Act)
- AODA (Accessibility for Ontarians with Disabilities Act)
- International regulations overview
- Legal case studies
- Compliance documentation

## Module 5: Assistive Technologies

- Screen readers (JAWS, NVDA, VoiceOver, TalkBack)
- Screen magnification software
- Voice recognition software
- Alternative input devices
- Braille displays
- Captions and transcripts
- Browser extensions for accessibility
- Operating system accessibility features

## Module 6: Semantic HTML

- Proper element selection
- Heading hierarchy (h1-h6)
- Landmark elements
- Lists (ul, ol, dl)
- Tables structure
- Forms and form controls
- Buttons vs. links
- Document structure best practices

## Module 7: ARIA Fundamentals

- WAI-ARIA 1.2 specification
- WAI-ARIA 1.3 emerging features
- ARIA roles
- ARIA properties
- ARIA states
- First rule of ARIA
- When to use ARIA
- When NOT to use ARIA

## Module 8: ARIA Roles

- Landmark roles
- Widget roles
- Document structure roles
- Abstract roles
- Window roles
- Live region roles
- Role inheritance
- Implicit vs explicit roles

## Module 9: ARIA Properties and States

- aria-label and aria-labelledby
- aria-describedby
- aria-hidden
- aria-live regions
- aria-expanded
- aria-selected
- aria-checked
- aria-disabled vs disabled attribute

## Module 10: Keyboard Accessibility

- Keyboard navigation patterns
- Focus management
- Tab order and tabindex
- Skip links
- Keyboard shortcuts
- Focus indicators
- Focus traps
- Escape key functionality

## Module 11: Focus Management

- Focus order
- Focus visibility
- Focus styles customization
- Managing focus in SPAs
- Modal and dialog focus
- Dynamic content focus
- Focus restoration
- Focus loss prevention

## Module 12: Visual Accessibility

- Color contrast ratios
- Color blindness considerations
- Text sizing and scaling
- Font choice and readability
- Line height and spacing
- Text alternatives for images
- Visual layout and structure
- Responsive design considerations

## Module 13: Color and Contrast

- WCAG contrast requirements (AA and AAA)
- Contrast ratio calculation
- Text contrast
- Non-text contrast
- Color alone insufficiency
- Color palette accessibility
- Contrast testing tools
- High contrast mode support

## Module 14: Images and Graphics

- Alt text best practices
- Decorative images
- Complex images (charts, diagrams)
- SVG accessibility
- Image maps
- Captioned images
- Background images
- Icon accessibility

## Module 15: Forms and Input

- Form labels
- Required fields indication
- Error identification
- Error suggestions
- Form validation
- Input purpose identification
- Fieldset and legend
- Help text and instructions

## Module 16: Form Validation and Errors

- Inline validation
- Error message patterns
- Error prevention
- Success messages
- aria-invalid
- aria-errormessage
- Error summary patterns
- Real-time vs. on-submit validation

## Module 17: Navigation and Wayfinding

- Navigation landmarks
- Breadcrumbs
- Skip navigation links
- Site maps
- Search functionality
- Multiple ways to find content
- Current page indication
- Consistent navigation

## Module 18: Links and Buttons

- Link text best practices
- Link purpose in context
- Button labeling
- Link vs. button semantics
- External link indication
- Download link patterns
- New window warnings
- Ambiguous link text avoidance

## Module 19: Tables

- Data tables vs. layout tables
- Table headers (th)
- Header associations (scope, headers/id)
- Caption and summary
- Complex table structures
- Responsive table patterns
- Sortable tables
- Table accessibility testing

## Module 20: Multimedia Accessibility

- Video captions
- Audio descriptions
- Transcripts
- Sign language interpretation
- Media player controls
- Auto-play restrictions
- Volume controls
- Caption customization

## Module 21: Captions and Subtitles

- Caption formats (WebVTT, SRT)
- Caption quality standards
- Synchronization
- Speaker identification
- Sound effects notation
- Caption positioning
- Live captions
- Caption styling

## Module 22: Audio Descriptions

- Standard audio descriptions
- Extended audio descriptions
- Description timing
- Description writing
- Integration methods
- User controls
- Audio description tracks
- Quality standards

## Module 23: Document Accessibility

- PDF accessibility
- Word document accessibility
- PowerPoint accessibility
- Excel accessibility
- EPUB accessibility
- Reading order
- Tagged PDFs
- Document remediation

## Module 24: Mobile Accessibility

- iOS accessibility features
- Android accessibility features
- Touch target sizing
- Gesture alternatives
- Mobile screen reader testing
- Responsive design considerations
- Mobile-specific WCAG criteria
- App accessibility guidelines

## Module 25: Touch and Pointer Accessibility

- Touch target size (44x44px minimum)
- Touch target spacing
- Pointer cancellation
- Motion actuation alternatives
- Drag and drop alternatives
- Multi-pointer gestures
- Hover alternatives
- Context menu accessibility

## Module 26: Dynamic Content and SPAs

- Single Page Application accessibility
- Route change announcements
- Live regions
- Loading states
- Infinite scroll
- Dynamic content injection
- AJAX and fetch accessibility
- Progressive enhancement

## Module 27: Interactive Components

- Modal dialogs
- Dropdown menus
- Tooltips
- Accordions
- Tabs
- Carousels and sliders
- Autocomplete
- Date pickers

## Module 28: Modal Dialogs

- Focus trapping
- Backdrop interaction
- Close mechanisms
- aria-modal attribute
- Initial focus placement
- Focus return
- ESC key functionality
- Screen reader announcements

## Module 29: Menus and Navigation Patterns

- Dropdown menus
- Mega menus
- Flyout menus
- Menu button pattern
- Disclosure widgets
- Keyboard navigation in menus
- ARIA menubar pattern
- Mobile menu accessibility

## Module 30: Custom Widgets

- Design pattern library
- ARIA Authoring Practices Guide (APG)
- Component accessibility patterns
- Widget testing checklist
- Common widget pitfalls
- Third-party widget evaluation
- Accessible component libraries
- Custom control development

## Module 31: Cognitive Accessibility

- Clear language and readability
- Consistent identification
- Predictable behavior
- Input assistance
- Error prevention
- Time limits and timeouts
- Animation and motion
- Attention and distraction management

## Module 32: Reading Level and Language

- Plain language principles
- Reading level assessment
- Abbreviation expansion
- Pronunciation specification
- Unusual words definition
- Language of page
- Language of parts
- Multiple language support

## Module 33: Motion and Animation

- Prefers-reduced-motion
- Animation alternatives
- Motion-triggered functionality
- Parallax effects
- Auto-playing content
- Pause, stop, hide controls
- Essential vs. non-essential animation
- Vestibular disorder considerations

## Module 34: Time-Based Content

- Time limits
- Session timeouts
- Auto-updating content
- Auto-refreshing pages
- Time limit adjustments
- Timing warning patterns
- Pause and extend mechanisms
- Real-time updates accessibility

## Module 35: Testing Methodologies

- Manual testing procedures
- Automated testing tools
- Screen reader testing
- Keyboard-only testing
- Color contrast testing
- Code validation
- User testing with disabilities
- Continuous accessibility testing

## Module 36: Automated Testing Tools

- axe DevTools
- WAVE browser extension
- Lighthouse accessibility audit
- Pa11y
- HTML validation
- CSS validation
- ARIA validation
- CI/CD integration

## Module 37: Screen Reader Testing

- JAWS testing procedures
- NVDA testing procedures
- VoiceOver testing (macOS, iOS)
- TalkBack testing (Android)
- Narrator testing (Windows)
- Cross-screen reader testing
- Screen reader shortcuts
- Testing documentation

## Module 38: Manual Testing Procedures

- Keyboard navigation testing
- Focus indicator testing
- Form testing
- Link and button testing
- Heading structure testing
- Landmark testing
- Color and contrast inspection
- Testing checklist development

## Module 39: Accessibility Auditing

- WCAG conformance review
- VPAT (Voluntary Product Accessibility Template)
- Accessibility statements
- Audit report creation
- Issue prioritization
- Remediation roadmaps
- Regression testing
- Certification processes

## Module 40: Design for Accessibility

- Accessible design principles
- Inclusive design process
- Design system accessibility
- Wireframing for accessibility
- Prototyping accessibility
- Color palette selection
- Typography accessibility
- Component design patterns

## Module 41: Content Strategy

- Accessible content creation
- Heading strategy
- Alt text guidelines
- Link text strategy
- Microcopy accessibility
- Content structure
- Plain language editing
- Accessibility style guides

## Module 42: Development Best Practices

- Progressive enhancement
- Semantic HTML first
- ARIA as enhancement
- JavaScript accessibility
- CSS considerations
- Framework-specific patterns
- Code review for accessibility
- Documentation standards

## Module 43: Framework-Specific Accessibility

- React accessibility
- Vue.js accessibility
- Angular accessibility
- Svelte accessibility
- Next.js accessibility considerations
- Accessible component libraries
- Framework testing tools
- SSR accessibility implications

## Module 44: CSS and Accessibility

- Display properties impact
- Position and focus
- Visibility vs. opacity vs. display
- CSS-generated content
- Media queries for accessibility
- Focus-visible pseudo-class
- Reduced motion queries
- High contrast mode CSS

## Module 45: JavaScript Accessibility Patterns

- Event handler accessibility
- Custom controls
- ARIA live region updates
- Keyboard event handling
- Focus management with JS
- Accessible third-party libraries
- Progressive enhancement with JS
- Accessible animations

## Module 46: Performance and Accessibility

- Page load impact on accessibility
- Lazy loading considerations
- Skeleton screens
- Loading indicators
- Progressive rendering
- Time to interactive
- Core Web Vitals and accessibility
- Performance optimization techniques

## Module 47: Internationalization (i18n)

- Right-to-left (RTL) support
- Language switching
- Character encoding
- Text direction
- Cultural considerations
- International date/time formats
- Currency and number formatting
- Multilingual content accessibility

## Module 48: Search Engine Accessibility

- SEO and accessibility overlap
- Semantic markup for SEO
- Heading hierarchy for search
- Alt text and image search
- Structured data
- Sitemap accessibility
- Link structure
- Meta information

## Module 49: E-commerce Accessibility

- Product pages
- Shopping cart accessibility
- Checkout process
- Payment forms
- Order confirmation
- Product filters and search
- Product images and zoom
- Wish lists and comparisons

## Module 50: Social Media Accessibility

- Image alt text on social platforms
- Video captions on social media
- Accessible social sharing
- Social media embed accessibility
- Hashtag best practices
- Emoji accessibility
- GIF and meme accessibility
- Social platform-specific features

## Module 51: PDF Accessibility

- Tagged PDF structure
- PDF/UA standard
- Reading order in PDFs
- Form fields in PDFs
- Tables in PDFs
- Alternative formats
- PDF remediation tools
- PDF testing procedures

## Module 52: Email Accessibility

- Email HTML structure
- Alt text in emails
- Email heading hierarchy
- Link text in emails
- Color contrast in emails
- Email client compatibility
- Plain text alternatives
- Accessible email templates

## Module 53: Data Visualization Accessibility

- Chart accessibility
- Graph alternatives
- Data tables for charts
- Pattern and texture use
- Color-independent design
- Interactive chart accessibility
- Sonification
- Data description patterns

## Module 54: Maps and Geolocation

- Map alternatives
- Interactive map accessibility
- Marker and pin accessibility
- Zoom controls
- Pan controls
- Location search
- Directions accessibility
- Map legend accessibility

## Module 55: Authentication and Security

- CAPTCHA alternatives
- Two-factor authentication
- Password field accessibility
- Biometric authentication
- Security question accessibility
- Password strength indicators
- Login error messages
- Account recovery processes

## Module 56: Error Handling and Recovery

- Error identification
- Error description
- Error suggestion
- Error prevention
- Confirmation dialogs
- Undo functionality
- Data preservation
- Graceful degradation

## Module 57: Notifications and Alerts

- Toast notifications
- Alert patterns
- Success messages
- Warning messages
- Live region announcements
- Notification persistence
- Notification dismissal
- Critical vs. non-critical alerts

## Module 58: Search Functionality

- Search input accessibility
- Search results presentation
- No results handling
- Search suggestions
- Filters and facets
- Result count announcements
- Search shortcuts
- Advanced search accessibility

## Module 59: Pagination and Loading

- Pagination controls
- Infinite scroll alternatives
- Load more patterns
- Page number navigation
- Results per page
- Loading indicators
- Progress bars
- Skeleton screens

## Module 60: Settings and Preferences

- User preference storage
- Accessibility settings
- Theme switching
- Text size controls
- Reduced motion toggles
- High contrast modes
- Preference persistence
- Default settings

## Module 61: Chatbots and Conversational UI

- Chat interface accessibility
- Message announcement
- Input field accessibility
- Conversation history
- Bot response formatting
- Quick replies
- Typing indicators
- Chat transcripts

## Module 62: Virtual and Augmented Reality

- VR/AR accessibility challenges
- Alternative experiences
- Motion sickness considerations
- Spatial audio
- Text readability in VR
- Controller alternatives
- VR interface design
- Emerging standards

## Module 63: Artificial Intelligence and Accessibility

- AI-generated content accessibility
- Alternative text generation
- Caption generation
- Accessibility automation
- AI bias considerations
- Personalization with AI
- Voice assistants
- Ethical AI for accessibility

## Module 64: Voice User Interfaces

- Voice command accessibility
- Voice navigation
- Speech recognition
- Voice feedback
- Error handling in VUIs
- Alternative input methods
- Voice privacy
- Multi-modal interfaces

## Module 65: Gaming Accessibility

- Game control options
- Difficulty settings
- Visual accessibility options
- Audio accessibility options
- Cognitive accessibility features
- Xbox Adaptive Controller
- Game accessibility guidelines
- Inclusive game design

## Module 66: Accessibility in Emerging Technologies

- Web3 and blockchain accessibility
- NFT platform accessibility
- Metaverse accessibility
- IoT device accessibility
- Wearable technology
- Brain-computer interfaces
- Future accessibility challenges
- Accessibility research trends

## Module 67: Organizational Accessibility

- Accessibility policy development
- Accessibility team structure
- Training programs
- Accessibility champions
- Budget and resources
- Vendor accessibility requirements
- Procurement guidelines
- Organizational culture change

## Module 68: Accessibility Training and Education

- Developer training
- Designer training
- Content author training
- QA tester training
- Management awareness
- Accessibility workshops
- Certification programs
- Ongoing education

## Module 69: Accessibility Documentation

- Accessibility statements
- Conformance reports
- Testing documentation
- Design documentation
- Development guidelines
- Content guidelines
- User guides
- Known issues disclosure

## Module 70: User Research and Testing

- Recruiting users with disabilities
- Inclusive user research
- Usability testing protocols
- Remote accessibility testing
- Compensation and ethics
- Research synthesis
- Persona development
- User journey mapping

## Module 71: Accessibility Metrics

- Success metrics definition
- Conformance level tracking
- Issue volume and severity
- Remediation progress
- User satisfaction metrics
- Assistive technology usage
- Accessibility maturity models
- ROI measurement

## Module 72: Third-Party Content and Widgets

- Embedded content accessibility
- Social media embeds
- Video players
- Advertisement accessibility
- Third-party scripts
- Widget evaluation
- Vendor accessibility requirements
- Fallback content

## Module 73: Legacy System Accessibility

- Accessibility retrofit strategies
- Progressive enhancement approaches
- Overlay tools (pros and cons)
- Workaround documentation
- Phased remediation
- Budget constraints
- Technical debt management
- Migration planning

## Module 74: Accessibility Overlays and Widgets

- Overlay limitations
- Overlay controversies
- Alternative solutions
- When overlays fail
- Vendor claims evaluation
- Legal risks
- Best practice recommendations
- Community perspectives

## Module 75: Community and Advocacy

- Disability rights organizations
- W3C WAI participation
- Accessibility conferences
- Online communities
- Contributing to standards
- Open source accessibility
- Advocacy strategies
- Accessibility awareness campaigns

## Module 76: Case Studies and Examples

- Successful implementations
- Failure case studies
- Industry-specific examples
- Before and after comparisons
- Lessons learned
- Best practice examples
- Innovative solutions
- Real-world challenges

## Module 77: Resources and Tools

- Official specifications
- Testing tool comparison
- Browser extensions
- Design tools with accessibility features
- Code libraries and frameworks
- Documentation resources
- Community forums
- Continuing education

## Module 78: Future of Web Accessibility

- WCAG 3.0 (W3C Accessibility Guidelines)
- Silver project
- Emerging technologies impact
- Accessibility research directions
- Regulatory trends
- Industry evolution
- Global accessibility initiatives
- Next-generation standards

---

# ARIA Fundamentals

## ARIA Roles

ARIA (Accessible Rich Internet Applications) roles are attributes that define the purpose and behavior of HTML elements for assistive technologies like screen readers. They help make web content more accessible to users with disabilities.

### What Are ARIA Roles?

ARIA roles communicate the type of element to assistive technologies when native HTML semantics are insufficient. They're part of the WAI-ARIA specification maintained by the W3C.

### Categories of ARIA Roles

**Landmark Roles**
These define major page regions and help users navigate:
- `banner` - site header content
- `navigation` - navigation links
- `main` - primary content
- `complementary` - supporting content (like sidebars)
- `contentinfo` - footer information
- `search` - search functionality
- `form` - form collections

**Widget Roles**
These describe interactive interface elements:
- `button` - clickable button
- `checkbox` - checkable input
- `radio` - radio button
- `textbox` - text input field
- `slider` - range selector
- `tab`, `tablist`, `tabpanel` - tabbed interfaces
- `dialog` - modal dialog boxes
- `menu`, `menuitem` - menu systems

**Document Structure Roles**
These organize content structure:
- `article` - self-contained content
- `list`, `listitem` - lists
- `heading` - heading text
- `table`, `row`, `cell` - table structures
- `separator` - content dividers

**Abstract Roles**
These are not used directly in HTML but form the basis for other roles in the ARIA taxonomy.

### Basic Usage

```html
<div role="navigation">
  <ul>
    <li><a href="/">Home</a></li>
  </ul>
</div>

<button role="button">Click Me</button>

<div role="alert">Error: Please fill out all fields</div>
```

### Important Principles

**Use Native HTML First**
Semantic HTML elements have built-in roles. For example, `<nav>` already has `role="navigation"`, and `<button>` already has `role="button"`. [Inference: Using native elements is generally considered best practice in web accessibility circles.]

**Don't Override Native Semantics**
Avoid changing the natural role of elements. For instance, don't add `role="button"` to a `<h1>` element.

**Roles Are Usually Permanent**
Once set, roles typically shouldn't change dynamically. Use ARIA states (like `aria-pressed` or `aria-expanded`) for dynamic properties instead.

### Common Role Combinations

Certain roles work together to create accessible patterns:

**Tabs Interface**
```html
<div role="tablist">
  <button role="tab" aria-selected="true">Tab 1</button>
  <button role="tab" aria-selected="false">Tab 2</button>
</div>
<div role="tabpanel">Content for Tab 1</div>
```

**Alert Dialog**
```html
<div role="alertdialog" aria-labelledby="dialog-title">
  <h2 id="dialog-title">Confirm Action</h2>
  <p>Are you sure?</p>
  <button>Confirm</button>
</div>
```

### Roles vs. ARIA Attributes

Roles work alongside other ARIA features:
- **Roles** define what an element is
- **States** describe current conditions (e.g., `aria-checked="true"`)
- **Properties** define characteristics (e.g., `aria-label="Close"`)

### Browser and Assistive Technology Support

[Inference: Major modern browsers and screen readers support ARIA roles, though implementation quality can vary.] Testing with actual assistive technologies is recommended for critical applications.

### Resources for Further Learning

For authoritative information, consult the W3C WAI-ARIA specification at w3.org/TR/wai-aria/ and the ARIA Authoring Practices Guide for implementation patterns.

---

## ARIA Properties

ARIA properties provide additional information about elements to assistive technologies. Unlike ARIA states (which can change frequently), properties typically describe characteristics that remain stable throughout the element's lifecycle.

### What Are ARIA Properties?

ARIA properties are attributes that define the nature or characteristics of elements. They help assistive technologies understand relationships, labels, descriptions, and other qualities that aren't conveyed through HTML alone.

### Categories of ARIA Properties

**Labeling Properties**

These provide accessible names and descriptions:

- `aria-label` - Provides a text label for an element
- `aria-labelledby` - References ID(s) of elements that label the current element
- `aria-describedby` - References ID(s) of elements that describe the current element
- `aria-description` - Provides a description string directly

```html
<button aria-label="Close dialog">√ó</button>

<input type="text" aria-labelledby="username-label" aria-describedby="username-help">
<label id="username-label">Username</label>
<span id="username-help">Must be 3-20 characters</span>
```

**Relationship Properties**

These define connections between elements:

- `aria-controls` - References ID(s) of elements controlled by this element
- `aria-owns` - Defines a parent-child relationship in the accessibility tree
- `aria-flowto` - Indicates the reading order when it differs from DOM order
- `aria-activedescendant` - References the currently active descendant element

```html
<button aria-controls="menu-1">Open Menu</button>
<ul id="menu-1" role="menu">
  <li role="menuitem">Option 1</li>
</ul>

<div role="combobox" aria-activedescendant="option-2">
  <div id="option-1">Apple</div>
  <div id="option-2">Banana</div>
</div>
```

**Widget Properties**

These describe characteristics of interactive elements:

- `aria-placeholder` - Defines placeholder text for input fields
- `aria-readonly` - Indicates the element is not editable
- `aria-required` - Indicates the field must be completed
- `aria-autocomplete` - Describes autocomplete behavior (none, inline, list, both)
	- `none` - No autocomplete suggestions are provided. The user must type the complete value themselves.
	- `inline` - The system automatically completes the user's input by inserting suggested text directly into the input field after the cursor. For example, typing "ca" might automatically complete to "cat" with "t" highlighted.
	- `list` - Autocomplete suggestions appear in a separate popup list (like a dropdown menu). The user can select from these suggestions, but the input field itself isn't automatically completed.
	- `both` - Combines inline and list behaviors. The input field shows inline completion while also displaying a popup list of additional suggestions. For example, typing "ca" might complete to "cat" in the field while showing a dropdown with "cat", "car", "can", etc.
- `aria-multiline` - Indicates if text input accepts multiple lines
- `aria-multiselectable` - Indicates if multiple items can be selected
- `aria-orientation` - Defines orientation (horizontal or vertical)
- `aria-valuemin`, `aria-valuemax`, `aria-valuenow`, `aria-valuetext` - Describe range values

```html
<input type="text" aria-placeholder="Enter your email" aria-required="true">

<div role="slider" aria-valuemin="0" aria-valuemax="100" aria-valuenow="50" 
     aria-valuetext="50 percent"></div>

<div role="listbox" aria-multiselectable="true">
  <div role="option">Item 1</div>
  <div role="option">Item 2</div>
</div>
```

**Live Region Properties**

These control how dynamic content updates are announced:

- `aria-live` - Defines priority of updates
  - `off` - No announcements
  - `polite` - Announces when user is idle
  - `assertive` - Announces immediately, interrupting current speech
- `aria-atomic` - Indicates if the entire region should be announced on changes
  - `true` - Announces entire region content
  - `false` - Announces only changed content
- `aria-relevant` - Specifies which changes should be announced
  - `additions` - Announces when nodes are added
  - `removals` - Announces when nodes are removed
  - `text` - Announces text content changes
  - `all` - Announces all changes (additions, removals, and text) 

```html
<div aria-live="polite" aria-atomic="true">
  Loading: 45%
</div>

<div aria-live="assertive" aria-relevant="additions text">
  <p>New message received</p>
</div>
```

**Drag-and-Drop Properties**

These describe draggable elements and drop targets:

- `aria-dropeffect` - Indicates possible drop operations
  - `copy` - A duplicate of the source object will be dropped
  - `move` - The source object will be moved to the target location
  - `link` - A reference or shortcut to the source object will be created
  - `execute` - A function supported by the drop target will be executed
	  - Example: When a draggable item is dropped onto a valid target, the target's `onDrop` handler function runs to process the dropped data
    ```javascript
    dropTarget.addEventListener('drop', (e) => {
      e.preventDefault();
      const data = e.dataTransfer.getData('text');
      handleDroppedItem(data);
    });
    ```
  - `popup` - A popup menu or dialog will appear
  - `none` - No operation can be performed (default)
- `aria-grabbed` - Indicates if an element has been grabbed for dragging
  - `true` - Element has been selected for dragging
  - `false` - Element is not grabbed but is available for dragging
  - `undefined` - Element cannot be grabbed (default)

[Unverified: These properties may have limited support or may be deprecated in favor of native drag-and-drop APIs.]

**Relationship and Grouping Properties**

`aria-posinset` - Defines an element's position within a set

Example:
```html
<ul role="list">
  <li role="listitem" aria-posinset="1" aria-setsize="5">First item</li>
  <li role="listitem" aria-posinset="2" aria-setsize="5">Second item</li>
  <li role="listitem" aria-posinset="3" aria-setsize="5">Third item</li>
</ul>
```

`aria-setsize` - Defines the total number of items in a set

Example:
```html
<div role="tablist">
  <button role="tab" aria-posinset="1" aria-setsize="4">Tab 1</button>
  <button role="tab" aria-posinset="2" aria-setsize="4">Tab 2</button>
  <button role="tab" aria-posinset="3" aria-setsize="4">Tab 3</button>
  <button role="tab" aria-posinset="4" aria-setsize="4">Tab 4</button>
</div>
```

`aria-level` - Defines the hierarchical level of an element within a structure

Example:
```html
<div role="tree">
  <div role="treeitem" aria-level="1" aria-posinset="1" aria-setsize="3">
    Parent Item 1
  </div>
  <div role="treeitem" aria-level="2" aria-posinset="1" aria-setsize="2">
    Child Item 1.1
  </div>
  <div role="treeitem" aria-level="2" aria-posinset="2" aria-setsize="2">
    Child Item 1.2
  </div>
  <div role="treeitem" aria-level="1" aria-posinset="2" aria-setsize="3">
    Parent Item 2
  </div>
  <div role="treeitem" aria-level="2" aria-posinset="1" aria-setsize="1">
    Child Item 2.1
  </div>
  <div role="treeitem" aria-level="1" aria-posinset="3" aria-setsize="3">
    Parent Item 3
  </div>
</div>
```

*Complete Example: Hierarchical Navigation Menu*

```html
<nav aria-label="Main navigation">
  <ul role="tree">
    <!-- Top level item 1 -->
    <li role="treeitem" 
        aria-level="1" 
        aria-posinset="1" 
        aria-setsize="3"
        aria-expanded="true">
      <a href="/products">Products</a>
      <ul role="group">
        <li role="treeitem" 
            aria-level="2" 
            aria-posinset="1" 
            aria-setsize="3">
          <a href="/products/electronics">Electronics</a>
        </li>
        <li role="treeitem" 
            aria-level="2" 
            aria-posinset="2" 
            aria-setsize="3"
            aria-expanded="true">
          <a href="/products/clothing">Clothing</a>
          <ul role="group">
            <li role="treeitem" 
                aria-level="3" 
                aria-posinset="1" 
                aria-setsize="2">
              <a href="/products/clothing/mens">Men's</a>
            </li>
            <li role="treeitem" 
                aria-level="3" 
                aria-posinset="2" 
                aria-setsize="2">
              <a href="/products/clothing/womens">Women's</a>
            </li>
          </ul>
        </li>
        <li role="treeitem" 
            aria-level="2" 
            aria-posinset="3" 
            aria-setsize="3">
          <a href="/products/home">Home & Garden</a>
        </li>
      </ul>
    </li>
    
    <!-- Top level item 2 -->
    <li role="treeitem" 
        aria-level="1" 
        aria-posinset="2" 
        aria-setsize="3">
      <a href="/about">About Us</a>
    </li>
    
    <!-- Top level item 3 -->
    <li role="treeitem" 
        aria-level="1" 
        aria-posinset="3" 
        aria-setsize="3">
      <a href="/contact">Contact</a>
    </li>
  </ul>
</nav>
```

**Other Properties**

- `aria-haspopup` - Indicates the element triggers a popup
  - true
  - false
  - menu
  - listbox
  - tree
  - grid
  - dialog
- `aria-keyshortcuts` - Describes keyboard shortcuts
  - "Alt+S"
  - "Ctrl+Enter"
  - "Command+K"
- `aria-roledescription` - Provides a custom role description
  - "slide"
  - "carousel item"
  - "navigation menu"
- `aria-details` - References detailed information about the element
  - "element-id"
  - "details-section"
  - "info-panel"
- `aria-errormessage` - References an error message element
  - "error-message-id"
  - "validation-error"
  - "field-error"

```html
<button aria-haspopup="menu" aria-keyshortcuts="Alt+F">File</button>

<input type="email" aria-invalid="true" aria-errormessage="email-error">
<span id="email-error" role="alert">Please enter a valid email</span>
```

### Properties vs. States

**Properties** typically remain stable:
- `aria-label`, `aria-labelledby`
- `aria-required`
- `aria-valuemin`, `aria-valuemax`

**States** change based on user interaction or application state:
- `aria-checked`
- `aria-expanded`
- `aria-hidden`
- `aria-selected`
- `aria-pressed`

[Inference: This distinction helps developers understand which attributes should be static versus dynamic, though the boundary isn't always strict.]

### Best Practices

**Prefer Native HTML When Possible**
Native HTML elements often provide built-in accessibility without ARIA:
```html
<!-- Native HTML (preferred) -->
<label for="username">Username</label>
<input id="username" required>

<!-- ARIA equivalent (when native HTML isn't sufficient) -->
<span id="label">Username</span>
<div role="textbox" aria-labelledby="label" aria-required="true"></div>
```

**Don't Duplicate Information**
Avoid redundancy when native semantics already exist:
```html
<!-- Redundant - button already has implicit role -->
<button role="button">Click</button>

<!-- Correct -->
<button>Click</button>
```

**Use Proper ID References**
When using `aria-labelledby`, `aria-describedby`, or similar properties, ensure referenced IDs exist:
```html
<button aria-describedby="tooltip-1">Help</button>
<div id="tooltip-1" role="tooltip">Click for assistance</div>
```

**Test with Assistive Technologies**
[Inference: Implementation quality varies across browsers and screen readers.] Testing with actual assistive technologies provides the most reliable validation.

### Common Patterns

**Form Validation**
```html
<label for="email">Email</label>
<input id="email" type="email" aria-required="true" 
       aria-invalid="false" aria-describedby="email-hint">
<span id="email-hint">We'll never share your email</span>
```

**Modal Dialog**
```html
<div role="dialog" aria-labelledby="dialog-title" aria-describedby="dialog-desc">
  <h2 id="dialog-title">Confirm Delete</h2>
  <p id="dialog-desc">This action cannot be undone</p>
  <button>Delete</button>
  <button>Cancel</button>
</div>
```

**Progress Indicator**
```html
<div role="progressbar" aria-valuemin="0" aria-valuemax="100" 
     aria-valuenow="65" aria-label="Upload progress">
  65%
</div>
```

### Resources

For authoritative specifications, consult the W3C WAI-ARIA documentation at w3.org/TR/wai-aria/ which provides comprehensive details on all ARIA properties and their usage.

---

## ARIA States

ARIA states are attributes that describe the current condition of elements and are expected to change during the element's lifecycle, often in response to user interaction. Unlike ARIA properties (which are relatively stable), states are dynamic and reflect real-time status.

### What Are ARIA States?

ARIA states communicate the current condition or status of an element to assistive technologies. They update as users interact with the interface, providing crucial feedback about changes in the application state.

### Key Difference: States vs. Properties

**States** change frequently during interaction:
- `aria-checked`, `aria-expanded`, `aria-pressed`

**Properties** remain relatively stable:
- `aria-label`, `aria-required`, `aria-labelledby`

[Inference: This distinction helps developers understand which attributes need dynamic updates via JavaScript.]

### Common ARIA States

**Selection and Checked States**

- `aria-checked` - Indicates checkbox or radio button state (true, false, mixed)
- `aria-selected` - Indicates selection state in lists, tabs, or grids (true, false)
- `aria-pressed` - Indicates toggle button state (true, false, mixed)

The `mixed` value indicates an indeterminate or partially selected state.

For `aria-checked`:
- Used when a checkbox represents a group of sub-options where some (but not all) are checked
- Example: A "Select All" checkbox when only some items in a list are selected

For `aria-pressed`:
- Used when a toggle button controls multiple items that have different states
- Example: A "Bold" button in a text editor when the selection contains both bold and non-bold text

The `mixed` value communicates to assistive technologies that the element is in a state between fully on and fully off.

```html
<!-- Checkbox with mixed state (indeterminate) -->
<div role="checkbox" aria-checked="mixed">Select All</div>

<!-- Tab interface -->
<button role="tab" aria-selected="true">Tab 1</button>
<button role="tab" aria-selected="false">Tab 2</button>

<!-- Toggle button -->
<button aria-pressed="false">Mute</button>
```

**Expansion and Visibility States**

- `aria-expanded` - Indicates if a collapsible element is expanded (true, false, undefined)
- `aria-hidden` - Indicates if an element is visible to assistive technologies (true, false)

```html
<!-- Accordion -->
<button aria-expanded="false" aria-controls="panel-1">
  Section 1
</button>
<div id="panel-1" hidden>
  Panel content
</div>

<!-- Hidden decorative element -->
<span aria-hidden="true" class="icon">‚òÖ</span>
```

**Interaction States**

- `aria-disabled` - Indicates an element is disabled but still perceivable (true, false)
- `aria-busy` - Indicates content is loading or updating (true, false)
- `aria-grabbed` - Indicates drag-and-drop grab state (true, false, undefined)
- `aria-current` - Indicates the current item in a set (page, step, location, date, time, true, false)

```html
<!-- Disabled button -->
<button aria-disabled="true">Submit</button>

<!-- Loading content -->
<div aria-busy="true">
  Loading data...
</div>

<!-- Current page in navigation -->
<a href="/about" aria-current="page">About</a>

<!-- Current step in wizard -->
<div role="tab" aria-current="step">Step 2</div>
```

**Validation States**

- `aria-invalid` - Indicates invalid input (true, false, grammar, spelling)

```html
<!-- Invalid email field -->
<input type="email" aria-invalid="true" aria-describedby="error-msg">
<span id="error-msg" role="alert">Please enter a valid email</span>

<!-- Valid field after correction -->
<input type="email" aria-invalid="false" value="user@example.com">
```

### Detailed State Descriptions

**aria-checked**

Used with checkboxes, radio buttons, and similar widgets:
- `true` - Element is checked
- `false` - Element is not checked
- `mixed` - Represents indeterminate state (like "select all" when some items are selected)

```html
<div role="checkbox" aria-checked="false" tabindex="0">
  I agree to terms
</div>

<!-- Parent checkbox showing mixed state -->
<div role="checkbox" aria-checked="mixed" tabindex="0">
  Select All
</div>
```

**aria-expanded**

Essential for disclosures, accordions, menus, and comboboxes:
- `true` - Element is expanded, content visible
- `false` - Element is collapsed, content hidden
- `undefined` (or omitted) - Element is not expandable

```html
<!-- Collapsed dropdown -->
<button aria-expanded="false" aria-controls="menu">
  Options
</button>
<ul id="menu" hidden>
  <li>Option 1</li>
  <li>Option 2</li>
</ul>
```

**aria-hidden**

Controls visibility to assistive technologies:
- `true` - Hidden from assistive technologies (but may still be visible on screen)
- `false` - Explicitly not hidden (rarely needed, as this is the default)

```html
<!-- Decorative icon hidden from screen readers -->
<button>
  <span aria-hidden="true">üîç</span>
  Search
</button>

<!-- Modal overlay hiding background content -->
<div aria-hidden="true">
  Background content that shouldn't be read while modal is open
</div>
```

**Important**: When `aria-hidden="true"` is set on an element, all descendant elements are also hidden from assistive technologies.

**aria-selected**

Used in listboxes, grids, trees, and tabs:
- `true` - Element is selected
- `false` - Element is not selected
- `undefined` (or omitted) - Element is not selectable

```html
<div role="listbox">
  <div role="option" aria-selected="true">Apple</div>
  <div role="option" aria-selected="false">Banana</div>
  <div role="option" aria-selected="false">Cherry</div>
</div>
```

**aria-pressed**

Specifically for toggle buttons:
- `true` - Button is pressed/active
- `false` - Button is not pressed
- `mixed` - Mixed state (for buttons controlling multiple elements)

```html
<!-- Mute button that toggles -->
<button aria-pressed="false" aria-label="Mute">
  üîä
</button>
```

**aria-current**

Indicates the current item within a container or set:
- `page` - Current page in a set of pages
- `step` - Current step in a process
- `location` - Current location in a navigation
- `date` - Current date in a calendar
- `time` - Current time in a schedule
- `true` - Generic current item
- `false` - Not current (or omit the attribute)

```html
<!-- Breadcrumb navigation -->
<nav aria-label="Breadcrumb">
  <a href="/">Home</a>
  <a href="/products">Products</a>
  <a href="/products/shoes" aria-current="page">Shoes</a>
</nav>

<!-- Step indicator -->
<div role="tablist">
  <div role="tab" aria-current="step">Payment</div>
  <div role="tab">Confirmation</div>
</div>
```

**aria-disabled**

Indicates disabled state while keeping element perceivable:
- `true` - Element is disabled
- `false` - Element is enabled (or omit the attribute)

```html
<!-- Disabled button that remains in tab order -->
<button aria-disabled="true" tabindex="0">
  Submit (complete form first)
</button>
```

[Inference: Unlike the `disabled` attribute, `aria-disabled` doesn't automatically prevent keyboard focus, so developers must handle this separately.]

**aria-busy**

Indicates loading or updating content:
- `true` - Content is loading/updating
- `false` - Content is ready (or omit the attribute)

```html
<div role="region" aria-busy="true" aria-live="polite">
  <div class="spinner"></div>
  Loading results...
</div>
```

### Updating States with JavaScript

States must be updated programmatically to reflect changes:

```javascript
// Toggle expansion
const button = document.querySelector('[aria-expanded]');
button.addEventListener('click', () => {
  const isExpanded = button.getAttribute('aria-expanded') === 'true';
  button.setAttribute('aria-expanded', !isExpanded);
});

// Update checked state
const checkbox = document.querySelector('[role="checkbox"]');
checkbox.addEventListener('click', () => {
  const isChecked = checkbox.getAttribute('aria-checked') === 'true';
  checkbox.setAttribute('aria-checked', !isChecked);
});

// Show loading state
async function loadData() {
  const container = document.getElementById('data-container');
  container.setAttribute('aria-busy', 'true');
  
  const data = await fetch('/api/data');
  container.innerHTML = await data.text();
  
  container.setAttribute('aria-busy', 'false');
}

// Update selection
const options = document.querySelectorAll('[role="option"]');
options.forEach(option => {
  option.addEventListener('click', () => {
    options.forEach(opt => opt.setAttribute('aria-selected', 'false'));
    option.setAttribute('aria-selected', 'true');
  });
});
```

### Common Patterns and Examples

**Accordion Component**

```html
<div class="accordion">
  <button aria-expanded="false" aria-controls="panel-1">
    Section 1
  </button>
  <div id="panel-1" hidden>
    Content for section 1
  </div>
  
  <button aria-expanded="false" aria-controls="panel-2">
    Section 2
  </button>
  <div id="panel-2" hidden>
    Content for section 2
  </div>
</div>
```

**Tab Interface**

```html
<div role="tablist">
  <button role="tab" aria-selected="true" aria-controls="tab-panel-1">
    Overview
  </button>
  <button role="tab" aria-selected="false" aria-controls="tab-panel-2">
    Details
  </button>
</div>

<div role="tabpanel" id="tab-panel-1" aria-hidden="false">
  Overview content
</div>
<div role="tabpanel" id="tab-panel-2" aria-hidden="true" hidden>
  Details content
</div>
```

**Custom Checkbox**

```html
<div role="checkbox" 
     aria-checked="false" 
     aria-labelledby="checkbox-label"
     tabindex="0">
  <span id="checkbox-label">Accept terms and conditions</span>
</div>
```

**Form with Validation**

```html
<form>
  <label for="username">Username</label>
  <input id="username" 
         type="text" 
         aria-required="true"
         aria-invalid="false">
  
  <span id="username-error" role="alert" aria-hidden="true"></span>
  
  <button type="submit" aria-disabled="false">Submit</button>
</form>

<script>
// Validation example
const input = document.getElementById('username');
const error = document.getElementById('username-error');

input.addEventListener('blur', () => {
  if (input.value.length < 3) {
    input.setAttribute('aria-invalid', 'true');
    error.textContent = 'Username must be at least 3 characters';
    error.setAttribute('aria-hidden', 'false');
  } else {
    input.setAttribute('aria-invalid', 'false');
    error.setAttribute('aria-hidden', 'true');
  }
});
</script>
```

**Loading Content Region**

```html
<div role="region" 
     aria-label="Search results" 
     aria-busy="false"
     aria-live="polite">
  <!-- Results will be loaded here -->
</div>
```

### Best Practices

**Keep States Synchronized**

Ensure ARIA states match visual presentation:
```javascript
// When hiding content, update both hidden attribute and aria-expanded
function togglePanel(button, panel) {
  const isExpanded = button.getAttribute('aria-expanded') === 'true';
  button.setAttribute('aria-expanded', !isExpanded);
  panel.hidden = isExpanded;
}
```

**Use Semantic HTML First**

Native elements often provide built-in state management:
```html
<!-- Native checkbox (preferred) -->
<input type="checkbox" checked>

<!-- Custom checkbox (when necessary) -->
<div role="checkbox" aria-checked="true"></div>
```

**Manage Focus Appropriately**

When state changes affect focus or keyboard navigation:
```javascript
// When disabling a button, handle focus management
button.setAttribute('aria-disabled', 'true');
button.setAttribute('tabindex', '-1'); // Remove from tab order if needed
```

**Provide Appropriate Feedback**

Combine states with live regions for dynamic updates:
```html
<button aria-pressed="false">Notifications</button>
<div role="status" aria-live="polite" aria-atomic="true">
  Notifications enabled
</div>
```

**Test State Changes**

[Inference: Different screen readers may announce state changes differently.] Testing with multiple assistive technologies helps ensure consistent user experience.

### Common Mistakes to Avoid

**Don't use aria-hidden to hide interactive content**
```html
<!-- Bad - button is hidden but still focusable -->
<button aria-hidden="true">Click me</button>

<!-- Good - use hidden attribute or CSS display: none -->
<button hidden>Click me</button>
```

**Don't forget to update states**
```javascript
// Bad - visual change without ARIA update
button.classList.toggle('pressed');

// Good - update both visual and ARIA state
button.classList.toggle('pressed');
button.setAttribute('aria-pressed', 
  button.classList.contains('pressed'));
```

**Don't set contradictory states**
```html
<!-- Bad - button can't be both disabled and pressed -->
<button aria-disabled="true" aria-pressed="true">Toggle</button>

<!-- Good - disabled buttons shouldn't have pressed state -->
<button aria-disabled="true">Toggle</button>
```

### Resources

For complete specifications and detailed guidance, consult the W3C WAI-ARIA documentation at w3.org/TR/wai-aria/ and the ARIA Authoring Practices Guide at w3.org/WAI/ARIA/apg/ for implementation patterns.

---

# ARIA Roles



---

# ARIA Properties and States




---
